/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./ethers-5.1.esm.min.js":
/*!*******************************!*\
  !*** ./ethers-5.1.esm.min.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContract": () => (/* binding */ BaseContract),
/* harmony export */   "BigNumber": () => (/* binding */ BigNumber),
/* harmony export */   "Contract": () => (/* binding */ Contract),
/* harmony export */   "ContractFactory": () => (/* binding */ ContractFactory),
/* harmony export */   "FixedNumber": () => (/* binding */ FixedNumber),
/* harmony export */   "Signer": () => (/* binding */ Signer),
/* harmony export */   "VoidSigner": () => (/* binding */ VoidSigner),
/* harmony export */   "Wallet": () => (/* binding */ Wallet),
/* harmony export */   "Wordlist": () => (/* binding */ Wordlist),
/* harmony export */   "constants": () => (/* binding */ index$1),
/* harmony export */   "errors": () => (/* binding */ ErrorCode),
/* harmony export */   "ethers": () => (/* binding */ ethers),
/* harmony export */   "getDefaultProvider": () => (/* binding */ getDefaultProvider),
/* harmony export */   "logger": () => (/* binding */ logger$H),
/* harmony export */   "providers": () => (/* binding */ index$3),
/* harmony export */   "utils": () => (/* binding */ utils$1),
/* harmony export */   "version": () => (/* binding */ version$o),
/* harmony export */   "wordlists": () => (/* binding */ wordlists)
/* harmony export */ });
var commonjsGlobal=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof __webpack_require__.g!=="undefined"?__webpack_require__.g:typeof self!=="undefined"?self:{};function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function createCommonjsModule(fn,basedir,module){return module={path:basedir,exports:{},require:function(path,base){return commonjsRequire(path,base===undefined||base===null?module.path:base)}},fn(module,module.exports),module.exports}function getDefaultExportFromNamespaceIfPresent(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")?n["default"]:n}function getDefaultExportFromNamespaceIfNotNamed(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")&&Object.keys(n).length===1?n["default"]:n}function getAugmentedNamespace(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:true});Object.keys(n).forEach(function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:true,get:function(){return n[k]}})});return a}function commonjsRequire(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var bn=createCommonjsModule(function(module){(function(module,exports){"use strict";function assert(val,msg){if(!val)throw new Error(msg||"Assertion failed")}function inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}function BN(number,base,endian){if(BN.isBN(number)){return number}this.negative=0;this.words=null;this.length=0;this.red=null;if(number!==null){if(base==="le"||base==="be"){endian=base;base=10}this._init(number||0,base||10,endian||"be")}}if(typeof module==="object"){module.exports=BN}else{exports.BN=BN}BN.BN=BN;BN.wordSize=26;var Buffer;try{if(typeof window!=="undefined"&&typeof window.Buffer!=="undefined"){Buffer=window.Buffer}else{Buffer=null.Buffer}}catch(e){}BN.isBN=function isBN(num){if(num instanceof BN){return true}return num!==null&&typeof num==="object"&&num.constructor.wordSize===BN.wordSize&&Array.isArray(num.words)};BN.max=function max(left,right){if(left.cmp(right)>0)return left;return right};BN.min=function min(left,right){if(left.cmp(right)<0)return left;return right};BN.prototype._init=function init(number,base,endian){if(typeof number==="number"){return this._initNumber(number,base,endian)}if(typeof number==="object"){return this._initArray(number,base,endian)}if(base==="hex"){base=16}assert(base===(base|0)&&base>=2&&base<=36);number=number.toString().replace(/\s+/g,"");var start=0;if(number[0]==="-"){start++;this.negative=1}if(start<number.length){if(base===16){this._parseHex(number,start,endian)}else{this._parseBase(number,base,start);if(endian==="le"){this._initArray(this.toArray(),base,endian)}}}};BN.prototype._initNumber=function _initNumber(number,base,endian){if(number<0){this.negative=1;number=-number}if(number<67108864){this.words=[number&67108863];this.length=1}else if(number<4503599627370496){this.words=[number&67108863,number/67108864&67108863];this.length=2}else{assert(number<9007199254740992);this.words=[number&67108863,number/67108864&67108863,1];this.length=3}if(endian!=="le")return;this._initArray(this.toArray(),base,endian)};BN.prototype._initArray=function _initArray(number,base,endian){assert(typeof number.length==="number");if(number.length<=0){this.words=[0];this.length=1;return this}this.length=Math.ceil(number.length/3);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0}var j,w;var off=0;if(endian==="be"){for(i=number.length-1,j=0;i>=0;i-=3){w=number[i]|number[i-1]<<8|number[i-2]<<16;this.words[j]|=w<<off&67108863;this.words[j+1]=w>>>26-off&67108863;off+=24;if(off>=26){off-=26;j++}}}else if(endian==="le"){for(i=0,j=0;i<number.length;i+=3){w=number[i]|number[i+1]<<8|number[i+2]<<16;this.words[j]|=w<<off&67108863;this.words[j+1]=w>>>26-off&67108863;off+=24;if(off>=26){off-=26;j++}}}return this.strip()};function parseHex4Bits(string,index){var c=string.charCodeAt(index);if(c>=65&&c<=70){return c-55}else if(c>=97&&c<=102){return c-87}else{return c-48&15}}function parseHexByte(string,lowerBound,index){var r=parseHex4Bits(string,index);if(index-1>=lowerBound){r|=parseHex4Bits(string,index-1)<<4}return r}BN.prototype._parseHex=function _parseHex(number,start,endian){this.length=Math.ceil((number.length-start)/6);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0}var off=0;var j=0;var w;if(endian==="be"){for(i=number.length-1;i>=start;i-=2){w=parseHexByte(number,start,i)<<off;this.words[j]|=w&67108863;if(off>=18){off-=18;j+=1;this.words[j]|=w>>>26}else{off+=8}}}else{var parseLength=number.length-start;for(i=parseLength%2===0?start+1:start;i<number.length;i+=2){w=parseHexByte(number,start,i)<<off;this.words[j]|=w&67108863;if(off>=18){off-=18;j+=1;this.words[j]|=w>>>26}else{off+=8}}}this.strip()};function parseBase(str,start,end,mul){var r=0;var len=Math.min(str.length,end);for(var i=start;i<len;i++){var c=str.charCodeAt(i)-48;r*=mul;if(c>=49){r+=c-49+10}else if(c>=17){r+=c-17+10}else{r+=c}}return r}BN.prototype._parseBase=function _parseBase(number,base,start){this.words=[0];this.length=1;for(var limbLen=0,limbPow=1;limbPow<=67108863;limbPow*=base){limbLen++}limbLen--;limbPow=limbPow/base|0;var total=number.length-start;var mod=total%limbLen;var end=Math.min(total,total-mod)+start;var word=0;for(var i=start;i<end;i+=limbLen){word=parseBase(number,i,i+limbLen,base);this.imuln(limbPow);if(this.words[0]+word<67108864){this.words[0]+=word}else{this._iaddn(word)}}if(mod!==0){var pow=1;word=parseBase(number,i,number.length,base);for(i=0;i<mod;i++){pow*=base}this.imuln(pow);if(this.words[0]+word<67108864){this.words[0]+=word}else{this._iaddn(word)}}this.strip()};BN.prototype.copy=function copy(dest){dest.words=new Array(this.length);for(var i=0;i<this.length;i++){dest.words[i]=this.words[i]}dest.length=this.length;dest.negative=this.negative;dest.red=this.red};BN.prototype.clone=function clone(){var r=new BN(null);this.copy(r);return r};BN.prototype._expand=function _expand(size){while(this.length<size){this.words[this.length++]=0}return this};BN.prototype.strip=function strip(){while(this.length>1&&this.words[this.length-1]===0){this.length--}return this._normSign()};BN.prototype._normSign=function _normSign(){if(this.length===1&&this.words[0]===0){this.negative=0}return this};BN.prototype.inspect=function inspect(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var zeros=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"];var groupSizes=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5];var groupBases=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];BN.prototype.toString=function toString(base,padding){base=base||10;padding=padding|0||1;var out;if(base===16||base==="hex"){out="";var off=0;var carry=0;for(var i=0;i<this.length;i++){var w=this.words[i];var word=((w<<off|carry)&16777215).toString(16);carry=w>>>24-off&16777215;if(carry!==0||i!==this.length-1){out=zeros[6-word.length]+word+out}else{out=word+out}off+=2;if(off>=26){off-=26;i--}}if(carry!==0){out=carry.toString(16)+out}while(out.length%padding!==0){out="0"+out}if(this.negative!==0){out="-"+out}return out}if(base===(base|0)&&base>=2&&base<=36){var groupSize=groupSizes[base];var groupBase=groupBases[base];out="";var c=this.clone();c.negative=0;while(!c.isZero()){var r=c.modn(groupBase).toString(base);c=c.idivn(groupBase);if(!c.isZero()){out=zeros[groupSize-r.length]+r+out}else{out=r+out}}if(this.isZero()){out="0"+out}while(out.length%padding!==0){out="0"+out}if(this.negative!==0){out="-"+out}return out}assert(false,"Base should be between 2 and 36")};BN.prototype.toNumber=function toNumber(){var ret=this.words[0];if(this.length===2){ret+=this.words[1]*67108864}else if(this.length===3&&this.words[2]===1){ret+=4503599627370496+this.words[1]*67108864}else if(this.length>2){assert(false,"Number can only safely store up to 53 bits")}return this.negative!==0?-ret:ret};BN.prototype.toJSON=function toJSON(){return this.toString(16)};BN.prototype.toBuffer=function toBuffer(endian,length){assert(typeof Buffer!=="undefined");return this.toArrayLike(Buffer,endian,length)};BN.prototype.toArray=function toArray(endian,length){return this.toArrayLike(Array,endian,length)};BN.prototype.toArrayLike=function toArrayLike(ArrayType,endian,length){var byteLength=this.byteLength();var reqLength=length||Math.max(1,byteLength);assert(byteLength<=reqLength,"byte array longer than desired length");assert(reqLength>0,"Requested array length <= 0");this.strip();var littleEndian=endian==="le";var res=new ArrayType(reqLength);var b,i;var q=this.clone();if(!littleEndian){for(i=0;i<reqLength-byteLength;i++){res[i]=0}for(i=0;!q.isZero();i++){b=q.andln(255);q.iushrn(8);res[reqLength-i-1]=b}}else{for(i=0;!q.isZero();i++){b=q.andln(255);q.iushrn(8);res[i]=b}for(;i<reqLength;i++){res[i]=0}}return res};if(Math.clz32){BN.prototype._countBits=function _countBits(w){return 32-Math.clz32(w)}}else{BN.prototype._countBits=function _countBits(w){var t=w;var r=0;if(t>=4096){r+=13;t>>>=13}if(t>=64){r+=7;t>>>=7}if(t>=8){r+=4;t>>>=4}if(t>=2){r+=2;t>>>=2}return r+t}}BN.prototype._zeroBits=function _zeroBits(w){if(w===0)return 26;var t=w;var r=0;if((t&8191)===0){r+=13;t>>>=13}if((t&127)===0){r+=7;t>>>=7}if((t&15)===0){r+=4;t>>>=4}if((t&3)===0){r+=2;t>>>=2}if((t&1)===0){r++}return r};BN.prototype.bitLength=function bitLength(){var w=this.words[this.length-1];var hi=this._countBits(w);return(this.length-1)*26+hi};function toBitArray(num){var w=new Array(num.bitLength());for(var bit=0;bit<w.length;bit++){var off=bit/26|0;var wbit=bit%26;w[bit]=(num.words[off]&1<<wbit)>>>wbit}return w}BN.prototype.zeroBits=function zeroBits(){if(this.isZero())return 0;var r=0;for(var i=0;i<this.length;i++){var b=this._zeroBits(this.words[i]);r+=b;if(b!==26)break}return r};BN.prototype.byteLength=function byteLength(){return Math.ceil(this.bitLength()/8)};BN.prototype.toTwos=function toTwos(width){if(this.negative!==0){return this.abs().inotn(width).iaddn(1)}return this.clone()};BN.prototype.fromTwos=function fromTwos(width){if(this.testn(width-1)){return this.notn(width).iaddn(1).ineg()}return this.clone()};BN.prototype.isNeg=function isNeg(){return this.negative!==0};BN.prototype.neg=function neg(){return this.clone().ineg()};BN.prototype.ineg=function ineg(){if(!this.isZero()){this.negative^=1}return this};BN.prototype.iuor=function iuor(num){while(this.length<num.length){this.words[this.length++]=0}for(var i=0;i<num.length;i++){this.words[i]=this.words[i]|num.words[i]}return this.strip()};BN.prototype.ior=function ior(num){assert((this.negative|num.negative)===0);return this.iuor(num)};BN.prototype.or=function or(num){if(this.length>num.length)return this.clone().ior(num);return num.clone().ior(this)};BN.prototype.uor=function uor(num){if(this.length>num.length)return this.clone().iuor(num);return num.clone().iuor(this)};BN.prototype.iuand=function iuand(num){var b;if(this.length>num.length){b=num}else{b=this}for(var i=0;i<b.length;i++){this.words[i]=this.words[i]&num.words[i]}this.length=b.length;return this.strip()};BN.prototype.iand=function iand(num){assert((this.negative|num.negative)===0);return this.iuand(num)};BN.prototype.and=function and(num){if(this.length>num.length)return this.clone().iand(num);return num.clone().iand(this)};BN.prototype.uand=function uand(num){if(this.length>num.length)return this.clone().iuand(num);return num.clone().iuand(this)};BN.prototype.iuxor=function iuxor(num){var a;var b;if(this.length>num.length){a=this;b=num}else{a=num;b=this}for(var i=0;i<b.length;i++){this.words[i]=a.words[i]^b.words[i]}if(this!==a){for(;i<a.length;i++){this.words[i]=a.words[i]}}this.length=a.length;return this.strip()};BN.prototype.ixor=function ixor(num){assert((this.negative|num.negative)===0);return this.iuxor(num)};BN.prototype.xor=function xor(num){if(this.length>num.length)return this.clone().ixor(num);return num.clone().ixor(this)};BN.prototype.uxor=function uxor(num){if(this.length>num.length)return this.clone().iuxor(num);return num.clone().iuxor(this)};BN.prototype.inotn=function inotn(width){assert(typeof width==="number"&&width>=0);var bytesNeeded=Math.ceil(width/26)|0;var bitsLeft=width%26;this._expand(bytesNeeded);if(bitsLeft>0){bytesNeeded--}for(var i=0;i<bytesNeeded;i++){this.words[i]=~this.words[i]&67108863}if(bitsLeft>0){this.words[i]=~this.words[i]&67108863>>26-bitsLeft}return this.strip()};BN.prototype.notn=function notn(width){return this.clone().inotn(width)};BN.prototype.setn=function setn(bit,val){assert(typeof bit==="number"&&bit>=0);var off=bit/26|0;var wbit=bit%26;this._expand(off+1);if(val){this.words[off]=this.words[off]|1<<wbit}else{this.words[off]=this.words[off]&~(1<<wbit)}return this.strip()};BN.prototype.iadd=function iadd(num){var r;if(this.negative!==0&&num.negative===0){this.negative=0;r=this.isub(num);this.negative^=1;return this._normSign()}else if(this.negative===0&&num.negative!==0){num.negative=0;r=this.isub(num);num.negative=1;return r._normSign()}var a,b;if(this.length>num.length){a=this;b=num}else{a=num;b=this}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)+(b.words[i]|0)+carry;this.words[i]=r&67108863;carry=r>>>26}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;this.words[i]=r&67108863;carry=r>>>26}this.length=a.length;if(carry!==0){this.words[this.length]=carry;this.length++}else if(a!==this){for(;i<a.length;i++){this.words[i]=a.words[i]}}return this};BN.prototype.add=function add(num){var res;if(num.negative!==0&&this.negative===0){num.negative=0;res=this.sub(num);num.negative^=1;return res}else if(num.negative===0&&this.negative!==0){this.negative=0;res=num.sub(this);this.negative=1;return res}if(this.length>num.length)return this.clone().iadd(num);return num.clone().iadd(this)};BN.prototype.isub=function isub(num){if(num.negative!==0){num.negative=0;var r=this.iadd(num);num.negative=1;return r._normSign()}else if(this.negative!==0){this.negative=0;this.iadd(num);this.negative=1;return this._normSign()}var cmp=this.cmp(num);if(cmp===0){this.negative=0;this.length=1;this.words[0]=0;return this}var a,b;if(cmp>0){a=this;b=num}else{a=num;b=this}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)-(b.words[i]|0)+carry;carry=r>>26;this.words[i]=r&67108863}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;carry=r>>26;this.words[i]=r&67108863}if(carry===0&&i<a.length&&a!==this){for(;i<a.length;i++){this.words[i]=a.words[i]}}this.length=Math.max(this.length,i);if(a!==this){this.negative=1}return this.strip()};BN.prototype.sub=function sub(num){return this.clone().isub(num)};function smallMulTo(self,num,out){out.negative=num.negative^self.negative;var len=self.length+num.length|0;out.length=len;len=len-1|0;var a=self.words[0]|0;var b=num.words[0]|0;var r=a*b;var lo=r&67108863;var carry=r/67108864|0;out.words[0]=lo;for(var k=1;k<len;k++){var ncarry=carry>>>26;var rword=carry&67108863;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j|0;a=self.words[i]|0;b=num.words[j]|0;r=a*b+rword;ncarry+=r/67108864|0;rword=r&67108863}out.words[k]=rword|0;carry=ncarry|0}if(carry!==0){out.words[k]=carry|0}else{out.length--}return out.strip()}var comb10MulTo=function comb10MulTo(self,num,out){var a=self.words;var b=num.words;var o=out.words;var c=0;var lo;var mid;var hi;var a0=a[0]|0;var al0=a0&8191;var ah0=a0>>>13;var a1=a[1]|0;var al1=a1&8191;var ah1=a1>>>13;var a2=a[2]|0;var al2=a2&8191;var ah2=a2>>>13;var a3=a[3]|0;var al3=a3&8191;var ah3=a3>>>13;var a4=a[4]|0;var al4=a4&8191;var ah4=a4>>>13;var a5=a[5]|0;var al5=a5&8191;var ah5=a5>>>13;var a6=a[6]|0;var al6=a6&8191;var ah6=a6>>>13;var a7=a[7]|0;var al7=a7&8191;var ah7=a7>>>13;var a8=a[8]|0;var al8=a8&8191;var ah8=a8>>>13;var a9=a[9]|0;var al9=a9&8191;var ah9=a9>>>13;var b0=b[0]|0;var bl0=b0&8191;var bh0=b0>>>13;var b1=b[1]|0;var bl1=b1&8191;var bh1=b1>>>13;var b2=b[2]|0;var bl2=b2&8191;var bh2=b2>>>13;var b3=b[3]|0;var bl3=b3&8191;var bh3=b3>>>13;var b4=b[4]|0;var bl4=b4&8191;var bh4=b4>>>13;var b5=b[5]|0;var bl5=b5&8191;var bh5=b5>>>13;var b6=b[6]|0;var bl6=b6&8191;var bh6=b6>>>13;var b7=b[7]|0;var bl7=b7&8191;var bh7=b7>>>13;var b8=b[8]|0;var bl8=b8&8191;var bh8=b8>>>13;var b9=b[9]|0;var bl9=b9&8191;var bh9=b9>>>13;out.negative=self.negative^num.negative;out.length=19;lo=Math.imul(al0,bl0);mid=Math.imul(al0,bh0);mid=mid+Math.imul(ah0,bl0)|0;hi=Math.imul(ah0,bh0);var w0=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w0>>>26)|0;w0&=67108863;lo=Math.imul(al1,bl0);mid=Math.imul(al1,bh0);mid=mid+Math.imul(ah1,bl0)|0;hi=Math.imul(ah1,bh0);lo=lo+Math.imul(al0,bl1)|0;mid=mid+Math.imul(al0,bh1)|0;mid=mid+Math.imul(ah0,bl1)|0;hi=hi+Math.imul(ah0,bh1)|0;var w1=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w1>>>26)|0;w1&=67108863;lo=Math.imul(al2,bl0);mid=Math.imul(al2,bh0);mid=mid+Math.imul(ah2,bl0)|0;hi=Math.imul(ah2,bh0);lo=lo+Math.imul(al1,bl1)|0;mid=mid+Math.imul(al1,bh1)|0;mid=mid+Math.imul(ah1,bl1)|0;hi=hi+Math.imul(ah1,bh1)|0;lo=lo+Math.imul(al0,bl2)|0;mid=mid+Math.imul(al0,bh2)|0;mid=mid+Math.imul(ah0,bl2)|0;hi=hi+Math.imul(ah0,bh2)|0;var w2=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w2>>>26)|0;w2&=67108863;lo=Math.imul(al3,bl0);mid=Math.imul(al3,bh0);mid=mid+Math.imul(ah3,bl0)|0;hi=Math.imul(ah3,bh0);lo=lo+Math.imul(al2,bl1)|0;mid=mid+Math.imul(al2,bh1)|0;mid=mid+Math.imul(ah2,bl1)|0;hi=hi+Math.imul(ah2,bh1)|0;lo=lo+Math.imul(al1,bl2)|0;mid=mid+Math.imul(al1,bh2)|0;mid=mid+Math.imul(ah1,bl2)|0;hi=hi+Math.imul(ah1,bh2)|0;lo=lo+Math.imul(al0,bl3)|0;mid=mid+Math.imul(al0,bh3)|0;mid=mid+Math.imul(ah0,bl3)|0;hi=hi+Math.imul(ah0,bh3)|0;var w3=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w3>>>26)|0;w3&=67108863;lo=Math.imul(al4,bl0);mid=Math.imul(al4,bh0);mid=mid+Math.imul(ah4,bl0)|0;hi=Math.imul(ah4,bh0);lo=lo+Math.imul(al3,bl1)|0;mid=mid+Math.imul(al3,bh1)|0;mid=mid+Math.imul(ah3,bl1)|0;hi=hi+Math.imul(ah3,bh1)|0;lo=lo+Math.imul(al2,bl2)|0;mid=mid+Math.imul(al2,bh2)|0;mid=mid+Math.imul(ah2,bl2)|0;hi=hi+Math.imul(ah2,bh2)|0;lo=lo+Math.imul(al1,bl3)|0;mid=mid+Math.imul(al1,bh3)|0;mid=mid+Math.imul(ah1,bl3)|0;hi=hi+Math.imul(ah1,bh3)|0;lo=lo+Math.imul(al0,bl4)|0;mid=mid+Math.imul(al0,bh4)|0;mid=mid+Math.imul(ah0,bl4)|0;hi=hi+Math.imul(ah0,bh4)|0;var w4=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w4>>>26)|0;w4&=67108863;lo=Math.imul(al5,bl0);mid=Math.imul(al5,bh0);mid=mid+Math.imul(ah5,bl0)|0;hi=Math.imul(ah5,bh0);lo=lo+Math.imul(al4,bl1)|0;mid=mid+Math.imul(al4,bh1)|0;mid=mid+Math.imul(ah4,bl1)|0;hi=hi+Math.imul(ah4,bh1)|0;lo=lo+Math.imul(al3,bl2)|0;mid=mid+Math.imul(al3,bh2)|0;mid=mid+Math.imul(ah3,bl2)|0;hi=hi+Math.imul(ah3,bh2)|0;lo=lo+Math.imul(al2,bl3)|0;mid=mid+Math.imul(al2,bh3)|0;mid=mid+Math.imul(ah2,bl3)|0;hi=hi+Math.imul(ah2,bh3)|0;lo=lo+Math.imul(al1,bl4)|0;mid=mid+Math.imul(al1,bh4)|0;mid=mid+Math.imul(ah1,bl4)|0;hi=hi+Math.imul(ah1,bh4)|0;lo=lo+Math.imul(al0,bl5)|0;mid=mid+Math.imul(al0,bh5)|0;mid=mid+Math.imul(ah0,bl5)|0;hi=hi+Math.imul(ah0,bh5)|0;var w5=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w5>>>26)|0;w5&=67108863;lo=Math.imul(al6,bl0);mid=Math.imul(al6,bh0);mid=mid+Math.imul(ah6,bl0)|0;hi=Math.imul(ah6,bh0);lo=lo+Math.imul(al5,bl1)|0;mid=mid+Math.imul(al5,bh1)|0;mid=mid+Math.imul(ah5,bl1)|0;hi=hi+Math.imul(ah5,bh1)|0;lo=lo+Math.imul(al4,bl2)|0;mid=mid+Math.imul(al4,bh2)|0;mid=mid+Math.imul(ah4,bl2)|0;hi=hi+Math.imul(ah4,bh2)|0;lo=lo+Math.imul(al3,bl3)|0;mid=mid+Math.imul(al3,bh3)|0;mid=mid+Math.imul(ah3,bl3)|0;hi=hi+Math.imul(ah3,bh3)|0;lo=lo+Math.imul(al2,bl4)|0;mid=mid+Math.imul(al2,bh4)|0;mid=mid+Math.imul(ah2,bl4)|0;hi=hi+Math.imul(ah2,bh4)|0;lo=lo+Math.imul(al1,bl5)|0;mid=mid+Math.imul(al1,bh5)|0;mid=mid+Math.imul(ah1,bl5)|0;hi=hi+Math.imul(ah1,bh5)|0;lo=lo+Math.imul(al0,bl6)|0;mid=mid+Math.imul(al0,bh6)|0;mid=mid+Math.imul(ah0,bl6)|0;hi=hi+Math.imul(ah0,bh6)|0;var w6=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w6>>>26)|0;w6&=67108863;lo=Math.imul(al7,bl0);mid=Math.imul(al7,bh0);mid=mid+Math.imul(ah7,bl0)|0;hi=Math.imul(ah7,bh0);lo=lo+Math.imul(al6,bl1)|0;mid=mid+Math.imul(al6,bh1)|0;mid=mid+Math.imul(ah6,bl1)|0;hi=hi+Math.imul(ah6,bh1)|0;lo=lo+Math.imul(al5,bl2)|0;mid=mid+Math.imul(al5,bh2)|0;mid=mid+Math.imul(ah5,bl2)|0;hi=hi+Math.imul(ah5,bh2)|0;lo=lo+Math.imul(al4,bl3)|0;mid=mid+Math.imul(al4,bh3)|0;mid=mid+Math.imul(ah4,bl3)|0;hi=hi+Math.imul(ah4,bh3)|0;lo=lo+Math.imul(al3,bl4)|0;mid=mid+Math.imul(al3,bh4)|0;mid=mid+Math.imul(ah3,bl4)|0;hi=hi+Math.imul(ah3,bh4)|0;lo=lo+Math.imul(al2,bl5)|0;mid=mid+Math.imul(al2,bh5)|0;mid=mid+Math.imul(ah2,bl5)|0;hi=hi+Math.imul(ah2,bh5)|0;lo=lo+Math.imul(al1,bl6)|0;mid=mid+Math.imul(al1,bh6)|0;mid=mid+Math.imul(ah1,bl6)|0;hi=hi+Math.imul(ah1,bh6)|0;lo=lo+Math.imul(al0,bl7)|0;mid=mid+Math.imul(al0,bh7)|0;mid=mid+Math.imul(ah0,bl7)|0;hi=hi+Math.imul(ah0,bh7)|0;var w7=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w7>>>26)|0;w7&=67108863;lo=Math.imul(al8,bl0);mid=Math.imul(al8,bh0);mid=mid+Math.imul(ah8,bl0)|0;hi=Math.imul(ah8,bh0);lo=lo+Math.imul(al7,bl1)|0;mid=mid+Math.imul(al7,bh1)|0;mid=mid+Math.imul(ah7,bl1)|0;hi=hi+Math.imul(ah7,bh1)|0;lo=lo+Math.imul(al6,bl2)|0;mid=mid+Math.imul(al6,bh2)|0;mid=mid+Math.imul(ah6,bl2)|0;hi=hi+Math.imul(ah6,bh2)|0;lo=lo+Math.imul(al5,bl3)|0;mid=mid+Math.imul(al5,bh3)|0;mid=mid+Math.imul(ah5,bl3)|0;hi=hi+Math.imul(ah5,bh3)|0;lo=lo+Math.imul(al4,bl4)|0;mid=mid+Math.imul(al4,bh4)|0;mid=mid+Math.imul(ah4,bl4)|0;hi=hi+Math.imul(ah4,bh4)|0;lo=lo+Math.imul(al3,bl5)|0;mid=mid+Math.imul(al3,bh5)|0;mid=mid+Math.imul(ah3,bl5)|0;hi=hi+Math.imul(ah3,bh5)|0;lo=lo+Math.imul(al2,bl6)|0;mid=mid+Math.imul(al2,bh6)|0;mid=mid+Math.imul(ah2,bl6)|0;hi=hi+Math.imul(ah2,bh6)|0;lo=lo+Math.imul(al1,bl7)|0;mid=mid+Math.imul(al1,bh7)|0;mid=mid+Math.imul(ah1,bl7)|0;hi=hi+Math.imul(ah1,bh7)|0;lo=lo+Math.imul(al0,bl8)|0;mid=mid+Math.imul(al0,bh8)|0;mid=mid+Math.imul(ah0,bl8)|0;hi=hi+Math.imul(ah0,bh8)|0;var w8=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w8>>>26)|0;w8&=67108863;lo=Math.imul(al9,bl0);mid=Math.imul(al9,bh0);mid=mid+Math.imul(ah9,bl0)|0;hi=Math.imul(ah9,bh0);lo=lo+Math.imul(al8,bl1)|0;mid=mid+Math.imul(al8,bh1)|0;mid=mid+Math.imul(ah8,bl1)|0;hi=hi+Math.imul(ah8,bh1)|0;lo=lo+Math.imul(al7,bl2)|0;mid=mid+Math.imul(al7,bh2)|0;mid=mid+Math.imul(ah7,bl2)|0;hi=hi+Math.imul(ah7,bh2)|0;lo=lo+Math.imul(al6,bl3)|0;mid=mid+Math.imul(al6,bh3)|0;mid=mid+Math.imul(ah6,bl3)|0;hi=hi+Math.imul(ah6,bh3)|0;lo=lo+Math.imul(al5,bl4)|0;mid=mid+Math.imul(al5,bh4)|0;mid=mid+Math.imul(ah5,bl4)|0;hi=hi+Math.imul(ah5,bh4)|0;lo=lo+Math.imul(al4,bl5)|0;mid=mid+Math.imul(al4,bh5)|0;mid=mid+Math.imul(ah4,bl5)|0;hi=hi+Math.imul(ah4,bh5)|0;lo=lo+Math.imul(al3,bl6)|0;mid=mid+Math.imul(al3,bh6)|0;mid=mid+Math.imul(ah3,bl6)|0;hi=hi+Math.imul(ah3,bh6)|0;lo=lo+Math.imul(al2,bl7)|0;mid=mid+Math.imul(al2,bh7)|0;mid=mid+Math.imul(ah2,bl7)|0;hi=hi+Math.imul(ah2,bh7)|0;lo=lo+Math.imul(al1,bl8)|0;mid=mid+Math.imul(al1,bh8)|0;mid=mid+Math.imul(ah1,bl8)|0;hi=hi+Math.imul(ah1,bh8)|0;lo=lo+Math.imul(al0,bl9)|0;mid=mid+Math.imul(al0,bh9)|0;mid=mid+Math.imul(ah0,bl9)|0;hi=hi+Math.imul(ah0,bh9)|0;var w9=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w9>>>26)|0;w9&=67108863;lo=Math.imul(al9,bl1);mid=Math.imul(al9,bh1);mid=mid+Math.imul(ah9,bl1)|0;hi=Math.imul(ah9,bh1);lo=lo+Math.imul(al8,bl2)|0;mid=mid+Math.imul(al8,bh2)|0;mid=mid+Math.imul(ah8,bl2)|0;hi=hi+Math.imul(ah8,bh2)|0;lo=lo+Math.imul(al7,bl3)|0;mid=mid+Math.imul(al7,bh3)|0;mid=mid+Math.imul(ah7,bl3)|0;hi=hi+Math.imul(ah7,bh3)|0;lo=lo+Math.imul(al6,bl4)|0;mid=mid+Math.imul(al6,bh4)|0;mid=mid+Math.imul(ah6,bl4)|0;hi=hi+Math.imul(ah6,bh4)|0;lo=lo+Math.imul(al5,bl5)|0;mid=mid+Math.imul(al5,bh5)|0;mid=mid+Math.imul(ah5,bl5)|0;hi=hi+Math.imul(ah5,bh5)|0;lo=lo+Math.imul(al4,bl6)|0;mid=mid+Math.imul(al4,bh6)|0;mid=mid+Math.imul(ah4,bl6)|0;hi=hi+Math.imul(ah4,bh6)|0;lo=lo+Math.imul(al3,bl7)|0;mid=mid+Math.imul(al3,bh7)|0;mid=mid+Math.imul(ah3,bl7)|0;hi=hi+Math.imul(ah3,bh7)|0;lo=lo+Math.imul(al2,bl8)|0;mid=mid+Math.imul(al2,bh8)|0;mid=mid+Math.imul(ah2,bl8)|0;hi=hi+Math.imul(ah2,bh8)|0;lo=lo+Math.imul(al1,bl9)|0;mid=mid+Math.imul(al1,bh9)|0;mid=mid+Math.imul(ah1,bl9)|0;hi=hi+Math.imul(ah1,bh9)|0;var w10=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w10>>>26)|0;w10&=67108863;lo=Math.imul(al9,bl2);mid=Math.imul(al9,bh2);mid=mid+Math.imul(ah9,bl2)|0;hi=Math.imul(ah9,bh2);lo=lo+Math.imul(al8,bl3)|0;mid=mid+Math.imul(al8,bh3)|0;mid=mid+Math.imul(ah8,bl3)|0;hi=hi+Math.imul(ah8,bh3)|0;lo=lo+Math.imul(al7,bl4)|0;mid=mid+Math.imul(al7,bh4)|0;mid=mid+Math.imul(ah7,bl4)|0;hi=hi+Math.imul(ah7,bh4)|0;lo=lo+Math.imul(al6,bl5)|0;mid=mid+Math.imul(al6,bh5)|0;mid=mid+Math.imul(ah6,bl5)|0;hi=hi+Math.imul(ah6,bh5)|0;lo=lo+Math.imul(al5,bl6)|0;mid=mid+Math.imul(al5,bh6)|0;mid=mid+Math.imul(ah5,bl6)|0;hi=hi+Math.imul(ah5,bh6)|0;lo=lo+Math.imul(al4,bl7)|0;mid=mid+Math.imul(al4,bh7)|0;mid=mid+Math.imul(ah4,bl7)|0;hi=hi+Math.imul(ah4,bh7)|0;lo=lo+Math.imul(al3,bl8)|0;mid=mid+Math.imul(al3,bh8)|0;mid=mid+Math.imul(ah3,bl8)|0;hi=hi+Math.imul(ah3,bh8)|0;lo=lo+Math.imul(al2,bl9)|0;mid=mid+Math.imul(al2,bh9)|0;mid=mid+Math.imul(ah2,bl9)|0;hi=hi+Math.imul(ah2,bh9)|0;var w11=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w11>>>26)|0;w11&=67108863;lo=Math.imul(al9,bl3);mid=Math.imul(al9,bh3);mid=mid+Math.imul(ah9,bl3)|0;hi=Math.imul(ah9,bh3);lo=lo+Math.imul(al8,bl4)|0;mid=mid+Math.imul(al8,bh4)|0;mid=mid+Math.imul(ah8,bl4)|0;hi=hi+Math.imul(ah8,bh4)|0;lo=lo+Math.imul(al7,bl5)|0;mid=mid+Math.imul(al7,bh5)|0;mid=mid+Math.imul(ah7,bl5)|0;hi=hi+Math.imul(ah7,bh5)|0;lo=lo+Math.imul(al6,bl6)|0;mid=mid+Math.imul(al6,bh6)|0;mid=mid+Math.imul(ah6,bl6)|0;hi=hi+Math.imul(ah6,bh6)|0;lo=lo+Math.imul(al5,bl7)|0;mid=mid+Math.imul(al5,bh7)|0;mid=mid+Math.imul(ah5,bl7)|0;hi=hi+Math.imul(ah5,bh7)|0;lo=lo+Math.imul(al4,bl8)|0;mid=mid+Math.imul(al4,bh8)|0;mid=mid+Math.imul(ah4,bl8)|0;hi=hi+Math.imul(ah4,bh8)|0;lo=lo+Math.imul(al3,bl9)|0;mid=mid+Math.imul(al3,bh9)|0;mid=mid+Math.imul(ah3,bl9)|0;hi=hi+Math.imul(ah3,bh9)|0;var w12=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w12>>>26)|0;w12&=67108863;lo=Math.imul(al9,bl4);mid=Math.imul(al9,bh4);mid=mid+Math.imul(ah9,bl4)|0;hi=Math.imul(ah9,bh4);lo=lo+Math.imul(al8,bl5)|0;mid=mid+Math.imul(al8,bh5)|0;mid=mid+Math.imul(ah8,bl5)|0;hi=hi+Math.imul(ah8,bh5)|0;lo=lo+Math.imul(al7,bl6)|0;mid=mid+Math.imul(al7,bh6)|0;mid=mid+Math.imul(ah7,bl6)|0;hi=hi+Math.imul(ah7,bh6)|0;lo=lo+Math.imul(al6,bl7)|0;mid=mid+Math.imul(al6,bh7)|0;mid=mid+Math.imul(ah6,bl7)|0;hi=hi+Math.imul(ah6,bh7)|0;lo=lo+Math.imul(al5,bl8)|0;mid=mid+Math.imul(al5,bh8)|0;mid=mid+Math.imul(ah5,bl8)|0;hi=hi+Math.imul(ah5,bh8)|0;lo=lo+Math.imul(al4,bl9)|0;mid=mid+Math.imul(al4,bh9)|0;mid=mid+Math.imul(ah4,bl9)|0;hi=hi+Math.imul(ah4,bh9)|0;var w13=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w13>>>26)|0;w13&=67108863;lo=Math.imul(al9,bl5);mid=Math.imul(al9,bh5);mid=mid+Math.imul(ah9,bl5)|0;hi=Math.imul(ah9,bh5);lo=lo+Math.imul(al8,bl6)|0;mid=mid+Math.imul(al8,bh6)|0;mid=mid+Math.imul(ah8,bl6)|0;hi=hi+Math.imul(ah8,bh6)|0;lo=lo+Math.imul(al7,bl7)|0;mid=mid+Math.imul(al7,bh7)|0;mid=mid+Math.imul(ah7,bl7)|0;hi=hi+Math.imul(ah7,bh7)|0;lo=lo+Math.imul(al6,bl8)|0;mid=mid+Math.imul(al6,bh8)|0;mid=mid+Math.imul(ah6,bl8)|0;hi=hi+Math.imul(ah6,bh8)|0;lo=lo+Math.imul(al5,bl9)|0;mid=mid+Math.imul(al5,bh9)|0;mid=mid+Math.imul(ah5,bl9)|0;hi=hi+Math.imul(ah5,bh9)|0;var w14=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w14>>>26)|0;w14&=67108863;lo=Math.imul(al9,bl6);mid=Math.imul(al9,bh6);mid=mid+Math.imul(ah9,bl6)|0;hi=Math.imul(ah9,bh6);lo=lo+Math.imul(al8,bl7)|0;mid=mid+Math.imul(al8,bh7)|0;mid=mid+Math.imul(ah8,bl7)|0;hi=hi+Math.imul(ah8,bh7)|0;lo=lo+Math.imul(al7,bl8)|0;mid=mid+Math.imul(al7,bh8)|0;mid=mid+Math.imul(ah7,bl8)|0;hi=hi+Math.imul(ah7,bh8)|0;lo=lo+Math.imul(al6,bl9)|0;mid=mid+Math.imul(al6,bh9)|0;mid=mid+Math.imul(ah6,bl9)|0;hi=hi+Math.imul(ah6,bh9)|0;var w15=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w15>>>26)|0;w15&=67108863;lo=Math.imul(al9,bl7);mid=Math.imul(al9,bh7);mid=mid+Math.imul(ah9,bl7)|0;hi=Math.imul(ah9,bh7);lo=lo+Math.imul(al8,bl8)|0;mid=mid+Math.imul(al8,bh8)|0;mid=mid+Math.imul(ah8,bl8)|0;hi=hi+Math.imul(ah8,bh8)|0;lo=lo+Math.imul(al7,bl9)|0;mid=mid+Math.imul(al7,bh9)|0;mid=mid+Math.imul(ah7,bl9)|0;hi=hi+Math.imul(ah7,bh9)|0;var w16=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w16>>>26)|0;w16&=67108863;lo=Math.imul(al9,bl8);mid=Math.imul(al9,bh8);mid=mid+Math.imul(ah9,bl8)|0;hi=Math.imul(ah9,bh8);lo=lo+Math.imul(al8,bl9)|0;mid=mid+Math.imul(al8,bh9)|0;mid=mid+Math.imul(ah8,bl9)|0;hi=hi+Math.imul(ah8,bh9)|0;var w17=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w17>>>26)|0;w17&=67108863;lo=Math.imul(al9,bl9);mid=Math.imul(al9,bh9);mid=mid+Math.imul(ah9,bl9)|0;hi=Math.imul(ah9,bh9);var w18=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w18>>>26)|0;w18&=67108863;o[0]=w0;o[1]=w1;o[2]=w2;o[3]=w3;o[4]=w4;o[5]=w5;o[6]=w6;o[7]=w7;o[8]=w8;o[9]=w9;o[10]=w10;o[11]=w11;o[12]=w12;o[13]=w13;o[14]=w14;o[15]=w15;o[16]=w16;o[17]=w17;o[18]=w18;if(c!==0){o[19]=c;out.length++}return out};if(!Math.imul){comb10MulTo=smallMulTo}function bigMulTo(self,num,out){out.negative=num.negative^self.negative;out.length=self.length+num.length;var carry=0;var hncarry=0;for(var k=0;k<out.length-1;k++){var ncarry=hncarry;hncarry=0;var rword=carry&67108863;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j;var a=self.words[i]|0;var b=num.words[j]|0;var r=a*b;var lo=r&67108863;ncarry=ncarry+(r/67108864|0)|0;lo=lo+rword|0;rword=lo&67108863;ncarry=ncarry+(lo>>>26)|0;hncarry+=ncarry>>>26;ncarry&=67108863}out.words[k]=rword;carry=ncarry;ncarry=hncarry}if(carry!==0){out.words[k]=carry}else{out.length--}return out.strip()}function jumboMulTo(self,num,out){var fftm=new FFTM;return fftm.mulp(self,num,out)}BN.prototype.mulTo=function mulTo(num,out){var res;var len=this.length+num.length;if(this.length===10&&num.length===10){res=comb10MulTo(this,num,out)}else if(len<63){res=smallMulTo(this,num,out)}else if(len<1024){res=bigMulTo(this,num,out)}else{res=jumboMulTo(this,num,out)}return res};function FFTM(x,y){this.x=x;this.y=y}FFTM.prototype.makeRBT=function makeRBT(N){var t=new Array(N);var l=BN.prototype._countBits(N)-1;for(var i=0;i<N;i++){t[i]=this.revBin(i,l,N)}return t};FFTM.prototype.revBin=function revBin(x,l,N){if(x===0||x===N-1)return x;var rb=0;for(var i=0;i<l;i++){rb|=(x&1)<<l-i-1;x>>=1}return rb};FFTM.prototype.permute=function permute(rbt,rws,iws,rtws,itws,N){for(var i=0;i<N;i++){rtws[i]=rws[rbt[i]];itws[i]=iws[rbt[i]]}};FFTM.prototype.transform=function transform(rws,iws,rtws,itws,N,rbt){this.permute(rbt,rws,iws,rtws,itws,N);for(var s=1;s<N;s<<=1){var l=s<<1;var rtwdf=Math.cos(2*Math.PI/l);var itwdf=Math.sin(2*Math.PI/l);for(var p=0;p<N;p+=l){var rtwdf_=rtwdf;var itwdf_=itwdf;for(var j=0;j<s;j++){var re=rtws[p+j];var ie=itws[p+j];var ro=rtws[p+j+s];var io=itws[p+j+s];var rx=rtwdf_*ro-itwdf_*io;io=rtwdf_*io+itwdf_*ro;ro=rx;rtws[p+j]=re+ro;itws[p+j]=ie+io;rtws[p+j+s]=re-ro;itws[p+j+s]=ie-io;if(j!==l){rx=rtwdf*rtwdf_-itwdf*itwdf_;itwdf_=rtwdf*itwdf_+itwdf*rtwdf_;rtwdf_=rx}}}}};FFTM.prototype.guessLen13b=function guessLen13b(n,m){var N=Math.max(m,n)|1;var odd=N&1;var i=0;for(N=N/2|0;N;N=N>>>1){i++}return 1<<i+1+odd};FFTM.prototype.conjugate=function conjugate(rws,iws,N){if(N<=1)return;for(var i=0;i<N/2;i++){var t=rws[i];rws[i]=rws[N-i-1];rws[N-i-1]=t;t=iws[i];iws[i]=-iws[N-i-1];iws[N-i-1]=-t}};FFTM.prototype.normalize13b=function normalize13b(ws,N){var carry=0;for(var i=0;i<N/2;i++){var w=Math.round(ws[2*i+1]/N)*8192+Math.round(ws[2*i]/N)+carry;ws[i]=w&67108863;if(w<67108864){carry=0}else{carry=w/67108864|0}}return ws};FFTM.prototype.convert13b=function convert13b(ws,len,rws,N){var carry=0;for(var i=0;i<len;i++){carry=carry+(ws[i]|0);rws[2*i]=carry&8191;carry=carry>>>13;rws[2*i+1]=carry&8191;carry=carry>>>13}for(i=2*len;i<N;++i){rws[i]=0}assert(carry===0);assert((carry&~8191)===0)};FFTM.prototype.stub=function stub(N){var ph=new Array(N);for(var i=0;i<N;i++){ph[i]=0}return ph};FFTM.prototype.mulp=function mulp(x,y,out){var N=2*this.guessLen13b(x.length,y.length);var rbt=this.makeRBT(N);var _=this.stub(N);var rws=new Array(N);var rwst=new Array(N);var iwst=new Array(N);var nrws=new Array(N);var nrwst=new Array(N);var niwst=new Array(N);var rmws=out.words;rmws.length=N;this.convert13b(x.words,x.length,rws,N);this.convert13b(y.words,y.length,nrws,N);this.transform(rws,_,rwst,iwst,N,rbt);this.transform(nrws,_,nrwst,niwst,N,rbt);for(var i=0;i<N;i++){var rx=rwst[i]*nrwst[i]-iwst[i]*niwst[i];iwst[i]=rwst[i]*niwst[i]+iwst[i]*nrwst[i];rwst[i]=rx}this.conjugate(rwst,iwst,N);this.transform(rwst,iwst,rmws,_,N,rbt);this.conjugate(rmws,_,N);this.normalize13b(rmws,N);out.negative=x.negative^y.negative;out.length=x.length+y.length;return out.strip()};BN.prototype.mul=function mul(num){var out=new BN(null);out.words=new Array(this.length+num.length);return this.mulTo(num,out)};BN.prototype.mulf=function mulf(num){var out=new BN(null);out.words=new Array(this.length+num.length);return jumboMulTo(this,num,out)};BN.prototype.imul=function imul(num){return this.clone().mulTo(num,this)};BN.prototype.imuln=function imuln(num){assert(typeof num==="number");assert(num<67108864);var carry=0;for(var i=0;i<this.length;i++){var w=(this.words[i]|0)*num;var lo=(w&67108863)+(carry&67108863);carry>>=26;carry+=w/67108864|0;carry+=lo>>>26;this.words[i]=lo&67108863}if(carry!==0){this.words[i]=carry;this.length++}return this};BN.prototype.muln=function muln(num){return this.clone().imuln(num)};BN.prototype.sqr=function sqr(){return this.mul(this)};BN.prototype.isqr=function isqr(){return this.imul(this.clone())};BN.prototype.pow=function pow(num){var w=toBitArray(num);if(w.length===0)return new BN(1);var res=this;for(var i=0;i<w.length;i++,res=res.sqr()){if(w[i]!==0)break}if(++i<w.length){for(var q=res.sqr();i<w.length;i++,q=q.sqr()){if(w[i]===0)continue;res=res.mul(q)}}return res};BN.prototype.iushln=function iushln(bits){assert(typeof bits==="number"&&bits>=0);var r=bits%26;var s=(bits-r)/26;var carryMask=67108863>>>26-r<<26-r;var i;if(r!==0){var carry=0;for(i=0;i<this.length;i++){var newCarry=this.words[i]&carryMask;var c=(this.words[i]|0)-newCarry<<r;this.words[i]=c|carry;carry=newCarry>>>26-r}if(carry){this.words[i]=carry;this.length++}}if(s!==0){for(i=this.length-1;i>=0;i--){this.words[i+s]=this.words[i]}for(i=0;i<s;i++){this.words[i]=0}this.length+=s}return this.strip()};BN.prototype.ishln=function ishln(bits){assert(this.negative===0);return this.iushln(bits)};BN.prototype.iushrn=function iushrn(bits,hint,extended){assert(typeof bits==="number"&&bits>=0);var h;if(hint){h=(hint-hint%26)/26}else{h=0}var r=bits%26;var s=Math.min((bits-r)/26,this.length);var mask=67108863^67108863>>>r<<r;var maskedWords=extended;h-=s;h=Math.max(0,h);if(maskedWords){for(var i=0;i<s;i++){maskedWords.words[i]=this.words[i]}maskedWords.length=s}if(s===0){}else if(this.length>s){this.length-=s;for(i=0;i<this.length;i++){this.words[i]=this.words[i+s]}}else{this.words[0]=0;this.length=1}var carry=0;for(i=this.length-1;i>=0&&(carry!==0||i>=h);i--){var word=this.words[i]|0;this.words[i]=carry<<26-r|word>>>r;carry=word&mask}if(maskedWords&&carry!==0){maskedWords.words[maskedWords.length++]=carry}if(this.length===0){this.words[0]=0;this.length=1}return this.strip()};BN.prototype.ishrn=function ishrn(bits,hint,extended){assert(this.negative===0);return this.iushrn(bits,hint,extended)};BN.prototype.shln=function shln(bits){return this.clone().ishln(bits)};BN.prototype.ushln=function ushln(bits){return this.clone().iushln(bits)};BN.prototype.shrn=function shrn(bits){return this.clone().ishrn(bits)};BN.prototype.ushrn=function ushrn(bits){return this.clone().iushrn(bits)};BN.prototype.testn=function testn(bit){assert(typeof bit==="number"&&bit>=0);var r=bit%26;var s=(bit-r)/26;var q=1<<r;if(this.length<=s)return false;var w=this.words[s];return!!(w&q)};BN.prototype.imaskn=function imaskn(bits){assert(typeof bits==="number"&&bits>=0);var r=bits%26;var s=(bits-r)/26;assert(this.negative===0,"imaskn works only with positive numbers");if(this.length<=s){return this}if(r!==0){s++}this.length=Math.min(s,this.length);if(r!==0){var mask=67108863^67108863>>>r<<r;this.words[this.length-1]&=mask}return this.strip()};BN.prototype.maskn=function maskn(bits){return this.clone().imaskn(bits)};BN.prototype.iaddn=function iaddn(num){assert(typeof num==="number");assert(num<67108864);if(num<0)return this.isubn(-num);if(this.negative!==0){if(this.length===1&&(this.words[0]|0)<num){this.words[0]=num-(this.words[0]|0);this.negative=0;return this}this.negative=0;this.isubn(num);this.negative=1;return this}return this._iaddn(num)};BN.prototype._iaddn=function _iaddn(num){this.words[0]+=num;for(var i=0;i<this.length&&this.words[i]>=67108864;i++){this.words[i]-=67108864;if(i===this.length-1){this.words[i+1]=1}else{this.words[i+1]++}}this.length=Math.max(this.length,i+1);return this};BN.prototype.isubn=function isubn(num){assert(typeof num==="number");assert(num<67108864);if(num<0)return this.iaddn(-num);if(this.negative!==0){this.negative=0;this.iaddn(num);this.negative=1;return this}this.words[0]-=num;if(this.length===1&&this.words[0]<0){this.words[0]=-this.words[0];this.negative=1}else{for(var i=0;i<this.length&&this.words[i]<0;i++){this.words[i]+=67108864;this.words[i+1]-=1}}return this.strip()};BN.prototype.addn=function addn(num){return this.clone().iaddn(num)};BN.prototype.subn=function subn(num){return this.clone().isubn(num)};BN.prototype.iabs=function iabs(){this.negative=0;return this};BN.prototype.abs=function abs(){return this.clone().iabs()};BN.prototype._ishlnsubmul=function _ishlnsubmul(num,mul,shift){var len=num.length+shift;var i;this._expand(len);var w;var carry=0;for(i=0;i<num.length;i++){w=(this.words[i+shift]|0)+carry;var right=(num.words[i]|0)*mul;w-=right&67108863;carry=(w>>26)-(right/67108864|0);this.words[i+shift]=w&67108863}for(;i<this.length-shift;i++){w=(this.words[i+shift]|0)+carry;carry=w>>26;this.words[i+shift]=w&67108863}if(carry===0)return this.strip();assert(carry===-1);carry=0;for(i=0;i<this.length;i++){w=-(this.words[i]|0)+carry;carry=w>>26;this.words[i]=w&67108863}this.negative=1;return this.strip()};BN.prototype._wordDiv=function _wordDiv(num,mode){var shift=this.length-num.length;var a=this.clone();var b=num;var bhi=b.words[b.length-1]|0;var bhiBits=this._countBits(bhi);shift=26-bhiBits;if(shift!==0){b=b.ushln(shift);a.iushln(shift);bhi=b.words[b.length-1]|0}var m=a.length-b.length;var q;if(mode!=="mod"){q=new BN(null);q.length=m+1;q.words=new Array(q.length);for(var i=0;i<q.length;i++){q.words[i]=0}}var diff=a.clone()._ishlnsubmul(b,1,m);if(diff.negative===0){a=diff;if(q){q.words[m]=1}}for(var j=m-1;j>=0;j--){var qj=(a.words[b.length+j]|0)*67108864+(a.words[b.length+j-1]|0);qj=Math.min(qj/bhi|0,67108863);a._ishlnsubmul(b,qj,j);while(a.negative!==0){qj--;a.negative=0;a._ishlnsubmul(b,1,j);if(!a.isZero()){a.negative^=1}}if(q){q.words[j]=qj}}if(q){q.strip()}a.strip();if(mode!=="div"&&shift!==0){a.iushrn(shift)}return{div:q||null,mod:a}};BN.prototype.divmod=function divmod(num,mode,positive){assert(!num.isZero());if(this.isZero()){return{div:new BN(0),mod:new BN(0)}}var div,mod,res;if(this.negative!==0&&num.negative===0){res=this.neg().divmod(num,mode);if(mode!=="mod"){div=res.div.neg()}if(mode!=="div"){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.iadd(num)}}return{div:div,mod:mod}}if(this.negative===0&&num.negative!==0){res=this.divmod(num.neg(),mode);if(mode!=="mod"){div=res.div.neg()}return{div:div,mod:res.mod}}if((this.negative&num.negative)!==0){res=this.neg().divmod(num.neg(),mode);if(mode!=="div"){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.isub(num)}}return{div:res.div,mod:mod}}if(num.length>this.length||this.cmp(num)<0){return{div:new BN(0),mod:this}}if(num.length===1){if(mode==="div"){return{div:this.divn(num.words[0]),mod:null}}if(mode==="mod"){return{div:null,mod:new BN(this.modn(num.words[0]))}}return{div:this.divn(num.words[0]),mod:new BN(this.modn(num.words[0]))}}return this._wordDiv(num,mode)};BN.prototype.div=function div(num){return this.divmod(num,"div",false).div};BN.prototype.mod=function mod(num){return this.divmod(num,"mod",false).mod};BN.prototype.umod=function umod(num){return this.divmod(num,"mod",true).mod};BN.prototype.divRound=function divRound(num){var dm=this.divmod(num);if(dm.mod.isZero())return dm.div;var mod=dm.div.negative!==0?dm.mod.isub(num):dm.mod;var half=num.ushrn(1);var r2=num.andln(1);var cmp=mod.cmp(half);if(cmp<0||r2===1&&cmp===0)return dm.div;return dm.div.negative!==0?dm.div.isubn(1):dm.div.iaddn(1)};BN.prototype.modn=function modn(num){assert(num<=67108863);var p=(1<<26)%num;var acc=0;for(var i=this.length-1;i>=0;i--){acc=(p*acc+(this.words[i]|0))%num}return acc};BN.prototype.idivn=function idivn(num){assert(num<=67108863);var carry=0;for(var i=this.length-1;i>=0;i--){var w=(this.words[i]|0)+carry*67108864;this.words[i]=w/num|0;carry=w%num}return this.strip()};BN.prototype.divn=function divn(num){return this.clone().idivn(num)};BN.prototype.egcd=function egcd(p){assert(p.negative===0);assert(!p.isZero());var x=this;var y=p.clone();if(x.negative!==0){x=x.umod(p)}else{x=x.clone()}var A=new BN(1);var B=new BN(0);var C=new BN(0);var D=new BN(1);var g=0;while(x.isEven()&&y.isEven()){x.iushrn(1);y.iushrn(1);++g}var yp=y.clone();var xp=x.clone();while(!x.isZero()){for(var i=0,im=1;(x.words[0]&im)===0&&i<26;++i,im<<=1);if(i>0){x.iushrn(i);while(i-- >0){if(A.isOdd()||B.isOdd()){A.iadd(yp);B.isub(xp)}A.iushrn(1);B.iushrn(1)}}for(var j=0,jm=1;(y.words[0]&jm)===0&&j<26;++j,jm<<=1);if(j>0){y.iushrn(j);while(j-- >0){if(C.isOdd()||D.isOdd()){C.iadd(yp);D.isub(xp)}C.iushrn(1);D.iushrn(1)}}if(x.cmp(y)>=0){x.isub(y);A.isub(C);B.isub(D)}else{y.isub(x);C.isub(A);D.isub(B)}}return{a:C,b:D,gcd:y.iushln(g)}};BN.prototype._invmp=function _invmp(p){assert(p.negative===0);assert(!p.isZero());var a=this;var b=p.clone();if(a.negative!==0){a=a.umod(p)}else{a=a.clone()}var x1=new BN(1);var x2=new BN(0);var delta=b.clone();while(a.cmpn(1)>0&&b.cmpn(1)>0){for(var i=0,im=1;(a.words[0]&im)===0&&i<26;++i,im<<=1);if(i>0){a.iushrn(i);while(i-- >0){if(x1.isOdd()){x1.iadd(delta)}x1.iushrn(1)}}for(var j=0,jm=1;(b.words[0]&jm)===0&&j<26;++j,jm<<=1);if(j>0){b.iushrn(j);while(j-- >0){if(x2.isOdd()){x2.iadd(delta)}x2.iushrn(1)}}if(a.cmp(b)>=0){a.isub(b);x1.isub(x2)}else{b.isub(a);x2.isub(x1)}}var res;if(a.cmpn(1)===0){res=x1}else{res=x2}if(res.cmpn(0)<0){res.iadd(p)}return res};BN.prototype.gcd=function gcd(num){if(this.isZero())return num.abs();if(num.isZero())return this.abs();var a=this.clone();var b=num.clone();a.negative=0;b.negative=0;for(var shift=0;a.isEven()&&b.isEven();shift++){a.iushrn(1);b.iushrn(1)}do{while(a.isEven()){a.iushrn(1)}while(b.isEven()){b.iushrn(1)}var r=a.cmp(b);if(r<0){var t=a;a=b;b=t}else if(r===0||b.cmpn(1)===0){break}a.isub(b)}while(true);return b.iushln(shift)};BN.prototype.invm=function invm(num){return this.egcd(num).a.umod(num)};BN.prototype.isEven=function isEven(){return(this.words[0]&1)===0};BN.prototype.isOdd=function isOdd(){return(this.words[0]&1)===1};BN.prototype.andln=function andln(num){return this.words[0]&num};BN.prototype.bincn=function bincn(bit){assert(typeof bit==="number");var r=bit%26;var s=(bit-r)/26;var q=1<<r;if(this.length<=s){this._expand(s+1);this.words[s]|=q;return this}var carry=q;for(var i=s;carry!==0&&i<this.length;i++){var w=this.words[i]|0;w+=carry;carry=w>>>26;w&=67108863;this.words[i]=w}if(carry!==0){this.words[i]=carry;this.length++}return this};BN.prototype.isZero=function isZero(){return this.length===1&&this.words[0]===0};BN.prototype.cmpn=function cmpn(num){var negative=num<0;if(this.negative!==0&&!negative)return-1;if(this.negative===0&&negative)return 1;this.strip();var res;if(this.length>1){res=1}else{if(negative){num=-num}assert(num<=67108863,"Number is too big");var w=this.words[0]|0;res=w===num?0:w<num?-1:1}if(this.negative!==0)return-res|0;return res};BN.prototype.cmp=function cmp(num){if(this.negative!==0&&num.negative===0)return-1;if(this.negative===0&&num.negative!==0)return 1;var res=this.ucmp(num);if(this.negative!==0)return-res|0;return res};BN.prototype.ucmp=function ucmp(num){if(this.length>num.length)return 1;if(this.length<num.length)return-1;var res=0;for(var i=this.length-1;i>=0;i--){var a=this.words[i]|0;var b=num.words[i]|0;if(a===b)continue;if(a<b){res=-1}else if(a>b){res=1}break}return res};BN.prototype.gtn=function gtn(num){return this.cmpn(num)===1};BN.prototype.gt=function gt(num){return this.cmp(num)===1};BN.prototype.gten=function gten(num){return this.cmpn(num)>=0};BN.prototype.gte=function gte(num){return this.cmp(num)>=0};BN.prototype.ltn=function ltn(num){return this.cmpn(num)===-1};BN.prototype.lt=function lt(num){return this.cmp(num)===-1};BN.prototype.lten=function lten(num){return this.cmpn(num)<=0};BN.prototype.lte=function lte(num){return this.cmp(num)<=0};BN.prototype.eqn=function eqn(num){return this.cmpn(num)===0};BN.prototype.eq=function eq(num){return this.cmp(num)===0};BN.red=function red(num){return new Red(num)};BN.prototype.toRed=function toRed(ctx){assert(!this.red,"Already a number in reduction context");assert(this.negative===0,"red works only with positives");return ctx.convertTo(this)._forceRed(ctx)};BN.prototype.fromRed=function fromRed(){assert(this.red,"fromRed works only with numbers in reduction context");return this.red.convertFrom(this)};BN.prototype._forceRed=function _forceRed(ctx){this.red=ctx;return this};BN.prototype.forceRed=function forceRed(ctx){assert(!this.red,"Already a number in reduction context");return this._forceRed(ctx)};BN.prototype.redAdd=function redAdd(num){assert(this.red,"redAdd works only with red numbers");return this.red.add(this,num)};BN.prototype.redIAdd=function redIAdd(num){assert(this.red,"redIAdd works only with red numbers");return this.red.iadd(this,num)};BN.prototype.redSub=function redSub(num){assert(this.red,"redSub works only with red numbers");return this.red.sub(this,num)};BN.prototype.redISub=function redISub(num){assert(this.red,"redISub works only with red numbers");return this.red.isub(this,num)};BN.prototype.redShl=function redShl(num){assert(this.red,"redShl works only with red numbers");return this.red.shl(this,num)};BN.prototype.redMul=function redMul(num){assert(this.red,"redMul works only with red numbers");this.red._verify2(this,num);return this.red.mul(this,num)};BN.prototype.redIMul=function redIMul(num){assert(this.red,"redMul works only with red numbers");this.red._verify2(this,num);return this.red.imul(this,num)};BN.prototype.redSqr=function redSqr(){assert(this.red,"redSqr works only with red numbers");this.red._verify1(this);return this.red.sqr(this)};BN.prototype.redISqr=function redISqr(){assert(this.red,"redISqr works only with red numbers");this.red._verify1(this);return this.red.isqr(this)};BN.prototype.redSqrt=function redSqrt(){assert(this.red,"redSqrt works only with red numbers");this.red._verify1(this);return this.red.sqrt(this)};BN.prototype.redInvm=function redInvm(){assert(this.red,"redInvm works only with red numbers");this.red._verify1(this);return this.red.invm(this)};BN.prototype.redNeg=function redNeg(){assert(this.red,"redNeg works only with red numbers");this.red._verify1(this);return this.red.neg(this)};BN.prototype.redPow=function redPow(num){assert(this.red&&!num.red,"redPow(normalNum)");this.red._verify1(this);return this.red.pow(this,num)};var primes={k256:null,p224:null,p192:null,p25519:null};function MPrime(name,p){this.name=name;this.p=new BN(p,16);this.n=this.p.bitLength();this.k=new BN(1).iushln(this.n).isub(this.p);this.tmp=this._tmp()}MPrime.prototype._tmp=function _tmp(){var tmp=new BN(null);tmp.words=new Array(Math.ceil(this.n/13));return tmp};MPrime.prototype.ireduce=function ireduce(num){var r=num;var rlen;do{this.split(r,this.tmp);r=this.imulK(r);r=r.iadd(this.tmp);rlen=r.bitLength()}while(rlen>this.n);var cmp=rlen<this.n?-1:r.ucmp(this.p);if(cmp===0){r.words[0]=0;r.length=1}else if(cmp>0){r.isub(this.p)}else{if(r.strip!==undefined){r.strip()}else{r._strip()}}return r};MPrime.prototype.split=function split(input,out){input.iushrn(this.n,0,out)};MPrime.prototype.imulK=function imulK(num){return num.imul(this.k)};function K256(){MPrime.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}inherits(K256,MPrime);K256.prototype.split=function split(input,output){var mask=4194303;var outLen=Math.min(input.length,9);for(var i=0;i<outLen;i++){output.words[i]=input.words[i]}output.length=outLen;if(input.length<=9){input.words[0]=0;input.length=1;return}var prev=input.words[9];output.words[output.length++]=prev&mask;for(i=10;i<input.length;i++){var next=input.words[i]|0;input.words[i-10]=(next&mask)<<4|prev>>>22;prev=next}prev>>>=22;input.words[i-10]=prev;if(prev===0&&input.length>10){input.length-=10}else{input.length-=9}};K256.prototype.imulK=function imulK(num){num.words[num.length]=0;num.words[num.length+1]=0;num.length+=2;var lo=0;for(var i=0;i<num.length;i++){var w=num.words[i]|0;lo+=w*977;num.words[i]=lo&67108863;lo=w*64+(lo/67108864|0)}if(num.words[num.length-1]===0){num.length--;if(num.words[num.length-1]===0){num.length--}}return num};function P224(){MPrime.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}inherits(P224,MPrime);function P192(){MPrime.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}inherits(P192,MPrime);function P25519(){MPrime.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}inherits(P25519,MPrime);P25519.prototype.imulK=function imulK(num){var carry=0;for(var i=0;i<num.length;i++){var hi=(num.words[i]|0)*19+carry;var lo=hi&67108863;hi>>>=26;num.words[i]=lo;carry=hi}if(carry!==0){num.words[num.length++]=carry}return num};BN._prime=function prime(name){if(primes[name])return primes[name];var prime;if(name==="k256"){prime=new K256}else if(name==="p224"){prime=new P224}else if(name==="p192"){prime=new P192}else if(name==="p25519"){prime=new P25519}else{throw new Error("Unknown prime "+name)}primes[name]=prime;return prime};function Red(m){if(typeof m==="string"){var prime=BN._prime(m);this.m=prime.p;this.prime=prime}else{assert(m.gtn(1),"modulus must be greater than 1");this.m=m;this.prime=null}}Red.prototype._verify1=function _verify1(a){assert(a.negative===0,"red works only with positives");assert(a.red,"red works only with red numbers")};Red.prototype._verify2=function _verify2(a,b){assert((a.negative|b.negative)===0,"red works only with positives");assert(a.red&&a.red===b.red,"red works only with red numbers")};Red.prototype.imod=function imod(a){if(this.prime)return this.prime.ireduce(a)._forceRed(this);return a.umod(this.m)._forceRed(this)};Red.prototype.neg=function neg(a){if(a.isZero()){return a.clone()}return this.m.sub(a)._forceRed(this)};Red.prototype.add=function add(a,b){this._verify2(a,b);var res=a.add(b);if(res.cmp(this.m)>=0){res.isub(this.m)}return res._forceRed(this)};Red.prototype.iadd=function iadd(a,b){this._verify2(a,b);var res=a.iadd(b);if(res.cmp(this.m)>=0){res.isub(this.m)}return res};Red.prototype.sub=function sub(a,b){this._verify2(a,b);var res=a.sub(b);if(res.cmpn(0)<0){res.iadd(this.m)}return res._forceRed(this)};Red.prototype.isub=function isub(a,b){this._verify2(a,b);var res=a.isub(b);if(res.cmpn(0)<0){res.iadd(this.m)}return res};Red.prototype.shl=function shl(a,num){this._verify1(a);return this.imod(a.ushln(num))};Red.prototype.imul=function imul(a,b){this._verify2(a,b);return this.imod(a.imul(b))};Red.prototype.mul=function mul(a,b){this._verify2(a,b);return this.imod(a.mul(b))};Red.prototype.isqr=function isqr(a){return this.imul(a,a.clone())};Red.prototype.sqr=function sqr(a){return this.mul(a,a)};Red.prototype.sqrt=function sqrt(a){if(a.isZero())return a.clone();var mod3=this.m.andln(3);assert(mod3%2===1);if(mod3===3){var pow=this.m.add(new BN(1)).iushrn(2);return this.pow(a,pow)}var q=this.m.subn(1);var s=0;while(!q.isZero()&&q.andln(1)===0){s++;q.iushrn(1)}assert(!q.isZero());var one=new BN(1).toRed(this);var nOne=one.redNeg();var lpow=this.m.subn(1).iushrn(1);var z=this.m.bitLength();z=new BN(2*z*z).toRed(this);while(this.pow(z,lpow).cmp(nOne)!==0){z.redIAdd(nOne)}var c=this.pow(z,q);var r=this.pow(a,q.addn(1).iushrn(1));var t=this.pow(a,q);var m=s;while(t.cmp(one)!==0){var tmp=t;for(var i=0;tmp.cmp(one)!==0;i++){tmp=tmp.redSqr()}assert(i<m);var b=this.pow(c,new BN(1).iushln(m-i-1));r=r.redMul(b);c=b.redSqr();t=t.redMul(c);m=i}return r};Red.prototype.invm=function invm(a){var inv=a._invmp(this.m);if(inv.negative!==0){inv.negative=0;return this.imod(inv).redNeg()}else{return this.imod(inv)}};Red.prototype.pow=function pow(a,num){if(num.isZero())return new BN(1).toRed(this);if(num.cmpn(1)===0)return a.clone();var windowSize=4;var wnd=new Array(1<<windowSize);wnd[0]=new BN(1).toRed(this);wnd[1]=a;for(var i=2;i<wnd.length;i++){wnd[i]=this.mul(wnd[i-1],a)}var res=wnd[0];var current=0;var currentLen=0;var start=num.bitLength()%26;if(start===0){start=26}for(i=num.length-1;i>=0;i--){var word=num.words[i];for(var j=start-1;j>=0;j--){var bit=word>>j&1;if(res!==wnd[0]){res=this.sqr(res)}if(bit===0&&current===0){currentLen=0;continue}current<<=1;current|=bit;currentLen++;if(currentLen!==windowSize&&(i!==0||j!==0))continue;res=this.mul(res,wnd[current]);currentLen=0;current=0}start=26}return res};Red.prototype.convertTo=function convertTo(num){var r=num.umod(this.m);return r===num?r.clone():r};Red.prototype.convertFrom=function convertFrom(num){var res=num.clone();res.red=null;return res};BN.mont=function mont(num){return new Mont(num)};function Mont(m){Red.call(this,m);this.shift=this.m.bitLength();if(this.shift%26!==0){this.shift+=26-this.shift%26}this.r=new BN(1).iushln(this.shift);this.r2=this.imod(this.r.sqr());this.rinv=this.r._invmp(this.m);this.minv=this.rinv.mul(this.r).isubn(1).div(this.m);this.minv=this.minv.umod(this.r);this.minv=this.r.sub(this.minv)}inherits(Mont,Red);Mont.prototype.convertTo=function convertTo(num){return this.imod(num.ushln(this.shift))};Mont.prototype.convertFrom=function convertFrom(num){var r=this.imod(num.mul(this.rinv));r.red=null;return r};Mont.prototype.imul=function imul(a,b){if(a.isZero()||b.isZero()){a.words[0]=0;a.length=1;return a}var t=a.imul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m)}else if(u.cmpn(0)<0){res=u.iadd(this.m)}return res._forceRed(this)};Mont.prototype.mul=function mul(a,b){if(a.isZero()||b.isZero())return new BN(0)._forceRed(this);var t=a.mul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m)}else if(u.cmpn(0)<0){res=u.iadd(this.m)}return res._forceRed(this)};Mont.prototype.invm=function invm(a){var res=this.imod(a._invmp(this.m).mul(this.r2));return res._forceRed(this)}})( false||module,commonjsGlobal)});const version="logger/5.1.0";"use strict";let _permanentCensorErrors=false;let _censorErrors=false;const LogLevels={debug:1,default:2,info:2,warning:3,error:4,off:5};let _logLevel=LogLevels["default"];let _globalLogger=null;function _checkNormalize(){try{const missing=[];["NFD","NFC","NFKD","NFKC"].forEach(form=>{try{if("test".normalize(form)!=="test"){throw new Error("bad normalize")}}catch(error){missing.push(form)}});if(missing.length){throw new Error("missing "+missing.join(", "))}if(String.fromCharCode(233).normalize("NFD")!==String.fromCharCode(101,769)){throw new Error("broken implementation")}}catch(error){return error.message}return null}const _normalizeError=_checkNormalize();var LogLevel;(function(LogLevel){LogLevel["DEBUG"]="DEBUG";LogLevel["INFO"]="INFO";LogLevel["WARNING"]="WARNING";LogLevel["ERROR"]="ERROR";LogLevel["OFF"]="OFF"})(LogLevel||(LogLevel={}));var ErrorCode;(function(ErrorCode){ErrorCode["UNKNOWN_ERROR"]="UNKNOWN_ERROR";ErrorCode["NOT_IMPLEMENTED"]="NOT_IMPLEMENTED";ErrorCode["UNSUPPORTED_OPERATION"]="UNSUPPORTED_OPERATION";ErrorCode["NETWORK_ERROR"]="NETWORK_ERROR";ErrorCode["SERVER_ERROR"]="SERVER_ERROR";ErrorCode["TIMEOUT"]="TIMEOUT";ErrorCode["BUFFER_OVERRUN"]="BUFFER_OVERRUN";ErrorCode["NUMERIC_FAULT"]="NUMERIC_FAULT";ErrorCode["MISSING_NEW"]="MISSING_NEW";ErrorCode["INVALID_ARGUMENT"]="INVALID_ARGUMENT";ErrorCode["MISSING_ARGUMENT"]="MISSING_ARGUMENT";ErrorCode["UNEXPECTED_ARGUMENT"]="UNEXPECTED_ARGUMENT";ErrorCode["CALL_EXCEPTION"]="CALL_EXCEPTION";ErrorCode["INSUFFICIENT_FUNDS"]="INSUFFICIENT_FUNDS";ErrorCode["NONCE_EXPIRED"]="NONCE_EXPIRED";ErrorCode["REPLACEMENT_UNDERPRICED"]="REPLACEMENT_UNDERPRICED";ErrorCode["UNPREDICTABLE_GAS_LIMIT"]="UNPREDICTABLE_GAS_LIMIT"})(ErrorCode||(ErrorCode={}));class Logger{constructor(version){Object.defineProperty(this,"version",{enumerable:true,value:version,writable:false})}_log(logLevel,args){const level=logLevel.toLowerCase();if(LogLevels[level]==null){this.throwArgumentError("invalid log level name","logLevel",logLevel)}if(_logLevel>LogLevels[level]){return}console.log.apply(console,args)}debug(...args){this._log(Logger.levels.DEBUG,args)}info(...args){this._log(Logger.levels.INFO,args)}warn(...args){this._log(Logger.levels.WARNING,args)}makeError(message,code,params){if(_censorErrors){return this.makeError("censored error",code,{})}if(!code){code=Logger.errors.UNKNOWN_ERROR}if(!params){params={}}const messageDetails=[];Object.keys(params).forEach(key=>{try{messageDetails.push(key+"="+JSON.stringify(params[key]))}catch(error){messageDetails.push(key+"="+JSON.stringify(params[key].toString()))}});messageDetails.push(`code=${code}`);messageDetails.push(`version=${this.version}`);const reason=message;if(messageDetails.length){message+=" ("+messageDetails.join(", ")+")"}const error=new Error(message);error.reason=reason;error.code=code;Object.keys(params).forEach(function(key){error[key]=params[key]});return error}throwError(message,code,params){throw this.makeError(message,code,params)}throwArgumentError(message,name,value){return this.throwError(message,Logger.errors.INVALID_ARGUMENT,{argument:name,value:value})}assert(condition,message,code,params){if(!!condition){return}this.throwError(message,code,params)}assertArgument(condition,message,name,value){if(!!condition){return}this.throwArgumentError(message,name,value)}checkNormalize(message){if(message==null){message="platform missing String.prototype.normalize"}if(_normalizeError){this.throwError("platform missing String.prototype.normalize",Logger.errors.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:_normalizeError})}}checkSafeUint53(value,message){if(typeof value!=="number"){return}if(message==null){message="value not safe"}if(value<0||value>=9007199254740991){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"out-of-safe-range",value:value})}if(value%1){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"non-integer",value:value})}}checkArgumentCount(count,expectedCount,message){if(message){message=": "+message}else{message=""}if(count<expectedCount){this.throwError("missing argument"+message,Logger.errors.MISSING_ARGUMENT,{count:count,expectedCount:expectedCount})}if(count>expectedCount){this.throwError("too many arguments"+message,Logger.errors.UNEXPECTED_ARGUMENT,{count:count,expectedCount:expectedCount})}}checkNew(target,kind){if(target===Object||target==null){this.throwError("missing new",Logger.errors.MISSING_NEW,{name:kind.name})}}checkAbstract(target,kind){if(target===kind){this.throwError("cannot instantiate abstract class "+JSON.stringify(kind.name)+" directly; use a sub-class",Logger.errors.UNSUPPORTED_OPERATION,{name:target.name,operation:"new"})}else if(target===Object||target==null){this.throwError("missing new",Logger.errors.MISSING_NEW,{name:kind.name})}}static globalLogger(){if(!_globalLogger){_globalLogger=new Logger(version)}return _globalLogger}static setCensorship(censorship,permanent){if(!censorship&&permanent){this.globalLogger().throwError("cannot permanently disable censorship",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}if(_permanentCensorErrors){if(!censorship){return}this.globalLogger().throwError("error censorship permanent",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}_censorErrors=!!censorship;_permanentCensorErrors=!!permanent}static setLogLevel(logLevel){const level=LogLevels[logLevel.toLowerCase()];if(level==null){Logger.globalLogger().warn("invalid log level - "+logLevel);return}_logLevel=level}static from(version){return new Logger(version)}}Logger.errors=ErrorCode;Logger.levels=LogLevel;const version$1="bytes/5.1.0";"use strict";const logger=new Logger(version$1);function isHexable(value){return!!value.toHexString}function addSlice(array){if(array.slice){return array}array.slice=function(){const args=Array.prototype.slice.call(arguments);return addSlice(new Uint8Array(Array.prototype.slice.apply(array,args)))};return array}function isBytesLike(value){return isHexString(value)&&!(value.length%2)||isBytes(value)}function isBytes(value){if(value==null){return false}if(value.constructor===Uint8Array){return true}if(typeof value==="string"){return false}if(value.length==null){return false}for(let i=0;i<value.length;i++){const v=value[i];if(typeof v!=="number"||v<0||v>=256||v%1){return false}}return true}function arrayify(value,options){if(!options){options={}}if(typeof value==="number"){logger.checkSafeUint53(value,"invalid arrayify value");const result=[];while(value){result.unshift(value&255);value=parseInt(String(value/256))}if(result.length===0){result.push(0)}return addSlice(new Uint8Array(result))}if(options.allowMissingPrefix&&typeof value==="string"&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexable(value)){value=value.toHexString()}if(isHexString(value)){let hex=value.substring(2);if(hex.length%2){if(options.hexPad==="left"){hex="0x0"+hex.substring(2)}else if(options.hexPad==="right"){hex+="0"}else{logger.throwArgumentError("hex data is odd-length","value",value)}}const result=[];for(let i=0;i<hex.length;i+=2){result.push(parseInt(hex.substring(i,i+2),16))}return addSlice(new Uint8Array(result))}if(isBytes(value)){return addSlice(new Uint8Array(value))}return logger.throwArgumentError("invalid arrayify value","value",value)}function concat(items){const objects=items.map(item=>arrayify(item));const length=objects.reduce((accum,item)=>accum+item.length,0);const result=new Uint8Array(length);objects.reduce((offset,object)=>{result.set(object,offset);return offset+object.length},0);return addSlice(result)}function stripZeros(value){let result=arrayify(value);if(result.length===0){return result}let start=0;while(start<result.length&&result[start]===0){start++}if(start){result=result.slice(start)}return result}function zeroPad(value,length){value=arrayify(value);if(value.length>length){logger.throwArgumentError("value out of range","value",arguments[0])}const result=new Uint8Array(length);result.set(value,length-value.length);return addSlice(result)}function isHexString(value,length){if(typeof value!=="string"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(length&&value.length!==2+2*length){return false}return true}const HexCharacters="0123456789abcdef";function hexlify(value,options){if(!options){options={}}if(typeof value==="number"){logger.checkSafeUint53(value,"invalid hexlify value");let hex="";while(value){hex=HexCharacters[value&15]+hex;value=Math.floor(value/16)}if(hex.length){if(hex.length%2){hex="0"+hex}return"0x"+hex}return"0x00"}if(options.allowMissingPrefix&&typeof value==="string"&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexable(value)){return value.toHexString()}if(isHexString(value)){if(value.length%2){if(options.hexPad==="left"){value="0x0"+value.substring(2)}else if(options.hexPad==="right"){value+="0"}else{logger.throwArgumentError("hex data is odd-length","value",value)}}return value.toLowerCase()}if(isBytes(value)){let result="0x";for(let i=0;i<value.length;i++){let v=value[i];result+=HexCharacters[(v&240)>>4]+HexCharacters[v&15]}return result}return logger.throwArgumentError("invalid hexlify value","value",value)}function hexDataLength(data){if(typeof data!=="string"){data=hexlify(data)}else if(!isHexString(data)||data.length%2){return null}return(data.length-2)/2}function hexDataSlice(data,offset,endOffset){if(typeof data!=="string"){data=hexlify(data)}else if(!isHexString(data)||data.length%2){logger.throwArgumentError("invalid hexData","value",data)}offset=2+2*offset;if(endOffset!=null){return"0x"+data.substring(offset,2+2*endOffset)}return"0x"+data.substring(offset)}function hexConcat(items){let result="0x";items.forEach(item=>{result+=hexlify(item).substring(2)});return result}function hexValue(value){const trimmed=hexStripZeros(hexlify(value,{hexPad:"left"}));if(trimmed==="0x"){return"0x0"}return trimmed}function hexStripZeros(value){if(typeof value!=="string"){value=hexlify(value)}if(!isHexString(value)){logger.throwArgumentError("invalid hex string","value",value)}value=value.substring(2);let offset=0;while(offset<value.length&&value[offset]==="0"){offset++}return"0x"+value.substring(offset)}function hexZeroPad(value,length){if(typeof value!=="string"){value=hexlify(value)}else if(!isHexString(value)){logger.throwArgumentError("invalid hex string","value",value)}if(value.length>2*length+2){logger.throwArgumentError("value out of range","value",arguments[1])}while(value.length<2*length+2){value="0x0"+value.substring(2)}return value}function splitSignature(signature){const result={r:"0x",s:"0x",_vs:"0x",recoveryParam:0,v:0};if(isBytesLike(signature)){const bytes=arrayify(signature);if(bytes.length!==65){logger.throwArgumentError("invalid signature string; must be 65 bytes","signature",signature)}result.r=hexlify(bytes.slice(0,32));result.s=hexlify(bytes.slice(32,64));result.v=bytes[64];if(result.v<27){if(result.v===0||result.v===1){result.v+=27}else{logger.throwArgumentError("signature invalid v byte","signature",signature)}}result.recoveryParam=1-result.v%2;if(result.recoveryParam){bytes[32]|=128}result._vs=hexlify(bytes.slice(32,64))}else{result.r=signature.r;result.s=signature.s;result.v=signature.v;result.recoveryParam=signature.recoveryParam;result._vs=signature._vs;if(result._vs!=null){const vs=zeroPad(arrayify(result._vs),32);result._vs=hexlify(vs);const recoveryParam=vs[0]>=128?1:0;if(result.recoveryParam==null){result.recoveryParam=recoveryParam}else if(result.recoveryParam!==recoveryParam){logger.throwArgumentError("signature recoveryParam mismatch _vs","signature",signature)}vs[0]&=127;const s=hexlify(vs);if(result.s==null){result.s=s}else if(result.s!==s){logger.throwArgumentError("signature v mismatch _vs","signature",signature)}}if(result.recoveryParam==null){if(result.v==null){logger.throwArgumentError("signature missing v and recoveryParam","signature",signature)}else if(result.v===0||result.v===1){result.recoveryParam=result.v}else{result.recoveryParam=1-result.v%2}}else{if(result.v==null){result.v=27+result.recoveryParam}else if(result.recoveryParam!==1-result.v%2){logger.throwArgumentError("signature recoveryParam mismatch v","signature",signature)}}if(result.r==null||!isHexString(result.r)){logger.throwArgumentError("signature missing or invalid r","signature",signature)}else{result.r=hexZeroPad(result.r,32)}if(result.s==null||!isHexString(result.s)){logger.throwArgumentError("signature missing or invalid s","signature",signature)}else{result.s=hexZeroPad(result.s,32)}const vs=arrayify(result.s);if(vs[0]>=128){logger.throwArgumentError("signature s out of range","signature",signature)}if(result.recoveryParam){vs[0]|=128}const _vs=hexlify(vs);if(result._vs){if(!isHexString(result._vs)){logger.throwArgumentError("signature invalid _vs","signature",signature)}result._vs=hexZeroPad(result._vs,32)}if(result._vs==null){result._vs=_vs}else if(result._vs!==_vs){logger.throwArgumentError("signature _vs mismatch v and s","signature",signature)}}return result}function joinSignature(signature){signature=splitSignature(signature);return hexlify(concat([signature.r,signature.s,signature.recoveryParam?"0x1c":"0x1b"]))}const version$2="bignumber/5.1.1";"use strict";var BN=bn.BN;const logger$1=new Logger(version$2);const _constructorGuard={};const MAX_SAFE=9007199254740991;function isBigNumberish(value){return value!=null&&(BigNumber.isBigNumber(value)||typeof value==="number"&&value%1===0||typeof value==="string"&&!!value.match(/^-?[0-9]+$/)||isHexString(value)||typeof value==="bigint"||isBytes(value))}let _warnedToStringRadix=false;class BigNumber{constructor(constructorGuard,hex){logger$1.checkNew(new.target,BigNumber);if(constructorGuard!==_constructorGuard){logger$1.throwError("cannot call constructor directly; use BigNumber.from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new (BigNumber)"})}this._hex=hex;this._isBigNumber=true;Object.freeze(this)}fromTwos(value){return toBigNumber(toBN(this).fromTwos(value))}toTwos(value){return toBigNumber(toBN(this).toTwos(value))}abs(){if(this._hex[0]==="-"){return BigNumber.from(this._hex.substring(1))}return this}add(other){return toBigNumber(toBN(this).add(toBN(other)))}sub(other){return toBigNumber(toBN(this).sub(toBN(other)))}div(other){const o=BigNumber.from(other);if(o.isZero()){throwFault("division by zero","div")}return toBigNumber(toBN(this).div(toBN(other)))}mul(other){return toBigNumber(toBN(this).mul(toBN(other)))}mod(other){const value=toBN(other);if(value.isNeg()){throwFault("cannot modulo negative values","mod")}return toBigNumber(toBN(this).umod(value))}pow(other){const value=toBN(other);if(value.isNeg()){throwFault("cannot raise to negative values","pow")}return toBigNumber(toBN(this).pow(value))}and(other){const value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault("cannot 'and' negative values","and")}return toBigNumber(toBN(this).and(value))}or(other){const value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault("cannot 'or' negative values","or")}return toBigNumber(toBN(this).or(value))}xor(other){const value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault("cannot 'xor' negative values","xor")}return toBigNumber(toBN(this).xor(value))}mask(value){if(this.isNegative()||value<0){throwFault("cannot mask negative values","mask")}return toBigNumber(toBN(this).maskn(value))}shl(value){if(this.isNegative()||value<0){throwFault("cannot shift negative values","shl")}return toBigNumber(toBN(this).shln(value))}shr(value){if(this.isNegative()||value<0){throwFault("cannot shift negative values","shr")}return toBigNumber(toBN(this).shrn(value))}eq(other){return toBN(this).eq(toBN(other))}lt(other){return toBN(this).lt(toBN(other))}lte(other){return toBN(this).lte(toBN(other))}gt(other){return toBN(this).gt(toBN(other))}gte(other){return toBN(this).gte(toBN(other))}isNegative(){return this._hex[0]==="-"}isZero(){return toBN(this).isZero()}toNumber(){try{return toBN(this).toNumber()}catch(error){throwFault("overflow","toNumber",this.toString())}return null}toBigInt(){try{return BigInt(this.toString())}catch(e){}return logger$1.throwError("this platform does not support BigInt",Logger.errors.UNSUPPORTED_OPERATION,{value:this.toString()})}toString(){if(arguments.length>0){if(arguments[0]===10){if(!_warnedToStringRadix){_warnedToStringRadix=true;logger$1.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")}}else if(arguments[0]===16){logger$1.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",Logger.errors.UNEXPECTED_ARGUMENT,{})}else{logger$1.throwError("BigNumber.toString does not accept parameters",Logger.errors.UNEXPECTED_ARGUMENT,{})}}return toBN(this).toString(10)}toHexString(){return this._hex}toJSON(key){return{type:"BigNumber",hex:this.toHexString()}}static from(value){if(value instanceof BigNumber){return value}if(typeof value==="string"){if(value.match(/^-?0x[0-9a-f]+$/i)){return new BigNumber(_constructorGuard,toHex(value))}if(value.match(/^-?[0-9]+$/)){return new BigNumber(_constructorGuard,toHex(new BN(value)))}return logger$1.throwArgumentError("invalid BigNumber string","value",value)}if(typeof value==="number"){if(value%1){throwFault("underflow","BigNumber.from",value)}if(value>=MAX_SAFE||value<=-MAX_SAFE){throwFault("overflow","BigNumber.from",value)}return BigNumber.from(String(value))}const anyValue=value;if(typeof anyValue==="bigint"){return BigNumber.from(anyValue.toString())}if(isBytes(anyValue)){return BigNumber.from(hexlify(anyValue))}if(anyValue){if(anyValue.toHexString){const hex=anyValue.toHexString();if(typeof hex==="string"){return BigNumber.from(hex)}}else{let hex=anyValue._hex;if(hex==null&&anyValue.type==="BigNumber"){hex=anyValue.hex}if(typeof hex==="string"){if(isHexString(hex)||hex[0]==="-"&&isHexString(hex.substring(1))){return BigNumber.from(hex)}}}}return logger$1.throwArgumentError("invalid BigNumber value","value",value)}static isBigNumber(value){return!!(value&&value._isBigNumber)}}function toHex(value){if(typeof value!=="string"){return toHex(value.toString(16))}if(value[0]==="-"){value=value.substring(1);if(value[0]==="-"){logger$1.throwArgumentError("invalid hex","value",value)}value=toHex(value);if(value==="0x00"){return value}return"-"+value}if(value.substring(0,2)!=="0x"){value="0x"+value}if(value==="0x"){return"0x00"}if(value.length%2){value="0x0"+value.substring(2)}while(value.length>4&&value.substring(0,4)==="0x00"){value="0x"+value.substring(4)}return value}function toBigNumber(value){return BigNumber.from(toHex(value))}function toBN(value){const hex=BigNumber.from(value).toHexString();if(hex[0]==="-"){return new BN("-"+hex.substring(3),16)}return new BN(hex.substring(2),16)}function throwFault(fault,operation,value){const params={fault:fault,operation:operation};if(value!=null){params.value=value}return logger$1.throwError(fault,Logger.errors.NUMERIC_FAULT,params)}function _base36To16(value){return new BN(value,36).toString(16)}function _base16To36(value){return new BN(value,16).toString(36)}"use strict";const logger$2=new Logger(version$2);const _constructorGuard$1={};const Zero=BigNumber.from(0);const NegativeOne=BigNumber.from(-1);function throwFault$1(message,fault,operation,value){const params={fault:fault,operation:operation};if(value!==undefined){params.value=value}return logger$2.throwError(message,Logger.errors.NUMERIC_FAULT,params)}let zeros="0";while(zeros.length<256){zeros+=zeros}function getMultiplier(decimals){if(typeof decimals!=="number"){try{decimals=BigNumber.from(decimals).toNumber()}catch(e){}}if(typeof decimals==="number"&&decimals>=0&&decimals<=256&&!(decimals%1)){return"1"+zeros.substring(0,decimals)}return logger$2.throwArgumentError("invalid decimal size","decimals",decimals)}function formatFixed(value,decimals){if(decimals==null){decimals=0}const multiplier=getMultiplier(decimals);value=BigNumber.from(value);const negative=value.lt(Zero);if(negative){value=value.mul(NegativeOne)}let fraction=value.mod(multiplier).toString();while(fraction.length<multiplier.length-1){fraction="0"+fraction}fraction=fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];const whole=value.div(multiplier).toString();value=whole+"."+fraction;if(negative){value="-"+value}return value}function parseFixed(value,decimals){if(decimals==null){decimals=0}const multiplier=getMultiplier(decimals);if(typeof value!=="string"||!value.match(/^-?[0-9.,]+$/)){logger$2.throwArgumentError("invalid decimal value","value",value)}if(multiplier.length-1===0){return BigNumber.from(value)}const negative=value.substring(0,1)==="-";if(negative){value=value.substring(1)}if(value==="."){logger$2.throwArgumentError("missing value","value",value)}const comps=value.split(".");if(comps.length>2){logger$2.throwArgumentError("too many decimal points","value",value)}let whole=comps[0],fraction=comps[1];if(!whole){whole="0"}if(!fraction){fraction="0"}if(fraction.length>multiplier.length-1){throwFault$1("fractional component exceeds decimals","underflow","parseFixed")}while(fraction.length<multiplier.length-1){fraction+="0"}const wholeValue=BigNumber.from(whole);const fractionValue=BigNumber.from(fraction);let wei=wholeValue.mul(multiplier).add(fractionValue);if(negative){wei=wei.mul(NegativeOne)}return wei}class FixedFormat{constructor(constructorGuard,signed,width,decimals){if(constructorGuard!==_constructorGuard$1){logger$2.throwError("cannot use FixedFormat constructor; use FixedFormat.from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new FixedFormat"})}this.signed=signed;this.width=width;this.decimals=decimals;this.name=(signed?"":"u")+"fixed"+String(width)+"x"+String(decimals);this._multiplier=getMultiplier(decimals);Object.freeze(this)}static from(value){if(value instanceof FixedFormat){return value}let signed=true;let width=128;let decimals=18;if(typeof value==="string"){if(value==="fixed"){}else if(value==="ufixed"){signed=false}else if(value!=null){const match=value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);if(!match){logger$2.throwArgumentError("invalid fixed format","format",value)}signed=match[1]!=="u";width=parseInt(match[2]);decimals=parseInt(match[3])}}else if(value){const check=(key,type,defaultValue)=>{if(value[key]==null){return defaultValue}if(typeof value[key]!==type){logger$2.throwArgumentError("invalid fixed format ("+key+" not "+type+")","format."+key,value[key])}return value[key]};signed=check("signed","boolean",signed);width=check("width","number",width);decimals=check("decimals","number",decimals)}if(width%8){logger$2.throwArgumentError("invalid fixed format width (not byte aligned)","format.width",width)}if(decimals>80){logger$2.throwArgumentError("invalid fixed format (decimals too large)","format.decimals",decimals)}return new FixedFormat(_constructorGuard$1,signed,width,decimals)}}class FixedNumber{constructor(constructorGuard,hex,value,format){logger$2.checkNew(new.target,FixedNumber);if(constructorGuard!==_constructorGuard$1){logger$2.throwError("cannot use FixedNumber constructor; use FixedNumber.from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new FixedFormat"})}this.format=format;this._hex=hex;this._value=value;this._isFixedNumber=true;Object.freeze(this)}_checkFormat(other){if(this.format.name!==other.format.name){logger$2.throwArgumentError("incompatible format; use fixedNumber.toFormat","other",other)}}addUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.add(b),this.format.decimals,this.format)}subUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.sub(b),this.format.decimals,this.format)}mulUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier),this.format.decimals,this.format)}divUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b),this.format.decimals,this.format)}floor(){let comps=this.toString().split(".");let result=FixedNumber.from(comps[0],this.format);const hasFraction=!comps[1].match(/^(0*)$/);if(this.isNegative()&&hasFraction){result=result.subUnsafe(ONE)}return result}ceiling(){let comps=this.toString().split(".");let result=FixedNumber.from(comps[0],this.format);const hasFraction=!comps[1].match(/^(0*)$/);if(!this.isNegative()&&hasFraction){result=result.addUnsafe(ONE)}return result}round(decimals){if(decimals==null){decimals=0}let comps=this.toString().split(".");if(decimals<0||decimals>80||decimals%1){logger$2.throwArgumentError("invalid decimal count","decimals",decimals)}if(comps[1].length<=decimals){return this}const factor=FixedNumber.from("1"+zeros.substring(0,decimals));return this.mulUnsafe(factor).addUnsafe(BUMP).floor().divUnsafe(factor)}isZero(){return this._value==="0.0"}isNegative(){return this._value[0]==="-"}toString(){return this._value}toHexString(width){if(width==null){return this._hex}if(width%8){logger$2.throwArgumentError("invalid byte width","width",width)}const hex=BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();return hexZeroPad(hex,width/8)}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(format){return FixedNumber.fromString(this._value,format)}static fromValue(value,decimals,format){if(format==null&&decimals!=null&&!isBigNumberish(decimals)){format=decimals;decimals=null}if(decimals==null){decimals=0}if(format==null){format="fixed"}return FixedNumber.fromString(formatFixed(value,decimals),FixedFormat.from(format))}static fromString(value,format){if(format==null){format="fixed"}const fixedFormat=FixedFormat.from(format);const numeric=parseFixed(value,fixedFormat.decimals);if(!fixedFormat.signed&&numeric.lt(Zero)){throwFault$1("unsigned value cannot be negative","overflow","value",value)}let hex=null;if(fixedFormat.signed){hex=numeric.toTwos(fixedFormat.width).toHexString()}else{hex=numeric.toHexString();hex=hexZeroPad(hex,fixedFormat.width/8)}const decimal=formatFixed(numeric,fixedFormat.decimals);return new FixedNumber(_constructorGuard$1,hex,decimal,fixedFormat)}static fromBytes(value,format){if(format==null){format="fixed"}const fixedFormat=FixedFormat.from(format);if(arrayify(value).length>fixedFormat.width/8){throw new Error("overflow")}let numeric=BigNumber.from(value);if(fixedFormat.signed){numeric=numeric.fromTwos(fixedFormat.width)}const hex=numeric.toTwos((fixedFormat.signed?0:1)+fixedFormat.width).toHexString();const decimal=formatFixed(numeric,fixedFormat.decimals);return new FixedNumber(_constructorGuard$1,hex,decimal,fixedFormat)}static from(value,format){if(typeof value==="string"){return FixedNumber.fromString(value,format)}if(isBytes(value)){return FixedNumber.fromBytes(value,format)}try{return FixedNumber.fromValue(value,0,format)}catch(error){if(error.code!==Logger.errors.INVALID_ARGUMENT){throw error}}return logger$2.throwArgumentError("invalid FixedNumber value","value",value)}static isFixedNumber(value){return!!(value&&value._isFixedNumber)}}const ONE=FixedNumber.from(1);const BUMP=FixedNumber.from("0.5");const version$3="properties/5.1.0";"use strict";var __awaiter=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$3=new Logger(version$3);function defineReadOnly(object,name,value){Object.defineProperty(object,name,{enumerable:true,value:value,writable:false})}function getStatic(ctor,key){for(let i=0;i<32;i++){if(ctor[key]){return ctor[key]}if(!ctor.prototype||typeof ctor.prototype!=="object"){break}ctor=Object.getPrototypeOf(ctor.prototype).constructor}return null}function resolveProperties(object){return __awaiter(this,void 0,void 0,function*(){const promises=Object.keys(object).map(key=>{const value=object[key];return Promise.resolve(value).then(v=>({key:key,value:v}))});const results=yield Promise.all(promises);return results.reduce((accum,result)=>{accum[result.key]=result.value;return accum},{})})}function checkProperties(object,properties){if(!object||typeof object!=="object"){logger$3.throwArgumentError("invalid object","object",object)}Object.keys(object).forEach(key=>{if(!properties[key]){logger$3.throwArgumentError("invalid object key - "+key,"transaction:"+key,object)}})}function shallowCopy(object){const result={};for(const key in object){result[key]=object[key]}return result}const opaque={bigint:true,boolean:true,function:true,number:true,string:true};function _isFrozen(object){if(object===undefined||object===null||opaque[typeof object]){return true}if(Array.isArray(object)||typeof object==="object"){if(!Object.isFrozen(object)){return false}const keys=Object.keys(object);for(let i=0;i<keys.length;i++){if(!_isFrozen(object[keys[i]])){return false}}return true}return logger$3.throwArgumentError(`Cannot deepCopy ${typeof object}`,"object",object)}function _deepCopy(object){if(_isFrozen(object)){return object}if(Array.isArray(object)){return Object.freeze(object.map(item=>deepCopy(item)))}if(typeof object==="object"){const result={};for(const key in object){const value=object[key];if(value===undefined){continue}defineReadOnly(result,key,deepCopy(value))}return result}return logger$3.throwArgumentError(`Cannot deepCopy ${typeof object}`,"object",object)}function deepCopy(object){return _deepCopy(object)}class Description{constructor(info){for(const key in info){this[key]=deepCopy(info[key])}}}const version$4="abi/5.1.2";"use strict";const logger$4=new Logger(version$4);const _constructorGuard$2={};let ModifiersBytes={calldata:true,memory:true,storage:true};let ModifiersNest={calldata:true,memory:true};function checkModifier(type,name){if(type==="bytes"||type==="string"){if(ModifiersBytes[name]){return true}}else if(type==="address"){if(name==="payable"){return true}}else if(type.indexOf("[")>=0||type==="tuple"){if(ModifiersNest[name]){return true}}if(ModifiersBytes[name]||name==="payable"){logger$4.throwArgumentError("invalid modifier","name",name)}return false}function parseParamType(param,allowIndexed){let originalParam=param;function throwError(i){logger$4.throwArgumentError(`unexpected character at position ${i}`,"param",param)}param=param.replace(/\s/g," ");function newNode(parent){let node={type:"",name:"",parent:parent,state:{allowType:true}};if(allowIndexed){node.indexed=false}return node}let parent={type:"",name:"",state:{allowType:true}};let node=parent;for(let i=0;i<param.length;i++){let c=param[i];switch(c){case"(":if(node.state.allowType&&node.type===""){node.type="tuple"}else if(!node.state.allowParams){throwError(i)}node.state.allowType=false;node.type=verifyType(node.type);node.components=[newNode(node)];node=node.components[0];break;case")":delete node.state;if(node.name==="indexed"){if(!allowIndexed){throwError(i)}node.indexed=true;node.name=""}if(checkModifier(node.type,node.name)){node.name=""}node.type=verifyType(node.type);let child=node;node=node.parent;if(!node){throwError(i)}delete child.parent;node.state.allowParams=false;node.state.allowName=true;node.state.allowArray=true;break;case",":delete node.state;if(node.name==="indexed"){if(!allowIndexed){throwError(i)}node.indexed=true;node.name=""}if(checkModifier(node.type,node.name)){node.name=""}node.type=verifyType(node.type);let sibling=newNode(node.parent);node.parent.components.push(sibling);delete node.parent;node=sibling;break;case" ":if(node.state.allowType){if(node.type!==""){node.type=verifyType(node.type);delete node.state.allowType;node.state.allowName=true;node.state.allowParams=true}}if(node.state.allowName){if(node.name!==""){if(node.name==="indexed"){if(!allowIndexed){throwError(i)}if(node.indexed){throwError(i)}node.indexed=true;node.name=""}else if(checkModifier(node.type,node.name)){node.name=""}else{node.state.allowName=false}}}break;case"[":if(!node.state.allowArray){throwError(i)}node.type+=c;node.state.allowArray=false;node.state.allowName=false;node.state.readArray=true;break;case"]":if(!node.state.readArray){throwError(i)}node.type+=c;node.state.readArray=false;node.state.allowArray=true;node.state.allowName=true;break;default:if(node.state.allowType){node.type+=c;node.state.allowParams=true;node.state.allowArray=true}else if(node.state.allowName){node.name+=c;delete node.state.allowArray}else if(node.state.readArray){node.type+=c}else{throwError(i)}}}if(node.parent){logger$4.throwArgumentError("unexpected eof","param",param)}delete parent.state;if(node.name==="indexed"){if(!allowIndexed){throwError(originalParam.length-7)}if(node.indexed){throwError(originalParam.length-7)}node.indexed=true;node.name=""}else if(checkModifier(node.type,node.name)){node.name=""}parent.type=verifyType(parent.type);return parent}function populate(object,params){for(let key in params){defineReadOnly(object,key,params[key])}}const FormatTypes=Object.freeze({sighash:"sighash",minimal:"minimal",full:"full",json:"json"});const paramTypeArray=new RegExp(/^(.*)\[([0-9]*)\]$/);class ParamType{constructor(constructorGuard,params){if(constructorGuard!==_constructorGuard$2){logger$4.throwError("use fromString",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new ParamType()"})}populate(this,params);let match=this.type.match(paramTypeArray);if(match){populate(this,{arrayLength:parseInt(match[2]||"-1"),arrayChildren:ParamType.fromObject({type:match[1],components:this.components}),baseType:"array"})}else{populate(this,{arrayLength:null,arrayChildren:null,baseType:this.components!=null?"tuple":this.type})}this._isParamType=true;Object.freeze(this)}format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){let result={type:this.baseType==="tuple"?"tuple":this.type,name:this.name||undefined};if(typeof this.indexed==="boolean"){result.indexed=this.indexed}if(this.components){result.components=this.components.map(comp=>JSON.parse(comp.format(format)))}return JSON.stringify(result)}let result="";if(this.baseType==="array"){result+=this.arrayChildren.format(format);result+="["+(this.arrayLength<0?"":String(this.arrayLength))+"]"}else{if(this.baseType==="tuple"){if(format!==FormatTypes.sighash){result+=this.type}result+="("+this.components.map(comp=>comp.format(format)).join(format===FormatTypes.full?", ":",")+")"}else{result+=this.type}}if(format!==FormatTypes.sighash){if(this.indexed===true){result+=" indexed"}if(format===FormatTypes.full&&this.name){result+=" "+this.name}}return result}static from(value,allowIndexed){if(typeof value==="string"){return ParamType.fromString(value,allowIndexed)}return ParamType.fromObject(value)}static fromObject(value){if(ParamType.isParamType(value)){return value}return new ParamType(_constructorGuard$2,{name:value.name||null,type:verifyType(value.type),indexed:value.indexed==null?null:!!value.indexed,components:value.components?value.components.map(ParamType.fromObject):null})}static fromString(value,allowIndexed){function ParamTypify(node){return ParamType.fromObject({name:node.name,type:node.type,indexed:node.indexed,components:node.components})}return ParamTypify(parseParamType(value,!!allowIndexed))}static isParamType(value){return!!(value!=null&&value._isParamType)}}function parseParams(value,allowIndex){return splitNesting(value).map(param=>ParamType.fromString(param,allowIndex))}class Fragment{constructor(constructorGuard,params){if(constructorGuard!==_constructorGuard$2){logger$4.throwError("use a static from method",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new Fragment()"})}populate(this,params);this._isFragment=true;Object.freeze(this)}static from(value){if(Fragment.isFragment(value)){return value}if(typeof value==="string"){return Fragment.fromString(value)}return Fragment.fromObject(value)}static fromObject(value){if(Fragment.isFragment(value)){return value}switch(value.type){case"function":return FunctionFragment.fromObject(value);case"event":return EventFragment.fromObject(value);case"constructor":return ConstructorFragment.fromObject(value);case"error":case"fallback":case"receive":return null}return logger$4.throwArgumentError("invalid fragment object","value",value)}static fromString(value){value=value.replace(/\s/g," ");value=value.replace(/\(/g," (").replace(/\)/g,") ").replace(/\s+/g," ");value=value.trim();if(value.split(" ")[0]==="event"){return EventFragment.fromString(value.substring(5).trim())}else if(value.split(" ")[0]==="function"){return FunctionFragment.fromString(value.substring(8).trim())}else if(value.split("(")[0].trim()==="constructor"){return ConstructorFragment.fromString(value.trim())}return logger$4.throwArgumentError("unsupported fragment","value",value)}static isFragment(value){return!!(value&&value._isFragment)}}class EventFragment extends Fragment{format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){return JSON.stringify({type:"event",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}let result="";if(format!==FormatTypes.sighash){result+="event "}result+=this.name+"("+this.inputs.map(input=>input.format(format)).join(format===FormatTypes.full?", ":",")+") ";if(format!==FormatTypes.sighash){if(this.anonymous){result+="anonymous "}}return result.trim()}static from(value){if(typeof value==="string"){return EventFragment.fromString(value)}return EventFragment.fromObject(value)}static fromObject(value){if(EventFragment.isEventFragment(value)){return value}if(value.type!=="event"){logger$4.throwArgumentError("invalid event object","value",value)}const params={name:verifyIdentifier(value.name),anonymous:value.anonymous,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],type:"event"};return new EventFragment(_constructorGuard$2,params)}static fromString(value){let match=value.match(regexParen);if(!match){logger$4.throwArgumentError("invalid event string","value",value)}let anonymous=false;match[3].split(" ").forEach(modifier=>{switch(modifier.trim()){case"anonymous":anonymous=true;break;case"":break;default:logger$4.warn("unknown modifier: "+modifier)}});return EventFragment.fromObject({name:match[1].trim(),anonymous:anonymous,inputs:parseParams(match[2],true),type:"event"})}static isEventFragment(value){return value&&value._isFragment&&value.type==="event"}}function parseGas(value,params){params.gas=null;let comps=value.split("@");if(comps.length!==1){if(comps.length>2){logger$4.throwArgumentError("invalid human-readable ABI signature","value",value)}if(!comps[1].match(/^[0-9]+$/)){logger$4.throwArgumentError("invalid human-readable ABI signature gas","value",value)}params.gas=BigNumber.from(comps[1]);return comps[0]}return value}function parseModifiers(value,params){params.constant=false;params.payable=false;params.stateMutability="nonpayable";value.split(" ").forEach(modifier=>{switch(modifier.trim()){case"constant":params.constant=true;break;case"payable":params.payable=true;params.stateMutability="payable";break;case"nonpayable":params.payable=false;params.stateMutability="nonpayable";break;case"pure":params.constant=true;params.stateMutability="pure";break;case"view":params.constant=true;params.stateMutability="view";break;case"external":case"public":case"":break;default:console.log("unknown modifier: "+modifier)}})}function verifyState(value){let result={constant:false,payable:true,stateMutability:"payable"};if(value.stateMutability!=null){result.stateMutability=value.stateMutability;result.constant=result.stateMutability==="view"||result.stateMutability==="pure";if(value.constant!=null){if(!!value.constant!==result.constant){logger$4.throwArgumentError("cannot have constant function with mutability "+result.stateMutability,"value",value)}}result.payable=result.stateMutability==="payable";if(value.payable!=null){if(!!value.payable!==result.payable){logger$4.throwArgumentError("cannot have payable function with mutability "+result.stateMutability,"value",value)}}}else if(value.payable!=null){result.payable=!!value.payable;if(value.constant==null&&!result.payable&&value.type!=="constructor"){logger$4.throwArgumentError("unable to determine stateMutability","value",value)}result.constant=!!value.constant;if(result.constant){result.stateMutability="view"}else{result.stateMutability=result.payable?"payable":"nonpayable"}if(result.payable&&result.constant){logger$4.throwArgumentError("cannot have constant payable function","value",value)}}else if(value.constant!=null){result.constant=!!value.constant;result.payable=!result.constant;result.stateMutability=result.constant?"view":"payable"}else if(value.type!=="constructor"){logger$4.throwArgumentError("unable to determine stateMutability","value",value)}return result}class ConstructorFragment extends Fragment{format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){return JSON.stringify({type:"constructor",stateMutability:this.stateMutability!=="nonpayable"?this.stateMutability:undefined,payable:this.payable,gas:this.gas?this.gas.toNumber():undefined,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}if(format===FormatTypes.sighash){logger$4.throwError("cannot format a constructor for sighash",Logger.errors.UNSUPPORTED_OPERATION,{operation:"format(sighash)"})}let result="constructor("+this.inputs.map(input=>input.format(format)).join(format===FormatTypes.full?", ":",")+") ";if(this.stateMutability&&this.stateMutability!=="nonpayable"){result+=this.stateMutability+" "}return result.trim()}static from(value){if(typeof value==="string"){return ConstructorFragment.fromString(value)}return ConstructorFragment.fromObject(value)}static fromObject(value){if(ConstructorFragment.isConstructorFragment(value)){return value}if(value.type!=="constructor"){logger$4.throwArgumentError("invalid constructor object","value",value)}let state=verifyState(value);if(state.constant){logger$4.throwArgumentError("constructor cannot be constant","value",value)}const params={name:null,type:value.type,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],payable:state.payable,stateMutability:state.stateMutability,gas:value.gas?BigNumber.from(value.gas):null};return new ConstructorFragment(_constructorGuard$2,params)}static fromString(value){let params={type:"constructor"};value=parseGas(value,params);let parens=value.match(regexParen);if(!parens||parens[1].trim()!=="constructor"){logger$4.throwArgumentError("invalid constructor string","value",value)}params.inputs=parseParams(parens[2].trim(),false);parseModifiers(parens[3].trim(),params);return ConstructorFragment.fromObject(params)}static isConstructorFragment(value){return value&&value._isFragment&&value.type==="constructor"}}class FunctionFragment extends ConstructorFragment{format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){return JSON.stringify({type:"function",name:this.name,constant:this.constant,stateMutability:this.stateMutability!=="nonpayable"?this.stateMutability:undefined,payable:this.payable,gas:this.gas?this.gas.toNumber():undefined,inputs:this.inputs.map(input=>JSON.parse(input.format(format))),outputs:this.outputs.map(output=>JSON.parse(output.format(format)))})}let result="";if(format!==FormatTypes.sighash){result+="function "}result+=this.name+"("+this.inputs.map(input=>input.format(format)).join(format===FormatTypes.full?", ":",")+") ";if(format!==FormatTypes.sighash){if(this.stateMutability){if(this.stateMutability!=="nonpayable"){result+=this.stateMutability+" "}}else if(this.constant){result+="view "}if(this.outputs&&this.outputs.length){result+="returns ("+this.outputs.map(output=>output.format(format)).join(", ")+") "}if(this.gas!=null){result+="@"+this.gas.toString()+" "}}return result.trim()}static from(value){if(typeof value==="string"){return FunctionFragment.fromString(value)}return FunctionFragment.fromObject(value)}static fromObject(value){if(FunctionFragment.isFunctionFragment(value)){return value}if(value.type!=="function"){logger$4.throwArgumentError("invalid function object","value",value)}let state=verifyState(value);const params={type:value.type,name:verifyIdentifier(value.name),constant:state.constant,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],outputs:value.outputs?value.outputs.map(ParamType.fromObject):[],payable:state.payable,stateMutability:state.stateMutability,gas:value.gas?BigNumber.from(value.gas):null};return new FunctionFragment(_constructorGuard$2,params)}static fromString(value){let params={type:"function"};value=parseGas(value,params);let comps=value.split(" returns ");if(comps.length>2){logger$4.throwArgumentError("invalid function string","value",value)}let parens=comps[0].match(regexParen);if(!parens){logger$4.throwArgumentError("invalid function signature","value",value)}params.name=parens[1].trim();if(params.name){verifyIdentifier(params.name)}params.inputs=parseParams(parens[2],false);parseModifiers(parens[3].trim(),params);if(comps.length>1){let returns=comps[1].match(regexParen);if(returns[1].trim()!=""||returns[3].trim()!=""){logger$4.throwArgumentError("unexpected tokens","value",value)}params.outputs=parseParams(returns[2],false)}else{params.outputs=[]}return FunctionFragment.fromObject(params)}static isFunctionFragment(value){return value&&value._isFragment&&value.type==="function"}}function verifyType(type){if(type.match(/^uint($|[^1-9])/)){type="uint256"+type.substring(4)}else if(type.match(/^int($|[^1-9])/)){type="int256"+type.substring(3)}return type}const regexIdentifier=new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");function verifyIdentifier(value){if(!value||!value.match(regexIdentifier)){logger$4.throwArgumentError(`invalid identifier "${value}"`,"value",value)}return value}const regexParen=new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");function splitNesting(value){value=value.trim();let result=[];let accum="";let depth=0;for(let offset=0;offset<value.length;offset++){let c=value[offset];if(c===","&&depth===0){result.push(accum);accum=""}else{accum+=c;if(c==="("){depth++}else if(c===")"){depth--;if(depth===-1){logger$4.throwArgumentError("unbalanced parenthesis","value",value)}}}}if(accum){result.push(accum)}return result}"use strict";const logger$5=new Logger(version$4);function checkResultErrors(result){const errors=[];const checkErrors=function(path,object){if(!Array.isArray(object)){return}for(let key in object){const childPath=path.slice();childPath.push(key);try{checkErrors(childPath,object[key])}catch(error){errors.push({path:childPath,error:error})}}};checkErrors([],result);return errors}class Coder{constructor(name,type,localName,dynamic){this.name=name;this.type=type;this.localName=localName;this.dynamic=dynamic}_throwError(message,value){logger$5.throwArgumentError(message,this.localName,value)}}class Writer{constructor(wordSize){defineReadOnly(this,"wordSize",wordSize||32);this._data=[];this._dataLength=0;this._padding=new Uint8Array(wordSize)}get data(){return hexConcat(this._data)}get length(){return this._dataLength}_writeData(data){this._data.push(data);this._dataLength+=data.length;return data.length}appendWriter(writer){return this._writeData(concat(writer._data))}writeBytes(value){let bytes=arrayify(value);const paddingOffset=bytes.length%this.wordSize;if(paddingOffset){bytes=concat([bytes,this._padding.slice(paddingOffset)])}return this._writeData(bytes)}_getValue(value){let bytes=arrayify(BigNumber.from(value));if(bytes.length>this.wordSize){logger$5.throwError("value out-of-bounds",Logger.errors.BUFFER_OVERRUN,{length:this.wordSize,offset:bytes.length})}if(bytes.length%this.wordSize){bytes=concat([this._padding.slice(bytes.length%this.wordSize),bytes])}return bytes}writeValue(value){return this._writeData(this._getValue(value))}writeUpdatableValue(){const offset=this._data.length;this._data.push(this._padding);this._dataLength+=this.wordSize;return value=>{this._data[offset]=this._getValue(value)}}}class Reader{constructor(data,wordSize,coerceFunc,allowLoose){defineReadOnly(this,"_data",arrayify(data));defineReadOnly(this,"wordSize",wordSize||32);defineReadOnly(this,"_coerceFunc",coerceFunc);defineReadOnly(this,"allowLoose",allowLoose);this._offset=0}get data(){return hexlify(this._data)}get consumed(){return this._offset}static coerce(name,value){let match=name.match("^u?int([0-9]+)$");if(match&&parseInt(match[1])<=48){value=value.toNumber()}return value}coerce(name,value){if(this._coerceFunc){return this._coerceFunc(name,value)}return Reader.coerce(name,value)}_peekBytes(offset,length,loose){let alignedLength=Math.ceil(length/this.wordSize)*this.wordSize;if(this._offset+alignedLength>this._data.length){if(this.allowLoose&&loose&&this._offset+length<=this._data.length){alignedLength=length}else{logger$5.throwError("data out-of-bounds",Logger.errors.BUFFER_OVERRUN,{length:this._data.length,offset:this._offset+alignedLength})}}return this._data.slice(this._offset,this._offset+alignedLength)}subReader(offset){return new Reader(this._data.slice(this._offset+offset),this.wordSize,this._coerceFunc,this.allowLoose)}readBytes(length,loose){let bytes=this._peekBytes(0,length,!!loose);this._offset+=bytes.length;return bytes.slice(0,length)}readValue(){return BigNumber.from(this.readBytes(this.wordSize))}}var sha3=createCommonjsModule(function(module){(function(){"use strict";var root=typeof window==="object"?window:{};var NODE_JS=!root.JS_SHA3_NO_NODE_JS&&typeof process==="object"&&process.versions&&process.versions.node;if(NODE_JS){root=commonjsGlobal}var COMMON_JS=!root.JS_SHA3_NO_COMMON_JS&&"object"==="object"&&module.exports;var HEX_CHARS="0123456789abcdef".split("");var SHAKE_PADDING=[31,7936,2031616,520093696];var KECCAK_PADDING=[1,256,65536,16777216];var PADDING=[6,1536,393216,100663296];var SHIFT=[0,8,16,24];var RC=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648];var BITS=[224,256,384,512];var SHAKE_BITS=[128,256];var OUTPUT_TYPES=["hex","buffer","arrayBuffer","array"];var createOutputMethod=function(bits,padding,outputType){return function(message){return new Keccak(bits,padding,bits).update(message)[outputType]()}};var createShakeOutputMethod=function(bits,padding,outputType){return function(message,outputBits){return new Keccak(bits,padding,outputBits).update(message)[outputType]()}};var createMethod=function(bits,padding){var method=createOutputMethod(bits,padding,"hex");method.create=function(){return new Keccak(bits,padding,bits)};method.update=function(message){return method.create().update(message)};for(var i=0;i<OUTPUT_TYPES.length;++i){var type=OUTPUT_TYPES[i];method[type]=createOutputMethod(bits,padding,type)}return method};var createShakeMethod=function(bits,padding){var method=createShakeOutputMethod(bits,padding,"hex");method.create=function(outputBits){return new Keccak(bits,padding,outputBits)};method.update=function(message,outputBits){return method.create(outputBits).update(message)};for(var i=0;i<OUTPUT_TYPES.length;++i){var type=OUTPUT_TYPES[i];method[type]=createShakeOutputMethod(bits,padding,type)}return method};var algorithms=[{name:"keccak",padding:KECCAK_PADDING,bits:BITS,createMethod:createMethod},{name:"sha3",padding:PADDING,bits:BITS,createMethod:createMethod},{name:"shake",padding:SHAKE_PADDING,bits:SHAKE_BITS,createMethod:createShakeMethod}];var methods={},methodNames=[];for(var i=0;i<algorithms.length;++i){var algorithm=algorithms[i];var bits=algorithm.bits;for(var j=0;j<bits.length;++j){var methodName=algorithm.name+"_"+bits[j];methodNames.push(methodName);methods[methodName]=algorithm.createMethod(bits[j],algorithm.padding)}}function Keccak(bits,padding,outputBits){this.blocks=[];this.s=[];this.padding=padding;this.outputBits=outputBits;this.reset=true;this.block=0;this.start=0;this.blockCount=1600-(bits<<1)>>5;this.byteCount=this.blockCount<<2;this.outputBlocks=outputBits>>5;this.extraBytes=(outputBits&31)>>3;for(var i=0;i<50;++i){this.s[i]=0}}Keccak.prototype.update=function(message){var notString=typeof message!=="string";if(notString&&message.constructor===ArrayBuffer){message=new Uint8Array(message)}var length=message.length,blocks=this.blocks,byteCount=this.byteCount,blockCount=this.blockCount,index=0,s=this.s,i,code;while(index<length){if(this.reset){this.reset=false;blocks[0]=this.block;for(i=1;i<blockCount+1;++i){blocks[i]=0}}if(notString){for(i=this.start;index<length&&i<byteCount;++index){blocks[i>>2]|=message[index]<<SHIFT[i++&3]}}else{for(i=this.start;index<length&&i<byteCount;++index){code=message.charCodeAt(index);if(code<128){blocks[i>>2]|=code<<SHIFT[i++&3]}else if(code<2048){blocks[i>>2]|=(192|code>>6)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}else if(code<55296||code>=57344){blocks[i>>2]|=(224|code>>12)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>6&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}else{code=65536+((code&1023)<<10|message.charCodeAt(++index)&1023);blocks[i>>2]|=(240|code>>18)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>12&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>6&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}}}this.lastByteIndex=i;if(i>=byteCount){this.start=i-byteCount;this.block=blocks[blockCount];for(i=0;i<blockCount;++i){s[i]^=blocks[i]}f(s);this.reset=true}else{this.start=i}}return this};Keccak.prototype.finalize=function(){var blocks=this.blocks,i=this.lastByteIndex,blockCount=this.blockCount,s=this.s;blocks[i>>2]|=this.padding[i&3];if(this.lastByteIndex===this.byteCount){blocks[0]=blocks[blockCount];for(i=1;i<blockCount+1;++i){blocks[i]=0}}blocks[blockCount-1]|=2147483648;for(i=0;i<blockCount;++i){s[i]^=blocks[i]}f(s)};Keccak.prototype.toString=Keccak.prototype.hex=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var hex="",block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){block=s[i];hex+=HEX_CHARS[block>>4&15]+HEX_CHARS[block&15]+HEX_CHARS[block>>12&15]+HEX_CHARS[block>>8&15]+HEX_CHARS[block>>20&15]+HEX_CHARS[block>>16&15]+HEX_CHARS[block>>28&15]+HEX_CHARS[block>>24&15]}if(j%blockCount===0){f(s);i=0}}if(extraBytes){block=s[i];if(extraBytes>0){hex+=HEX_CHARS[block>>4&15]+HEX_CHARS[block&15]}if(extraBytes>1){hex+=HEX_CHARS[block>>12&15]+HEX_CHARS[block>>8&15]}if(extraBytes>2){hex+=HEX_CHARS[block>>20&15]+HEX_CHARS[block>>16&15]}}return hex};Keccak.prototype.arrayBuffer=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var bytes=this.outputBits>>3;var buffer;if(extraBytes){buffer=new ArrayBuffer(outputBlocks+1<<2)}else{buffer=new ArrayBuffer(bytes)}var array=new Uint32Array(buffer);while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){array[j]=s[i]}if(j%blockCount===0){f(s)}}if(extraBytes){array[i]=s[i];buffer=buffer.slice(0,bytes)}return buffer};Keccak.prototype.buffer=Keccak.prototype.arrayBuffer;Keccak.prototype.digest=Keccak.prototype.array=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var array=[],offset,block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){offset=j<<2;block=s[i];array[offset]=block&255;array[offset+1]=block>>8&255;array[offset+2]=block>>16&255;array[offset+3]=block>>24&255}if(j%blockCount===0){f(s)}}if(extraBytes){offset=j<<2;block=s[i];if(extraBytes>0){array[offset]=block&255}if(extraBytes>1){array[offset+1]=block>>8&255}if(extraBytes>2){array[offset+2]=block>>16&255}}return array};var f=function(s){var h,l,n,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31,b32,b33,b34,b35,b36,b37,b38,b39,b40,b41,b42,b43,b44,b45,b46,b47,b48,b49;for(n=0;n<48;n+=2){c0=s[0]^s[10]^s[20]^s[30]^s[40];c1=s[1]^s[11]^s[21]^s[31]^s[41];c2=s[2]^s[12]^s[22]^s[32]^s[42];c3=s[3]^s[13]^s[23]^s[33]^s[43];c4=s[4]^s[14]^s[24]^s[34]^s[44];c5=s[5]^s[15]^s[25]^s[35]^s[45];c6=s[6]^s[16]^s[26]^s[36]^s[46];c7=s[7]^s[17]^s[27]^s[37]^s[47];c8=s[8]^s[18]^s[28]^s[38]^s[48];c9=s[9]^s[19]^s[29]^s[39]^s[49];h=c8^(c2<<1|c3>>>31);l=c9^(c3<<1|c2>>>31);s[0]^=h;s[1]^=l;s[10]^=h;s[11]^=l;s[20]^=h;s[21]^=l;s[30]^=h;s[31]^=l;s[40]^=h;s[41]^=l;h=c0^(c4<<1|c5>>>31);l=c1^(c5<<1|c4>>>31);s[2]^=h;s[3]^=l;s[12]^=h;s[13]^=l;s[22]^=h;s[23]^=l;s[32]^=h;s[33]^=l;s[42]^=h;s[43]^=l;h=c2^(c6<<1|c7>>>31);l=c3^(c7<<1|c6>>>31);s[4]^=h;s[5]^=l;s[14]^=h;s[15]^=l;s[24]^=h;s[25]^=l;s[34]^=h;s[35]^=l;s[44]^=h;s[45]^=l;h=c4^(c8<<1|c9>>>31);l=c5^(c9<<1|c8>>>31);s[6]^=h;s[7]^=l;s[16]^=h;s[17]^=l;s[26]^=h;s[27]^=l;s[36]^=h;s[37]^=l;s[46]^=h;s[47]^=l;h=c6^(c0<<1|c1>>>31);l=c7^(c1<<1|c0>>>31);s[8]^=h;s[9]^=l;s[18]^=h;s[19]^=l;s[28]^=h;s[29]^=l;s[38]^=h;s[39]^=l;s[48]^=h;s[49]^=l;b0=s[0];b1=s[1];b32=s[11]<<4|s[10]>>>28;b33=s[10]<<4|s[11]>>>28;b14=s[20]<<3|s[21]>>>29;b15=s[21]<<3|s[20]>>>29;b46=s[31]<<9|s[30]>>>23;b47=s[30]<<9|s[31]>>>23;b28=s[40]<<18|s[41]>>>14;b29=s[41]<<18|s[40]>>>14;b20=s[2]<<1|s[3]>>>31;b21=s[3]<<1|s[2]>>>31;b2=s[13]<<12|s[12]>>>20;b3=s[12]<<12|s[13]>>>20;b34=s[22]<<10|s[23]>>>22;b35=s[23]<<10|s[22]>>>22;b16=s[33]<<13|s[32]>>>19;b17=s[32]<<13|s[33]>>>19;b48=s[42]<<2|s[43]>>>30;b49=s[43]<<2|s[42]>>>30;b40=s[5]<<30|s[4]>>>2;b41=s[4]<<30|s[5]>>>2;b22=s[14]<<6|s[15]>>>26;b23=s[15]<<6|s[14]>>>26;b4=s[25]<<11|s[24]>>>21;b5=s[24]<<11|s[25]>>>21;b36=s[34]<<15|s[35]>>>17;b37=s[35]<<15|s[34]>>>17;b18=s[45]<<29|s[44]>>>3;b19=s[44]<<29|s[45]>>>3;b10=s[6]<<28|s[7]>>>4;b11=s[7]<<28|s[6]>>>4;b42=s[17]<<23|s[16]>>>9;b43=s[16]<<23|s[17]>>>9;b24=s[26]<<25|s[27]>>>7;b25=s[27]<<25|s[26]>>>7;b6=s[36]<<21|s[37]>>>11;b7=s[37]<<21|s[36]>>>11;b38=s[47]<<24|s[46]>>>8;b39=s[46]<<24|s[47]>>>8;b30=s[8]<<27|s[9]>>>5;b31=s[9]<<27|s[8]>>>5;b12=s[18]<<20|s[19]>>>12;b13=s[19]<<20|s[18]>>>12;b44=s[29]<<7|s[28]>>>25;b45=s[28]<<7|s[29]>>>25;b26=s[38]<<8|s[39]>>>24;b27=s[39]<<8|s[38]>>>24;b8=s[48]<<14|s[49]>>>18;b9=s[49]<<14|s[48]>>>18;s[0]=b0^~b2&b4;s[1]=b1^~b3&b5;s[10]=b10^~b12&b14;s[11]=b11^~b13&b15;s[20]=b20^~b22&b24;s[21]=b21^~b23&b25;s[30]=b30^~b32&b34;s[31]=b31^~b33&b35;s[40]=b40^~b42&b44;s[41]=b41^~b43&b45;s[2]=b2^~b4&b6;s[3]=b3^~b5&b7;s[12]=b12^~b14&b16;s[13]=b13^~b15&b17;s[22]=b22^~b24&b26;s[23]=b23^~b25&b27;s[32]=b32^~b34&b36;s[33]=b33^~b35&b37;s[42]=b42^~b44&b46;s[43]=b43^~b45&b47;s[4]=b4^~b6&b8;s[5]=b5^~b7&b9;s[14]=b14^~b16&b18;s[15]=b15^~b17&b19;s[24]=b24^~b26&b28;s[25]=b25^~b27&b29;s[34]=b34^~b36&b38;s[35]=b35^~b37&b39;s[44]=b44^~b46&b48;s[45]=b45^~b47&b49;s[6]=b6^~b8&b0;s[7]=b7^~b9&b1;s[16]=b16^~b18&b10;s[17]=b17^~b19&b11;s[26]=b26^~b28&b20;s[27]=b27^~b29&b21;s[36]=b36^~b38&b30;s[37]=b37^~b39&b31;s[46]=b46^~b48&b40;s[47]=b47^~b49&b41;s[8]=b8^~b0&b2;s[9]=b9^~b1&b3;s[18]=b18^~b10&b12;s[19]=b19^~b11&b13;s[28]=b28^~b20&b22;s[29]=b29^~b21&b23;s[38]=b38^~b30&b32;s[39]=b39^~b31&b33;s[48]=b48^~b40&b42;s[49]=b49^~b41&b43;s[0]^=RC[n];s[1]^=RC[n+1]}};if(COMMON_JS){module.exports=methods}else{for(var i=0;i<methodNames.length;++i){root[methodNames[i]]=methods[methodNames[i]]}}})()});"use strict";function keccak256(data){return"0x"+sha3.keccak_256(arrayify(data))}const version$5="rlp/5.1.0";"use strict";const logger$6=new Logger(version$5);function arrayifyInteger(value){const result=[];while(value){result.unshift(value&255);value>>=8}return result}function unarrayifyInteger(data,offset,length){let result=0;for(let i=0;i<length;i++){result=result*256+data[offset+i]}return result}function _encode(object){if(Array.isArray(object)){let payload=[];object.forEach(function(child){payload=payload.concat(_encode(child))});if(payload.length<=55){payload.unshift(192+payload.length);return payload}const length=arrayifyInteger(payload.length);length.unshift(247+length.length);return length.concat(payload)}if(!isBytesLike(object)){logger$6.throwArgumentError("RLP object must be BytesLike","object",object)}const data=Array.prototype.slice.call(arrayify(object));if(data.length===1&&data[0]<=127){return data}else if(data.length<=55){data.unshift(128+data.length);return data}const length=arrayifyInteger(data.length);length.unshift(183+length.length);return length.concat(data)}function encode(object){return hexlify(_encode(object))}function _decodeChildren(data,offset,childOffset,length){const result=[];while(childOffset<offset+1+length){const decoded=_decode(data,childOffset);result.push(decoded.result);childOffset+=decoded.consumed;if(childOffset>offset+1+length){logger$6.throwError("child data too short",Logger.errors.BUFFER_OVERRUN,{})}}return{consumed:1+length,result:result}}function _decode(data,offset){if(data.length===0){logger$6.throwError("data too short",Logger.errors.BUFFER_OVERRUN,{})}if(data[offset]>=248){const lengthLength=data[offset]-247;if(offset+1+lengthLength>data.length){logger$6.throwError("data short segment too short",Logger.errors.BUFFER_OVERRUN,{})}const length=unarrayifyInteger(data,offset+1,lengthLength);if(offset+1+lengthLength+length>data.length){logger$6.throwError("data long segment too short",Logger.errors.BUFFER_OVERRUN,{})}return _decodeChildren(data,offset,offset+1+lengthLength,lengthLength+length)}else if(data[offset]>=192){const length=data[offset]-192;if(offset+1+length>data.length){logger$6.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{})}return _decodeChildren(data,offset,offset+1,length)}else if(data[offset]>=184){const lengthLength=data[offset]-183;if(offset+1+lengthLength>data.length){logger$6.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{})}const length=unarrayifyInteger(data,offset+1,lengthLength);if(offset+1+lengthLength+length>data.length){logger$6.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{})}const result=hexlify(data.slice(offset+1+lengthLength,offset+1+lengthLength+length));return{consumed:1+lengthLength+length,result:result}}else if(data[offset]>=128){const length=data[offset]-128;if(offset+1+length>data.length){logger$6.throwError("data too short",Logger.errors.BUFFER_OVERRUN,{})}const result=hexlify(data.slice(offset+1,offset+1+length));return{consumed:1+length,result:result}}return{consumed:1,result:hexlify(data[offset])}}function decode(data){const bytes=arrayify(data);const decoded=_decode(bytes,0);if(decoded.consumed!==bytes.length){logger$6.throwArgumentError("invalid rlp data","data",data)}return decoded.result}var index=Object.freeze({__proto__:null,encode:encode,decode:decode});const version$6="address/5.1.0";"use strict";const logger$7=new Logger(version$6);function getChecksumAddress(address){if(!isHexString(address,20)){logger$7.throwArgumentError("invalid address","address",address)}address=address.toLowerCase();const chars=address.substring(2).split("");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=arrayify(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return"0x"+chars.join("")}const MAX_SAFE_INTEGER=9007199254740991;function log10(x){if(Math.log10){return Math.log10(x)}return Math.log(x)/Math.LN10}const ibanLookup={};for(let i=0;i<10;i++){ibanLookup[String(i)]=String(i)}for(let i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i)}const safeDigits=Math.floor(log10(MAX_SAFE_INTEGER));function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+"00";let expanded=address.split("").map(c=>{return ibanLookup[c]}).join("");while(expanded.length>=safeDigits){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum="0"+checksum}return checksum}function getAddress(address){let result=null;if(typeof address!=="string"){logger$7.throwArgumentError("invalid address","address",address)}if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(address.substring(0,2)!=="0x"){address="0x"+address}result=getChecksumAddress(address);if(address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&result!==address){logger$7.throwArgumentError("bad address checksum","address",address)}}else if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){if(address.substring(2,4)!==ibanChecksum(address)){logger$7.throwArgumentError("bad icap checksum","address",address)}result=_base36To16(address.substring(4));while(result.length<40){result="0"+result}result=getChecksumAddress("0x"+result)}else{logger$7.throwArgumentError("invalid address","address",address)}return result}function isAddress(address){try{getAddress(address);return true}catch(error){}return false}function getIcapAddress(address){let base36=_base16To36(getAddress(address).substring(2)).toUpperCase();while(base36.length<30){base36="0"+base36}return"XE"+ibanChecksum("XE00"+base36)+base36}function getContractAddress(transaction){let from=null;try{from=getAddress(transaction.from)}catch(error){logger$7.throwArgumentError("missing from address","transaction",transaction)}const nonce=stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));return getAddress(hexDataSlice(keccak256(encode([from,nonce])),12))}function getCreate2Address(from,salt,initCodeHash){if(hexDataLength(salt)!==32){logger$7.throwArgumentError("salt must be 32 bytes","salt",salt)}if(hexDataLength(initCodeHash)!==32){logger$7.throwArgumentError("initCodeHash must be 32 bytes","initCodeHash",initCodeHash)}return getAddress(hexDataSlice(keccak256(concat(["0xff",getAddress(from),salt,initCodeHash])),12))}"use strict";class AddressCoder extends Coder{constructor(localName){super("address","address",localName,false)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(writer,value){try{getAddress(value)}catch(error){this._throwError(error.message,value)}return writer.writeValue(value)}decode(reader){return getAddress(hexZeroPad(reader.readValue().toHexString(),20))}}"use strict";class AnonymousCoder extends Coder{constructor(coder){super(coder.name,coder.type,undefined,coder.dynamic);this.coder=coder}defaultValue(){return this.coder.defaultValue()}encode(writer,value){return this.coder.encode(writer,value)}decode(reader){return this.coder.decode(reader)}}"use strict";const logger$8=new Logger(version$4);function pack(writer,coders,values){let arrayValues=null;if(Array.isArray(values)){arrayValues=values}else if(values&&typeof values==="object"){let unique={};arrayValues=coders.map(coder=>{const name=coder.localName;if(!name){logger$8.throwError("cannot encode object for signature with missing names",Logger.errors.INVALID_ARGUMENT,{argument:"values",coder:coder,value:values})}if(unique[name]){logger$8.throwError("cannot encode object for signature with duplicate names",Logger.errors.INVALID_ARGUMENT,{argument:"values",coder:coder,value:values})}unique[name]=true;return values[name]})}else{logger$8.throwArgumentError("invalid tuple value","tuple",values)}if(coders.length!==arrayValues.length){logger$8.throwArgumentError("types/value length mismatch","tuple",values)}let staticWriter=new Writer(writer.wordSize);let dynamicWriter=new Writer(writer.wordSize);let updateFuncs=[];coders.forEach((coder,index)=>{let value=arrayValues[index];if(coder.dynamic){let dynamicOffset=dynamicWriter.length;coder.encode(dynamicWriter,value);let updateFunc=staticWriter.writeUpdatableValue();updateFuncs.push(baseOffset=>{updateFunc(baseOffset+dynamicOffset)})}else{coder.encode(staticWriter,value)}});updateFuncs.forEach(func=>{func(staticWriter.length)});let length=writer.appendWriter(staticWriter);length+=writer.appendWriter(dynamicWriter);return length}function unpack(reader,coders){let values=[];let baseReader=reader.subReader(0);coders.forEach(coder=>{let value=null;if(coder.dynamic){let offset=reader.readValue();let offsetReader=baseReader.subReader(offset.toNumber());try{value=coder.decode(offsetReader)}catch(error){if(error.code===Logger.errors.BUFFER_OVERRUN){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}else{try{value=coder.decode(reader)}catch(error){if(error.code===Logger.errors.BUFFER_OVERRUN){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}if(value!=undefined){values.push(value)}});const uniqueNames=coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name==="length"){name="_length"}if(values[name]!=null){return}const value=values[index];if(value instanceof Error){Object.defineProperty(values,name,{get:()=>{throw value}})}else{values[name]=value}});for(let i=0;i<values.length;i++){const value=values[i];if(value instanceof Error){Object.defineProperty(values,i,{get:()=>{throw value}})}}return Object.freeze(values)}class ArrayCoder extends Coder{constructor(coder,length,localName){const type=coder.type+"["+(length>=0?length:"")+"]";const dynamic=length===-1||coder.dynamic;super("array",type,localName,dynamic);this.coder=coder;this.length=length}defaultValue(){const defaultChild=this.coder.defaultValue();const result=[];for(let i=0;i<this.length;i++){result.push(defaultChild)}return result}encode(writer,value){if(!Array.isArray(value)){this._throwError("expected array value",value)}let count=this.length;if(count===-1){count=value.length;writer.writeValue(value.length)}logger$8.checkArgumentCount(value.length,count,"coder array"+(this.localName?" "+this.localName:""));let coders=[];for(let i=0;i<value.length;i++){coders.push(this.coder)}return pack(writer,coders,value)}decode(reader){let count=this.length;if(count===-1){count=reader.readValue().toNumber();if(count*32>reader._data.length){logger$8.throwError("insufficient data length",Logger.errors.BUFFER_OVERRUN,{length:reader._data.length,count:count})}}let coders=[];for(let i=0;i<count;i++){coders.push(new AnonymousCoder(this.coder))}return reader.coerce(this.name,unpack(reader,coders))}}"use strict";class BooleanCoder extends Coder{constructor(localName){super("bool","bool",localName,false)}defaultValue(){return false}encode(writer,value){return writer.writeValue(value?1:0)}decode(reader){return reader.coerce(this.type,!reader.readValue().isZero())}}"use strict";class DynamicBytesCoder extends Coder{constructor(type,localName){super(type,type,localName,true)}defaultValue(){return"0x"}encode(writer,value){value=arrayify(value);let length=writer.writeValue(value.length);length+=writer.writeBytes(value);return length}decode(reader){return reader.readBytes(reader.readValue().toNumber(),true)}}class BytesCoder extends DynamicBytesCoder{constructor(localName){super("bytes",localName)}decode(reader){return reader.coerce(this.name,hexlify(super.decode(reader)))}}"use strict";class FixedBytesCoder extends Coder{constructor(size,localName){let name="bytes"+String(size);super(name,name,localName,false);this.size=size}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+this.size*2)}encode(writer,value){let data=arrayify(value);if(data.length!==this.size){this._throwError("incorrect data length",value)}return writer.writeBytes(data)}decode(reader){return reader.coerce(this.name,hexlify(reader.readBytes(this.size)))}}"use strict";class NullCoder extends Coder{constructor(localName){super("null","",localName,false)}defaultValue(){return null}encode(writer,value){if(value!=null){this._throwError("not null",value)}return writer.writeBytes([])}decode(reader){reader.readBytes(0);return reader.coerce(this.name,null)}}const AddressZero="0x0000000000000000000000000000000000000000";const NegativeOne$1=BigNumber.from(-1);const Zero$1=BigNumber.from(0);const One=BigNumber.from(1);const Two=BigNumber.from(2);const WeiPerEther=BigNumber.from("1000000000000000000");const MaxUint256=BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const HashZero="0x0000000000000000000000000000000000000000000000000000000000000000";const EtherSymbol="";"use strict";var index$1=Object.freeze({__proto__:null,AddressZero:AddressZero,NegativeOne:NegativeOne$1,Zero:Zero$1,One:One,Two:Two,WeiPerEther:WeiPerEther,MaxUint256:MaxUint256,HashZero:HashZero,EtherSymbol:EtherSymbol});"use strict";class NumberCoder extends Coder{constructor(size,signed,localName){const name=(signed?"int":"uint")+size*8;super(name,name,localName,false);this.size=size;this.signed=signed}defaultValue(){return 0}encode(writer,value){let v=BigNumber.from(value);let maxUintValue=MaxUint256.mask(writer.wordSize*8);if(this.signed){let bounds=maxUintValue.mask(this.size*8-1);if(v.gt(bounds)||v.lt(bounds.add(One).mul(NegativeOne$1))){this._throwError("value out-of-bounds",value)}}else if(v.lt(Zero$1)||v.gt(maxUintValue.mask(this.size*8))){this._throwError("value out-of-bounds",value)}v=v.toTwos(this.size*8).mask(this.size*8);if(this.signed){v=v.fromTwos(this.size*8).toTwos(8*writer.wordSize)}return writer.writeValue(v)}decode(reader){let value=reader.readValue().mask(this.size*8);if(this.signed){value=value.fromTwos(this.size*8)}return reader.coerce(this.name,value)}}const version$7="strings/5.1.0";"use strict";const logger$9=new Logger(version$7);var UnicodeNormalizationForm;(function(UnicodeNormalizationForm){UnicodeNormalizationForm["current"]="";UnicodeNormalizationForm["NFC"]="NFC";UnicodeNormalizationForm["NFD"]="NFD";UnicodeNormalizationForm["NFKC"]="NFKC";UnicodeNormalizationForm["NFKD"]="NFKD"})(UnicodeNormalizationForm||(UnicodeNormalizationForm={}));var Utf8ErrorReason;(function(Utf8ErrorReason){Utf8ErrorReason["UNEXPECTED_CONTINUE"]="unexpected continuation byte";Utf8ErrorReason["BAD_PREFIX"]="bad codepoint prefix";Utf8ErrorReason["OVERRUN"]="string overrun";Utf8ErrorReason["MISSING_CONTINUE"]="missing continuation byte";Utf8ErrorReason["OUT_OF_RANGE"]="out of UTF-8 range";Utf8ErrorReason["UTF16_SURROGATE"]="UTF-16 surrogate";Utf8ErrorReason["OVERLONG"]="overlong representation"})(Utf8ErrorReason||(Utf8ErrorReason={}));function errorFunc(reason,offset,bytes,output,badCodepoint){return logger$9.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`,"bytes",bytes)}function ignoreFunc(reason,offset,bytes,output,badCodepoint){if(reason===Utf8ErrorReason.BAD_PREFIX||reason===Utf8ErrorReason.UNEXPECTED_CONTINUE){let i=0;for(let o=offset+1;o<bytes.length;o++){if(bytes[o]>>6!==2){break}i++}return i}if(reason===Utf8ErrorReason.OVERRUN){return bytes.length-offset-1}return 0}function replaceFunc(reason,offset,bytes,output,badCodepoint){if(reason===Utf8ErrorReason.OVERLONG){output.push(badCodepoint);return 0}output.push(65533);return ignoreFunc(reason,offset,bytes,output,badCodepoint)}const Utf8ErrorFuncs=Object.freeze({error:errorFunc,ignore:ignoreFunc,replace:replaceFunc});function getUtf8CodePoints(bytes,onError){if(onError==null){onError=Utf8ErrorFuncs.error}bytes=arrayify(bytes);const result=[];let i=0;while(i<bytes.length){const c=bytes[i++];if(c>>7===0){result.push(c);continue}let extraLength=null;let overlongMask=null;if((c&224)===192){extraLength=1;overlongMask=127}else if((c&240)===224){extraLength=2;overlongMask=2047}else if((c&248)===240){extraLength=3;overlongMask=65535}else{if((c&192)===128){i+=onError(Utf8ErrorReason.UNEXPECTED_CONTINUE,i-1,bytes,result)}else{i+=onError(Utf8ErrorReason.BAD_PREFIX,i-1,bytes,result)}continue}if(i-1+extraLength>=bytes.length){i+=onError(Utf8ErrorReason.OVERRUN,i-1,bytes,result);continue}let res=c&(1<<8-extraLength-1)-1;for(let j=0;j<extraLength;j++){let nextChar=bytes[i];if((nextChar&192)!=128){i+=onError(Utf8ErrorReason.MISSING_CONTINUE,i,bytes,result);res=null;break}res=res<<6|nextChar&63;i++}if(res===null){continue}if(res>1114111){i+=onError(Utf8ErrorReason.OUT_OF_RANGE,i-1-extraLength,bytes,result,res);continue}if(res>=55296&&res<=57343){i+=onError(Utf8ErrorReason.UTF16_SURROGATE,i-1-extraLength,bytes,result,res);continue}if(res<=overlongMask){i+=onError(Utf8ErrorReason.OVERLONG,i-1-extraLength,bytes,result,res);continue}result.push(res)}return result}function toUtf8Bytes(str,form=UnicodeNormalizationForm.current){if(form!=UnicodeNormalizationForm.current){logger$9.checkNormalize();str=str.normalize(form)}let result=[];for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){result.push(c)}else if(c<2048){result.push(c>>6|192);result.push(c&63|128)}else if((c&64512)==55296){i++;const c2=str.charCodeAt(i);if(i>=str.length||(c2&64512)!==56320){throw new Error("invalid utf-8 string")}const pair=65536+((c&1023)<<10)+(c2&1023);result.push(pair>>18|240);result.push(pair>>12&63|128);result.push(pair>>6&63|128);result.push(pair&63|128)}else{result.push(c>>12|224);result.push(c>>6&63|128);result.push(c&63|128)}}return arrayify(result)}function escapeChar(value){const hex="0000"+value.toString(16);return"\\u"+hex.substring(hex.length-4)}function _toEscapedUtf8String(bytes,onError){return'"'+getUtf8CodePoints(bytes,onError).map(codePoint=>{if(codePoint<256){switch(codePoint){case 8:return"\\b";case 9:return"\\t";case 10:return"\\n";case 13:return"\\r";case 34:return'\\"';case 92:return"\\\\"}if(codePoint>=32&&codePoint<127){return String.fromCharCode(codePoint)}}if(codePoint<=65535){return escapeChar(codePoint)}codePoint-=65536;return escapeChar((codePoint>>10&1023)+55296)+escapeChar((codePoint&1023)+56320)}).join("")+'"'}function _toUtf8String(codePoints){return codePoints.map(codePoint=>{if(codePoint<=65535){return String.fromCharCode(codePoint)}codePoint-=65536;return String.fromCharCode((codePoint>>10&1023)+55296,(codePoint&1023)+56320)}).join("")}function toUtf8String(bytes,onError){return _toUtf8String(getUtf8CodePoints(bytes,onError))}function toUtf8CodePoints(str,form=UnicodeNormalizationForm.current){return getUtf8CodePoints(toUtf8Bytes(str,form))}"use strict";function formatBytes32String(text){const bytes=toUtf8Bytes(text);if(bytes.length>31){throw new Error("bytes32 string must be less than 32 bytes")}return hexlify(concat([bytes,HashZero]).slice(0,32))}function parseBytes32String(bytes){const data=arrayify(bytes);if(data.length!==32){throw new Error("invalid bytes32 - not 32 bytes long")}if(data[31]!==0){throw new Error("invalid bytes32 string - no null terminator")}let length=31;while(data[length-1]===0){length--}return toUtf8String(data.slice(0,length))}"use strict";function bytes2(data){if(data.length%4!==0){throw new Error("bad data")}let result=[];for(let i=0;i<data.length;i+=4){result.push(parseInt(data.substring(i,i+4),16))}return result}function createTable(data,func){if(!func){func=function(value){return[parseInt(value,16)]}}let lo=0;let result={};data.split(",").forEach(pair=>{let comps=pair.split(":");lo+=parseInt(comps[0],16);result[lo]=func(comps[1])});return result}function createRangeTable(data){let hi=0;return data.split(",").map(v=>{let comps=v.split("-");if(comps.length===1){comps[1]="0"}else if(comps[1]===""){comps[1]="1"}let lo=hi+parseInt(comps[0],16);hi=parseInt(comps[1],16);return{l:lo,h:hi}})}function matchMap(value,ranges){let lo=0;for(let i=0;i<ranges.length;i++){let range=ranges[i];lo+=range.l;if(value>=lo&&value<=lo+range.h&&(value-lo)%(range.d||1)===0){if(range.e&&range.e.indexOf(value-lo)!==-1){continue}return range}}return null}const Table_A_1_ranges=createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");const Table_B_1_flags="ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(v=>parseInt(v,16));const Table_B_2_ranges=[{h:25,s:32,l:65},{h:30,s:32,e:[23],l:127},{h:54,s:1,e:[48],l:64,d:2},{h:14,s:1,l:57,d:2},{h:44,s:1,l:17,d:2},{h:10,s:1,e:[2,6,8],l:61,d:2},{h:16,s:1,l:68,d:2},{h:84,s:1,e:[18,24,66],l:19,d:2},{h:26,s:32,e:[17],l:435},{h:22,s:1,l:71,d:2},{h:15,s:80,l:40},{h:31,s:32,l:16},{h:32,s:1,l:80,d:2},{h:52,s:1,l:42,d:2},{h:12,s:1,l:55,d:2},{h:40,s:1,e:[38],l:15,d:2},{h:14,s:1,l:48,d:2},{h:37,s:48,l:49},{h:148,s:1,l:6351,d:2},{h:88,s:1,l:160,d:2},{h:15,s:16,l:704},{h:25,s:26,l:854},{h:25,s:32,l:55915},{h:37,s:40,l:1247},{h:25,s:-119711,l:53248},{h:25,s:-119763,l:52},{h:25,s:-119815,l:52},{h:25,s:-119867,e:[1,4,5,7,8,11,12,17],l:52},{h:25,s:-119919,l:52},{h:24,s:-119971,e:[2,7,8,17],l:52},{h:24,s:-120023,e:[2,7,13,15,16,17],l:52},{h:25,s:-120075,l:52},{h:25,s:-120127,l:52},{h:25,s:-120179,l:52},{h:25,s:-120231,l:52},{h:25,s:-120283,l:52},{h:25,s:-120335,l:52},{h:24,s:-119543,e:[17],l:56},{h:24,s:-119601,e:[17],l:58},{h:24,s:-119659,e:[17],l:58},{h:24,s:-119717,e:[17],l:58},{h:24,s:-119775,e:[17],l:58}];const Table_B_2_lut_abs=createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");const Table_B_2_lut_rel=createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");const Table_B_2_complex=createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D",bytes2);const Table_C_ranges=createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");function flatten(values){return values.reduce((accum,value)=>{value.forEach(value=>{accum.push(value)});return accum},[])}function _nameprepTableA1(codepoint){return!!matchMap(codepoint,Table_A_1_ranges)}function _nameprepTableB2(codepoint){let range=matchMap(codepoint,Table_B_2_ranges);if(range){return[codepoint+range.s]}let codes=Table_B_2_lut_abs[codepoint];if(codes){return codes}let shift=Table_B_2_lut_rel[codepoint];if(shift){return[codepoint+shift[0]]}let complex=Table_B_2_complex[codepoint];if(complex){return complex}return null}function _nameprepTableC(codepoint){return!!matchMap(codepoint,Table_C_ranges)}function nameprep(value){if(value.match(/^[a-z0-9-]*$/i)&&value.length<=59){return value.toLowerCase()}let codes=toUtf8CodePoints(value);codes=flatten(codes.map(code=>{if(Table_B_1_flags.indexOf(code)>=0){return[]}if(code>=65024&&code<=65039){return[]}let codesTableB2=_nameprepTableB2(code);if(codesTableB2){return codesTableB2}return[code]}));codes=toUtf8CodePoints(_toUtf8String(codes),UnicodeNormalizationForm.NFKC);codes.forEach(code=>{if(_nameprepTableC(code)){throw new Error("STRINGPREP_CONTAINS_PROHIBITED")}});codes.forEach(code=>{if(_nameprepTableA1(code)){throw new Error("STRINGPREP_CONTAINS_UNASSIGNED")}});let name=_toUtf8String(codes);if(name.substring(0,1)==="-"||name.substring(2,4)==="--"||name.substring(name.length-1)==="-"){throw new Error("invalid hyphen")}if(name.length>63){throw new Error("too long")}return name}"use strict";"use strict";class StringCoder extends DynamicBytesCoder{constructor(localName){super("string",localName)}defaultValue(){return""}encode(writer,value){return super.encode(writer,toUtf8Bytes(value))}decode(reader){return toUtf8String(super.decode(reader))}}"use strict";class TupleCoder extends Coder{constructor(coders,localName){let dynamic=false;const types=[];coders.forEach(coder=>{if(coder.dynamic){dynamic=true}types.push(coder.type)});const type="tuple("+types.join(",")+")";super("tuple",type,localName,dynamic);this.coders=coders}defaultValue(){const values=[];this.coders.forEach(coder=>{values.push(coder.defaultValue())});const uniqueNames=this.coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});this.coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name==="length"){name="_length"}if(values[name]!=null){return}values[name]=values[index]});return Object.freeze(values)}encode(writer,value){return pack(writer,this.coders,value)}decode(reader){return reader.coerce(this.name,unpack(reader,this.coders))}}"use strict";const logger$a=new Logger(version$4);const paramTypeBytes=new RegExp(/^bytes([0-9]*)$/);const paramTypeNumber=new RegExp(/^(u?int)([0-9]*)$/);class AbiCoder{constructor(coerceFunc){logger$a.checkNew(new.target,AbiCoder);defineReadOnly(this,"coerceFunc",coerceFunc||null)}_getCoder(param){switch(param.baseType){case"address":return new AddressCoder(param.name);case"bool":return new BooleanCoder(param.name);case"string":return new StringCoder(param.name);case"bytes":return new BytesCoder(param.name);case"array":return new ArrayCoder(this._getCoder(param.arrayChildren),param.arrayLength,param.name);case"tuple":return new TupleCoder((param.components||[]).map(component=>{return this._getCoder(component)}),param.name);case"":return new NullCoder(param.name)}let match=param.type.match(paramTypeNumber);if(match){let size=parseInt(match[2]||"256");if(size===0||size>256||size%8!==0){logger$a.throwArgumentError("invalid "+match[1]+" bit length","param",param)}return new NumberCoder(size/8,match[1]==="int",param.name)}match=param.type.match(paramTypeBytes);if(match){let size=parseInt(match[1]);if(size===0||size>32){logger$a.throwArgumentError("invalid bytes length","param",param)}return new FixedBytesCoder(size,param.name)}return logger$a.throwArgumentError("invalid type","type",param.type)}_getWordSize(){return 32}_getReader(data,allowLoose){return new Reader(data,this._getWordSize(),this.coerceFunc,allowLoose)}_getWriter(){return new Writer(this._getWordSize())}getDefaultValue(types){const coders=types.map(type=>this._getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.defaultValue()}encode(types,values){if(types.length!==values.length){logger$a.throwError("types/values length mismatch",Logger.errors.INVALID_ARGUMENT,{count:{types:types.length,values:values.length},value:{types:types,values:values}})}const coders=types.map(type=>this._getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");const writer=this._getWriter();coder.encode(writer,values);return writer.data}decode(types,data,loose){const coders=types.map(type=>this._getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.decode(this._getReader(arrayify(data),loose))}}const defaultAbiCoder=new AbiCoder;function id(text){return keccak256(toUtf8Bytes(text))}const version$8="hash/5.1.0";const logger$b=new Logger(version$8);const Zeros=new Uint8Array(32);Zeros.fill(0);const Partition=new RegExp("^((.*)\\.)?([^.]+)$");function isValidName(name){try{const comps=name.split(".");for(let i=0;i<comps.length;i++){if(nameprep(comps[i]).length===0){throw new Error("empty")}}return true}catch(error){}return false}function namehash(name){if(typeof name!=="string"){logger$b.throwArgumentError("invalid address - "+String(name),"name",name)}let result=Zeros;while(name.length){const partition=name.match(Partition);const label=toUtf8Bytes(nameprep(partition[3]));result=keccak256(concat([result,keccak256(label)]));name=partition[2]||""}return hexlify(result)}const messagePrefix="Ethereum Signed Message:\n";function hashMessage(message){if(typeof message==="string"){message=toUtf8Bytes(message)}return keccak256(concat([toUtf8Bytes(messagePrefix),toUtf8Bytes(String(message.length)),message]))}var __awaiter$1=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$c=new Logger(version$8);const padding=new Uint8Array(32);padding.fill(0);const NegativeOne$2=BigNumber.from(-1);const Zero$2=BigNumber.from(0);const One$1=BigNumber.from(1);const MaxUint256$1=BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function hexPadRight(value){const bytes=arrayify(value);const padOffset=bytes.length%32;if(padOffset){return hexConcat([bytes,padding.slice(padOffset)])}return hexlify(bytes)}const hexTrue=hexZeroPad(One$1.toHexString(),32);const hexFalse=hexZeroPad(Zero$2.toHexString(),32);const domainFieldTypes={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"};const domainFieldNames=["name","version","chainId","verifyingContract","salt"];function checkString(key){return function(value){if(typeof value!=="string"){logger$c.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`,`domain.${key}`,value)}return value}}const domainChecks={name:checkString("name"),version:checkString("version"),chainId:function(value){try{return BigNumber.from(value).toString()}catch(error){}return logger$c.throwArgumentError(`invalid domain value for "chainId"`,"domain.chainId",value)},verifyingContract:function(value){try{return getAddress(value).toLowerCase()}catch(error){}return logger$c.throwArgumentError(`invalid domain value "verifyingContract"`,"domain.verifyingContract",value)},salt:function(value){try{const bytes=arrayify(value);if(bytes.length!==32){throw new Error("bad length")}return hexlify(bytes)}catch(error){}return logger$c.throwArgumentError(`invalid domain value "salt"`,"domain.salt",value)}};function getBaseEncoder(type){{const match=type.match(/^(u?)int(\d*)$/);if(match){const signed=match[1]==="";const width=parseInt(match[2]||"256");if(width%8!==0||width>256||match[2]&&match[2]!==String(width)){logger$c.throwArgumentError("invalid numeric width","type",type)}const boundsUpper=MaxUint256$1.mask(signed?width-1:width);const boundsLower=signed?boundsUpper.add(One$1).mul(NegativeOne$2):Zero$2;return function(value){const v=BigNumber.from(value);if(v.lt(boundsLower)||v.gt(boundsUpper)){logger$c.throwArgumentError(`value out-of-bounds for ${type}`,"value",value)}return hexZeroPad(v.toTwos(256).toHexString(),32)}}}{const match=type.match(/^bytes(\d+)$/);if(match){const width=parseInt(match[1]);if(width===0||width>32||match[1]!==String(width)){logger$c.throwArgumentError("invalid bytes width","type",type)}return function(value){const bytes=arrayify(value);if(bytes.length!==width){logger$c.throwArgumentError(`invalid length for ${type}`,"value",value)}return hexPadRight(value)}}}switch(type){case"address":return function(value){return hexZeroPad(getAddress(value),32)};case"bool":return function(value){return!value?hexFalse:hexTrue};case"bytes":return function(value){return keccak256(value)};case"string":return function(value){return id(value)}}return null}function encodeType(name,fields){return`${name}(${fields.map(({name:name,type:type})=>type+" "+name).join(",")})`}class TypedDataEncoder{constructor(types){defineReadOnly(this,"types",Object.freeze(deepCopy(types)));defineReadOnly(this,"_encoderCache",{});defineReadOnly(this,"_types",{});const links={};const parents={};const subtypes={};Object.keys(types).forEach(type=>{links[type]={};parents[type]=[];subtypes[type]={}});for(const name in types){const uniqueNames={};types[name].forEach(field=>{if(uniqueNames[field.name]){logger$c.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`,"types",types)}uniqueNames[field.name]=true;const baseType=field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];if(baseType===name){logger$c.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`,"types",types)}const encoder=getBaseEncoder(baseType);if(encoder){return}if(!parents[baseType]){logger$c.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`,"types",types)}parents[baseType].push(name);links[name][baseType]=true})}const primaryTypes=Object.keys(parents).filter(n=>parents[n].length===0);if(primaryTypes.length===0){logger$c.throwArgumentError("missing primary type","types",types)}else if(primaryTypes.length>1){logger$c.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map(t=>JSON.stringify(t)).join(", ")}`,"types",types)}defineReadOnly(this,"primaryType",primaryTypes[0]);function checkCircular(type,found){if(found[type]){logger$c.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`,"types",types)}found[type]=true;Object.keys(links[type]).forEach(child=>{if(!parents[child]){return}checkCircular(child,found);Object.keys(found).forEach(subtype=>{subtypes[subtype][child]=true})});delete found[type]}checkCircular(this.primaryType,{});for(const name in subtypes){const st=Object.keys(subtypes[name]);st.sort();this._types[name]=encodeType(name,types[name])+st.map(t=>encodeType(t,types[t])).join("")}}getEncoder(type){let encoder=this._encoderCache[type];if(!encoder){encoder=this._encoderCache[type]=this._getEncoder(type)}return encoder}_getEncoder(type){{const encoder=getBaseEncoder(type);if(encoder){return encoder}}const match=type.match(/^(.*)(\x5b(\d*)\x5d)$/);if(match){const subtype=match[1];const subEncoder=this.getEncoder(subtype);const length=parseInt(match[3]);return value=>{if(length>=0&&value.length!==length){logger$c.throwArgumentError("array length mismatch; expected length ${ arrayLength }","value",value)}let result=value.map(subEncoder);if(this._types[subtype]){result=result.map(keccak256)}return keccak256(hexConcat(result))}}const fields=this.types[type];if(fields){const encodedType=id(this._types[type]);return value=>{const values=fields.map(({name:name,type:type})=>{const result=this.getEncoder(type)(value[name]);if(this._types[type]){return keccak256(result)}return result});values.unshift(encodedType);return hexConcat(values)}}return logger$c.throwArgumentError(`unknown type: ${type}`,"type",type)}encodeType(name){const result=this._types[name];if(!result){logger$c.throwArgumentError(`unknown type: ${JSON.stringify(name)}`,"name",name)}return result}encodeData(type,value){return this.getEncoder(type)(value)}hashStruct(name,value){return keccak256(this.encodeData(name,value))}encode(value){return this.encodeData(this.primaryType,value)}hash(value){return this.hashStruct(this.primaryType,value)}_visit(type,value,callback){{const encoder=getBaseEncoder(type);if(encoder){return callback(type,value)}}const match=type.match(/^(.*)(\x5b(\d*)\x5d)$/);if(match){const subtype=match[1];const length=parseInt(match[3]);if(length>=0&&value.length!==length){logger$c.throwArgumentError("array length mismatch; expected length ${ arrayLength }","value",value)}return value.map(v=>this._visit(subtype,v,callback))}const fields=this.types[type];if(fields){return fields.reduce((accum,{name:name,type:type})=>{accum[name]=this._visit(type,value[name],callback);return accum},{})}return logger$c.throwArgumentError(`unknown type: ${type}`,"type",type)}visit(value,callback){return this._visit(this.primaryType,value,callback)}static from(types){return new TypedDataEncoder(types)}static getPrimaryType(types){return TypedDataEncoder.from(types).primaryType}static hashStruct(name,types,value){return TypedDataEncoder.from(types).hashStruct(name,value)}static hashDomain(domain){const domainFields=[];for(const name in domain){const type=domainFieldTypes[name];if(!type){logger$c.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`,"domain",domain)}domainFields.push({name:name,type:type})}domainFields.sort((a,b)=>{return domainFieldNames.indexOf(a.name)-domainFieldNames.indexOf(b.name)});return TypedDataEncoder.hashStruct("EIP712Domain",{EIP712Domain:domainFields},domain)}static encode(domain,types,value){return hexConcat(["0x1901",TypedDataEncoder.hashDomain(domain),TypedDataEncoder.from(types).hash(value)])}static hash(domain,types,value){return keccak256(TypedDataEncoder.encode(domain,types,value))}static resolveNames(domain,types,value,resolveName){return __awaiter$1(this,void 0,void 0,function*(){domain=shallowCopy(domain);const ensCache={};if(domain.verifyingContract&&!isHexString(domain.verifyingContract,20)){ensCache[domain.verifyingContract]="0x"}const encoder=TypedDataEncoder.from(types);encoder.visit(value,(type,value)=>{if(type==="address"&&!isHexString(value,20)){ensCache[value]="0x"}return value});for(const name in ensCache){ensCache[name]=yield resolveName(name)}if(domain.verifyingContract&&ensCache[domain.verifyingContract]){domain.verifyingContract=ensCache[domain.verifyingContract]}value=encoder.visit(value,(type,value)=>{if(type==="address"&&ensCache[value]){return ensCache[value]}return value});return{domain:domain,value:value}})}static getPayload(domain,types,value){TypedDataEncoder.hashDomain(domain);const domainValues={};const domainTypes=[];domainFieldNames.forEach(name=>{const value=domain[name];if(value==null){return}domainValues[name]=domainChecks[name](value);domainTypes.push({name:name,type:domainFieldTypes[name]})});const encoder=TypedDataEncoder.from(types);const typesWithDomain=shallowCopy(types);if(typesWithDomain.EIP712Domain){logger$c.throwArgumentError("types must not contain EIP712Domain type","types.EIP712Domain",types)}else{typesWithDomain.EIP712Domain=domainTypes}encoder.encode(value);return{types:typesWithDomain,domain:domainValues,primaryType:encoder.primaryType,message:encoder.visit(value,(type,value)=>{if(type.match(/^bytes(\d*)/)){return hexlify(arrayify(value))}if(type.match(/^u?int/)){return BigNumber.from(value).toString()}switch(type){case"address":return value.toLowerCase();case"bool":return!!value;case"string":if(typeof value!=="string"){logger$c.throwArgumentError(`invalid string`,"value",value)}return value}return logger$c.throwArgumentError("unsupported type","type",type)})}}}"use strict";"use strict";const logger$d=new Logger(version$4);class LogDescription extends Description{}class TransactionDescription extends Description{}class Indexed extends Description{static isIndexed(value){return!!(value&&value._isIndexed)}}function wrapAccessError(property,error){const wrap=new Error(`deferred error during ABI decoding triggered accessing ${property}`);wrap.error=error;return wrap}class Interface{constructor(fragments){logger$d.checkNew(new.target,Interface);let abi=[];if(typeof fragments==="string"){abi=JSON.parse(fragments)}else{abi=fragments}defineReadOnly(this,"fragments",abi.map(fragment=>{return Fragment.from(fragment)}).filter(fragment=>fragment!=null));defineReadOnly(this,"_abiCoder",getStatic(new.target,"getAbiCoder")());defineReadOnly(this,"functions",{});defineReadOnly(this,"errors",{});defineReadOnly(this,"events",{});defineReadOnly(this,"structs",{});this.fragments.forEach(fragment=>{let bucket=null;switch(fragment.type){case"constructor":if(this.deploy){logger$d.warn("duplicate definition - constructor");return}defineReadOnly(this,"deploy",fragment);return;case"function":bucket=this.functions;break;case"event":bucket=this.events;break;default:return}let signature=fragment.format();if(bucket[signature]){logger$d.warn("duplicate definition - "+signature);return}bucket[signature]=fragment});if(!this.deploy){defineReadOnly(this,"deploy",ConstructorFragment.from({payable:false,type:"constructor"}))}defineReadOnly(this,"_isInterface",true)}format(format){if(!format){format=FormatTypes.full}if(format===FormatTypes.sighash){logger$d.throwArgumentError("interface does not support formatting sighash","format",format)}const abi=this.fragments.map(fragment=>fragment.format(format));if(format===FormatTypes.json){return JSON.stringify(abi.map(j=>JSON.parse(j)))}return abi}static getAbiCoder(){return defaultAbiCoder}static getAddress(address){return getAddress(address)}static getSighash(functionFragment){return hexDataSlice(id(functionFragment.format()),0,4)}static getEventTopic(eventFragment){return id(eventFragment.format())}getFunction(nameOrSignatureOrSighash){if(isHexString(nameOrSignatureOrSighash)){for(const name in this.functions){if(nameOrSignatureOrSighash===this.getSighash(name)){return this.functions[name]}}logger$d.throwArgumentError("no matching function","sighash",nameOrSignatureOrSighash)}if(nameOrSignatureOrSighash.indexOf("(")===-1){const name=nameOrSignatureOrSighash.trim();const matching=Object.keys(this.functions).filter(f=>f.split("(")[0]===name);if(matching.length===0){logger$d.throwArgumentError("no matching function","name",name)}else if(matching.length>1){logger$d.throwArgumentError("multiple matching functions","name",name)}return this.functions[matching[0]]}const result=this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];if(!result){logger$d.throwArgumentError("no matching function","signature",nameOrSignatureOrSighash)}return result}getEvent(nameOrSignatureOrTopic){if(isHexString(nameOrSignatureOrTopic)){const topichash=nameOrSignatureOrTopic.toLowerCase();for(const name in this.events){if(topichash===this.getEventTopic(name)){return this.events[name]}}logger$d.throwArgumentError("no matching event","topichash",topichash)}if(nameOrSignatureOrTopic.indexOf("(")===-1){const name=nameOrSignatureOrTopic.trim();const matching=Object.keys(this.events).filter(f=>f.split("(")[0]===name);if(matching.length===0){logger$d.throwArgumentError("no matching event","name",name)}else if(matching.length>1){logger$d.throwArgumentError("multiple matching events","name",name)}return this.events[matching[0]]}const result=this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];if(!result){logger$d.throwArgumentError("no matching event","signature",nameOrSignatureOrTopic)}return result}getSighash(functionFragment){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}return getStatic(this.constructor,"getSighash")(functionFragment)}getEventTopic(eventFragment){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}return getStatic(this.constructor,"getEventTopic")(eventFragment)}_decodeParams(params,data){return this._abiCoder.decode(params,data)}_encodeParams(params,values){return this._abiCoder.encode(params,values)}encodeDeploy(values){return this._encodeParams(this.deploy.inputs,values||[])}decodeFunctionData(functionFragment,data){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}const bytes=arrayify(data);if(hexlify(bytes.slice(0,4))!==this.getSighash(functionFragment)){logger$d.throwArgumentError(`data signature does not match function ${functionFragment.name}.`,"data",hexlify(bytes))}return this._decodeParams(functionFragment.inputs,bytes.slice(4))}encodeFunctionData(functionFragment,values){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}return hexlify(concat([this.getSighash(functionFragment),this._encodeParams(functionFragment.inputs,values||[])]))}decodeFunctionResult(functionFragment,data){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}let bytes=arrayify(data);let reason=null;let errorSignature=null;switch(bytes.length%this._abiCoder._getWordSize()){case 0:try{return this._abiCoder.decode(functionFragment.outputs,bytes)}catch(error){}break;case 4:if(hexlify(bytes.slice(0,4))==="0x08c379a0"){errorSignature="Error(string)";reason=this._abiCoder.decode(["string"],bytes.slice(4))[0]}break}return logger$d.throwError("call revert exception",Logger.errors.CALL_EXCEPTION,{method:functionFragment.format(),errorSignature:errorSignature,errorArgs:[reason],reason:reason})}encodeFunctionResult(functionFragment,values){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}return hexlify(this._abiCoder.encode(functionFragment.outputs,values||[]))}encodeFilterTopics(eventFragment,values){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}if(values.length>eventFragment.inputs.length){logger$d.throwError("too many arguments for "+eventFragment.format(),Logger.errors.UNEXPECTED_ARGUMENT,{argument:"values",value:values})}let topics=[];if(!eventFragment.anonymous){topics.push(this.getEventTopic(eventFragment))}const encodeTopic=(param,value)=>{if(param.type==="string"){return id(value)}else if(param.type==="bytes"){return keccak256(hexlify(value))}if(param.type==="address"){this._abiCoder.encode(["address"],[value])}return hexZeroPad(hexlify(value),32)};values.forEach((value,index)=>{let param=eventFragment.inputs[index];if(!param.indexed){if(value!=null){logger$d.throwArgumentError("cannot filter non-indexed parameters; must be null","contract."+param.name,value)}return}if(value==null){topics.push(null)}else if(param.baseType==="array"||param.baseType==="tuple"){logger$d.throwArgumentError("filtering with tuples or arrays not supported","contract."+param.name,value)}else if(Array.isArray(value)){topics.push(value.map(value=>encodeTopic(param,value)))}else{topics.push(encodeTopic(param,value))}});while(topics.length&&topics[topics.length-1]===null){topics.pop()}return topics}encodeEventLog(eventFragment,values){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}const topics=[];const dataTypes=[];const dataValues=[];if(!eventFragment.anonymous){topics.push(this.getEventTopic(eventFragment))}if(values.length!==eventFragment.inputs.length){logger$d.throwArgumentError("event arguments/values mismatch","values",values)}eventFragment.inputs.forEach((param,index)=>{const value=values[index];if(param.indexed){if(param.type==="string"){topics.push(id(value))}else if(param.type==="bytes"){topics.push(keccak256(value))}else if(param.baseType==="tuple"||param.baseType==="array"){throw new Error("not implemented")}else{topics.push(this._abiCoder.encode([param.type],[value]))}}else{dataTypes.push(param);dataValues.push(value)}});return{data:this._abiCoder.encode(dataTypes,dataValues),topics:topics}}decodeEventLog(eventFragment,data,topics){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}if(topics!=null&&!eventFragment.anonymous){let topicHash=this.getEventTopic(eventFragment);if(!isHexString(topics[0],32)||topics[0].toLowerCase()!==topicHash){logger$d.throwError("fragment/topic mismatch",Logger.errors.INVALID_ARGUMENT,{argument:"topics[0]",expected:topicHash,value:topics[0]})}topics=topics.slice(1)}let indexed=[];let nonIndexed=[];let dynamic=[];eventFragment.inputs.forEach((param,index)=>{if(param.indexed){if(param.type==="string"||param.type==="bytes"||param.baseType==="tuple"||param.baseType==="array"){indexed.push(ParamType.fromObject({type:"bytes32",name:param.name}));dynamic.push(true)}else{indexed.push(param);dynamic.push(false)}}else{nonIndexed.push(param);dynamic.push(false)}});let resultIndexed=topics!=null?this._abiCoder.decode(indexed,concat(topics)):null;let resultNonIndexed=this._abiCoder.decode(nonIndexed,data,true);let result=[];let nonIndexedIndex=0,indexedIndex=0;eventFragment.inputs.forEach((param,index)=>{if(param.indexed){if(resultIndexed==null){result[index]=new Indexed({_isIndexed:true,hash:null})}else if(dynamic[index]){result[index]=new Indexed({_isIndexed:true,hash:resultIndexed[indexedIndex++]})}else{try{result[index]=resultIndexed[indexedIndex++]}catch(error){result[index]=error}}}else{try{result[index]=resultNonIndexed[nonIndexedIndex++]}catch(error){result[index]=error}}if(param.name&&result[param.name]==null){const value=result[index];if(value instanceof Error){Object.defineProperty(result,param.name,{get:()=>{throw wrapAccessError(`property ${JSON.stringify(param.name)}`,value)}})}else{result[param.name]=value}}});for(let i=0;i<result.length;i++){const value=result[i];if(value instanceof Error){Object.defineProperty(result,i,{get:()=>{throw wrapAccessError(`index ${i}`,value)}})}}return Object.freeze(result)}parseTransaction(tx){let fragment=this.getFunction(tx.data.substring(0,10).toLowerCase());if(!fragment){return null}return new TransactionDescription({args:this._abiCoder.decode(fragment.inputs,"0x"+tx.data.substring(10)),functionFragment:fragment,name:fragment.name,signature:fragment.format(),sighash:this.getSighash(fragment),value:BigNumber.from(tx.value||"0")})}parseLog(log){let fragment=this.getEvent(log.topics[0]);if(!fragment||fragment.anonymous){return null}return new LogDescription({eventFragment:fragment,name:fragment.name,signature:fragment.format(),topic:this.getEventTopic(fragment),args:this.decodeEventLog(fragment,log.data,log.topics)})}static isInterface(value){return!!(value&&value._isInterface)}}"use strict";const version$9="abstract-provider/5.1.0";"use strict";const logger$e=new Logger(version$9);class ForkEvent extends Description{static isForkEvent(value){return!!(value&&value._isForkEvent)}}class BlockForkEvent extends ForkEvent{constructor(blockHash,expiry){if(!isHexString(blockHash,32)){logger$e.throwArgumentError("invalid blockHash","blockHash",blockHash)}super({_isForkEvent:true,_isBlockForkEvent:true,expiry:expiry||0,blockHash:blockHash})}}class TransactionForkEvent extends ForkEvent{constructor(hash,expiry){if(!isHexString(hash,32)){logger$e.throwArgumentError("invalid transaction hash","hash",hash)}super({_isForkEvent:true,_isTransactionForkEvent:true,expiry:expiry||0,hash:hash})}}class TransactionOrderForkEvent extends ForkEvent{constructor(beforeHash,afterHash,expiry){if(!isHexString(beforeHash,32)){logger$e.throwArgumentError("invalid transaction hash","beforeHash",beforeHash)}if(!isHexString(afterHash,32)){logger$e.throwArgumentError("invalid transaction hash","afterHash",afterHash)}super({_isForkEvent:true,_isTransactionOrderForkEvent:true,expiry:expiry||0,beforeHash:beforeHash,afterHash:afterHash})}}class Provider{constructor(){logger$e.checkAbstract(new.target,Provider);defineReadOnly(this,"_isProvider",true)}addListener(eventName,listener){return this.on(eventName,listener)}removeListener(eventName,listener){return this.off(eventName,listener)}static isProvider(value){return!!(value&&value._isProvider)}}const version$a="abstract-signer/5.1.0";"use strict";var __awaiter$2=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$f=new Logger(version$a);const allowedTransactionKeys=["accessList","chainId","data","from","gasLimit","gasPrice","nonce","to","type","value"];const forwardErrors=[Logger.errors.INSUFFICIENT_FUNDS,Logger.errors.NONCE_EXPIRED,Logger.errors.REPLACEMENT_UNDERPRICED];class Signer{constructor(){logger$f.checkAbstract(new.target,Signer);defineReadOnly(this,"_isSigner",true)}getBalance(blockTag){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getBalance");return yield this.provider.getBalance(this.getAddress(),blockTag)})}getTransactionCount(blockTag){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getTransactionCount");return yield this.provider.getTransactionCount(this.getAddress(),blockTag)})}estimateGas(transaction){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("estimateGas");const tx=yield resolveProperties(this.checkTransaction(transaction));return yield this.provider.estimateGas(tx)})}call(transaction,blockTag){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("call");const tx=yield resolveProperties(this.checkTransaction(transaction));return yield this.provider.call(tx,blockTag)})}sendTransaction(transaction){this._checkProvider("sendTransaction");return this.populateTransaction(transaction).then(tx=>{return this.signTransaction(tx).then(signedTx=>{return this.provider.sendTransaction(signedTx)})})}getChainId(){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getChainId");const network=yield this.provider.getNetwork();return network.chainId})}getGasPrice(){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getGasPrice");return yield this.provider.getGasPrice()})}resolveName(name){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("resolveName");return yield this.provider.resolveName(name)})}checkTransaction(transaction){for(const key in transaction){if(allowedTransactionKeys.indexOf(key)===-1){logger$f.throwArgumentError("invalid transaction key: "+key,"transaction",transaction)}}const tx=shallowCopy(transaction);if(tx.from==null){tx.from=this.getAddress()}else{tx.from=Promise.all([Promise.resolve(tx.from),this.getAddress()]).then(result=>{if(result[0].toLowerCase()!==result[1].toLowerCase()){logger$f.throwArgumentError("from address mismatch","transaction",transaction)}return result[0]})}return tx}populateTransaction(transaction){return __awaiter$2(this,void 0,void 0,function*(){const tx=yield resolveProperties(this.checkTransaction(transaction));if(tx.to!=null){tx.to=Promise.resolve(tx.to).then(to=>__awaiter$2(this,void 0,void 0,function*(){if(to==null){return null}const address=yield this.resolveName(to);if(address==null){logger$f.throwArgumentError("provided ENS name resolves to null","tx.to",to)}return address}))}if(tx.gasPrice==null){tx.gasPrice=this.getGasPrice()}if(tx.nonce==null){tx.nonce=this.getTransactionCount("pending")}if(tx.gasLimit==null){tx.gasLimit=this.estimateGas(tx).catch(error=>{if(forwardErrors.indexOf(error.code)>=0){throw error}return logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit",Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,tx:tx})})}if(tx.chainId==null){tx.chainId=this.getChainId()}else{tx.chainId=Promise.all([Promise.resolve(tx.chainId),this.getChainId()]).then(results=>{if(results[1]!==0&&results[0]!==results[1]){logger$f.throwArgumentError("chainId address mismatch","transaction",transaction)}return results[0]})}return yield resolveProperties(tx)})}_checkProvider(operation){if(!this.provider){logger$f.throwError("missing provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:operation||"_checkProvider"})}}static isSigner(value){return!!(value&&value._isSigner)}}class VoidSigner extends Signer{constructor(address,provider){logger$f.checkNew(new.target,VoidSigner);super();defineReadOnly(this,"address",address);defineReadOnly(this,"provider",provider||null)}getAddress(){return Promise.resolve(this.address)}_fail(message,operation){return Promise.resolve().then(()=>{logger$f.throwError(message,Logger.errors.UNSUPPORTED_OPERATION,{operation:operation})})}signMessage(message){return this._fail("VoidSigner cannot sign messages","signMessage")}signTransaction(transaction){return this._fail("VoidSigner cannot sign transactions","signTransaction")}_signTypedData(domain,types,value){return this._fail("VoidSigner cannot sign typed data","signTypedData")}connect(provider){return new VoidSigner(this.address,provider)}}var minimalisticAssert=assert;function assert(val,msg){if(!val)throw new Error(msg||"Assertion failed")}assert.equal=function assertEqual(l,r,msg){if(l!=r)throw new Error(msg||"Assertion failed: "+l+" != "+r)};var inherits_browser=createCommonjsModule(function(module){if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}}else{module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}}}});var inherits=createCommonjsModule(function(module){try{var util=null;if(typeof util.inherits!=="function")throw"";module.exports=util.inherits}catch(e){module.exports=inherits_browser}});"use strict";var inherits_1=inherits;function toArray(msg,enc){if(Array.isArray(msg))return msg.slice();if(!msg)return[];var res=[];if(typeof msg==="string"){if(!enc){for(var i=0;i<msg.length;i++){var c=msg.charCodeAt(i);var hi=c>>8;var lo=c&255;if(hi)res.push(hi,lo);else res.push(lo)}}else if(enc==="hex"){msg=msg.replace(/[^a-z0-9]+/gi,"");if(msg.length%2!==0)msg="0"+msg;for(i=0;i<msg.length;i+=2)res.push(parseInt(msg[i]+msg[i+1],16))}}else{for(i=0;i<msg.length;i++)res[i]=msg[i]|0}return res}var toArray_1=toArray;function toHex$1(msg){var res="";for(var i=0;i<msg.length;i++)res+=zero2(msg[i].toString(16));return res}var toHex_1=toHex$1;function htonl(w){var res=w>>>24|w>>>8&65280|w<<8&16711680|(w&255)<<24;return res>>>0}var htonl_1=htonl;function toHex32(msg,endian){var res="";for(var i=0;i<msg.length;i++){var w=msg[i];if(endian==="little")w=htonl(w);res+=zero8(w.toString(16))}return res}var toHex32_1=toHex32;function zero2(word){if(word.length===1)return"0"+word;else return word}var zero2_1=zero2;function zero8(word){if(word.length===7)return"0"+word;else if(word.length===6)return"00"+word;else if(word.length===5)return"000"+word;else if(word.length===4)return"0000"+word;else if(word.length===3)return"00000"+word;else if(word.length===2)return"000000"+word;else if(word.length===1)return"0000000"+word;else return word}var zero8_1=zero8;function join32(msg,start,end,endian){var len=end-start;minimalisticAssert(len%4===0);var res=new Array(len/4);for(var i=0,k=start;i<res.length;i++,k+=4){var w;if(endian==="big")w=msg[k]<<24|msg[k+1]<<16|msg[k+2]<<8|msg[k+3];else w=msg[k+3]<<24|msg[k+2]<<16|msg[k+1]<<8|msg[k];res[i]=w>>>0}return res}var join32_1=join32;function split32(msg,endian){var res=new Array(msg.length*4);for(var i=0,k=0;i<msg.length;i++,k+=4){var m=msg[i];if(endian==="big"){res[k]=m>>>24;res[k+1]=m>>>16&255;res[k+2]=m>>>8&255;res[k+3]=m&255}else{res[k+3]=m>>>24;res[k+2]=m>>>16&255;res[k+1]=m>>>8&255;res[k]=m&255}}return res}var split32_1=split32;function rotr32(w,b){return w>>>b|w<<32-b}var rotr32_1=rotr32;function rotl32(w,b){return w<<b|w>>>32-b}var rotl32_1=rotl32;function sum32(a,b){return a+b>>>0}var sum32_1=sum32;function sum32_3(a,b,c){return a+b+c>>>0}var sum32_3_1=sum32_3;function sum32_4(a,b,c,d){return a+b+c+d>>>0}var sum32_4_1=sum32_4;function sum32_5(a,b,c,d,e){return a+b+c+d+e>>>0}var sum32_5_1=sum32_5;function sum64(buf,pos,ah,al){var bh=buf[pos];var bl=buf[pos+1];var lo=al+bl>>>0;var hi=(lo<al?1:0)+ah+bh;buf[pos]=hi>>>0;buf[pos+1]=lo}var sum64_1=sum64;function sum64_hi(ah,al,bh,bl){var lo=al+bl>>>0;var hi=(lo<al?1:0)+ah+bh;return hi>>>0}var sum64_hi_1=sum64_hi;function sum64_lo(ah,al,bh,bl){var lo=al+bl;return lo>>>0}var sum64_lo_1=sum64_lo;function sum64_4_hi(ah,al,bh,bl,ch,cl,dh,dl){var carry=0;var lo=al;lo=lo+bl>>>0;carry+=lo<al?1:0;lo=lo+cl>>>0;carry+=lo<cl?1:0;lo=lo+dl>>>0;carry+=lo<dl?1:0;var hi=ah+bh+ch+dh+carry;return hi>>>0}var sum64_4_hi_1=sum64_4_hi;function sum64_4_lo(ah,al,bh,bl,ch,cl,dh,dl){var lo=al+bl+cl+dl;return lo>>>0}var sum64_4_lo_1=sum64_4_lo;function sum64_5_hi(ah,al,bh,bl,ch,cl,dh,dl,eh,el){var carry=0;var lo=al;lo=lo+bl>>>0;carry+=lo<al?1:0;lo=lo+cl>>>0;carry+=lo<cl?1:0;lo=lo+dl>>>0;carry+=lo<dl?1:0;lo=lo+el>>>0;carry+=lo<el?1:0;var hi=ah+bh+ch+dh+eh+carry;return hi>>>0}var sum64_5_hi_1=sum64_5_hi;function sum64_5_lo(ah,al,bh,bl,ch,cl,dh,dl,eh,el){var lo=al+bl+cl+dl+el;return lo>>>0}var sum64_5_lo_1=sum64_5_lo;function rotr64_hi(ah,al,num){var r=al<<32-num|ah>>>num;return r>>>0}var rotr64_hi_1=rotr64_hi;function rotr64_lo(ah,al,num){var r=ah<<32-num|al>>>num;return r>>>0}var rotr64_lo_1=rotr64_lo;function shr64_hi(ah,al,num){return ah>>>num}var shr64_hi_1=shr64_hi;function shr64_lo(ah,al,num){var r=ah<<32-num|al>>>num;return r>>>0}var shr64_lo_1=shr64_lo;var utils={inherits:inherits_1,toArray:toArray_1,toHex:toHex_1,htonl:htonl_1,toHex32:toHex32_1,zero2:zero2_1,zero8:zero8_1,join32:join32_1,split32:split32_1,rotr32:rotr32_1,rotl32:rotl32_1,sum32:sum32_1,sum32_3:sum32_3_1,sum32_4:sum32_4_1,sum32_5:sum32_5_1,sum64:sum64_1,sum64_hi:sum64_hi_1,sum64_lo:sum64_lo_1,sum64_4_hi:sum64_4_hi_1,sum64_4_lo:sum64_4_lo_1,sum64_5_hi:sum64_5_hi_1,sum64_5_lo:sum64_5_lo_1,rotr64_hi:rotr64_hi_1,rotr64_lo:rotr64_lo_1,shr64_hi:shr64_hi_1,shr64_lo:shr64_lo_1};"use strict";function BlockHash(){this.pending=null;this.pendingTotal=0;this.blockSize=this.constructor.blockSize;this.outSize=this.constructor.outSize;this.hmacStrength=this.constructor.hmacStrength;this.padLength=this.constructor.padLength/8;this.endian="big";this._delta8=this.blockSize/8;this._delta32=this.blockSize/32}var BlockHash_1=BlockHash;BlockHash.prototype.update=function update(msg,enc){msg=utils.toArray(msg,enc);if(!this.pending)this.pending=msg;else this.pending=this.pending.concat(msg);this.pendingTotal+=msg.length;if(this.pending.length>=this._delta8){msg=this.pending;var r=msg.length%this._delta8;this.pending=msg.slice(msg.length-r,msg.length);if(this.pending.length===0)this.pending=null;msg=utils.join32(msg,0,msg.length-r,this.endian);for(var i=0;i<msg.length;i+=this._delta32)this._update(msg,i,i+this._delta32)}return this};BlockHash.prototype.digest=function digest(enc){this.update(this._pad());minimalisticAssert(this.pending===null);return this._digest(enc)};BlockHash.prototype._pad=function pad(){var len=this.pendingTotal;var bytes=this._delta8;var k=bytes-(len+this.padLength)%bytes;var res=new Array(k+this.padLength);res[0]=128;for(var i=1;i<k;i++)res[i]=0;len<<=3;if(this.endian==="big"){for(var t=8;t<this.padLength;t++)res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=len>>>24&255;res[i++]=len>>>16&255;res[i++]=len>>>8&255;res[i++]=len&255}else{res[i++]=len&255;res[i++]=len>>>8&255;res[i++]=len>>>16&255;res[i++]=len>>>24&255;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;for(t=8;t<this.padLength;t++)res[i++]=0}return res};var common={BlockHash:BlockHash_1};"use strict";var rotr32$1=utils.rotr32;function ft_1(s,x,y,z){if(s===0)return ch32(x,y,z);if(s===1||s===3)return p32(x,y,z);if(s===2)return maj32(x,y,z)}var ft_1_1=ft_1;function ch32(x,y,z){return x&y^~x&z}var ch32_1=ch32;function maj32(x,y,z){return x&y^x&z^y&z}var maj32_1=maj32;function p32(x,y,z){return x^y^z}var p32_1=p32;function s0_256(x){return rotr32$1(x,2)^rotr32$1(x,13)^rotr32$1(x,22)}var s0_256_1=s0_256;function s1_256(x){return rotr32$1(x,6)^rotr32$1(x,11)^rotr32$1(x,25)}var s1_256_1=s1_256;function g0_256(x){return rotr32$1(x,7)^rotr32$1(x,18)^x>>>3}var g0_256_1=g0_256;function g1_256(x){return rotr32$1(x,17)^rotr32$1(x,19)^x>>>10}var g1_256_1=g1_256;var common$1={ft_1:ft_1_1,ch32:ch32_1,maj32:maj32_1,p32:p32_1,s0_256:s0_256_1,s1_256:s1_256_1,g0_256:g0_256_1,g1_256:g1_256_1};"use strict";var rotl32$1=utils.rotl32;var sum32$1=utils.sum32;var sum32_5$1=utils.sum32_5;var ft_1$1=common$1.ft_1;var BlockHash$1=common.BlockHash;var sha1_K=[1518500249,1859775393,2400959708,3395469782];function SHA1(){if(!(this instanceof SHA1))return new SHA1;BlockHash$1.call(this);this.h=[1732584193,4023233417,2562383102,271733878,3285377520];this.W=new Array(80)}utils.inherits(SHA1,BlockHash$1);var _1=SHA1;SHA1.blockSize=512;SHA1.outSize=160;SHA1.hmacStrength=80;SHA1.padLength=64;SHA1.prototype._update=function _update(msg,start){var W=this.W;for(var i=0;i<16;i++)W[i]=msg[start+i];for(;i<W.length;i++)W[i]=rotl32$1(W[i-3]^W[i-8]^W[i-14]^W[i-16],1);var a=this.h[0];var b=this.h[1];var c=this.h[2];var d=this.h[3];var e=this.h[4];for(i=0;i<W.length;i++){var s=~~(i/20);var t=sum32_5$1(rotl32$1(a,5),ft_1$1(s,b,c,d),e,W[i],sha1_K[s]);e=d;d=c;c=rotl32$1(b,30);b=a;a=t}this.h[0]=sum32$1(this.h[0],a);this.h[1]=sum32$1(this.h[1],b);this.h[2]=sum32$1(this.h[2],c);this.h[3]=sum32$1(this.h[3],d);this.h[4]=sum32$1(this.h[4],e)};SHA1.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"big");else return utils.split32(this.h,"big")};"use strict";var sum32$2=utils.sum32;var sum32_4$1=utils.sum32_4;var sum32_5$2=utils.sum32_5;var ch32$1=common$1.ch32;var maj32$1=common$1.maj32;var s0_256$1=common$1.s0_256;var s1_256$1=common$1.s1_256;var g0_256$1=common$1.g0_256;var g1_256$1=common$1.g1_256;var BlockHash$2=common.BlockHash;var sha256_K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function SHA256(){if(!(this instanceof SHA256))return new SHA256;BlockHash$2.call(this);this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];this.k=sha256_K;this.W=new Array(64)}utils.inherits(SHA256,BlockHash$2);var _256=SHA256;SHA256.blockSize=512;SHA256.outSize=256;SHA256.hmacStrength=192;SHA256.padLength=64;SHA256.prototype._update=function _update(msg,start){var W=this.W;for(var i=0;i<16;i++)W[i]=msg[start+i];for(;i<W.length;i++)W[i]=sum32_4$1(g1_256$1(W[i-2]),W[i-7],g0_256$1(W[i-15]),W[i-16]);var a=this.h[0];var b=this.h[1];var c=this.h[2];var d=this.h[3];var e=this.h[4];var f=this.h[5];var g=this.h[6];var h=this.h[7];minimalisticAssert(this.k.length===W.length);for(i=0;i<W.length;i++){var T1=sum32_5$2(h,s1_256$1(e),ch32$1(e,f,g),this.k[i],W[i]);var T2=sum32$2(s0_256$1(a),maj32$1(a,b,c));h=g;g=f;f=e;e=sum32$2(d,T1);d=c;c=b;b=a;a=sum32$2(T1,T2)}this.h[0]=sum32$2(this.h[0],a);this.h[1]=sum32$2(this.h[1],b);this.h[2]=sum32$2(this.h[2],c);this.h[3]=sum32$2(this.h[3],d);this.h[4]=sum32$2(this.h[4],e);this.h[5]=sum32$2(this.h[5],f);this.h[6]=sum32$2(this.h[6],g);this.h[7]=sum32$2(this.h[7],h)};SHA256.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"big");else return utils.split32(this.h,"big")};"use strict";function SHA224(){if(!(this instanceof SHA224))return new SHA224;_256.call(this);this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}utils.inherits(SHA224,_256);var _224=SHA224;SHA224.blockSize=512;SHA224.outSize=224;SHA224.hmacStrength=192;SHA224.padLength=64;SHA224.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h.slice(0,7),"big");else return utils.split32(this.h.slice(0,7),"big")};"use strict";var rotr64_hi$1=utils.rotr64_hi;var rotr64_lo$1=utils.rotr64_lo;var shr64_hi$1=utils.shr64_hi;var shr64_lo$1=utils.shr64_lo;var sum64$1=utils.sum64;var sum64_hi$1=utils.sum64_hi;var sum64_lo$1=utils.sum64_lo;var sum64_4_hi$1=utils.sum64_4_hi;var sum64_4_lo$1=utils.sum64_4_lo;var sum64_5_hi$1=utils.sum64_5_hi;var sum64_5_lo$1=utils.sum64_5_lo;var BlockHash$3=common.BlockHash;var sha512_K=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function SHA512(){if(!(this instanceof SHA512))return new SHA512;BlockHash$3.call(this);this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209];this.k=sha512_K;this.W=new Array(160)}utils.inherits(SHA512,BlockHash$3);var _512=SHA512;SHA512.blockSize=1024;SHA512.outSize=512;SHA512.hmacStrength=192;SHA512.padLength=128;SHA512.prototype._prepareBlock=function _prepareBlock(msg,start){var W=this.W;for(var i=0;i<32;i++)W[i]=msg[start+i];for(;i<W.length;i+=2){var c0_hi=g1_512_hi(W[i-4],W[i-3]);var c0_lo=g1_512_lo(W[i-4],W[i-3]);var c1_hi=W[i-14];var c1_lo=W[i-13];var c2_hi=g0_512_hi(W[i-30],W[i-29]);var c2_lo=g0_512_lo(W[i-30],W[i-29]);var c3_hi=W[i-32];var c3_lo=W[i-31];W[i]=sum64_4_hi$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo);W[i+1]=sum64_4_lo$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo)}};SHA512.prototype._update=function _update(msg,start){this._prepareBlock(msg,start);var W=this.W;var ah=this.h[0];var al=this.h[1];var bh=this.h[2];var bl=this.h[3];var ch=this.h[4];var cl=this.h[5];var dh=this.h[6];var dl=this.h[7];var eh=this.h[8];var el=this.h[9];var fh=this.h[10];var fl=this.h[11];var gh=this.h[12];var gl=this.h[13];var hh=this.h[14];var hl=this.h[15];minimalisticAssert(this.k.length===W.length);for(var i=0;i<W.length;i+=2){var c0_hi=hh;var c0_lo=hl;var c1_hi=s1_512_hi(eh,el);var c1_lo=s1_512_lo(eh,el);var c2_hi=ch64_hi(eh,el,fh,fl,gh,gl);var c2_lo=ch64_lo(eh,el,fh,fl,gh,gl);var c3_hi=this.k[i];var c3_lo=this.k[i+1];var c4_hi=W[i];var c4_lo=W[i+1];var T1_hi=sum64_5_hi$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo,c4_hi,c4_lo);var T1_lo=sum64_5_lo$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo,c4_hi,c4_lo);c0_hi=s0_512_hi(ah,al);c0_lo=s0_512_lo(ah,al);c1_hi=maj64_hi(ah,al,bh,bl,ch,cl);c1_lo=maj64_lo(ah,al,bh,bl,ch,cl);var T2_hi=sum64_hi$1(c0_hi,c0_lo,c1_hi,c1_lo);var T2_lo=sum64_lo$1(c0_hi,c0_lo,c1_hi,c1_lo);hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;eh=sum64_hi$1(dh,dl,T1_hi,T1_lo);el=sum64_lo$1(dl,dl,T1_hi,T1_lo);dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;ah=sum64_hi$1(T1_hi,T1_lo,T2_hi,T2_lo);al=sum64_lo$1(T1_hi,T1_lo,T2_hi,T2_lo)}sum64$1(this.h,0,ah,al);sum64$1(this.h,2,bh,bl);sum64$1(this.h,4,ch,cl);sum64$1(this.h,6,dh,dl);sum64$1(this.h,8,eh,el);sum64$1(this.h,10,fh,fl);sum64$1(this.h,12,gh,gl);sum64$1(this.h,14,hh,hl)};SHA512.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"big");else return utils.split32(this.h,"big")};function ch64_hi(xh,xl,yh,yl,zh){var r=xh&yh^~xh&zh;if(r<0)r+=4294967296;return r}function ch64_lo(xh,xl,yh,yl,zh,zl){var r=xl&yl^~xl&zl;if(r<0)r+=4294967296;return r}function maj64_hi(xh,xl,yh,yl,zh){var r=xh&yh^xh&zh^yh&zh;if(r<0)r+=4294967296;return r}function maj64_lo(xh,xl,yh,yl,zh,zl){var r=xl&yl^xl&zl^yl&zl;if(r<0)r+=4294967296;return r}function s0_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,28);var c1_hi=rotr64_hi$1(xl,xh,2);var c2_hi=rotr64_hi$1(xl,xh,7);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function s0_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,28);var c1_lo=rotr64_lo$1(xl,xh,2);var c2_lo=rotr64_lo$1(xl,xh,7);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}function s1_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,14);var c1_hi=rotr64_hi$1(xh,xl,18);var c2_hi=rotr64_hi$1(xl,xh,9);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function s1_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,14);var c1_lo=rotr64_lo$1(xh,xl,18);var c2_lo=rotr64_lo$1(xl,xh,9);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}function g0_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,1);var c1_hi=rotr64_hi$1(xh,xl,8);var c2_hi=shr64_hi$1(xh,xl,7);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function g0_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,1);var c1_lo=rotr64_lo$1(xh,xl,8);var c2_lo=shr64_lo$1(xh,xl,7);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}function g1_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,19);var c1_hi=rotr64_hi$1(xl,xh,29);var c2_hi=shr64_hi$1(xh,xl,6);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function g1_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,19);var c1_lo=rotr64_lo$1(xl,xh,29);var c2_lo=shr64_lo$1(xh,xl,6);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}"use strict";function SHA384(){if(!(this instanceof SHA384))return new SHA384;_512.call(this);this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}utils.inherits(SHA384,_512);var _384=SHA384;SHA384.blockSize=1024;SHA384.outSize=384;SHA384.hmacStrength=192;SHA384.padLength=128;SHA384.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h.slice(0,12),"big");else return utils.split32(this.h.slice(0,12),"big")};"use strict";var sha1=_1;var sha224=_224;var sha256=_256;var sha384=_384;var sha512=_512;var sha={sha1:sha1,sha224:sha224,sha256:sha256,sha384:sha384,sha512:sha512};"use strict";var rotl32$2=utils.rotl32;var sum32$3=utils.sum32;var sum32_3$1=utils.sum32_3;var sum32_4$2=utils.sum32_4;var BlockHash$4=common.BlockHash;function RIPEMD160(){if(!(this instanceof RIPEMD160))return new RIPEMD160;BlockHash$4.call(this);this.h=[1732584193,4023233417,2562383102,271733878,3285377520];this.endian="little"}utils.inherits(RIPEMD160,BlockHash$4);var ripemd160=RIPEMD160;RIPEMD160.blockSize=512;RIPEMD160.outSize=160;RIPEMD160.hmacStrength=192;RIPEMD160.padLength=64;RIPEMD160.prototype._update=function update(msg,start){var A=this.h[0];var B=this.h[1];var C=this.h[2];var D=this.h[3];var E=this.h[4];var Ah=A;var Bh=B;var Ch=C;var Dh=D;var Eh=E;for(var j=0;j<80;j++){var T=sum32$3(rotl32$2(sum32_4$2(A,f(j,B,C,D),msg[r[j]+start],K(j)),s[j]),E);A=E;E=D;D=rotl32$2(C,10);C=B;B=T;T=sum32$3(rotl32$2(sum32_4$2(Ah,f(79-j,Bh,Ch,Dh),msg[rh[j]+start],Kh(j)),sh[j]),Eh);Ah=Eh;Eh=Dh;Dh=rotl32$2(Ch,10);Ch=Bh;Bh=T}T=sum32_3$1(this.h[1],C,Dh);this.h[1]=sum32_3$1(this.h[2],D,Eh);this.h[2]=sum32_3$1(this.h[3],E,Ah);this.h[3]=sum32_3$1(this.h[4],A,Bh);this.h[4]=sum32_3$1(this.h[0],B,Ch);this.h[0]=T};RIPEMD160.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"little");else return utils.split32(this.h,"little")};function f(j,x,y,z){if(j<=15)return x^y^z;else if(j<=31)return x&y|~x&z;else if(j<=47)return(x|~y)^z;else if(j<=63)return x&z|y&~z;else return x^(y|~z)}function K(j){if(j<=15)return 0;else if(j<=31)return 1518500249;else if(j<=47)return 1859775393;else if(j<=63)return 2400959708;else return 2840853838}function Kh(j){if(j<=15)return 1352829926;else if(j<=31)return 1548603684;else if(j<=47)return 1836072691;else if(j<=63)return 2053994217;else return 0}var r=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13];var rh=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11];var s=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6];var sh=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11];var ripemd={ripemd160:ripemd160};"use strict";function Hmac(hash,key,enc){if(!(this instanceof Hmac))return new Hmac(hash,key,enc);this.Hash=hash;this.blockSize=hash.blockSize/8;this.outSize=hash.outSize/8;this.inner=null;this.outer=null;this._init(utils.toArray(key,enc))}var hmac=Hmac;Hmac.prototype._init=function init(key){if(key.length>this.blockSize)key=(new this.Hash).update(key).digest();minimalisticAssert(key.length<=this.blockSize);for(var i=key.length;i<this.blockSize;i++)key.push(0);for(i=0;i<key.length;i++)key[i]^=54;this.inner=(new this.Hash).update(key);for(i=0;i<key.length;i++)key[i]^=106;this.outer=(new this.Hash).update(key)};Hmac.prototype.update=function update(msg,enc){this.inner.update(msg,enc);return this};Hmac.prototype.digest=function digest(enc){this.outer.update(this.inner.digest());return this.outer.digest(enc)};var hash_1=createCommonjsModule(function(module,exports){var hash=exports;hash.utils=utils;hash.common=common;hash.sha=sha;hash.ripemd=ripemd;hash.hmac=hmac;hash.sha1=hash.sha.sha1;hash.sha256=hash.sha.sha256;hash.sha224=hash.sha.sha224;hash.sha384=hash.sha.sha384;hash.sha512=hash.sha.sha512;hash.ripemd160=hash.ripemd.ripemd160});var commonjsGlobal$1=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof __webpack_require__.g!=="undefined"?__webpack_require__.g:typeof self!=="undefined"?self:{};function getDefaultExportFromCjs$1(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function createCommonjsModule$1(fn,basedir,module){return module={path:basedir,exports:{},require:function(path,base){return commonjsRequire$1(path,base===undefined||base===null?module.path:base)}},fn(module,module.exports),module.exports}function getDefaultExportFromNamespaceIfPresent$1(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")?n["default"]:n}function getDefaultExportFromNamespaceIfNotNamed$1(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")&&Object.keys(n).length===1?n["default"]:n}function getAugmentedNamespace$1(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:true});Object.keys(n).forEach(function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:true,get:function(){return n[k]}})});return a}function commonjsRequire$1(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var minimalisticAssert$1=assert$1;function assert$1(val,msg){if(!val)throw new Error(msg||"Assertion failed")}assert$1.equal=function assertEqual(l,r,msg){if(l!=r)throw new Error(msg||"Assertion failed: "+l+" != "+r)};var utils_1=createCommonjsModule$1(function(module,exports){"use strict";var utils=exports;function toArray(msg,enc){if(Array.isArray(msg))return msg.slice();if(!msg)return[];var res=[];if(typeof msg!=="string"){for(var i=0;i<msg.length;i++)res[i]=msg[i]|0;return res}if(enc==="hex"){msg=msg.replace(/[^a-z0-9]+/gi,"");if(msg.length%2!==0)msg="0"+msg;for(var i=0;i<msg.length;i+=2)res.push(parseInt(msg[i]+msg[i+1],16))}else{for(var i=0;i<msg.length;i++){var c=msg.charCodeAt(i);var hi=c>>8;var lo=c&255;if(hi)res.push(hi,lo);else res.push(lo)}}return res}utils.toArray=toArray;function zero2(word){if(word.length===1)return"0"+word;else return word}utils.zero2=zero2;function toHex(msg){var res="";for(var i=0;i<msg.length;i++)res+=zero2(msg[i].toString(16));return res}utils.toHex=toHex;utils.encode=function encode(arr,enc){if(enc==="hex")return toHex(arr);else return arr}});var utils_1$1=createCommonjsModule$1(function(module,exports){"use strict";var utils=exports;utils.assert=minimalisticAssert$1;utils.toArray=utils_1.toArray;utils.zero2=utils_1.zero2;utils.toHex=utils_1.toHex;utils.encode=utils_1.encode;function getNAF(num,w,bits){var naf=new Array(Math.max(num.bitLength(),bits)+1);naf.fill(0);var ws=1<<w+1;var k=num.clone();for(var i=0;i<naf.length;i++){var z;var mod=k.andln(ws-1);if(k.isOdd()){if(mod>(ws>>1)-1)z=(ws>>1)-mod;else z=mod;k.isubn(z)}else{z=0}naf[i]=z;k.iushrn(1)}return naf}utils.getNAF=getNAF;function getJSF(k1,k2){var jsf=[[],[]];k1=k1.clone();k2=k2.clone();var d1=0;var d2=0;var m8;while(k1.cmpn(-d1)>0||k2.cmpn(-d2)>0){var m14=k1.andln(3)+d1&3;var m24=k2.andln(3)+d2&3;if(m14===3)m14=-1;if(m24===3)m24=-1;var u1;if((m14&1)===0){u1=0}else{m8=k1.andln(7)+d1&7;if((m8===3||m8===5)&&m24===2)u1=-m14;else u1=m14}jsf[0].push(u1);var u2;if((m24&1)===0){u2=0}else{m8=k2.andln(7)+d2&7;if((m8===3||m8===5)&&m14===2)u2=-m24;else u2=m24}jsf[1].push(u2);if(2*d1===u1+1)d1=1-d1;if(2*d2===u2+1)d2=1-d2;k1.iushrn(1);k2.iushrn(1)}return jsf}utils.getJSF=getJSF;function cachedProperty(obj,name,computer){var key="_"+name;obj.prototype[name]=function cachedProperty(){return this[key]!==undefined?this[key]:this[key]=computer.call(this)}}utils.cachedProperty=cachedProperty;function parseBytes(bytes){return typeof bytes==="string"?utils.toArray(bytes,"hex"):bytes}utils.parseBytes=parseBytes;function intFromLE(bytes){return new bn(bytes,"hex","le")}utils.intFromLE=intFromLE});"use strict";var getNAF=utils_1$1.getNAF;var getJSF=utils_1$1.getJSF;var assert$1$1=utils_1$1.assert;function BaseCurve(type,conf){this.type=type;this.p=new bn(conf.p,16);this.red=conf.prime?bn.red(conf.prime):bn.mont(this.p);this.zero=new bn(0).toRed(this.red);this.one=new bn(1).toRed(this.red);this.two=new bn(2).toRed(this.red);this.n=conf.n&&new bn(conf.n,16);this.g=conf.g&&this.pointFromJSON(conf.g,conf.gRed);this._wnafT1=new Array(4);this._wnafT2=new Array(4);this._wnafT3=new Array(4);this._wnafT4=new Array(4);this._bitLength=this.n?this.n.bitLength():0;var adjustCount=this.n&&this.p.div(this.n);if(!adjustCount||adjustCount.cmpn(100)>0){this.redN=null}else{this._maxwellTrick=true;this.redN=this.n.toRed(this.red)}}var base=BaseCurve;BaseCurve.prototype.point=function point(){throw new Error("Not implemented")};BaseCurve.prototype.validate=function validate(){throw new Error("Not implemented")};BaseCurve.prototype._fixedNafMul=function _fixedNafMul(p,k){assert$1$1(p.precomputed);var doubles=p._getDoubles();var naf=getNAF(k,1,this._bitLength);var I=(1<<doubles.step+1)-(doubles.step%2===0?2:1);I/=3;var repr=[];var j;var nafW;for(j=0;j<naf.length;j+=doubles.step){nafW=0;for(var l=j+doubles.step-1;l>=j;l--)nafW=(nafW<<1)+naf[l];repr.push(nafW)}var a=this.jpoint(null,null,null);var b=this.jpoint(null,null,null);for(var i=I;i>0;i--){for(j=0;j<repr.length;j++){nafW=repr[j];if(nafW===i)b=b.mixedAdd(doubles.points[j]);else if(nafW===-i)b=b.mixedAdd(doubles.points[j].neg())}a=a.add(b)}return a.toP()};BaseCurve.prototype._wnafMul=function _wnafMul(p,k){var w=4;var nafPoints=p._getNAFPoints(w);w=nafPoints.wnd;var wnd=nafPoints.points;var naf=getNAF(k,w,this._bitLength);var acc=this.jpoint(null,null,null);for(var i=naf.length-1;i>=0;i--){for(var l=0;i>=0&&naf[i]===0;i--)l++;if(i>=0)l++;acc=acc.dblp(l);if(i<0)break;var z=naf[i];assert$1$1(z!==0);if(p.type==="affine"){if(z>0)acc=acc.mixedAdd(wnd[z-1>>1]);else acc=acc.mixedAdd(wnd[-z-1>>1].neg())}else{if(z>0)acc=acc.add(wnd[z-1>>1]);else acc=acc.add(wnd[-z-1>>1].neg())}}return p.type==="affine"?acc.toP():acc};BaseCurve.prototype._wnafMulAdd=function _wnafMulAdd(defW,points,coeffs,len,jacobianResult){var wndWidth=this._wnafT1;var wnd=this._wnafT2;var naf=this._wnafT3;var max=0;var i;var j;var p;for(i=0;i<len;i++){p=points[i];var nafPoints=p._getNAFPoints(defW);wndWidth[i]=nafPoints.wnd;wnd[i]=nafPoints.points}for(i=len-1;i>=1;i-=2){var a=i-1;var b=i;if(wndWidth[a]!==1||wndWidth[b]!==1){naf[a]=getNAF(coeffs[a],wndWidth[a],this._bitLength);naf[b]=getNAF(coeffs[b],wndWidth[b],this._bitLength);max=Math.max(naf[a].length,max);max=Math.max(naf[b].length,max);continue}var comb=[points[a],null,null,points[b]];if(points[a].y.cmp(points[b].y)===0){comb[1]=points[a].add(points[b]);comb[2]=points[a].toJ().mixedAdd(points[b].neg())}else if(points[a].y.cmp(points[b].y.redNeg())===0){comb[1]=points[a].toJ().mixedAdd(points[b]);comb[2]=points[a].add(points[b].neg())}else{comb[1]=points[a].toJ().mixedAdd(points[b]);comb[2]=points[a].toJ().mixedAdd(points[b].neg())}var index=[-3,-1,-5,-7,0,7,5,1,3];var jsf=getJSF(coeffs[a],coeffs[b]);max=Math.max(jsf[0].length,max);naf[a]=new Array(max);naf[b]=new Array(max);for(j=0;j<max;j++){var ja=jsf[0][j]|0;var jb=jsf[1][j]|0;naf[a][j]=index[(ja+1)*3+(jb+1)];naf[b][j]=0;wnd[a]=comb}}var acc=this.jpoint(null,null,null);var tmp=this._wnafT4;for(i=max;i>=0;i--){var k=0;while(i>=0){var zero=true;for(j=0;j<len;j++){tmp[j]=naf[j][i]|0;if(tmp[j]!==0)zero=false}if(!zero)break;k++;i--}if(i>=0)k++;acc=acc.dblp(k);if(i<0)break;for(j=0;j<len;j++){var z=tmp[j];p;if(z===0)continue;else if(z>0)p=wnd[j][z-1>>1];else if(z<0)p=wnd[j][-z-1>>1].neg();if(p.type==="affine")acc=acc.mixedAdd(p);else acc=acc.add(p)}}for(i=0;i<len;i++)wnd[i]=null;if(jacobianResult)return acc;else return acc.toP()};function BasePoint(curve,type){this.curve=curve;this.type=type;this.precomputed=null}BaseCurve.BasePoint=BasePoint;BasePoint.prototype.eq=function eq(){throw new Error("Not implemented")};BasePoint.prototype.validate=function validate(){return this.curve.validate(this)};BaseCurve.prototype.decodePoint=function decodePoint(bytes,enc){bytes=utils_1$1.toArray(bytes,enc);var len=this.p.byteLength();if((bytes[0]===4||bytes[0]===6||bytes[0]===7)&&bytes.length-1===2*len){if(bytes[0]===6)assert$1$1(bytes[bytes.length-1]%2===0);else if(bytes[0]===7)assert$1$1(bytes[bytes.length-1]%2===1);var res=this.point(bytes.slice(1,1+len),bytes.slice(1+len,1+2*len));return res}else if((bytes[0]===2||bytes[0]===3)&&bytes.length-1===len){return this.pointFromX(bytes.slice(1,1+len),bytes[0]===3)}throw new Error("Unknown point format")};BasePoint.prototype.encodeCompressed=function encodeCompressed(enc){return this.encode(enc,true)};BasePoint.prototype._encode=function _encode(compact){var len=this.curve.p.byteLength();var x=this.getX().toArray("be",len);if(compact)return[this.getY().isEven()?2:3].concat(x);return[4].concat(x,this.getY().toArray("be",len))};BasePoint.prototype.encode=function encode(enc,compact){return utils_1$1.encode(this._encode(compact),enc)};BasePoint.prototype.precompute=function precompute(power){if(this.precomputed)return this;var precomputed={doubles:null,naf:null,beta:null};precomputed.naf=this._getNAFPoints(8);precomputed.doubles=this._getDoubles(4,power);precomputed.beta=this._getBeta();this.precomputed=precomputed;return this};BasePoint.prototype._hasDoubles=function _hasDoubles(k){if(!this.precomputed)return false;var doubles=this.precomputed.doubles;if(!doubles)return false;return doubles.points.length>=Math.ceil((k.bitLength()+1)/doubles.step)};BasePoint.prototype._getDoubles=function _getDoubles(step,power){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;var doubles=[this];var acc=this;for(var i=0;i<power;i+=step){for(var j=0;j<step;j++)acc=acc.dbl();doubles.push(acc)}return{step:step,points:doubles}};BasePoint.prototype._getNAFPoints=function _getNAFPoints(wnd){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;var res=[this];var max=(1<<wnd)-1;var dbl=max===1?null:this.dbl();for(var i=1;i<max;i++)res[i]=res[i-1].add(dbl);return{wnd:wnd,points:res}};BasePoint.prototype._getBeta=function _getBeta(){return null};BasePoint.prototype.dblp=function dblp(k){var r=this;for(var i=0;i<k;i++)r=r.dbl();return r};var inherits_browser$1=createCommonjsModule$1(function(module){if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}}else{module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}}}});"use strict";var assert$2=utils_1$1.assert;function ShortCurve(conf){base.call(this,"short",conf);this.a=new bn(conf.a,16).toRed(this.red);this.b=new bn(conf.b,16).toRed(this.red);this.tinv=this.two.redInvm();this.zeroA=this.a.fromRed().cmpn(0)===0;this.threeA=this.a.fromRed().sub(this.p).cmpn(-3)===0;this.endo=this._getEndomorphism(conf);this._endoWnafT1=new Array(4);this._endoWnafT2=new Array(4)}inherits_browser$1(ShortCurve,base);var short_1=ShortCurve;ShortCurve.prototype._getEndomorphism=function _getEndomorphism(conf){if(!this.zeroA||!this.g||!this.n||this.p.modn(3)!==1)return;var beta;var lambda;if(conf.beta){beta=new bn(conf.beta,16).toRed(this.red)}else{var betas=this._getEndoRoots(this.p);beta=betas[0].cmp(betas[1])<0?betas[0]:betas[1];beta=beta.toRed(this.red)}if(conf.lambda){lambda=new bn(conf.lambda,16)}else{var lambdas=this._getEndoRoots(this.n);if(this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta))===0){lambda=lambdas[0]}else{lambda=lambdas[1];assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta))===0)}}var basis;if(conf.basis){basis=conf.basis.map(function(vec){return{a:new bn(vec.a,16),b:new bn(vec.b,16)}})}else{basis=this._getEndoBasis(lambda)}return{beta:beta,lambda:lambda,basis:basis}};ShortCurve.prototype._getEndoRoots=function _getEndoRoots(num){var red=num===this.p?this.red:bn.mont(num);var tinv=new bn(2).toRed(red).redInvm();var ntinv=tinv.redNeg();var s=new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);var l1=ntinv.redAdd(s).fromRed();var l2=ntinv.redSub(s).fromRed();return[l1,l2]};ShortCurve.prototype._getEndoBasis=function _getEndoBasis(lambda){var aprxSqrt=this.n.ushrn(Math.floor(this.n.bitLength()/2));var u=lambda;var v=this.n.clone();var x1=new bn(1);var y1=new bn(0);var x2=new bn(0);var y2=new bn(1);var a0;var b0;var a1;var b1;var a2;var b2;var prevR;var i=0;var r;var x;while(u.cmpn(0)!==0){var q=v.div(u);r=v.sub(q.mul(u));x=x2.sub(q.mul(x1));var y=y2.sub(q.mul(y1));if(!a1&&r.cmp(aprxSqrt)<0){a0=prevR.neg();b0=x1;a1=r.neg();b1=x}else if(a1&&++i===2){break}prevR=r;v=u;u=r;x2=x1;x1=x;y2=y1;y1=y}a2=r.neg();b2=x;var len1=a1.sqr().add(b1.sqr());var len2=a2.sqr().add(b2.sqr());if(len2.cmp(len1)>=0){a2=a0;b2=b0}if(a1.negative){a1=a1.neg();b1=b1.neg()}if(a2.negative){a2=a2.neg();b2=b2.neg()}return[{a:a1,b:b1},{a:a2,b:b2}]};ShortCurve.prototype._endoSplit=function _endoSplit(k){var basis=this.endo.basis;var v1=basis[0];var v2=basis[1];var c1=v2.b.mul(k).divRound(this.n);var c2=v1.b.neg().mul(k).divRound(this.n);var p1=c1.mul(v1.a);var p2=c2.mul(v2.a);var q1=c1.mul(v1.b);var q2=c2.mul(v2.b);var k1=k.sub(p1).sub(p2);var k2=q1.add(q2).neg();return{k1:k1,k2:k2}};ShortCurve.prototype.pointFromX=function pointFromX(x,odd){x=new bn(x,16);if(!x.red)x=x.toRed(this.red);var y2=x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);var y=y2.redSqrt();if(y.redSqr().redSub(y2).cmp(this.zero)!==0)throw new Error("invalid point");var isOdd=y.fromRed().isOdd();if(odd&&!isOdd||!odd&&isOdd)y=y.redNeg();return this.point(x,y)};ShortCurve.prototype.validate=function validate(point){if(point.inf)return true;var x=point.x;var y=point.y;var ax=this.a.redMul(x);var rhs=x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);return y.redSqr().redISub(rhs).cmpn(0)===0};ShortCurve.prototype._endoWnafMulAdd=function _endoWnafMulAdd(points,coeffs,jacobianResult){var npoints=this._endoWnafT1;var ncoeffs=this._endoWnafT2;for(var i=0;i<points.length;i++){var split=this._endoSplit(coeffs[i]);var p=points[i];var beta=p._getBeta();if(split.k1.negative){split.k1.ineg();p=p.neg(true)}if(split.k2.negative){split.k2.ineg();beta=beta.neg(true)}npoints[i*2]=p;npoints[i*2+1]=beta;ncoeffs[i*2]=split.k1;ncoeffs[i*2+1]=split.k2}var res=this._wnafMulAdd(1,npoints,ncoeffs,i*2,jacobianResult);for(var j=0;j<i*2;j++){npoints[j]=null;ncoeffs[j]=null}return res};function Point(curve,x,y,isRed){base.BasePoint.call(this,curve,"affine");if(x===null&&y===null){this.x=null;this.y=null;this.inf=true}else{this.x=new bn(x,16);this.y=new bn(y,16);if(isRed){this.x.forceRed(this.curve.red);this.y.forceRed(this.curve.red)}if(!this.x.red)this.x=this.x.toRed(this.curve.red);if(!this.y.red)this.y=this.y.toRed(this.curve.red);this.inf=false}}inherits_browser$1(Point,base.BasePoint);ShortCurve.prototype.point=function point(x,y,isRed){return new Point(this,x,y,isRed)};ShortCurve.prototype.pointFromJSON=function pointFromJSON(obj,red){return Point.fromJSON(this,obj,red)};Point.prototype._getBeta=function _getBeta(){if(!this.curve.endo)return;var pre=this.precomputed;if(pre&&pre.beta)return pre.beta;var beta=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(pre){var curve=this.curve;var endoMul=function(p){return curve.point(p.x.redMul(curve.endo.beta),p.y)};pre.beta=beta;beta.precomputed={beta:null,naf:pre.naf&&{wnd:pre.naf.wnd,points:pre.naf.points.map(endoMul)},doubles:pre.doubles&&{step:pre.doubles.step,points:pre.doubles.points.map(endoMul)}}}return beta};Point.prototype.toJSON=function toJSON(){if(!this.precomputed)return[this.x,this.y];return[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]};Point.fromJSON=function fromJSON(curve,obj,red){if(typeof obj==="string")obj=JSON.parse(obj);var res=curve.point(obj[0],obj[1],red);if(!obj[2])return res;function obj2point(obj){return curve.point(obj[0],obj[1],red)}var pre=obj[2];res.precomputed={beta:null,doubles:pre.doubles&&{step:pre.doubles.step,points:[res].concat(pre.doubles.points.map(obj2point))},naf:pre.naf&&{wnd:pre.naf.wnd,points:[res].concat(pre.naf.points.map(obj2point))}};return res};Point.prototype.inspect=function inspect(){if(this.isInfinity())return"<EC Point Infinity>";return"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"};Point.prototype.isInfinity=function isInfinity(){return this.inf};Point.prototype.add=function add(p){if(this.inf)return p;if(p.inf)return this;if(this.eq(p))return this.dbl();if(this.neg().eq(p))return this.curve.point(null,null);if(this.x.cmp(p.x)===0)return this.curve.point(null,null);var c=this.y.redSub(p.y);if(c.cmpn(0)!==0)c=c.redMul(this.x.redSub(p.x).redInvm());var nx=c.redSqr().redISub(this.x).redISub(p.x);var ny=c.redMul(this.x.redSub(nx)).redISub(this.y);return this.curve.point(nx,ny)};Point.prototype.dbl=function dbl(){if(this.inf)return this;var ys1=this.y.redAdd(this.y);if(ys1.cmpn(0)===0)return this.curve.point(null,null);var a=this.curve.a;var x2=this.x.redSqr();var dyinv=ys1.redInvm();var c=x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);var nx=c.redSqr().redISub(this.x.redAdd(this.x));var ny=c.redMul(this.x.redSub(nx)).redISub(this.y);return this.curve.point(nx,ny)};Point.prototype.getX=function getX(){return this.x.fromRed()};Point.prototype.getY=function getY(){return this.y.fromRed()};Point.prototype.mul=function mul(k){k=new bn(k,16);if(this.isInfinity())return this;else if(this._hasDoubles(k))return this.curve._fixedNafMul(this,k);else if(this.curve.endo)return this.curve._endoWnafMulAdd([this],[k]);else return this.curve._wnafMul(this,k)};Point.prototype.mulAdd=function mulAdd(k1,p2,k2){var points=[this,p2];var coeffs=[k1,k2];if(this.curve.endo)return this.curve._endoWnafMulAdd(points,coeffs);else return this.curve._wnafMulAdd(1,points,coeffs,2)};Point.prototype.jmulAdd=function jmulAdd(k1,p2,k2){var points=[this,p2];var coeffs=[k1,k2];if(this.curve.endo)return this.curve._endoWnafMulAdd(points,coeffs,true);else return this.curve._wnafMulAdd(1,points,coeffs,2,true)};Point.prototype.eq=function eq(p){return this===p||this.inf===p.inf&&(this.inf||this.x.cmp(p.x)===0&&this.y.cmp(p.y)===0)};Point.prototype.neg=function neg(_precompute){if(this.inf)return this;var res=this.curve.point(this.x,this.y.redNeg());if(_precompute&&this.precomputed){var pre=this.precomputed;var negate=function(p){return p.neg()};res.precomputed={naf:pre.naf&&{wnd:pre.naf.wnd,points:pre.naf.points.map(negate)},doubles:pre.doubles&&{step:pre.doubles.step,points:pre.doubles.points.map(negate)}}}return res};Point.prototype.toJ=function toJ(){if(this.inf)return this.curve.jpoint(null,null,null);var res=this.curve.jpoint(this.x,this.y,this.curve.one);return res};function JPoint(curve,x,y,z){base.BasePoint.call(this,curve,"jacobian");if(x===null&&y===null&&z===null){this.x=this.curve.one;this.y=this.curve.one;this.z=new bn(0)}else{this.x=new bn(x,16);this.y=new bn(y,16);this.z=new bn(z,16)}if(!this.x.red)this.x=this.x.toRed(this.curve.red);if(!this.y.red)this.y=this.y.toRed(this.curve.red);if(!this.z.red)this.z=this.z.toRed(this.curve.red);this.zOne=this.z===this.curve.one}inherits_browser$1(JPoint,base.BasePoint);ShortCurve.prototype.jpoint=function jpoint(x,y,z){return new JPoint(this,x,y,z)};JPoint.prototype.toP=function toP(){if(this.isInfinity())return this.curve.point(null,null);var zinv=this.z.redInvm();var zinv2=zinv.redSqr();var ax=this.x.redMul(zinv2);var ay=this.y.redMul(zinv2).redMul(zinv);return this.curve.point(ax,ay)};JPoint.prototype.neg=function neg(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)};JPoint.prototype.add=function add(p){if(this.isInfinity())return p;if(p.isInfinity())return this;var pz2=p.z.redSqr();var z2=this.z.redSqr();var u1=this.x.redMul(pz2);var u2=p.x.redMul(z2);var s1=this.y.redMul(pz2.redMul(p.z));var s2=p.y.redMul(z2.redMul(this.z));var h=u1.redSub(u2);var r=s1.redSub(s2);if(h.cmpn(0)===0){if(r.cmpn(0)!==0)return this.curve.jpoint(null,null,null);else return this.dbl()}var h2=h.redSqr();var h3=h2.redMul(h);var v=u1.redMul(h2);var nx=r.redSqr().redIAdd(h3).redISub(v).redISub(v);var ny=r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));var nz=this.z.redMul(p.z).redMul(h);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.mixedAdd=function mixedAdd(p){if(this.isInfinity())return p.toJ();if(p.isInfinity())return this;var z2=this.z.redSqr();var u1=this.x;var u2=p.x.redMul(z2);var s1=this.y;var s2=p.y.redMul(z2).redMul(this.z);var h=u1.redSub(u2);var r=s1.redSub(s2);if(h.cmpn(0)===0){if(r.cmpn(0)!==0)return this.curve.jpoint(null,null,null);else return this.dbl()}var h2=h.redSqr();var h3=h2.redMul(h);var v=u1.redMul(h2);var nx=r.redSqr().redIAdd(h3).redISub(v).redISub(v);var ny=r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));var nz=this.z.redMul(h);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.dblp=function dblp(pow){if(pow===0)return this;if(this.isInfinity())return this;if(!pow)return this.dbl();var i;if(this.curve.zeroA||this.curve.threeA){var r=this;for(i=0;i<pow;i++)r=r.dbl();return r}var a=this.curve.a;var tinv=this.curve.tinv;var jx=this.x;var jy=this.y;var jz=this.z;var jz4=jz.redSqr().redSqr();var jyd=jy.redAdd(jy);for(i=0;i<pow;i++){var jx2=jx.redSqr();var jyd2=jyd.redSqr();var jyd4=jyd2.redSqr();var c=jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));var t1=jx.redMul(jyd2);var nx=c.redSqr().redISub(t1.redAdd(t1));var t2=t1.redISub(nx);var dny=c.redMul(t2);dny=dny.redIAdd(dny).redISub(jyd4);var nz=jyd.redMul(jz);if(i+1<pow)jz4=jz4.redMul(jyd4);jx=nx;jz=nz;jyd=dny}return this.curve.jpoint(jx,jyd.redMul(tinv),jz)};JPoint.prototype.dbl=function dbl(){if(this.isInfinity())return this;if(this.curve.zeroA)return this._zeroDbl();else if(this.curve.threeA)return this._threeDbl();else return this._dbl()};JPoint.prototype._zeroDbl=function _zeroDbl(){var nx;var ny;var nz;if(this.zOne){var xx=this.x.redSqr();var yy=this.y.redSqr();var yyyy=yy.redSqr();var s=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);s=s.redIAdd(s);var m=xx.redAdd(xx).redIAdd(xx);var t=m.redSqr().redISub(s).redISub(s);var yyyy8=yyyy.redIAdd(yyyy);yyyy8=yyyy8.redIAdd(yyyy8);yyyy8=yyyy8.redIAdd(yyyy8);nx=t;ny=m.redMul(s.redISub(t)).redISub(yyyy8);nz=this.y.redAdd(this.y)}else{var a=this.x.redSqr();var b=this.y.redSqr();var c=b.redSqr();var d=this.x.redAdd(b).redSqr().redISub(a).redISub(c);d=d.redIAdd(d);var e=a.redAdd(a).redIAdd(a);var f=e.redSqr();var c8=c.redIAdd(c);c8=c8.redIAdd(c8);c8=c8.redIAdd(c8);nx=f.redISub(d).redISub(d);ny=e.redMul(d.redISub(nx)).redISub(c8);nz=this.y.redMul(this.z);nz=nz.redIAdd(nz)}return this.curve.jpoint(nx,ny,nz)};JPoint.prototype._threeDbl=function _threeDbl(){var nx;var ny;var nz;if(this.zOne){var xx=this.x.redSqr();var yy=this.y.redSqr();var yyyy=yy.redSqr();var s=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);s=s.redIAdd(s);var m=xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);var t=m.redSqr().redISub(s).redISub(s);nx=t;var yyyy8=yyyy.redIAdd(yyyy);yyyy8=yyyy8.redIAdd(yyyy8);yyyy8=yyyy8.redIAdd(yyyy8);ny=m.redMul(s.redISub(t)).redISub(yyyy8);nz=this.y.redAdd(this.y)}else{var delta=this.z.redSqr();var gamma=this.y.redSqr();var beta=this.x.redMul(gamma);var alpha=this.x.redSub(delta).redMul(this.x.redAdd(delta));alpha=alpha.redAdd(alpha).redIAdd(alpha);var beta4=beta.redIAdd(beta);beta4=beta4.redIAdd(beta4);var beta8=beta4.redAdd(beta4);nx=alpha.redSqr().redISub(beta8);nz=this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);var ggamma8=gamma.redSqr();ggamma8=ggamma8.redIAdd(ggamma8);ggamma8=ggamma8.redIAdd(ggamma8);ggamma8=ggamma8.redIAdd(ggamma8);ny=alpha.redMul(beta4.redISub(nx)).redISub(ggamma8)}return this.curve.jpoint(nx,ny,nz)};JPoint.prototype._dbl=function _dbl(){var a=this.curve.a;var jx=this.x;var jy=this.y;var jz=this.z;var jz4=jz.redSqr().redSqr();var jx2=jx.redSqr();var jy2=jy.redSqr();var c=jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));var jxd4=jx.redAdd(jx);jxd4=jxd4.redIAdd(jxd4);var t1=jxd4.redMul(jy2);var nx=c.redSqr().redISub(t1.redAdd(t1));var t2=t1.redISub(nx);var jyd8=jy2.redSqr();jyd8=jyd8.redIAdd(jyd8);jyd8=jyd8.redIAdd(jyd8);jyd8=jyd8.redIAdd(jyd8);var ny=c.redMul(t2).redISub(jyd8);var nz=jy.redAdd(jy).redMul(jz);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.trpl=function trpl(){if(!this.curve.zeroA)return this.dbl().add(this);var xx=this.x.redSqr();var yy=this.y.redSqr();var zz=this.z.redSqr();var yyyy=yy.redSqr();var m=xx.redAdd(xx).redIAdd(xx);var mm=m.redSqr();var e=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);e=e.redIAdd(e);e=e.redAdd(e).redIAdd(e);e=e.redISub(mm);var ee=e.redSqr();var t=yyyy.redIAdd(yyyy);t=t.redIAdd(t);t=t.redIAdd(t);t=t.redIAdd(t);var u=m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);var yyu4=yy.redMul(u);yyu4=yyu4.redIAdd(yyu4);yyu4=yyu4.redIAdd(yyu4);var nx=this.x.redMul(ee).redISub(yyu4);nx=nx.redIAdd(nx);nx=nx.redIAdd(nx);var ny=this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));ny=ny.redIAdd(ny);ny=ny.redIAdd(ny);ny=ny.redIAdd(ny);var nz=this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.mul=function mul(k,kbase){k=new bn(k,kbase);return this.curve._wnafMul(this,k)};JPoint.prototype.eq=function eq(p){if(p.type==="affine")return this.eq(p.toJ());if(this===p)return true;var z2=this.z.redSqr();var pz2=p.z.redSqr();if(this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0)!==0)return false;var z3=z2.redMul(this.z);var pz3=pz2.redMul(p.z);return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0)===0};JPoint.prototype.eqXToP=function eqXToP(x){var zs=this.z.redSqr();var rx=x.toRed(this.curve.red).redMul(zs);if(this.x.cmp(rx)===0)return true;var xc=x.clone();var t=this.curve.redN.redMul(zs);for(;;){xc.iadd(this.curve.n);if(xc.cmp(this.curve.p)>=0)return false;rx.redIAdd(t);if(this.x.cmp(rx)===0)return true}};JPoint.prototype.inspect=function inspect(){if(this.isInfinity())return"<EC JPoint Infinity>";return"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"};JPoint.prototype.isInfinity=function isInfinity(){return this.z.cmpn(0)===0};var curve_1=createCommonjsModule$1(function(module,exports){"use strict";var curve=exports;curve.base=base;curve.short=short_1;curve.mont=null;curve.edwards=null});var curves_1=createCommonjsModule$1(function(module,exports){"use strict";var curves=exports;var assert=utils_1$1.assert;function PresetCurve(options){if(options.type==="short")this.curve=new curve_1.short(options);else if(options.type==="edwards")this.curve=new curve_1.edwards(options);else this.curve=new curve_1.mont(options);this.g=this.curve.g;this.n=this.curve.n;this.hash=options.hash;assert(this.g.validate(),"Invalid curve");assert(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}curves.PresetCurve=PresetCurve;function defineCurve(name,options){Object.defineProperty(curves,name,{configurable:true,enumerable:true,get:function(){var curve=new PresetCurve(options);Object.defineProperty(curves,name,{configurable:true,enumerable:true,value:curve});return curve}})}defineCurve("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:hash_1.sha256,gRed:false,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]});defineCurve("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:hash_1.sha256,gRed:false,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]});defineCurve("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:hash_1.sha256,gRed:false,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]});defineCurve("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f "+"5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 "+"f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:hash_1.sha384,gRed:false,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 "+"5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 "+"0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]});defineCurve("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b "+"99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd "+"3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 "+"f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:hash_1.sha512,gRed:false,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 "+"053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 "+"a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 "+"579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 "+"3fad0761 353c7086 a272c240 88be9476 9fd16650"]});defineCurve("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:hash_1.sha256,gRed:false,g:["9"]});defineCurve("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:hash_1.sha256,gRed:false,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});var pre;try{pre=null.crash()}catch(e){pre=undefined}defineCurve("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:hash_1.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:false,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",pre]})});"use strict";function HmacDRBG(options){if(!(this instanceof HmacDRBG))return new HmacDRBG(options);this.hash=options.hash;this.predResist=!!options.predResist;this.outLen=this.hash.outSize;this.minEntropy=options.minEntropy||this.hash.hmacStrength;this._reseed=null;this.reseedInterval=null;this.K=null;this.V=null;var entropy=utils_1.toArray(options.entropy,options.entropyEnc||"hex");var nonce=utils_1.toArray(options.nonce,options.nonceEnc||"hex");var pers=utils_1.toArray(options.pers,options.persEnc||"hex");minimalisticAssert$1(entropy.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits");this._init(entropy,nonce,pers)}var hmacDrbg=HmacDRBG;HmacDRBG.prototype._init=function init(entropy,nonce,pers){var seed=entropy.concat(nonce).concat(pers);this.K=new Array(this.outLen/8);this.V=new Array(this.outLen/8);for(var i=0;i<this.V.length;i++){this.K[i]=0;this.V[i]=1}this._update(seed);this._reseed=1;this.reseedInterval=281474976710656};HmacDRBG.prototype._hmac=function hmac(){return new hash_1.hmac(this.hash,this.K)};HmacDRBG.prototype._update=function update(seed){var kmac=this._hmac().update(this.V).update([0]);if(seed)kmac=kmac.update(seed);this.K=kmac.digest();this.V=this._hmac().update(this.V).digest();if(!seed)return;this.K=this._hmac().update(this.V).update([1]).update(seed).digest();this.V=this._hmac().update(this.V).digest()};HmacDRBG.prototype.reseed=function reseed(entropy,entropyEnc,add,addEnc){if(typeof entropyEnc!=="string"){addEnc=add;add=entropyEnc;entropyEnc=null}entropy=utils_1.toArray(entropy,entropyEnc);add=utils_1.toArray(add,addEnc);minimalisticAssert$1(entropy.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits");this._update(entropy.concat(add||[]));this._reseed=1};HmacDRBG.prototype.generate=function generate(len,enc,add,addEnc){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");if(typeof enc!=="string"){addEnc=add;add=enc;enc=null}if(add){add=utils_1.toArray(add,addEnc||"hex");this._update(add)}var temp=[];while(temp.length<len){this.V=this._hmac().update(this.V).digest();temp=temp.concat(this.V)}var res=temp.slice(0,len);this._update(add);this._reseed++;return utils_1.encode(res,enc)};"use strict";var assert$3=utils_1$1.assert;function KeyPair(ec,options){this.ec=ec;this.priv=null;this.pub=null;if(options.priv)this._importPrivate(options.priv,options.privEnc);if(options.pub)this._importPublic(options.pub,options.pubEnc)}var key=KeyPair;KeyPair.fromPublic=function fromPublic(ec,pub,enc){if(pub instanceof KeyPair)return pub;return new KeyPair(ec,{pub:pub,pubEnc:enc})};KeyPair.fromPrivate=function fromPrivate(ec,priv,enc){if(priv instanceof KeyPair)return priv;return new KeyPair(ec,{priv:priv,privEnc:enc})};KeyPair.prototype.validate=function validate(){var pub=this.getPublic();if(pub.isInfinity())return{result:false,reason:"Invalid public key"};if(!pub.validate())return{result:false,reason:"Public key is not a point"};if(!pub.mul(this.ec.curve.n).isInfinity())return{result:false,reason:"Public key * N != O"};return{result:true,reason:null}};KeyPair.prototype.getPublic=function getPublic(compact,enc){if(typeof compact==="string"){enc=compact;compact=null}if(!this.pub)this.pub=this.ec.g.mul(this.priv);if(!enc)return this.pub;return this.pub.encode(enc,compact)};KeyPair.prototype.getPrivate=function getPrivate(enc){if(enc==="hex")return this.priv.toString(16,2);else return this.priv};KeyPair.prototype._importPrivate=function _importPrivate(key,enc){this.priv=new bn(key,enc||16);this.priv=this.priv.umod(this.ec.curve.n)};KeyPair.prototype._importPublic=function _importPublic(key,enc){if(key.x||key.y){if(this.ec.curve.type==="mont"){assert$3(key.x,"Need x coordinate")}else if(this.ec.curve.type==="short"||this.ec.curve.type==="edwards"){assert$3(key.x&&key.y,"Need both x and y coordinate")}this.pub=this.ec.curve.point(key.x,key.y);return}this.pub=this.ec.curve.decodePoint(key,enc)};KeyPair.prototype.derive=function derive(pub){if(!pub.validate()){assert$3(pub.validate(),"public point not validated")}return pub.mul(this.priv).getX()};KeyPair.prototype.sign=function sign(msg,enc,options){return this.ec.sign(msg,this,enc,options)};KeyPair.prototype.verify=function verify(msg,signature){return this.ec.verify(msg,signature,this)};KeyPair.prototype.inspect=function inspect(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"};"use strict";var assert$4=utils_1$1.assert;function Signature(options,enc){if(options instanceof Signature)return options;if(this._importDER(options,enc))return;assert$4(options.r&&options.s,"Signature without r or s");this.r=new bn(options.r,16);this.s=new bn(options.s,16);if(options.recoveryParam===undefined)this.recoveryParam=null;else this.recoveryParam=options.recoveryParam}var signature=Signature;function Position(){this.place=0}function getLength(buf,p){var initial=buf[p.place++];if(!(initial&128)){return initial}var octetLen=initial&15;if(octetLen===0||octetLen>4){return false}var val=0;for(var i=0,off=p.place;i<octetLen;i++,off++){val<<=8;val|=buf[off];val>>>=0}if(val<=127){return false}p.place=off;return val}function rmPadding(buf){var i=0;var len=buf.length-1;while(!buf[i]&&!(buf[i+1]&128)&&i<len){i++}if(i===0){return buf}return buf.slice(i)}Signature.prototype._importDER=function _importDER(data,enc){data=utils_1$1.toArray(data,enc);var p=new Position;if(data[p.place++]!==48){return false}var len=getLength(data,p);if(len===false){return false}if(len+p.place!==data.length){return false}if(data[p.place++]!==2){return false}var rlen=getLength(data,p);if(rlen===false){return false}var r=data.slice(p.place,rlen+p.place);p.place+=rlen;if(data[p.place++]!==2){return false}var slen=getLength(data,p);if(slen===false){return false}if(data.length!==slen+p.place){return false}var s=data.slice(p.place,slen+p.place);if(r[0]===0){if(r[1]&128){r=r.slice(1)}else{return false}}if(s[0]===0){if(s[1]&128){s=s.slice(1)}else{return false}}this.r=new bn(r);this.s=new bn(s);this.recoveryParam=null;return true};function constructLength(arr,len){if(len<128){arr.push(len);return}var octets=1+(Math.log(len)/Math.LN2>>>3);arr.push(octets|128);while(--octets){arr.push(len>>>(octets<<3)&255)}arr.push(len)}Signature.prototype.toDER=function toDER(enc){var r=this.r.toArray();var s=this.s.toArray();if(r[0]&128)r=[0].concat(r);if(s[0]&128)s=[0].concat(s);r=rmPadding(r);s=rmPadding(s);while(!s[0]&&!(s[1]&128)){s=s.slice(1)}var arr=[2];constructLength(arr,r.length);arr=arr.concat(r);arr.push(2);constructLength(arr,s.length);var backHalf=arr.concat(s);var res=[48];constructLength(res,backHalf.length);res=res.concat(backHalf);return utils_1$1.encode(res,enc)};"use strict";var rand=function(){throw new Error("unsupported")};var assert$5=utils_1$1.assert;function EC(options){if(!(this instanceof EC))return new EC(options);if(typeof options==="string"){assert$5(Object.prototype.hasOwnProperty.call(curves_1,options),"Unknown curve "+options);options=curves_1[options]}if(options instanceof curves_1.PresetCurve)options={curve:options};this.curve=options.curve.curve;this.n=this.curve.n;this.nh=this.n.ushrn(1);this.g=this.curve.g;this.g=options.curve.g;this.g.precompute(options.curve.n.bitLength()+1);this.hash=options.hash||options.curve.hash}var ec=EC;EC.prototype.keyPair=function keyPair(options){return new key(this,options)};EC.prototype.keyFromPrivate=function keyFromPrivate(priv,enc){return key.fromPrivate(this,priv,enc)};EC.prototype.keyFromPublic=function keyFromPublic(pub,enc){return key.fromPublic(this,pub,enc)};EC.prototype.genKeyPair=function genKeyPair(options){if(!options)options={};var drbg=new hmacDrbg({hash:this.hash,pers:options.pers,persEnc:options.persEnc||"utf8",entropy:options.entropy||rand(this.hash.hmacStrength),entropyEnc:options.entropy&&options.entropyEnc||"utf8",nonce:this.n.toArray()});var bytes=this.n.byteLength();var ns2=this.n.sub(new bn(2));for(;;){var priv=new bn(drbg.generate(bytes));if(priv.cmp(ns2)>0)continue;priv.iaddn(1);return this.keyFromPrivate(priv)}};EC.prototype._truncateToN=function _truncateToN(msg,truncOnly){var delta=msg.byteLength()*8-this.n.bitLength();if(delta>0)msg=msg.ushrn(delta);if(!truncOnly&&msg.cmp(this.n)>=0)return msg.sub(this.n);else return msg};EC.prototype.sign=function sign(msg,key,enc,options){if(typeof enc==="object"){options=enc;enc=null}if(!options)options={};key=this.keyFromPrivate(key,enc);msg=this._truncateToN(new bn(msg,16));var bytes=this.n.byteLength();var bkey=key.getPrivate().toArray("be",bytes);var nonce=msg.toArray("be",bytes);var drbg=new hmacDrbg({hash:this.hash,entropy:bkey,nonce:nonce,pers:options.pers,persEnc:options.persEnc||"utf8"});var ns1=this.n.sub(new bn(1));for(var iter=0;;iter++){var k=options.k?options.k(iter):new bn(drbg.generate(this.n.byteLength()));k=this._truncateToN(k,true);if(k.cmpn(1)<=0||k.cmp(ns1)>=0)continue;var kp=this.g.mul(k);if(kp.isInfinity())continue;var kpX=kp.getX();var r=kpX.umod(this.n);if(r.cmpn(0)===0)continue;var s=k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));s=s.umod(this.n);if(s.cmpn(0)===0)continue;var recoveryParam=(kp.getY().isOdd()?1:0)|(kpX.cmp(r)!==0?2:0);if(options.canonical&&s.cmp(this.nh)>0){s=this.n.sub(s);recoveryParam^=1}return new signature({r:r,s:s,recoveryParam:recoveryParam})}};EC.prototype.verify=function verify(msg,signature$1,key,enc){msg=this._truncateToN(new bn(msg,16));key=this.keyFromPublic(key,enc);signature$1=new signature(signature$1,"hex");var r=signature$1.r;var s=signature$1.s;if(r.cmpn(1)<0||r.cmp(this.n)>=0)return false;if(s.cmpn(1)<0||s.cmp(this.n)>=0)return false;var sinv=s.invm(this.n);var u1=sinv.mul(msg).umod(this.n);var u2=sinv.mul(r).umod(this.n);var p;if(!this.curve._maxwellTrick){p=this.g.mulAdd(u1,key.getPublic(),u2);if(p.isInfinity())return false;return p.getX().umod(this.n).cmp(r)===0}p=this.g.jmulAdd(u1,key.getPublic(),u2);if(p.isInfinity())return false;return p.eqXToP(r)};EC.prototype.recoverPubKey=function(msg,signature$1,j,enc){assert$5((3&j)===j,"The recovery param is more than two bits");signature$1=new signature(signature$1,enc);var n=this.n;var e=new bn(msg);var r=signature$1.r;var s=signature$1.s;var isYOdd=j&1;var isSecondKey=j>>1;if(r.cmp(this.curve.p.umod(this.curve.n))>=0&&isSecondKey)throw new Error("Unable to find sencond key candinate");if(isSecondKey)r=this.curve.pointFromX(r.add(this.curve.n),isYOdd);else r=this.curve.pointFromX(r,isYOdd);var rInv=signature$1.r.invm(n);var s1=n.sub(e).mul(rInv).umod(n);var s2=s.mul(rInv).umod(n);return this.g.mulAdd(s1,r,s2)};EC.prototype.getKeyRecoveryParam=function(e,signature$1,Q,enc){signature$1=new signature(signature$1,enc);if(signature$1.recoveryParam!==null)return signature$1.recoveryParam;for(var i=0;i<4;i++){var Qprime;try{Qprime=this.recoverPubKey(e,signature$1,i)}catch(e){continue}if(Qprime.eq(Q))return i}throw new Error("Unable to find valid recovery factor")};var elliptic_1=createCommonjsModule$1(function(module,exports){"use strict";var elliptic=exports;elliptic.version={version:"6.5.4"}.version;elliptic.utils=utils_1$1;elliptic.rand=function(){throw new Error("unsupported")};elliptic.curve=curve_1;elliptic.curves=curves_1;elliptic.ec=ec;elliptic.eddsa=null});var EC$1=elliptic_1.ec;const version$b="signing-key/5.1.0";"use strict";const logger$g=new Logger(version$b);let _curve=null;function getCurve(){if(!_curve){_curve=new EC$1("secp256k1")}return _curve}class SigningKey{constructor(privateKey){defineReadOnly(this,"curve","secp256k1");defineReadOnly(this,"privateKey",hexlify(privateKey));const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey));defineReadOnly(this,"publicKey","0x"+keyPair.getPublic(false,"hex"));defineReadOnly(this,"compressedPublicKey","0x"+keyPair.getPublic(true,"hex"));defineReadOnly(this,"_isSigningKey",true)}_addPoint(other){const p0=getCurve().keyFromPublic(arrayify(this.publicKey));const p1=getCurve().keyFromPublic(arrayify(other));return"0x"+p0.pub.add(p1.pub).encodeCompressed("hex")}signDigest(digest){const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey));const digestBytes=arrayify(digest);if(digestBytes.length!==32){logger$g.throwArgumentError("bad digest length","digest",digest)}const signature=keyPair.sign(digestBytes,{canonical:true});return splitSignature({recoveryParam:signature.recoveryParam,r:hexZeroPad("0x"+signature.r.toString(16),32),s:hexZeroPad("0x"+signature.s.toString(16),32)})}computeSharedSecret(otherKey){const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey));const otherKeyPair=getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));return hexZeroPad("0x"+keyPair.derive(otherKeyPair.getPublic()).toString(16),32)}static isSigningKey(value){return!!(value&&value._isSigningKey)}}function recoverPublicKey(digest,signature){const sig=splitSignature(signature);const rs={r:arrayify(sig.r),s:arrayify(sig.s)};return"0x"+getCurve().recoverPubKey(arrayify(digest),rs,sig.recoveryParam).encode("hex",false)}function computePublicKey(key,compressed){const bytes=arrayify(key);if(bytes.length===32){const signingKey=new SigningKey(bytes);if(compressed){return"0x"+getCurve().keyFromPrivate(bytes).getPublic(true,"hex")}return signingKey.publicKey}else if(bytes.length===33){if(compressed){return hexlify(bytes)}return"0x"+getCurve().keyFromPublic(bytes).getPublic(false,"hex")}else if(bytes.length===65){if(!compressed){return hexlify(bytes)}return"0x"+getCurve().keyFromPublic(bytes).getPublic(true,"hex")}return logger$g.throwArgumentError("invalid public or private key","key","[REDACTED]")}const version$c="transactions/5.1.1";"use strict";const logger$h=new Logger(version$c);function handleAddress(value){if(value==="0x"){return null}return getAddress(value)}function handleNumber(value){if(value==="0x"){return Zero$1}return BigNumber.from(value)}const transactionFields=[{name:"nonce",maxLength:32,numeric:true},{name:"gasPrice",maxLength:32,numeric:true},{name:"gasLimit",maxLength:32,numeric:true},{name:"to",length:20},{name:"value",maxLength:32,numeric:true},{name:"data"}];const allowedTransactionKeys$1={chainId:true,data:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true};function computeAddress(key){const publicKey=computePublicKey(key);return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey,1)),12))}function recoverAddress(digest,signature){return computeAddress(recoverPublicKey(arrayify(digest),signature))}function formatNumber(value,name){const result=stripZeros(BigNumber.from(value).toHexString());if(result.length>32){logger$h.throwArgumentError("invalid length for "+name,"transaction:"+name,value)}return result}function accessSetify(addr,storageKeys){return{address:getAddress(addr),storageKeys:(storageKeys||[]).map((storageKey,index)=>{if(hexDataLength(storageKey)!==32){logger$h.throwArgumentError("invalid access list storageKey",`accessList[${addr}:${index}]`,storageKey)}return storageKey.toLowerCase()})}}function accessListify(value){if(Array.isArray(value)){return value.map((set,index)=>{if(Array.isArray(set)){if(set.length>2){logger$h.throwArgumentError("access list expected to be [ address, storageKeys[] ]",`value[${index}]`,set)}return accessSetify(set[0],set[1])}return accessSetify(set.address,set.storageKeys)})}const result=Object.keys(value).map(addr=>{const storageKeys=value[addr].reduce((accum,storageKey)=>{accum[storageKey]=true;return accum},{});return accessSetify(addr,Object.keys(storageKeys).sort())});result.sort((a,b)=>a.address.localeCompare(b.address));return result}function formatAccessList(value){return accessListify(value).map(set=>[set.address,set.storageKeys])}function _serializeEip2930(transaction,signature){const fields=[formatNumber(transaction.chainId||0,"chainId"),formatNumber(transaction.nonce||0,"nonce"),formatNumber(transaction.gasPrice||0,"gasPrice"),formatNumber(transaction.gasLimit||0,"gasLimit"),transaction.to!=null?getAddress(transaction.to):"0x",formatNumber(transaction.value||0,"value"),transaction.data||"0x",formatAccessList(transaction.accessList||[])];if(signature){const sig=splitSignature(signature);fields.push(formatNumber(sig.recoveryParam,"recoveryParam"));fields.push(stripZeros(sig.r));fields.push(stripZeros(sig.s))}return hexConcat(["0x01",encode(fields)])}function _serialize(transaction,signature){checkProperties(transaction,allowedTransactionKeys$1);const raw=[];transactionFields.forEach(function(fieldInfo){let value=transaction[fieldInfo.name]||[];const options={};if(fieldInfo.numeric){options.hexPad="left"}value=arrayify(hexlify(value,options));if(fieldInfo.length&&value.length!==fieldInfo.length&&value.length>0){logger$h.throwArgumentError("invalid length for "+fieldInfo.name,"transaction:"+fieldInfo.name,value)}if(fieldInfo.maxLength){value=stripZeros(value);if(value.length>fieldInfo.maxLength){logger$h.throwArgumentError("invalid length for "+fieldInfo.name,"transaction:"+fieldInfo.name,value)}}raw.push(hexlify(value))});let chainId=0;if(transaction.chainId!=null){chainId=transaction.chainId;if(typeof chainId!=="number"){logger$h.throwArgumentError("invalid transaction.chainId","transaction",transaction)}}else if(signature&&!isBytesLike(signature)&&signature.v>28){chainId=Math.floor((signature.v-35)/2)}if(chainId!==0){raw.push(hexlify(chainId));raw.push("0x");raw.push("0x")}if(!signature){return encode(raw)}const sig=splitSignature(signature);let v=27+sig.recoveryParam;if(chainId!==0){raw.pop();raw.pop();raw.pop();v+=chainId*2+8;if(sig.v>28&&sig.v!==v){logger$h.throwArgumentError("transaction.chainId/signature.v mismatch","signature",signature)}}else if(sig.v!==v){logger$h.throwArgumentError("transaction.chainId/signature.v mismatch","signature",signature)}raw.push(hexlify(v));raw.push(stripZeros(arrayify(sig.r)));raw.push(stripZeros(arrayify(sig.s)));return encode(raw)}function serialize(transaction,signature){if(transaction.type==null){if(transaction.accessList!=null){logger$h.throwArgumentError("untyped transactions do not support accessList; include type: 1","transaction",transaction)}return _serialize(transaction,signature)}switch(transaction.type){case 1:return _serializeEip2930(transaction,signature);default:break}return logger$h.throwError(`unsupported transaction type: ${transaction.type}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"serializeTransaction",transactionType:transaction.type})}function _parseEip2930(payload){const transaction=decode(payload.slice(1));if(transaction.length!==8&&transaction.length!==11){logger$h.throwArgumentError("invalid component count for transaction type: 1","payload",hexlify(payload))}const tx={type:1,chainId:handleNumber(transaction[0]).toNumber(),nonce:handleNumber(transaction[1]).toNumber(),gasPrice:handleNumber(transaction[2]),gasLimit:handleNumber(transaction[3]),to:handleAddress(transaction[4]),value:handleNumber(transaction[5]),data:transaction[6],accessList:accessListify(transaction[7])};if(transaction.length===8){return tx}try{const recid=handleNumber(transaction[8]).toNumber();if(recid!==0&&recid!==1){throw new Error("bad recid")}tx.v=recid}catch(error){logger$h.throwArgumentError("invalid v for transaction type: 1","v",transaction[8])}tx.r=hexZeroPad(transaction[9],32);tx.s=hexZeroPad(transaction[10],32);try{const digest=keccak256(_serializeEip2930(tx));tx.from=recoverAddress(digest,{r:tx.r,s:tx.s,recoveryParam:tx.v})}catch(error){console.log(error)}tx.hash=keccak256(payload);return tx}function _parse(rawTransaction){const transaction=decode(rawTransaction);if(transaction.length!==9&&transaction.length!==6){logger$h.throwArgumentError("invalid raw transaction","rawTransaction",rawTransaction)}const tx={nonce:handleNumber(transaction[0]).toNumber(),gasPrice:handleNumber(transaction[1]),gasLimit:handleNumber(transaction[2]),to:handleAddress(transaction[3]),value:handleNumber(transaction[4]),data:transaction[5],chainId:0};if(transaction.length===6){return tx}try{tx.v=BigNumber.from(transaction[6]).toNumber()}catch(error){console.log(error);return tx}tx.r=hexZeroPad(transaction[7],32);tx.s=hexZeroPad(transaction[8],32);if(BigNumber.from(tx.r).isZero()&&BigNumber.from(tx.s).isZero()){tx.chainId=tx.v;tx.v=0}else{tx.chainId=Math.floor((tx.v-35)/2);if(tx.chainId<0){tx.chainId=0}let recoveryParam=tx.v-27;const raw=transaction.slice(0,6);if(tx.chainId!==0){raw.push(hexlify(tx.chainId));raw.push("0x");raw.push("0x");recoveryParam-=tx.chainId*2+8}const digest=keccak256(encode(raw));try{tx.from=recoverAddress(digest,{r:hexlify(tx.r),s:hexlify(tx.s),recoveryParam:recoveryParam})}catch(error){console.log(error)}tx.hash=keccak256(rawTransaction)}tx.type=null;return tx}function parse(rawTransaction){const payload=arrayify(rawTransaction);if(payload[0]>127){return _parse(payload)}switch(payload[0]){case 1:return _parseEip2930(payload);default:break}return logger$h.throwError(`unsupported transaction type: ${payload[0]}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"parseTransaction",transactionType:payload[0]})}const version$d="contracts/5.1.1";"use strict";var __awaiter$3=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$i=new Logger(version$d);const allowedTransactionKeys$2={chainId:true,data:true,from:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true,type:true,accessList:true};function resolveName(resolver,nameOrPromise){return __awaiter$3(this,void 0,void 0,function*(){const name=yield nameOrPromise;try{return getAddress(name)}catch(error){}if(!resolver){logger$i.throwError("a provider or signer is needed to resolve ENS names",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resolveName"})}const address=yield resolver.resolveName(name);if(address==null){logger$i.throwArgumentError("resolver or addr is not configured for ENS name","name",name)}return address})}function resolveAddresses(resolver,value,paramType){return __awaiter$3(this,void 0,void 0,function*(){if(Array.isArray(paramType)){return yield Promise.all(paramType.map((paramType,index)=>{return resolveAddresses(resolver,Array.isArray(value)?value[index]:value[paramType.name],paramType)}))}if(paramType.type==="address"){return yield resolveName(resolver,value)}if(paramType.type==="tuple"){return yield resolveAddresses(resolver,value,paramType.components)}if(paramType.baseType==="array"){if(!Array.isArray(value)){return Promise.reject(new Error("invalid value for array"))}return yield Promise.all(value.map(v=>resolveAddresses(resolver,v,paramType.arrayChildren)))}return value})}function populateTransaction(contract,fragment,args){return __awaiter$3(this,void 0,void 0,function*(){let overrides={};if(args.length===fragment.inputs.length+1&&typeof args[args.length-1]==="object"){overrides=shallowCopy(args.pop())}logger$i.checkArgumentCount(args.length,fragment.inputs.length,"passed to contract");if(contract.signer){if(overrides.from){overrides.from=resolveProperties({override:resolveName(contract.signer,overrides.from),signer:contract.signer.getAddress()}).then(check=>__awaiter$3(this,void 0,void 0,function*(){if(getAddress(check.signer)!==check.override){logger$i.throwError("Contract with a Signer cannot override from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"overrides.from"})}return check.override}))}else{overrides.from=contract.signer.getAddress()}}else if(overrides.from){overrides.from=resolveName(contract.provider,overrides.from)}const resolved=yield resolveProperties({args:resolveAddresses(contract.signer||contract.provider,args,fragment.inputs),address:contract.resolvedAddress,overrides:resolveProperties(overrides)||{}});const data=contract.interface.encodeFunctionData(fragment,resolved.args);const tx={data:data,to:resolved.address};const ro=resolved.overrides;if(ro.nonce!=null){tx.nonce=BigNumber.from(ro.nonce).toNumber()}if(ro.gasLimit!=null){tx.gasLimit=BigNumber.from(ro.gasLimit)}if(ro.gasPrice!=null){tx.gasPrice=BigNumber.from(ro.gasPrice)}if(ro.from!=null){tx.from=ro.from}if(ro.type!=null){tx.type=ro.type}if(ro.accessList!=null){tx.accessList=accessListify(ro.accessList)}if(tx.gasLimit==null&&fragment.gas!=null){let intrinsic=21e3;const bytes=arrayify(data);for(let i=0;i<bytes.length;i++){intrinsic+=4;if(bytes[i]){intrinsic+=64}}tx.gasLimit=BigNumber.from(fragment.gas).add(intrinsic)}if(ro.value){const roValue=BigNumber.from(ro.value);if(!roValue.isZero()&&!fragment.payable){logger$i.throwError("non-payable method cannot override value",Logger.errors.UNSUPPORTED_OPERATION,{operation:"overrides.value",value:overrides.value})}tx.value=roValue}delete overrides.nonce;delete overrides.gasLimit;delete overrides.gasPrice;delete overrides.from;delete overrides.value;delete overrides.type;delete overrides.accessList;const leftovers=Object.keys(overrides).filter(key=>overrides[key]!=null);if(leftovers.length){logger$i.throwError(`cannot override ${leftovers.map(l=>JSON.stringify(l)).join(",")}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"overrides",overrides:leftovers})}return tx})}function buildPopulate(contract,fragment){return function(...args){return populateTransaction(contract,fragment,args)}}function buildEstimate(contract,fragment){const signerOrProvider=contract.signer||contract.provider;return function(...args){return __awaiter$3(this,void 0,void 0,function*(){if(!signerOrProvider){logger$i.throwError("estimate require a provider or signer",Logger.errors.UNSUPPORTED_OPERATION,{operation:"estimateGas"})}const tx=yield populateTransaction(contract,fragment,args);return yield signerOrProvider.estimateGas(tx)})}}function buildCall(contract,fragment,collapseSimple){const signerOrProvider=contract.signer||contract.provider;return function(...args){return __awaiter$3(this,void 0,void 0,function*(){let blockTag=undefined;if(args.length===fragment.inputs.length+1&&typeof args[args.length-1]==="object"){const overrides=shallowCopy(args.pop());if(overrides.blockTag!=null){blockTag=yield overrides.blockTag}delete overrides.blockTag;args.push(overrides)}if(contract.deployTransaction!=null){yield contract._deployed(blockTag)}const tx=yield populateTransaction(contract,fragment,args);const result=yield signerOrProvider.call(tx,blockTag);try{let value=contract.interface.decodeFunctionResult(fragment,result);if(collapseSimple&&fragment.outputs.length===1){value=value[0]}return value}catch(error){if(error.code===Logger.errors.CALL_EXCEPTION){error.address=contract.address;error.args=args;error.transaction=tx}throw error}})}}function buildSend(contract,fragment){return function(...args){return __awaiter$3(this,void 0,void 0,function*(){if(!contract.signer){logger$i.throwError("sending a transaction requires a signer",Logger.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction"})}if(contract.deployTransaction!=null){yield contract._deployed()}const txRequest=yield populateTransaction(contract,fragment,args);const tx=yield contract.signer.sendTransaction(txRequest);const wait=tx.wait.bind(tx);tx.wait=(confirmations=>{return wait(confirmations).then(receipt=>{receipt.events=receipt.logs.map(log=>{let event=deepCopy(log);let parsed=null;try{parsed=contract.interface.parseLog(log)}catch(e){}if(parsed){event.args=parsed.args;event.decode=((data,topics)=>{return contract.interface.decodeEventLog(parsed.eventFragment,data,topics)});event.event=parsed.name;event.eventSignature=parsed.signature}event.removeListener=(()=>{return contract.provider});event.getBlock=(()=>{return contract.provider.getBlock(receipt.blockHash)});event.getTransaction=(()=>{return contract.provider.getTransaction(receipt.transactionHash)});event.getTransactionReceipt=(()=>{return Promise.resolve(receipt)});return event});return receipt})});return tx})}}function buildDefault(contract,fragment,collapseSimple){if(fragment.constant){return buildCall(contract,fragment,collapseSimple)}return buildSend(contract,fragment)}function getEventTag(filter){if(filter.address&&(filter.topics==null||filter.topics.length===0)){return"*"}return(filter.address||"*")+"@"+(filter.topics?filter.topics.map(topic=>{if(Array.isArray(topic)){return topic.join("|")}return topic}).join(":"):"")}class RunningEvent{constructor(tag,filter){defineReadOnly(this,"tag",tag);defineReadOnly(this,"filter",filter);this._listeners=[]}addListener(listener,once){this._listeners.push({listener:listener,once:once})}removeListener(listener){let done=false;this._listeners=this._listeners.filter(item=>{if(done||item.listener!==listener){return true}done=true;return false})}removeAllListeners(){this._listeners=[]}listeners(){return this._listeners.map(i=>i.listener)}listenerCount(){return this._listeners.length}run(args){const listenerCount=this.listenerCount();this._listeners=this._listeners.filter(item=>{const argsCopy=args.slice();setTimeout(()=>{item.listener.apply(this,argsCopy)},0);return!item.once});return listenerCount}prepareEvent(event){}getEmit(event){return[event]}}class ErrorRunningEvent extends RunningEvent{constructor(){super("error",null)}}class FragmentRunningEvent extends RunningEvent{constructor(address,contractInterface,fragment,topics){const filter={address:address};let topic=contractInterface.getEventTopic(fragment);if(topics){if(topic!==topics[0]){logger$i.throwArgumentError("topic mismatch","topics",topics)}filter.topics=topics.slice()}else{filter.topics=[topic]}super(getEventTag(filter),filter);defineReadOnly(this,"address",address);defineReadOnly(this,"interface",contractInterface);defineReadOnly(this,"fragment",fragment)}prepareEvent(event){super.prepareEvent(event);event.event=this.fragment.name;event.eventSignature=this.fragment.format();event.decode=((data,topics)=>{return this.interface.decodeEventLog(this.fragment,data,topics)});try{event.args=this.interface.decodeEventLog(this.fragment,event.data,event.topics)}catch(error){event.args=null;event.decodeError=error}}getEmit(event){const errors=checkResultErrors(event.args);if(errors.length){throw errors[0].error}const args=(event.args||[]).slice();args.push(event);return args}}class WildcardRunningEvent extends RunningEvent{constructor(address,contractInterface){super("*",{address:address});defineReadOnly(this,"address",address);defineReadOnly(this,"interface",contractInterface)}prepareEvent(event){super.prepareEvent(event);try{const parsed=this.interface.parseLog(event);event.event=parsed.name;event.eventSignature=parsed.signature;event.decode=((data,topics)=>{return this.interface.decodeEventLog(parsed.eventFragment,data,topics)});event.args=parsed.args}catch(error){}}}class BaseContract{constructor(addressOrName,contractInterface,signerOrProvider){logger$i.checkNew(new.target,Contract);defineReadOnly(this,"interface",getStatic(new.target,"getInterface")(contractInterface));if(signerOrProvider==null){defineReadOnly(this,"provider",null);defineReadOnly(this,"signer",null)}else if(Signer.isSigner(signerOrProvider)){defineReadOnly(this,"provider",signerOrProvider.provider||null);defineReadOnly(this,"signer",signerOrProvider)}else if(Provider.isProvider(signerOrProvider)){defineReadOnly(this,"provider",signerOrProvider);defineReadOnly(this,"signer",null)}else{logger$i.throwArgumentError("invalid signer or provider","signerOrProvider",signerOrProvider)}defineReadOnly(this,"callStatic",{});defineReadOnly(this,"estimateGas",{});defineReadOnly(this,"functions",{});defineReadOnly(this,"populateTransaction",{});defineReadOnly(this,"filters",{});{const uniqueFilters={};Object.keys(this.interface.events).forEach(eventSignature=>{const event=this.interface.events[eventSignature];defineReadOnly(this.filters,eventSignature,(...args)=>{return{address:this.address,topics:this.interface.encodeFilterTopics(event,args)}});if(!uniqueFilters[event.name]){uniqueFilters[event.name]=[]}uniqueFilters[event.name].push(eventSignature)});Object.keys(uniqueFilters).forEach(name=>{const filters=uniqueFilters[name];if(filters.length===1){defineReadOnly(this.filters,name,this.filters[filters[0]])}else{logger$i.warn(`Duplicate definition of ${name} (${filters.join(", ")})`)}})}defineReadOnly(this,"_runningEvents",{});defineReadOnly(this,"_wrappedEmits",{});if(addressOrName==null){logger$i.throwArgumentError("invalid contract address or ENS name","addressOrName",addressOrName)}defineReadOnly(this,"address",addressOrName);if(this.provider){defineReadOnly(this,"resolvedAddress",resolveName(this.provider,addressOrName))}else{try{defineReadOnly(this,"resolvedAddress",Promise.resolve(getAddress(addressOrName)))}catch(error){logger$i.throwError("provider is required to use ENS name as contract address",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new Contract"})}}const uniqueNames={};const uniqueSignatures={};Object.keys(this.interface.functions).forEach(signature=>{const fragment=this.interface.functions[signature];if(uniqueSignatures[signature]){logger$i.warn(`Duplicate ABI entry for ${JSON.stringify(name)}`);return}uniqueSignatures[signature]=true;{const name=fragment.name;if(!uniqueNames[name]){uniqueNames[name]=[]}uniqueNames[name].push(signature)}if(this[signature]==null){defineReadOnly(this,signature,buildDefault(this,fragment,true))}if(this.functions[signature]==null){defineReadOnly(this.functions,signature,buildDefault(this,fragment,false))}if(this.callStatic[signature]==null){defineReadOnly(this.callStatic,signature,buildCall(this,fragment,true))}if(this.populateTransaction[signature]==null){defineReadOnly(this.populateTransaction,signature,buildPopulate(this,fragment))}if(this.estimateGas[signature]==null){defineReadOnly(this.estimateGas,signature,buildEstimate(this,fragment))}});Object.keys(uniqueNames).forEach(name=>{const signatures=uniqueNames[name];if(signatures.length>1){return}const signature=signatures[0];try{if(this[name]==null){defineReadOnly(this,name,this[signature])}}catch(e){}if(this.functions[name]==null){defineReadOnly(this.functions,name,this.functions[signature])}if(this.callStatic[name]==null){defineReadOnly(this.callStatic,name,this.callStatic[signature])}if(this.populateTransaction[name]==null){defineReadOnly(this.populateTransaction,name,this.populateTransaction[signature])}if(this.estimateGas[name]==null){defineReadOnly(this.estimateGas,name,this.estimateGas[signature])}})}static getContractAddress(transaction){return getContractAddress(transaction)}static getInterface(contractInterface){if(Interface.isInterface(contractInterface)){return contractInterface}return new Interface(contractInterface)}deployed(){return this._deployed()}_deployed(blockTag){if(!this._deployedPromise){if(this.deployTransaction){this._deployedPromise=this.deployTransaction.wait().then(()=>{return this})}else{this._deployedPromise=this.provider.getCode(this.address,blockTag).then(code=>{if(code==="0x"){logger$i.throwError("contract not deployed",Logger.errors.UNSUPPORTED_OPERATION,{contractAddress:this.address,operation:"getDeployed"})}return this})}}return this._deployedPromise}fallback(overrides){if(!this.signer){logger$i.throwError("sending a transactions require a signer",Logger.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction(fallback)"})}const tx=shallowCopy(overrides||{});["from","to"].forEach(function(key){if(tx[key]==null){return}logger$i.throwError("cannot override "+key,Logger.errors.UNSUPPORTED_OPERATION,{operation:key})});tx.to=this.resolvedAddress;return this.deployed().then(()=>{return this.signer.sendTransaction(tx)})}connect(signerOrProvider){if(typeof signerOrProvider==="string"){signerOrProvider=new VoidSigner(signerOrProvider,this.provider)}const contract=new this.constructor(this.address,this.interface,signerOrProvider);if(this.deployTransaction){defineReadOnly(contract,"deployTransaction",this.deployTransaction)}return contract}attach(addressOrName){return new this.constructor(addressOrName,this.interface,this.signer||this.provider)}static isIndexed(value){return Indexed.isIndexed(value)}_normalizeRunningEvent(runningEvent){if(this._runningEvents[runningEvent.tag]){return this._runningEvents[runningEvent.tag]}return runningEvent}_getRunningEvent(eventName){if(typeof eventName==="string"){if(eventName==="error"){return this._normalizeRunningEvent(new ErrorRunningEvent)}if(eventName==="event"){return this._normalizeRunningEvent(new RunningEvent("event",null))}if(eventName==="*"){return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface))}const fragment=this.interface.getEvent(eventName);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,fragment))}if(eventName.topics&&eventName.topics.length>0){try{const topic=eventName.topics[0];if(typeof topic!=="string"){throw new Error("invalid topic")}const fragment=this.interface.getEvent(topic);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,fragment,eventName.topics))}catch(error){}const filter={address:this.address,topics:eventName.topics};return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter),filter))}return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface))}_checkRunningEvents(runningEvent){if(runningEvent.listenerCount()===0){delete this._runningEvents[runningEvent.tag];const emit=this._wrappedEmits[runningEvent.tag];if(emit&&runningEvent.filter){this.provider.off(runningEvent.filter,emit);delete this._wrappedEmits[runningEvent.tag]}}}_wrapEvent(runningEvent,log,listener){const event=deepCopy(log);event.removeListener=(()=>{if(!listener){return}runningEvent.removeListener(listener);this._checkRunningEvents(runningEvent)});event.getBlock=(()=>{return this.provider.getBlock(log.blockHash)});event.getTransaction=(()=>{return this.provider.getTransaction(log.transactionHash)});event.getTransactionReceipt=(()=>{return this.provider.getTransactionReceipt(log.transactionHash)});runningEvent.prepareEvent(event);return event}_addEventListener(runningEvent,listener,once){if(!this.provider){logger$i.throwError("events require a provider or a signer with a provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"once"})}runningEvent.addListener(listener,once);this._runningEvents[runningEvent.tag]=runningEvent;if(!this._wrappedEmits[runningEvent.tag]){const wrappedEmit=log=>{let event=this._wrapEvent(runningEvent,log,listener);if(event.decodeError==null){try{const args=runningEvent.getEmit(event);this.emit(runningEvent.filter,...args)}catch(error){event.decodeError=error.error}}if(runningEvent.filter!=null){this.emit("event",event)}if(event.decodeError!=null){this.emit("error",event.decodeError,event)}};this._wrappedEmits[runningEvent.tag]=wrappedEmit;if(runningEvent.filter!=null){this.provider.on(runningEvent.filter,wrappedEmit)}}}queryFilter(event,fromBlockOrBlockhash,toBlock){const runningEvent=this._getRunningEvent(event);const filter=shallowCopy(runningEvent.filter);if(typeof fromBlockOrBlockhash==="string"&&isHexString(fromBlockOrBlockhash,32)){if(toBlock!=null){logger$i.throwArgumentError("cannot specify toBlock with blockhash","toBlock",toBlock)}filter.blockHash=fromBlockOrBlockhash}else{filter.fromBlock=fromBlockOrBlockhash!=null?fromBlockOrBlockhash:0;filter.toBlock=toBlock!=null?toBlock:"latest"}return this.provider.getLogs(filter).then(logs=>{return logs.map(log=>this._wrapEvent(runningEvent,log,null))})}on(event,listener){this._addEventListener(this._getRunningEvent(event),listener,false);return this}once(event,listener){this._addEventListener(this._getRunningEvent(event),listener,true);return this}emit(eventName,...args){if(!this.provider){return false}const runningEvent=this._getRunningEvent(eventName);const result=runningEvent.run(args)>0;this._checkRunningEvents(runningEvent);return result}listenerCount(eventName){if(!this.provider){return 0}if(eventName==null){return Object.keys(this._runningEvents).reduce((accum,key)=>{return accum+this._runningEvents[key].listenerCount()},0)}return this._getRunningEvent(eventName).listenerCount()}listeners(eventName){if(!this.provider){return[]}if(eventName==null){const result=[];for(let tag in this._runningEvents){this._runningEvents[tag].listeners().forEach(listener=>{result.push(listener)})}return result}return this._getRunningEvent(eventName).listeners()}removeAllListeners(eventName){if(!this.provider){return this}if(eventName==null){for(const tag in this._runningEvents){const runningEvent=this._runningEvents[tag];runningEvent.removeAllListeners();this._checkRunningEvents(runningEvent)}return this}const runningEvent=this._getRunningEvent(eventName);runningEvent.removeAllListeners();this._checkRunningEvents(runningEvent);return this}off(eventName,listener){if(!this.provider){return this}const runningEvent=this._getRunningEvent(eventName);runningEvent.removeListener(listener);this._checkRunningEvents(runningEvent);return this}removeListener(eventName,listener){return this.off(eventName,listener)}}class Contract extends BaseContract{}class ContractFactory{constructor(contractInterface,bytecode,signer){let bytecodeHex=null;if(typeof bytecode==="string"){bytecodeHex=bytecode}else if(isBytes(bytecode)){bytecodeHex=hexlify(bytecode)}else if(bytecode&&typeof bytecode.object==="string"){bytecodeHex=bytecode.object}else{bytecodeHex="!"}if(bytecodeHex.substring(0,2)!=="0x"){bytecodeHex="0x"+bytecodeHex}if(!isHexString(bytecodeHex)||bytecodeHex.length%2){logger$i.throwArgumentError("invalid bytecode","bytecode",bytecode)}if(signer&&!Signer.isSigner(signer)){logger$i.throwArgumentError("invalid signer","signer",signer)}defineReadOnly(this,"bytecode",bytecodeHex);defineReadOnly(this,"interface",getStatic(new.target,"getInterface")(contractInterface));defineReadOnly(this,"signer",signer||null)}getDeployTransaction(...args){let tx={};if(args.length===this.interface.deploy.inputs.length+1&&typeof args[args.length-1]==="object"){tx=shallowCopy(args.pop());for(const key in tx){if(!allowedTransactionKeys$2[key]){throw new Error("unknown transaction override "+key)}}}["data","from","to"].forEach(key=>{if(tx[key]==null){return}logger$i.throwError("cannot override "+key,Logger.errors.UNSUPPORTED_OPERATION,{operation:key})});logger$i.checkArgumentCount(args.length,this.interface.deploy.inputs.length," in Contract constructor");tx.data=hexlify(concat([this.bytecode,this.interface.encodeDeploy(args)]));return tx}deploy(...args){return __awaiter$3(this,void 0,void 0,function*(){let overrides={};if(args.length===this.interface.deploy.inputs.length+1){overrides=args.pop()}logger$i.checkArgumentCount(args.length,this.interface.deploy.inputs.length," in Contract constructor");const params=yield resolveAddresses(this.signer,args,this.interface.deploy.inputs);params.push(overrides);const unsignedTx=this.getDeployTransaction(...params);const tx=yield this.signer.sendTransaction(unsignedTx);const address=getStatic(this.constructor,"getContractAddress")(tx);const contract=getStatic(this.constructor,"getContract")(address,this.interface,this.signer);defineReadOnly(contract,"deployTransaction",tx);return contract})}attach(address){return this.constructor.getContract(address,this.interface,this.signer)}connect(signer){return new this.constructor(this.interface,this.bytecode,signer)}static fromSolidity(compilerOutput,signer){if(compilerOutput==null){logger$i.throwError("missing compiler output",Logger.errors.MISSING_ARGUMENT,{argument:"compilerOutput"})}if(typeof compilerOutput==="string"){compilerOutput=JSON.parse(compilerOutput)}const abi=compilerOutput.abi;let bytecode=null;if(compilerOutput.bytecode){bytecode=compilerOutput.bytecode}else if(compilerOutput.evm&&compilerOutput.evm.bytecode){bytecode=compilerOutput.evm.bytecode}return new this(abi,bytecode,signer)}static getInterface(contractInterface){return Contract.getInterface(contractInterface)}static getContractAddress(tx){return getContractAddress(tx)}static getContract(address,contractInterface,signer){return new Contract(address,contractInterface,signer)}}class BaseX{constructor(alphabet){defineReadOnly(this,"alphabet",alphabet);defineReadOnly(this,"base",alphabet.length);defineReadOnly(this,"_alphabetMap",{});defineReadOnly(this,"_leader",alphabet.charAt(0));for(let i=0;i<alphabet.length;i++){this._alphabetMap[alphabet.charAt(i)]=i}}encode(value){let source=arrayify(value);if(source.length===0){return""}let digits=[0];for(let i=0;i<source.length;++i){let carry=source[i];for(let j=0;j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%this.base;carry=carry/this.base|0}while(carry>0){digits.push(carry%this.base);carry=carry/this.base|0}}let string="";for(let k=0;source[k]===0&&k<source.length-1;++k){string+=this._leader}for(let q=digits.length-1;q>=0;--q){string+=this.alphabet[digits[q]]}return string}decode(value){if(typeof value!=="string"){throw new TypeError("Expected String")}let bytes=[];if(value.length===0){return new Uint8Array(bytes)}bytes.push(0);for(let i=0;i<value.length;i++){let byte=this._alphabetMap[value[i]];if(byte===undefined){throw new Error("Non-base"+this.base+" character")}let carry=byte;for(let j=0;j<bytes.length;++j){carry+=bytes[j]*this.base;bytes[j]=carry&255;carry>>=8}while(carry>0){bytes.push(carry&255);carry>>=8}}for(let k=0;value[k]===this._leader&&k<value.length-1;++k){bytes.push(0)}return arrayify(new Uint8Array(bytes.reverse()))}}const Base32=new BaseX("abcdefghijklmnopqrstuvwxyz234567");const Base58=new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");var SupportedAlgorithm;(function(SupportedAlgorithm){SupportedAlgorithm["sha256"]="sha256";SupportedAlgorithm["sha512"]="sha512"})(SupportedAlgorithm||(SupportedAlgorithm={}));const version$e="sha2/5.1.0";"use strict";const logger$j=new Logger(version$e);function ripemd160$1(data){return"0x"+hash_1.ripemd160().update(arrayify(data)).digest("hex")}function sha256$1(data){return"0x"+hash_1.sha256().update(arrayify(data)).digest("hex")}function sha512$1(data){return"0x"+hash_1.sha512().update(arrayify(data)).digest("hex")}function computeHmac(algorithm,key,data){if(!SupportedAlgorithm[algorithm]){logger$j.throwError("unsupported algorithm "+algorithm,Logger.errors.UNSUPPORTED_OPERATION,{operation:"hmac",algorithm:algorithm})}return"0x"+hash_1.hmac(hash_1[algorithm],arrayify(key)).update(arrayify(data)).digest("hex")}"use strict";function pbkdf2(password,salt,iterations,keylen,hashAlgorithm){password=arrayify(password);salt=arrayify(salt);let hLen;let l=1;const DK=new Uint8Array(keylen);const block1=new Uint8Array(salt.length+4);block1.set(salt);let r;let T;for(let i=1;i<=l;i++){block1[salt.length]=i>>24&255;block1[salt.length+1]=i>>16&255;block1[salt.length+2]=i>>8&255;block1[salt.length+3]=i&255;let U=arrayify(computeHmac(hashAlgorithm,password,block1));if(!hLen){hLen=U.length;T=new Uint8Array(hLen);l=Math.ceil(keylen/hLen);r=keylen-(l-1)*hLen}T.set(U);for(let j=1;j<iterations;j++){U=arrayify(computeHmac(hashAlgorithm,password,U));for(let k=0;k<hLen;k++)T[k]^=U[k]}const destPos=(i-1)*hLen;const len=i===l?r:hLen;DK.set(arrayify(T).slice(0,len),destPos)}return hexlify(DK)}const version$f="wordlists/5.1.0";"use strict";const exportWordlist=false;const logger$k=new Logger(version$f);class Wordlist{constructor(locale){logger$k.checkAbstract(new.target,Wordlist);defineReadOnly(this,"locale",locale)}split(mnemonic){return mnemonic.toLowerCase().split(/ +/g)}join(words){return words.join(" ")}static check(wordlist){const words=[];for(let i=0;i<2048;i++){const word=wordlist.getWord(i);if(i!==wordlist.getWordIndex(word)){return"0x"}words.push(word)}return id(words.join("\n")+"\n")}static register(lang,name){if(!name){name=lang.locale}if(exportWordlist){try{const anyGlobal=window;if(anyGlobal._ethers&&anyGlobal._ethers.wordlists){if(!anyGlobal._ethers.wordlists[name]){defineReadOnly(anyGlobal._ethers.wordlists,name,lang)}}}catch(error){}}}}"use strict";const words="AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk";let wordlist=null;function loadWords(lang){if(wordlist!=null){return}wordlist=words.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ");if(Wordlist.check(lang)!=="0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a"){wordlist=null;throw new Error("BIP39 Wordlist for en (English) FAILED")}}class LangCz extends Wordlist{constructor(){super("cz")}getWord(index){loadWords(this);return wordlist[index]}getWordIndex(word){loadWords(this);return wordlist.indexOf(word)}}const langCz=new LangCz;Wordlist.register(langCz);"use strict";const words$1="AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";let wordlist$1=null;function loadWords$1(lang){if(wordlist$1!=null){return}wordlist$1=words$1.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ");if(Wordlist.check(lang)!=="0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"){wordlist$1=null;throw new Error("BIP39 Wordlist for en (English) FAILED")}}class LangEn extends Wordlist{constructor(){super("en")}getWord(index){loadWords$1(this);return wordlist$1[index]}getWordIndex(word){loadWords$1(this);return wordlist$1.indexOf(word)}}const langEn=new LangEn;Wordlist.register(langEn);"use strict";const words$2="A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo";const lookup={};let wordlist$2=null;function dropDiacritic(word){logger$k.checkNormalize();return toUtf8String(Array.prototype.filter.call(toUtf8Bytes(word.normalize("NFD").toLowerCase()),c=>{return c>=65&&c<=90||c>=97&&c<=123}))}function expand(word){const output=[];Array.prototype.forEach.call(toUtf8Bytes(word),c=>{if(c===47){output.push(204);output.push(129)}else if(c===126){output.push(110);output.push(204);output.push(131)}else{output.push(c)}});return toUtf8String(output)}function loadWords$2(lang){if(wordlist$2!=null){return}wordlist$2=words$2.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ").map(w=>expand(w));wordlist$2.forEach((word,index)=>{lookup[dropDiacritic(word)]=index});if(Wordlist.check(lang)!=="0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300"){wordlist$2=null;throw new Error("BIP39 Wordlist for es (Spanish) FAILED")}}class LangEs extends Wordlist{constructor(){super("es")}getWord(index){loadWords$2(this);return wordlist$2[index]}getWordIndex(word){loadWords$2(this);return lookup[dropDiacritic(word)]}}const langEs=new LangEs;Wordlist.register(langEs);"use strict";const words$3="AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie";let wordlist$3=null;const lookup$1={};function dropDiacritic$1(word){logger$k.checkNormalize();return toUtf8String(Array.prototype.filter.call(toUtf8Bytes(word.normalize("NFD").toLowerCase()),c=>{return c>=65&&c<=90||c>=97&&c<=123}))}function expand$1(word){const output=[];Array.prototype.forEach.call(toUtf8Bytes(word),c=>{if(c===47){output.push(204);output.push(129)}else if(c===45){output.push(204);output.push(128)}else{output.push(c)}});return toUtf8String(output)}function loadWords$3(lang){if(wordlist$3!=null){return}wordlist$3=words$3.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ").map(w=>expand$1(w));wordlist$3.forEach((word,index)=>{lookup$1[dropDiacritic$1(word)]=index});if(Wordlist.check(lang)!=="0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045"){wordlist$3=null;throw new Error("BIP39 Wordlist for fr (French) FAILED")}}class LangFr extends Wordlist{constructor(){super("fr")}getWord(index){loadWords$3(this);return wordlist$3[index]}getWordIndex(word){loadWords$3(this);return lookup$1[dropDiacritic$1(word)]}}const langFr=new LangFr;Wordlist.register(langFr);"use strict";const data=["AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR","ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR","AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm","ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC","BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD","QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD","IJBEJqXZJ"];const mapping="~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";let wordlist$4=null;function hex(word){return hexlify(toUtf8Bytes(word))}const KiYoKu="0xe3818de38284e3818f";const KyoKu="0xe3818de38283e3818f";function loadWords$4(lang){if(wordlist$4!==null){return}wordlist$4=[];const transform={};transform[toUtf8String([227,130,154])]=false;transform[toUtf8String([227,130,153])]=false;transform[toUtf8String([227,130,133])]=toUtf8String([227,130,134]);transform[toUtf8String([227,129,163])]=toUtf8String([227,129,164]);transform[toUtf8String([227,130,131])]=toUtf8String([227,130,132]);transform[toUtf8String([227,130,135])]=toUtf8String([227,130,136]);function normalize(word){let result="";for(let i=0;i<word.length;i++){let kana=word[i];const target=transform[kana];if(target===false){continue}if(target){kana=target}result+=kana}return result}function sortJapanese(a,b){a=normalize(a);b=normalize(b);if(a<b){return-1}if(a>b){return 1}return 0}for(let length=3;length<=9;length++){const d=data[length-3];for(let offset=0;offset<d.length;offset+=length){const word=[];for(let i=0;i<length;i++){const k=mapping.indexOf(d[offset+i]);word.push(227);word.push(k&64?130:129);word.push((k&63)+128)}wordlist$4.push(toUtf8String(word))}}wordlist$4.sort(sortJapanese);if(hex(wordlist$4[442])===KiYoKu&&hex(wordlist$4[443])===KyoKu){const tmp=wordlist$4[442];wordlist$4[442]=wordlist$4[443];wordlist$4[443]=tmp}if(Wordlist.check(lang)!=="0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600"){wordlist$4=null;throw new Error("BIP39 Wordlist for ja (Japanese) FAILED")}}class LangJa extends Wordlist{constructor(){super("ja")}getWord(index){loadWords$4(this);return wordlist$4[index]}getWordIndex(word){loadWords$4(this);return wordlist$4.indexOf(word)}split(mnemonic){logger$k.checkNormalize();return mnemonic.split(/(?:\u3000| )+/g)}join(words){return words.join("")}}const langJa=new LangJa;Wordlist.register(langJa);"use strict";const data$1=["OYAa","ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8","ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6","ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv","AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo","AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg","HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb","AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"];const codes="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";function getHangul(code){if(code>=40){code=code+168-40}else if(code>=19){code=code+97-19}return toUtf8String([225,(code>>6)+132,(code&63)+128])}let wordlist$5=null;function loadWords$5(lang){if(wordlist$5!=null){return}wordlist$5=[];data$1.forEach((data,length)=>{length+=4;for(let i=0;i<data.length;i+=length){let word="";for(let j=0;j<length;j++){word+=getHangul(codes.indexOf(data[i+j]))}wordlist$5.push(word)}});wordlist$5.sort();if(Wordlist.check(lang)!=="0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a"){wordlist$5=null;throw new Error("BIP39 Wordlist for ko (Korean) FAILED")}}class LangKo extends Wordlist{constructor(){super("ko")}getWord(index){loadWords$5(this);return wordlist$5[index]}getWordIndex(word){loadWords$5(this);return wordlist$5.indexOf(word)}}const langKo=new LangKo;Wordlist.register(langKo);"use strict";const words$4="AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa";let wordlist$6=null;function loadWords$6(lang){if(wordlist$6!=null){return}wordlist$6=words$4.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ");if(Wordlist.check(lang)!=="0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620"){wordlist$6=null;throw new Error("BIP39 Wordlist for it (Italian) FAILED")}}class LangIt extends Wordlist{constructor(){super("it")}getWord(index){loadWords$6(this);return wordlist$6[index]}getWordIndex(word){loadWords$6(this);return wordlist$6.indexOf(word)}}const langIt=new LangIt;Wordlist.register(langIt);"use strict";const data$2="}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";const deltaData="FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";const wordlist$7={zh_cn:null,zh_tw:null};const Checks={zh_cn:"0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",zh_tw:"0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"};const codes$1="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";const style="~!@#$%^&*_-=[]{}|;:,.()<>?";function loadWords$7(lang){if(wordlist$7[lang.locale]!==null){return}wordlist$7[lang.locale]=[];let deltaOffset=0;for(let i=0;i<2048;i++){const s=style.indexOf(data$2[i*3]);const bytes=[228+(s>>2),128+codes$1.indexOf(data$2[i*3+1]),128+codes$1.indexOf(data$2[i*3+2])];if(lang.locale==="zh_tw"){const common=s%4;for(let i=common;i<3;i++){bytes[i]=codes$1.indexOf(deltaData[deltaOffset++])+(i==0?228:128)}}wordlist$7[lang.locale].push(toUtf8String(bytes))}if(Wordlist.check(lang)!==Checks[lang.locale]){wordlist$7[lang.locale]=null;throw new Error("BIP39 Wordlist for "+lang.locale+" (Chinese) FAILED")}}class LangZh extends Wordlist{constructor(country){super("zh_"+country)}getWord(index){loadWords$7(this);return wordlist$7[this.locale][index]}getWordIndex(word){loadWords$7(this);return wordlist$7[this.locale].indexOf(word)}split(mnemonic){mnemonic=mnemonic.replace(/(?:\u3000| )+/g,"");return mnemonic.split("")}}const langZhCn=new LangZh("cn");Wordlist.register(langZhCn);Wordlist.register(langZhCn,"zh");const langZhTw=new LangZh("tw");Wordlist.register(langZhTw);const wordlists={cz:langCz,en:langEn,es:langEs,fr:langFr,it:langIt,ja:langJa,ko:langKo,zh:langZhCn,zh_cn:langZhCn,zh_tw:langZhTw};"use strict";const version$g="hdnode/5.1.0";"use strict";const logger$l=new Logger(version$g);const N=BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const MasterSecret=toUtf8Bytes("Bitcoin seed");const HardenedBit=2147483648;function getUpperMask(bits){return(1<<bits)-1<<8-bits}function getLowerMask(bits){return(1<<bits)-1}function bytes32(value){return hexZeroPad(hexlify(value),32)}function base58check(data){return Base58.encode(concat([data,hexDataSlice(sha256$1(sha256$1(data)),0,4)]))}function getWordlist(wordlist){if(wordlist==null){return wordlists["en"]}if(typeof wordlist==="string"){const words=wordlists[wordlist];if(words==null){logger$l.throwArgumentError("unknown locale","wordlist",wordlist)}return words}return wordlist}const _constructorGuard$3={};const defaultPath="m/44'/60'/0'/0/0";class HDNode{constructor(constructorGuard,privateKey,publicKey,parentFingerprint,chainCode,index,depth,mnemonicOrPath){logger$l.checkNew(new.target,HDNode);if(constructorGuard!==_constructorGuard$3){throw new Error("HDNode constructor cannot be called directly")}if(privateKey){const signingKey=new SigningKey(privateKey);defineReadOnly(this,"privateKey",signingKey.privateKey);defineReadOnly(this,"publicKey",signingKey.compressedPublicKey)}else{defineReadOnly(this,"privateKey",null);defineReadOnly(this,"publicKey",hexlify(publicKey))}defineReadOnly(this,"parentFingerprint",parentFingerprint);defineReadOnly(this,"fingerprint",hexDataSlice(ripemd160$1(sha256$1(this.publicKey)),0,4));defineReadOnly(this,"address",computeAddress(this.publicKey));defineReadOnly(this,"chainCode",chainCode);defineReadOnly(this,"index",index);defineReadOnly(this,"depth",depth);if(mnemonicOrPath==null){defineReadOnly(this,"mnemonic",null);defineReadOnly(this,"path",null)}else if(typeof mnemonicOrPath==="string"){defineReadOnly(this,"mnemonic",null);defineReadOnly(this,"path",mnemonicOrPath)}else{defineReadOnly(this,"mnemonic",mnemonicOrPath);defineReadOnly(this,"path",mnemonicOrPath.path)}}get extendedKey(){if(this.depth>=256){throw new Error("Depth too large!")}return base58check(concat([this.privateKey!=null?"0x0488ADE4":"0x0488B21E",hexlify(this.depth),this.parentFingerprint,hexZeroPad(hexlify(this.index),4),this.chainCode,this.privateKey!=null?concat(["0x00",this.privateKey]):this.publicKey]))}neuter(){return new HDNode(_constructorGuard$3,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,this.path)}_derive(index){if(index>4294967295){throw new Error("invalid index - "+String(index))}let path=this.path;if(path){path+="/"+(index&~HardenedBit)}const data=new Uint8Array(37);if(index&HardenedBit){if(!this.privateKey){throw new Error("cannot derive child of neutered node")}data.set(arrayify(this.privateKey),1);if(path){path+="'"}}else{data.set(arrayify(this.publicKey))}for(let i=24;i>=0;i-=8){data[33+(i>>3)]=index>>24-i&255}const I=arrayify(computeHmac(SupportedAlgorithm.sha512,this.chainCode,data));const IL=I.slice(0,32);const IR=I.slice(32);let ki=null;let Ki=null;if(this.privateKey){ki=bytes32(BigNumber.from(IL).add(this.privateKey).mod(N))}else{const ek=new SigningKey(hexlify(IL));Ki=ek._addPoint(this.publicKey)}let mnemonicOrPath=path;const srcMnemonic=this.mnemonic;if(srcMnemonic){mnemonicOrPath=Object.freeze({phrase:srcMnemonic.phrase,path:path,locale:srcMnemonic.locale||"en"})}return new HDNode(_constructorGuard$3,ki,Ki,this.fingerprint,bytes32(IR),index,this.depth+1,mnemonicOrPath)}derivePath(path){const components=path.split("/");if(components.length===0||components[0]==="m"&&this.depth!==0){throw new Error("invalid path - "+path)}if(components[0]==="m"){components.shift()}let result=this;for(let i=0;i<components.length;i++){const component=components[i];if(component.match(/^[0-9]+'$/)){const index=parseInt(component.substring(0,component.length-1));if(index>=HardenedBit){throw new Error("invalid path index - "+component)}result=result._derive(HardenedBit+index)}else if(component.match(/^[0-9]+$/)){const index=parseInt(component);if(index>=HardenedBit){throw new Error("invalid path index - "+component)}result=result._derive(index)}else{throw new Error("invalid path component - "+component)}}return result}static _fromSeed(seed,mnemonic){const seedArray=arrayify(seed);if(seedArray.length<16||seedArray.length>64){throw new Error("invalid seed")}const I=arrayify(computeHmac(SupportedAlgorithm.sha512,MasterSecret,seedArray));return new HDNode(_constructorGuard$3,bytes32(I.slice(0,32)),null,"0x00000000",bytes32(I.slice(32)),0,0,mnemonic)}static fromMnemonic(mnemonic,password,wordlist){wordlist=getWordlist(wordlist);mnemonic=entropyToMnemonic(mnemonicToEntropy(mnemonic,wordlist),wordlist);return HDNode._fromSeed(mnemonicToSeed(mnemonic,password),{phrase:mnemonic,path:"m",locale:wordlist.locale})}static fromSeed(seed){return HDNode._fromSeed(seed,null)}static fromExtendedKey(extendedKey){const bytes=Base58.decode(extendedKey);if(bytes.length!==82||base58check(bytes.slice(0,78))!==extendedKey){logger$l.throwArgumentError("invalid extended key","extendedKey","[REDACTED]")}const depth=bytes[4];const parentFingerprint=hexlify(bytes.slice(5,9));const index=parseInt(hexlify(bytes.slice(9,13)).substring(2),16);const chainCode=hexlify(bytes.slice(13,45));const key=bytes.slice(45,78);switch(hexlify(bytes.slice(0,4))){case"0x0488b21e":case"0x043587cf":return new HDNode(_constructorGuard$3,null,hexlify(key),parentFingerprint,chainCode,index,depth,null);case"0x0488ade4":case"0x04358394 ":if(key[0]!==0){break}return new HDNode(_constructorGuard$3,hexlify(key.slice(1)),null,parentFingerprint,chainCode,index,depth,null)}return logger$l.throwArgumentError("invalid extended key","extendedKey","[REDACTED]")}}function mnemonicToSeed(mnemonic,password){if(!password){password=""}const salt=toUtf8Bytes("mnemonic"+password,UnicodeNormalizationForm.NFKD);return pbkdf2(toUtf8Bytes(mnemonic,UnicodeNormalizationForm.NFKD),salt,2048,64,"sha512")}function mnemonicToEntropy(mnemonic,wordlist){wordlist=getWordlist(wordlist);logger$l.checkNormalize();const words=wordlist.split(mnemonic);if(words.length%3!==0){throw new Error("invalid mnemonic")}const entropy=arrayify(new Uint8Array(Math.ceil(11*words.length/8)));let offset=0;for(let i=0;i<words.length;i++){let index=wordlist.getWordIndex(words[i].normalize("NFKD"));if(index===-1){throw new Error("invalid mnemonic")}for(let bit=0;bit<11;bit++){if(index&1<<10-bit){entropy[offset>>3]|=1<<7-offset%8}offset++}}const entropyBits=32*words.length/3;const checksumBits=words.length/3;const checksumMask=getUpperMask(checksumBits);const checksum=arrayify(sha256$1(entropy.slice(0,entropyBits/8)))[0]&checksumMask;if(checksum!==(entropy[entropy.length-1]&checksumMask)){throw new Error("invalid checksum")}return hexlify(entropy.slice(0,entropyBits/8))}function entropyToMnemonic(entropy,wordlist){wordlist=getWordlist(wordlist);entropy=arrayify(entropy);if(entropy.length%4!==0||entropy.length<16||entropy.length>32){throw new Error("invalid entropy")}const indices=[0];let remainingBits=11;for(let i=0;i<entropy.length;i++){if(remainingBits>8){indices[indices.length-1]<<=8;indices[indices.length-1]|=entropy[i];remainingBits-=8}else{indices[indices.length-1]<<=remainingBits;indices[indices.length-1]|=entropy[i]>>8-remainingBits;indices.push(entropy[i]&getLowerMask(8-remainingBits));remainingBits+=3}}const checksumBits=entropy.length/4;const checksum=arrayify(sha256$1(entropy))[0]&getUpperMask(checksumBits);indices[indices.length-1]<<=checksumBits;indices[indices.length-1]|=checksum>>8-checksumBits;return wordlist.join(indices.map(index=>wordlist.getWord(index)))}function isValidMnemonic(mnemonic,wordlist){try{mnemonicToEntropy(mnemonic,wordlist);return true}catch(error){}return false}const version$h="random/5.1.0";"use strict";const logger$m=new Logger(version$h);let anyGlobal=null;try{anyGlobal=window;if(anyGlobal==null){throw new Error("try next")}}catch(error){try{anyGlobal=__webpack_require__.g;if(anyGlobal==null){throw new Error("try next")}}catch(error){anyGlobal={}}}let crypto=anyGlobal.crypto||anyGlobal.msCrypto;if(!crypto||!crypto.getRandomValues){logger$m.warn("WARNING: Missing strong random number source");crypto={getRandomValues:function(buffer){return logger$m.throwError("no secure random source avaialble",Logger.errors.UNSUPPORTED_OPERATION,{operation:"crypto.getRandomValues"})}}}function randomBytes(length){if(length<=0||length>1024||length%1){logger$m.throwArgumentError("invalid length","length",length)}const result=new Uint8Array(length);crypto.getRandomValues(result);return arrayify(result)}"use strict";function shuffled(array){array=array.slice();for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));const tmp=array[i];array[i]=array[j];array[j]=tmp}return array}"use strict";var aesJs=createCommonjsModule(function(module,exports){"use strict";(function(root){function checkInt(value){return parseInt(value)===value}function checkInts(arrayish){if(!checkInt(arrayish.length)){return false}for(var i=0;i<arrayish.length;i++){if(!checkInt(arrayish[i])||arrayish[i]<0||arrayish[i]>255){return false}}return true}function coerceArray(arg,copy){if(arg.buffer&&ArrayBuffer.isView(arg)&&arg.name==="Uint8Array"){if(copy){if(arg.slice){arg=arg.slice()}else{arg=Array.prototype.slice.call(arg)}}return arg}if(Array.isArray(arg)){if(!checkInts(arg)){throw new Error("Array contains invalid value: "+arg)}return new Uint8Array(arg)}if(checkInt(arg.length)&&checkInts(arg)){return new Uint8Array(arg)}throw new Error("unsupported array-like object")}function createArray(length){return new Uint8Array(length)}function copyArray(sourceArray,targetArray,targetStart,sourceStart,sourceEnd){if(sourceStart!=null||sourceEnd!=null){if(sourceArray.slice){sourceArray=sourceArray.slice(sourceStart,sourceEnd)}else{sourceArray=Array.prototype.slice.call(sourceArray,sourceStart,sourceEnd)}}targetArray.set(sourceArray,targetStart)}var convertUtf8=function(){function toBytes(text){var result=[],i=0;text=encodeURI(text);while(i<text.length){var c=text.charCodeAt(i++);if(c===37){result.push(parseInt(text.substr(i,2),16));i+=2}else{result.push(c)}}return coerceArray(result)}function fromBytes(bytes){var result=[],i=0;while(i<bytes.length){var c=bytes[i];if(c<128){result.push(String.fromCharCode(c));i++}else if(c>191&&c<224){result.push(String.fromCharCode((c&31)<<6|bytes[i+1]&63));i+=2}else{result.push(String.fromCharCode((c&15)<<12|(bytes[i+1]&63)<<6|bytes[i+2]&63));i+=3}}return result.join("")}return{toBytes:toBytes,fromBytes:fromBytes}}();var convertHex=function(){function toBytes(text){var result=[];for(var i=0;i<text.length;i+=2){result.push(parseInt(text.substr(i,2),16))}return result}var Hex="0123456789abcdef";function fromBytes(bytes){var result=[];for(var i=0;i<bytes.length;i++){var v=bytes[i];result.push(Hex[(v&240)>>4]+Hex[v&15])}return result.join("")}return{toBytes:toBytes,fromBytes:fromBytes}}();var numberOfRounds={16:10,24:12,32:14};var rcon=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145];var S=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];var Si=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125];var T1=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986];var T2=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766];var T3=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126];var T4=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436];var T5=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890];var T6=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935];var T7=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600];var T8=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480];var U1=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795];var U2=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855];var U3=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150];var U4=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function convertToInt32(bytes){var result=[];for(var i=0;i<bytes.length;i+=4){result.push(bytes[i]<<24|bytes[i+1]<<16|bytes[i+2]<<8|bytes[i+3])}return result}var AES=function(key){if(!(this instanceof AES)){throw Error("AES must be instanitated with `new`")}Object.defineProperty(this,"key",{value:coerceArray(key,true)});this._prepare()};AES.prototype._prepare=function(){var rounds=numberOfRounds[this.key.length];if(rounds==null){throw new Error("invalid key size (must be 16, 24 or 32 bytes)")}this._Ke=[];this._Kd=[];for(var i=0;i<=rounds;i++){this._Ke.push([0,0,0,0]);this._Kd.push([0,0,0,0])}var roundKeyCount=(rounds+1)*4;var KC=this.key.length/4;var tk=convertToInt32(this.key);var index;for(var i=0;i<KC;i++){index=i>>2;this._Ke[index][i%4]=tk[i];this._Kd[rounds-index][i%4]=tk[i]}var rconpointer=0;var t=KC,tt;while(t<roundKeyCount){tt=tk[KC-1];tk[0]^=S[tt>>16&255]<<24^S[tt>>8&255]<<16^S[tt&255]<<8^S[tt>>24&255]^rcon[rconpointer]<<24;rconpointer+=1;if(KC!=8){for(var i=1;i<KC;i++){tk[i]^=tk[i-1]}}else{for(var i=1;i<KC/2;i++){tk[i]^=tk[i-1]}tt=tk[KC/2-1];tk[KC/2]^=S[tt&255]^S[tt>>8&255]<<8^S[tt>>16&255]<<16^S[tt>>24&255]<<24;for(var i=KC/2+1;i<KC;i++){tk[i]^=tk[i-1]}}var i=0,r,c;while(i<KC&&t<roundKeyCount){r=t>>2;c=t%4;this._Ke[r][c]=tk[i];this._Kd[rounds-r][c]=tk[i++];t++}}for(var r=1;r<rounds;r++){for(var c=0;c<4;c++){tt=this._Kd[r][c];this._Kd[r][c]=U1[tt>>24&255]^U2[tt>>16&255]^U3[tt>>8&255]^U4[tt&255]}}};AES.prototype.encrypt=function(plaintext){if(plaintext.length!=16){throw new Error("invalid plaintext size (must be 16 bytes)")}var rounds=this._Ke.length-1;var a=[0,0,0,0];var t=convertToInt32(plaintext);for(var i=0;i<4;i++){t[i]^=this._Ke[0][i]}for(var r=1;r<rounds;r++){for(var i=0;i<4;i++){a[i]=T1[t[i]>>24&255]^T2[t[(i+1)%4]>>16&255]^T3[t[(i+2)%4]>>8&255]^T4[t[(i+3)%4]&255]^this._Ke[r][i]}t=a.slice()}var result=createArray(16),tt;for(var i=0;i<4;i++){tt=this._Ke[rounds][i];result[4*i]=(S[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(S[t[(i+1)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(S[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(S[t[(i+3)%4]&255]^tt)&255}return result};AES.prototype.decrypt=function(ciphertext){if(ciphertext.length!=16){throw new Error("invalid ciphertext size (must be 16 bytes)")}var rounds=this._Kd.length-1;var a=[0,0,0,0];var t=convertToInt32(ciphertext);for(var i=0;i<4;i++){t[i]^=this._Kd[0][i]}for(var r=1;r<rounds;r++){for(var i=0;i<4;i++){a[i]=T5[t[i]>>24&255]^T6[t[(i+3)%4]>>16&255]^T7[t[(i+2)%4]>>8&255]^T8[t[(i+1)%4]&255]^this._Kd[r][i]}t=a.slice()}var result=createArray(16),tt;for(var i=0;i<4;i++){tt=this._Kd[rounds][i];result[4*i]=(Si[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(Si[t[(i+3)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(Si[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(Si[t[(i+1)%4]&255]^tt)&255}return result};var ModeOfOperationECB=function(key){if(!(this instanceof ModeOfOperationECB)){throw Error("AES must be instanitated with `new`")}this.description="Electronic Code Block";this.name="ecb";this._aes=new AES(key)};ModeOfOperationECB.prototype.encrypt=function(plaintext){plaintext=coerceArray(plaintext);if(plaintext.length%16!==0){throw new Error("invalid plaintext size (must be multiple of 16 bytes)")}var ciphertext=createArray(plaintext.length);var block=createArray(16);for(var i=0;i<plaintext.length;i+=16){copyArray(plaintext,block,0,i,i+16);block=this._aes.encrypt(block);copyArray(block,ciphertext,i)}return ciphertext};ModeOfOperationECB.prototype.decrypt=function(ciphertext){ciphertext=coerceArray(ciphertext);if(ciphertext.length%16!==0){throw new Error("invalid ciphertext size (must be multiple of 16 bytes)")}var plaintext=createArray(ciphertext.length);var block=createArray(16);for(var i=0;i<ciphertext.length;i+=16){copyArray(ciphertext,block,0,i,i+16);block=this._aes.decrypt(block);copyArray(block,plaintext,i)}return plaintext};var ModeOfOperationCBC=function(key,iv){if(!(this instanceof ModeOfOperationCBC)){throw Error("AES must be instanitated with `new`")}this.description="Cipher Block Chaining";this.name="cbc";if(!iv){iv=createArray(16)}else if(iv.length!=16){throw new Error("invalid initialation vector size (must be 16 bytes)")}this._lastCipherblock=coerceArray(iv,true);this._aes=new AES(key)};ModeOfOperationCBC.prototype.encrypt=function(plaintext){plaintext=coerceArray(plaintext);if(plaintext.length%16!==0){throw new Error("invalid plaintext size (must be multiple of 16 bytes)")}var ciphertext=createArray(plaintext.length);var block=createArray(16);for(var i=0;i<plaintext.length;i+=16){copyArray(plaintext,block,0,i,i+16);for(var j=0;j<16;j++){block[j]^=this._lastCipherblock[j]}this._lastCipherblock=this._aes.encrypt(block);copyArray(this._lastCipherblock,ciphertext,i)}return ciphertext};ModeOfOperationCBC.prototype.decrypt=function(ciphertext){ciphertext=coerceArray(ciphertext);if(ciphertext.length%16!==0){throw new Error("invalid ciphertext size (must be multiple of 16 bytes)")}var plaintext=createArray(ciphertext.length);var block=createArray(16);for(var i=0;i<ciphertext.length;i+=16){copyArray(ciphertext,block,0,i,i+16);block=this._aes.decrypt(block);for(var j=0;j<16;j++){plaintext[i+j]=block[j]^this._lastCipherblock[j]}copyArray(ciphertext,this._lastCipherblock,0,i,i+16)}return plaintext};var ModeOfOperationCFB=function(key,iv,segmentSize){if(!(this instanceof ModeOfOperationCFB)){throw Error("AES must be instanitated with `new`")}this.description="Cipher Feedback";this.name="cfb";if(!iv){iv=createArray(16)}else if(iv.length!=16){throw new Error("invalid initialation vector size (must be 16 size)")}if(!segmentSize){segmentSize=1}this.segmentSize=segmentSize;this._shiftRegister=coerceArray(iv,true);this._aes=new AES(key)};ModeOfOperationCFB.prototype.encrypt=function(plaintext){if(plaintext.length%this.segmentSize!=0){throw new Error("invalid plaintext size (must be segmentSize bytes)")}var encrypted=coerceArray(plaintext,true);var xorSegment;for(var i=0;i<encrypted.length;i+=this.segmentSize){xorSegment=this._aes.encrypt(this._shiftRegister);for(var j=0;j<this.segmentSize;j++){encrypted[i+j]^=xorSegment[j]}copyArray(this._shiftRegister,this._shiftRegister,0,this.segmentSize);copyArray(encrypted,this._shiftRegister,16-this.segmentSize,i,i+this.segmentSize)}return encrypted};ModeOfOperationCFB.prototype.decrypt=function(ciphertext){if(ciphertext.length%this.segmentSize!=0){throw new Error("invalid ciphertext size (must be segmentSize bytes)")}var plaintext=coerceArray(ciphertext,true);var xorSegment;for(var i=0;i<plaintext.length;i+=this.segmentSize){xorSegment=this._aes.encrypt(this._shiftRegister);for(var j=0;j<this.segmentSize;j++){plaintext[i+j]^=xorSegment[j]}copyArray(this._shiftRegister,this._shiftRegister,0,this.segmentSize);copyArray(ciphertext,this._shiftRegister,16-this.segmentSize,i,i+this.segmentSize)}return plaintext};var ModeOfOperationOFB=function(key,iv){if(!(this instanceof ModeOfOperationOFB)){throw Error("AES must be instanitated with `new`")}this.description="Output Feedback";this.name="ofb";if(!iv){iv=createArray(16)}else if(iv.length!=16){throw new Error("invalid initialation vector size (must be 16 bytes)")}this._lastPrecipher=coerceArray(iv,true);this._lastPrecipherIndex=16;this._aes=new AES(key)};ModeOfOperationOFB.prototype.encrypt=function(plaintext){var encrypted=coerceArray(plaintext,true);for(var i=0;i<encrypted.length;i++){if(this._lastPrecipherIndex===16){this._lastPrecipher=this._aes.encrypt(this._lastPrecipher);this._lastPrecipherIndex=0}encrypted[i]^=this._lastPrecipher[this._lastPrecipherIndex++]}return encrypted};ModeOfOperationOFB.prototype.decrypt=ModeOfOperationOFB.prototype.encrypt;var Counter=function(initialValue){if(!(this instanceof Counter)){throw Error("Counter must be instanitated with `new`")}if(initialValue!==0&&!initialValue){initialValue=1}if(typeof initialValue==="number"){this._counter=createArray(16);this.setValue(initialValue)}else{this.setBytes(initialValue)}};Counter.prototype.setValue=function(value){if(typeof value!=="number"||parseInt(value)!=value){throw new Error("invalid counter value (must be an integer)")}for(var index=15;index>=0;--index){this._counter[index]=value%256;value=value>>8}};Counter.prototype.setBytes=function(bytes){bytes=coerceArray(bytes,true);if(bytes.length!=16){throw new Error("invalid counter bytes size (must be 16 bytes)")}this._counter=bytes};Counter.prototype.increment=function(){for(var i=15;i>=0;i--){if(this._counter[i]===255){this._counter[i]=0}else{this._counter[i]++;break}}};var ModeOfOperationCTR=function(key,counter){if(!(this instanceof ModeOfOperationCTR)){throw Error("AES must be instanitated with `new`")}this.description="Counter";this.name="ctr";if(!(counter instanceof Counter)){counter=new Counter(counter)}this._counter=counter;this._remainingCounter=null;this._remainingCounterIndex=16;this._aes=new AES(key)};ModeOfOperationCTR.prototype.encrypt=function(plaintext){var encrypted=coerceArray(plaintext,true);for(var i=0;i<encrypted.length;i++){if(this._remainingCounterIndex===16){this._remainingCounter=this._aes.encrypt(this._counter._counter);this._remainingCounterIndex=0;this._counter.increment()}encrypted[i]^=this._remainingCounter[this._remainingCounterIndex++]}return encrypted};ModeOfOperationCTR.prototype.decrypt=ModeOfOperationCTR.prototype.encrypt;function pkcs7pad(data){data=coerceArray(data,true);var padder=16-data.length%16;var result=createArray(data.length+padder);copyArray(data,result);for(var i=data.length;i<result.length;i++){result[i]=padder}return result}function pkcs7strip(data){data=coerceArray(data,true);if(data.length<16){throw new Error("PKCS#7 invalid length")}var padder=data[data.length-1];if(padder>16){throw new Error("PKCS#7 padding byte out of range")}var length=data.length-padder;for(var i=0;i<padder;i++){if(data[length+i]!==padder){throw new Error("PKCS#7 invalid padding byte")}}var result=createArray(length);copyArray(data,result,0,0,length);return result}var aesjs={AES:AES,Counter:Counter,ModeOfOperation:{ecb:ModeOfOperationECB,cbc:ModeOfOperationCBC,cfb:ModeOfOperationCFB,ofb:ModeOfOperationOFB,ctr:ModeOfOperationCTR},utils:{hex:convertHex,utf8:convertUtf8},padding:{pkcs7:{pad:pkcs7pad,strip:pkcs7strip}},_arrayTest:{coerceArray:coerceArray,createArray:createArray,copyArray:copyArray}};if(true){module.exports=aesjs}else {}})(commonjsGlobal)});const version$i="json-wallets/5.1.0";"use strict";function looseArrayify(hexString){if(typeof hexString==="string"&&hexString.substring(0,2)!=="0x"){hexString="0x"+hexString}return arrayify(hexString)}function zpad(value,length){value=String(value);while(value.length<length){value="0"+value}return value}function getPassword(password){if(typeof password==="string"){return toUtf8Bytes(password,UnicodeNormalizationForm.NFKC)}return arrayify(password)}function searchPath(object,path){let currentChild=object;const comps=path.toLowerCase().split("/");for(let i=0;i<comps.length;i++){let matchingChild=null;for(const key in currentChild){if(key.toLowerCase()===comps[i]){matchingChild=currentChild[key];break}}if(matchingChild===null){return null}currentChild=matchingChild}return currentChild}function uuidV4(randomBytes){const bytes=arrayify(randomBytes);bytes[6]=bytes[6]&15|64;bytes[8]=bytes[8]&63|128;const value=hexlify(bytes);return[value.substring(2,10),value.substring(10,14),value.substring(14,18),value.substring(18,22),value.substring(22,34)].join("-")}"use strict";const logger$n=new Logger(version$i);class CrowdsaleAccount extends Description{isCrowdsaleAccount(value){return!!(value&&value._isCrowdsaleAccount)}}function decrypt(json,password){const data=JSON.parse(json);password=getPassword(password);const ethaddr=getAddress(searchPath(data,"ethaddr"));const encseed=looseArrayify(searchPath(data,"encseed"));if(!encseed||encseed.length%16!==0){logger$n.throwArgumentError("invalid encseed","json",json)}const key=arrayify(pbkdf2(password,password,2e3,32,"sha256")).slice(0,16);const iv=encseed.slice(0,16);const encryptedSeed=encseed.slice(16);const aesCbc=new aesJs.ModeOfOperation.cbc(key,iv);const seed=aesJs.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));let seedHex="";for(let i=0;i<seed.length;i++){seedHex+=String.fromCharCode(seed[i])}const seedHexBytes=toUtf8Bytes(seedHex);const privateKey=keccak256(seedHexBytes);return new CrowdsaleAccount({_isCrowdsaleAccount:true,address:ethaddr,privateKey:privateKey})}"use strict";function isCrowdsaleWallet(json){let data=null;try{data=JSON.parse(json)}catch(error){return false}return data.encseed&&data.ethaddr}function isKeystoreWallet(json){let data=null;try{data=JSON.parse(json)}catch(error){return false}if(!data.version||parseInt(data.version)!==data.version||parseInt(data.version)!==3){return false}return true}function getJsonWalletAddress(json){if(isCrowdsaleWallet(json)){try{return getAddress(JSON.parse(json).ethaddr)}catch(error){return null}}if(isKeystoreWallet(json)){try{return getAddress(JSON.parse(json).address)}catch(error){return null}}return null}var scrypt=createCommonjsModule(function(module,exports){"use strict";(function(root){const MAX_VALUE=2147483647;function SHA256(m){const K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);let h0=1779033703,h1=3144134277,h2=1013904242,h3=2773480762;let h4=1359893119,h5=2600822924,h6=528734635,h7=1541459225;const w=new Uint32Array(64);function blocks(p){let off=0,len=p.length;while(len>=64){let a=h0,b=h1,c=h2,d=h3,e=h4,f=h5,g=h6,h=h7,u,i,j,t1,t2;for(i=0;i<16;i++){j=off+i*4;w[i]=(p[j]&255)<<24|(p[j+1]&255)<<16|(p[j+2]&255)<<8|p[j+3]&255}for(i=16;i<64;i++){u=w[i-2];t1=(u>>>17|u<<32-17)^(u>>>19|u<<32-19)^u>>>10;u=w[i-15];t2=(u>>>7|u<<32-7)^(u>>>18|u<<32-18)^u>>>3;w[i]=(t1+w[i-7]|0)+(t2+w[i-16]|0)|0}for(i=0;i<64;i++){t1=(((e>>>6|e<<32-6)^(e>>>11|e<<32-11)^(e>>>25|e<<32-25))+(e&f^~e&g)|0)+(h+(K[i]+w[i]|0)|0)|0;t2=((a>>>2|a<<32-2)^(a>>>13|a<<32-13)^(a>>>22|a<<32-22))+(a&b^a&c^b&c)|0;h=g;g=f;f=e;e=d+t1|0;d=c;c=b;b=a;a=t1+t2|0}h0=h0+a|0;h1=h1+b|0;h2=h2+c|0;h3=h3+d|0;h4=h4+e|0;h5=h5+f|0;h6=h6+g|0;h7=h7+h|0;off+=64;len-=64}}blocks(m);let i,bytesLeft=m.length%64,bitLenHi=m.length/536870912|0,bitLenLo=m.length<<3,numZeros=bytesLeft<56?56:120,p=m.slice(m.length-bytesLeft,m.length);p.push(128);for(i=bytesLeft+1;i<numZeros;i++){p.push(0)}p.push(bitLenHi>>>24&255);p.push(bitLenHi>>>16&255);p.push(bitLenHi>>>8&255);p.push(bitLenHi>>>0&255);p.push(bitLenLo>>>24&255);p.push(bitLenLo>>>16&255);p.push(bitLenLo>>>8&255);p.push(bitLenLo>>>0&255);blocks(p);return[h0>>>24&255,h0>>>16&255,h0>>>8&255,h0>>>0&255,h1>>>24&255,h1>>>16&255,h1>>>8&255,h1>>>0&255,h2>>>24&255,h2>>>16&255,h2>>>8&255,h2>>>0&255,h3>>>24&255,h3>>>16&255,h3>>>8&255,h3>>>0&255,h4>>>24&255,h4>>>16&255,h4>>>8&255,h4>>>0&255,h5>>>24&255,h5>>>16&255,h5>>>8&255,h5>>>0&255,h6>>>24&255,h6>>>16&255,h6>>>8&255,h6>>>0&255,h7>>>24&255,h7>>>16&255,h7>>>8&255,h7>>>0&255]}function PBKDF2_HMAC_SHA256_OneIter(password,salt,dkLen){password=password.length<=64?password:SHA256(password);const innerLen=64+salt.length+4;const inner=new Array(innerLen);const outerKey=new Array(64);let i;let dk=[];for(i=0;i<64;i++){inner[i]=54}for(i=0;i<password.length;i++){inner[i]^=password[i]}for(i=0;i<salt.length;i++){inner[64+i]=salt[i]}for(i=innerLen-4;i<innerLen;i++){inner[i]=0}for(i=0;i<64;i++)outerKey[i]=92;for(i=0;i<password.length;i++)outerKey[i]^=password[i];function incrementCounter(){for(let i=innerLen-1;i>=innerLen-4;i--){inner[i]++;if(inner[i]<=255)return;inner[i]=0}}while(dkLen>=32){incrementCounter();dk=dk.concat(SHA256(outerKey.concat(SHA256(inner))));dkLen-=32}if(dkLen>0){incrementCounter();dk=dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0,dkLen))}return dk}function blockmix_salsa8(BY,Yi,r,x,_X){let i;arraycopy(BY,(2*r-1)*16,_X,0,16);for(i=0;i<2*r;i++){blockxor(BY,i*16,_X,16);salsa20_8(_X,x);arraycopy(_X,0,BY,Yi+i*16,16)}for(i=0;i<r;i++){arraycopy(BY,Yi+i*2*16,BY,i*16,16)}for(i=0;i<r;i++){arraycopy(BY,Yi+(i*2+1)*16,BY,(i+r)*16,16)}}function R(a,b){return a<<b|a>>>32-b}function salsa20_8(B,x){arraycopy(B,0,x,0,16);for(let i=8;i>0;i-=2){x[4]^=R(x[0]+x[12],7);x[8]^=R(x[4]+x[0],9);x[12]^=R(x[8]+x[4],13);x[0]^=R(x[12]+x[8],18);x[9]^=R(x[5]+x[1],7);x[13]^=R(x[9]+x[5],9);x[1]^=R(x[13]+x[9],13);x[5]^=R(x[1]+x[13],18);x[14]^=R(x[10]+x[6],7);x[2]^=R(x[14]+x[10],9);x[6]^=R(x[2]+x[14],13);x[10]^=R(x[6]+x[2],18);x[3]^=R(x[15]+x[11],7);x[7]^=R(x[3]+x[15],9);x[11]^=R(x[7]+x[3],13);x[15]^=R(x[11]+x[7],18);x[1]^=R(x[0]+x[3],7);x[2]^=R(x[1]+x[0],9);x[3]^=R(x[2]+x[1],13);x[0]^=R(x[3]+x[2],18);x[6]^=R(x[5]+x[4],7);x[7]^=R(x[6]+x[5],9);x[4]^=R(x[7]+x[6],13);x[5]^=R(x[4]+x[7],18);x[11]^=R(x[10]+x[9],7);x[8]^=R(x[11]+x[10],9);x[9]^=R(x[8]+x[11],13);x[10]^=R(x[9]+x[8],18);x[12]^=R(x[15]+x[14],7);x[13]^=R(x[12]+x[15],9);x[14]^=R(x[13]+x[12],13);x[15]^=R(x[14]+x[13],18)}for(let i=0;i<16;++i){B[i]+=x[i]}}function blockxor(S,Si,D,len){for(let i=0;i<len;i++){D[i]^=S[Si+i]}}function arraycopy(src,srcPos,dest,destPos,length){while(length--){dest[destPos++]=src[srcPos++]}}function checkBufferish(o){if(!o||typeof o.length!=="number"){return false}for(let i=0;i<o.length;i++){const v=o[i];if(typeof v!=="number"||v%1||v<0||v>=256){return false}}return true}function ensureInteger(value,name){if(typeof value!=="number"||value%1){throw new Error("invalid "+name)}return value}function _scrypt(password,salt,N,r,p,dkLen,callback){N=ensureInteger(N,"N");r=ensureInteger(r,"r");p=ensureInteger(p,"p");dkLen=ensureInteger(dkLen,"dkLen");if(N===0||(N&N-1)!==0){throw new Error("N must be power of 2")}if(N>MAX_VALUE/128/r){throw new Error("N too large")}if(r>MAX_VALUE/128/p){throw new Error("r too large")}if(!checkBufferish(password)){throw new Error("password must be an array or buffer")}password=Array.prototype.slice.call(password);if(!checkBufferish(salt)){throw new Error("salt must be an array or buffer")}salt=Array.prototype.slice.call(salt);let b=PBKDF2_HMAC_SHA256_OneIter(password,salt,p*128*r);const B=new Uint32Array(p*32*r);for(let i=0;i<B.length;i++){const j=i*4;B[i]=(b[j+3]&255)<<24|(b[j+2]&255)<<16|(b[j+1]&255)<<8|(b[j+0]&255)<<0}const XY=new Uint32Array(64*r);const V=new Uint32Array(32*r*N);const Yi=32*r;const x=new Uint32Array(16);const _X=new Uint32Array(16);const totalOps=p*N*2;let currentOp=0;let lastPercent10=null;let stop=false;let state=0;let i0=0,i1;let Bi;const limit=callback?parseInt(1e3/r):4294967295;const nextTick=typeof setImmediate!=="undefined"?setImmediate:setTimeout;const incrementalSMix=function(){if(stop){return callback(new Error("cancelled"),currentOp/totalOps)}let steps;switch(state){case 0:Bi=i0*32*r;arraycopy(B,Bi,XY,0,Yi);state=1;i1=0;case 1:steps=N-i1;if(steps>limit){steps=limit}for(let i=0;i<steps;i++){arraycopy(XY,0,V,(i1+i)*Yi,Yi);blockmix_salsa8(XY,Yi,r,x,_X)}i1+=steps;currentOp+=steps;if(callback){const percent10=parseInt(1e3*currentOp/totalOps);if(percent10!==lastPercent10){stop=callback(null,currentOp/totalOps);if(stop){break}lastPercent10=percent10}}if(i1<N){break}i1=0;state=2;case 2:steps=N-i1;if(steps>limit){steps=limit}for(let i=0;i<steps;i++){const offset=(2*r-1)*16;const j=XY[offset]&N-1;blockxor(V,j*Yi,XY,Yi);blockmix_salsa8(XY,Yi,r,x,_X)}i1+=steps;currentOp+=steps;if(callback){const percent10=parseInt(1e3*currentOp/totalOps);if(percent10!==lastPercent10){stop=callback(null,currentOp/totalOps);if(stop){break}lastPercent10=percent10}}if(i1<N){break}arraycopy(XY,0,B,Bi,Yi);i0++;if(i0<p){state=0;break}b=[];for(let i=0;i<B.length;i++){b.push(B[i]>>0&255);b.push(B[i]>>8&255);b.push(B[i]>>16&255);b.push(B[i]>>24&255)}const derivedKey=PBKDF2_HMAC_SHA256_OneIter(password,b,dkLen);if(callback){callback(null,1,derivedKey)}return derivedKey}if(callback){nextTick(incrementalSMix)}};if(!callback){while(true){const derivedKey=incrementalSMix();if(derivedKey!=undefined){return derivedKey}}}incrementalSMix()}const lib={scrypt:function(password,salt,N,r,p,dkLen,progressCallback){return new Promise(function(resolve,reject){let lastProgress=0;if(progressCallback){progressCallback(0)}_scrypt(password,salt,N,r,p,dkLen,function(error,progress,key){if(error){reject(error)}else if(key){if(progressCallback&&lastProgress!==1){progressCallback(1)}resolve(new Uint8Array(key))}else if(progressCallback&&progress!==lastProgress){lastProgress=progress;return progressCallback(progress)}})})},syncScrypt:function(password,salt,N,r,p,dkLen){return new Uint8Array(_scrypt(password,salt,N,r,p,dkLen))}};if(true){module.exports=lib}else {}})(commonjsGlobal)});"use strict";var __awaiter$4=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$o=new Logger(version$i);function hasMnemonic(value){return value!=null&&value.mnemonic&&value.mnemonic.phrase}class KeystoreAccount extends Description{isKeystoreAccount(value){return!!(value&&value._isKeystoreAccount)}}function _decrypt(data,key,ciphertext){const cipher=searchPath(data,"crypto/cipher");if(cipher==="aes-128-ctr"){const iv=looseArrayify(searchPath(data,"crypto/cipherparams/iv"));const counter=new aesJs.Counter(iv);const aesCtr=new aesJs.ModeOfOperation.ctr(key,counter);return arrayify(aesCtr.decrypt(ciphertext))}return null}function _getAccount(data,key){const ciphertext=looseArrayify(searchPath(data,"crypto/ciphertext"));const computedMAC=hexlify(keccak256(concat([key.slice(16,32),ciphertext]))).substring(2);if(computedMAC!==searchPath(data,"crypto/mac").toLowerCase()){throw new Error("invalid password")}const privateKey=_decrypt(data,key.slice(0,16),ciphertext);if(!privateKey){logger$o.throwError("unsupported cipher",Logger.errors.UNSUPPORTED_OPERATION,{operation:"decrypt"})}const mnemonicKey=key.slice(32,64);const address=computeAddress(privateKey);if(data.address){let check=data.address.toLowerCase();if(check.substring(0,2)!=="0x"){check="0x"+check}if(getAddress(check)!==address){throw new Error("address mismatch")}}const account={_isKeystoreAccount:true,address:address,privateKey:hexlify(privateKey)};if(searchPath(data,"x-ethers/version")==="0.1"){const mnemonicCiphertext=looseArrayify(searchPath(data,"x-ethers/mnemonicCiphertext"));const mnemonicIv=looseArrayify(searchPath(data,"x-ethers/mnemonicCounter"));const mnemonicCounter=new aesJs.Counter(mnemonicIv);const mnemonicAesCtr=new aesJs.ModeOfOperation.ctr(mnemonicKey,mnemonicCounter);const path=searchPath(data,"x-ethers/path")||defaultPath;const locale=searchPath(data,"x-ethers/locale")||"en";const entropy=arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));try{const mnemonic=entropyToMnemonic(entropy,locale);const node=HDNode.fromMnemonic(mnemonic,null,locale).derivePath(path);if(node.privateKey!=account.privateKey){throw new Error("mnemonic mismatch")}account.mnemonic=node.mnemonic}catch(error){if(error.code!==Logger.errors.INVALID_ARGUMENT||error.argument!=="wordlist"){throw error}}}return new KeystoreAccount(account)}function pbkdf2Sync(passwordBytes,salt,count,dkLen,prfFunc){return arrayify(pbkdf2(passwordBytes,salt,count,dkLen,prfFunc))}function pbkdf2$1(passwordBytes,salt,count,dkLen,prfFunc){return Promise.resolve(pbkdf2Sync(passwordBytes,salt,count,dkLen,prfFunc))}function _computeKdfKey(data,password,pbkdf2Func,scryptFunc,progressCallback){const passwordBytes=getPassword(password);const kdf=searchPath(data,"crypto/kdf");if(kdf&&typeof kdf==="string"){const throwError=function(name,value){return logger$o.throwArgumentError("invalid key-derivation function parameters",name,value)};if(kdf.toLowerCase()==="scrypt"){const salt=looseArrayify(searchPath(data,"crypto/kdfparams/salt"));const N=parseInt(searchPath(data,"crypto/kdfparams/n"));const r=parseInt(searchPath(data,"crypto/kdfparams/r"));const p=parseInt(searchPath(data,"crypto/kdfparams/p"));if(!N||!r||!p){throwError("kdf",kdf)}if((N&N-1)!==0){throwError("N",N)}const dkLen=parseInt(searchPath(data,"crypto/kdfparams/dklen"));if(dkLen!==32){throwError("dklen",dkLen)}return scryptFunc(passwordBytes,salt,N,r,p,64,progressCallback)}else if(kdf.toLowerCase()==="pbkdf2"){const salt=looseArrayify(searchPath(data,"crypto/kdfparams/salt"));let prfFunc=null;const prf=searchPath(data,"crypto/kdfparams/prf");if(prf==="hmac-sha256"){prfFunc="sha256"}else if(prf==="hmac-sha512"){prfFunc="sha512"}else{throwError("prf",prf)}const count=parseInt(searchPath(data,"crypto/kdfparams/c"));const dkLen=parseInt(searchPath(data,"crypto/kdfparams/dklen"));if(dkLen!==32){throwError("dklen",dkLen)}return pbkdf2Func(passwordBytes,salt,count,dkLen,prfFunc)}}return logger$o.throwArgumentError("unsupported key-derivation function","kdf",kdf)}function decryptSync(json,password){const data=JSON.parse(json);const key=_computeKdfKey(data,password,pbkdf2Sync,scrypt.syncScrypt);return _getAccount(data,key)}function decrypt$1(json,password,progressCallback){return __awaiter$4(this,void 0,void 0,function*(){const data=JSON.parse(json);const key=yield _computeKdfKey(data,password,pbkdf2$1,scrypt.scrypt,progressCallback);return _getAccount(data,key)})}function encrypt(account,password,options,progressCallback){try{if(getAddress(account.address)!==computeAddress(account.privateKey)){throw new Error("address/privateKey mismatch")}if(hasMnemonic(account)){const mnemonic=account.mnemonic;const node=HDNode.fromMnemonic(mnemonic.phrase,null,mnemonic.locale).derivePath(mnemonic.path||defaultPath);if(node.privateKey!=account.privateKey){throw new Error("mnemonic mismatch")}}}catch(e){return Promise.reject(e)}if(typeof options==="function"&&!progressCallback){progressCallback=options;options={}}if(!options){options={}}const privateKey=arrayify(account.privateKey);const passwordBytes=getPassword(password);let entropy=null;let path=null;let locale=null;if(hasMnemonic(account)){const srcMnemonic=account.mnemonic;entropy=arrayify(mnemonicToEntropy(srcMnemonic.phrase,srcMnemonic.locale||"en"));path=srcMnemonic.path||defaultPath;locale=srcMnemonic.locale||"en"}let client=options.client;if(!client){client="ethers.js"}let salt=null;if(options.salt){salt=arrayify(options.salt)}else{salt=randomBytes(32)}let iv=null;if(options.iv){iv=arrayify(options.iv);if(iv.length!==16){throw new Error("invalid iv")}}else{iv=randomBytes(16)}let uuidRandom=null;if(options.uuid){uuidRandom=arrayify(options.uuid);if(uuidRandom.length!==16){throw new Error("invalid uuid")}}else{uuidRandom=randomBytes(16)}let N=1<<17,r=8,p=1;if(options.scrypt){if(options.scrypt.N){N=options.scrypt.N}if(options.scrypt.r){r=options.scrypt.r}if(options.scrypt.p){p=options.scrypt.p}}return scrypt.scrypt(passwordBytes,salt,N,r,p,64,progressCallback).then(key=>{key=arrayify(key);const derivedKey=key.slice(0,16);const macPrefix=key.slice(16,32);const mnemonicKey=key.slice(32,64);const counter=new aesJs.Counter(iv);const aesCtr=new aesJs.ModeOfOperation.ctr(derivedKey,counter);const ciphertext=arrayify(aesCtr.encrypt(privateKey));const mac=keccak256(concat([macPrefix,ciphertext]));const data={address:account.address.substring(2).toLowerCase(),id:uuidV4(uuidRandom),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:hexlify(iv).substring(2)},ciphertext:hexlify(ciphertext).substring(2),kdf:"scrypt",kdfparams:{salt:hexlify(salt).substring(2),n:N,dklen:32,p:p,r:r},mac:mac.substring(2)}};if(entropy){const mnemonicIv=randomBytes(16);const mnemonicCounter=new aesJs.Counter(mnemonicIv);const mnemonicAesCtr=new aesJs.ModeOfOperation.ctr(mnemonicKey,mnemonicCounter);const mnemonicCiphertext=arrayify(mnemonicAesCtr.encrypt(entropy));const now=new Date;const timestamp=now.getUTCFullYear()+"-"+zpad(now.getUTCMonth()+1,2)+"-"+zpad(now.getUTCDate(),2)+"T"+zpad(now.getUTCHours(),2)+"-"+zpad(now.getUTCMinutes(),2)+"-"+zpad(now.getUTCSeconds(),2)+".0Z";data["x-ethers"]={client:client,gethFilename:"UTC--"+timestamp+"--"+data.address,mnemonicCounter:hexlify(mnemonicIv).substring(2),mnemonicCiphertext:hexlify(mnemonicCiphertext).substring(2),path:path,locale:locale,version:"0.1"}}return JSON.stringify(data)})}"use strict";function decryptJsonWallet(json,password,progressCallback){if(isCrowdsaleWallet(json)){if(progressCallback){progressCallback(0)}const account=decrypt(json,password);if(progressCallback){progressCallback(1)}return Promise.resolve(account)}if(isKeystoreWallet(json)){return decrypt$1(json,password,progressCallback)}return Promise.reject(new Error("invalid JSON wallet"))}function decryptJsonWalletSync(json,password){if(isCrowdsaleWallet(json)){return decrypt(json,password)}if(isKeystoreWallet(json)){return decryptSync(json,password)}throw new Error("invalid JSON wallet")}const version$j="wallet/5.1.0";"use strict";var __awaiter$5=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$p=new Logger(version$j);function isAccount(value){return value!=null&&isHexString(value.privateKey,32)&&value.address!=null}function hasMnemonic$1(value){const mnemonic=value.mnemonic;return mnemonic&&mnemonic.phrase}class Wallet extends Signer{constructor(privateKey,provider){logger$p.checkNew(new.target,Wallet);super();if(isAccount(privateKey)){const signingKey=new SigningKey(privateKey.privateKey);defineReadOnly(this,"_signingKey",()=>signingKey);defineReadOnly(this,"address",computeAddress(this.publicKey));if(this.address!==getAddress(privateKey.address)){logger$p.throwArgumentError("privateKey/address mismatch","privateKey","[REDACTED]")}if(hasMnemonic$1(privateKey)){const srcMnemonic=privateKey.mnemonic;defineReadOnly(this,"_mnemonic",()=>({phrase:srcMnemonic.phrase,path:srcMnemonic.path||defaultPath,locale:srcMnemonic.locale||"en"}));const mnemonic=this.mnemonic;const node=HDNode.fromMnemonic(mnemonic.phrase,null,mnemonic.locale).derivePath(mnemonic.path);if(computeAddress(node.privateKey)!==this.address){logger$p.throwArgumentError("mnemonic/address mismatch","privateKey","[REDACTED]")}}else{defineReadOnly(this,"_mnemonic",()=>null)}}else{if(SigningKey.isSigningKey(privateKey)){if(privateKey.curve!=="secp256k1"){logger$p.throwArgumentError("unsupported curve; must be secp256k1","privateKey","[REDACTED]")}defineReadOnly(this,"_signingKey",()=>privateKey)}else{if(typeof privateKey==="string"){if(privateKey.match(/^[0-9a-f]*$/i)&&privateKey.length===64){privateKey="0x"+privateKey}}const signingKey=new SigningKey(privateKey);defineReadOnly(this,"_signingKey",()=>signingKey)}defineReadOnly(this,"_mnemonic",()=>null);defineReadOnly(this,"address",computeAddress(this.publicKey))}if(provider&&!Provider.isProvider(provider)){logger$p.throwArgumentError("invalid provider","provider",provider)}defineReadOnly(this,"provider",provider||null)}get mnemonic(){return this._mnemonic()}get privateKey(){return this._signingKey().privateKey}get publicKey(){return this._signingKey().publicKey}getAddress(){return Promise.resolve(this.address)}connect(provider){return new Wallet(this,provider)}signTransaction(transaction){return resolveProperties(transaction).then(tx=>{if(tx.from!=null){if(getAddress(tx.from)!==this.address){logger$p.throwArgumentError("transaction from address mismatch","transaction.from",transaction.from)}delete tx.from}const signature=this._signingKey().signDigest(keccak256(serialize(tx)));return serialize(tx,signature)})}signMessage(message){return __awaiter$5(this,void 0,void 0,function*(){return joinSignature(this._signingKey().signDigest(hashMessage(message)))})}_signTypedData(domain,types,value){return __awaiter$5(this,void 0,void 0,function*(){const populated=yield TypedDataEncoder.resolveNames(domain,types,value,name=>{if(this.provider==null){logger$p.throwError("cannot resolve ENS names without a provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resolveName",value:name})}return this.provider.resolveName(name)});return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain,types,populated.value)))})}encrypt(password,options,progressCallback){if(typeof options==="function"&&!progressCallback){progressCallback=options;options={}}if(progressCallback&&typeof progressCallback!=="function"){throw new Error("invalid callback")}if(!options){options={}}return encrypt(this,password,options,progressCallback)}static createRandom(options){let entropy=randomBytes(16);if(!options){options={}}if(options.extraEntropy){entropy=arrayify(hexDataSlice(keccak256(concat([entropy,options.extraEntropy])),0,16))}const mnemonic=entropyToMnemonic(entropy,options.locale);return Wallet.fromMnemonic(mnemonic,options.path,options.locale)}static fromEncryptedJson(json,password,progressCallback){return decryptJsonWallet(json,password,progressCallback).then(account=>{return new Wallet(account)})}static fromEncryptedJsonSync(json,password){return new Wallet(decryptJsonWalletSync(json,password))}static fromMnemonic(mnemonic,path,wordlist){if(!path){path=defaultPath}return new Wallet(HDNode.fromMnemonic(mnemonic,null,wordlist).derivePath(path))}}function verifyMessage(message,signature){return recoverAddress(hashMessage(message),signature)}function verifyTypedData(domain,types,value,signature){return recoverAddress(TypedDataEncoder.hash(domain,types,value),signature)}const version$k="networks/5.1.0";"use strict";const logger$q=new Logger(version$k);function isRenetworkable(value){return value&&typeof value.renetwork==="function"}function ethDefaultProvider(network){const func=function(providers,options){if(options==null){options={}}const providerList=[];if(providers.InfuraProvider){try{providerList.push(new providers.InfuraProvider(network,options.infura))}catch(error){}}if(providers.EtherscanProvider){try{providerList.push(new providers.EtherscanProvider(network,options.etherscan))}catch(error){}}if(providers.AlchemyProvider){const skip=["goerli","ropsten","rinkeby"];try{const provider=new providers.AlchemyProvider(network,options.alchemy);if(provider.network&&skip.indexOf(provider.network.name)===-1){providerList.push(provider)}}catch(error){}}if(providers.PocketProvider){const skip=["goerli","ropsten","rinkeby"];try{const provider=new providers.PocketProvider(network);if(provider.network&&skip.indexOf(provider.network.name)===-1){providerList.push(provider)}}catch(error){}}if(providers.CloudflareProvider){try{providerList.push(new providers.CloudflareProvider(network))}catch(error){}}if(providerList.length===0){return null}if(providers.FallbackProvider){let quorum=1;if(options.quorum!=null){quorum=options.quorum}else if(network==="homestead"){quorum=2}return new providers.FallbackProvider(providerList,quorum)}return providerList[0]};func.renetwork=function(network){return ethDefaultProvider(network)};return func}function etcDefaultProvider(url,network){const func=function(providers,options){if(providers.JsonRpcProvider){return new providers.JsonRpcProvider(url,network)}return null};func.renetwork=function(network){return etcDefaultProvider(url,network)};return func}const homestead={chainId:1,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"homestead",_defaultProvider:ethDefaultProvider("homestead")};const ropsten={chainId:3,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"ropsten",_defaultProvider:ethDefaultProvider("ropsten")};const classicMordor={chainId:63,name:"classicMordor",_defaultProvider:etcDefaultProvider("https://www.ethercluster.com/mordor","classicMordor")};const networks={unspecified:{chainId:0,name:"unspecified"},homestead:homestead,mainnet:homestead,morden:{chainId:2,name:"morden"},ropsten:ropsten,testnet:ropsten,rinkeby:{chainId:4,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"rinkeby",_defaultProvider:ethDefaultProvider("rinkeby")},kovan:{chainId:42,name:"kovan",_defaultProvider:ethDefaultProvider("kovan")},goerli:{chainId:5,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"goerli",_defaultProvider:ethDefaultProvider("goerli")},classic:{chainId:61,name:"classic",_defaultProvider:etcDefaultProvider("https://www.ethercluster.com/etc","classic")},classicMorden:{chainId:62,name:"classicMorden"},classicMordor:classicMordor,classicTestnet:classicMordor,classicKotti:{chainId:6,name:"classicKotti",_defaultProvider:etcDefaultProvider("https://www.ethercluster.com/kotti","classicKotti")}};function getNetwork(network){if(network==null){return null}if(typeof network==="number"){for(const name in networks){const standard=networks[name];if(standard.chainId===network){return{name:standard.name,chainId:standard.chainId,ensAddress:standard.ensAddress||null,_defaultProvider:standard._defaultProvider||null}}}return{chainId:network,name:"unknown"}}if(typeof network==="string"){const standard=networks[network];if(standard==null){return null}return{name:standard.name,chainId:standard.chainId,ensAddress:standard.ensAddress,_defaultProvider:standard._defaultProvider||null}}const standard=networks[network.name];if(!standard){if(typeof network.chainId!=="number"){logger$q.throwArgumentError("invalid network chainId","network",network)}return network}if(network.chainId!==0&&network.chainId!==standard.chainId){logger$q.throwArgumentError("network chainId mismatch","network",network)}let defaultProvider=network._defaultProvider||null;if(defaultProvider==null&&standard._defaultProvider){if(isRenetworkable(standard._defaultProvider)){defaultProvider=standard._defaultProvider.renetwork(network)}else{defaultProvider=standard._defaultProvider}}return{name:network.name,chainId:standard.chainId,ensAddress:network.ensAddress||standard.ensAddress||null,_defaultProvider:defaultProvider}}"use strict";function decode$1(textData){textData=atob(textData);const data=[];for(let i=0;i<textData.length;i++){data.push(textData.charCodeAt(i))}return arrayify(data)}function encode$1(data){data=arrayify(data);let textData="";for(let i=0;i<data.length;i++){textData+=String.fromCharCode(data[i])}return btoa(textData)}"use strict";var index$2=Object.freeze({__proto__:null,decode:decode$1,encode:encode$1});const version$l="web/5.1.0";"use strict";var __awaiter$6=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};function getUrl(href,options){return __awaiter$6(this,void 0,void 0,function*(){if(options==null){options={}}const request={method:options.method||"GET",headers:options.headers||{},body:options.body||undefined,mode:"cors",cache:"no-cache",credentials:"same-origin",redirect:"follow",referrer:"client"};const response=yield fetch(href,request);const body=yield response.arrayBuffer();const headers={};if(response.headers.forEach){response.headers.forEach((value,key)=>{headers[key.toLowerCase()]=value})}else{response.headers.keys().forEach(key=>{headers[key.toLowerCase()]=response.headers.get(key)})}return{headers:headers,statusCode:response.status,statusMessage:response.statusText,body:arrayify(new Uint8Array(body))}})}"use strict";var __awaiter$7=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$r=new Logger(version$l);function staller(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}function bodyify(value,type){if(value==null){return null}if(typeof value==="string"){return value}if(isBytesLike(value)){if(type&&(type.split("/")[0]==="text"||type.split(";")[0].trim()==="application/json")){try{return toUtf8String(value)}catch(error){}}return hexlify(value)}return value}function _fetchData(connection,body,processFunc){const attemptLimit=typeof connection==="object"&&connection.throttleLimit!=null?connection.throttleLimit:12;logger$r.assertArgument(attemptLimit>0&&attemptLimit%1===0,"invalid connection throttle limit","connection.throttleLimit",attemptLimit);const throttleCallback=typeof connection==="object"?connection.throttleCallback:null;const throttleSlotInterval=typeof connection==="object"&&typeof connection.throttleSlotInterval==="number"?connection.throttleSlotInterval:100;logger$r.assertArgument(throttleSlotInterval>0&&throttleSlotInterval%1===0,"invalid connection throttle slot interval","connection.throttleSlotInterval",throttleSlotInterval);const headers={};let url=null;const options={method:"GET"};let allow304=false;let timeout=2*60*1e3;if(typeof connection==="string"){url=connection}else if(typeof connection==="object"){if(connection==null||connection.url==null){logger$r.throwArgumentError("missing URL","connection.url",connection)}url=connection.url;if(typeof connection.timeout==="number"&&connection.timeout>0){timeout=connection.timeout}if(connection.headers){for(const key in connection.headers){headers[key.toLowerCase()]={key:key,value:String(connection.headers[key])};if(["if-none-match","if-modified-since"].indexOf(key.toLowerCase())>=0){allow304=true}}}options.allowGzip=!!connection.allowGzip;if(connection.user!=null&&connection.password!=null){if(url.substring(0,6)!=="https:"&&connection.allowInsecureAuthentication!==true){logger$r.throwError("basic authentication requires a secure https url",Logger.errors.INVALID_ARGUMENT,{argument:"url",url:url,user:connection.user,password:"[REDACTED]"})}const authorization=connection.user+":"+connection.password;headers["authorization"]={key:"Authorization",value:"Basic "+encode$1(toUtf8Bytes(authorization))}}}if(body){options.method="POST";options.body=body;if(headers["content-type"]==null){headers["content-type"]={key:"Content-Type",value:"application/octet-stream"}}if(headers["content-length"]==null){headers["content-length"]={key:"Content-Length",value:String(body.length)}}}const flatHeaders={};Object.keys(headers).forEach(key=>{const header=headers[key];flatHeaders[header.key]=header.value});options.headers=flatHeaders;const runningTimeout=function(){let timer=null;const promise=new Promise(function(resolve,reject){if(timeout){timer=setTimeout(()=>{if(timer==null){return}timer=null;reject(logger$r.makeError("timeout",Logger.errors.TIMEOUT,{requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,timeout:timeout,url:url}))},timeout)}});const cancel=function(){if(timer==null){return}clearTimeout(timer);timer=null};return{promise:promise,cancel:cancel}}();const runningFetch=function(){return __awaiter$7(this,void 0,void 0,function*(){for(let attempt=0;attempt<attemptLimit;attempt++){let response=null;try{response=yield getUrl(url,options);if(response.statusCode===429&&attempt<attemptLimit){let tryAgain=true;if(throttleCallback){tryAgain=yield throttleCallback(attempt,url)}if(tryAgain){let stall=0;const retryAfter=response.headers["retry-after"];if(typeof retryAfter==="string"&&retryAfter.match(/^[1-9][0-9]*$/)){stall=parseInt(retryAfter)*1e3}else{stall=throttleSlotInterval*parseInt(String(Math.random()*Math.pow(2,attempt)))}yield staller(stall);continue}}}catch(error){response=error.response;if(response==null){runningTimeout.cancel();logger$r.throwError("missing response",Logger.errors.SERVER_ERROR,{requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,serverError:error,url:url})}}let body=response.body;if(allow304&&response.statusCode===304){body=null}else if(response.statusCode<200||response.statusCode>=300){runningTimeout.cancel();logger$r.throwError("bad response",Logger.errors.SERVER_ERROR,{status:response.statusCode,headers:response.headers,body:bodyify(body,response.headers?response.headers["content-type"]:null),requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,url:url})}if(processFunc){try{const result=yield processFunc(body,response);runningTimeout.cancel();return result}catch(error){if(error.throttleRetry&&attempt<attemptLimit){let tryAgain=true;if(throttleCallback){tryAgain=yield throttleCallback(attempt,url)}if(tryAgain){const timeout=throttleSlotInterval*parseInt(String(Math.random()*Math.pow(2,attempt)));yield staller(timeout);continue}}runningTimeout.cancel();logger$r.throwError("processing response error",Logger.errors.SERVER_ERROR,{body:bodyify(body,response.headers?response.headers["content-type"]:null),error:error,requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,url:url})}}runningTimeout.cancel();return body}return logger$r.throwError("failed response",Logger.errors.SERVER_ERROR,{requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,url:url})})}();return Promise.race([runningTimeout.promise,runningFetch])}function fetchJson(connection,json,processFunc){let processJsonFunc=(value,response)=>{let result=null;if(value!=null){try{result=JSON.parse(toUtf8String(value))}catch(error){logger$r.throwError("invalid JSON",Logger.errors.SERVER_ERROR,{body:value,error:error})}}if(processFunc){result=processFunc(result,response)}return result};let body=null;if(json!=null){body=toUtf8Bytes(json);const updated=typeof connection==="string"?{url:connection}:shallowCopy(connection);if(updated.headers){const hasContentType=Object.keys(updated.headers).filter(k=>k.toLowerCase()==="content-type").length!==0;if(!hasContentType){updated.headers=shallowCopy(updated.headers);updated.headers["content-type"]="application/json"}}else{updated.headers={"content-type":"application/json"}}connection=updated}return _fetchData(connection,body,processJsonFunc)}function poll(func,options){if(!options){options={}}options=shallowCopy(options);if(options.floor==null){options.floor=0}if(options.ceiling==null){options.ceiling=1e4}if(options.interval==null){options.interval=250}return new Promise(function(resolve,reject){let timer=null;let done=false;const cancel=()=>{if(done){return false}done=true;if(timer){clearTimeout(timer)}return true};if(options.timeout){timer=setTimeout(()=>{if(cancel()){reject(new Error("timeout"))}},options.timeout)}const retryLimit=options.retryLimit;let attempt=0;function check(){return func().then(function(result){if(result!==undefined){if(cancel()){resolve(result)}}else if(options.oncePoll){options.oncePoll.once("poll",check)}else if(options.onceBlock){options.onceBlock.once("block",check)}else if(!done){attempt++;if(attempt>retryLimit){if(cancel()){reject(new Error("retry limit reached"))}return}let timeout=options.interval*parseInt(String(Math.random()*Math.pow(2,attempt)));if(timeout<options.floor){timeout=options.floor}if(timeout>options.ceiling){timeout=options.ceiling}setTimeout(check,timeout)}return null},function(error){if(cancel()){reject(error)}})}check()})}"use strict";var ALPHABET="qpzry9x8gf2tvdw0s3jn54khce6mua7l";var ALPHABET_MAP={};for(var z=0;z<ALPHABET.length;z++){var x=ALPHABET.charAt(z);if(ALPHABET_MAP[x]!==undefined)throw new TypeError(x+" is ambiguous");ALPHABET_MAP[x]=z}function polymodStep(pre){var b=pre>>25;return(pre&33554431)<<5^-(b>>0&1)&996825010^-(b>>1&1)&642813549^-(b>>2&1)&513874426^-(b>>3&1)&1027748829^-(b>>4&1)&705979059}function prefixChk(prefix){var chk=1;for(var i=0;i<prefix.length;++i){var c=prefix.charCodeAt(i);if(c<33||c>126)return"Invalid prefix ("+prefix+")";chk=polymodStep(chk)^c>>5}chk=polymodStep(chk);for(i=0;i<prefix.length;++i){var v=prefix.charCodeAt(i);chk=polymodStep(chk)^v&31}return chk}function encode$2(prefix,words,LIMIT){LIMIT=LIMIT||90;if(prefix.length+7+words.length>LIMIT)throw new TypeError("Exceeds length limit");prefix=prefix.toLowerCase();var chk=prefixChk(prefix);if(typeof chk==="string")throw new Error(chk);var result=prefix+"1";for(var i=0;i<words.length;++i){var x=words[i];if(x>>5!==0)throw new Error("Non 5-bit word");chk=polymodStep(chk)^x;result+=ALPHABET.charAt(x)}for(i=0;i<6;++i){chk=polymodStep(chk)}chk^=1;for(i=0;i<6;++i){var v=chk>>(5-i)*5&31;result+=ALPHABET.charAt(v)}return result}function __decode(str,LIMIT){LIMIT=LIMIT||90;if(str.length<8)return str+" too short";if(str.length>LIMIT)return"Exceeds length limit";var lowered=str.toLowerCase();var uppered=str.toUpperCase();if(str!==lowered&&str!==uppered)return"Mixed-case string "+str;str=lowered;var split=str.lastIndexOf("1");if(split===-1)return"No separator character for "+str;if(split===0)return"Missing prefix for "+str;var prefix=str.slice(0,split);var wordChars=str.slice(split+1);if(wordChars.length<6)return"Data too short";var chk=prefixChk(prefix);if(typeof chk==="string")return chk;var words=[];for(var i=0;i<wordChars.length;++i){var c=wordChars.charAt(i);var v=ALPHABET_MAP[c];if(v===undefined)return"Unknown character "+c;chk=polymodStep(chk)^v;if(i+6>=wordChars.length)continue;words.push(v)}if(chk!==1)return"Invalid checksum for "+str;return{prefix:prefix,words:words}}function decodeUnsafe(){var res=__decode.apply(null,arguments);if(typeof res==="object")return res}function decode$2(str){var res=__decode.apply(null,arguments);if(typeof res==="object")return res;throw new Error(res)}function convert(data,inBits,outBits,pad){var value=0;var bits=0;var maxV=(1<<outBits)-1;var result=[];for(var i=0;i<data.length;++i){value=value<<inBits|data[i];bits+=inBits;while(bits>=outBits){bits-=outBits;result.push(value>>bits&maxV)}}if(pad){if(bits>0){result.push(value<<outBits-bits&maxV)}}else{if(bits>=inBits)return"Excess padding";if(value<<outBits-bits&maxV)return"Non-zero padding"}return result}function toWordsUnsafe(bytes){var res=convert(bytes,8,5,true);if(Array.isArray(res))return res}function toWords(bytes){var res=convert(bytes,8,5,true);if(Array.isArray(res))return res;throw new Error(res)}function fromWordsUnsafe(words){var res=convert(words,5,8,false);if(Array.isArray(res))return res}function fromWords(words){var res=convert(words,5,8,false);if(Array.isArray(res))return res;throw new Error(res)}var bech32={decodeUnsafe:decodeUnsafe,decode:decode$2,encode:encode$2,toWordsUnsafe:toWordsUnsafe,toWords:toWords,fromWordsUnsafe:fromWordsUnsafe,fromWords:fromWords};const version$m="providers/5.1.2";"use strict";const logger$s=new Logger(version$m);class Formatter{constructor(){logger$s.checkNew(new.target,Formatter);this.formats=this.getDefaultFormats()}getDefaultFormats(){const formats={};const address=this.address.bind(this);const bigNumber=this.bigNumber.bind(this);const blockTag=this.blockTag.bind(this);const data=this.data.bind(this);const hash=this.hash.bind(this);const hex=this.hex.bind(this);const number=this.number.bind(this);const strictData=v=>{return this.data(v,true)};formats.transaction={hash:hash,type:Formatter.allowNull(number,null),accessList:Formatter.allowNull(this.accessList.bind(this),null),blockHash:Formatter.allowNull(hash,null),blockNumber:Formatter.allowNull(number,null),transactionIndex:Formatter.allowNull(number,null),confirmations:Formatter.allowNull(number,null),from:address,gasPrice:bigNumber,gasLimit:bigNumber,to:Formatter.allowNull(address,null),value:bigNumber,nonce:number,data:data,r:Formatter.allowNull(this.uint256),s:Formatter.allowNull(this.uint256),v:Formatter.allowNull(number),creates:Formatter.allowNull(address,null),raw:Formatter.allowNull(data)};formats.transactionRequest={from:Formatter.allowNull(address),nonce:Formatter.allowNull(number),gasLimit:Formatter.allowNull(bigNumber),gasPrice:Formatter.allowNull(bigNumber),to:Formatter.allowNull(address),value:Formatter.allowNull(bigNumber),data:Formatter.allowNull(strictData),type:Formatter.allowNull(number),accessList:Formatter.allowNull(this.accessList.bind(this),null)};formats.receiptLog={transactionIndex:number,blockNumber:number,transactionHash:hash,address:address,topics:Formatter.arrayOf(hash),data:data,logIndex:number,blockHash:hash};formats.receipt={to:Formatter.allowNull(this.address,null),from:Formatter.allowNull(this.address,null),contractAddress:Formatter.allowNull(address,null),transactionIndex:number,root:Formatter.allowNull(hex),gasUsed:bigNumber,logsBloom:Formatter.allowNull(data),blockHash:hash,transactionHash:hash,logs:Formatter.arrayOf(this.receiptLog.bind(this)),blockNumber:number,confirmations:Formatter.allowNull(number,null),cumulativeGasUsed:bigNumber,status:Formatter.allowNull(number)};formats.block={hash:hash,parentHash:hash,number:number,timestamp:number,nonce:Formatter.allowNull(hex),difficulty:this.difficulty.bind(this),gasLimit:bigNumber,gasUsed:bigNumber,miner:address,extraData:data,transactions:Formatter.allowNull(Formatter.arrayOf(hash))};formats.blockWithTransactions=shallowCopy(formats.block);formats.blockWithTransactions.transactions=Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));formats.filter={fromBlock:Formatter.allowNull(blockTag,undefined),toBlock:Formatter.allowNull(blockTag,undefined),blockHash:Formatter.allowNull(hash,undefined),address:Formatter.allowNull(address,undefined),topics:Formatter.allowNull(this.topics.bind(this),undefined)};formats.filterLog={blockNumber:Formatter.allowNull(number),blockHash:Formatter.allowNull(hash),transactionIndex:number,removed:Formatter.allowNull(this.boolean.bind(this)),address:address,data:Formatter.allowFalsish(data,"0x"),topics:Formatter.arrayOf(hash),transactionHash:hash,logIndex:number};return formats}accessList(accessList){return accessListify(accessList||[])}number(number){if(number==="0x"){return 0}return BigNumber.from(number).toNumber()}bigNumber(value){return BigNumber.from(value)}boolean(value){if(typeof value==="boolean"){return value}if(typeof value==="string"){value=value.toLowerCase();if(value==="true"){return true}if(value==="false"){return false}}throw new Error("invalid boolean - "+value)}hex(value,strict){if(typeof value==="string"){if(!strict&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexString(value)){return value.toLowerCase()}}return logger$s.throwArgumentError("invalid hash","value",value)}data(value,strict){const result=this.hex(value,strict);if(result.length%2!==0){throw new Error("invalid data; odd-length - "+value)}return result}address(value){return getAddress(value)}callAddress(value){if(!isHexString(value,32)){return null}const address=getAddress(hexDataSlice(value,12));return address===AddressZero?null:address}contractAddress(value){return getContractAddress(value)}blockTag(blockTag){if(blockTag==null){return"latest"}if(blockTag==="earliest"){return"0x0"}if(blockTag==="latest"||blockTag==="pending"){return blockTag}if(typeof blockTag==="number"||isHexString(blockTag)){return hexValue(blockTag)}throw new Error("invalid blockTag")}hash(value,strict){const result=this.hex(value,strict);if(hexDataLength(result)!==32){return logger$s.throwArgumentError("invalid hash","value",value)}return result}difficulty(value){if(value==null){return null}const v=BigNumber.from(value);try{return v.toNumber()}catch(error){}return null}uint256(value){if(!isHexString(value)){throw new Error("invalid uint256")}return hexZeroPad(value,32)}_block(value,format){if(value.author!=null&&value.miner==null){value.miner=value.author}return Formatter.check(format,value)}block(value){return this._block(value,this.formats.block)}blockWithTransactions(value){return this._block(value,this.formats.blockWithTransactions)}transactionRequest(value){return Formatter.check(this.formats.transactionRequest,value)}transactionResponse(transaction){if(transaction.gas!=null&&transaction.gasLimit==null){transaction.gasLimit=transaction.gas}if(transaction.to&&BigNumber.from(transaction.to).isZero()){transaction.to="0x0000000000000000000000000000000000000000"}if(transaction.input!=null&&transaction.data==null){transaction.data=transaction.input}if(transaction.to==null&&transaction.creates==null){transaction.creates=this.contractAddress(transaction)}if(transaction.type===1&&transaction.accessList==null){transaction.accessList=[]}const result=Formatter.check(this.formats.transaction,transaction);if(transaction.chainId!=null){let chainId=transaction.chainId;if(isHexString(chainId)){chainId=BigNumber.from(chainId).toNumber()}result.chainId=chainId}else{let chainId=transaction.networkId;if(chainId==null&&result.v==null){chainId=transaction.chainId}if(isHexString(chainId)){chainId=BigNumber.from(chainId).toNumber()}if(typeof chainId!=="number"&&result.v!=null){chainId=(result.v-35)/2;if(chainId<0){chainId=0}chainId=parseInt(chainId)}if(typeof chainId!=="number"){chainId=0}result.chainId=chainId}if(result.blockHash&&result.blockHash.replace(/0/g,"")==="x"){result.blockHash=null}return result}transaction(value){return parse(value)}receiptLog(value){return Formatter.check(this.formats.receiptLog,value)}receipt(value){const result=Formatter.check(this.formats.receipt,value);if(result.root!=null){if(result.root.length<=4){const value=BigNumber.from(result.root).toNumber();if(value===0||value===1){if(result.status!=null&&result.status!==value){logger$s.throwArgumentError("alt-root-status/status mismatch","value",{root:result.root,status:result.status})}result.status=value;delete result.root}else{logger$s.throwArgumentError("invalid alt-root-status","value.root",result.root)}}else if(result.root.length!==66){logger$s.throwArgumentError("invalid root hash","value.root",result.root)}}if(result.status!=null){result.byzantium=true}return result}topics(value){if(Array.isArray(value)){return value.map(v=>this.topics(v))}else if(value!=null){return this.hash(value,true)}return null}filter(value){return Formatter.check(this.formats.filter,value)}filterLog(value){return Formatter.check(this.formats.filterLog,value)}static check(format,object){const result={};for(const key in format){try{const value=format[key](object[key]);if(value!==undefined){result[key]=value}}catch(error){error.checkKey=key;error.checkValue=object[key];throw error}}return result}static allowNull(format,nullValue){return function(value){if(value==null){return nullValue}return format(value)}}static allowFalsish(format,replaceValue){return function(value){if(!value){return replaceValue}return format(value)}}static arrayOf(format){return function(array){if(!Array.isArray(array)){throw new Error("not an array")}const result=[];array.forEach(function(value){result.push(format(value))});return result}}}function isCommunityResourcable(value){return value&&typeof value.isCommunityResource==="function"}function isCommunityResource(value){return isCommunityResourcable(value)&&value.isCommunityResource()}let throttleMessage=false;function showThrottleMessage(){if(throttleMessage){return}throttleMessage=true;console.log("========= NOTICE =========");console.log("Request-Rate Exceeded  (this message will not be repeated)");console.log("");console.log("The default API keys for each service are provided as a highly-throttled,");console.log("community resource for low-traffic projects and early prototyping.");console.log("");console.log("While your application will continue to function, we highly recommended");console.log("signing up for your own API keys to improve performance, increase your");console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");console.log("");console.log("For more details: https://docs.ethers.io/api-keys/");console.log("==========================")}"use strict";var __awaiter$8=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$t=new Logger(version$m);function checkTopic(topic){if(topic==null){return"null"}if(hexDataLength(topic)!==32){logger$t.throwArgumentError("invalid topic","topic",topic)}return topic.toLowerCase()}function serializeTopics(topics){topics=topics.slice();while(topics.length>0&&topics[topics.length-1]==null){topics.pop()}return topics.map(topic=>{if(Array.isArray(topic)){const unique={};topic.forEach(topic=>{unique[checkTopic(topic)]=true});const sorted=Object.keys(unique);sorted.sort();return sorted.join("|")}else{return checkTopic(topic)}}).join("&")}function deserializeTopics(data){if(data===""){return[]}return data.split(/&/g).map(topic=>{if(topic===""){return[]}const comps=topic.split("|").map(topic=>{return topic==="null"?null:topic});return comps.length===1?comps[0]:comps})}function getEventTag$1(eventName){if(typeof eventName==="string"){eventName=eventName.toLowerCase();if(hexDataLength(eventName)===32){return"tx:"+eventName}if(eventName.indexOf(":")===-1){return eventName}}else if(Array.isArray(eventName)){return"filter:*:"+serializeTopics(eventName)}else if(ForkEvent.isForkEvent(eventName)){logger$t.warn("not implemented");throw new Error("not implemented")}else if(eventName&&typeof eventName==="object"){return"filter:"+(eventName.address||"*")+":"+serializeTopics(eventName.topics||[])}throw new Error("invalid event - "+eventName)}function getTime(){return(new Date).getTime()}function stall(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}const PollableEvents=["block","network","pending","poll"];class Event{constructor(tag,listener,once){defineReadOnly(this,"tag",tag);defineReadOnly(this,"listener",listener);defineReadOnly(this,"once",once)}get event(){switch(this.type){case"tx":return this.hash;case"filter":return this.filter}return this.tag}get type(){return this.tag.split(":")[0]}get hash(){const comps=this.tag.split(":");if(comps[0]!=="tx"){return null}return comps[1]}get filter(){const comps=this.tag.split(":");if(comps[0]!=="filter"){return null}const address=comps[1];const topics=deserializeTopics(comps[2]);const filter={};if(topics.length>0){filter.topics=topics}if(address&&address!=="*"){filter.address=address}return filter}pollable(){return this.tag.indexOf(":")>=0||PollableEvents.indexOf(this.tag)>=0}}const coinInfos={0:{symbol:"btc",p2pkh:0,p2sh:5,prefix:"bc"},2:{symbol:"ltc",p2pkh:48,p2sh:50,prefix:"ltc"},3:{symbol:"doge",p2pkh:30,p2sh:22},60:{symbol:"eth",ilk:"eth"},61:{symbol:"etc",ilk:"eth"},700:{symbol:"xdai",ilk:"eth"}};function bytes32ify(value){return hexZeroPad(BigNumber.from(value).toHexString(),32)}function base58Encode(data){return Base58.encode(concat([data,hexDataSlice(sha256$1(sha256$1(data)),0,4)]))}class Resolver{constructor(provider,address,name){defineReadOnly(this,"provider",provider);defineReadOnly(this,"name",name);defineReadOnly(this,"address",provider.formatter.address(address))}_fetchBytes(selector,parameters){return __awaiter$8(this,void 0,void 0,function*(){const transaction={to:this.address,data:hexConcat([selector,namehash(this.name),parameters||"0x"])};const result=yield this.provider.call(transaction);if(result==="0x"){return null}const offset=BigNumber.from(hexDataSlice(result,0,32)).toNumber();const length=BigNumber.from(hexDataSlice(result,offset,offset+32)).toNumber();return hexDataSlice(result,offset+32,offset+32+length)})}_getAddress(coinType,hexBytes){const coinInfo=coinInfos[String(coinType)];if(coinInfo==null){logger$t.throwError(`unsupported coin type: ${coinType}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:`getAddress(${coinType})`})}if(coinInfo.ilk==="eth"){return this.provider.formatter.address(hexBytes)}const bytes=arrayify(hexBytes);if(coinInfo.p2pkh!=null){const p2pkh=hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);if(p2pkh){const length=parseInt(p2pkh[1],16);if(p2pkh[2].length===length*2&&length>=1&&length<=75){return base58Encode(concat([[coinInfo.p2pkh],"0x"+p2pkh[2]]))}}}if(coinInfo.p2sh!=null){const p2sh=hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);if(p2sh){const length=parseInt(p2sh[1],16);if(p2sh[2].length===length*2&&length>=1&&length<=75){return base58Encode(concat([[coinInfo.p2sh],"0x"+p2sh[2]]))}}}if(coinInfo.prefix!=null){const length=bytes[1];let version=bytes[0];if(version===0){if(length!==20&&length!==32){version=-1}}else{version=-1}if(version>=0&&bytes.length===2+length&&length>=1&&length<=75){const words=bech32.toWords(bytes.slice(2));words.unshift(version);return bech32.encode(coinInfo.prefix,words)}}return null}getAddress(coinType){return __awaiter$8(this,void 0,void 0,function*(){if(coinType==null){coinType=60}if(coinType===60){const transaction={to:this.address,data:"0x3b3b57de"+namehash(this.name).substring(2)};const hexBytes=yield this.provider.call(transaction);if(hexBytes==="0x"||hexBytes===HashZero){return null}return this.provider.formatter.callAddress(hexBytes)}const hexBytes=yield this._fetchBytes("0xf1cb7e06",bytes32ify(coinType));if(hexBytes==null||hexBytes==="0x"){return null}const address=this._getAddress(coinType,hexBytes);if(address==null){logger$t.throwError(`invalid or unsupported coin data`,Logger.errors.UNSUPPORTED_OPERATION,{operation:`getAddress(${coinType})`,coinType:coinType,data:hexBytes})}return address})}getContentHash(){return __awaiter$8(this,void 0,void 0,function*(){const hexBytes=yield this._fetchBytes("0xbc1c58d1");if(hexBytes==null||hexBytes==="0x"){return null}const ipfs=hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);if(ipfs){const length=parseInt(ipfs[3],16);if(ipfs[4].length===length*2){return"ipfs://"+Base58.encode("0x"+ipfs[1])}}const swarm=hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);if(swarm){if(swarm[1].length===32*2){return"bzz://"+swarm[1]}}return logger$t.throwError(`invalid or unsupported content hash data`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"getContentHash()",data:hexBytes})})}getText(key){return __awaiter$8(this,void 0,void 0,function*(){let keyBytes=toUtf8Bytes(key);keyBytes=concat([bytes32ify(64),bytes32ify(keyBytes.length),keyBytes]);if(keyBytes.length%32!==0){keyBytes=concat([keyBytes,hexZeroPad("0x",32-key.length%32)])}const hexBytes=yield this._fetchBytes("0x59d1d43c",hexlify(keyBytes));if(hexBytes==null||hexBytes==="0x"){return null}return toUtf8String(hexBytes)})}}let defaultFormatter=null;let nextPollId=1;class BaseProvider extends Provider{constructor(network){logger$t.checkNew(new.target,Provider);super();this._events=[];this._emitted={block:-2};this.formatter=new.target.getFormatter();defineReadOnly(this,"anyNetwork",network==="any");if(this.anyNetwork){network=this.detectNetwork()}if(network instanceof Promise){this._networkPromise=network;network.catch(error=>{});this._ready().catch(error=>{})}else{const knownNetwork=getStatic(new.target,"getNetwork")(network);if(knownNetwork){defineReadOnly(this,"_network",knownNetwork);this.emit("network",knownNetwork,null)}else{logger$t.throwArgumentError("invalid network","network",network)}}this._maxInternalBlockNumber=-1024;this._lastBlockNumber=-2;this._pollingInterval=4e3;this._fastQueryDate=0}_ready(){return __awaiter$8(this,void 0,void 0,function*(){if(this._network==null){let network=null;if(this._networkPromise){try{network=yield this._networkPromise}catch(error){}}if(network==null){network=yield this.detectNetwork()}if(!network){logger$t.throwError("no network detected",Logger.errors.UNKNOWN_ERROR,{})}if(this._network==null){if(this.anyNetwork){this._network=network}else{defineReadOnly(this,"_network",network)}this.emit("network",network,null)}}return this._network})}get ready(){return poll(()=>{return this._ready().then(network=>{return network},error=>{if(error.code===Logger.errors.NETWORK_ERROR&&error.event==="noNetwork"){return undefined}throw error})})}static getFormatter(){if(defaultFormatter==null){defaultFormatter=new Formatter}return defaultFormatter}static getNetwork(network){return getNetwork(network==null?"homestead":network)}_getInternalBlockNumber(maxAge){return __awaiter$8(this,void 0,void 0,function*(){yield this._ready();if(maxAge>0){while(this._internalBlockNumber){const internalBlockNumber=this._internalBlockNumber;try{const result=yield internalBlockNumber;if(getTime()-result.respTime<=maxAge){return result.blockNumber}break}catch(error){if(this._internalBlockNumber===internalBlockNumber){break}}}}const reqTime=getTime();const checkInternalBlockNumber=resolveProperties({blockNumber:this.perform("getBlockNumber",{}),networkError:this.getNetwork().then(network=>null,error=>error)}).then(({blockNumber:blockNumber,networkError:networkError})=>{if(networkError){if(this._internalBlockNumber===checkInternalBlockNumber){this._internalBlockNumber=null}throw networkError}const respTime=getTime();blockNumber=BigNumber.from(blockNumber).toNumber();if(blockNumber<this._maxInternalBlockNumber){blockNumber=this._maxInternalBlockNumber}this._maxInternalBlockNumber=blockNumber;this._setFastBlockNumber(blockNumber);return{blockNumber:blockNumber,reqTime:reqTime,respTime:respTime}});this._internalBlockNumber=checkInternalBlockNumber;checkInternalBlockNumber.catch(error=>{if(this._internalBlockNumber===checkInternalBlockNumber){this._internalBlockNumber=null}});return(yield checkInternalBlockNumber).blockNumber})}poll(){return __awaiter$8(this,void 0,void 0,function*(){const pollId=nextPollId++;const runners=[];let blockNumber=null;try{blockNumber=yield this._getInternalBlockNumber(100+this.pollingInterval/2)}catch(error){this.emit("error",error);return}this._setFastBlockNumber(blockNumber);this.emit("poll",pollId,blockNumber);if(blockNumber===this._lastBlockNumber){this.emit("didPoll",pollId);return}if(this._emitted.block===-2){this._emitted.block=blockNumber-1}if(Math.abs(this._emitted.block-blockNumber)>1e3){logger$t.warn("network block skew detected; skipping block events");this.emit("error",logger$t.makeError("network block skew detected",Logger.errors.NETWORK_ERROR,{blockNumber:blockNumber,event:"blockSkew",previousBlockNumber:this._emitted.block}));this.emit("block",blockNumber)}else{for(let i=this._emitted.block+1;i<=blockNumber;i++){this.emit("block",i)}}if(this._emitted.block!==blockNumber){this._emitted.block=blockNumber;Object.keys(this._emitted).forEach(key=>{if(key==="block"){return}const eventBlockNumber=this._emitted[key];if(eventBlockNumber==="pending"){return}if(blockNumber-eventBlockNumber>12){delete this._emitted[key]}})}if(this._lastBlockNumber===-2){this._lastBlockNumber=blockNumber-1}this._events.forEach(event=>{switch(event.type){case"tx":{const hash=event.hash;let runner=this.getTransactionReceipt(hash).then(receipt=>{if(!receipt||receipt.blockNumber==null){return null}this._emitted["t:"+hash]=receipt.blockNumber;this.emit(hash,receipt);return null}).catch(error=>{this.emit("error",error)});runners.push(runner);break}case"filter":{const filter=event.filter;filter.fromBlock=this._lastBlockNumber+1;filter.toBlock=blockNumber;const runner=this.getLogs(filter).then(logs=>{if(logs.length===0){return}logs.forEach(log=>{this._emitted["b:"+log.blockHash]=log.blockNumber;this._emitted["t:"+log.transactionHash]=log.blockNumber;this.emit(filter,log)})}).catch(error=>{this.emit("error",error)});runners.push(runner);break}}});this._lastBlockNumber=blockNumber;Promise.all(runners).then(()=>{this.emit("didPoll",pollId)}).catch(error=>{this.emit("error",error)});return})}resetEventsBlock(blockNumber){this._lastBlockNumber=blockNumber-1;if(this.polling){this.poll()}}get network(){return this._network}detectNetwork(){return __awaiter$8(this,void 0,void 0,function*(){return logger$t.throwError("provider does not support network detection",Logger.errors.UNSUPPORTED_OPERATION,{operation:"provider.detectNetwork"})})}getNetwork(){return __awaiter$8(this,void 0,void 0,function*(){const network=yield this._ready();const currentNetwork=yield this.detectNetwork();if(network.chainId!==currentNetwork.chainId){if(this.anyNetwork){this._network=currentNetwork;this._lastBlockNumber=-2;this._fastBlockNumber=null;this._fastBlockNumberPromise=null;this._fastQueryDate=0;this._emitted.block=-2;this._maxInternalBlockNumber=-1024;this._internalBlockNumber=null;this.emit("network",currentNetwork,network);yield stall(0);return this._network}const error=logger$t.makeError("underlying network changed",Logger.errors.NETWORK_ERROR,{event:"changed",network:network,detectedNetwork:currentNetwork});this.emit("error",error);throw error}return network})}get blockNumber(){this._getInternalBlockNumber(100+this.pollingInterval/2).then(blockNumber=>{this._setFastBlockNumber(blockNumber)},error=>{});return this._fastBlockNumber!=null?this._fastBlockNumber:-1}get polling(){return this._poller!=null}set polling(value){if(value&&!this._poller){this._poller=setInterval(()=>{this.poll()},this.pollingInterval);if(!this._bootstrapPoll){this._bootstrapPoll=setTimeout(()=>{this.poll();this._bootstrapPoll=setTimeout(()=>{if(!this._poller){this.poll()}this._bootstrapPoll=null},this.pollingInterval)},0)}}else if(!value&&this._poller){clearInterval(this._poller);this._poller=null}}get pollingInterval(){return this._pollingInterval}set pollingInterval(value){if(typeof value!=="number"||value<=0||parseInt(String(value))!=value){throw new Error("invalid polling interval")}this._pollingInterval=value;if(this._poller){clearInterval(this._poller);this._poller=setInterval(()=>{this.poll()},this._pollingInterval)}}_getFastBlockNumber(){const now=getTime();if(now-this._fastQueryDate>2*this._pollingInterval){this._fastQueryDate=now;this._fastBlockNumberPromise=this.getBlockNumber().then(blockNumber=>{if(this._fastBlockNumber==null||blockNumber>this._fastBlockNumber){this._fastBlockNumber=blockNumber}return this._fastBlockNumber})}return this._fastBlockNumberPromise}_setFastBlockNumber(blockNumber){if(this._fastBlockNumber!=null&&blockNumber<this._fastBlockNumber){return}this._fastQueryDate=getTime();if(this._fastBlockNumber==null||blockNumber>this._fastBlockNumber){this._fastBlockNumber=blockNumber;this._fastBlockNumberPromise=Promise.resolve(blockNumber)}}waitForTransaction(transactionHash,confirmations,timeout){return __awaiter$8(this,void 0,void 0,function*(){if(confirmations==null){confirmations=1}const receipt=yield this.getTransactionReceipt(transactionHash);if((receipt?receipt.confirmations:0)>=confirmations){return receipt}return new Promise((resolve,reject)=>{let timer=null;let done=false;const handler=receipt=>{if(receipt.confirmations<confirmations){return}if(timer){clearTimeout(timer)}if(done){return}done=true;this.removeListener(transactionHash,handler);resolve(receipt)};this.on(transactionHash,handler);if(typeof timeout==="number"&&timeout>0){timer=setTimeout(()=>{if(done){return}timer=null;done=true;this.removeListener(transactionHash,handler);reject(logger$t.makeError("timeout exceeded",Logger.errors.TIMEOUT,{timeout:timeout}))},timeout);if(timer.unref){timer.unref()}}})})}getBlockNumber(){return __awaiter$8(this,void 0,void 0,function*(){return this._getInternalBlockNumber(0)})}getGasPrice(){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const result=yield this.perform("getGasPrice",{});try{return BigNumber.from(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getGasPrice",result:result,error:error})}})}getBalance(addressOrName,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("getBalance",params);try{return BigNumber.from(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getBalance",params:params,result:result,error:error})}})}getTransactionCount(addressOrName,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("getTransactionCount",params);try{return BigNumber.from(result).toNumber()}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getTransactionCount",params:params,result:result,error:error})}})}getCode(addressOrName,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("getCode",params);try{return hexlify(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getCode",params:params,result:result,error:error})}})}getStorageAt(addressOrName,position,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag),position:Promise.resolve(position).then(p=>hexValue(p))});const result=yield this.perform("getStorageAt",params);try{return hexlify(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getStorageAt",params:params,result:result,error:error})}})}_wrapTransaction(tx,hash){if(hash!=null&&hexDataLength(hash)!==32){throw new Error("invalid response - sendTransaction")}const result=tx;if(hash!=null&&tx.hash!==hash){logger$t.throwError("Transaction hash mismatch from Provider.sendTransaction.",Logger.errors.UNKNOWN_ERROR,{expectedHash:tx.hash,returnedHash:hash})}result.wait=(confirmations=>__awaiter$8(this,void 0,void 0,function*(){if(confirmations!==0){this._emitted["t:"+tx.hash]="pending"}const receipt=yield this.waitForTransaction(tx.hash,confirmations);if(receipt==null&&confirmations===0){return null}this._emitted["t:"+tx.hash]=receipt.blockNumber;if(receipt.status===0){logger$t.throwError("transaction failed",Logger.errors.CALL_EXCEPTION,{transactionHash:tx.hash,transaction:tx,receipt:receipt})}return receipt}));return result}sendTransaction(signedTransaction){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const hexTx=yield Promise.resolve(signedTransaction).then(t=>hexlify(t));const tx=this.formatter.transaction(signedTransaction);try{const hash=yield this.perform("sendTransaction",{signedTransaction:hexTx});return this._wrapTransaction(tx,hash)}catch(error){error.transaction=tx;error.transactionHash=tx.hash;throw error}})}_getTransactionRequest(transaction){return __awaiter$8(this,void 0,void 0,function*(){const values=yield transaction;const tx={};["from","to"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v?this._getAddress(v):null)});["gasLimit","gasPrice","value"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v?BigNumber.from(v):null)});["type"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v!=null?v:null)});if(values.accessList){tx.accessList=this.formatter.accessList(values.accessList)}["data"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v?hexlify(v):null)});return this.formatter.transactionRequest(yield resolveProperties(tx))})}_getFilter(filter){return __awaiter$8(this,void 0,void 0,function*(){filter=yield filter;const result={};if(filter.address!=null){result.address=this._getAddress(filter.address)}["blockHash","topics"].forEach(key=>{if(filter[key]==null){return}result[key]=filter[key]});["fromBlock","toBlock"].forEach(key=>{if(filter[key]==null){return}result[key]=this._getBlockTag(filter[key])});return this.formatter.filter(yield resolveProperties(result))})}call(transaction,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({transaction:this._getTransactionRequest(transaction),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("call",params);try{return hexlify(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"call",params:params,result:result,error:error})}})}estimateGas(transaction){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({transaction:this._getTransactionRequest(transaction)});const result=yield this.perform("estimateGas",params);try{return BigNumber.from(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"estimateGas",params:params,result:result,error:error})}})}_getAddress(addressOrName){return __awaiter$8(this,void 0,void 0,function*(){const address=yield this.resolveName(addressOrName);if(address==null){logger$t.throwError("ENS name not configured",Logger.errors.UNSUPPORTED_OPERATION,{operation:`resolveName(${JSON.stringify(addressOrName)})`})}return address})}_getBlock(blockHashOrBlockTag,includeTransactions){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();blockHashOrBlockTag=yield blockHashOrBlockTag;let blockNumber=-128;const params={includeTransactions:!!includeTransactions};if(isHexString(blockHashOrBlockTag,32)){params.blockHash=blockHashOrBlockTag}else{try{params.blockTag=this.formatter.blockTag(yield this._getBlockTag(blockHashOrBlockTag));if(isHexString(params.blockTag)){blockNumber=parseInt(params.blockTag.substring(2),16)}}catch(error){logger$t.throwArgumentError("invalid block hash or block tag","blockHashOrBlockTag",blockHashOrBlockTag)}}return poll(()=>__awaiter$8(this,void 0,void 0,function*(){const block=yield this.perform("getBlock",params);if(block==null){if(params.blockHash!=null){if(this._emitted["b:"+params.blockHash]==null){return null}}if(params.blockTag!=null){if(blockNumber>this._emitted.block){return null}}return undefined}if(includeTransactions){let blockNumber=null;for(let i=0;i<block.transactions.length;i++){const tx=block.transactions[i];if(tx.blockNumber==null){tx.confirmations=0}else if(tx.confirmations==null){if(blockNumber==null){blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval)}let confirmations=blockNumber-tx.blockNumber+1;if(confirmations<=0){confirmations=1}tx.confirmations=confirmations}}return this.formatter.blockWithTransactions(block)}return this.formatter.block(block)}),{oncePoll:this})})}getBlock(blockHashOrBlockTag){return this._getBlock(blockHashOrBlockTag,false)}getBlockWithTransactions(blockHashOrBlockTag){return this._getBlock(blockHashOrBlockTag,true)}getTransaction(transactionHash){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();transactionHash=yield transactionHash;const params={transactionHash:this.formatter.hash(transactionHash,true)};return poll(()=>__awaiter$8(this,void 0,void 0,function*(){const result=yield this.perform("getTransaction",params);if(result==null){if(this._emitted["t:"+transactionHash]==null){return null}return undefined}const tx=this.formatter.transactionResponse(result);if(tx.blockNumber==null){tx.confirmations=0}else if(tx.confirmations==null){const blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval);let confirmations=blockNumber-tx.blockNumber+1;if(confirmations<=0){confirmations=1}tx.confirmations=confirmations}return this._wrapTransaction(tx)}),{oncePoll:this})})}getTransactionReceipt(transactionHash){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();transactionHash=yield transactionHash;const params={transactionHash:this.formatter.hash(transactionHash,true)};return poll(()=>__awaiter$8(this,void 0,void 0,function*(){const result=yield this.perform("getTransactionReceipt",params);if(result==null){if(this._emitted["t:"+transactionHash]==null){return null}return undefined}if(result.blockHash==null){return undefined}const receipt=this.formatter.receipt(result);if(receipt.blockNumber==null){receipt.confirmations=0}else if(receipt.confirmations==null){const blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval);let confirmations=blockNumber-receipt.blockNumber+1;if(confirmations<=0){confirmations=1}receipt.confirmations=confirmations}return receipt}),{oncePoll:this})})}getLogs(filter){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({filter:this._getFilter(filter)});const logs=yield this.perform("getLogs",params);logs.forEach(log=>{if(log.removed==null){log.removed=false}});return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)})}getEtherPrice(){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();return this.perform("getEtherPrice",{})})}_getBlockTag(blockTag){return __awaiter$8(this,void 0,void 0,function*(){blockTag=yield blockTag;if(typeof blockTag==="number"&&blockTag<0){if(blockTag%1){logger$t.throwArgumentError("invalid BlockTag","blockTag",blockTag)}let blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval);blockNumber+=blockTag;if(blockNumber<0){blockNumber=0}return this.formatter.blockTag(blockNumber)}return this.formatter.blockTag(blockTag)})}getResolver(name){return __awaiter$8(this,void 0,void 0,function*(){const address=yield this._getResolver(name);if(address==null){return null}return new Resolver(this,address,name)})}_getResolver(name){return __awaiter$8(this,void 0,void 0,function*(){const network=yield this.getNetwork();if(!network.ensAddress){logger$t.throwError("network does not support ENS",Logger.errors.UNSUPPORTED_OPERATION,{operation:"ENS",network:network.name})}const transaction={to:network.ensAddress,data:"0x0178b8bf"+namehash(name).substring(2)};return this.formatter.callAddress(yield this.call(transaction))})}resolveName(name){return __awaiter$8(this,void 0,void 0,function*(){name=yield name;try{return Promise.resolve(this.formatter.address(name))}catch(error){if(isHexString(name)){throw error}}if(typeof name!=="string"){logger$t.throwArgumentError("invalid ENS name","name",name)}const resolver=yield this.getResolver(name);if(!resolver){return null}return yield resolver.getAddress()})}lookupAddress(address){return __awaiter$8(this,void 0,void 0,function*(){address=yield address;address=this.formatter.address(address);const reverseName=address.substring(2).toLowerCase()+".addr.reverse";const resolverAddress=yield this._getResolver(reverseName);if(!resolverAddress){return null}let bytes=arrayify(yield this.call({to:resolverAddress,data:"0x691f3431"+namehash(reverseName).substring(2)}));if(bytes.length<32||!BigNumber.from(bytes.slice(0,32)).eq(32)){return null}bytes=bytes.slice(32);if(bytes.length<32){return null}const length=BigNumber.from(bytes.slice(0,32)).toNumber();bytes=bytes.slice(32);if(length>bytes.length){return null}const name=toUtf8String(bytes.slice(0,length));const addr=yield this.resolveName(name);if(addr!=address){return null}return name})}perform(method,params){return logger$t.throwError(method+" not implemented",Logger.errors.NOT_IMPLEMENTED,{operation:method})}_startEvent(event){this.polling=this._events.filter(e=>e.pollable()).length>0}_stopEvent(event){this.polling=this._events.filter(e=>e.pollable()).length>0}_addEventListener(eventName,listener,once){const event=new Event(getEventTag$1(eventName),listener,once);this._events.push(event);this._startEvent(event);return this}on(eventName,listener){return this._addEventListener(eventName,listener,false)}once(eventName,listener){return this._addEventListener(eventName,listener,true)}emit(eventName,...args){let result=false;let stopped=[];let eventTag=getEventTag$1(eventName);this._events=this._events.filter(event=>{if(event.tag!==eventTag){return true}setTimeout(()=>{event.listener.apply(this,args)},0);result=true;if(event.once){stopped.push(event);return false}return true});stopped.forEach(event=>{this._stopEvent(event)});return result}listenerCount(eventName){if(!eventName){return this._events.length}let eventTag=getEventTag$1(eventName);return this._events.filter(event=>{return event.tag===eventTag}).length}listeners(eventName){if(eventName==null){return this._events.map(event=>event.listener)}let eventTag=getEventTag$1(eventName);return this._events.filter(event=>event.tag===eventTag).map(event=>event.listener)}off(eventName,listener){if(listener==null){return this.removeAllListeners(eventName)}const stopped=[];let found=false;let eventTag=getEventTag$1(eventName);this._events=this._events.filter(event=>{if(event.tag!==eventTag||event.listener!=listener){return true}if(found){return true}found=true;stopped.push(event);return false});stopped.forEach(event=>{this._stopEvent(event)});return this}removeAllListeners(eventName){let stopped=[];if(eventName==null){stopped=this._events;this._events=[]}else{const eventTag=getEventTag$1(eventName);this._events=this._events.filter(event=>{if(event.tag!==eventTag){return true}stopped.push(event);return false})}stopped.forEach(event=>{this._stopEvent(event)});return this}}"use strict";var __awaiter$9=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$u=new Logger(version$m);const errorGas=["call","estimateGas"];function checkError(method,error,params){if(method==="call"&&error.code===Logger.errors.SERVER_ERROR){const e=error.error;if(e&&e.message.match("reverted")&&isHexString(e.data)){return e.data}}let message=error.message;if(error.code===Logger.errors.SERVER_ERROR&&error.error&&typeof error.error.message==="string"){message=error.error.message}else if(typeof error.body==="string"){message=error.body}else if(typeof error.responseText==="string"){message=error.responseText}message=(message||"").toLowerCase();const transaction=params.transaction||params.signedTransaction;if(message.match(/insufficient funds/)){logger$u.throwError("insufficient funds for intrinsic transaction cost",Logger.errors.INSUFFICIENT_FUNDS,{error:error,method:method,transaction:transaction})}if(message.match(/nonce too low/)){logger$u.throwError("nonce has already been used",Logger.errors.NONCE_EXPIRED,{error:error,method:method,transaction:transaction})}if(message.match(/replacement transaction underpriced/)){logger$u.throwError("replacement fee too low",Logger.errors.REPLACEMENT_UNDERPRICED,{error:error,method:method,transaction:transaction})}if(message.match(/only replay-protected/)){logger$u.throwError("legacy pre-eip-155 transactions not supported",Logger.errors.UNSUPPORTED_OPERATION,{error:error,method:method,transaction:transaction})}if(errorGas.indexOf(method)>=0&&message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)){logger$u.throwError("cannot estimate gas; transaction may fail or may require manual gas limit",Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,method:method,transaction:transaction})}throw error}function timer(timeout){return new Promise(function(resolve){setTimeout(resolve,timeout)})}function getResult(payload){if(payload.error){const error=new Error(payload.error.message);error.code=payload.error.code;error.data=payload.error.data;throw error}return payload.result}function getLowerCase(value){if(value){return value.toLowerCase()}return value}const _constructorGuard$4={};class JsonRpcSigner extends Signer{constructor(constructorGuard,provider,addressOrIndex){logger$u.checkNew(new.target,JsonRpcSigner);super();if(constructorGuard!==_constructorGuard$4){throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner")}defineReadOnly(this,"provider",provider);if(addressOrIndex==null){addressOrIndex=0}if(typeof addressOrIndex==="string"){defineReadOnly(this,"_address",this.provider.formatter.address(addressOrIndex));defineReadOnly(this,"_index",null)}else if(typeof addressOrIndex==="number"){defineReadOnly(this,"_index",addressOrIndex);defineReadOnly(this,"_address",null)}else{logger$u.throwArgumentError("invalid address or index","addressOrIndex",addressOrIndex)}}connect(provider){return logger$u.throwError("cannot alter JSON-RPC Signer connection",Logger.errors.UNSUPPORTED_OPERATION,{operation:"connect"})}connectUnchecked(){return new UncheckedJsonRpcSigner(_constructorGuard$4,this.provider,this._address||this._index)}getAddress(){if(this._address){return Promise.resolve(this._address)}return this.provider.send("eth_accounts",[]).then(accounts=>{if(accounts.length<=this._index){logger$u.throwError("unknown account #"+this._index,Logger.errors.UNSUPPORTED_OPERATION,{operation:"getAddress"})}return this.provider.formatter.address(accounts[this._index])})}sendUncheckedTransaction(transaction){transaction=shallowCopy(transaction);const fromAddress=this.getAddress().then(address=>{if(address){address=address.toLowerCase()}return address});if(transaction.gasLimit==null){const estimate=shallowCopy(transaction);estimate.from=fromAddress;transaction.gasLimit=this.provider.estimateGas(estimate)}return resolveProperties({tx:resolveProperties(transaction),sender:fromAddress}).then(({tx:tx,sender:sender})=>{if(tx.from!=null){if(tx.from.toLowerCase()!==sender){logger$u.throwArgumentError("from address mismatch","transaction",transaction)}}else{tx.from=sender}const hexTx=this.provider.constructor.hexlifyTransaction(tx,{from:true});return this.provider.send("eth_sendTransaction",[hexTx]).then(hash=>{return hash},error=>{return checkError("sendTransaction",error,hexTx)})})}signTransaction(transaction){return logger$u.throwError("signing transactions is unsupported",Logger.errors.UNSUPPORTED_OPERATION,{operation:"signTransaction"})}sendTransaction(transaction){return this.sendUncheckedTransaction(transaction).then(hash=>{return poll(()=>{return this.provider.getTransaction(hash).then(tx=>{if(tx===null){return undefined}return this.provider._wrapTransaction(tx,hash)})},{onceBlock:this.provider}).catch(error=>{error.transactionHash=hash;throw error})})}signMessage(message){return __awaiter$9(this,void 0,void 0,function*(){const data=typeof message==="string"?toUtf8Bytes(message):message;const address=yield this.getAddress();return yield this.provider.send("eth_sign",[address.toLowerCase(),hexlify(data)])})}_signTypedData(domain,types,value){return __awaiter$9(this,void 0,void 0,function*(){const populated=yield TypedDataEncoder.resolveNames(domain,types,value,name=>{return this.provider.resolveName(name)});const address=yield this.getAddress();return yield this.provider.send("eth_signTypedData_v4",[address.toLowerCase(),JSON.stringify(TypedDataEncoder.getPayload(populated.domain,types,populated.value))])})}unlock(password){return __awaiter$9(this,void 0,void 0,function*(){const provider=this.provider;const address=yield this.getAddress();return provider.send("personal_unlockAccount",[address.toLowerCase(),password,null])})}}class UncheckedJsonRpcSigner extends JsonRpcSigner{sendTransaction(transaction){return this.sendUncheckedTransaction(transaction).then(hash=>{return{hash:hash,nonce:null,gasLimit:null,gasPrice:null,data:null,value:null,chainId:null,confirmations:0,from:null,wait:confirmations=>{return this.provider.waitForTransaction(hash,confirmations)}}})}}const allowedTransactionKeys$3={chainId:true,data:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true,type:true,accessList:true};class JsonRpcProvider extends BaseProvider{constructor(url,network){logger$u.checkNew(new.target,JsonRpcProvider);let networkOrReady=network;if(networkOrReady==null){networkOrReady=new Promise((resolve,reject)=>{setTimeout(()=>{this.detectNetwork().then(network=>{resolve(network)},error=>{reject(error)})},0)})}super(networkOrReady);if(!url){url=getStatic(this.constructor,"defaultUrl")()}if(typeof url==="string"){defineReadOnly(this,"connection",Object.freeze({url:url}))}else{defineReadOnly(this,"connection",Object.freeze(shallowCopy(url)))}this._nextId=42}get _cache(){if(this._eventLoopCache==null){this._eventLoopCache={}}return this._eventLoopCache}static defaultUrl(){return"http://localhost:8545"}detectNetwork(){if(!this._cache["detectNetwork"]){this._cache["detectNetwork"]=this._uncachedDetectNetwork();setTimeout(()=>{this._cache["detectNetwork"]=null},0)}return this._cache["detectNetwork"]}_uncachedDetectNetwork(){return __awaiter$9(this,void 0,void 0,function*(){yield timer(0);let chainId=null;try{chainId=yield this.send("eth_chainId",[])}catch(error){try{chainId=yield this.send("net_version",[])}catch(error){}}if(chainId!=null){const getNetwork=getStatic(this.constructor,"getNetwork");try{return getNetwork(BigNumber.from(chainId).toNumber())}catch(error){return logger$u.throwError("could not detect network",Logger.errors.NETWORK_ERROR,{chainId:chainId,event:"invalidNetwork",serverError:error})}}return logger$u.throwError("could not detect network",Logger.errors.NETWORK_ERROR,{event:"noNetwork"})})}getSigner(addressOrIndex){return new JsonRpcSigner(_constructorGuard$4,this,addressOrIndex)}getUncheckedSigner(addressOrIndex){return this.getSigner(addressOrIndex).connectUnchecked()}listAccounts(){return this.send("eth_accounts",[]).then(accounts=>{return accounts.map(a=>this.formatter.address(a))})}send(method,params){const request={method:method,params:params,id:this._nextId++,jsonrpc:"2.0"};this.emit("debug",{action:"request",request:deepCopy(request),provider:this});const cache=["eth_chainId","eth_blockNumber"].indexOf(method)>=0;if(cache&&this._cache[method]){return this._cache[method]}const result=fetchJson(this.connection,JSON.stringify(request),getResult).then(result=>{this.emit("debug",{action:"response",request:request,response:result,provider:this});return result},error=>{this.emit("debug",{action:"response",error:error,request:request,provider:this});throw error});if(cache){this._cache[method]=result;setTimeout(()=>{this._cache[method]=null},0)}return result}prepareRequest(method,params){switch(method){case"getBlockNumber":return["eth_blockNumber",[]];case"getGasPrice":return["eth_gasPrice",[]];case"getBalance":return["eth_getBalance",[getLowerCase(params.address),params.blockTag]];case"getTransactionCount":return["eth_getTransactionCount",[getLowerCase(params.address),params.blockTag]];case"getCode":return["eth_getCode",[getLowerCase(params.address),params.blockTag]];case"getStorageAt":return["eth_getStorageAt",[getLowerCase(params.address),params.position,params.blockTag]];case"sendTransaction":return["eth_sendRawTransaction",[params.signedTransaction]];case"getBlock":if(params.blockTag){return["eth_getBlockByNumber",[params.blockTag,!!params.includeTransactions]]}else if(params.blockHash){return["eth_getBlockByHash",[params.blockHash,!!params.includeTransactions]]}return null;case"getTransaction":return["eth_getTransactionByHash",[params.transactionHash]];case"getTransactionReceipt":return["eth_getTransactionReceipt",[params.transactionHash]];case"call":{const hexlifyTransaction=getStatic(this.constructor,"hexlifyTransaction");return["eth_call",[hexlifyTransaction(params.transaction,{from:true}),params.blockTag]]}case"estimateGas":{const hexlifyTransaction=getStatic(this.constructor,"hexlifyTransaction");return["eth_estimateGas",[hexlifyTransaction(params.transaction,{from:true})]]}case"getLogs":if(params.filter&&params.filter.address!=null){params.filter.address=getLowerCase(params.filter.address)}return["eth_getLogs",[params.filter]];default:break}return null}perform(method,params){return __awaiter$9(this,void 0,void 0,function*(){const args=this.prepareRequest(method,params);if(args==null){logger$u.throwError(method+" not implemented",Logger.errors.NOT_IMPLEMENTED,{operation:method})}try{return yield this.send(args[0],args[1])}catch(error){return checkError(method,error,params)}})}_startEvent(event){if(event.tag==="pending"){this._startPending()}super._startEvent(event)}_startPending(){if(this._pendingFilter!=null){return}const self=this;const pendingFilter=this.send("eth_newPendingTransactionFilter",[]);this._pendingFilter=pendingFilter;pendingFilter.then(function(filterId){function poll(){self.send("eth_getFilterChanges",[filterId]).then(function(hashes){if(self._pendingFilter!=pendingFilter){return null}let seq=Promise.resolve();hashes.forEach(function(hash){self._emitted["t:"+hash.toLowerCase()]="pending";seq=seq.then(function(){return self.getTransaction(hash).then(function(tx){self.emit("pending",tx);return null})})});return seq.then(function(){return timer(1e3)})}).then(function(){if(self._pendingFilter!=pendingFilter){self.send("eth_uninstallFilter",[filterId]);return}setTimeout(function(){poll()},0);return null}).catch(error=>{})}poll();return filterId}).catch(error=>{})}_stopEvent(event){if(event.tag==="pending"&&this.listenerCount("pending")===0){this._pendingFilter=null}super._stopEvent(event)}static hexlifyTransaction(transaction,allowExtra){const allowed=shallowCopy(allowedTransactionKeys$3);if(allowExtra){for(const key in allowExtra){if(allowExtra[key]){allowed[key]=true}}}checkProperties(transaction,allowed);const result={};["gasLimit","gasPrice","type","nonce","value"].forEach(function(key){if(transaction[key]==null){return}const value=hexValue(transaction[key]);if(key==="gasLimit"){key="gas"}result[key]=value});["from","to","data"].forEach(function(key){if(transaction[key]==null){return}result[key]=hexlify(transaction[key])});if(transaction.accessList){result["accessList"]=accessListify(transaction.accessList)}return result}}"use strict";let WS=null;try{WS=WebSocket;if(WS==null){throw new Error("inject please")}}catch(error){const logger=new Logger(version$m);WS=function(){logger.throwError("WebSockets not supported in this environment",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new WebSocket()"})}}"use strict";var __awaiter$a=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$v=new Logger(version$m);let NextId=1;class WebSocketProvider extends JsonRpcProvider{constructor(url,network){if(network==="any"){logger$v.throwError("WebSocketProvider does not support 'any' network yet",Logger.errors.UNSUPPORTED_OPERATION,{operation:"network:any"})}super(url,network);this._pollingInterval=-1;this._wsReady=false;defineReadOnly(this,"_websocket",new WS(this.connection.url));defineReadOnly(this,"_requests",{});defineReadOnly(this,"_subs",{});defineReadOnly(this,"_subIds",{});defineReadOnly(this,"_detectNetwork",super.detectNetwork());this._websocket.onopen=(()=>{this._wsReady=true;Object.keys(this._requests).forEach(id=>{this._websocket.send(this._requests[id].payload)})});this._websocket.onmessage=(messageEvent=>{const data=messageEvent.data;const result=JSON.parse(data);if(result.id!=null){const id=String(result.id);const request=this._requests[id];delete this._requests[id];if(result.result!==undefined){request.callback(null,result.result);this.emit("debug",{action:"response",request:JSON.parse(request.payload),response:result.result,provider:this})}else{let error=null;if(result.error){error=new Error(result.error.message||"unknown error");defineReadOnly(error,"code",result.error.code||null);defineReadOnly(error,"response",data)}else{error=new Error("unknown error")}request.callback(error,undefined);this.emit("debug",{action:"response",error:error,request:JSON.parse(request.payload),provider:this})}}else if(result.method==="eth_subscription"){const sub=this._subs[result.params.subscription];if(sub){sub.processFunc(result.params.result)}}else{console.warn("this should not happen")}});const fauxPoll=setInterval(()=>{this.emit("poll")},1e3);if(fauxPoll.unref){fauxPoll.unref()}}detectNetwork(){return this._detectNetwork}get pollingInterval(){return 0}resetEventsBlock(blockNumber){logger$v.throwError("cannot reset events block on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resetEventBlock"})}set pollingInterval(value){logger$v.throwError("cannot set polling interval on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setPollingInterval"})}poll(){return __awaiter$a(this,void 0,void 0,function*(){return null})}set polling(value){if(!value){return}logger$v.throwError("cannot set polling on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setPolling"})}send(method,params){const rid=NextId++;return new Promise((resolve,reject)=>{function callback(error,result){if(error){return reject(error)}return resolve(result)}const payload=JSON.stringify({method:method,params:params,id:rid,jsonrpc:"2.0"});this.emit("debug",{action:"request",request:JSON.parse(payload),provider:this});this._requests[String(rid)]={callback:callback,payload:payload};if(this._wsReady){this._websocket.send(payload)}})}static defaultUrl(){return"ws://localhost:8546"}_subscribe(tag,param,processFunc){return __awaiter$a(this,void 0,void 0,function*(){let subIdPromise=this._subIds[tag];if(subIdPromise==null){subIdPromise=Promise.all(param).then(param=>{return this.send("eth_subscribe",param)});this._subIds[tag]=subIdPromise}const subId=yield subIdPromise;this._subs[subId]={tag:tag,processFunc:processFunc}})}_startEvent(event){switch(event.type){case"block":this._subscribe("block",["newHeads"],result=>{const blockNumber=BigNumber.from(result.number).toNumber();this._emitted.block=blockNumber;this.emit("block",blockNumber)});break;case"pending":this._subscribe("pending",["newPendingTransactions"],result=>{this.emit("pending",result)});break;case"filter":this._subscribe(event.tag,["logs",this._getFilter(event.filter)],result=>{if(result.removed==null){result.removed=false}this.emit(event.filter,this.formatter.filterLog(result))});break;case"tx":{const emitReceipt=event=>{const hash=event.hash;this.getTransactionReceipt(hash).then(receipt=>{if(!receipt){return}this.emit(hash,receipt)})};emitReceipt(event);this._subscribe("tx",["newHeads"],result=>{this._events.filter(e=>e.type==="tx").forEach(emitReceipt)});break}case"debug":case"poll":case"willPoll":case"didPoll":case"error":break;default:console.log("unhandled:",event);break}}_stopEvent(event){let tag=event.tag;if(event.type==="tx"){if(this._events.filter(e=>e.type==="tx").length){return}tag="tx"}else if(this.listenerCount(event.event)){return}const subId=this._subIds[tag];if(!subId){return}delete this._subIds[tag];subId.then(subId=>{if(!this._subs[subId]){return}delete this._subs[subId];this.send("eth_unsubscribe",[subId])})}destroy(){return __awaiter$a(this,void 0,void 0,function*(){if(this._websocket.readyState===WS.CONNECTING){yield new Promise(resolve=>{this._websocket.onopen=function(){resolve(true)};this._websocket.onerror=function(){resolve(false)}})}this._websocket.close(1e3)})}}"use strict";var __awaiter$b=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$w=new Logger(version$m);class StaticJsonRpcProvider extends JsonRpcProvider{detectNetwork(){const _super=Object.create(null,{detectNetwork:{get:()=>super.detectNetwork}});return __awaiter$b(this,void 0,void 0,function*(){let network=this.network;if(network==null){network=yield _super.detectNetwork.call(this);if(!network){logger$w.throwError("no network detected",Logger.errors.UNKNOWN_ERROR,{})}if(this._network==null){defineReadOnly(this,"_network",network);this.emit("network",network,null)}}return network})}}class UrlJsonRpcProvider extends StaticJsonRpcProvider{constructor(network,apiKey){logger$w.checkAbstract(new.target,UrlJsonRpcProvider);network=getStatic(new.target,"getNetwork")(network);apiKey=getStatic(new.target,"getApiKey")(apiKey);const connection=getStatic(new.target,"getUrl")(network,apiKey);super(connection,network);if(typeof apiKey==="string"){defineReadOnly(this,"apiKey",apiKey)}else if(apiKey!=null){Object.keys(apiKey).forEach(key=>{defineReadOnly(this,key,apiKey[key])})}}_startPending(){logger$w.warn("WARNING: API provider does not support pending filters")}isCommunityResource(){return false}getSigner(address){return logger$w.throwError("API provider does not support signing",Logger.errors.UNSUPPORTED_OPERATION,{operation:"getSigner"})}listAccounts(){return Promise.resolve([])}static getApiKey(apiKey){return apiKey}static getUrl(network,apiKey){return logger$w.throwError("not implemented; sub-classes must override getUrl",Logger.errors.NOT_IMPLEMENTED,{operation:"getUrl"})}}"use strict";const logger$x=new Logger(version$m);const defaultApiKey="_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";class AlchemyWebSocketProvider extends WebSocketProvider{constructor(network,apiKey){const provider=new AlchemyProvider(network,apiKey);const url=provider.connection.url.replace(/^http/i,"ws").replace(".alchemyapi.",".ws.alchemyapi.");super(url,provider.network);defineReadOnly(this,"apiKey",provider.apiKey)}isCommunityResource(){return this.apiKey===defaultApiKey}}class AlchemyProvider extends UrlJsonRpcProvider{static getWebSocketProvider(network,apiKey){return new AlchemyWebSocketProvider(network,apiKey)}static getApiKey(apiKey){if(apiKey==null){return defaultApiKey}if(apiKey&&typeof apiKey!=="string"){logger$x.throwArgumentError("invalid apiKey","apiKey",apiKey)}return apiKey}static getUrl(network,apiKey){let host=null;switch(network.name){case"homestead":host="eth-mainnet.alchemyapi.io/v2/";break;case"ropsten":host="eth-ropsten.alchemyapi.io/v2/";break;case"rinkeby":host="eth-rinkeby.alchemyapi.io/v2/";break;case"goerli":host="eth-goerli.alchemyapi.io/v2/";break;case"kovan":host="eth-kovan.alchemyapi.io/v2/";break;default:logger$x.throwArgumentError("unsupported network","network",arguments[0])}return{allowGzip:true,url:"https:/"+"/"+host+apiKey,throttleCallback:(attempt,url)=>{if(apiKey===defaultApiKey){showThrottleMessage()}return Promise.resolve(true)}}}isCommunityResource(){return this.apiKey===defaultApiKey}}"use strict";var __awaiter$c=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$y=new Logger(version$m);class CloudflareProvider extends UrlJsonRpcProvider{static getApiKey(apiKey){if(apiKey!=null){logger$y.throwArgumentError("apiKey not supported for cloudflare","apiKey",apiKey)}return null}static getUrl(network,apiKey){let host=null;switch(network.name){case"homestead":host="https://cloudflare-eth.com/";break;default:logger$y.throwArgumentError("unsupported network","network",arguments[0])}return host}perform(method,params){const _super=Object.create(null,{perform:{get:()=>super.perform}});return __awaiter$c(this,void 0,void 0,function*(){if(method==="getBlockNumber"){const block=yield _super.perform.call(this,"getBlock",{blockTag:"latest"});return block.number}return _super.perform.call(this,method,params)})}}"use strict";var __awaiter$d=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$z=new Logger(version$m);function getTransactionPostData(transaction){const result={};for(let key in transaction){if(transaction[key]==null){continue}let value=transaction[key];if({type:true,gasLimit:true,gasPrice:true,nonce:true,value:true}[key]){value=hexValue(hexlify(value))}else if(key==="accessList"){const sets=accessListify(value);value="["+sets.map(set=>{return`{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`}).join(",")+"]"}else{value=hexlify(value)}result[key]=value}return result}function getResult$1(result){if(result.status==0&&(result.message==="No records found"||result.message==="No transactions found")){return result.result}if(result.status!=1||result.message!="OK"){const error=new Error("invalid response");error.result=JSON.stringify(result);if((result.result||"").toLowerCase().indexOf("rate limit")>=0){error.throttleRetry=true}throw error}return result.result}function getJsonResult(result){if(result&&result.status==0&&result.message=="NOTOK"&&(result.result||"").toLowerCase().indexOf("rate limit")>=0){const error=new Error("throttled response");error.result=JSON.stringify(result);error.throttleRetry=true;throw error}if(result.jsonrpc!="2.0"){const error=new Error("invalid response");error.result=JSON.stringify(result);throw error}if(result.error){const error=new Error(result.error.message||"unknown error");if(result.error.code){error.code=result.error.code}if(result.error.data){error.data=result.error.data}throw error}return result.result}function checkLogTag(blockTag){if(blockTag==="pending"){throw new Error("pending not supported")}if(blockTag==="latest"){return blockTag}return parseInt(blockTag.substring(2),16)}const defaultApiKey$1="9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";function checkError$1(method,error,transaction){if(method==="call"&&error.code===Logger.errors.SERVER_ERROR){const e=error.error;if(e&&e.message.match("reverted")&&isHexString(e.data)){return e.data}}let message=error.message;if(error.code===Logger.errors.SERVER_ERROR){if(error.error&&typeof error.error.message==="string"){message=error.error.message}else if(typeof error.body==="string"){message=error.body}else if(typeof error.responseText==="string"){message=error.responseText}}message=(message||"").toLowerCase();if(message.match(/insufficient funds/)){logger$z.throwError("insufficient funds for intrinsic transaction cost",Logger.errors.INSUFFICIENT_FUNDS,{error:error,method:method,transaction:transaction})}if(message.match(/same hash was already imported|transaction nonce is too low/)){logger$z.throwError("nonce has already been used",Logger.errors.NONCE_EXPIRED,{error:error,method:method,transaction:transaction})}if(message.match(/another transaction with same nonce/)){logger$z.throwError("replacement fee too low",Logger.errors.REPLACEMENT_UNDERPRICED,{error:error,method:method,transaction:transaction})}if(message.match(/execution failed due to an exception/)){logger$z.throwError("cannot estimate gas; transaction may fail or may require manual gas limit",Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,method:method,transaction:transaction})}throw error}class EtherscanProvider extends BaseProvider{constructor(network,apiKey){logger$z.checkNew(new.target,EtherscanProvider);super(network);let name="invalid";if(this.network){name=this.network.name}let baseUrl=null;switch(name){case"homestead":baseUrl="https://api.etherscan.io";break;case"ropsten":baseUrl="https://api-ropsten.etherscan.io";break;case"rinkeby":baseUrl="https://api-rinkeby.etherscan.io";break;case"kovan":baseUrl="https://api-kovan.etherscan.io";break;case"goerli":baseUrl="https://api-goerli.etherscan.io";break;default:throw new Error("unsupported network")}defineReadOnly(this,"baseUrl",baseUrl);defineReadOnly(this,"apiKey",apiKey||defaultApiKey$1)}detectNetwork(){return __awaiter$d(this,void 0,void 0,function*(){return this.network})}perform(method,params){const _super=Object.create(null,{perform:{get:()=>super.perform}});return __awaiter$d(this,void 0,void 0,function*(){let url=this.baseUrl+"/api";let apiKey="";if(this.apiKey){apiKey+="&apikey="+this.apiKey}const get=(url,payload,procFunc)=>__awaiter$d(this,void 0,void 0,function*(){this.emit("debug",{action:"request",request:url,provider:this});const connection={url:url,throttleSlotInterval:1e3,throttleCallback:(attempt,url)=>{if(this.isCommunityResource()){showThrottleMessage()}return Promise.resolve(true)}};let payloadStr=null;if(payload){connection.headers={"content-type":"application/x-www-form-urlencoded; charset=UTF-8"};payloadStr=Object.keys(payload).map(key=>{return`${key}=${payload[key]}`}).join("&")}const result=yield fetchJson(connection,payloadStr,procFunc||getJsonResult);this.emit("debug",{action:"response",request:url,response:deepCopy(result),provider:this});return result});switch(method){case"getBlockNumber":url+="?module=proxy&action=eth_blockNumber"+apiKey;return get(url,null);case"getGasPrice":url+="?module=proxy&action=eth_gasPrice"+apiKey;return get(url,null);case"getBalance":url+="?module=account&action=balance&address="+params.address;url+="&tag="+params.blockTag+apiKey;return get(url,null,getResult$1);case"getTransactionCount":url+="?module=proxy&action=eth_getTransactionCount&address="+params.address;url+="&tag="+params.blockTag+apiKey;return get(url,null);case"getCode":url+="?module=proxy&action=eth_getCode&address="+params.address;url+="&tag="+params.blockTag+apiKey;return get(url,null);case"getStorageAt":url+="?module=proxy&action=eth_getStorageAt&address="+params.address;url+="&position="+params.position;url+="&tag="+params.blockTag+apiKey;return get(url,null);case"sendTransaction":return get(url,{module:"proxy",action:"eth_sendRawTransaction",hex:params.signedTransaction,apikey:this.apiKey}).catch(error=>{return checkError$1("sendTransaction",error,params.signedTransaction)});case"getBlock":if(params.blockTag){url+="?module=proxy&action=eth_getBlockByNumber&tag="+params.blockTag;if(params.includeTransactions){url+="&boolean=true"}else{url+="&boolean=false"}url+=apiKey;return get(url,null)}throw new Error("getBlock by blockHash not implemented");case"getTransaction":url+="?module=proxy&action=eth_getTransactionByHash&txhash="+params.transactionHash;url+=apiKey;return get(url,null);case"getTransactionReceipt":url+="?module=proxy&action=eth_getTransactionReceipt&txhash="+params.transactionHash;url+=apiKey;return get(url,null);case"call":{if(params.blockTag!=="latest"){throw new Error("EtherscanProvider does not support blockTag for call")}const postData=getTransactionPostData(params.transaction);postData.module="proxy";postData.action="eth_call";postData.apikey=this.apiKey;try{return yield get(url,postData)}catch(error){return checkError$1("call",error,params.transaction)}}case"estimateGas":{const postData=getTransactionPostData(params.transaction);postData.module="proxy";postData.action="eth_estimateGas";postData.apikey=this.apiKey;try{return yield get(url,postData)}catch(error){return checkError$1("estimateGas",error,params.transaction)}}case"getLogs":{url+="?module=logs&action=getLogs";if(params.filter.fromBlock){url+="&fromBlock="+checkLogTag(params.filter.fromBlock)}if(params.filter.toBlock){url+="&toBlock="+checkLogTag(params.filter.toBlock)}if(params.filter.address){url+="&address="+params.filter.address}if(params.filter.topics&&params.filter.topics.length>0){if(params.filter.topics.length>1){logger$z.throwError("unsupported topic count",Logger.errors.UNSUPPORTED_OPERATION,{topics:params.filter.topics})}if(params.filter.topics.length===1){const topic0=params.filter.topics[0];if(typeof topic0!=="string"||topic0.length!==66){logger$z.throwError("unsupported topic format",Logger.errors.UNSUPPORTED_OPERATION,{topic0:topic0})}url+="&topic0="+topic0}}url+=apiKey;const logs=yield get(url,null,getResult$1);let blocks={};for(let i=0;i<logs.length;i++){const log=logs[i];if(log.blockHash!=null){continue}if(blocks[log.blockNumber]==null){const block=yield this.getBlock(log.blockNumber);if(block){blocks[log.blockNumber]=block.hash}}log.blockHash=blocks[log.blockNumber]}return logs}case"getEtherPrice":if(this.network.name!=="homestead"){return 0}url+="?module=stats&action=ethprice";url+=apiKey;return parseFloat((yield get(url,null,getResult$1)).ethusd);default:break}return _super.perform.call(this,method,params)})}getHistory(addressOrName,startBlock,endBlock){let url=this.baseUrl;let apiKey="";if(this.apiKey){apiKey+="&apikey="+this.apiKey}if(startBlock==null){startBlock=0}if(endBlock==null){endBlock=99999999}return this.resolveName(addressOrName).then(address=>{url+="/api?module=account&action=txlist&address="+address;url+="&startblock="+startBlock;url+="&endblock="+endBlock;url+="&sort=asc"+apiKey;this.emit("debug",{action:"request",request:url,provider:this});const connection={url:url,throttleSlotInterval:1e3,throttleCallback:(attempt,url)=>{if(this.apiKey===defaultApiKey$1){showThrottleMessage()}return Promise.resolve(true)}};return fetchJson(connection,null,getResult$1).then(result=>{this.emit("debug",{action:"response",request:url,response:deepCopy(result),provider:this});let output=[];result.forEach(tx=>{["contractAddress","to"].forEach(function(key){if(tx[key]==""){delete tx[key]}});if(tx.creates==null&&tx.contractAddress!=null){tx.creates=tx.contractAddress}let item=this.formatter.transactionResponse(tx);if(tx.timeStamp){item.timestamp=parseInt(tx.timeStamp)}output.push(item)});return output})})}isCommunityResource(){return this.apiKey===defaultApiKey$1}}"use strict";var __awaiter$e=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$A=new Logger(version$m);function now(){return(new Date).getTime()}function checkNetworks(networks){let result=null;for(let i=0;i<networks.length;i++){const network=networks[i];if(network==null){return null}if(result){if(!(result.name===network.name&&result.chainId===network.chainId&&(result.ensAddress===network.ensAddress||result.ensAddress==null&&network.ensAddress==null))){logger$A.throwArgumentError("provider mismatch","networks",networks)}}else{result=network}}return result}function median(values,maxDelta){values=values.slice().sort();const middle=Math.floor(values.length/2);if(values.length%2){return values[middle]}const a=values[middle-1],b=values[middle];if(maxDelta!=null&&Math.abs(a-b)>maxDelta){return null}return(a+b)/2}function serialize$1(value){if(value===null){return"null"}else if(typeof value==="number"||typeof value==="boolean"){return JSON.stringify(value)}else if(typeof value==="string"){return value}else if(BigNumber.isBigNumber(value)){return value.toString()}else if(Array.isArray(value)){return JSON.stringify(value.map(i=>serialize$1(i)))}else if(typeof value==="object"){const keys=Object.keys(value);keys.sort();return"{"+keys.map(key=>{let v=value[key];if(typeof v==="function"){v="[function]"}else{v=serialize$1(v)}return JSON.stringify(key)+":"+v}).join(",")+"}"}throw new Error("unknown value type: "+typeof value)}let nextRid=1;function stall$1(duration){let cancel=null;let timer=null;let promise=new Promise(resolve=>{cancel=function(){if(timer){clearTimeout(timer);timer=null}resolve()};timer=setTimeout(cancel,duration)});const wait=func=>{promise=promise.then(func);return promise};function getPromise(){return promise}return{cancel:cancel,getPromise:getPromise,wait:wait}}const ForwardErrors=[Logger.errors.CALL_EXCEPTION,Logger.errors.INSUFFICIENT_FUNDS,Logger.errors.NONCE_EXPIRED,Logger.errors.REPLACEMENT_UNDERPRICED,Logger.errors.UNPREDICTABLE_GAS_LIMIT];const ForwardProperties=["address","args","errorArgs","errorSignature","method","transaction"];function exposeDebugConfig(config,now){const result={weight:config.weight};Object.defineProperty(result,"provider",{get:()=>config.provider});if(config.start){result.start=config.start}if(now){result.duration=now-config.start}if(config.done){if(config.error){result.error=config.error}else{result.result=config.result||null}}return result}function normalizedTally(normalize,quorum){return function(configs){const tally={};configs.forEach(c=>{const value=normalize(c.result);if(!tally[value]){tally[value]={count:0,result:c.result}}tally[value].count++});const keys=Object.keys(tally);for(let i=0;i<keys.length;i++){const check=tally[keys[i]];if(check.count>=quorum){return check.result}}return undefined}}function getProcessFunc(provider,method,params){let normalize=serialize$1;switch(method){case"getBlockNumber":return function(configs){const values=configs.map(c=>c.result);let blockNumber=median(configs.map(c=>c.result),2);if(blockNumber==null){return undefined}blockNumber=Math.ceil(blockNumber);if(values.indexOf(blockNumber+1)>=0){blockNumber++}if(blockNumber>=provider._highestBlockNumber){provider._highestBlockNumber=blockNumber}return provider._highestBlockNumber};case"getGasPrice":return function(configs){const values=configs.map(c=>c.result);values.sort();return values[Math.floor(values.length/2)]};case"getEtherPrice":return function(configs){return median(configs.map(c=>c.result))};case"getBalance":case"getTransactionCount":case"getCode":case"getStorageAt":case"call":case"estimateGas":case"getLogs":break;case"getTransaction":case"getTransactionReceipt":normalize=function(tx){if(tx==null){return null}tx=shallowCopy(tx);tx.confirmations=-1;return serialize$1(tx)};break;case"getBlock":if(params.includeTransactions){normalize=function(block){if(block==null){return null}block=shallowCopy(block);block.transactions=block.transactions.map(tx=>{tx=shallowCopy(tx);tx.confirmations=-1;return tx});return serialize$1(block)}}else{normalize=function(block){if(block==null){return null}return serialize$1(block)}}break;default:throw new Error("unknown method: "+method)}return normalizedTally(normalize,provider.quorum)}function waitForSync(config,blockNumber){return __awaiter$e(this,void 0,void 0,function*(){const provider=config.provider;if(provider.blockNumber!=null&&provider.blockNumber>=blockNumber||blockNumber===-1){return provider}return poll(()=>{return new Promise((resolve,reject)=>{setTimeout(function(){if(provider.blockNumber>=blockNumber){return resolve(provider)}if(config.cancelled){return resolve(null)}return resolve(undefined)},0)})},{oncePoll:provider})})}function getRunner(config,currentBlockNumber,method,params){return __awaiter$e(this,void 0,void 0,function*(){let provider=config.provider;switch(method){case"getBlockNumber":case"getGasPrice":return provider[method]();case"getEtherPrice":if(provider.getEtherPrice){return provider.getEtherPrice()}break;case"getBalance":case"getTransactionCount":case"getCode":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider[method](params.address,params.blockTag||"latest");case"getStorageAt":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider.getStorageAt(params.address,params.position,params.blockTag||"latest");case"getBlock":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider[params.includeTransactions?"getBlockWithTransactions":"getBlock"](params.blockTag||params.blockHash);case"call":case"estimateGas":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider[method](params.transaction);case"getTransaction":case"getTransactionReceipt":return provider[method](params.transactionHash);case"getLogs":{let filter=params.filter;if(filter.fromBlock&&isHexString(filter.fromBlock)||filter.toBlock&&isHexString(filter.toBlock)){provider=yield waitForSync(config,currentBlockNumber)}return provider.getLogs(filter)}}return logger$A.throwError("unknown method error",Logger.errors.UNKNOWN_ERROR,{method:method,params:params})})}class FallbackProvider extends BaseProvider{constructor(providers,quorum){logger$A.checkNew(new.target,FallbackProvider);if(providers.length===0){logger$A.throwArgumentError("missing providers","providers",providers)}const providerConfigs=providers.map((configOrProvider,index)=>{if(Provider.isProvider(configOrProvider)){const stallTimeout=isCommunityResource(configOrProvider)?2e3:750;const priority=1;return Object.freeze({provider:configOrProvider,weight:1,stallTimeout:stallTimeout,priority:priority})}const config=shallowCopy(configOrProvider);if(config.priority==null){config.priority=1}if(config.stallTimeout==null){config.stallTimeout=isCommunityResource(configOrProvider)?2e3:750}if(config.weight==null){config.weight=1}const weight=config.weight;if(weight%1||weight>512||weight<1){logger$A.throwArgumentError("invalid weight; must be integer in [1, 512]",`providers[${index}].weight`,weight)}return Object.freeze(config)});const total=providerConfigs.reduce((accum,c)=>accum+c.weight,0);if(quorum==null){quorum=total/2}else if(quorum>total){logger$A.throwArgumentError("quorum will always fail; larger than total weight","quorum",quorum)}let networkOrReady=checkNetworks(providerConfigs.map(c=>c.provider.network));if(networkOrReady==null){networkOrReady=new Promise((resolve,reject)=>{setTimeout(()=>{this.detectNetwork().then(resolve,reject)},0)})}super(networkOrReady);defineReadOnly(this,"providerConfigs",Object.freeze(providerConfigs));defineReadOnly(this,"quorum",quorum);this._highestBlockNumber=-1}detectNetwork(){return __awaiter$e(this,void 0,void 0,function*(){const networks=yield Promise.all(this.providerConfigs.map(c=>c.provider.getNetwork()));return checkNetworks(networks)})}perform(method,params){return __awaiter$e(this,void 0,void 0,function*(){if(method==="sendTransaction"){const results=yield Promise.all(this.providerConfigs.map(c=>{return c.provider.sendTransaction(params.signedTransaction).then(result=>{return result.hash},error=>{return error})}));for(let i=0;i<results.length;i++){const result=results[i];if(typeof result==="string"){return result}}throw results[0]}if(this._highestBlockNumber===-1&&method!=="getBlockNumber"){yield this.getBlockNumber()}const processFunc=getProcessFunc(this,method,params);const configs=shuffled(this.providerConfigs.map(shallowCopy));configs.sort((a,b)=>a.priority-b.priority);const currentBlockNumber=this._highestBlockNumber;let i=0;let first=true;while(true){const t0=now();let inflightWeight=configs.filter(c=>c.runner&&t0-c.start<c.stallTimeout).reduce((accum,c)=>accum+c.weight,0);while(inflightWeight<this.quorum&&i<configs.length){const config=configs[i++];const rid=nextRid++;config.start=now();config.staller=stall$1(config.stallTimeout);config.staller.wait(()=>{config.staller=null});config.runner=getRunner(config,currentBlockNumber,method,params).then(result=>{config.done=true;config.result=result;if(this.listenerCount("debug")){this.emit("debug",{action:"request",rid:rid,backend:exposeDebugConfig(config,now()),request:{method:method,params:deepCopy(params)},provider:this})}},error=>{config.done=true;config.error=error;if(this.listenerCount("debug")){this.emit("debug",{action:"request",rid:rid,backend:exposeDebugConfig(config,now()),request:{method:method,params:deepCopy(params)},provider:this})}});if(this.listenerCount("debug")){this.emit("debug",{action:"request",rid:rid,backend:exposeDebugConfig(config,null),request:{method:method,params:deepCopy(params)},provider:this})}inflightWeight+=config.weight}const waiting=[];configs.forEach(c=>{if(c.done||!c.runner){return}waiting.push(c.runner);if(c.staller){waiting.push(c.staller.getPromise())}});if(waiting.length){yield Promise.race(waiting)}const results=configs.filter(c=>c.done&&c.error==null);if(results.length>=this.quorum){const result=processFunc(results);if(result!==undefined){configs.forEach(c=>{if(c.staller){c.staller.cancel()}c.cancelled=true});return result}if(!first){yield stall$1(100).getPromise()}first=false}const errors=configs.reduce((accum,c)=>{if(!c.done||c.error==null){return accum}const code=c.error.code;if(ForwardErrors.indexOf(code)>=0){if(!accum[code]){accum[code]={error:c.error,weight:0}}accum[code].weight+=c.weight}return accum},{});Object.keys(errors).forEach(errorCode=>{const tally=errors[errorCode];if(tally.weight<this.quorum){return}configs.forEach(c=>{if(c.staller){c.staller.cancel()}c.cancelled=true});const e=tally.error;const props={};ForwardProperties.forEach(name=>{if(e[name]==null){return}props[name]=e[name]});logger$A.throwError(e.reason||e.message,errorCode,props)});if(configs.filter(c=>!c.done).length===0){break}}configs.forEach(c=>{if(c.staller){c.staller.cancel()}c.cancelled=true});return logger$A.throwError("failed to meet quorum",Logger.errors.SERVER_ERROR,{method:method,params:params,results:configs.map(c=>exposeDebugConfig(c)),provider:this})})}}"use strict";const IpcProvider=null;"use strict";const logger$B=new Logger(version$m);const defaultProjectId="84842078b09946638c03157f83405213";class InfuraWebSocketProvider extends WebSocketProvider{constructor(network,apiKey){const provider=new InfuraProvider(network,apiKey);const connection=provider.connection;if(connection.password){logger$B.throwError("INFURA WebSocket project secrets unsupported",Logger.errors.UNSUPPORTED_OPERATION,{operation:"InfuraProvider.getWebSocketProvider()"})}const url=connection.url.replace(/^http/i,"ws").replace("/v3/","/ws/v3/");super(url,network);defineReadOnly(this,"apiKey",provider.projectId);defineReadOnly(this,"projectId",provider.projectId);defineReadOnly(this,"projectSecret",provider.projectSecret)}isCommunityResource(){return this.projectId===defaultProjectId}}class InfuraProvider extends UrlJsonRpcProvider{static getWebSocketProvider(network,apiKey){return new InfuraWebSocketProvider(network,apiKey)}static getApiKey(apiKey){const apiKeyObj={apiKey:defaultProjectId,projectId:defaultProjectId,projectSecret:null};if(apiKey==null){return apiKeyObj}if(typeof apiKey==="string"){apiKeyObj.projectId=apiKey}else if(apiKey.projectSecret!=null){logger$B.assertArgument(typeof apiKey.projectId==="string","projectSecret requires a projectId","projectId",apiKey.projectId);logger$B.assertArgument(typeof apiKey.projectSecret==="string","invalid projectSecret","projectSecret","[REDACTED]");apiKeyObj.projectId=apiKey.projectId;apiKeyObj.projectSecret=apiKey.projectSecret}else if(apiKey.projectId){apiKeyObj.projectId=apiKey.projectId}apiKeyObj.apiKey=apiKeyObj.projectId;return apiKeyObj}static getUrl(network,apiKey){let host=null;switch(network?network.name:"unknown"){case"homestead":host="mainnet.infura.io";break;case"ropsten":host="ropsten.infura.io";break;case"rinkeby":host="rinkeby.infura.io";break;case"kovan":host="kovan.infura.io";break;case"goerli":host="goerli.infura.io";break;default:logger$B.throwError("unsupported network",Logger.errors.INVALID_ARGUMENT,{argument:"network",value:network})}const connection={allowGzip:true,url:"https:/"+"/"+host+"/v3/"+apiKey.projectId,throttleCallback:(attempt,url)=>{if(apiKey.projectId===defaultProjectId){showThrottleMessage()}return Promise.resolve(true)}};if(apiKey.projectSecret!=null){connection.user="";connection.password=apiKey.projectSecret}return connection}isCommunityResource(){return this.projectId===defaultProjectId}}class JsonRpcBatchProvider extends JsonRpcProvider{send(method,params){const request={method:method,params:params,id:this._nextId++,jsonrpc:"2.0"};if(this._pendingBatch==null){this._pendingBatch=[]}const inflightRequest={request:request,resolve:null,reject:null};const promise=new Promise((resolve,reject)=>{inflightRequest.resolve=resolve;inflightRequest.reject=reject});this._pendingBatch.push(inflightRequest);if(!this._pendingBatchAggregator){this._pendingBatchAggregator=setTimeout(()=>{const batch=this._pendingBatch;this._pendingBatch=null;this._pendingBatchAggregator=null;const request=batch.map(inflight=>inflight.request);this.emit("debug",{action:"requestBatch",request:deepCopy(request),provider:this});return fetchJson(this.connection,JSON.stringify(request)).then(result=>{this.emit("debug",{action:"response",request:request,response:result,provider:this});batch.forEach((inflightRequest,index)=>{const payload=result[index];if(payload.error){const error=new Error(payload.error.message);error.code=payload.error.code;error.data=payload.error.data;inflightRequest.reject(error)}else{inflightRequest.resolve(payload.result)}})},error=>{this.emit("debug",{action:"response",error:error,request:request,provider:this});batch.forEach(inflightRequest=>{inflightRequest.reject(error)})})},10)}return promise}}"use strict";const logger$C=new Logger(version$m);const defaultApiKey$2="ETHERS_JS_SHARED";class NodesmithProvider extends UrlJsonRpcProvider{static getApiKey(apiKey){if(apiKey&&typeof apiKey!=="string"){logger$C.throwArgumentError("invalid apiKey","apiKey",apiKey)}return apiKey||defaultApiKey$2}static getUrl(network,apiKey){logger$C.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");let host=null;switch(network.name){case"homestead":host="https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";break;case"ropsten":host="https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";break;case"rinkeby":host="https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";break;case"goerli":host="https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";break;case"kovan":host="https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";break;default:logger$C.throwArgumentError("unsupported network","network",arguments[0])}return host+"?apiKey="+apiKey}}"use strict";const logger$D=new Logger(version$m);const defaultApplicationIds={homestead:"6004bcd10040261633ade990",ropsten:"6004bd4d0040261633ade991",rinkeby:"6004bda20040261633ade994",goerli:"6004bd860040261633ade992"};class PocketProvider extends UrlJsonRpcProvider{constructor(network,apiKey){if(apiKey==null){const n=getStatic(new.target,"getNetwork")(network);if(n){const applicationId=defaultApplicationIds[n.name];if(applicationId){apiKey={applicationId:applicationId,loadBalancer:true}}}if(apiKey==null){logger$D.throwError("unsupported network",Logger.errors.INVALID_ARGUMENT,{argument:"network",value:network})}}super(network,apiKey)}static getApiKey(apiKey){if(apiKey==null){logger$D.throwArgumentError("PocketProvider.getApiKey does not support null apiKey","apiKey",apiKey)}const apiKeyObj={applicationId:null,loadBalancer:false,applicationSecretKey:null};if(typeof apiKey==="string"){apiKeyObj.applicationId=apiKey}else if(apiKey.applicationSecretKey!=null){logger$D.assertArgument(typeof apiKey.applicationId==="string","applicationSecretKey requires an applicationId","applicationId",apiKey.applicationId);logger$D.assertArgument(typeof apiKey.applicationSecretKey==="string","invalid applicationSecretKey","applicationSecretKey","[REDACTED]");apiKeyObj.applicationId=apiKey.applicationId;apiKeyObj.applicationSecretKey=apiKey.applicationSecretKey;apiKeyObj.loadBalancer=!!apiKey.loadBalancer}else if(apiKey.applicationId){logger$D.assertArgument(typeof apiKey.applicationId==="string","apiKey.applicationId must be a string","apiKey.applicationId",apiKey.applicationId);apiKeyObj.applicationId=apiKey.applicationId;apiKeyObj.loadBalancer=!!apiKey.loadBalancer}else{logger$D.throwArgumentError("unsupported PocketProvider apiKey","apiKey",apiKey)}return apiKeyObj}static getUrl(network,apiKey){let host=null;switch(network?network.name:"unknown"){case"homestead":host="eth-mainnet.gateway.pokt.network";break;case"ropsten":host="eth-ropsten.gateway.pokt.network";break;case"rinkeby":host="eth-rinkeby.gateway.pokt.network";break;case"goerli":host="eth-goerli.gateway.pokt.network";break;default:logger$D.throwError("unsupported network",Logger.errors.INVALID_ARGUMENT,{argument:"network",value:network})}let url=null;if(apiKey.loadBalancer){url=`https://${host}/v1/lb/${apiKey.applicationId}`}else{url=`https://${host}/v1/${apiKey.applicationId}`}const connection={url:url};connection.headers={};if(apiKey.applicationSecretKey!=null){connection.user="";connection.password=apiKey.applicationSecretKey}return connection}isCommunityResource(){return this.applicationId===defaultApplicationIds[this.network.name]}}"use strict";const logger$E=new Logger(version$m);let _nextId=1;function buildWeb3LegacyFetcher(provider,sendFunc){return function(method,params){if(method=="eth_sign"&&(provider.isMetaMask||provider.isStatus)){method="personal_sign";params=[params[1],params[0]]}const request={method:method,params:params,id:_nextId++,jsonrpc:"2.0"};return new Promise((resolve,reject)=>{sendFunc(request,function(error,result){if(error){return reject(error)}if(result.error){const error=new Error(result.error.message);error.code=result.error.code;error.data=result.error.data;return reject(error)}resolve(result.result)})})}}function buildEip1193Fetcher(provider){return function(method,params){if(params==null){params=[]}if(method=="eth_sign"&&(provider.isMetaMask||provider.isStatus)){method="personal_sign";params=[params[1],params[0]]}return provider.request({method:method,params:params})}}class Web3Provider extends JsonRpcProvider{constructor(provider,network){logger$E.checkNew(new.target,Web3Provider);if(provider==null){logger$E.throwArgumentError("missing provider","provider",provider)}let path=null;let jsonRpcFetchFunc=null;let subprovider=null;if(typeof provider==="function"){path="unknown:";jsonRpcFetchFunc=provider}else{path=provider.host||provider.path||"";if(!path&&provider.isMetaMask){path="metamask"}subprovider=provider;if(provider.request){if(path===""){path="eip-1193:"}jsonRpcFetchFunc=buildEip1193Fetcher(provider)}else if(provider.sendAsync){jsonRpcFetchFunc=buildWeb3LegacyFetcher(provider,provider.sendAsync.bind(provider))}else if(provider.send){jsonRpcFetchFunc=buildWeb3LegacyFetcher(provider,provider.send.bind(provider))}else{logger$E.throwArgumentError("unsupported provider","provider",provider)}if(!path){path="unknown:"}}super(path,network);defineReadOnly(this,"jsonRpcFetchFunc",jsonRpcFetchFunc);defineReadOnly(this,"provider",subprovider)}send(method,params){return this.jsonRpcFetchFunc(method,params)}}"use strict";const logger$F=new Logger(version$m);function getDefaultProvider(network,options){if(network==null){network="homestead"}if(typeof network==="string"){const match=network.match(/^(ws|http)s?:/i);if(match){switch(match[1]){case"http":return new JsonRpcProvider(network);case"ws":return new WebSocketProvider(network);default:logger$F.throwArgumentError("unsupported URL scheme","network",network)}}}const n=getNetwork(network);if(!n||!n._defaultProvider){logger$F.throwError("unsupported getDefaultProvider network",Logger.errors.NETWORK_ERROR,{operation:"getDefaultProvider",network:network})}return n._defaultProvider({FallbackProvider:FallbackProvider,AlchemyProvider:AlchemyProvider,CloudflareProvider:CloudflareProvider,EtherscanProvider:EtherscanProvider,InfuraProvider:InfuraProvider,JsonRpcProvider:JsonRpcProvider,NodesmithProvider:NodesmithProvider,PocketProvider:PocketProvider,Web3Provider:Web3Provider,IpcProvider:IpcProvider},options)}var index$3=Object.freeze({__proto__:null,Provider:Provider,BaseProvider:BaseProvider,Resolver:Resolver,UrlJsonRpcProvider:UrlJsonRpcProvider,FallbackProvider:FallbackProvider,AlchemyProvider:AlchemyProvider,AlchemyWebSocketProvider:AlchemyWebSocketProvider,CloudflareProvider:CloudflareProvider,EtherscanProvider:EtherscanProvider,InfuraProvider:InfuraProvider,InfuraWebSocketProvider:InfuraWebSocketProvider,JsonRpcProvider:JsonRpcProvider,JsonRpcBatchProvider:JsonRpcBatchProvider,NodesmithProvider:NodesmithProvider,PocketProvider:PocketProvider,StaticJsonRpcProvider:StaticJsonRpcProvider,Web3Provider:Web3Provider,WebSocketProvider:WebSocketProvider,IpcProvider:IpcProvider,JsonRpcSigner:JsonRpcSigner,getDefaultProvider:getDefaultProvider,getNetwork:getNetwork,isCommunityResource:isCommunityResource,isCommunityResourcable:isCommunityResourcable,showThrottleMessage:showThrottleMessage,Formatter:Formatter});"use strict";const regexBytes=new RegExp("^bytes([0-9]+)$");const regexNumber=new RegExp("^(u?int)([0-9]*)$");const regexArray=new RegExp("^(.*)\\[([0-9]*)\\]$");const Zeros$1="0000000000000000000000000000000000000000000000000000000000000000";function _pack(type,value,isArray){switch(type){case"address":if(isArray){return zeroPad(value,32)}return arrayify(value);case"string":return toUtf8Bytes(value);case"bytes":return arrayify(value);case"bool":value=value?"0x01":"0x00";if(isArray){return zeroPad(value,32)}return arrayify(value)}let match=type.match(regexNumber);if(match){let size=parseInt(match[2]||"256");if(match[2]&&String(size)!==match[2]||size%8!==0||size===0||size>256){throw new Error("invalid number type - "+type)}if(isArray){size=256}value=BigNumber.from(value).toTwos(size);return zeroPad(value,size/8)}match=type.match(regexBytes);if(match){const size=parseInt(match[1]);if(String(size)!==match[1]||size===0||size>32){throw new Error("invalid bytes type - "+type)}if(arrayify(value).byteLength!==size){throw new Error("invalid value for "+type)}if(isArray){return arrayify((value+Zeros$1).substring(0,66))}return value}match=type.match(regexArray);if(match&&Array.isArray(value)){const baseType=match[1];const count=parseInt(match[2]||String(value.length));if(count!=value.length){throw new Error("invalid value for "+type)}const result=[];value.forEach(function(value){result.push(_pack(baseType,value,true))});return concat(result)}throw new Error("invalid type - "+type)}function pack$1(types,values){if(types.length!=values.length){throw new Error("type/value count mismatch")}const tight=[];types.forEach(function(type,index){tight.push(_pack(type,values[index]))});return hexlify(concat(tight))}function keccak256$1(types,values){return keccak256(pack$1(types,values))}function sha256$2(types,values){return sha256$1(pack$1(types,values))}const version$n="units/5.1.0";"use strict";const logger$G=new Logger(version$n);const names=["wei","kwei","mwei","gwei","szabo","finney","ether"];function commify(value){const comps=String(value).split(".");if(comps.length>2||!comps[0].match(/^-?[0-9]*$/)||comps[1]&&!comps[1].match(/^[0-9]*$/)||value==="."||value==="-."){logger$G.throwArgumentError("invalid value","value",value)}let whole=comps[0];let negative="";if(whole.substring(0,1)==="-"){negative="-";whole=whole.substring(1)}while(whole.substring(0,1)==="0"){whole=whole.substring(1)}if(whole===""){whole="0"}let suffix="";if(comps.length===2){suffix="."+(comps[1]||"0")}while(suffix.length>2&&suffix[suffix.length-1]==="0"){suffix=suffix.substring(0,suffix.length-1)}const formatted=[];while(whole.length){if(whole.length<=3){formatted.unshift(whole);break}else{const index=whole.length-3;formatted.unshift(whole.substring(index));whole=whole.substring(0,index)}}return negative+formatted.join(",")+suffix}function formatUnits(value,unitName){if(typeof unitName==="string"){const index=names.indexOf(unitName);if(index!==-1){unitName=3*index}}return formatFixed(value,unitName!=null?unitName:18)}function parseUnits(value,unitName){if(typeof value!=="string"){logger$G.throwArgumentError("value must be a string","value",value)}if(typeof unitName==="string"){const index=names.indexOf(unitName);if(index!==-1){unitName=3*index}}return parseFixed(value,unitName!=null?unitName:18)}function formatEther(wei){return formatUnits(wei,18)}function parseEther(ether){return parseUnits(ether,18)}"use strict";var utils$1=Object.freeze({__proto__:null,AbiCoder:AbiCoder,defaultAbiCoder:defaultAbiCoder,Fragment:Fragment,EventFragment:EventFragment,FunctionFragment:FunctionFragment,ParamType:ParamType,FormatTypes:FormatTypes,checkResultErrors:checkResultErrors,Logger:Logger,RLP:index,_fetchData:_fetchData,fetchJson:fetchJson,poll:poll,checkProperties:checkProperties,deepCopy:deepCopy,defineReadOnly:defineReadOnly,getStatic:getStatic,resolveProperties:resolveProperties,shallowCopy:shallowCopy,arrayify:arrayify,concat:concat,stripZeros:stripZeros,zeroPad:zeroPad,isBytes:isBytes,isBytesLike:isBytesLike,defaultPath:defaultPath,HDNode:HDNode,SigningKey:SigningKey,Interface:Interface,LogDescription:LogDescription,TransactionDescription:TransactionDescription,base58:Base58,base64:index$2,hexlify:hexlify,isHexString:isHexString,hexConcat:hexConcat,hexStripZeros:hexStripZeros,hexValue:hexValue,hexZeroPad:hexZeroPad,hexDataLength:hexDataLength,hexDataSlice:hexDataSlice,nameprep:nameprep,_toEscapedUtf8String:_toEscapedUtf8String,toUtf8Bytes:toUtf8Bytes,toUtf8CodePoints:toUtf8CodePoints,toUtf8String:toUtf8String,Utf8ErrorFuncs:Utf8ErrorFuncs,formatBytes32String:formatBytes32String,parseBytes32String:parseBytes32String,hashMessage:hashMessage,namehash:namehash,isValidName:isValidName,id:id,_TypedDataEncoder:TypedDataEncoder,getAddress:getAddress,getIcapAddress:getIcapAddress,getContractAddress:getContractAddress,getCreate2Address:getCreate2Address,isAddress:isAddress,formatEther:formatEther,parseEther:parseEther,formatUnits:formatUnits,parseUnits:parseUnits,commify:commify,computeHmac:computeHmac,keccak256:keccak256,ripemd160:ripemd160$1,sha256:sha256$1,sha512:sha512$1,randomBytes:randomBytes,shuffled:shuffled,solidityPack:pack$1,solidityKeccak256:keccak256$1,soliditySha256:sha256$2,splitSignature:splitSignature,joinSignature:joinSignature,accessListify:accessListify,parseTransaction:parse,serializeTransaction:serialize,getJsonWalletAddress:getJsonWalletAddress,computeAddress:computeAddress,recoverAddress:recoverAddress,computePublicKey:computePublicKey,recoverPublicKey:recoverPublicKey,verifyMessage:verifyMessage,verifyTypedData:verifyTypedData,mnemonicToEntropy:mnemonicToEntropy,entropyToMnemonic:entropyToMnemonic,isValidMnemonic:isValidMnemonic,mnemonicToSeed:mnemonicToSeed,get SupportedAlgorithm(){return SupportedAlgorithm},get UnicodeNormalizationForm(){return UnicodeNormalizationForm},get Utf8ErrorReason(){return Utf8ErrorReason},Indexed:Indexed});const version$o="ethers/5.1.4";"use strict";const logger$H=new Logger(version$o);var ethers=Object.freeze({__proto__:null,Signer:Signer,Wallet:Wallet,VoidSigner:VoidSigner,getDefaultProvider:getDefaultProvider,providers:index$3,BaseContract:BaseContract,Contract:Contract,ContractFactory:ContractFactory,BigNumber:BigNumber,FixedNumber:FixedNumber,constants:index$1,get errors(){return ErrorCode},logger:logger$H,utils:utils$1,wordlists:wordlists,version:version$o,Wordlist:Wordlist});"use strict";try{const anyGlobal=window;if(anyGlobal._ethers==null){anyGlobal._ethers=ethers}}catch(error){}

/***/ }),

/***/ "./login-auth.js":
/*!***********************!*\
  !*** ./login-auth.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "login": () => (/* binding */ login),
/* harmony export */   "handle_auth": () => (/* binding */ handle_auth)
/* harmony export */ });
/* harmony import */ var _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ethers-5.1.esm.min.js */ "./ethers-5.1.esm.min.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./utils.js");



async function login(wallet_address, web3)
{
    const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.genRandomLoginMsg)();

    const provider = new _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_0__.ethers.providers.Web3Provider(web3);
    const signer = provider.getSigner();
    const signature = await signer.signMessage(msg);

    await handle_auth(wallet_address, msg, signature);

    window.location.href = "/index";
}

async function handle_auth(wallet_address, msg, signature)
{
    console.log(wallet_address);
    console.log(signature);

    const data = {address: wallet_address, message: msg, signature: signature}

    await fetch('login', {
            method: 'post',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
}


/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addLeadingZeros)
/* harmony export */ });
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/formatters/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/formatters/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../_lib/getUTCDayOfYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js");
/* harmony import */ var _lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js");
/* harmony import */ var _lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
/* harmony import */ var _lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../_lib/getUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js");
/* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");
/* harmony import */ var _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lightFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js");







var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

var formatters = {
  // Era
  G: function (date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].y(date, token);
  },
  // Local week-numbering year
  Y: function (date, token, localize, options) {
    var signedWeekYear = (0,_lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function (date, token) {
    var isoWeekYear = (0,_lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date); // Padding

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    var year = date.getUTCFullYear();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(year, token.length);
  },
  // Quarter
  Q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function (date, token, localize, options) {
    var week = (0,_lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(week, token.length);
  },
  // ISO week of year
  I: function (date, token, localize) {
    var isoWeek = (0,_lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeek, token.length);
  },
  // Day of the month
  d: function (date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].d(date, token);
  },
  // Day of year
  D: function (date, token, localize) {
    var dayOfYear = (0,_lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dayOfYear, token.length);
  },
  // Day of week
  E: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].h(date, token);
  },
  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].H(date, token);
  },
  // Hour [0-11]
  K: function (date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Hour [1-24]
  k: function (date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Minute
  m: function (date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].m(date, token);
  },
  // Second
  s: function (date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].s(date, token);
  },
  // Fraction of second
  S: function (date, token) {
    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.floor(absOffset / 60), 2);
  var minutes = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters = {
  // Year
  y: function (date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function (date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(month + 1, 2);
  },
  // Day of the month
  d: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function (date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours(), token.length);
  },
  // Minute
  m: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function (date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fractionalSeconds, token.length);
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/longFormatters/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}

function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}

function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (longFormatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTimezoneOffsetInMilliseconds)
/* harmony export */ });
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCDayOfYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCISOWeekYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCISOWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
/* harmony import */ var _startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");




var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date).getTime() - (0,_startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCWeekYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCWeek/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");




var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeek(dirtyDate, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, options).getTime() - (0,_startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isSameUTCWeek)
/* harmony export */ });
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");

 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function isSameUTCWeek(dirtyDateLeft, dirtyDateRight, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeftStartOfWeek = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft, options);
  var dateRightStartOfWeek = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/protectedTokens/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isProtectedDayOfYearToken": () => (/* binding */ isProtectedDayOfYearToken),
/* harmony export */   "isProtectedWeekYearToken": () => (/* binding */ isProtectedWeekYearToken),
/* harmony export */   "throwProtectedError": () => (/* binding */ throwProtectedError)
/* harmony export */ });
var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/requiredArgs/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ requiredArgs)
/* harmony export */ });
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCISOWeekYear)
/* harmony export */ });
/* harmony import */ var _getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var year = (0,_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuary);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCISOWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var weekStartsOn = 1;
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCWeekYear)
/* harmony export */ });
/* harmony import */ var _getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.firstWeekContainsDate);
  var year = (0,_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeek, dirtyOptions);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/toInteger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/toInteger/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toInteger)
/* harmony export */ });
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/addMilliseconds/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/addMilliseconds/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addMilliseconds)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var timestamp = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate).getTime();
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
  return new Date(timestamp + amount);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/format/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/format/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
/* harmony import */ var _isValid_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../isValid/index.js */ "./node_modules/date-fns/esm/isValid/index.js");
/* harmony import */ var _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../locale/en-US/index.js */ "./node_modules/date-fns/esm/locale/en-US/index.js");
/* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../subMilliseconds/index.js */ "./node_modules/date-fns/esm/subMilliseconds/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_lib/format/formatters/index.js */ "./node_modules/date-fns/esm/_lib/format/formatters/index.js");
/* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_lib/format/longFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js");
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../_lib/getTimezoneOffsetInMilliseconds/index.js */ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js");
/* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_lib/protectedTokens/index.js */ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");









 // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The second argument is now required for the sake of explicitness.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   format(new Date(2016, 0, 1))
 *
 *   // v2.0.0 onward
 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
 *   ```
 *
 * - New format string API for `format` function
 *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
 *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
 *
 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);

  if (!(0,_isValid_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(originalDate);
  var utcDate = (0,_subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_7__["default"][firstCharacter];
      return longFormatter(substring, locale.formatLong, formatterOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }

    var formatter = _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_8__["default"][firstCharacter];

    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedWeekYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(substring, dirtyFormatStr, dirtyDate);
      }

      if (!options.useAdditionalDayOfYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedDayOfYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(substring, dirtyFormatStr, dirtyDate);
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/isDate/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  return value instanceof Date || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isValid/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/isValid/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isValid)
/* harmony export */ });
/* harmony import */ var _isDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../isDate/index.js */ "./node_modules/date-fns/esm/isDate/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Now `isValid` doesn't throw an exception
 *   if the first argument is not an instance of Date.
 *   Instead, argument is converted beforehand using `toDate`.
 *
 *   Examples:
 *
 *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
 *   |---------------------------|---------------|---------------|
 *   | `new Date()`              | `true`        | `true`        |
 *   | `new Date('2016-01-01')`  | `true`        | `true`        |
 *   | `new Date('')`            | `false`       | `false`       |
 *   | `new Date(1488370835081)` | `true`        | `true`        |
 *   | `new Date(NaN)`           | `false`       | `false`       |
 *   | `'2016-01-01'`            | `TypeError`   | `false`       |
 *   | `''`                      | `TypeError`   | `false`       |
 *   | `1488370835081`           | `TypeError`   | `true`        |
 *   | `NaN`                     | `TypeError`   | `false`       |
 *
 *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
 *   that try to coerce arguments to the expected type
 *   (which is also the case with other *date-fns* functions).
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);

  if (!(0,_isDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  return !isNaN(Number(date));
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildFormatLongFn)
/* harmony export */ });
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildLocalizeFn)
/* harmony export */ });
function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildMatchFn)
/* harmony export */ });
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildMatchPatternFn)
/* harmony export */ });
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/formatDistance/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/formatDistance/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatDistanceLocale = {
  lessThanXSeconds: {
    standalone: {
      one: 'weniger als 1 Sekunde',
      other: 'weniger als {{count}} Sekunden'
    },
    withPreposition: {
      one: 'weniger als 1 Sekunde',
      other: 'weniger als {{count}} Sekunden'
    }
  },
  xSeconds: {
    standalone: {
      one: '1 Sekunde',
      other: '{{count}} Sekunden'
    },
    withPreposition: {
      one: '1 Sekunde',
      other: '{{count}} Sekunden'
    }
  },
  halfAMinute: {
    standalone: 'halbe Minute',
    withPreposition: 'halben Minute'
  },
  lessThanXMinutes: {
    standalone: {
      one: 'weniger als 1 Minute',
      other: 'weniger als {{count}} Minuten'
    },
    withPreposition: {
      one: 'weniger als 1 Minute',
      other: 'weniger als {{count}} Minuten'
    }
  },
  xMinutes: {
    standalone: {
      one: '1 Minute',
      other: '{{count}} Minuten'
    },
    withPreposition: {
      one: '1 Minute',
      other: '{{count}} Minuten'
    }
  },
  aboutXHours: {
    standalone: {
      one: 'etwa 1 Stunde',
      other: 'etwa {{count}} Stunden'
    },
    withPreposition: {
      one: 'etwa 1 Stunde',
      other: 'etwa {{count}} Stunden'
    }
  },
  xHours: {
    standalone: {
      one: '1 Stunde',
      other: '{{count}} Stunden'
    },
    withPreposition: {
      one: '1 Stunde',
      other: '{{count}} Stunden'
    }
  },
  xDays: {
    standalone: {
      one: '1 Tag',
      other: '{{count}} Tage'
    },
    withPreposition: {
      one: '1 Tag',
      other: '{{count}} Tagen'
    }
  },
  aboutXWeeks: {
    standalone: {
      one: 'etwa 1 Woche',
      other: 'etwa {{count}} Wochen'
    },
    withPreposition: {
      one: 'etwa 1 Woche',
      other: 'etwa {{count}} Wochen'
    }
  },
  xWeeks: {
    standalone: {
      one: '1 Woche',
      other: '{{count}} Wochen'
    },
    withPreposition: {
      one: '1 Woche',
      other: '{{count}} Wochen'
    }
  },
  aboutXMonths: {
    standalone: {
      one: 'etwa 1 Monat',
      other: 'etwa {{count}} Monate'
    },
    withPreposition: {
      one: 'etwa 1 Monat',
      other: 'etwa {{count}} Monaten'
    }
  },
  xMonths: {
    standalone: {
      one: '1 Monat',
      other: '{{count}} Monate'
    },
    withPreposition: {
      one: '1 Monat',
      other: '{{count}} Monaten'
    }
  },
  aboutXYears: {
    standalone: {
      one: 'etwa 1 Jahr',
      other: 'etwa {{count}} Jahre'
    },
    withPreposition: {
      one: 'etwa 1 Jahr',
      other: 'etwa {{count}} Jahren'
    }
  },
  xYears: {
    standalone: {
      one: '1 Jahr',
      other: '{{count}} Jahre'
    },
    withPreposition: {
      one: '1 Jahr',
      other: '{{count}} Jahren'
    }
  },
  overXYears: {
    standalone: {
      one: 'mehr als 1 Jahr',
      other: 'mehr als {{count}} Jahre'
    },
    withPreposition: {
      one: 'mehr als 1 Jahr',
      other: 'mehr als {{count}} Jahren'
    }
  },
  almostXYears: {
    standalone: {
      one: 'fast 1 Jahr',
      other: 'fast {{count}} Jahre'
    },
    withPreposition: {
      one: 'fast 1 Jahr',
      other: 'fast {{count}} Jahren'
    }
  }
};

var formatDistance = function (token, count, options) {
  var result;
  var tokenValue = options !== null && options !== void 0 && options.addSuffix ? formatDistanceLocale[token].withPreposition : formatDistanceLocale[token].standalone;

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', String(count));
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return 'vor ' + result;
    }
  }

  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatDistance);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/formatLong/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/formatLong/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");

// DIN 5008: https://de.wikipedia.org/wiki/Datumsformat#DIN_5008
var dateFormats = {
  full: 'EEEE, do MMMM y',
  // Montag, 7. Januar 2018
  long: 'do MMMM y',
  // 7. Januar 2018
  medium: 'do MMM y',
  // 7. Jan. 2018
  short: 'dd.MM.y' // 07.01.2018

};
var timeFormats = {
  full: 'HH:mm:ss zzzz',
  long: 'HH:mm:ss z',
  medium: 'HH:mm:ss',
  short: 'HH:mm'
};
var dateTimeFormats = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: '{{date}} {{time}}',
  short: '{{date}} {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/formatRelative/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/formatRelative/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatRelativeLocale = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: 'P'
};

var formatRelative = function (token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatRelative);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/localize/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/localize/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");

var eraValues = {
  narrow: ['v.Chr.', 'n.Chr.'],
  abbreviated: ['v.Chr.', 'n.Chr.'],
  wide: ['vor Christus', 'nach Christus']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal']
}; // Note: in German, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  wide: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
}; // https://st.unicode.org/cldr-apps/v#/de/Gregorian/

var formattingMonthValues = {
  narrow: monthValues.narrow,
  abbreviated: ['Jan.', 'Feb.', 'Mrz', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'],
  wide: monthValues.wide
};
var dayValues = {
  narrow: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  short: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
  abbreviated: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
  wide: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag']
}; // https://www.unicode.org/cldr/charts/32/summary/de.html#1881

var dayPeriodValues = {
  narrow: {
    am: 'vm.',
    pm: 'nm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'Morgen',
    afternoon: 'Nachm.',
    evening: 'Abend',
    night: 'Nacht'
  },
  abbreviated: {
    am: 'vorm.',
    pm: 'nachm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'Morgen',
    afternoon: 'Nachmittag',
    evening: 'Abend',
    night: 'Nacht'
  },
  wide: {
    am: 'vormittags',
    pm: 'nachmittags',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'Morgen',
    afternoon: 'Nachmittag',
    evening: 'Abend',
    night: 'Nacht'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'vm.',
    pm: 'nm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'morgens',
    afternoon: 'nachm.',
    evening: 'abends',
    night: 'nachts'
  },
  abbreviated: {
    am: 'vorm.',
    pm: 'nachm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'morgens',
    afternoon: 'nachmittags',
    evening: 'abends',
    night: 'nachts'
  },
  wide: {
    am: 'vormittags',
    pm: 'nachmittags',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'morgens',
    afternoon: 'nachmittags',
    evening: 'abends',
    night: 'nachts'
  }
};

var ordinalNumber = function (dirtyNumber) {
  var number = Number(dirtyNumber);
  return number + '.';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    formattingValues: formattingMonthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/match/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/match/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");


var matchOrdinalNumberPattern = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
var parseEraPatterns = {
  any: [/^v/i, /^n/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(j[a]n|feb|mr[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
  wide: /^(januar|februar|mrz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^j[a]/i, /^f/i, /^mr/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
var parseDayPatterns = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i // will never be matched. Night is matched by `pm`

  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/formatDistance/index.js");
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/formatLong/index.js");
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/formatRelative/index.js");
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/localize/index.js");
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/match/index.js");






/**
 * @type {Locale}
 * @category Locales
 * @summary German locale.
 * @language German
 * @iso-639-2 deu
 * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
 * @author Asia [@asia-t]{@link https://github.com/asia-t}
 * @author Van Vuong Ngo [@vanvuongngo]{@link https://github.com/vanvuongngo}
 * @author RomanErnst [@pex]{@link https://github.com/pex}
 * @author Philipp Keck [@Philipp91]{@link https://github.com/Philipp91}
 */
var locale = {
  code: 'de',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 1
    /* Monday */
    ,
    firstWeekContainsDate: 4
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function (token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatDistance);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function (token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatRelative);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function (dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");


var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js");
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js");
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js");
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js");
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js");






/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatDistance)
/* harmony export */ });
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xSeconds: {
    one: '1 ',
    other: '{{count}} '
  },
  halfAMinute: '',
  lessThanXMinutes: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMinutes: {
    one: '1 ',
    other: '{{count}} '
  },
  xHours: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXHours: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xDays: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXWeeks: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xWeeks: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXMonths: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMonths: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xYears: {
    one: '1 ',
    other: '{{count}} '
  },
  overXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  almostXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return result + '';
    } else {
      return result + '';
    }
  }

  return result;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");

var dateFormats = {
  full: "y''M''d'' EEEE",
  long: "y''M''d''",
  medium: 'yyyy-MM-dd',
  short: 'yy-MM-dd'
};
var timeFormats = {
  full: 'zzzz a h:mm:ss',
  long: 'z a h:mm:ss',
  medium: 'a h:mm:ss',
  short: 'a h:mm'
};
var dateTimeFormats = {
  full: '{{date}} {{time}}',
  long: '{{date}} {{time}}',
  medium: '{{date}} {{time}}',
  short: '{{date}} {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatRelative)
/* harmony export */ });
/* harmony import */ var _lib_isSameUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../_lib/isSameUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js");


function checkWeek(_date, _baseDate, _options, baseFormat) {
  if ((0,_lib_isSameUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_date, _baseDate, _options)) {
    return baseFormat; // in same week
  } else if (_date.getTime() > _baseDate.getTime()) {
    return "''" + baseFormat; // in next week
  }

  return "''" + baseFormat; // in last week
}

var formatRelativeLocale = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: 'PP p'
};
function formatRelative(token, _date, _baseDate, _options) {
  var format = formatRelativeLocale[token];

  if (typeof format === 'function') {
    return format(_date, _baseDate, _options, 'eeee p');
  }

  return format;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");

var eraValues = {
  narrow: ['', ''],
  abbreviated: ['', ''],
  wide: ['', '']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['', '', '', ''],
  wide: ['', '', '', '']
};
var monthValues = {
  narrow: ['', '', '', '', '', '', '', '', '', '', '', ''],
  abbreviated: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  wide: ['', '', '', '', '', '', '', '', '', '', '', '']
};
var dayValues = {
  narrow: ['', '', '', '', '', '', ''],
  short: ['', '', '', '', '', '', ''],
  abbreviated: ['', '', '', '', '', '', ''],
  wide: ['', '', '', '', '', '', '']
};
var dayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};

function ordinalNumber(dirtyNumber, dirtyOptions) {
  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`:
  //
  //   var options = dirtyOptions || {}
  //   var unit = String(options.unit)
  //
  // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'
  var number = Number(dirtyNumber);
  var options = dirtyOptions || {};
  var unit = String(options.unit);

  switch (unit) {
    case 'date':
      return number.toString() + '';

    case 'hour':
      return number.toString() + '';

    case 'minute':
      return number.toString() + '';

    case 'second':
      return number.toString() + '';

    default:
      return ' ' + number.toString();
  }
}

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");


var matchOrdinalNumberPattern = /^(\s*)?\d+(|||)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^()/i,
  abbreviated: /^()/i,
  wide: /^(|)/i
};
var parseEraPatterns = {
  any: [/^()/i, /^()/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
var parseQuarterPatterns = {
  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
var matchMonthPatterns = {
  narrow: /^(|||||||||[])/i,
  abbreviated: /^(|||||||||[]|\d|1[12])/i,
  wide: /^(|||||||||[])/i
};
var parseMonthPatterns = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^(?!(|))/i, /^/i, /^/i],
  any: [/^|1/i, /^|2/i, /^|3/i, /^|4/i, /^|5/i, /^|6/i, /^|7/i, /^|8/i, /^|9/i, /^(?!(|))|10/i, /^|11/i, /^|12/i]
};
var matchDayPatterns = {
  narrow: /^[]/i,
  short: /^[]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
var parseDayPatterns = {
  any: [//i, //i, //i, //i, //i, //i, //i]
};
var matchDayPeriodPatterns = {
  any: /^(?|?||[]|?||?||)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^?/i,
    pm: /^?/i,
    midnight: /^/i,
    noon: /^[]/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^?/i,
    night: /^/i
  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js");
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js");
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js");
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js");
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js");





/**
 * @type {Locale}
 * @category Locales
 * @summary Chinese Simplified locale.
 * @language Chinese Simplified
 * @iso-639-2 zho
 * @author Changyu Geng [@KingMario]{@link https://github.com/KingMario}
 * @author Song Shuoyun [@fnlctrl]{@link https://github.com/fnlctrl}
 * @author sabrinaM [@sabrinamiao]{@link https://github.com/sabrinamiao}
 * @author Carney Wu [@cubicwork]{@link https://github.com/cubicwork}
 * @author Terrence Lam [@skyuplam]{@link https://github.com/skyuplam}
 */

var locale = {
  code: 'zh-CN',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 1
    /* Monday */
    ,
    firstWeekContainsDate: 4
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),

/***/ "./node_modules/date-fns/esm/subMilliseconds/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/subMilliseconds/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ subMilliseconds)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addMilliseconds/index.js */ "./node_modules/date-fns/esm/addMilliseconds/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
  return (0,_addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/toDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/toDate/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ }),

/***/ "./utils.js":
/*!******************!*\
  !*** ./utils.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getRandomInt": () => (/* binding */ getRandomInt),
/* harmony export */   "genRandomLoginMsg": () => (/* binding */ genRandomLoginMsg),
/* harmony export */   "error_msg": () => (/* binding */ error_msg),
/* harmony export */   "sleep": () => (/* binding */ sleep)
/* harmony export */ });
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
};

const genRandomHex = size => [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');

function genRandomLoginMsg() {
    // E.g. "LogIn-fab164a3-2f63-000d-159b-3b86868d8ffe"
    return "LogIn-" + genRandomHex(8) + "-" + genRandomHex(4) + "-" + genRandomHex(4) + "-" + genRandomHex(4) + "-" + genRandomHex(12);
}



function error_msg(msg, category) {
  // Make nice error messages using Bootstrap alerts
  const insert_str = "<div class='alert alert-dismissable fade show alert-" + category + "'> " + msg +
                     "  <button type='button' class='btn-close' data-bs-dismiss='alert' aria-label='Close' style='float: right'>" +
                      "   </button> </div>";
  console.log(insert_str);
  document.getElementById("alert-messages").insertAdjacentHTML('beforeend', insert_str);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!***********************!*\
  !*** ./statistics.js ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/format/index.js");
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! date-fns/locale */ "./node_modules/date-fns/esm/locale/en-US/index.js");
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns/locale */ "./node_modules/date-fns/esm/locale/de/index.js");
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns/locale */ "./node_modules/date-fns/esm/locale/zh-CN/index.js");


const locale_obj = {
    "en": date_fns_locale__WEBPACK_IMPORTED_MODULE_0__["default"],
    "en-US": date_fns_locale__WEBPACK_IMPORTED_MODULE_0__["default"],
    "de": date_fns_locale__WEBPACK_IMPORTED_MODULE_1__["default"],
    "zh": date_fns_locale__WEBPACK_IMPORTED_MODULE_2__["default"],
    "zh-CN": date_fns_locale__WEBPACK_IMPORTED_MODULE_2__["default"]
}

function getLang() {
    if (navigator.languages != undefined) 
      return navigator.languages[0]; 
    return navigator.language;
};

function getLocale() {
    const lang = getLang();
    let locale = locale_obj[lang];

    if (!locale)
        locale = locale_obj["en"];
    
    return locale;
};

const locale = getLocale();
// console.log(locale);

function dateTimeFormatter(timestamp) {
    return (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(new Date(timestamp), "dd/MM/yyyy HH:mm");
    //return format(new Date(timestamp), "Pp", {"locale": locale_obj[locale]});
}

window.dateTimeFormatter = dateTimeFormatter;

document.addEventListener("DOMContentLoaded", function (event) {
    try {
        $("#table-stats-metamons").on("post-header.bs.table", adjustExportButton);
    }
    catch (error) {}
});

function adjustExportButton () {
    const export_elements = document.getElementsByClassName("export");
    if (export_elements.length > 0) {
        const element = export_elements[0];
        const button = element.getElementsByTagName("button")[0];
        button.textContent = "Export";

        // If data is not available, disable button
        if (! ($("#table-stats-metamons")[0].dataset.url))
            button.disabled = true
    }

    adjustTable();
}

function adjustTable () {
    // Makes borders in the middle of the table head to separate "Metamon" and "Results"
    const el = $(".tr-class-1")[0];
    el.getElementsByTagName("th")[1].style.borderLeft = "2px solid #444444";
    const el2 = $(".tr-class-2")[0];
    el2.getElementsByTagName("th")[5].style.borderLeft = "2px solid #444444";
}
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!********************!*\
  !*** ./manager.js ***!
  \********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./utils.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);



function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
};

async function make_request() {
    var kvpairs = {};
    const form = document.getElementById("manager-form");
    for ( var i = 0; i < form.elements.length; i++ ) {
        var e = form.elements[i]; 
        if (e.type == "checkbox")
            kvpairs[e.name] = e.checked ? "on" : "off";
        else
            kvpairs[e.name] = e.value;
    };

    const options = {
        method: 'post',
        credentials: 'same-origin',
        headers: {
          'X-CSRF-TOKEN': getCookie('csrf_access_token'),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(kvpairs)
    };

    await fetch('/manager', options);
};

if (document.getElementById("battle-submit-button")) {
    document.getElementById("battle-submit-button").onclick = async ()=>{
        //await make_request();
        await startBattles();
    };
}

async function log (text) {
    const options = {
        method: 'post',
        headers: {
          'X-CSRF-TOKEN': getCookie('csrf_access_token'),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(text)
    };

    await fetch('/log', options);

}

async function fetch_loop(url, method, data, headers) {
    //let h =  {'Content-Type': 'application/json'};
    let h =  {};
	if (headers) {
		Object.assign(h, headers);
	};

	const options = {
        method: method,
        headers: h,
        body: data
    };


	for (let n = 0; n < 5; n++) {
        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(0.5);
		try {
            // await log("Fetch " + url + " " + JSON.stringify(options));
			const response = await fetch(url, options);
            const response_json = await response.json();
            //await log("Response " + JSON.stringify(response_json));
            return response_json;
		} catch (err) {
			await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(2);
		}
	}
	
};

function urlencoded(obj) {
    lodash__WEBPACK_IMPORTED_MODULE_1__.result = lodash__WEBPACK_IMPORTED_MODULE_1___default().join(lodash__WEBPACK_IMPORTED_MODULE_1___default().map(Object.entries(obj), function(o) {return o[0] + "=" + o[1]}), "&");
    return lodash__WEBPACK_IMPORTED_MODULE_1__.result;
}

// URLs to make api calls
const BASE_URL = "https://metamon-api.radiocaca.com/usm-api";
const TOKEN_URL = BASE_URL + "/login";
const LIST_MONSTER_URL = BASE_URL + "/getWalletPropertyBySymbol";
const CHANGE_FIGHTER_URL = BASE_URL + "/isFightMonster";
const START_FIGHT_URL = BASE_URL + "/startBattle";
const LIST_BATTLER_URL = BASE_URL + "/getBattelObjects";
const WALLET_PROPERTY_LIST = BASE_URL + "/getWalletPropertyList";
const LVL_UP_URL = BASE_URL + "/updateMonster";
const MINT_EGG_URL = BASE_URL + "/composeMonsterEgg";

class MetamonIsland {
	constructor(address, sign, msg) {
		this.address = address;
		this.sign = sign;
		this.msg = msg;
		
        this.not_enough_money = false;
        this.total_bp_num = 0;
        this.total_success = 0;
        this.total_fail = 0;
        this.mtm_stats = [];
        this.token = null;
	}
	
	async initToken() {
		const payload = "address=" + this.address + "&sign=" + this.sign + "&msg=" + this.msg;
        const response = await fetch_loop(TOKEN_URL, "post", payload, {"Content-Type": "application/x-www-form-urlencoded"});

        if (response["code"] == "SUCCESS") {
            this.token = response["data"];
            return true;
        }
        else {
            return false;
        }    
	}
	
    async changeFighter(monster_id) {
        // Switch to next metamon if you have few
        const payload = {
            "metamonId": monster_id,
            "address": this.address,
        };
        await fetch_loop(CHANGE_FIGHTER_URL, "post", urlencoded(payload), this.headersTokenAndCT());
	}
	
	async listOpponents(monster_id, front=1) {
        // Obtain list of opponents
        const payload = {
            "address": this.address,
            "metamonId": monster_id,
            "front": front,
        };

        const response = await fetch_loop(LIST_BATTLER_URL, "post", urlencoded(payload), this.headersTokenAndCT());
        return response["data"]["objects"];
	}

	headersToken () {
		return {"accessToken": this.token};	
	}

    headersTokenAndCT () {
		return {"Content-Type": "application/x-www-form-urlencoded",
                "accessToken": this.token};	
	}

	/**
	Obtain list of Metamons in the wallet
	 */
	async updateWallet() {
        let data = [];
        let page = 1;
        while (true) {
            const payload = {"address": this.address, "page": page, "pageSize": 60};
            const response = await fetch_loop(WALLET_PROPERTY_LIST, "post", urlencoded(payload), this.headersTokenAndCT());
            if (response["code"] != "SUCCESS")
                break;

			const mtms = response["data"]["metamonList"];
            if (mtms.length > 0) {
                Object.assign(data, mtms);
                page += 1;
			}
            else
                break;
		};
		
        this.metamons = data;
        return data;
	}

    /**
     * Return the index of a metamon with token monster_token_id in the list of metamons.
     */
    metamon_idx(monster_token_id) {
        let count = 0;
        for (let monster of this.metamons) {
            if (monster.tokenId == monster_token_id) {
                return count;
            }
            count++;
        }
    }
	
	/**
	Perform all battles of a list of monsters
	 */
	async battle (monsters, strategy="weakest", levelup=true) {
        // const wallet_monsters = this.updateWallet();
        this.total_level_ups = 0;

        for (let monster of monsters) {
			if (monster.tear == 0)
				continue;

            const tear = monster.tear;
            // level = monster.get("level")
            const battlers = await this.listOpponents(monster.id);
            const battler = MetamonIsland.pickOpponent(battlers, strategy);
            const target_monster_id = battler.id;

            await this.changeFighter(monster.id);
            // Workaround: Pass the index of the monster in the current table
            // This is required because updateMetamonTable uses metamon objects at the beginning of the battles
            // However, the list of metamons in mi gets updated after level ups, thus it would not find the metamons anymore
            const monster_table_idx = this.metamon_idx(monster.tokenId);
            await this.battleMetamon(monster, monster_table_idx, target_monster_id, tear, levelup);

            if (this.not_enough_money)
                break;
		}
        
		const total_count = this.total_success + this.total_fail;
        let success_percent = 0.0;
        if (total_count > 0) {
            success_percent = this.total_success / total_count;
		};

        // Stats of all battles
        const stats = {
            "won": this.total_success,
            "defeats": this.total_fail,
            "win_rate": success_percent,
            "fragments": this.total_bp_num,
            "level_ups": this.total_level_ups,
            "timestamp": Date.now()
        };

        return [stats, this.mtm_stats];
	}
	
    /**
	Main method for battelng with a specific metamon
	 */
	async battleMetamon(monster, monster_table_idx, target_monster_id, loop_count=1, levelup=true) {
        let success = 0;
        let fail = 0;
        let total_bp_fragment_num = 0;
        const my_monster_id = monster.id;
        const my_monster_token_id = parseInt(monster.tokenId);
        let my_level = monster.level;
        const my_power = monster.sca;
        let battle_level = MetamonIsland.pickBattleLevel(my_level);
        const init_tear = monster.tear;
        let experience = monster.exp;
        let exp_to_next = monster.expMax;

        for (let count = 0; count < loop_count; count++) {
            const payload = {
                "monsterA": my_monster_id,
                "monsterB": target_monster_id,
                "address": this.address,
                "battleLevel": battle_level,
            };
            const response = await fetch_loop(START_FIGHT_URL, "post", urlencoded(payload), this.headersTokenAndCT());

            const code = response.code;
            if (code == "BATTLE_NOPAY") {
                this.not_enough_money = true;
				(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.error_msg)("Not enough uRACA to play on Metamon Island!", "danger");
                break;
			}
            else if (code == "SUCCESS") {
                const data = response.data;
                const fight_result = data.challengeResult;
                const bp_fragment_num = data.bpFragmentNum;
                const experience_incr = data.challengeExp;

                if (levelup) {
                    // Try to level up
                    const payload = {"nftId": my_monster_id, "address": this.address}
                    const res = await fetch_loop(LVL_UP_URL, "post",  urlencoded(payload), this.headersTokenAndCT());
                    const code = res.code;
                    if (code == "SUCCESS") {
                        my_level += 1;
                        // Update league level if new level is 21 or 41
                        battle_level = MetamonIsland.pickBattleLevel(my_level);
                        this.total_level_ups += 1;
                        experience = experience - exp_to_next;
                        // Now we need to update the metamon to update the expMax field
                        const all_monsters = await this.updateWallet();
                        exp_to_next = all_monsters.find(element => element.tokenId == my_monster_token_id).expMax;
                    };
                };

                this.total_bp_num += bp_fragment_num;
                total_bp_fragment_num += bp_fragment_num;
                experience += experience_incr;
                if (fight_result) {
                    success += 1;
                    this.total_success += 1;
                } else {
                    fail += 1;
                    this.total_fail += 1;
                }

                // Change state in UI
                updateMetamonTable(monster, monster_table_idx, my_level, experience, init_tear - count - 1, progress_from_tear(init_tear - count - 1), success, total_bp_fragment_num);
            };
        };

        const curr_mtm_stats = {
            "metamon_id": my_monster_token_id,
            "league_level": battle_level,
            "battles": loop_count,
            "power": my_power,
            "experience": experience,
            "metamon_level": my_level,
            "rarity": monster.rarity,
            "won": success,
            "fragments": total_bp_fragment_num,
            "timestamp": Date.now()
        }
        this.mtm_stats.push(curr_mtm_stats);
    }
	
	async mintEggs () {
        // await this.init_token();

        const payload = {"address": this.address};

        let minted_eggs = 0;
        while (true) {
            const res = await fetch_loop(MINT_EGG_URL, "post", urlencoded(payload), this.headersTokenAndCT());
            const code = res["code"];
            if (code != "SUCCESS")
                break;
            minted_eggs += 1;
		}
        console.log("Minted Eggs Total: " + minted_eggs);
        return minted_eggs;
	}
	
	// Static methods
	
	/**
	Pick an opponent according to a given strategy ("weakest" or "random")
	 */
	static pickOpponent(monsters_list, strategy="weakest") {
	    let battlers = [];
		for (let monster of monsters_list) {
			if (monster["rarity"] == "N")
				battlers.push(monster);
		};
		
		if (battlers.length == 0) {
			for (let monster of monsters_list) {
				if (monster["rarity"] == "R")
					battlers.push(monster);
			};		
		};
	        
	
	    if (strategy == "weakest")
	        return MetamonIsland.pickOpponentWeakest(battlers);
		else if (strategy == "random")
	        return MetamonIsland.pickOpponentRandom(battlers);		
	};
	
	static pickOpponentRandom(battlers) {
	    return battlers[(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getRandomInt)(len(battlers))];
	};
	
	static pickOpponentWeakest(battlers) {
	    let best_battler = battlers[0];
	    let score_min = best_battler["sca"];
	    
		for (let battler of battlers) {
	        if (battler["sca"] < score_min) {
	            best_battler = battler;
	            score_min = battler["sca"];
			};
		};
	    return best_battler;
	};
	
	/**
	Pick a battle league (currently there are 3!)
	 */
	static pickBattleLevel (level=1) {
	    if ((21 <= level) && (level <= 40)) {
	        return 2;
		} else if ((41 <= level) && (level <= 60)) {
	        return 3;
		}
		
	    return 1;
	};
};

let mi = null;
const MAX_TEAR = 20;

function progress_from_tear(tear) {
    return (MAX_TEAR - tear)*100.0/MAX_TEAR;
}

async function loadMetamons (address, sign, msg) {
    enable_submit_button(false);
    show_spinner(true);
    button_text("Loading...");

    await log("Loading Metamon table " + JSON.stringify({"a": 1, "b": 2}));

    let success = true;
    if (mi == null) {
        mi = new MetamonIsland(address, sign, msg);
        success = await mi.initToken();

        if (!success) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.error_msg)("Could not login to Metamon Island!", "danger");
        }
    }

    if (success) {
        const metamons = await mi.updateWallet();
        const progress = lodash__WEBPACK_IMPORTED_MODULE_1___default().map(metamons, function (m) {return progress_from_tear(m.tear);});
        const wins = Array.from('-'.repeat(metamons.length));
        const fragments = Array.from('-'.repeat(metamons.length));

        fillMetamonTable(metamons, progress, wins, fragments);
    }

    enable_submit_button(true);
    show_spinner(false);
    button_text("Start battles!");
}

async function startBattles () {
    if (!mi)
        return;

    enable_submit_button(false);
    show_spinner(true);
    button_text("Battling...");

    const strategy = document.getElementById("strategy").value;
    const levelup = document.getElementById("levelup").checked;
    const minteggs = document.getElementById("minteggs").checked;
    const statistics = document.getElementById("statistics").checked;

    let metamons_to_play = [];
    let count = 0;
    for (let metamon of mi.metamons) {
        if (document.getElementById("mtm" + count).checked) {
            metamons_to_play.push(metamon);
        }
        count++;
    }

    const result = await mi.battle(metamons_to_play, strategy, levelup);

    if (result.length > 0) {
        const stats = result[0];
        const mtm_stats = result[1];
        
        stats["minted_eggs"] = 0;
        if (minteggs) {
            const minted_eggs = await mi.mintEggs();
            stats["minted_eggs"] = minted_eggs;
        }

        if (statistics)
            sendStats([stats, mtm_stats, statistics]);

        fillSummaryTable(stats);
        show_battle_results();
    }
    await mi.updateWallet();
    
    enable_submit_button(true);
    show_spinner(false);
    button_text("Start battles!");
}

async function sendStats(data) {
    await fetch('stats', {
        method: 'post',
        headers: {'Content-Type': 'application/json',
                  'X-CSRF-TOKEN': getCookie('csrf_access_token')},
        body: JSON.stringify(data)
    });
}

// User Interface

function fillMetamonTable (metamons, progress, wins, fragments) {
    const table_body = document.getElementById("metamon_table_body");

    let count = 0;
	for (let metamon of metamons) {
		// <tr>	
		const row = document.createElement('tr');

        // Checkbox
        row.insertAdjacentHTML("beforeend", '<td> <input id="mtm' + count + '" name="mtm' + count + '" type="checkbox" class="select-item checkbox form-check-input" checked> </td>');
        // Data: Token Id
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.tokenId + ' </td>');
        // Data: Pic
        row.insertAdjacentHTML("beforeend", '<td> <img src="' + metamon.imageUrl  + '" alt="' + metamon.tokenId + '"></td>');
        // Data: Rarity
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.rarity + '</td>');
        // Data: Power
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.sca + '</td>');
        // Data: Level
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.level + '<i>/' + metamon.levelMax + '</i></td>');
        // Data: Experience
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.exp + '</td>');
        // Data: Experience
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.tear + '<i>/20</i></td>');
        // Data: Progress bar
        let add_class = "";
        if (progress[count] == 100) {
            add_class = "progress_finished"
        };
        row.insertAdjacentHTML("beforeend", '<td> <div class="progress"> <div class="progress-bar ' + add_class + '" role="progressbar" style="width: ' + progress[count] + '%" aria-valuenow="' + progress[count] + '" aria-valuemin="0" aria-valuemax="100"></div></div></td>');
        // Data: Wins
        row.insertAdjacentHTML("beforeend", '<td>' + wins[count] + '</td>');
        // Data: Fragments
        row.insertAdjacentHTML("beforeend", '<td>' + fragments[count] + '</td>');

        // Append a new row to table
        table_body.appendChild(row);
        count++;
	}

    setCheckboxOnClickEvents();
};

function updateMetamonTable (metamon, monster_table_idx, level, experience, tear, progress, wins, fragments) {
    const table_body = document.getElementById("metamon_table_body");

    const tr_tag = table_body.getElementsByTagName("tr")[monster_table_idx];

    if (!tr_tag) {
        console.log(table_body, monster_table_idx, table_body.getElementsByTagName("tr").length);
    }

    const td_tags = tr_tag.getElementsByTagName("td");

    td_tags[5].innerHTML = level + '<i>/' + metamon.levelMax + '</i>';
    td_tags[6].innerHTML = String(experience);
    td_tags[7].innerHTML = tear + '<i>/' + MAX_TEAR + '</i>';
    let add_class = "";
    if (progress == 100) {
        add_class = "progress_finished"
    };
    td_tags[8].innerHTML = '<div class="progress"> <div class="progress-bar ' + add_class + '" role="progressbar" style="width: ' + progress + '%" aria-valuenow="' + progress + '" aria-valuemin="0" aria-valuemax="100"></div></div>';
    td_tags[9].innerHTML = String(wins);
    td_tags[10].innerHTML = String(fragments);
}

function fillSummaryTable (stats) {
    const table_body = document.getElementById("battle-results");

    const stats_list = [stats["won"] + stats["defeats"], stats["won"], stats["defeats"], (Math.round(stats["win_rate"] * 1000) / 10).toFixed(1) + "%", 
                        stats["fragments"], stats["minted_eggs"], stats["level_ups"]];
    const tr_tags = table_body.getElementsByTagName("tr");
    for (let n = 0 ; n < stats_list.length ; n++) {
        const td_tag = tr_tags[n].getElementsByTagName("td")[1];
        td_tag.innerHTML = String(stats_list[n]);
    }
};

function button_text (label) {
    document.getElementById("battle-submit-button-text").textContent = label;
}

function enable_submit_button (value) {
    document.getElementById("battle-submit-button").disabled = !value;
}

function show_spinner (value) {
    let str_val = value ? "" : "none";
    document.getElementById("battle-submit-button").getElementsByClassName("spinner-border")[0].style.display = str_val;
}

function show_battle_results () {
    document.getElementById("battle-submit-button").style.display = "block";
}

function setCheckboxOnClickEvents() {
    //column checkbox select all or cancel
    document.getElementsByClassName("select-all")[0].onclick = function() {
        var checked = this.checked;
        [].forEach.call(document.getElementsByClassName('select-item'), function(item, index) {
            item.checked = checked;
        });
    };

    //check selected items
    [].forEach.call(document.getElementsByClassName("select-item"), (item, index) => {
        item.onclick = function() {
            const checked = this.checked;
            let all = document.getElementsByClassName("select-all")[0];
            // number of boxes
            const total = document.getElementsByClassName("select-item").length;
            // number of checked boxes
            let num_checked = document.querySelectorAll('.select-item:checked').length;
            all.checked = num_checked===total;
        };
    });
};

var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
  return new bootstrap.Tooltip(tooltipTriggerEl)
})


window.loadMetamons = loadMetamons;
//window.startBattles = startBattles;
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!*********************!*\
  !*** ./mm-login.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _login_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login-auth.js */ "./login-auth.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./utils.js");



const BSC_CHAIN_ID = 56;

[].forEach.call(document.getElementsByClassName("metamask-login"), (item, index) => {
    item.onclick = async ()=>{
        try  {
            if (!await check_metamask()) {
                return false;
            }
            if (!check_chain()) {
                return false;
            }

            const wallet_address = await get_wallet_address();
            await (0,_login_auth_js__WEBPACK_IMPORTED_MODULE_0__.login)(wallet_address, window.ethereum);
        }
        catch(error) {
            if (error.code == 4001) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("User denied MetaMask to sign the message. This is required to enter the Metamon Island.", "danger");
            }
        }
    };
});

async function check_metamask(wallet_address)
{
    let success = false;
    try {
        success = ethereum.isMetaMask;
    }
    catch (e) {
        console.log(e);
    }

    if (!success){
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("Cannot find Metamask!", "danger");
        return false;
    }
    return true;
}

function check_chain(wallet_address)
{
    if (ethereum.chainId != 56) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("You need to switch to Binance Smart Chain Mainnet!", "danger");
        return false;
    }
    return true;
}

async function get_wallet_address()
{
    try {
        let response = await ethereum.request({method: "eth_requestAccounts"});
        return response[0];
    } catch(e) {
        console.log(error);
        return 0;
    }
}
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!********************************!*\
  !*** ./walletconnect-login.js ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _login_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login-auth.js */ "./login-auth.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./utils.js");
/* harmony import */ var _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ethers-5.1.esm.min.js */ "./ethers-5.1.esm.min.js");




//import lodash from 'lodash';
// import Web3 from "web3-provider-engine";
//import WalletConnectProvider from "./walletconnect-web3-provider";

/* import WalletConnectClient from "@walletconnect/client"; */
//const WalletConnectProvider = window.WalletConnectProvider.default;
//const Web3 = window.Web3.default;
let WalletConnectProvider;
if (window.WalletConnectProvider)
    WalletConnectProvider = window.WalletConnectProvider.default;
 
let wc_provider;
 
[].forEach.call(document.getElementsByClassName("walletconnect-login"), (item, index) => {
    item.onclick = async ()=>{
        //  Create WalletConnect Provider
        wc_provider = new WalletConnectProvider({
            //infuraId: "27e484dcd9e3efcfd25a83a78777cdf1", // Required
            rpc: {
                56: "https://bsc-dataseed.binance.org/"
              },
              chainId: 56
        });

        // Subscribe to accounts change
        wc_provider.on("accountsChanged", (accounts) => {
            console.log(accounts);
        });
        
        // Subscribe to session connection
        wc_provider.on("connect", connect);

        //if (get_wallet_address(wc_provider).length >= 42) {
            //await connect();
            wc_provider.disconnect();
        //}

            //  Enable session (triggers QR Code modal)
            try {
                await wc_provider.enable();
            }
            catch(error) {
                if (error == "Error: User closed modal") {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("User closed the window to connect via WalletConnect. Please login to use Metamon Manager.", "danger");
                }
            }
        
    };
});

async function connect () {
    const wallet_address = get_wallet_address(wc_provider);
    const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.genRandomLoginMsg)();

    const signature = await wc_provider.send(
        'personal_sign',
        [ _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_2__.ethers.utils.hexlify(_ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_2__.ethers.utils.toUtf8Bytes(msg)), wallet_address.toLowerCase() ]
    );

    console.log(signature);

    await (0,_login_auth_js__WEBPACK_IMPORTED_MODULE_0__.handle_auth)(wallet_address, msg, signature);

    window.location.href = "/index";

    //await login(wallet_address, wc_provider);

        /*
    const provider = new ethers.providers.Web3Provider(wc_provider);
    const signer = provider.getSigner();
    const signature = await signer.signMessage("Test");
    const address = await signer.getAddress();

    const address2 = wc_provider.wc.accounts[0];

    let signedMessage = await wc_provider.send(
        'personal_sign',
        [ ethers.utils.hexlify(ethers.utils.toUtf8Bytes("Test")), address2.toLowerCase() ]
    );

    const web3 = new Web3(provider);
    const accounts = await web3.eth.getAccounts();
    */
};

function get_wallet_address(wc_provider) {
    try {
        return wc_provider.wc.accounts[0].toLowerCase();
    } catch(e) {
        console.log(e);
        return "";
    }
};
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************!*\
  !*** ./toasts.js ***!
  \*******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./utils.js");


function showPrivacyToast(show) {
    var toastElement = document.getElementById('gdprToast');
    if (toastElement) {
        var toast = new bootstrap.Toast(toastElement);
        if (show) {
            toast.show();
        }
        else {
            toast.hide();
        }
    };
};

// Event Listener
document.addEventListener('DOMContentLoaded', initConsent);

async function initConsent () {
    if (consentRequired()) {
        showPrivacyToast(true);
    }
    else {
        await sendConsent("NOT_REQUIRED");
    }
};

var notAgree = document.getElementById('privacy-not-agree');
if (notAgree)
    notAgree.onclick = notAcceptGDPR;
var agree = document.getElementById('privacy-agree');
if (agree)
    agree.onclick = acceptGDPR;

async function notAcceptGDPR () {
    showPrivacyToast(false);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.error_msg)("You need to accept to placing cookies to use this website. Functionality will be restricted.", "danger");
    await sendConsent(false);
};

async function acceptGDPR () {
    await sendConsent(true);
};

async function sendConsent(consent) {
    const options = {
        method: 'post',
        headers: {
            'Content-Type': 'application/json'
          },
        body: JSON.stringify({"consent": consent})
    };
    await fetch('/consent', options);
};

/**
 * Determine whether a consent to setting cookies according to teh GDPR is required.
 * @returns true if a user is likely living in EU
 */
function consentRequired() {
    let tz = "";
    try {
        tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch (err) {
        return true;
    }

    switch (tz) {
      case 'Europe/Vienna':
        return true;
      case 'Europe/Brussels':
        return true;
      case 'Europe/Sofia':
        return true;
      case 'Europe/Zagreb':
        return true;
      case 'Asia/Famagusta':
        return true;
      case 'Asia/Nicosia':
        return true;
      case 'Europe/Prague':
        return true;
      case 'Europe/Copenhagen':
        return true;
      case 'Europe/Tallinn':
        return true;
      case 'Europe/Helsinki':
        return true;
      case 'Europe/Paris':
        return true;
      case 'Europe/Berlin':
        return true;
      case 'Europe/Busingen':
        return true;
      case 'Europe/Athens':
        return true;
      case 'Europe/Budapest':
        return true;
      case 'Europe/Dublin':
        return true;
      case 'Europe/Rome':
        return true;
      case 'Europe/Riga':
        return true;
      case 'Europe/Vilnius':
        return true;
      case 'Europe/Luxembourg':
        return true;
      case 'Europe/Malta':
        return true;
      case 'Europe/Amsterdam':
        return true;
      case 'Europe/Warsaw':
        return true;
      case 'Atlantic/Azores':
        return true;
      case 'Atlantic/Madeira':
        return true;
      case 'Europe/Lisbon':
        return true;
      case 'Europe/Bucharest':
        return true;
      case 'Europe/Bratislava':
        return true;
      case 'Europe/Ljubljana':
        return true;
      case 'Africa/Ceuta':
        return true;
      case 'Atlantic/Canary':
        return true;
      case 'Europe/Madrid':
        return true;
      case 'Europe/Stockholm':
        return true;
      default:
        return false;
    }
};
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0IsY0FBYyxnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0IsY0FBYyxnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0IsY0FBYyxnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0Isd0NBQXdDLGNBQWMsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQixtQ0FBbUMsZ0NBQWdDLGFBQWEsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQixtQ0FBbUMsZ0NBQWdDLGFBQWEsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQixtQ0FBbUMsZ0NBQWdDLGFBQWEsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEy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RUE7QUFDQSxlQUFlLHFFQUFlO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxRUFBZTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUscUVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxxRUFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLFdBQVcscUVBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLG1FQUFp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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2YsRUFBRSxzRUFBWTtBQUNkLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx3S0FBd0s7O0FBRXhLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsUUFBUTtBQUNSLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUSxVQUFVO0FBQ2pDLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxVQUFVO0FBQ2pDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxVQUFVO0FBQ2pDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFl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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsV0FBVztBQUNsQyxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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LElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRO0FBQ3BFO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLE9BQU8sZ0JBQWdCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBMkQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ldGhlcnMtNS4xLmVzbS5taW4uanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbG9naW4tYXV0aC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvYWRkTGVhZGluZ1plcm9zL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9mb3JtYXQvZm9ybWF0dGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZm9ybWF0L2xpZ2h0Rm9ybWF0dGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZm9ybWF0L2xvbmdGb3JtYXR0ZXJzL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRVVENEYXlPZlllYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFVUQ0lTT1dlZWtZZWFyL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRVVENJU09XZWVrL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRVVENXZWVrWWVhci9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZ2V0VVRDV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvaXNTYW1lVVRDV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvcHJvdGVjdGVkVG9rZW5zL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3N0YXJ0T2ZVVENJU09XZWVrWWVhci9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvc3RhcnRPZlVUQ0lTT1dlZWsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3N0YXJ0T2ZVVENXZWVrWWVhci9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvc3RhcnRPZlVUQ1dlZWsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3RvSW50ZWdlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2FkZE1pbGxpc2Vjb25kcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2Zvcm1hdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2lzRGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2lzVmFsaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvX2xpYi9idWlsZEZvcm1hdExvbmdGbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9fbGliL2J1aWxkTG9jYWxpemVGbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9fbGliL2J1aWxkTWF0Y2hGbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZGUvX2xpYi9mb3JtYXREaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9kZS9fbGliL2Zvcm1hdExvbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZGUvX2xpYi9mb3JtYXRSZWxhdGl2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9kZS9fbGliL2xvY2FsaXplL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2RlL19saWIvbWF0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXREaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdExvbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXRSZWxhdGl2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL2xvY2FsaXplL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2VuLVVTL19saWIvbWF0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvemgtQ04vX2xpYi9mb3JtYXREaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS96aC1DTi9fbGliL2Zvcm1hdExvbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvemgtQ04vX2xpYi9mb3JtYXRSZWxhdGl2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS96aC1DTi9fbGliL2xvY2FsaXplL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL3poLUNOL19saWIvbWF0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvemgtQ04vaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9zdWJNaWxsaXNlY29uZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS90b0RhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL3N0YXRpc3RpY3MuanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9tbS1sb2dpbi5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi93YWxsZXRjb25uZWN0LWxvZ2luLmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL3RvYXN0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uanNHbG9iYWw9dHlwZW9mIGdsb2JhbFRoaXMhPT1cInVuZGVmaW5lZFwiP2dsb2JhbFRoaXM6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93OnR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiP2dsb2JhbDp0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp7fTtmdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh4KXtyZXR1cm4geCYmeC5fX2VzTW9kdWxlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCxcImRlZmF1bHRcIik/eFtcImRlZmF1bHRcIl06eH1mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbixiYXNlZGlyLG1vZHVsZSl7cmV0dXJuIG1vZHVsZT17cGF0aDpiYXNlZGlyLGV4cG9ydHM6e30scmVxdWlyZTpmdW5jdGlvbihwYXRoLGJhc2Upe3JldHVybiBjb21tb25qc1JlcXVpcmUocGF0aCxiYXNlPT09dW5kZWZpbmVkfHxiYXNlPT09bnVsbD9tb2R1bGUucGF0aDpiYXNlKX19LGZuKG1vZHVsZSxtb2R1bGUuZXhwb3J0cyksbW9kdWxlLmV4cG9ydHN9ZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZlByZXNlbnQobil7cmV0dXJuIG4mJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiZGVmYXVsdFwiKT9uW1wiZGVmYXVsdFwiXTpufWZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZChuKXtyZXR1cm4gbiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJkZWZhdWx0XCIpJiZPYmplY3Qua2V5cyhuKS5sZW5ndGg9PT0xP25bXCJkZWZhdWx0XCJdOm59ZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pe2lmKG4uX19lc01vZHVsZSlyZXR1cm4gbjt2YXIgYT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKGspe3ZhciBkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobixrKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxrLGQuZ2V0P2Q6e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbltrXX19KX0pO3JldHVybiBhfWZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSgpe3Rocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzXCIpfXZhciBibj1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihtb2R1bGUpeyhmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYXNzZXJ0KHZhbCxtc2cpe2lmKCF2YWwpdGhyb3cgbmV3IEVycm9yKG1zZ3x8XCJBc3NlcnRpb24gZmFpbGVkXCIpfWZ1bmN0aW9uIGluaGVyaXRzKGN0b3Isc3VwZXJDdG9yKXtjdG9yLnN1cGVyXz1zdXBlckN0b3I7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9c3VwZXJDdG9yLnByb3RvdHlwZTtjdG9yLnByb3RvdHlwZT1uZXcgVGVtcEN0b3I7Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3I9Y3Rvcn1mdW5jdGlvbiBCTihudW1iZXIsYmFzZSxlbmRpYW4pe2lmKEJOLmlzQk4obnVtYmVyKSl7cmV0dXJuIG51bWJlcn10aGlzLm5lZ2F0aXZlPTA7dGhpcy53b3Jkcz1udWxsO3RoaXMubGVuZ3RoPTA7dGhpcy5yZWQ9bnVsbDtpZihudW1iZXIhPT1udWxsKXtpZihiYXNlPT09XCJsZVwifHxiYXNlPT09XCJiZVwiKXtlbmRpYW49YmFzZTtiYXNlPTEwfXRoaXMuX2luaXQobnVtYmVyfHwwLGJhc2V8fDEwLGVuZGlhbnx8XCJiZVwiKX19aWYodHlwZW9mIG1vZHVsZT09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPUJOfWVsc2V7ZXhwb3J0cy5CTj1CTn1CTi5CTj1CTjtCTi53b3JkU2l6ZT0yNjt2YXIgQnVmZmVyO3RyeXtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIHdpbmRvdy5CdWZmZXIhPT1cInVuZGVmaW5lZFwiKXtCdWZmZXI9d2luZG93LkJ1ZmZlcn1lbHNle0J1ZmZlcj1udWxsLkJ1ZmZlcn19Y2F0Y2goZSl7fUJOLmlzQk49ZnVuY3Rpb24gaXNCTihudW0pe2lmKG51bSBpbnN0YW5jZW9mIEJOKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gbnVtIT09bnVsbCYmdHlwZW9mIG51bT09PVwib2JqZWN0XCImJm51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZT09PUJOLndvcmRTaXplJiZBcnJheS5pc0FycmF5KG51bS53b3Jkcyl9O0JOLm1heD1mdW5jdGlvbiBtYXgobGVmdCxyaWdodCl7aWYobGVmdC5jbXAocmlnaHQpPjApcmV0dXJuIGxlZnQ7cmV0dXJuIHJpZ2h0fTtCTi5taW49ZnVuY3Rpb24gbWluKGxlZnQscmlnaHQpe2lmKGxlZnQuY21wKHJpZ2h0KTwwKXJldHVybiBsZWZ0O3JldHVybiByaWdodH07Qk4ucHJvdG90eXBlLl9pbml0PWZ1bmN0aW9uIGluaXQobnVtYmVyLGJhc2UsZW5kaWFuKXtpZih0eXBlb2YgbnVtYmVyPT09XCJudW1iZXJcIil7cmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLGJhc2UsZW5kaWFuKX1pZih0eXBlb2YgbnVtYmVyPT09XCJvYmplY3RcIil7cmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsYmFzZSxlbmRpYW4pfWlmKGJhc2U9PT1cImhleFwiKXtiYXNlPTE2fWFzc2VydChiYXNlPT09KGJhc2V8MCkmJmJhc2U+PTImJmJhc2U8PTM2KTtudW1iZXI9bnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLFwiXCIpO3ZhciBzdGFydD0wO2lmKG51bWJlclswXT09PVwiLVwiKXtzdGFydCsrO3RoaXMubmVnYXRpdmU9MX1pZihzdGFydDxudW1iZXIubGVuZ3RoKXtpZihiYXNlPT09MTYpe3RoaXMuX3BhcnNlSGV4KG51bWJlcixzdGFydCxlbmRpYW4pfWVsc2V7dGhpcy5fcGFyc2VCYXNlKG51bWJlcixiYXNlLHN0YXJ0KTtpZihlbmRpYW49PT1cImxlXCIpe3RoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSxiYXNlLGVuZGlhbil9fX19O0JOLnByb3RvdHlwZS5faW5pdE51bWJlcj1mdW5jdGlvbiBfaW5pdE51bWJlcihudW1iZXIsYmFzZSxlbmRpYW4pe2lmKG51bWJlcjwwKXt0aGlzLm5lZ2F0aXZlPTE7bnVtYmVyPS1udW1iZXJ9aWYobnVtYmVyPDY3MTA4ODY0KXt0aGlzLndvcmRzPVtudW1iZXImNjcxMDg4NjNdO3RoaXMubGVuZ3RoPTF9ZWxzZSBpZihudW1iZXI8NDUwMzU5OTYyNzM3MDQ5Nil7dGhpcy53b3Jkcz1bbnVtYmVyJjY3MTA4ODYzLG51bWJlci82NzEwODg2NCY2NzEwODg2M107dGhpcy5sZW5ndGg9Mn1lbHNle2Fzc2VydChudW1iZXI8OTAwNzE5OTI1NDc0MDk5Mik7dGhpcy53b3Jkcz1bbnVtYmVyJjY3MTA4ODYzLG51bWJlci82NzEwODg2NCY2NzEwODg2MywxXTt0aGlzLmxlbmd0aD0zfWlmKGVuZGlhbiE9PVwibGVcIilyZXR1cm47dGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLGJhc2UsZW5kaWFuKX07Qk4ucHJvdG90eXBlLl9pbml0QXJyYXk9ZnVuY3Rpb24gX2luaXRBcnJheShudW1iZXIsYmFzZSxlbmRpYW4pe2Fzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aD09PVwibnVtYmVyXCIpO2lmKG51bWJlci5sZW5ndGg8PTApe3RoaXMud29yZHM9WzBdO3RoaXMubGVuZ3RoPTE7cmV0dXJuIHRoaXN9dGhpcy5sZW5ndGg9TWF0aC5jZWlsKG51bWJlci5sZW5ndGgvMyk7dGhpcy53b3Jkcz1uZXcgQXJyYXkodGhpcy5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt0aGlzLndvcmRzW2ldPTB9dmFyIGosdzt2YXIgb2ZmPTA7aWYoZW5kaWFuPT09XCJiZVwiKXtmb3IoaT1udW1iZXIubGVuZ3RoLTEsaj0wO2k+PTA7aS09Myl7dz1udW1iZXJbaV18bnVtYmVyW2ktMV08PDh8bnVtYmVyW2ktMl08PDE2O3RoaXMud29yZHNbal18PXc8PG9mZiY2NzEwODg2Mzt0aGlzLndvcmRzW2orMV09dz4+PjI2LW9mZiY2NzEwODg2MztvZmYrPTI0O2lmKG9mZj49MjYpe29mZi09MjY7aisrfX19ZWxzZSBpZihlbmRpYW49PT1cImxlXCIpe2ZvcihpPTAsaj0wO2k8bnVtYmVyLmxlbmd0aDtpKz0zKXt3PW51bWJlcltpXXxudW1iZXJbaSsxXTw8OHxudW1iZXJbaSsyXTw8MTY7dGhpcy53b3Jkc1tqXXw9dzw8b2ZmJjY3MTA4ODYzO3RoaXMud29yZHNbaisxXT13Pj4+MjYtb2ZmJjY3MTA4ODYzO29mZis9MjQ7aWYob2ZmPj0yNil7b2ZmLT0yNjtqKyt9fX1yZXR1cm4gdGhpcy5zdHJpcCgpfTtmdW5jdGlvbiBwYXJzZUhleDRCaXRzKHN0cmluZyxpbmRleCl7dmFyIGM9c3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO2lmKGM+PTY1JiZjPD03MCl7cmV0dXJuIGMtNTV9ZWxzZSBpZihjPj05NyYmYzw9MTAyKXtyZXR1cm4gYy04N31lbHNle3JldHVybiBjLTQ4JjE1fX1mdW5jdGlvbiBwYXJzZUhleEJ5dGUoc3RyaW5nLGxvd2VyQm91bmQsaW5kZXgpe3ZhciByPXBhcnNlSGV4NEJpdHMoc3RyaW5nLGluZGV4KTtpZihpbmRleC0xPj1sb3dlckJvdW5kKXtyfD1wYXJzZUhleDRCaXRzKHN0cmluZyxpbmRleC0xKTw8NH1yZXR1cm4gcn1CTi5wcm90b3R5cGUuX3BhcnNlSGV4PWZ1bmN0aW9uIF9wYXJzZUhleChudW1iZXIsc3RhcnQsZW5kaWFuKXt0aGlzLmxlbmd0aD1NYXRoLmNlaWwoKG51bWJlci5sZW5ndGgtc3RhcnQpLzYpO3RoaXMud29yZHM9bmV3IEFycmF5KHRoaXMubGVuZ3RoKTtmb3IodmFyIGk9MDtpPHRoaXMubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT0wfXZhciBvZmY9MDt2YXIgaj0wO3ZhciB3O2lmKGVuZGlhbj09PVwiYmVcIil7Zm9yKGk9bnVtYmVyLmxlbmd0aC0xO2k+PXN0YXJ0O2ktPTIpe3c9cGFyc2VIZXhCeXRlKG51bWJlcixzdGFydCxpKTw8b2ZmO3RoaXMud29yZHNbal18PXcmNjcxMDg4NjM7aWYob2ZmPj0xOCl7b2ZmLT0xODtqKz0xO3RoaXMud29yZHNbal18PXc+Pj4yNn1lbHNle29mZis9OH19fWVsc2V7dmFyIHBhcnNlTGVuZ3RoPW51bWJlci5sZW5ndGgtc3RhcnQ7Zm9yKGk9cGFyc2VMZW5ndGglMj09PTA/c3RhcnQrMTpzdGFydDtpPG51bWJlci5sZW5ndGg7aSs9Mil7dz1wYXJzZUhleEJ5dGUobnVtYmVyLHN0YXJ0LGkpPDxvZmY7dGhpcy53b3Jkc1tqXXw9dyY2NzEwODg2MztpZihvZmY+PTE4KXtvZmYtPTE4O2orPTE7dGhpcy53b3Jkc1tqXXw9dz4+PjI2fWVsc2V7b2ZmKz04fX19dGhpcy5zdHJpcCgpfTtmdW5jdGlvbiBwYXJzZUJhc2Uoc3RyLHN0YXJ0LGVuZCxtdWwpe3ZhciByPTA7dmFyIGxlbj1NYXRoLm1pbihzdHIubGVuZ3RoLGVuZCk7Zm9yKHZhciBpPXN0YXJ0O2k8bGVuO2krKyl7dmFyIGM9c3RyLmNoYXJDb2RlQXQoaSktNDg7cio9bXVsO2lmKGM+PTQ5KXtyKz1jLTQ5KzEwfWVsc2UgaWYoYz49MTcpe3IrPWMtMTcrMTB9ZWxzZXtyKz1jfX1yZXR1cm4gcn1CTi5wcm90b3R5cGUuX3BhcnNlQmFzZT1mdW5jdGlvbiBfcGFyc2VCYXNlKG51bWJlcixiYXNlLHN0YXJ0KXt0aGlzLndvcmRzPVswXTt0aGlzLmxlbmd0aD0xO2Zvcih2YXIgbGltYkxlbj0wLGxpbWJQb3c9MTtsaW1iUG93PD02NzEwODg2MztsaW1iUG93Kj1iYXNlKXtsaW1iTGVuKyt9bGltYkxlbi0tO2xpbWJQb3c9bGltYlBvdy9iYXNlfDA7dmFyIHRvdGFsPW51bWJlci5sZW5ndGgtc3RhcnQ7dmFyIG1vZD10b3RhbCVsaW1iTGVuO3ZhciBlbmQ9TWF0aC5taW4odG90YWwsdG90YWwtbW9kKStzdGFydDt2YXIgd29yZD0wO2Zvcih2YXIgaT1zdGFydDtpPGVuZDtpKz1saW1iTGVuKXt3b3JkPXBhcnNlQmFzZShudW1iZXIsaSxpK2xpbWJMZW4sYmFzZSk7dGhpcy5pbXVsbihsaW1iUG93KTtpZih0aGlzLndvcmRzWzBdK3dvcmQ8NjcxMDg4NjQpe3RoaXMud29yZHNbMF0rPXdvcmR9ZWxzZXt0aGlzLl9pYWRkbih3b3JkKX19aWYobW9kIT09MCl7dmFyIHBvdz0xO3dvcmQ9cGFyc2VCYXNlKG51bWJlcixpLG51bWJlci5sZW5ndGgsYmFzZSk7Zm9yKGk9MDtpPG1vZDtpKyspe3Bvdyo9YmFzZX10aGlzLmltdWxuKHBvdyk7aWYodGhpcy53b3Jkc1swXSt3b3JkPDY3MTA4ODY0KXt0aGlzLndvcmRzWzBdKz13b3JkfWVsc2V7dGhpcy5faWFkZG4od29yZCl9fXRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24gY29weShkZXN0KXtkZXN0LndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aDtpKyspe2Rlc3Qud29yZHNbaV09dGhpcy53b3Jkc1tpXX1kZXN0Lmxlbmd0aD10aGlzLmxlbmd0aDtkZXN0Lm5lZ2F0aXZlPXRoaXMubmVnYXRpdmU7ZGVzdC5yZWQ9dGhpcy5yZWR9O0JOLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbiBjbG9uZSgpe3ZhciByPW5ldyBCTihudWxsKTt0aGlzLmNvcHkocik7cmV0dXJuIHJ9O0JOLnByb3RvdHlwZS5fZXhwYW5kPWZ1bmN0aW9uIF9leHBhbmQoc2l6ZSl7d2hpbGUodGhpcy5sZW5ndGg8c2l6ZSl7dGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXT0wfXJldHVybiB0aGlzfTtCTi5wcm90b3R5cGUuc3RyaXA9ZnVuY3Rpb24gc3RyaXAoKXt3aGlsZSh0aGlzLmxlbmd0aD4xJiZ0aGlzLndvcmRzW3RoaXMubGVuZ3RoLTFdPT09MCl7dGhpcy5sZW5ndGgtLX1yZXR1cm4gdGhpcy5fbm9ybVNpZ24oKX07Qk4ucHJvdG90eXBlLl9ub3JtU2lnbj1mdW5jdGlvbiBfbm9ybVNpZ24oKXtpZih0aGlzLmxlbmd0aD09PTEmJnRoaXMud29yZHNbMF09PT0wKXt0aGlzLm5lZ2F0aXZlPTB9cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uIGluc3BlY3QoKXtyZXR1cm4odGhpcy5yZWQ/XCI8Qk4tUjogXCI6XCI8Qk46IFwiKSt0aGlzLnRvU3RyaW5nKDE2KStcIj5cIn07dmFyIHplcm9zPVtcIlwiLFwiMFwiLFwiMDBcIixcIjAwMFwiLFwiMDAwMFwiLFwiMDAwMDBcIixcIjAwMDAwMFwiLFwiMDAwMDAwMFwiLFwiMDAwMDAwMDBcIixcIjAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDBcIixcIjAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDBcIixcIjAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDBcIixcIjAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiXTt2YXIgZ3JvdXBTaXplcz1bMCwwLDI1LDE2LDEyLDExLDEwLDksOCw4LDcsNyw3LDcsNiw2LDYsNiw2LDYsNiw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1XTt2YXIgZ3JvdXBCYXNlcz1bMCwwLDMzNTU0NDMyLDQzMDQ2NzIxLDE2Nzc3MjE2LDQ4ODI4MTI1LDYwNDY2MTc2LDQwMzUzNjA3LDE2Nzc3MjE2LDQzMDQ2NzIxLDFlNywxOTQ4NzE3MSwzNTgzMTgwOCw2Mjc0ODUxNyw3NTI5NTM2LDExMzkwNjI1LDE2Nzc3MjE2LDI0MTM3NTY5LDM0MDEyMjI0LDQ3MDQ1ODgxLDY0ZTYsNDA4NDEwMSw1MTUzNjMyLDY0MzYzNDMsNzk2MjYyNCw5NzY1NjI1LDExODgxMzc2LDE0MzQ4OTA3LDE3MjEwMzY4LDIwNTExMTQ5LDI0M2U1LDI4NjI5MTUxLDMzNTU0NDMyLDM5MTM1MzkzLDQ1NDM1NDI0LDUyNTIxODc1LDYwNDY2MTc2XTtCTi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoYmFzZSxwYWRkaW5nKXtiYXNlPWJhc2V8fDEwO3BhZGRpbmc9cGFkZGluZ3wwfHwxO3ZhciBvdXQ7aWYoYmFzZT09PTE2fHxiYXNlPT09XCJoZXhcIil7b3V0PVwiXCI7dmFyIG9mZj0wO3ZhciBjYXJyeT0wO2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt2YXIgdz10aGlzLndvcmRzW2ldO3ZhciB3b3JkPSgodzw8b2ZmfGNhcnJ5KSYxNjc3NzIxNSkudG9TdHJpbmcoMTYpO2NhcnJ5PXc+Pj4yNC1vZmYmMTY3NzcyMTU7aWYoY2FycnkhPT0wfHxpIT09dGhpcy5sZW5ndGgtMSl7b3V0PXplcm9zWzYtd29yZC5sZW5ndGhdK3dvcmQrb3V0fWVsc2V7b3V0PXdvcmQrb3V0fW9mZis9MjtpZihvZmY+PTI2KXtvZmYtPTI2O2ktLX19aWYoY2FycnkhPT0wKXtvdXQ9Y2FycnkudG9TdHJpbmcoMTYpK291dH13aGlsZShvdXQubGVuZ3RoJXBhZGRpbmchPT0wKXtvdXQ9XCIwXCIrb3V0fWlmKHRoaXMubmVnYXRpdmUhPT0wKXtvdXQ9XCItXCIrb3V0fXJldHVybiBvdXR9aWYoYmFzZT09PShiYXNlfDApJiZiYXNlPj0yJiZiYXNlPD0zNil7dmFyIGdyb3VwU2l6ZT1ncm91cFNpemVzW2Jhc2VdO3ZhciBncm91cEJhc2U9Z3JvdXBCYXNlc1tiYXNlXTtvdXQ9XCJcIjt2YXIgYz10aGlzLmNsb25lKCk7Yy5uZWdhdGl2ZT0wO3doaWxlKCFjLmlzWmVybygpKXt2YXIgcj1jLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtjPWMuaWRpdm4oZ3JvdXBCYXNlKTtpZighYy5pc1plcm8oKSl7b3V0PXplcm9zW2dyb3VwU2l6ZS1yLmxlbmd0aF0rcitvdXR9ZWxzZXtvdXQ9citvdXR9fWlmKHRoaXMuaXNaZXJvKCkpe291dD1cIjBcIitvdXR9d2hpbGUob3V0Lmxlbmd0aCVwYWRkaW5nIT09MCl7b3V0PVwiMFwiK291dH1pZih0aGlzLm5lZ2F0aXZlIT09MCl7b3V0PVwiLVwiK291dH1yZXR1cm4gb3V0fWFzc2VydChmYWxzZSxcIkJhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzZcIil9O0JOLnByb3RvdHlwZS50b051bWJlcj1mdW5jdGlvbiB0b051bWJlcigpe3ZhciByZXQ9dGhpcy53b3Jkc1swXTtpZih0aGlzLmxlbmd0aD09PTIpe3JldCs9dGhpcy53b3Jkc1sxXSo2NzEwODg2NH1lbHNlIGlmKHRoaXMubGVuZ3RoPT09MyYmdGhpcy53b3Jkc1syXT09PTEpe3JldCs9NDUwMzU5OTYyNzM3MDQ5Nit0aGlzLndvcmRzWzFdKjY3MTA4ODY0fWVsc2UgaWYodGhpcy5sZW5ndGg+Mil7YXNzZXJ0KGZhbHNlLFwiTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzXCIpfXJldHVybiB0aGlzLm5lZ2F0aXZlIT09MD8tcmV0OnJldH07Qk4ucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbiB0b0pTT04oKXtyZXR1cm4gdGhpcy50b1N0cmluZygxNil9O0JOLnByb3RvdHlwZS50b0J1ZmZlcj1mdW5jdGlvbiB0b0J1ZmZlcihlbmRpYW4sbGVuZ3RoKXthc3NlcnQodHlwZW9mIEJ1ZmZlciE9PVwidW5kZWZpbmVkXCIpO3JldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlcixlbmRpYW4sbGVuZ3RoKX07Qk4ucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24gdG9BcnJheShlbmRpYW4sbGVuZ3RoKXtyZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSxlbmRpYW4sbGVuZ3RoKX07Qk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlPWZ1bmN0aW9uIHRvQXJyYXlMaWtlKEFycmF5VHlwZSxlbmRpYW4sbGVuZ3RoKXt2YXIgYnl0ZUxlbmd0aD10aGlzLmJ5dGVMZW5ndGgoKTt2YXIgcmVxTGVuZ3RoPWxlbmd0aHx8TWF0aC5tYXgoMSxieXRlTGVuZ3RoKTthc3NlcnQoYnl0ZUxlbmd0aDw9cmVxTGVuZ3RoLFwiYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aFwiKTthc3NlcnQocmVxTGVuZ3RoPjAsXCJSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDBcIik7dGhpcy5zdHJpcCgpO3ZhciBsaXR0bGVFbmRpYW49ZW5kaWFuPT09XCJsZVwiO3ZhciByZXM9bmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO3ZhciBiLGk7dmFyIHE9dGhpcy5jbG9uZSgpO2lmKCFsaXR0bGVFbmRpYW4pe2ZvcihpPTA7aTxyZXFMZW5ndGgtYnl0ZUxlbmd0aDtpKyspe3Jlc1tpXT0wfWZvcihpPTA7IXEuaXNaZXJvKCk7aSsrKXtiPXEuYW5kbG4oMjU1KTtxLml1c2hybig4KTtyZXNbcmVxTGVuZ3RoLWktMV09Yn19ZWxzZXtmb3IoaT0wOyFxLmlzWmVybygpO2krKyl7Yj1xLmFuZGxuKDI1NSk7cS5pdXNocm4oOCk7cmVzW2ldPWJ9Zm9yKDtpPHJlcUxlbmd0aDtpKyspe3Jlc1tpXT0wfX1yZXR1cm4gcmVzfTtpZihNYXRoLmNsejMyKXtCTi5wcm90b3R5cGUuX2NvdW50Qml0cz1mdW5jdGlvbiBfY291bnRCaXRzKHcpe3JldHVybiAzMi1NYXRoLmNsejMyKHcpfX1lbHNle0JOLnByb3RvdHlwZS5fY291bnRCaXRzPWZ1bmN0aW9uIF9jb3VudEJpdHModyl7dmFyIHQ9dzt2YXIgcj0wO2lmKHQ+PTQwOTYpe3IrPTEzO3Q+Pj49MTN9aWYodD49NjQpe3IrPTc7dD4+Pj03fWlmKHQ+PTgpe3IrPTQ7dD4+Pj00fWlmKHQ+PTIpe3IrPTI7dD4+Pj0yfXJldHVybiByK3R9fUJOLnByb3RvdHlwZS5femVyb0JpdHM9ZnVuY3Rpb24gX3plcm9CaXRzKHcpe2lmKHc9PT0wKXJldHVybiAyNjt2YXIgdD13O3ZhciByPTA7aWYoKHQmODE5MSk9PT0wKXtyKz0xMzt0Pj4+PTEzfWlmKCh0JjEyNyk9PT0wKXtyKz03O3Q+Pj49N31pZigodCYxNSk9PT0wKXtyKz00O3Q+Pj49NH1pZigodCYzKT09PTApe3IrPTI7dD4+Pj0yfWlmKCh0JjEpPT09MCl7cisrfXJldHVybiByfTtCTi5wcm90b3R5cGUuYml0TGVuZ3RoPWZ1bmN0aW9uIGJpdExlbmd0aCgpe3ZhciB3PXRoaXMud29yZHNbdGhpcy5sZW5ndGgtMV07dmFyIGhpPXRoaXMuX2NvdW50Qml0cyh3KTtyZXR1cm4odGhpcy5sZW5ndGgtMSkqMjYraGl9O2Z1bmN0aW9uIHRvQml0QXJyYXkobnVtKXt2YXIgdz1uZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtmb3IodmFyIGJpdD0wO2JpdDx3Lmxlbmd0aDtiaXQrKyl7dmFyIG9mZj1iaXQvMjZ8MDt2YXIgd2JpdD1iaXQlMjY7d1tiaXRdPShudW0ud29yZHNbb2ZmXSYxPDx3Yml0KT4+PndiaXR9cmV0dXJuIHd9Qk4ucHJvdG90eXBlLnplcm9CaXRzPWZ1bmN0aW9uIHplcm9CaXRzKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gMDt2YXIgcj0wO2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt2YXIgYj10aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtyKz1iO2lmKGIhPT0yNilicmVha31yZXR1cm4gcn07Qk4ucHJvdG90eXBlLmJ5dGVMZW5ndGg9ZnVuY3Rpb24gYnl0ZUxlbmd0aCgpe3JldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKS84KX07Qk4ucHJvdG90eXBlLnRvVHdvcz1mdW5jdGlvbiB0b1R3b3Mod2lkdGgpe2lmKHRoaXMubmVnYXRpdmUhPT0wKXtyZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSl9cmV0dXJuIHRoaXMuY2xvbmUoKX07Qk4ucHJvdG90eXBlLmZyb21Ud29zPWZ1bmN0aW9uIGZyb21Ud29zKHdpZHRoKXtpZih0aGlzLnRlc3RuKHdpZHRoLTEpKXtyZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCl9cmV0dXJuIHRoaXMuY2xvbmUoKX07Qk4ucHJvdG90eXBlLmlzTmVnPWZ1bmN0aW9uIGlzTmVnKCl7cmV0dXJuIHRoaXMubmVnYXRpdmUhPT0wfTtCTi5wcm90b3R5cGUubmVnPWZ1bmN0aW9uIG5lZygpe3JldHVybiB0aGlzLmNsb25lKCkuaW5lZygpfTtCTi5wcm90b3R5cGUuaW5lZz1mdW5jdGlvbiBpbmVnKCl7aWYoIXRoaXMuaXNaZXJvKCkpe3RoaXMubmVnYXRpdmVePTF9cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5pdW9yPWZ1bmN0aW9uIGl1b3IobnVtKXt3aGlsZSh0aGlzLmxlbmd0aDxudW0ubGVuZ3RoKXt0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdPTB9Zm9yKHZhciBpPTA7aTxudW0ubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT10aGlzLndvcmRzW2ldfG51bS53b3Jkc1tpXX1yZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuaW9yPWZ1bmN0aW9uIGlvcihudW0pe2Fzc2VydCgodGhpcy5uZWdhdGl2ZXxudW0ubmVnYXRpdmUpPT09MCk7cmV0dXJuIHRoaXMuaXVvcihudW0pfTtCTi5wcm90b3R5cGUub3I9ZnVuY3Rpb24gb3IobnVtKXtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7cmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKX07Qk4ucHJvdG90eXBlLnVvcj1mdW5jdGlvbiB1b3IobnVtKXtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO3JldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpfTtCTi5wcm90b3R5cGUuaXVhbmQ9ZnVuY3Rpb24gaXVhbmQobnVtKXt2YXIgYjtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXtiPW51bX1lbHNle2I9dGhpc31mb3IodmFyIGk9MDtpPGIubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT10aGlzLndvcmRzW2ldJm51bS53b3Jkc1tpXX10aGlzLmxlbmd0aD1iLmxlbmd0aDtyZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuaWFuZD1mdW5jdGlvbiBpYW5kKG51bSl7YXNzZXJ0KCh0aGlzLm5lZ2F0aXZlfG51bS5uZWdhdGl2ZSk9PT0wKTtyZXR1cm4gdGhpcy5pdWFuZChudW0pfTtCTi5wcm90b3R5cGUuYW5kPWZ1bmN0aW9uIGFuZChudW0pe2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7cmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyl9O0JOLnByb3RvdHlwZS51YW5kPWZ1bmN0aW9uIHVhbmQobnVtKXtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtyZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyl9O0JOLnByb3RvdHlwZS5pdXhvcj1mdW5jdGlvbiBpdXhvcihudW0pe3ZhciBhO3ZhciBiO2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpe2E9dGhpcztiPW51bX1lbHNle2E9bnVtO2I9dGhpc31mb3IodmFyIGk9MDtpPGIubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT1hLndvcmRzW2ldXmIud29yZHNbaV19aWYodGhpcyE9PWEpe2Zvcig7aTxhLmxlbmd0aDtpKyspe3RoaXMud29yZHNbaV09YS53b3Jkc1tpXX19dGhpcy5sZW5ndGg9YS5sZW5ndGg7cmV0dXJuIHRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLml4b3I9ZnVuY3Rpb24gaXhvcihudW0pe2Fzc2VydCgodGhpcy5uZWdhdGl2ZXxudW0ubmVnYXRpdmUpPT09MCk7cmV0dXJuIHRoaXMuaXV4b3IobnVtKX07Qk4ucHJvdG90eXBlLnhvcj1mdW5jdGlvbiB4b3IobnVtKXtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO3JldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpfTtCTi5wcm90b3R5cGUudXhvcj1mdW5jdGlvbiB1eG9yKG51bSl7aWYodGhpcy5sZW5ndGg+bnVtLmxlbmd0aClyZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7cmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpfTtCTi5wcm90b3R5cGUuaW5vdG49ZnVuY3Rpb24gaW5vdG4od2lkdGgpe2Fzc2VydCh0eXBlb2Ygd2lkdGg9PT1cIm51bWJlclwiJiZ3aWR0aD49MCk7dmFyIGJ5dGVzTmVlZGVkPU1hdGguY2VpbCh3aWR0aC8yNil8MDt2YXIgYml0c0xlZnQ9d2lkdGglMjY7dGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtpZihiaXRzTGVmdD4wKXtieXRlc05lZWRlZC0tfWZvcih2YXIgaT0wO2k8Ynl0ZXNOZWVkZWQ7aSsrKXt0aGlzLndvcmRzW2ldPX50aGlzLndvcmRzW2ldJjY3MTA4ODYzfWlmKGJpdHNMZWZ0PjApe3RoaXMud29yZHNbaV09fnRoaXMud29yZHNbaV0mNjcxMDg4NjM+PjI2LWJpdHNMZWZ0fXJldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5ub3RuPWZ1bmN0aW9uIG5vdG4od2lkdGgpe3JldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpfTtCTi5wcm90b3R5cGUuc2V0bj1mdW5jdGlvbiBzZXRuKGJpdCx2YWwpe2Fzc2VydCh0eXBlb2YgYml0PT09XCJudW1iZXJcIiYmYml0Pj0wKTt2YXIgb2ZmPWJpdC8yNnwwO3ZhciB3Yml0PWJpdCUyNjt0aGlzLl9leHBhbmQob2ZmKzEpO2lmKHZhbCl7dGhpcy53b3Jkc1tvZmZdPXRoaXMud29yZHNbb2ZmXXwxPDx3Yml0fWVsc2V7dGhpcy53b3Jkc1tvZmZdPXRoaXMud29yZHNbb2ZmXSZ+KDE8PHdiaXQpfXJldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5pYWRkPWZ1bmN0aW9uIGlhZGQobnVtKXt2YXIgcjtpZih0aGlzLm5lZ2F0aXZlIT09MCYmbnVtLm5lZ2F0aXZlPT09MCl7dGhpcy5uZWdhdGl2ZT0wO3I9dGhpcy5pc3ViKG51bSk7dGhpcy5uZWdhdGl2ZV49MTtyZXR1cm4gdGhpcy5fbm9ybVNpZ24oKX1lbHNlIGlmKHRoaXMubmVnYXRpdmU9PT0wJiZudW0ubmVnYXRpdmUhPT0wKXtudW0ubmVnYXRpdmU9MDtyPXRoaXMuaXN1YihudW0pO251bS5uZWdhdGl2ZT0xO3JldHVybiByLl9ub3JtU2lnbigpfXZhciBhLGI7aWYodGhpcy5sZW5ndGg+bnVtLmxlbmd0aCl7YT10aGlzO2I9bnVtfWVsc2V7YT1udW07Yj10aGlzfXZhciBjYXJyeT0wO2Zvcih2YXIgaT0wO2k8Yi5sZW5ndGg7aSsrKXtyPShhLndvcmRzW2ldfDApKyhiLndvcmRzW2ldfDApK2NhcnJ5O3RoaXMud29yZHNbaV09ciY2NzEwODg2MztjYXJyeT1yPj4+MjZ9Zm9yKDtjYXJyeSE9PTAmJmk8YS5sZW5ndGg7aSsrKXtyPShhLndvcmRzW2ldfDApK2NhcnJ5O3RoaXMud29yZHNbaV09ciY2NzEwODg2MztjYXJyeT1yPj4+MjZ9dGhpcy5sZW5ndGg9YS5sZW5ndGg7aWYoY2FycnkhPT0wKXt0aGlzLndvcmRzW3RoaXMubGVuZ3RoXT1jYXJyeTt0aGlzLmxlbmd0aCsrfWVsc2UgaWYoYSE9PXRoaXMpe2Zvcig7aTxhLmxlbmd0aDtpKyspe3RoaXMud29yZHNbaV09YS53b3Jkc1tpXX19cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24gYWRkKG51bSl7dmFyIHJlcztpZihudW0ubmVnYXRpdmUhPT0wJiZ0aGlzLm5lZ2F0aXZlPT09MCl7bnVtLm5lZ2F0aXZlPTA7cmVzPXRoaXMuc3ViKG51bSk7bnVtLm5lZ2F0aXZlXj0xO3JldHVybiByZXN9ZWxzZSBpZihudW0ubmVnYXRpdmU9PT0wJiZ0aGlzLm5lZ2F0aXZlIT09MCl7dGhpcy5uZWdhdGl2ZT0wO3Jlcz1udW0uc3ViKHRoaXMpO3RoaXMubmVnYXRpdmU9MTtyZXR1cm4gcmVzfWlmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7cmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyl9O0JOLnByb3RvdHlwZS5pc3ViPWZ1bmN0aW9uIGlzdWIobnVtKXtpZihudW0ubmVnYXRpdmUhPT0wKXtudW0ubmVnYXRpdmU9MDt2YXIgcj10aGlzLmlhZGQobnVtKTtudW0ubmVnYXRpdmU9MTtyZXR1cm4gci5fbm9ybVNpZ24oKX1lbHNlIGlmKHRoaXMubmVnYXRpdmUhPT0wKXt0aGlzLm5lZ2F0aXZlPTA7dGhpcy5pYWRkKG51bSk7dGhpcy5uZWdhdGl2ZT0xO3JldHVybiB0aGlzLl9ub3JtU2lnbigpfXZhciBjbXA9dGhpcy5jbXAobnVtKTtpZihjbXA9PT0wKXt0aGlzLm5lZ2F0aXZlPTA7dGhpcy5sZW5ndGg9MTt0aGlzLndvcmRzWzBdPTA7cmV0dXJuIHRoaXN9dmFyIGEsYjtpZihjbXA+MCl7YT10aGlzO2I9bnVtfWVsc2V7YT1udW07Yj10aGlzfXZhciBjYXJyeT0wO2Zvcih2YXIgaT0wO2k8Yi5sZW5ndGg7aSsrKXtyPShhLndvcmRzW2ldfDApLShiLndvcmRzW2ldfDApK2NhcnJ5O2NhcnJ5PXI+PjI2O3RoaXMud29yZHNbaV09ciY2NzEwODg2M31mb3IoO2NhcnJ5IT09MCYmaTxhLmxlbmd0aDtpKyspe3I9KGEud29yZHNbaV18MCkrY2Fycnk7Y2Fycnk9cj4+MjY7dGhpcy53b3Jkc1tpXT1yJjY3MTA4ODYzfWlmKGNhcnJ5PT09MCYmaTxhLmxlbmd0aCYmYSE9PXRoaXMpe2Zvcig7aTxhLmxlbmd0aDtpKyspe3RoaXMud29yZHNbaV09YS53b3Jkc1tpXX19dGhpcy5sZW5ndGg9TWF0aC5tYXgodGhpcy5sZW5ndGgsaSk7aWYoYSE9PXRoaXMpe3RoaXMubmVnYXRpdmU9MX1yZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uIHN1YihudW0pe3JldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pfTtmdW5jdGlvbiBzbWFsbE11bFRvKHNlbGYsbnVtLG91dCl7b3V0Lm5lZ2F0aXZlPW51bS5uZWdhdGl2ZV5zZWxmLm5lZ2F0aXZlO3ZhciBsZW49c2VsZi5sZW5ndGgrbnVtLmxlbmd0aHwwO291dC5sZW5ndGg9bGVuO2xlbj1sZW4tMXwwO3ZhciBhPXNlbGYud29yZHNbMF18MDt2YXIgYj1udW0ud29yZHNbMF18MDt2YXIgcj1hKmI7dmFyIGxvPXImNjcxMDg4NjM7dmFyIGNhcnJ5PXIvNjcxMDg4NjR8MDtvdXQud29yZHNbMF09bG87Zm9yKHZhciBrPTE7azxsZW47aysrKXt2YXIgbmNhcnJ5PWNhcnJ5Pj4+MjY7dmFyIHJ3b3JkPWNhcnJ5JjY3MTA4ODYzO3ZhciBtYXhKPU1hdGgubWluKGssbnVtLmxlbmd0aC0xKTtmb3IodmFyIGo9TWF0aC5tYXgoMCxrLXNlbGYubGVuZ3RoKzEpO2o8PW1heEo7aisrKXt2YXIgaT1rLWp8MDthPXNlbGYud29yZHNbaV18MDtiPW51bS53b3Jkc1tqXXwwO3I9YSpiK3J3b3JkO25jYXJyeSs9ci82NzEwODg2NHwwO3J3b3JkPXImNjcxMDg4NjN9b3V0LndvcmRzW2tdPXJ3b3JkfDA7Y2Fycnk9bmNhcnJ5fDB9aWYoY2FycnkhPT0wKXtvdXQud29yZHNba109Y2Fycnl8MH1lbHNle291dC5sZW5ndGgtLX1yZXR1cm4gb3V0LnN0cmlwKCl9dmFyIGNvbWIxME11bFRvPWZ1bmN0aW9uIGNvbWIxME11bFRvKHNlbGYsbnVtLG91dCl7dmFyIGE9c2VsZi53b3Jkczt2YXIgYj1udW0ud29yZHM7dmFyIG89b3V0LndvcmRzO3ZhciBjPTA7dmFyIGxvO3ZhciBtaWQ7dmFyIGhpO3ZhciBhMD1hWzBdfDA7dmFyIGFsMD1hMCY4MTkxO3ZhciBhaDA9YTA+Pj4xMzt2YXIgYTE9YVsxXXwwO3ZhciBhbDE9YTEmODE5MTt2YXIgYWgxPWExPj4+MTM7dmFyIGEyPWFbMl18MDt2YXIgYWwyPWEyJjgxOTE7dmFyIGFoMj1hMj4+PjEzO3ZhciBhMz1hWzNdfDA7dmFyIGFsMz1hMyY4MTkxO3ZhciBhaDM9YTM+Pj4xMzt2YXIgYTQ9YVs0XXwwO3ZhciBhbDQ9YTQmODE5MTt2YXIgYWg0PWE0Pj4+MTM7dmFyIGE1PWFbNV18MDt2YXIgYWw1PWE1JjgxOTE7dmFyIGFoNT1hNT4+PjEzO3ZhciBhNj1hWzZdfDA7dmFyIGFsNj1hNiY4MTkxO3ZhciBhaDY9YTY+Pj4xMzt2YXIgYTc9YVs3XXwwO3ZhciBhbDc9YTcmODE5MTt2YXIgYWg3PWE3Pj4+MTM7dmFyIGE4PWFbOF18MDt2YXIgYWw4PWE4JjgxOTE7dmFyIGFoOD1hOD4+PjEzO3ZhciBhOT1hWzldfDA7dmFyIGFsOT1hOSY4MTkxO3ZhciBhaDk9YTk+Pj4xMzt2YXIgYjA9YlswXXwwO3ZhciBibDA9YjAmODE5MTt2YXIgYmgwPWIwPj4+MTM7dmFyIGIxPWJbMV18MDt2YXIgYmwxPWIxJjgxOTE7dmFyIGJoMT1iMT4+PjEzO3ZhciBiMj1iWzJdfDA7dmFyIGJsMj1iMiY4MTkxO3ZhciBiaDI9YjI+Pj4xMzt2YXIgYjM9YlszXXwwO3ZhciBibDM9YjMmODE5MTt2YXIgYmgzPWIzPj4+MTM7dmFyIGI0PWJbNF18MDt2YXIgYmw0PWI0JjgxOTE7dmFyIGJoND1iND4+PjEzO3ZhciBiNT1iWzVdfDA7dmFyIGJsNT1iNSY4MTkxO3ZhciBiaDU9YjU+Pj4xMzt2YXIgYjY9Yls2XXwwO3ZhciBibDY9YjYmODE5MTt2YXIgYmg2PWI2Pj4+MTM7dmFyIGI3PWJbN118MDt2YXIgYmw3PWI3JjgxOTE7dmFyIGJoNz1iNz4+PjEzO3ZhciBiOD1iWzhdfDA7dmFyIGJsOD1iOCY4MTkxO3ZhciBiaDg9Yjg+Pj4xMzt2YXIgYjk9Yls5XXwwO3ZhciBibDk9YjkmODE5MTt2YXIgYmg5PWI5Pj4+MTM7b3V0Lm5lZ2F0aXZlPXNlbGYubmVnYXRpdmVebnVtLm5lZ2F0aXZlO291dC5sZW5ndGg9MTk7bG89TWF0aC5pbXVsKGFsMCxibDApO21pZD1NYXRoLmltdWwoYWwwLGJoMCk7bWlkPW1pZCtNYXRoLmltdWwoYWgwLGJsMCl8MDtoaT1NYXRoLmltdWwoYWgwLGJoMCk7dmFyIHcwPShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3MD4+PjI2KXwwO3cwJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWwxLGJsMCk7bWlkPU1hdGguaW11bChhbDEsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDEsYmwwKXwwO2hpPU1hdGguaW11bChhaDEsYmgwKTtsbz1sbytNYXRoLmltdWwoYWwwLGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDEpfDA7dmFyIHcxPShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3MT4+PjI2KXwwO3cxJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWwyLGJsMCk7bWlkPU1hdGguaW11bChhbDIsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDIsYmwwKXwwO2hpPU1hdGguaW11bChhaDIsYmgwKTtsbz1sbytNYXRoLmltdWwoYWwxLGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDEsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMSxibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMSxiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsMCxibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwwLGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDAsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDAsYmgyKXwwO3ZhciB3Mj0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzI+Pj4yNil8MDt3MiY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsMyxibDApO21pZD1NYXRoLmltdWwoYWwzLGJoMCk7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsMCl8MDtoaT1NYXRoLmltdWwoYWgzLGJoMCk7bG89bG8rTWF0aC5pbXVsKGFsMixibDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoMSl8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmwxKXwwO2hpPWhpK01hdGguaW11bChhaDIsYmgxKXwwO2xvPWxvK01hdGguaW11bChhbDEsYmwyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsMil8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoMil8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsMyl8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmgzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDMpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDMpfDA7dmFyIHczPShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3Mz4+PjI2KXwwO3czJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw0LGJsMCk7bWlkPU1hdGguaW11bChhbDQsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDQsYmwwKXwwO2hpPU1hdGguaW11bChhaDQsYmgwKTtsbz1sbytNYXRoLmltdWwoYWwzLGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsMixibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDIsYmgyKXwwO2xvPWxvK01hdGguaW11bChhbDEsYmwzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsMyl8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoMyl8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsNCl8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmg0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDQpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDQpfDA7dmFyIHc0PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3ND4+PjI2KXwwO3c0Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw1LGJsMCk7bWlkPU1hdGguaW11bChhbDUsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDUsYmwwKXwwO2hpPU1hdGguaW11bChhaDUsYmgwKTtsbz1sbytNYXRoLmltdWwoYWw0LGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDQsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNCxibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNCxiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsMyxibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwzLGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDMsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDMsYmgyKXwwO2xvPWxvK01hdGguaW11bChhbDIsYmwzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMixiaDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgyLGJsMyl8MDtoaT1oaStNYXRoLmltdWwoYWgyLGJoMyl8MDtsbz1sbytNYXRoLmltdWwoYWwxLGJsNCl8MDttaWQ9bWlkK01hdGguaW11bChhbDEsYmg0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMSxibDQpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMSxiaDQpfDA7bG89bG8rTWF0aC5pbXVsKGFsMCxibDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwwLGJoNSl8MDttaWQ9bWlkK01hdGguaW11bChhaDAsYmw1KXwwO2hpPWhpK01hdGguaW11bChhaDAsYmg1KXwwO3ZhciB3NT0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzU+Pj4yNil8MDt3NSY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsNixibDApO21pZD1NYXRoLmltdWwoYWw2LGJoMCk7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsMCl8MDtoaT1NYXRoLmltdWwoYWg2LGJoMCk7bG89bG8rTWF0aC5pbXVsKGFsNSxibDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw1LGJoMSl8MDttaWQ9bWlkK01hdGguaW11bChhaDUsYmwxKXwwO2hpPWhpK01hdGguaW11bChhaDUsYmgxKXwwO2xvPWxvK01hdGguaW11bChhbDQsYmwyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNCxiaDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg0LGJsMil8MDtoaT1oaStNYXRoLmltdWwoYWg0LGJoMil8MDtsbz1sbytNYXRoLmltdWwoYWwzLGJsMyl8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmgzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDMpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDMpfDA7bG89bG8rTWF0aC5pbXVsKGFsMixibDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoNCl8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmw0KXwwO2hpPWhpK01hdGguaW11bChhaDIsYmg0KXwwO2xvPWxvK01hdGguaW11bChhbDEsYmw1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsNSl8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoNSl8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsNil8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmg2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDYpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDYpfDA7dmFyIHc2PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3Nj4+PjI2KXwwO3c2Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw3LGJsMCk7bWlkPU1hdGguaW11bChhbDcsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDcsYmwwKXwwO2hpPU1hdGguaW11bChhaDcsYmgwKTtsbz1sbytNYXRoLmltdWwoYWw2LGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDYsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNixibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNixiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsNSxibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw1LGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDUsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDUsYmgyKXwwO2xvPWxvK01hdGguaW11bChhbDQsYmwzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNCxiaDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg0LGJsMyl8MDtoaT1oaStNYXRoLmltdWwoYWg0LGJoMyl8MDtsbz1sbytNYXRoLmltdWwoYWwzLGJsNCl8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmg0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDQpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDQpfDA7bG89bG8rTWF0aC5pbXVsKGFsMixibDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoNSl8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmw1KXwwO2hpPWhpK01hdGguaW11bChhaDIsYmg1KXwwO2xvPWxvK01hdGguaW11bChhbDEsYmw2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsNil8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoNil8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsNyl8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmg3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDcpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDcpfDA7dmFyIHc3PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3Nz4+PjI2KXwwO3c3Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw4LGJsMCk7bWlkPU1hdGguaW11bChhbDgsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDgsYmwwKXwwO2hpPU1hdGguaW11bChhaDgsYmgwKTtsbz1sbytNYXRoLmltdWwoYWw3LGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDcsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNyxibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNyxiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsNixibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw2LGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDYsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDYsYmgyKXwwO2xvPWxvK01hdGguaW11bChhbDUsYmwzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNSxiaDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg1LGJsMyl8MDtoaT1oaStNYXRoLmltdWwoYWg1LGJoMyl8MDtsbz1sbytNYXRoLmltdWwoYWw0LGJsNCl8MDttaWQ9bWlkK01hdGguaW11bChhbDQsYmg0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNCxibDQpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNCxiaDQpfDA7bG89bG8rTWF0aC5pbXVsKGFsMyxibDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwzLGJoNSl8MDttaWQ9bWlkK01hdGguaW11bChhaDMsYmw1KXwwO2hpPWhpK01hdGguaW11bChhaDMsYmg1KXwwO2xvPWxvK01hdGguaW11bChhbDIsYmw2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMixiaDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgyLGJsNil8MDtoaT1oaStNYXRoLmltdWwoYWgyLGJoNil8MDtsbz1sbytNYXRoLmltdWwoYWwxLGJsNyl8MDttaWQ9bWlkK01hdGguaW11bChhbDEsYmg3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMSxibDcpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMSxiaDcpfDA7bG89bG8rTWF0aC5pbXVsKGFsMCxibDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwwLGJoOCl8MDttaWQ9bWlkK01hdGguaW11bChhaDAsYmw4KXwwO2hpPWhpK01hdGguaW11bChhaDAsYmg4KXwwO3ZhciB3OD0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzg+Pj4yNil8MDt3OCY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsOSxibDApO21pZD1NYXRoLmltdWwoYWw5LGJoMCk7bWlkPW1pZCtNYXRoLmltdWwoYWg5LGJsMCl8MDtoaT1NYXRoLmltdWwoYWg5LGJoMCk7bG89bG8rTWF0aC5pbXVsKGFsOCxibDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw4LGJoMSl8MDttaWQ9bWlkK01hdGguaW11bChhaDgsYmwxKXwwO2hpPWhpK01hdGguaW11bChhaDgsYmgxKXwwO2xvPWxvK01hdGguaW11bChhbDcsYmwyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNyxiaDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg3LGJsMil8MDtoaT1oaStNYXRoLmltdWwoYWg3LGJoMil8MDtsbz1sbytNYXRoLmltdWwoYWw2LGJsMyl8MDttaWQ9bWlkK01hdGguaW11bChhbDYsYmgzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNixibDMpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNixiaDMpfDA7bG89bG8rTWF0aC5pbXVsKGFsNSxibDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw1LGJoNCl8MDttaWQ9bWlkK01hdGguaW11bChhaDUsYmw0KXwwO2hpPWhpK01hdGguaW11bChhaDUsYmg0KXwwO2xvPWxvK01hdGguaW11bChhbDQsYmw1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNCxiaDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg0LGJsNSl8MDtoaT1oaStNYXRoLmltdWwoYWg0LGJoNSl8MDtsbz1sbytNYXRoLmltdWwoYWwzLGJsNil8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmg2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDYpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDYpfDA7bG89bG8rTWF0aC5pbXVsKGFsMixibDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoNyl8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmw3KXwwO2hpPWhpK01hdGguaW11bChhaDIsYmg3KXwwO2xvPWxvK01hdGguaW11bChhbDEsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDkpfDA7dmFyIHc5PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3OT4+PjI2KXwwO3c5Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsMSk7bWlkPU1hdGguaW11bChhbDksYmgxKTttaWQ9bWlkK01hdGguaW11bChhaDksYmwxKXwwO2hpPU1hdGguaW11bChhaDksYmgxKTtsbz1sbytNYXRoLmltdWwoYWw4LGJsMil8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmgyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDIpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDIpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoMyl8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmwzKXwwO2hpPWhpK01hdGguaW11bChhaDcsYmgzKXwwO2xvPWxvK01hdGguaW11bChhbDYsYmw0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsNCl8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoNCl8MDtsbz1sbytNYXRoLmltdWwoYWw1LGJsNSl8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmg1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDUpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDUpfDA7bG89bG8rTWF0aC5pbXVsKGFsNCxibDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw0LGJoNil8MDttaWQ9bWlkK01hdGguaW11bChhaDQsYmw2KXwwO2hpPWhpK01hdGguaW11bChhaDQsYmg2KXwwO2xvPWxvK01hdGguaW11bChhbDMsYmw3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMyxiaDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsNyl8MDtoaT1oaStNYXRoLmltdWwoYWgzLGJoNyl8MDtsbz1sbytNYXRoLmltdWwoYWwyLGJsOCl8MDttaWQ9bWlkK01hdGguaW11bChhbDIsYmg4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDgpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMixiaDgpfDA7bG89bG8rTWF0aC5pbXVsKGFsMSxibDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwxLGJoOSl8MDttaWQ9bWlkK01hdGguaW11bChhaDEsYmw5KXwwO2hpPWhpK01hdGguaW11bChhaDEsYmg5KXwwO3ZhciB3MTA9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcxMD4+PjI2KXwwO3cxMCY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsOSxibDIpO21pZD1NYXRoLmltdWwoYWw5LGJoMik7bWlkPW1pZCtNYXRoLmltdWwoYWg5LGJsMil8MDtoaT1NYXRoLmltdWwoYWg5LGJoMik7bG89bG8rTWF0aC5pbXVsKGFsOCxibDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw4LGJoMyl8MDttaWQ9bWlkK01hdGguaW11bChhaDgsYmwzKXwwO2hpPWhpK01hdGguaW11bChhaDgsYmgzKXwwO2xvPWxvK01hdGguaW11bChhbDcsYmw0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNyxiaDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg3LGJsNCl8MDtoaT1oaStNYXRoLmltdWwoYWg3LGJoNCl8MDtsbz1sbytNYXRoLmltdWwoYWw2LGJsNSl8MDttaWQ9bWlkK01hdGguaW11bChhbDYsYmg1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNixibDUpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNixiaDUpfDA7bG89bG8rTWF0aC5pbXVsKGFsNSxibDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw1LGJoNil8MDttaWQ9bWlkK01hdGguaW11bChhaDUsYmw2KXwwO2hpPWhpK01hdGguaW11bChhaDUsYmg2KXwwO2xvPWxvK01hdGguaW11bChhbDQsYmw3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNCxiaDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg0LGJsNyl8MDtoaT1oaStNYXRoLmltdWwoYWg0LGJoNyl8MDtsbz1sbytNYXRoLmltdWwoYWwzLGJsOCl8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmg4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDgpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDgpfDA7bG89bG8rTWF0aC5pbXVsKGFsMixibDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoOSl8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmw5KXwwO2hpPWhpK01hdGguaW11bChhaDIsYmg5KXwwO3ZhciB3MTE9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcxMT4+PjI2KXwwO3cxMSY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsOSxibDMpO21pZD1NYXRoLmltdWwoYWw5LGJoMyk7bWlkPW1pZCtNYXRoLmltdWwoYWg5LGJsMyl8MDtoaT1NYXRoLmltdWwoYWg5LGJoMyk7bG89bG8rTWF0aC5pbXVsKGFsOCxibDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw4LGJoNCl8MDttaWQ9bWlkK01hdGguaW11bChhaDgsYmw0KXwwO2hpPWhpK01hdGguaW11bChhaDgsYmg0KXwwO2xvPWxvK01hdGguaW11bChhbDcsYmw1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNyxiaDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg3LGJsNSl8MDtoaT1oaStNYXRoLmltdWwoYWg3LGJoNSl8MDtsbz1sbytNYXRoLmltdWwoYWw2LGJsNil8MDttaWQ9bWlkK01hdGguaW11bChhbDYsYmg2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNixibDYpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNixiaDYpfDA7bG89bG8rTWF0aC5pbXVsKGFsNSxibDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw1LGJoNyl8MDttaWQ9bWlkK01hdGguaW11bChhaDUsYmw3KXwwO2hpPWhpK01hdGguaW11bChhaDUsYmg3KXwwO2xvPWxvK01hdGguaW11bChhbDQsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNCxiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg0LGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWg0LGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWwzLGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDkpfDA7dmFyIHcxMj0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzEyPj4+MjYpfDA7dzEyJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsNCk7bWlkPU1hdGguaW11bChhbDksYmg0KTttaWQ9bWlkK01hdGguaW11bChhaDksYmw0KXwwO2hpPU1hdGguaW11bChhaDksYmg0KTtsbz1sbytNYXRoLmltdWwoYWw4LGJsNSl8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmg1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDUpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDUpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoNil8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmw2KXwwO2hpPWhpK01hdGguaW11bChhaDcsYmg2KXwwO2xvPWxvK01hdGguaW11bChhbDYsYmw3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsNyl8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoNyl8MDtsbz1sbytNYXRoLmltdWwoYWw1LGJsOCl8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmg4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDgpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDgpfDA7bG89bG8rTWF0aC5pbXVsKGFsNCxibDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw0LGJoOSl8MDttaWQ9bWlkK01hdGguaW11bChhaDQsYmw5KXwwO2hpPWhpK01hdGguaW11bChhaDQsYmg5KXwwO3ZhciB3MTM9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcxMz4+PjI2KXwwO3cxMyY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsOSxibDUpO21pZD1NYXRoLmltdWwoYWw5LGJoNSk7bWlkPW1pZCtNYXRoLmltdWwoYWg5LGJsNSl8MDtoaT1NYXRoLmltdWwoYWg5LGJoNSk7bG89bG8rTWF0aC5pbXVsKGFsOCxibDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw4LGJoNil8MDttaWQ9bWlkK01hdGguaW11bChhaDgsYmw2KXwwO2hpPWhpK01hdGguaW11bChhaDgsYmg2KXwwO2xvPWxvK01hdGguaW11bChhbDcsYmw3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNyxiaDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg3LGJsNyl8MDtoaT1oaStNYXRoLmltdWwoYWg3LGJoNyl8MDtsbz1sbytNYXRoLmltdWwoYWw2LGJsOCl8MDttaWQ9bWlkK01hdGguaW11bChhbDYsYmg4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNixibDgpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNixiaDgpfDA7bG89bG8rTWF0aC5pbXVsKGFsNSxibDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw1LGJoOSl8MDttaWQ9bWlkK01hdGguaW11bChhaDUsYmw5KXwwO2hpPWhpK01hdGguaW11bChhaDUsYmg5KXwwO3ZhciB3MTQ9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcxND4+PjI2KXwwO3cxNCY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsOSxibDYpO21pZD1NYXRoLmltdWwoYWw5LGJoNik7bWlkPW1pZCtNYXRoLmltdWwoYWg5LGJsNil8MDtoaT1NYXRoLmltdWwoYWg5LGJoNik7bG89bG8rTWF0aC5pbXVsKGFsOCxibDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw4LGJoNyl8MDttaWQ9bWlkK01hdGguaW11bChhaDgsYmw3KXwwO2hpPWhpK01hdGguaW11bChhaDgsYmg3KXwwO2xvPWxvK01hdGguaW11bChhbDcsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNyxiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg3LGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWg3LGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWw2LGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDYsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNixibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNixiaDkpfDA7dmFyIHcxNT0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzE1Pj4+MjYpfDA7dzE1Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsNyk7bWlkPU1hdGguaW11bChhbDksYmg3KTttaWQ9bWlkK01hdGguaW11bChhaDksYmw3KXwwO2hpPU1hdGguaW11bChhaDksYmg3KTtsbz1sbytNYXRoLmltdWwoYWw4LGJsOCl8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmg4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDgpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDgpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoOSl8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmw5KXwwO2hpPWhpK01hdGguaW11bChhaDcsYmg5KXwwO3ZhciB3MTY9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcxNj4+PjI2KXwwO3cxNiY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsOSxibDgpO21pZD1NYXRoLmltdWwoYWw5LGJoOCk7bWlkPW1pZCtNYXRoLmltdWwoYWg5LGJsOCl8MDtoaT1NYXRoLmltdWwoYWg5LGJoOCk7bG89bG8rTWF0aC5pbXVsKGFsOCxibDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw4LGJoOSl8MDttaWQ9bWlkK01hdGguaW11bChhaDgsYmw5KXwwO2hpPWhpK01hdGguaW11bChhaDgsYmg5KXwwO3ZhciB3MTc9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcxNz4+PjI2KXwwO3cxNyY9NjcxMDg4NjM7bG89TWF0aC5pbXVsKGFsOSxibDkpO21pZD1NYXRoLmltdWwoYWw5LGJoOSk7bWlkPW1pZCtNYXRoLmltdWwoYWg5LGJsOSl8MDtoaT1NYXRoLmltdWwoYWg5LGJoOSk7dmFyIHcxOD0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzE4Pj4+MjYpfDA7dzE4Jj02NzEwODg2MztvWzBdPXcwO29bMV09dzE7b1syXT13MjtvWzNdPXczO29bNF09dzQ7b1s1XT13NTtvWzZdPXc2O29bN109dzc7b1s4XT13ODtvWzldPXc5O29bMTBdPXcxMDtvWzExXT13MTE7b1sxMl09dzEyO29bMTNdPXcxMztvWzE0XT13MTQ7b1sxNV09dzE1O29bMTZdPXcxNjtvWzE3XT13MTc7b1sxOF09dzE4O2lmKGMhPT0wKXtvWzE5XT1jO291dC5sZW5ndGgrK31yZXR1cm4gb3V0fTtpZighTWF0aC5pbXVsKXtjb21iMTBNdWxUbz1zbWFsbE11bFRvfWZ1bmN0aW9uIGJpZ011bFRvKHNlbGYsbnVtLG91dCl7b3V0Lm5lZ2F0aXZlPW51bS5uZWdhdGl2ZV5zZWxmLm5lZ2F0aXZlO291dC5sZW5ndGg9c2VsZi5sZW5ndGgrbnVtLmxlbmd0aDt2YXIgY2Fycnk9MDt2YXIgaG5jYXJyeT0wO2Zvcih2YXIgaz0wO2s8b3V0Lmxlbmd0aC0xO2srKyl7dmFyIG5jYXJyeT1obmNhcnJ5O2huY2Fycnk9MDt2YXIgcndvcmQ9Y2FycnkmNjcxMDg4NjM7dmFyIG1heEo9TWF0aC5taW4oayxudW0ubGVuZ3RoLTEpO2Zvcih2YXIgaj1NYXRoLm1heCgwLGstc2VsZi5sZW5ndGgrMSk7ajw9bWF4SjtqKyspe3ZhciBpPWstajt2YXIgYT1zZWxmLndvcmRzW2ldfDA7dmFyIGI9bnVtLndvcmRzW2pdfDA7dmFyIHI9YSpiO3ZhciBsbz1yJjY3MTA4ODYzO25jYXJyeT1uY2FycnkrKHIvNjcxMDg4NjR8MCl8MDtsbz1sbytyd29yZHwwO3J3b3JkPWxvJjY3MTA4ODYzO25jYXJyeT1uY2FycnkrKGxvPj4+MjYpfDA7aG5jYXJyeSs9bmNhcnJ5Pj4+MjY7bmNhcnJ5Jj02NzEwODg2M31vdXQud29yZHNba109cndvcmQ7Y2Fycnk9bmNhcnJ5O25jYXJyeT1obmNhcnJ5fWlmKGNhcnJ5IT09MCl7b3V0LndvcmRzW2tdPWNhcnJ5fWVsc2V7b3V0Lmxlbmd0aC0tfXJldHVybiBvdXQuc3RyaXAoKX1mdW5jdGlvbiBqdW1ib011bFRvKHNlbGYsbnVtLG91dCl7dmFyIGZmdG09bmV3IEZGVE07cmV0dXJuIGZmdG0ubXVscChzZWxmLG51bSxvdXQpfUJOLnByb3RvdHlwZS5tdWxUbz1mdW5jdGlvbiBtdWxUbyhudW0sb3V0KXt2YXIgcmVzO3ZhciBsZW49dGhpcy5sZW5ndGgrbnVtLmxlbmd0aDtpZih0aGlzLmxlbmd0aD09PTEwJiZudW0ubGVuZ3RoPT09MTApe3Jlcz1jb21iMTBNdWxUbyh0aGlzLG51bSxvdXQpfWVsc2UgaWYobGVuPDYzKXtyZXM9c21hbGxNdWxUbyh0aGlzLG51bSxvdXQpfWVsc2UgaWYobGVuPDEwMjQpe3Jlcz1iaWdNdWxUbyh0aGlzLG51bSxvdXQpfWVsc2V7cmVzPWp1bWJvTXVsVG8odGhpcyxudW0sb3V0KX1yZXR1cm4gcmVzfTtmdW5jdGlvbiBGRlRNKHgseSl7dGhpcy54PXg7dGhpcy55PXl9RkZUTS5wcm90b3R5cGUubWFrZVJCVD1mdW5jdGlvbiBtYWtlUkJUKE4pe3ZhciB0PW5ldyBBcnJheShOKTt2YXIgbD1CTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKS0xO2Zvcih2YXIgaT0wO2k8TjtpKyspe3RbaV09dGhpcy5yZXZCaW4oaSxsLE4pfXJldHVybiB0fTtGRlRNLnByb3RvdHlwZS5yZXZCaW49ZnVuY3Rpb24gcmV2QmluKHgsbCxOKXtpZih4PT09MHx8eD09PU4tMSlyZXR1cm4geDt2YXIgcmI9MDtmb3IodmFyIGk9MDtpPGw7aSsrKXtyYnw9KHgmMSk8PGwtaS0xO3g+Pj0xfXJldHVybiByYn07RkZUTS5wcm90b3R5cGUucGVybXV0ZT1mdW5jdGlvbiBwZXJtdXRlKHJidCxyd3MsaXdzLHJ0d3MsaXR3cyxOKXtmb3IodmFyIGk9MDtpPE47aSsrKXtydHdzW2ldPXJ3c1tyYnRbaV1dO2l0d3NbaV09aXdzW3JidFtpXV19fTtGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24gdHJhbnNmb3JtKHJ3cyxpd3MscnR3cyxpdHdzLE4scmJ0KXt0aGlzLnBlcm11dGUocmJ0LHJ3cyxpd3MscnR3cyxpdHdzLE4pO2Zvcih2YXIgcz0xO3M8TjtzPDw9MSl7dmFyIGw9czw8MTt2YXIgcnR3ZGY9TWF0aC5jb3MoMipNYXRoLlBJL2wpO3ZhciBpdHdkZj1NYXRoLnNpbigyKk1hdGguUEkvbCk7Zm9yKHZhciBwPTA7cDxOO3ArPWwpe3ZhciBydHdkZl89cnR3ZGY7dmFyIGl0d2RmXz1pdHdkZjtmb3IodmFyIGo9MDtqPHM7aisrKXt2YXIgcmU9cnR3c1twK2pdO3ZhciBpZT1pdHdzW3Aral07dmFyIHJvPXJ0d3NbcCtqK3NdO3ZhciBpbz1pdHdzW3AraitzXTt2YXIgcng9cnR3ZGZfKnJvLWl0d2RmXyppbztpbz1ydHdkZl8qaW8raXR3ZGZfKnJvO3JvPXJ4O3J0d3NbcCtqXT1yZStybztpdHdzW3Aral09aWUraW87cnR3c1twK2orc109cmUtcm87aXR3c1twK2orc109aWUtaW87aWYoaiE9PWwpe3J4PXJ0d2RmKnJ0d2RmXy1pdHdkZippdHdkZl87aXR3ZGZfPXJ0d2RmKml0d2RmXytpdHdkZipydHdkZl87cnR3ZGZfPXJ4fX19fX07RkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2I9ZnVuY3Rpb24gZ3Vlc3NMZW4xM2IobixtKXt2YXIgTj1NYXRoLm1heChtLG4pfDE7dmFyIG9kZD1OJjE7dmFyIGk9MDtmb3IoTj1OLzJ8MDtOO049Tj4+PjEpe2krK31yZXR1cm4gMTw8aSsxK29kZH07RkZUTS5wcm90b3R5cGUuY29uanVnYXRlPWZ1bmN0aW9uIGNvbmp1Z2F0ZShyd3MsaXdzLE4pe2lmKE48PTEpcmV0dXJuO2Zvcih2YXIgaT0wO2k8Ti8yO2krKyl7dmFyIHQ9cndzW2ldO3J3c1tpXT1yd3NbTi1pLTFdO3J3c1tOLWktMV09dDt0PWl3c1tpXTtpd3NbaV09LWl3c1tOLWktMV07aXdzW04taS0xXT0tdH19O0ZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYj1mdW5jdGlvbiBub3JtYWxpemUxM2Iod3MsTil7dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPTA7aTxOLzI7aSsrKXt2YXIgdz1NYXRoLnJvdW5kKHdzWzIqaSsxXS9OKSo4MTkyK01hdGgucm91bmQod3NbMippXS9OKStjYXJyeTt3c1tpXT13JjY3MTA4ODYzO2lmKHc8NjcxMDg4NjQpe2NhcnJ5PTB9ZWxzZXtjYXJyeT13LzY3MTA4ODY0fDB9fXJldHVybiB3c307RkZUTS5wcm90b3R5cGUuY29udmVydDEzYj1mdW5jdGlvbiBjb252ZXJ0MTNiKHdzLGxlbixyd3MsTil7dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtjYXJyeT1jYXJyeSsod3NbaV18MCk7cndzWzIqaV09Y2FycnkmODE5MTtjYXJyeT1jYXJyeT4+PjEzO3J3c1syKmkrMV09Y2FycnkmODE5MTtjYXJyeT1jYXJyeT4+PjEzfWZvcihpPTIqbGVuO2k8TjsrK2kpe3J3c1tpXT0wfWFzc2VydChjYXJyeT09PTApO2Fzc2VydCgoY2FycnkmfjgxOTEpPT09MCl9O0ZGVE0ucHJvdG90eXBlLnN0dWI9ZnVuY3Rpb24gc3R1YihOKXt2YXIgcGg9bmV3IEFycmF5KE4pO2Zvcih2YXIgaT0wO2k8TjtpKyspe3BoW2ldPTB9cmV0dXJuIHBofTtGRlRNLnByb3RvdHlwZS5tdWxwPWZ1bmN0aW9uIG11bHAoeCx5LG91dCl7dmFyIE49Mip0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLHkubGVuZ3RoKTt2YXIgcmJ0PXRoaXMubWFrZVJCVChOKTt2YXIgXz10aGlzLnN0dWIoTik7dmFyIHJ3cz1uZXcgQXJyYXkoTik7dmFyIHJ3c3Q9bmV3IEFycmF5KE4pO3ZhciBpd3N0PW5ldyBBcnJheShOKTt2YXIgbnJ3cz1uZXcgQXJyYXkoTik7dmFyIG5yd3N0PW5ldyBBcnJheShOKTt2YXIgbml3c3Q9bmV3IEFycmF5KE4pO3ZhciBybXdzPW91dC53b3JkcztybXdzLmxlbmd0aD1OO3RoaXMuY29udmVydDEzYih4LndvcmRzLHgubGVuZ3RoLHJ3cyxOKTt0aGlzLmNvbnZlcnQxM2IoeS53b3Jkcyx5Lmxlbmd0aCxucndzLE4pO3RoaXMudHJhbnNmb3JtKHJ3cyxfLHJ3c3QsaXdzdCxOLHJidCk7dGhpcy50cmFuc2Zvcm0obnJ3cyxfLG5yd3N0LG5pd3N0LE4scmJ0KTtmb3IodmFyIGk9MDtpPE47aSsrKXt2YXIgcng9cndzdFtpXSpucndzdFtpXS1pd3N0W2ldKm5pd3N0W2ldO2l3c3RbaV09cndzdFtpXSpuaXdzdFtpXStpd3N0W2ldKm5yd3N0W2ldO3J3c3RbaV09cnh9dGhpcy5jb25qdWdhdGUocndzdCxpd3N0LE4pO3RoaXMudHJhbnNmb3JtKHJ3c3QsaXdzdCxybXdzLF8sTixyYnQpO3RoaXMuY29uanVnYXRlKHJtd3MsXyxOKTt0aGlzLm5vcm1hbGl6ZTEzYihybXdzLE4pO291dC5uZWdhdGl2ZT14Lm5lZ2F0aXZlXnkubmVnYXRpdmU7b3V0Lmxlbmd0aD14Lmxlbmd0aCt5Lmxlbmd0aDtyZXR1cm4gb3V0LnN0cmlwKCl9O0JOLnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24gbXVsKG51bSl7dmFyIG91dD1uZXcgQk4obnVsbCk7b3V0LndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCtudW0ubGVuZ3RoKTtyZXR1cm4gdGhpcy5tdWxUbyhudW0sb3V0KX07Qk4ucHJvdG90eXBlLm11bGY9ZnVuY3Rpb24gbXVsZihudW0pe3ZhciBvdXQ9bmV3IEJOKG51bGwpO291dC53b3Jkcz1uZXcgQXJyYXkodGhpcy5sZW5ndGgrbnVtLmxlbmd0aCk7cmV0dXJuIGp1bWJvTXVsVG8odGhpcyxudW0sb3V0KX07Qk4ucHJvdG90eXBlLmltdWw9ZnVuY3Rpb24gaW11bChudW0pe3JldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLHRoaXMpfTtCTi5wcm90b3R5cGUuaW11bG49ZnVuY3Rpb24gaW11bG4obnVtKXthc3NlcnQodHlwZW9mIG51bT09PVwibnVtYmVyXCIpO2Fzc2VydChudW08NjcxMDg4NjQpO3ZhciBjYXJyeT0wO2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt2YXIgdz0odGhpcy53b3Jkc1tpXXwwKSpudW07dmFyIGxvPSh3JjY3MTA4ODYzKSsoY2FycnkmNjcxMDg4NjMpO2NhcnJ5Pj49MjY7Y2FycnkrPXcvNjcxMDg4NjR8MDtjYXJyeSs9bG8+Pj4yNjt0aGlzLndvcmRzW2ldPWxvJjY3MTA4ODYzfWlmKGNhcnJ5IT09MCl7dGhpcy53b3Jkc1tpXT1jYXJyeTt0aGlzLmxlbmd0aCsrfXJldHVybiB0aGlzfTtCTi5wcm90b3R5cGUubXVsbj1mdW5jdGlvbiBtdWxuKG51bSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pfTtCTi5wcm90b3R5cGUuc3FyPWZ1bmN0aW9uIHNxcigpe3JldHVybiB0aGlzLm11bCh0aGlzKX07Qk4ucHJvdG90eXBlLmlzcXI9ZnVuY3Rpb24gaXNxcigpe3JldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKX07Qk4ucHJvdG90eXBlLnBvdz1mdW5jdGlvbiBwb3cobnVtKXt2YXIgdz10b0JpdEFycmF5KG51bSk7aWYody5sZW5ndGg9PT0wKXJldHVybiBuZXcgQk4oMSk7dmFyIHJlcz10aGlzO2Zvcih2YXIgaT0wO2k8dy5sZW5ndGg7aSsrLHJlcz1yZXMuc3FyKCkpe2lmKHdbaV0hPT0wKWJyZWFrfWlmKCsraTx3Lmxlbmd0aCl7Zm9yKHZhciBxPXJlcy5zcXIoKTtpPHcubGVuZ3RoO2krKyxxPXEuc3FyKCkpe2lmKHdbaV09PT0wKWNvbnRpbnVlO3Jlcz1yZXMubXVsKHEpfX1yZXR1cm4gcmVzfTtCTi5wcm90b3R5cGUuaXVzaGxuPWZ1bmN0aW9uIGl1c2hsbihiaXRzKXthc3NlcnQodHlwZW9mIGJpdHM9PT1cIm51bWJlclwiJiZiaXRzPj0wKTt2YXIgcj1iaXRzJTI2O3ZhciBzPShiaXRzLXIpLzI2O3ZhciBjYXJyeU1hc2s9NjcxMDg4NjM+Pj4yNi1yPDwyNi1yO3ZhciBpO2lmKHIhPT0wKXt2YXIgY2Fycnk9MDtmb3IoaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt2YXIgbmV3Q2Fycnk9dGhpcy53b3Jkc1tpXSZjYXJyeU1hc2s7dmFyIGM9KHRoaXMud29yZHNbaV18MCktbmV3Q2Fycnk8PHI7dGhpcy53b3Jkc1tpXT1jfGNhcnJ5O2NhcnJ5PW5ld0NhcnJ5Pj4+MjYtcn1pZihjYXJyeSl7dGhpcy53b3Jkc1tpXT1jYXJyeTt0aGlzLmxlbmd0aCsrfX1pZihzIT09MCl7Zm9yKGk9dGhpcy5sZW5ndGgtMTtpPj0wO2ktLSl7dGhpcy53b3Jkc1tpK3NdPXRoaXMud29yZHNbaV19Zm9yKGk9MDtpPHM7aSsrKXt0aGlzLndvcmRzW2ldPTB9dGhpcy5sZW5ndGgrPXN9cmV0dXJuIHRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLmlzaGxuPWZ1bmN0aW9uIGlzaGxuKGJpdHMpe2Fzc2VydCh0aGlzLm5lZ2F0aXZlPT09MCk7cmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpfTtCTi5wcm90b3R5cGUuaXVzaHJuPWZ1bmN0aW9uIGl1c2hybihiaXRzLGhpbnQsZXh0ZW5kZWQpe2Fzc2VydCh0eXBlb2YgYml0cz09PVwibnVtYmVyXCImJmJpdHM+PTApO3ZhciBoO2lmKGhpbnQpe2g9KGhpbnQtaGludCUyNikvMjZ9ZWxzZXtoPTB9dmFyIHI9Yml0cyUyNjt2YXIgcz1NYXRoLm1pbigoYml0cy1yKS8yNix0aGlzLmxlbmd0aCk7dmFyIG1hc2s9NjcxMDg4NjNeNjcxMDg4NjM+Pj5yPDxyO3ZhciBtYXNrZWRXb3Jkcz1leHRlbmRlZDtoLT1zO2g9TWF0aC5tYXgoMCxoKTtpZihtYXNrZWRXb3Jkcyl7Zm9yKHZhciBpPTA7aTxzO2krKyl7bWFza2VkV29yZHMud29yZHNbaV09dGhpcy53b3Jkc1tpXX1tYXNrZWRXb3Jkcy5sZW5ndGg9c31pZihzPT09MCl7fWVsc2UgaWYodGhpcy5sZW5ndGg+cyl7dGhpcy5sZW5ndGgtPXM7Zm9yKGk9MDtpPHRoaXMubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT10aGlzLndvcmRzW2krc119fWVsc2V7dGhpcy53b3Jkc1swXT0wO3RoaXMubGVuZ3RoPTF9dmFyIGNhcnJ5PTA7Zm9yKGk9dGhpcy5sZW5ndGgtMTtpPj0wJiYoY2FycnkhPT0wfHxpPj1oKTtpLS0pe3ZhciB3b3JkPXRoaXMud29yZHNbaV18MDt0aGlzLndvcmRzW2ldPWNhcnJ5PDwyNi1yfHdvcmQ+Pj5yO2NhcnJ5PXdvcmQmbWFza31pZihtYXNrZWRXb3JkcyYmY2FycnkhPT0wKXttYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK109Y2Fycnl9aWYodGhpcy5sZW5ndGg9PT0wKXt0aGlzLndvcmRzWzBdPTA7dGhpcy5sZW5ndGg9MX1yZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuaXNocm49ZnVuY3Rpb24gaXNocm4oYml0cyxoaW50LGV4dGVuZGVkKXthc3NlcnQodGhpcy5uZWdhdGl2ZT09PTApO3JldHVybiB0aGlzLml1c2hybihiaXRzLGhpbnQsZXh0ZW5kZWQpfTtCTi5wcm90b3R5cGUuc2hsbj1mdW5jdGlvbiBzaGxuKGJpdHMpe3JldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyl9O0JOLnByb3RvdHlwZS51c2hsbj1mdW5jdGlvbiB1c2hsbihiaXRzKXtyZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKX07Qk4ucHJvdG90eXBlLnNocm49ZnVuY3Rpb24gc2hybihiaXRzKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpfTtCTi5wcm90b3R5cGUudXNocm49ZnVuY3Rpb24gdXNocm4oYml0cyl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyl9O0JOLnByb3RvdHlwZS50ZXN0bj1mdW5jdGlvbiB0ZXN0bihiaXQpe2Fzc2VydCh0eXBlb2YgYml0PT09XCJudW1iZXJcIiYmYml0Pj0wKTt2YXIgcj1iaXQlMjY7dmFyIHM9KGJpdC1yKS8yNjt2YXIgcT0xPDxyO2lmKHRoaXMubGVuZ3RoPD1zKXJldHVybiBmYWxzZTt2YXIgdz10aGlzLndvcmRzW3NdO3JldHVybiEhKHcmcSl9O0JOLnByb3RvdHlwZS5pbWFza249ZnVuY3Rpb24gaW1hc2tuKGJpdHMpe2Fzc2VydCh0eXBlb2YgYml0cz09PVwibnVtYmVyXCImJmJpdHM+PTApO3ZhciByPWJpdHMlMjY7dmFyIHM9KGJpdHMtcikvMjY7YXNzZXJ0KHRoaXMubmVnYXRpdmU9PT0wLFwiaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzXCIpO2lmKHRoaXMubGVuZ3RoPD1zKXtyZXR1cm4gdGhpc31pZihyIT09MCl7cysrfXRoaXMubGVuZ3RoPU1hdGgubWluKHMsdGhpcy5sZW5ndGgpO2lmKHIhPT0wKXt2YXIgbWFzaz02NzEwODg2M142NzEwODg2Mz4+PnI8PHI7dGhpcy53b3Jkc1t0aGlzLmxlbmd0aC0xXSY9bWFza31yZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUubWFza249ZnVuY3Rpb24gbWFza24oYml0cyl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyl9O0JOLnByb3RvdHlwZS5pYWRkbj1mdW5jdGlvbiBpYWRkbihudW0pe2Fzc2VydCh0eXBlb2YgbnVtPT09XCJudW1iZXJcIik7YXNzZXJ0KG51bTw2NzEwODg2NCk7aWYobnVtPDApcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7aWYodGhpcy5uZWdhdGl2ZSE9PTApe2lmKHRoaXMubGVuZ3RoPT09MSYmKHRoaXMud29yZHNbMF18MCk8bnVtKXt0aGlzLndvcmRzWzBdPW51bS0odGhpcy53b3Jkc1swXXwwKTt0aGlzLm5lZ2F0aXZlPTA7cmV0dXJuIHRoaXN9dGhpcy5uZWdhdGl2ZT0wO3RoaXMuaXN1Ym4obnVtKTt0aGlzLm5lZ2F0aXZlPTE7cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMuX2lhZGRuKG51bSl9O0JOLnByb3RvdHlwZS5faWFkZG49ZnVuY3Rpb24gX2lhZGRuKG51bSl7dGhpcy53b3Jkc1swXSs9bnVtO2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGgmJnRoaXMud29yZHNbaV0+PTY3MTA4ODY0O2krKyl7dGhpcy53b3Jkc1tpXS09NjcxMDg4NjQ7aWYoaT09PXRoaXMubGVuZ3RoLTEpe3RoaXMud29yZHNbaSsxXT0xfWVsc2V7dGhpcy53b3Jkc1tpKzFdKyt9fXRoaXMubGVuZ3RoPU1hdGgubWF4KHRoaXMubGVuZ3RoLGkrMSk7cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5pc3Vibj1mdW5jdGlvbiBpc3VibihudW0pe2Fzc2VydCh0eXBlb2YgbnVtPT09XCJudW1iZXJcIik7YXNzZXJ0KG51bTw2NzEwODg2NCk7aWYobnVtPDApcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7aWYodGhpcy5uZWdhdGl2ZSE9PTApe3RoaXMubmVnYXRpdmU9MDt0aGlzLmlhZGRuKG51bSk7dGhpcy5uZWdhdGl2ZT0xO3JldHVybiB0aGlzfXRoaXMud29yZHNbMF0tPW51bTtpZih0aGlzLmxlbmd0aD09PTEmJnRoaXMud29yZHNbMF08MCl7dGhpcy53b3Jkc1swXT0tdGhpcy53b3Jkc1swXTt0aGlzLm5lZ2F0aXZlPTF9ZWxzZXtmb3IodmFyIGk9MDtpPHRoaXMubGVuZ3RoJiZ0aGlzLndvcmRzW2ldPDA7aSsrKXt0aGlzLndvcmRzW2ldKz02NzEwODg2NDt0aGlzLndvcmRzW2krMV0tPTF9fXJldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5hZGRuPWZ1bmN0aW9uIGFkZG4obnVtKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSl9O0JOLnByb3RvdHlwZS5zdWJuPWZ1bmN0aW9uIHN1Ym4obnVtKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSl9O0JOLnByb3RvdHlwZS5pYWJzPWZ1bmN0aW9uIGlhYnMoKXt0aGlzLm5lZ2F0aXZlPTA7cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24gYWJzKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCl9O0JOLnByb3RvdHlwZS5faXNobG5zdWJtdWw9ZnVuY3Rpb24gX2lzaGxuc3VibXVsKG51bSxtdWwsc2hpZnQpe3ZhciBsZW49bnVtLmxlbmd0aCtzaGlmdDt2YXIgaTt0aGlzLl9leHBhbmQobGVuKTt2YXIgdzt2YXIgY2Fycnk9MDtmb3IoaT0wO2k8bnVtLmxlbmd0aDtpKyspe3c9KHRoaXMud29yZHNbaStzaGlmdF18MCkrY2Fycnk7dmFyIHJpZ2h0PShudW0ud29yZHNbaV18MCkqbXVsO3ctPXJpZ2h0JjY3MTA4ODYzO2NhcnJ5PSh3Pj4yNiktKHJpZ2h0LzY3MTA4ODY0fDApO3RoaXMud29yZHNbaStzaGlmdF09dyY2NzEwODg2M31mb3IoO2k8dGhpcy5sZW5ndGgtc2hpZnQ7aSsrKXt3PSh0aGlzLndvcmRzW2krc2hpZnRdfDApK2NhcnJ5O2NhcnJ5PXc+PjI2O3RoaXMud29yZHNbaStzaGlmdF09dyY2NzEwODg2M31pZihjYXJyeT09PTApcmV0dXJuIHRoaXMuc3RyaXAoKTthc3NlcnQoY2Fycnk9PT0tMSk7Y2Fycnk9MDtmb3IoaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt3PS0odGhpcy53b3Jkc1tpXXwwKStjYXJyeTtjYXJyeT13Pj4yNjt0aGlzLndvcmRzW2ldPXcmNjcxMDg4NjN9dGhpcy5uZWdhdGl2ZT0xO3JldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5fd29yZERpdj1mdW5jdGlvbiBfd29yZERpdihudW0sbW9kZSl7dmFyIHNoaWZ0PXRoaXMubGVuZ3RoLW51bS5sZW5ndGg7dmFyIGE9dGhpcy5jbG9uZSgpO3ZhciBiPW51bTt2YXIgYmhpPWIud29yZHNbYi5sZW5ndGgtMV18MDt2YXIgYmhpQml0cz10aGlzLl9jb3VudEJpdHMoYmhpKTtzaGlmdD0yNi1iaGlCaXRzO2lmKHNoaWZ0IT09MCl7Yj1iLnVzaGxuKHNoaWZ0KTthLml1c2hsbihzaGlmdCk7YmhpPWIud29yZHNbYi5sZW5ndGgtMV18MH12YXIgbT1hLmxlbmd0aC1iLmxlbmd0aDt2YXIgcTtpZihtb2RlIT09XCJtb2RcIil7cT1uZXcgQk4obnVsbCk7cS5sZW5ndGg9bSsxO3Eud29yZHM9bmV3IEFycmF5KHEubGVuZ3RoKTtmb3IodmFyIGk9MDtpPHEubGVuZ3RoO2krKyl7cS53b3Jkc1tpXT0wfX12YXIgZGlmZj1hLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsMSxtKTtpZihkaWZmLm5lZ2F0aXZlPT09MCl7YT1kaWZmO2lmKHEpe3Eud29yZHNbbV09MX19Zm9yKHZhciBqPW0tMTtqPj0wO2otLSl7dmFyIHFqPShhLndvcmRzW2IubGVuZ3RoK2pdfDApKjY3MTA4ODY0KyhhLndvcmRzW2IubGVuZ3RoK2otMV18MCk7cWo9TWF0aC5taW4ocWovYmhpfDAsNjcxMDg4NjMpO2EuX2lzaGxuc3VibXVsKGIscWosaik7d2hpbGUoYS5uZWdhdGl2ZSE9PTApe3FqLS07YS5uZWdhdGl2ZT0wO2EuX2lzaGxuc3VibXVsKGIsMSxqKTtpZighYS5pc1plcm8oKSl7YS5uZWdhdGl2ZV49MX19aWYocSl7cS53b3Jkc1tqXT1xan19aWYocSl7cS5zdHJpcCgpfWEuc3RyaXAoKTtpZihtb2RlIT09XCJkaXZcIiYmc2hpZnQhPT0wKXthLml1c2hybihzaGlmdCl9cmV0dXJue2RpdjpxfHxudWxsLG1vZDphfX07Qk4ucHJvdG90eXBlLmRpdm1vZD1mdW5jdGlvbiBkaXZtb2QobnVtLG1vZGUscG9zaXRpdmUpe2Fzc2VydCghbnVtLmlzWmVybygpKTtpZih0aGlzLmlzWmVybygpKXtyZXR1cm57ZGl2Om5ldyBCTigwKSxtb2Q6bmV3IEJOKDApfX12YXIgZGl2LG1vZCxyZXM7aWYodGhpcy5uZWdhdGl2ZSE9PTAmJm51bS5uZWdhdGl2ZT09PTApe3Jlcz10aGlzLm5lZygpLmRpdm1vZChudW0sbW9kZSk7aWYobW9kZSE9PVwibW9kXCIpe2Rpdj1yZXMuZGl2Lm5lZygpfWlmKG1vZGUhPT1cImRpdlwiKXttb2Q9cmVzLm1vZC5uZWcoKTtpZihwb3NpdGl2ZSYmbW9kLm5lZ2F0aXZlIT09MCl7bW9kLmlhZGQobnVtKX19cmV0dXJue2RpdjpkaXYsbW9kOm1vZH19aWYodGhpcy5uZWdhdGl2ZT09PTAmJm51bS5uZWdhdGl2ZSE9PTApe3Jlcz10aGlzLmRpdm1vZChudW0ubmVnKCksbW9kZSk7aWYobW9kZSE9PVwibW9kXCIpe2Rpdj1yZXMuZGl2Lm5lZygpfXJldHVybntkaXY6ZGl2LG1vZDpyZXMubW9kfX1pZigodGhpcy5uZWdhdGl2ZSZudW0ubmVnYXRpdmUpIT09MCl7cmVzPXRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSxtb2RlKTtpZihtb2RlIT09XCJkaXZcIil7bW9kPXJlcy5tb2QubmVnKCk7aWYocG9zaXRpdmUmJm1vZC5uZWdhdGl2ZSE9PTApe21vZC5pc3ViKG51bSl9fXJldHVybntkaXY6cmVzLmRpdixtb2Q6bW9kfX1pZihudW0ubGVuZ3RoPnRoaXMubGVuZ3RofHx0aGlzLmNtcChudW0pPDApe3JldHVybntkaXY6bmV3IEJOKDApLG1vZDp0aGlzfX1pZihudW0ubGVuZ3RoPT09MSl7aWYobW9kZT09PVwiZGl2XCIpe3JldHVybntkaXY6dGhpcy5kaXZuKG51bS53b3Jkc1swXSksbW9kOm51bGx9fWlmKG1vZGU9PT1cIm1vZFwiKXtyZXR1cm57ZGl2Om51bGwsbW9kOm5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSl9fXJldHVybntkaXY6dGhpcy5kaXZuKG51bS53b3Jkc1swXSksbW9kOm5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSl9fXJldHVybiB0aGlzLl93b3JkRGl2KG51bSxtb2RlKX07Qk4ucHJvdG90eXBlLmRpdj1mdW5jdGlvbiBkaXYobnVtKXtyZXR1cm4gdGhpcy5kaXZtb2QobnVtLFwiZGl2XCIsZmFsc2UpLmRpdn07Qk4ucHJvdG90eXBlLm1vZD1mdW5jdGlvbiBtb2QobnVtKXtyZXR1cm4gdGhpcy5kaXZtb2QobnVtLFwibW9kXCIsZmFsc2UpLm1vZH07Qk4ucHJvdG90eXBlLnVtb2Q9ZnVuY3Rpb24gdW1vZChudW0pe3JldHVybiB0aGlzLmRpdm1vZChudW0sXCJtb2RcIix0cnVlKS5tb2R9O0JOLnByb3RvdHlwZS5kaXZSb3VuZD1mdW5jdGlvbiBkaXZSb3VuZChudW0pe3ZhciBkbT10aGlzLmRpdm1vZChudW0pO2lmKGRtLm1vZC5pc1plcm8oKSlyZXR1cm4gZG0uZGl2O3ZhciBtb2Q9ZG0uZGl2Lm5lZ2F0aXZlIT09MD9kbS5tb2QuaXN1YihudW0pOmRtLm1vZDt2YXIgaGFsZj1udW0udXNocm4oMSk7dmFyIHIyPW51bS5hbmRsbigxKTt2YXIgY21wPW1vZC5jbXAoaGFsZik7aWYoY21wPDB8fHIyPT09MSYmY21wPT09MClyZXR1cm4gZG0uZGl2O3JldHVybiBkbS5kaXYubmVnYXRpdmUhPT0wP2RtLmRpdi5pc3VibigxKTpkbS5kaXYuaWFkZG4oMSl9O0JOLnByb3RvdHlwZS5tb2RuPWZ1bmN0aW9uIG1vZG4obnVtKXthc3NlcnQobnVtPD02NzEwODg2Myk7dmFyIHA9KDE8PDI2KSVudW07dmFyIGFjYz0wO2Zvcih2YXIgaT10aGlzLmxlbmd0aC0xO2k+PTA7aS0tKXthY2M9KHAqYWNjKyh0aGlzLndvcmRzW2ldfDApKSVudW19cmV0dXJuIGFjY307Qk4ucHJvdG90eXBlLmlkaXZuPWZ1bmN0aW9uIGlkaXZuKG51bSl7YXNzZXJ0KG51bTw9NjcxMDg4NjMpO3ZhciBjYXJyeT0wO2Zvcih2YXIgaT10aGlzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgdz0odGhpcy53b3Jkc1tpXXwwKStjYXJyeSo2NzEwODg2NDt0aGlzLndvcmRzW2ldPXcvbnVtfDA7Y2Fycnk9dyVudW19cmV0dXJuIHRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLmRpdm49ZnVuY3Rpb24gZGl2bihudW0pe3JldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKX07Qk4ucHJvdG90eXBlLmVnY2Q9ZnVuY3Rpb24gZWdjZChwKXthc3NlcnQocC5uZWdhdGl2ZT09PTApO2Fzc2VydCghcC5pc1plcm8oKSk7dmFyIHg9dGhpczt2YXIgeT1wLmNsb25lKCk7aWYoeC5uZWdhdGl2ZSE9PTApe3g9eC51bW9kKHApfWVsc2V7eD14LmNsb25lKCl9dmFyIEE9bmV3IEJOKDEpO3ZhciBCPW5ldyBCTigwKTt2YXIgQz1uZXcgQk4oMCk7dmFyIEQ9bmV3IEJOKDEpO3ZhciBnPTA7d2hpbGUoeC5pc0V2ZW4oKSYmeS5pc0V2ZW4oKSl7eC5pdXNocm4oMSk7eS5pdXNocm4oMSk7KytnfXZhciB5cD15LmNsb25lKCk7dmFyIHhwPXguY2xvbmUoKTt3aGlsZSgheC5pc1plcm8oKSl7Zm9yKHZhciBpPTAsaW09MTsoeC53b3Jkc1swXSZpbSk9PT0wJiZpPDI2OysraSxpbTw8PTEpO2lmKGk+MCl7eC5pdXNocm4oaSk7d2hpbGUoaS0tID4wKXtpZihBLmlzT2RkKCl8fEIuaXNPZGQoKSl7QS5pYWRkKHlwKTtCLmlzdWIoeHApfUEuaXVzaHJuKDEpO0IuaXVzaHJuKDEpfX1mb3IodmFyIGo9MCxqbT0xOyh5LndvcmRzWzBdJmptKT09PTAmJmo8MjY7KytqLGptPDw9MSk7aWYoaj4wKXt5Lml1c2hybihqKTt3aGlsZShqLS0gPjApe2lmKEMuaXNPZGQoKXx8RC5pc09kZCgpKXtDLmlhZGQoeXApO0QuaXN1Yih4cCl9Qy5pdXNocm4oMSk7RC5pdXNocm4oMSl9fWlmKHguY21wKHkpPj0wKXt4LmlzdWIoeSk7QS5pc3ViKEMpO0IuaXN1YihEKX1lbHNle3kuaXN1Yih4KTtDLmlzdWIoQSk7RC5pc3ViKEIpfX1yZXR1cm57YTpDLGI6RCxnY2Q6eS5pdXNobG4oZyl9fTtCTi5wcm90b3R5cGUuX2ludm1wPWZ1bmN0aW9uIF9pbnZtcChwKXthc3NlcnQocC5uZWdhdGl2ZT09PTApO2Fzc2VydCghcC5pc1plcm8oKSk7dmFyIGE9dGhpczt2YXIgYj1wLmNsb25lKCk7aWYoYS5uZWdhdGl2ZSE9PTApe2E9YS51bW9kKHApfWVsc2V7YT1hLmNsb25lKCl9dmFyIHgxPW5ldyBCTigxKTt2YXIgeDI9bmV3IEJOKDApO3ZhciBkZWx0YT1iLmNsb25lKCk7d2hpbGUoYS5jbXBuKDEpPjAmJmIuY21wbigxKT4wKXtmb3IodmFyIGk9MCxpbT0xOyhhLndvcmRzWzBdJmltKT09PTAmJmk8MjY7KytpLGltPDw9MSk7aWYoaT4wKXthLml1c2hybihpKTt3aGlsZShpLS0gPjApe2lmKHgxLmlzT2RkKCkpe3gxLmlhZGQoZGVsdGEpfXgxLml1c2hybigxKX19Zm9yKHZhciBqPTAsam09MTsoYi53b3Jkc1swXSZqbSk9PT0wJiZqPDI2OysraixqbTw8PTEpO2lmKGo+MCl7Yi5pdXNocm4oaik7d2hpbGUoai0tID4wKXtpZih4Mi5pc09kZCgpKXt4Mi5pYWRkKGRlbHRhKX14Mi5pdXNocm4oMSl9fWlmKGEuY21wKGIpPj0wKXthLmlzdWIoYik7eDEuaXN1Yih4Mil9ZWxzZXtiLmlzdWIoYSk7eDIuaXN1Yih4MSl9fXZhciByZXM7aWYoYS5jbXBuKDEpPT09MCl7cmVzPXgxfWVsc2V7cmVzPXgyfWlmKHJlcy5jbXBuKDApPDApe3Jlcy5pYWRkKHApfXJldHVybiByZXN9O0JOLnByb3RvdHlwZS5nY2Q9ZnVuY3Rpb24gZ2NkKG51bSl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gbnVtLmFicygpO2lmKG51bS5pc1plcm8oKSlyZXR1cm4gdGhpcy5hYnMoKTt2YXIgYT10aGlzLmNsb25lKCk7dmFyIGI9bnVtLmNsb25lKCk7YS5uZWdhdGl2ZT0wO2IubmVnYXRpdmU9MDtmb3IodmFyIHNoaWZ0PTA7YS5pc0V2ZW4oKSYmYi5pc0V2ZW4oKTtzaGlmdCsrKXthLml1c2hybigxKTtiLml1c2hybigxKX1kb3t3aGlsZShhLmlzRXZlbigpKXthLml1c2hybigxKX13aGlsZShiLmlzRXZlbigpKXtiLml1c2hybigxKX12YXIgcj1hLmNtcChiKTtpZihyPDApe3ZhciB0PWE7YT1iO2I9dH1lbHNlIGlmKHI9PT0wfHxiLmNtcG4oMSk9PT0wKXticmVha31hLmlzdWIoYil9d2hpbGUodHJ1ZSk7cmV0dXJuIGIuaXVzaGxuKHNoaWZ0KX07Qk4ucHJvdG90eXBlLmludm09ZnVuY3Rpb24gaW52bShudW0pe3JldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKX07Qk4ucHJvdG90eXBlLmlzRXZlbj1mdW5jdGlvbiBpc0V2ZW4oKXtyZXR1cm4odGhpcy53b3Jkc1swXSYxKT09PTB9O0JOLnByb3RvdHlwZS5pc09kZD1mdW5jdGlvbiBpc09kZCgpe3JldHVybih0aGlzLndvcmRzWzBdJjEpPT09MX07Qk4ucHJvdG90eXBlLmFuZGxuPWZ1bmN0aW9uIGFuZGxuKG51bSl7cmV0dXJuIHRoaXMud29yZHNbMF0mbnVtfTtCTi5wcm90b3R5cGUuYmluY249ZnVuY3Rpb24gYmluY24oYml0KXthc3NlcnQodHlwZW9mIGJpdD09PVwibnVtYmVyXCIpO3ZhciByPWJpdCUyNjt2YXIgcz0oYml0LXIpLzI2O3ZhciBxPTE8PHI7aWYodGhpcy5sZW5ndGg8PXMpe3RoaXMuX2V4cGFuZChzKzEpO3RoaXMud29yZHNbc118PXE7cmV0dXJuIHRoaXN9dmFyIGNhcnJ5PXE7Zm9yKHZhciBpPXM7Y2FycnkhPT0wJiZpPHRoaXMubGVuZ3RoO2krKyl7dmFyIHc9dGhpcy53b3Jkc1tpXXwwO3crPWNhcnJ5O2NhcnJ5PXc+Pj4yNjt3Jj02NzEwODg2Mzt0aGlzLndvcmRzW2ldPXd9aWYoY2FycnkhPT0wKXt0aGlzLndvcmRzW2ldPWNhcnJ5O3RoaXMubGVuZ3RoKyt9cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5pc1plcm89ZnVuY3Rpb24gaXNaZXJvKCl7cmV0dXJuIHRoaXMubGVuZ3RoPT09MSYmdGhpcy53b3Jkc1swXT09PTB9O0JOLnByb3RvdHlwZS5jbXBuPWZ1bmN0aW9uIGNtcG4obnVtKXt2YXIgbmVnYXRpdmU9bnVtPDA7aWYodGhpcy5uZWdhdGl2ZSE9PTAmJiFuZWdhdGl2ZSlyZXR1cm4tMTtpZih0aGlzLm5lZ2F0aXZlPT09MCYmbmVnYXRpdmUpcmV0dXJuIDE7dGhpcy5zdHJpcCgpO3ZhciByZXM7aWYodGhpcy5sZW5ndGg+MSl7cmVzPTF9ZWxzZXtpZihuZWdhdGl2ZSl7bnVtPS1udW19YXNzZXJ0KG51bTw9NjcxMDg4NjMsXCJOdW1iZXIgaXMgdG9vIGJpZ1wiKTt2YXIgdz10aGlzLndvcmRzWzBdfDA7cmVzPXc9PT1udW0/MDp3PG51bT8tMToxfWlmKHRoaXMubmVnYXRpdmUhPT0wKXJldHVybi1yZXN8MDtyZXR1cm4gcmVzfTtCTi5wcm90b3R5cGUuY21wPWZ1bmN0aW9uIGNtcChudW0pe2lmKHRoaXMubmVnYXRpdmUhPT0wJiZudW0ubmVnYXRpdmU9PT0wKXJldHVybi0xO2lmKHRoaXMubmVnYXRpdmU9PT0wJiZudW0ubmVnYXRpdmUhPT0wKXJldHVybiAxO3ZhciByZXM9dGhpcy51Y21wKG51bSk7aWYodGhpcy5uZWdhdGl2ZSE9PTApcmV0dXJuLXJlc3wwO3JldHVybiByZXN9O0JOLnByb3RvdHlwZS51Y21wPWZ1bmN0aW9uIHVjbXAobnVtKXtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXJldHVybiAxO2lmKHRoaXMubGVuZ3RoPG51bS5sZW5ndGgpcmV0dXJuLTE7dmFyIHJlcz0wO2Zvcih2YXIgaT10aGlzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgYT10aGlzLndvcmRzW2ldfDA7dmFyIGI9bnVtLndvcmRzW2ldfDA7aWYoYT09PWIpY29udGludWU7aWYoYTxiKXtyZXM9LTF9ZWxzZSBpZihhPmIpe3Jlcz0xfWJyZWFrfXJldHVybiByZXN9O0JOLnByb3RvdHlwZS5ndG49ZnVuY3Rpb24gZ3RuKG51bSl7cmV0dXJuIHRoaXMuY21wbihudW0pPT09MX07Qk4ucHJvdG90eXBlLmd0PWZ1bmN0aW9uIGd0KG51bSl7cmV0dXJuIHRoaXMuY21wKG51bSk9PT0xfTtCTi5wcm90b3R5cGUuZ3Rlbj1mdW5jdGlvbiBndGVuKG51bSl7cmV0dXJuIHRoaXMuY21wbihudW0pPj0wfTtCTi5wcm90b3R5cGUuZ3RlPWZ1bmN0aW9uIGd0ZShudW0pe3JldHVybiB0aGlzLmNtcChudW0pPj0wfTtCTi5wcm90b3R5cGUubHRuPWZ1bmN0aW9uIGx0bihudW0pe3JldHVybiB0aGlzLmNtcG4obnVtKT09PS0xfTtCTi5wcm90b3R5cGUubHQ9ZnVuY3Rpb24gbHQobnVtKXtyZXR1cm4gdGhpcy5jbXAobnVtKT09PS0xfTtCTi5wcm90b3R5cGUubHRlbj1mdW5jdGlvbiBsdGVuKG51bSl7cmV0dXJuIHRoaXMuY21wbihudW0pPD0wfTtCTi5wcm90b3R5cGUubHRlPWZ1bmN0aW9uIGx0ZShudW0pe3JldHVybiB0aGlzLmNtcChudW0pPD0wfTtCTi5wcm90b3R5cGUuZXFuPWZ1bmN0aW9uIGVxbihudW0pe3JldHVybiB0aGlzLmNtcG4obnVtKT09PTB9O0JOLnByb3RvdHlwZS5lcT1mdW5jdGlvbiBlcShudW0pe3JldHVybiB0aGlzLmNtcChudW0pPT09MH07Qk4ucmVkPWZ1bmN0aW9uIHJlZChudW0pe3JldHVybiBuZXcgUmVkKG51bSl9O0JOLnByb3RvdHlwZS50b1JlZD1mdW5jdGlvbiB0b1JlZChjdHgpe2Fzc2VydCghdGhpcy5yZWQsXCJBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpO2Fzc2VydCh0aGlzLm5lZ2F0aXZlPT09MCxcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpO3JldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpfTtCTi5wcm90b3R5cGUuZnJvbVJlZD1mdW5jdGlvbiBmcm9tUmVkKCl7YXNzZXJ0KHRoaXMucmVkLFwiZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dFwiKTtyZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyl9O0JOLnByb3RvdHlwZS5fZm9yY2VSZWQ9ZnVuY3Rpb24gX2ZvcmNlUmVkKGN0eCl7dGhpcy5yZWQ9Y3R4O3JldHVybiB0aGlzfTtCTi5wcm90b3R5cGUuZm9yY2VSZWQ9ZnVuY3Rpb24gZm9yY2VSZWQoY3R4KXthc3NlcnQoIXRoaXMucmVkLFwiQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dFwiKTtyZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KX07Qk4ucHJvdG90eXBlLnJlZEFkZD1mdW5jdGlvbiByZWRBZGQobnVtKXthc3NlcnQodGhpcy5yZWQsXCJyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3JldHVybiB0aGlzLnJlZC5hZGQodGhpcyxudW0pfTtCTi5wcm90b3R5cGUucmVkSUFkZD1mdW5jdGlvbiByZWRJQWRkKG51bSl7YXNzZXJ0KHRoaXMucmVkLFwicmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7cmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcyxudW0pfTtCTi5wcm90b3R5cGUucmVkU3ViPWZ1bmN0aW9uIHJlZFN1YihudW0pe2Fzc2VydCh0aGlzLnJlZCxcInJlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7cmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLG51bSl9O0JOLnByb3RvdHlwZS5yZWRJU3ViPWZ1bmN0aW9uIHJlZElTdWIobnVtKXthc3NlcnQodGhpcy5yZWQsXCJyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtyZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLG51bSl9O0JOLnByb3RvdHlwZS5yZWRTaGw9ZnVuY3Rpb24gcmVkU2hsKG51bSl7YXNzZXJ0KHRoaXMucmVkLFwicmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtyZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsbnVtKX07Qk4ucHJvdG90eXBlLnJlZE11bD1mdW5jdGlvbiByZWRNdWwobnVtKXthc3NlcnQodGhpcy5yZWQsXCJyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3RoaXMucmVkLl92ZXJpZnkyKHRoaXMsbnVtKTtyZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsbnVtKX07Qk4ucHJvdG90eXBlLnJlZElNdWw9ZnVuY3Rpb24gcmVkSU11bChudW0pe2Fzc2VydCh0aGlzLnJlZCxcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7dGhpcy5yZWQuX3ZlcmlmeTIodGhpcyxudW0pO3JldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsbnVtKX07Qk4ucHJvdG90eXBlLnJlZFNxcj1mdW5jdGlvbiByZWRTcXIoKXthc3NlcnQodGhpcy5yZWQsXCJyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3RoaXMucmVkLl92ZXJpZnkxKHRoaXMpO3JldHVybiB0aGlzLnJlZC5zcXIodGhpcyl9O0JOLnByb3RvdHlwZS5yZWRJU3FyPWZ1bmN0aW9uIHJlZElTcXIoKXthc3NlcnQodGhpcy5yZWQsXCJyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTt0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtyZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKX07Qk4ucHJvdG90eXBlLnJlZFNxcnQ9ZnVuY3Rpb24gcmVkU3FydCgpe2Fzc2VydCh0aGlzLnJlZCxcInJlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3RoaXMucmVkLl92ZXJpZnkxKHRoaXMpO3JldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpfTtCTi5wcm90b3R5cGUucmVkSW52bT1mdW5jdGlvbiByZWRJbnZtKCl7YXNzZXJ0KHRoaXMucmVkLFwicmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7dGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7cmV0dXJuIHRoaXMucmVkLmludm0odGhpcyl9O0JOLnByb3RvdHlwZS5yZWROZWc9ZnVuY3Rpb24gcmVkTmVnKCl7YXNzZXJ0KHRoaXMucmVkLFwicmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTt0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtyZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpfTtCTi5wcm90b3R5cGUucmVkUG93PWZ1bmN0aW9uIHJlZFBvdyhudW0pe2Fzc2VydCh0aGlzLnJlZCYmIW51bS5yZWQsXCJyZWRQb3cobm9ybWFsTnVtKVwiKTt0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtyZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsbnVtKX07dmFyIHByaW1lcz17azI1NjpudWxsLHAyMjQ6bnVsbCxwMTkyOm51bGwscDI1NTE5Om51bGx9O2Z1bmN0aW9uIE1QcmltZShuYW1lLHApe3RoaXMubmFtZT1uYW1lO3RoaXMucD1uZXcgQk4ocCwxNik7dGhpcy5uPXRoaXMucC5iaXRMZW5ndGgoKTt0aGlzLms9bmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTt0aGlzLnRtcD10aGlzLl90bXAoKX1NUHJpbWUucHJvdG90eXBlLl90bXA9ZnVuY3Rpb24gX3RtcCgpe3ZhciB0bXA9bmV3IEJOKG51bGwpO3RtcC53b3Jkcz1uZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubi8xMykpO3JldHVybiB0bXB9O01QcmltZS5wcm90b3R5cGUuaXJlZHVjZT1mdW5jdGlvbiBpcmVkdWNlKG51bSl7dmFyIHI9bnVtO3ZhciBybGVuO2Rve3RoaXMuc3BsaXQocix0aGlzLnRtcCk7cj10aGlzLmltdWxLKHIpO3I9ci5pYWRkKHRoaXMudG1wKTtybGVuPXIuYml0TGVuZ3RoKCl9d2hpbGUocmxlbj50aGlzLm4pO3ZhciBjbXA9cmxlbjx0aGlzLm4/LTE6ci51Y21wKHRoaXMucCk7aWYoY21wPT09MCl7ci53b3Jkc1swXT0wO3IubGVuZ3RoPTF9ZWxzZSBpZihjbXA+MCl7ci5pc3ViKHRoaXMucCl9ZWxzZXtpZihyLnN0cmlwIT09dW5kZWZpbmVkKXtyLnN0cmlwKCl9ZWxzZXtyLl9zdHJpcCgpfX1yZXR1cm4gcn07TVByaW1lLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbiBzcGxpdChpbnB1dCxvdXQpe2lucHV0Lml1c2hybih0aGlzLm4sMCxvdXQpfTtNUHJpbWUucHJvdG90eXBlLmltdWxLPWZ1bmN0aW9uIGltdWxLKG51bSl7cmV0dXJuIG51bS5pbXVsKHRoaXMuayl9O2Z1bmN0aW9uIEsyNTYoKXtNUHJpbWUuY2FsbCh0aGlzLFwiazI1NlwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIil9aW5oZXJpdHMoSzI1NixNUHJpbWUpO0syNTYucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uIHNwbGl0KGlucHV0LG91dHB1dCl7dmFyIG1hc2s9NDE5NDMwMzt2YXIgb3V0TGVuPU1hdGgubWluKGlucHV0Lmxlbmd0aCw5KTtmb3IodmFyIGk9MDtpPG91dExlbjtpKyspe291dHB1dC53b3Jkc1tpXT1pbnB1dC53b3Jkc1tpXX1vdXRwdXQubGVuZ3RoPW91dExlbjtpZihpbnB1dC5sZW5ndGg8PTkpe2lucHV0LndvcmRzWzBdPTA7aW5wdXQubGVuZ3RoPTE7cmV0dXJufXZhciBwcmV2PWlucHV0LndvcmRzWzldO291dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdPXByZXYmbWFzaztmb3IoaT0xMDtpPGlucHV0Lmxlbmd0aDtpKyspe3ZhciBuZXh0PWlucHV0LndvcmRzW2ldfDA7aW5wdXQud29yZHNbaS0xMF09KG5leHQmbWFzayk8PDR8cHJldj4+PjIyO3ByZXY9bmV4dH1wcmV2Pj4+PTIyO2lucHV0LndvcmRzW2ktMTBdPXByZXY7aWYocHJldj09PTAmJmlucHV0Lmxlbmd0aD4xMCl7aW5wdXQubGVuZ3RoLT0xMH1lbHNle2lucHV0Lmxlbmd0aC09OX19O0syNTYucHJvdG90eXBlLmltdWxLPWZ1bmN0aW9uIGltdWxLKG51bSl7bnVtLndvcmRzW251bS5sZW5ndGhdPTA7bnVtLndvcmRzW251bS5sZW5ndGgrMV09MDtudW0ubGVuZ3RoKz0yO3ZhciBsbz0wO2Zvcih2YXIgaT0wO2k8bnVtLmxlbmd0aDtpKyspe3ZhciB3PW51bS53b3Jkc1tpXXwwO2xvKz13Kjk3NztudW0ud29yZHNbaV09bG8mNjcxMDg4NjM7bG89dyo2NCsobG8vNjcxMDg4NjR8MCl9aWYobnVtLndvcmRzW251bS5sZW5ndGgtMV09PT0wKXtudW0ubGVuZ3RoLS07aWYobnVtLndvcmRzW251bS5sZW5ndGgtMV09PT0wKXtudW0ubGVuZ3RoLS19fXJldHVybiBudW19O2Z1bmN0aW9uIFAyMjQoKXtNUHJpbWUuY2FsbCh0aGlzLFwicDIyNFwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcIil9aW5oZXJpdHMoUDIyNCxNUHJpbWUpO2Z1bmN0aW9uIFAxOTIoKXtNUHJpbWUuY2FsbCh0aGlzLFwicDE5MlwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmZcIil9aW5oZXJpdHMoUDE5MixNUHJpbWUpO2Z1bmN0aW9uIFAyNTUxOSgpe01QcmltZS5jYWxsKHRoaXMsXCIyNTUxOVwiLFwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiKX1pbmhlcml0cyhQMjU1MTksTVByaW1lKTtQMjU1MTkucHJvdG90eXBlLmltdWxLPWZ1bmN0aW9uIGltdWxLKG51bSl7dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPTA7aTxudW0ubGVuZ3RoO2krKyl7dmFyIGhpPShudW0ud29yZHNbaV18MCkqMTkrY2Fycnk7dmFyIGxvPWhpJjY3MTA4ODYzO2hpPj4+PTI2O251bS53b3Jkc1tpXT1sbztjYXJyeT1oaX1pZihjYXJyeSE9PTApe251bS53b3Jkc1tudW0ubGVuZ3RoKytdPWNhcnJ5fXJldHVybiBudW19O0JOLl9wcmltZT1mdW5jdGlvbiBwcmltZShuYW1lKXtpZihwcmltZXNbbmFtZV0pcmV0dXJuIHByaW1lc1tuYW1lXTt2YXIgcHJpbWU7aWYobmFtZT09PVwiazI1NlwiKXtwcmltZT1uZXcgSzI1Nn1lbHNlIGlmKG5hbWU9PT1cInAyMjRcIil7cHJpbWU9bmV3IFAyMjR9ZWxzZSBpZihuYW1lPT09XCJwMTkyXCIpe3ByaW1lPW5ldyBQMTkyfWVsc2UgaWYobmFtZT09PVwicDI1NTE5XCIpe3ByaW1lPW5ldyBQMjU1MTl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHByaW1lIFwiK25hbWUpfXByaW1lc1tuYW1lXT1wcmltZTtyZXR1cm4gcHJpbWV9O2Z1bmN0aW9uIFJlZChtKXtpZih0eXBlb2YgbT09PVwic3RyaW5nXCIpe3ZhciBwcmltZT1CTi5fcHJpbWUobSk7dGhpcy5tPXByaW1lLnA7dGhpcy5wcmltZT1wcmltZX1lbHNle2Fzc2VydChtLmd0bigxKSxcIm1vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKTt0aGlzLm09bTt0aGlzLnByaW1lPW51bGx9fVJlZC5wcm90b3R5cGUuX3ZlcmlmeTE9ZnVuY3Rpb24gX3ZlcmlmeTEoYSl7YXNzZXJ0KGEubmVnYXRpdmU9PT0wLFwicmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXNcIik7YXNzZXJ0KGEucmVkLFwicmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKX07UmVkLnByb3RvdHlwZS5fdmVyaWZ5Mj1mdW5jdGlvbiBfdmVyaWZ5MihhLGIpe2Fzc2VydCgoYS5uZWdhdGl2ZXxiLm5lZ2F0aXZlKT09PTAsXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKTthc3NlcnQoYS5yZWQmJmEucmVkPT09Yi5yZWQsXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpfTtSZWQucHJvdG90eXBlLmltb2Q9ZnVuY3Rpb24gaW1vZChhKXtpZih0aGlzLnByaW1lKXJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO3JldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyl9O1JlZC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uIG5lZyhhKXtpZihhLmlzWmVybygpKXtyZXR1cm4gYS5jbG9uZSgpfXJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKX07UmVkLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24gYWRkKGEsYil7dGhpcy5fdmVyaWZ5MihhLGIpO3ZhciByZXM9YS5hZGQoYik7aWYocmVzLmNtcCh0aGlzLm0pPj0wKXtyZXMuaXN1Yih0aGlzLm0pfXJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpfTtSZWQucHJvdG90eXBlLmlhZGQ9ZnVuY3Rpb24gaWFkZChhLGIpe3RoaXMuX3ZlcmlmeTIoYSxiKTt2YXIgcmVzPWEuaWFkZChiKTtpZihyZXMuY21wKHRoaXMubSk+PTApe3Jlcy5pc3ViKHRoaXMubSl9cmV0dXJuIHJlc307UmVkLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24gc3ViKGEsYil7dGhpcy5fdmVyaWZ5MihhLGIpO3ZhciByZXM9YS5zdWIoYik7aWYocmVzLmNtcG4oMCk8MCl7cmVzLmlhZGQodGhpcy5tKX1yZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKX07UmVkLnByb3RvdHlwZS5pc3ViPWZ1bmN0aW9uIGlzdWIoYSxiKXt0aGlzLl92ZXJpZnkyKGEsYik7dmFyIHJlcz1hLmlzdWIoYik7aWYocmVzLmNtcG4oMCk8MCl7cmVzLmlhZGQodGhpcy5tKX1yZXR1cm4gcmVzfTtSZWQucHJvdG90eXBlLnNobD1mdW5jdGlvbiBzaGwoYSxudW0pe3RoaXMuX3ZlcmlmeTEoYSk7cmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpfTtSZWQucHJvdG90eXBlLmltdWw9ZnVuY3Rpb24gaW11bChhLGIpe3RoaXMuX3ZlcmlmeTIoYSxiKTtyZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSl9O1JlZC5wcm90b3R5cGUubXVsPWZ1bmN0aW9uIG11bChhLGIpe3RoaXMuX3ZlcmlmeTIoYSxiKTtyZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKX07UmVkLnByb3RvdHlwZS5pc3FyPWZ1bmN0aW9uIGlzcXIoYSl7cmV0dXJuIHRoaXMuaW11bChhLGEuY2xvbmUoKSl9O1JlZC5wcm90b3R5cGUuc3FyPWZ1bmN0aW9uIHNxcihhKXtyZXR1cm4gdGhpcy5tdWwoYSxhKX07UmVkLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uIHNxcnQoYSl7aWYoYS5pc1plcm8oKSlyZXR1cm4gYS5jbG9uZSgpO3ZhciBtb2QzPXRoaXMubS5hbmRsbigzKTthc3NlcnQobW9kMyUyPT09MSk7aWYobW9kMz09PTMpe3ZhciBwb3c9dGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtyZXR1cm4gdGhpcy5wb3coYSxwb3cpfXZhciBxPXRoaXMubS5zdWJuKDEpO3ZhciBzPTA7d2hpbGUoIXEuaXNaZXJvKCkmJnEuYW5kbG4oMSk9PT0wKXtzKys7cS5pdXNocm4oMSl9YXNzZXJ0KCFxLmlzWmVybygpKTt2YXIgb25lPW5ldyBCTigxKS50b1JlZCh0aGlzKTt2YXIgbk9uZT1vbmUucmVkTmVnKCk7dmFyIGxwb3c9dGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO3ZhciB6PXRoaXMubS5iaXRMZW5ndGgoKTt6PW5ldyBCTigyKnoqeikudG9SZWQodGhpcyk7d2hpbGUodGhpcy5wb3coeixscG93KS5jbXAobk9uZSkhPT0wKXt6LnJlZElBZGQobk9uZSl9dmFyIGM9dGhpcy5wb3coeixxKTt2YXIgcj10aGlzLnBvdyhhLHEuYWRkbigxKS5pdXNocm4oMSkpO3ZhciB0PXRoaXMucG93KGEscSk7dmFyIG09czt3aGlsZSh0LmNtcChvbmUpIT09MCl7dmFyIHRtcD10O2Zvcih2YXIgaT0wO3RtcC5jbXAob25lKSE9PTA7aSsrKXt0bXA9dG1wLnJlZFNxcigpfWFzc2VydChpPG0pO3ZhciBiPXRoaXMucG93KGMsbmV3IEJOKDEpLml1c2hsbihtLWktMSkpO3I9ci5yZWRNdWwoYik7Yz1iLnJlZFNxcigpO3Q9dC5yZWRNdWwoYyk7bT1pfXJldHVybiByfTtSZWQucHJvdG90eXBlLmludm09ZnVuY3Rpb24gaW52bShhKXt2YXIgaW52PWEuX2ludm1wKHRoaXMubSk7aWYoaW52Lm5lZ2F0aXZlIT09MCl7aW52Lm5lZ2F0aXZlPTA7cmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpfWVsc2V7cmV0dXJuIHRoaXMuaW1vZChpbnYpfX07UmVkLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24gcG93KGEsbnVtKXtpZihudW0uaXNaZXJvKCkpcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtpZihudW0uY21wbigxKT09PTApcmV0dXJuIGEuY2xvbmUoKTt2YXIgd2luZG93U2l6ZT00O3ZhciB3bmQ9bmV3IEFycmF5KDE8PHdpbmRvd1NpemUpO3duZFswXT1uZXcgQk4oMSkudG9SZWQodGhpcyk7d25kWzFdPWE7Zm9yKHZhciBpPTI7aTx3bmQubGVuZ3RoO2krKyl7d25kW2ldPXRoaXMubXVsKHduZFtpLTFdLGEpfXZhciByZXM9d25kWzBdO3ZhciBjdXJyZW50PTA7dmFyIGN1cnJlbnRMZW49MDt2YXIgc3RhcnQ9bnVtLmJpdExlbmd0aCgpJTI2O2lmKHN0YXJ0PT09MCl7c3RhcnQ9MjZ9Zm9yKGk9bnVtLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgd29yZD1udW0ud29yZHNbaV07Zm9yKHZhciBqPXN0YXJ0LTE7aj49MDtqLS0pe3ZhciBiaXQ9d29yZD4+aiYxO2lmKHJlcyE9PXduZFswXSl7cmVzPXRoaXMuc3FyKHJlcyl9aWYoYml0PT09MCYmY3VycmVudD09PTApe2N1cnJlbnRMZW49MDtjb250aW51ZX1jdXJyZW50PDw9MTtjdXJyZW50fD1iaXQ7Y3VycmVudExlbisrO2lmKGN1cnJlbnRMZW4hPT13aW5kb3dTaXplJiYoaSE9PTB8fGohPT0wKSljb250aW51ZTtyZXM9dGhpcy5tdWwocmVzLHduZFtjdXJyZW50XSk7Y3VycmVudExlbj0wO2N1cnJlbnQ9MH1zdGFydD0yNn1yZXR1cm4gcmVzfTtSZWQucHJvdG90eXBlLmNvbnZlcnRUbz1mdW5jdGlvbiBjb252ZXJ0VG8obnVtKXt2YXIgcj1udW0udW1vZCh0aGlzLm0pO3JldHVybiByPT09bnVtP3IuY2xvbmUoKTpyfTtSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tPWZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSl7dmFyIHJlcz1udW0uY2xvbmUoKTtyZXMucmVkPW51bGw7cmV0dXJuIHJlc307Qk4ubW9udD1mdW5jdGlvbiBtb250KG51bSl7cmV0dXJuIG5ldyBNb250KG51bSl9O2Z1bmN0aW9uIE1vbnQobSl7UmVkLmNhbGwodGhpcyxtKTt0aGlzLnNoaWZ0PXRoaXMubS5iaXRMZW5ndGgoKTtpZih0aGlzLnNoaWZ0JTI2IT09MCl7dGhpcy5zaGlmdCs9MjYtdGhpcy5zaGlmdCUyNn10aGlzLnI9bmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTt0aGlzLnIyPXRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO3RoaXMucmludj10aGlzLnIuX2ludm1wKHRoaXMubSk7dGhpcy5taW52PXRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTt0aGlzLm1pbnY9dGhpcy5taW52LnVtb2QodGhpcy5yKTt0aGlzLm1pbnY9dGhpcy5yLnN1Yih0aGlzLm1pbnYpfWluaGVyaXRzKE1vbnQsUmVkKTtNb250LnByb3RvdHlwZS5jb252ZXJ0VG89ZnVuY3Rpb24gY29udmVydFRvKG51bSl7cmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpfTtNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbT1mdW5jdGlvbiBjb252ZXJ0RnJvbShudW0pe3ZhciByPXRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO3IucmVkPW51bGw7cmV0dXJuIHJ9O01vbnQucHJvdG90eXBlLmltdWw9ZnVuY3Rpb24gaW11bChhLGIpe2lmKGEuaXNaZXJvKCl8fGIuaXNaZXJvKCkpe2Eud29yZHNbMF09MDthLmxlbmd0aD0xO3JldHVybiBhfXZhciB0PWEuaW11bChiKTt2YXIgYz10Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTt2YXIgdT10LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO3ZhciByZXM9dTtpZih1LmNtcCh0aGlzLm0pPj0wKXtyZXM9dS5pc3ViKHRoaXMubSl9ZWxzZSBpZih1LmNtcG4oMCk8MCl7cmVzPXUuaWFkZCh0aGlzLm0pfXJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpfTtNb250LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24gbXVsKGEsYil7aWYoYS5pc1plcm8oKXx8Yi5pc1plcm8oKSlyZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTt2YXIgdD1hLm11bChiKTt2YXIgYz10Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTt2YXIgdT10LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO3ZhciByZXM9dTtpZih1LmNtcCh0aGlzLm0pPj0wKXtyZXM9dS5pc3ViKHRoaXMubSl9ZWxzZSBpZih1LmNtcG4oMCk8MCl7cmVzPXUuaWFkZCh0aGlzLm0pfXJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpfTtNb250LnByb3RvdHlwZS5pbnZtPWZ1bmN0aW9uIGludm0oYSl7dmFyIHJlcz10aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO3JldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpfX0pKFwib2JqZWN0XCI9PT1cInVuZGVmaW5lZFwifHxtb2R1bGUsY29tbW9uanNHbG9iYWwpfSk7Y29uc3QgdmVyc2lvbj1cImxvZ2dlci81LjEuMFwiO1widXNlIHN0cmljdFwiO2xldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzPWZhbHNlO2xldCBfY2Vuc29yRXJyb3JzPWZhbHNlO2NvbnN0IExvZ0xldmVscz17ZGVidWc6MSxkZWZhdWx0OjIsaW5mbzoyLHdhcm5pbmc6MyxlcnJvcjo0LG9mZjo1fTtsZXQgX2xvZ0xldmVsPUxvZ0xldmVsc1tcImRlZmF1bHRcIl07bGV0IF9nbG9iYWxMb2dnZXI9bnVsbDtmdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKXt0cnl7Y29uc3QgbWlzc2luZz1bXTtbXCJORkRcIixcIk5GQ1wiLFwiTkZLRFwiLFwiTkZLQ1wiXS5mb3JFYWNoKGZvcm09Pnt0cnl7aWYoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pIT09XCJ0ZXN0XCIpe3Rocm93IG5ldyBFcnJvcihcImJhZCBub3JtYWxpemVcIil9fWNhdGNoKGVycm9yKXttaXNzaW5nLnB1c2goZm9ybSl9fSk7aWYobWlzc2luZy5sZW5ndGgpe3Rocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIrbWlzc2luZy5qb2luKFwiLCBcIikpfWlmKFN0cmluZy5mcm9tQ2hhckNvZGUoMjMzKS5ub3JtYWxpemUoXCJORkRcIikhPT1TdHJpbmcuZnJvbUNoYXJDb2RlKDEwMSw3NjkpKXt0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIil9fWNhdGNoKGVycm9yKXtyZXR1cm4gZXJyb3IubWVzc2FnZX1yZXR1cm4gbnVsbH1jb25zdCBfbm9ybWFsaXplRXJyb3I9X2NoZWNrTm9ybWFsaXplKCk7dmFyIExvZ0xldmVsOyhmdW5jdGlvbihMb2dMZXZlbCl7TG9nTGV2ZWxbXCJERUJVR1wiXT1cIkRFQlVHXCI7TG9nTGV2ZWxbXCJJTkZPXCJdPVwiSU5GT1wiO0xvZ0xldmVsW1wiV0FSTklOR1wiXT1cIldBUk5JTkdcIjtMb2dMZXZlbFtcIkVSUk9SXCJdPVwiRVJST1JcIjtMb2dMZXZlbFtcIk9GRlwiXT1cIk9GRlwifSkoTG9nTGV2ZWx8fChMb2dMZXZlbD17fSkpO3ZhciBFcnJvckNvZGU7KGZ1bmN0aW9uKEVycm9yQ29kZSl7RXJyb3JDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXT1cIlVOS05PV05fRVJST1JcIjtFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl09XCJOT1RfSU1QTEVNRU5URURcIjtFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl09XCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdPVwiTkVUV09SS19FUlJPUlwiO0Vycm9yQ29kZVtcIlNFUlZFUl9FUlJPUlwiXT1cIlNFUlZFUl9FUlJPUlwiO0Vycm9yQ29kZVtcIlRJTUVPVVRcIl09XCJUSU1FT1VUXCI7RXJyb3JDb2RlW1wiQlVGRkVSX09WRVJSVU5cIl09XCJCVUZGRVJfT1ZFUlJVTlwiO0Vycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl09XCJOVU1FUklDX0ZBVUxUXCI7RXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl09XCJNSVNTSU5HX05FV1wiO0Vycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl09XCJJTlZBTElEX0FSR1VNRU5UXCI7RXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXT1cIk1JU1NJTkdfQVJHVU1FTlRcIjtFcnJvckNvZGVbXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCJdPVwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO0Vycm9yQ29kZVtcIkNBTExfRVhDRVBUSU9OXCJdPVwiQ0FMTF9FWENFUFRJT05cIjtFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl09XCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdPVwiTk9OQ0VfRVhQSVJFRFwiO0Vycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdPVwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXT1cIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJ9KShFcnJvckNvZGV8fChFcnJvckNvZGU9e30pKTtjbGFzcyBMb2dnZXJ7Y29uc3RydWN0b3IodmVyc2lvbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJ2ZXJzaW9uXCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTp2ZXJzaW9uLHdyaXRhYmxlOmZhbHNlfSl9X2xvZyhsb2dMZXZlbCxhcmdzKXtjb25zdCBsZXZlbD1sb2dMZXZlbC50b0xvd2VyQ2FzZSgpO2lmKExvZ0xldmVsc1tsZXZlbF09PW51bGwpe3RoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLFwibG9nTGV2ZWxcIixsb2dMZXZlbCl9aWYoX2xvZ0xldmVsPkxvZ0xldmVsc1tsZXZlbF0pe3JldHVybn1jb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3MpfWRlYnVnKC4uLmFyZ3Mpe3RoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLkRFQlVHLGFyZ3MpfWluZm8oLi4uYXJncyl7dGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTyxhcmdzKX13YXJuKC4uLmFyZ3Mpe3RoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLldBUk5JTkcsYXJncyl9bWFrZUVycm9yKG1lc3NhZ2UsY29kZSxwYXJhbXMpe2lmKF9jZW5zb3JFcnJvcnMpe3JldHVybiB0aGlzLm1ha2VFcnJvcihcImNlbnNvcmVkIGVycm9yXCIsY29kZSx7fSl9aWYoIWNvZGUpe2NvZGU9TG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SfWlmKCFwYXJhbXMpe3BhcmFtcz17fX1jb25zdCBtZXNzYWdlRGV0YWlscz1bXTtPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goa2V5PT57dHJ5e21lc3NhZ2VEZXRhaWxzLnB1c2goa2V5K1wiPVwiK0pTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldKSl9Y2F0Y2goZXJyb3Ipe21lc3NhZ2VEZXRhaWxzLnB1c2goa2V5K1wiPVwiK0pTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldLnRvU3RyaW5nKCkpKX19KTttZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTttZXNzYWdlRGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dGhpcy52ZXJzaW9ufWApO2NvbnN0IHJlYXNvbj1tZXNzYWdlO2lmKG1lc3NhZ2VEZXRhaWxzLmxlbmd0aCl7bWVzc2FnZSs9XCIgKFwiK21lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKStcIilcIn1jb25zdCBlcnJvcj1uZXcgRXJyb3IobWVzc2FnZSk7ZXJyb3IucmVhc29uPXJlYXNvbjtlcnJvci5jb2RlPWNvZGU7T2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7ZXJyb3Jba2V5XT1wYXJhbXNba2V5XX0pO3JldHVybiBlcnJvcn10aHJvd0Vycm9yKG1lc3NhZ2UsY29kZSxwYXJhbXMpe3Rocm93IHRoaXMubWFrZUVycm9yKG1lc3NhZ2UsY29kZSxwYXJhbXMpfXRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLG5hbWUsdmFsdWUpe3JldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSxMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50Om5hbWUsdmFsdWU6dmFsdWV9KX1hc3NlcnQoY29uZGl0aW9uLG1lc3NhZ2UsY29kZSxwYXJhbXMpe2lmKCEhY29uZGl0aW9uKXtyZXR1cm59dGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsY29kZSxwYXJhbXMpfWFzc2VydEFyZ3VtZW50KGNvbmRpdGlvbixtZXNzYWdlLG5hbWUsdmFsdWUpe2lmKCEhY29uZGl0aW9uKXtyZXR1cm59dGhpcy50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSxuYW1lLHZhbHVlKX1jaGVja05vcm1hbGl6ZShtZXNzYWdlKXtpZihtZXNzYWdlPT1udWxsKXttZXNzYWdlPVwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwifWlmKF9ub3JtYWxpemVFcnJvcil7dGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLGZvcm06X25vcm1hbGl6ZUVycm9yfSl9fWNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSxtZXNzYWdlKXtpZih0eXBlb2YgdmFsdWUhPT1cIm51bWJlclwiKXtyZXR1cm59aWYobWVzc2FnZT09bnVsbCl7bWVzc2FnZT1cInZhbHVlIG5vdCBzYWZlXCJ9aWYodmFsdWU8MHx8dmFsdWU+PTkwMDcxOTkyNTQ3NDA5OTEpe3RoaXMudGhyb3dFcnJvcihtZXNzYWdlLExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCx7b3BlcmF0aW9uOlwiY2hlY2tTYWZlSW50ZWdlclwiLGZhdWx0Olwib3V0LW9mLXNhZmUtcmFuZ2VcIix2YWx1ZTp2YWx1ZX0pfWlmKHZhbHVlJTEpe3RoaXMudGhyb3dFcnJvcihtZXNzYWdlLExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCx7b3BlcmF0aW9uOlwiY2hlY2tTYWZlSW50ZWdlclwiLGZhdWx0Olwibm9uLWludGVnZXJcIix2YWx1ZTp2YWx1ZX0pfX1jaGVja0FyZ3VtZW50Q291bnQoY291bnQsZXhwZWN0ZWRDb3VudCxtZXNzYWdlKXtpZihtZXNzYWdlKXttZXNzYWdlPVwiOiBcIittZXNzYWdlfWVsc2V7bWVzc2FnZT1cIlwifWlmKGNvdW50PGV4cGVjdGVkQ291bnQpe3RoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgYXJndW1lbnRcIittZXNzYWdlLExvZ2dlci5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCx7Y291bnQ6Y291bnQsZXhwZWN0ZWRDb3VudDpleHBlY3RlZENvdW50fSl9aWYoY291bnQ+ZXhwZWN0ZWRDb3VudCl7dGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIrbWVzc2FnZSxMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQse2NvdW50OmNvdW50LGV4cGVjdGVkQ291bnQ6ZXhwZWN0ZWRDb3VudH0pfX1jaGVja05ldyh0YXJnZXQsa2luZCl7aWYodGFyZ2V0PT09T2JqZWN0fHx0YXJnZXQ9PW51bGwpe3RoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVyx7bmFtZTpraW5kLm5hbWV9KX19Y2hlY2tBYnN0cmFjdCh0YXJnZXQsa2luZCl7aWYodGFyZ2V0PT09a2luZCl7dGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiK0pTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkrXCIgZGlyZWN0bHk7IHVzZSBhIHN1Yi1jbGFzc1wiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtuYW1lOnRhcmdldC5uYW1lLG9wZXJhdGlvbjpcIm5ld1wifSl9ZWxzZSBpZih0YXJnZXQ9PT1PYmplY3R8fHRhcmdldD09bnVsbCl7dGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIixMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLHtuYW1lOmtpbmQubmFtZX0pfX1zdGF0aWMgZ2xvYmFsTG9nZ2VyKCl7aWYoIV9nbG9iYWxMb2dnZXIpe19nbG9iYWxMb2dnZXI9bmV3IExvZ2dlcih2ZXJzaW9uKX1yZXR1cm4gX2dsb2JhbExvZ2dlcn1zdGF0aWMgc2V0Q2Vuc29yc2hpcChjZW5zb3JzaGlwLHBlcm1hbmVudCl7aWYoIWNlbnNvcnNoaXAmJnBlcm1hbmVudCl7dGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzZXRDZW5zb3JzaGlwXCJ9KX1pZihfcGVybWFuZW50Q2Vuc29yRXJyb3JzKXtpZighY2Vuc29yc2hpcCl7cmV0dXJufXRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInNldENlbnNvcnNoaXBcIn0pfV9jZW5zb3JFcnJvcnM9ISFjZW5zb3JzaGlwO19wZXJtYW5lbnRDZW5zb3JFcnJvcnM9ISFwZXJtYW5lbnR9c3RhdGljIHNldExvZ0xldmVsKGxvZ0xldmVsKXtjb25zdCBsZXZlbD1Mb2dMZXZlbHNbbG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07aWYobGV2ZWw9PW51bGwpe0xvZ2dlci5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIitsb2dMZXZlbCk7cmV0dXJufV9sb2dMZXZlbD1sZXZlbH1zdGF0aWMgZnJvbSh2ZXJzaW9uKXtyZXR1cm4gbmV3IExvZ2dlcih2ZXJzaW9uKX19TG9nZ2VyLmVycm9ycz1FcnJvckNvZGU7TG9nZ2VyLmxldmVscz1Mb2dMZXZlbDtjb25zdCB2ZXJzaW9uJDE9XCJieXRlcy81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlcj1uZXcgTG9nZ2VyKHZlcnNpb24kMSk7ZnVuY3Rpb24gaXNIZXhhYmxlKHZhbHVlKXtyZXR1cm4hIXZhbHVlLnRvSGV4U3RyaW5nfWZ1bmN0aW9uIGFkZFNsaWNlKGFycmF5KXtpZihhcnJheS5zbGljZSl7cmV0dXJuIGFycmF5fWFycmF5LnNsaWNlPWZ1bmN0aW9uKCl7Y29uc3QgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3JldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksYXJncykpKX07cmV0dXJuIGFycmF5fWZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKXtyZXR1cm4gaXNIZXhTdHJpbmcodmFsdWUpJiYhKHZhbHVlLmxlbmd0aCUyKXx8aXNCeXRlcyh2YWx1ZSl9ZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSl7aWYodmFsdWU9PW51bGwpe3JldHVybiBmYWxzZX1pZih2YWx1ZS5jb25zdHJ1Y3Rvcj09PVVpbnQ4QXJyYXkpe3JldHVybiB0cnVlfWlmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe3JldHVybiBmYWxzZX1pZih2YWx1ZS5sZW5ndGg9PW51bGwpe3JldHVybiBmYWxzZX1mb3IobGV0IGk9MDtpPHZhbHVlLmxlbmd0aDtpKyspe2NvbnN0IHY9dmFsdWVbaV07aWYodHlwZW9mIHYhPT1cIm51bWJlclwifHx2PDB8fHY+PTI1Nnx8diUxKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfWZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLG9wdGlvbnMpe2lmKCFvcHRpb25zKXtvcHRpb25zPXt9fWlmKHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCIpe2xvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIpO2NvbnN0IHJlc3VsdD1bXTt3aGlsZSh2YWx1ZSl7cmVzdWx0LnVuc2hpZnQodmFsdWUmMjU1KTt2YWx1ZT1wYXJzZUludChTdHJpbmcodmFsdWUvMjU2KSl9aWYocmVzdWx0Lmxlbmd0aD09PTApe3Jlc3VsdC5wdXNoKDApfXJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKX1pZihvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCYmdHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIiYmdmFsdWUuc3Vic3RyaW5nKDAsMikhPT1cIjB4XCIpe3ZhbHVlPVwiMHhcIit2YWx1ZX1pZihpc0hleGFibGUodmFsdWUpKXt2YWx1ZT12YWx1ZS50b0hleFN0cmluZygpfWlmKGlzSGV4U3RyaW5nKHZhbHVlKSl7bGV0IGhleD12YWx1ZS5zdWJzdHJpbmcoMik7aWYoaGV4Lmxlbmd0aCUyKXtpZihvcHRpb25zLmhleFBhZD09PVwibGVmdFwiKXtoZXg9XCIweDBcIitoZXguc3Vic3RyaW5nKDIpfWVsc2UgaWYob3B0aW9ucy5oZXhQYWQ9PT1cInJpZ2h0XCIpe2hleCs9XCIwXCJ9ZWxzZXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLFwidmFsdWVcIix2YWx1ZSl9fWNvbnN0IHJlc3VsdD1bXTtmb3IobGV0IGk9MDtpPGhleC5sZW5ndGg7aSs9Mil7cmVzdWx0LnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpLGkrMiksMTYpKX1yZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSl9aWYoaXNCeXRlcyh2YWx1ZSkpe3JldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheSh2YWx1ZSkpfXJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiLFwidmFsdWVcIix2YWx1ZSl9ZnVuY3Rpb24gY29uY2F0KGl0ZW1zKXtjb25zdCBvYmplY3RzPWl0ZW1zLm1hcChpdGVtPT5hcnJheWlmeShpdGVtKSk7Y29uc3QgbGVuZ3RoPW9iamVjdHMucmVkdWNlKChhY2N1bSxpdGVtKT0+YWNjdW0raXRlbS5sZW5ndGgsMCk7Y29uc3QgcmVzdWx0PW5ldyBVaW50OEFycmF5KGxlbmd0aCk7b2JqZWN0cy5yZWR1Y2UoKG9mZnNldCxvYmplY3QpPT57cmVzdWx0LnNldChvYmplY3Qsb2Zmc2V0KTtyZXR1cm4gb2Zmc2V0K29iamVjdC5sZW5ndGh9LDApO3JldHVybiBhZGRTbGljZShyZXN1bHQpfWZ1bmN0aW9uIHN0cmlwWmVyb3ModmFsdWUpe2xldCByZXN1bHQ9YXJyYXlpZnkodmFsdWUpO2lmKHJlc3VsdC5sZW5ndGg9PT0wKXtyZXR1cm4gcmVzdWx0fWxldCBzdGFydD0wO3doaWxlKHN0YXJ0PHJlc3VsdC5sZW5ndGgmJnJlc3VsdFtzdGFydF09PT0wKXtzdGFydCsrfWlmKHN0YXJ0KXtyZXN1bHQ9cmVzdWx0LnNsaWNlKHN0YXJ0KX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIHplcm9QYWQodmFsdWUsbGVuZ3RoKXt2YWx1ZT1hcnJheWlmeSh2YWx1ZSk7aWYodmFsdWUubGVuZ3RoPmxlbmd0aCl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLFwidmFsdWVcIixhcmd1bWVudHNbMF0pfWNvbnN0IHJlc3VsdD1uZXcgVWludDhBcnJheShsZW5ndGgpO3Jlc3VsdC5zZXQodmFsdWUsbGVuZ3RoLXZhbHVlLmxlbmd0aCk7cmV0dXJuIGFkZFNsaWNlKHJlc3VsdCl9ZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsbGVuZ3RoKXtpZih0eXBlb2YgdmFsdWUhPT1cInN0cmluZ1wifHwhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSl7cmV0dXJuIGZhbHNlfWlmKGxlbmd0aCYmdmFsdWUubGVuZ3RoIT09MisyKmxlbmd0aCl7cmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfWNvbnN0IEhleENoYXJhY3RlcnM9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7ZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSxvcHRpb25zKXtpZighb3B0aW9ucyl7b3B0aW9ucz17fX1pZih0eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiKXtsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIpO2xldCBoZXg9XCJcIjt3aGlsZSh2YWx1ZSl7aGV4PUhleENoYXJhY3RlcnNbdmFsdWUmMTVdK2hleDt2YWx1ZT1NYXRoLmZsb29yKHZhbHVlLzE2KX1pZihoZXgubGVuZ3RoKXtpZihoZXgubGVuZ3RoJTIpe2hleD1cIjBcIitoZXh9cmV0dXJuXCIweFwiK2hleH1yZXR1cm5cIjB4MDBcIn1pZihvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCYmdHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIiYmdmFsdWUuc3Vic3RyaW5nKDAsMikhPT1cIjB4XCIpe3ZhbHVlPVwiMHhcIit2YWx1ZX1pZihpc0hleGFibGUodmFsdWUpKXtyZXR1cm4gdmFsdWUudG9IZXhTdHJpbmcoKX1pZihpc0hleFN0cmluZyh2YWx1ZSkpe2lmKHZhbHVlLmxlbmd0aCUyKXtpZihvcHRpb25zLmhleFBhZD09PVwibGVmdFwiKXt2YWx1ZT1cIjB4MFwiK3ZhbHVlLnN1YnN0cmluZygyKX1lbHNlIGlmKG9wdGlvbnMuaGV4UGFkPT09XCJyaWdodFwiKXt2YWx1ZSs9XCIwXCJ9ZWxzZXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLFwidmFsdWVcIix2YWx1ZSl9fXJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpfWlmKGlzQnl0ZXModmFsdWUpKXtsZXQgcmVzdWx0PVwiMHhcIjtmb3IobGV0IGk9MDtpPHZhbHVlLmxlbmd0aDtpKyspe2xldCB2PXZhbHVlW2ldO3Jlc3VsdCs9SGV4Q2hhcmFjdGVyc1sodiYyNDApPj40XStIZXhDaGFyYWN0ZXJzW3YmMTVdfXJldHVybiByZXN1bHR9cmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIixcInZhbHVlXCIsdmFsdWUpfWZ1bmN0aW9uIGhleERhdGFMZW5ndGgoZGF0YSl7aWYodHlwZW9mIGRhdGEhPT1cInN0cmluZ1wiKXtkYXRhPWhleGxpZnkoZGF0YSl9ZWxzZSBpZighaXNIZXhTdHJpbmcoZGF0YSl8fGRhdGEubGVuZ3RoJTIpe3JldHVybiBudWxsfXJldHVybihkYXRhLmxlbmd0aC0yKS8yfWZ1bmN0aW9uIGhleERhdGFTbGljZShkYXRhLG9mZnNldCxlbmRPZmZzZXQpe2lmKHR5cGVvZiBkYXRhIT09XCJzdHJpbmdcIil7ZGF0YT1oZXhsaWZ5KGRhdGEpfWVsc2UgaWYoIWlzSGV4U3RyaW5nKGRhdGEpfHxkYXRhLmxlbmd0aCUyKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhEYXRhXCIsXCJ2YWx1ZVwiLGRhdGEpfW9mZnNldD0yKzIqb2Zmc2V0O2lmKGVuZE9mZnNldCE9bnVsbCl7cmV0dXJuXCIweFwiK2RhdGEuc3Vic3RyaW5nKG9mZnNldCwyKzIqZW5kT2Zmc2V0KX1yZXR1cm5cIjB4XCIrZGF0YS5zdWJzdHJpbmcob2Zmc2V0KX1mdW5jdGlvbiBoZXhDb25jYXQoaXRlbXMpe2xldCByZXN1bHQ9XCIweFwiO2l0ZW1zLmZvckVhY2goaXRlbT0+e3Jlc3VsdCs9aGV4bGlmeShpdGVtKS5zdWJzdHJpbmcoMil9KTtyZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKXtjb25zdCB0cmltbWVkPWhleFN0cmlwWmVyb3MoaGV4bGlmeSh2YWx1ZSx7aGV4UGFkOlwibGVmdFwifSkpO2lmKHRyaW1tZWQ9PT1cIjB4XCIpe3JldHVyblwiMHgwXCJ9cmV0dXJuIHRyaW1tZWR9ZnVuY3Rpb24gaGV4U3RyaXBaZXJvcyh2YWx1ZSl7aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcIil7dmFsdWU9aGV4bGlmeSh2YWx1ZSl9aWYoIWlzSGV4U3RyaW5nKHZhbHVlKSl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLFwidmFsdWVcIix2YWx1ZSl9dmFsdWU9dmFsdWUuc3Vic3RyaW5nKDIpO2xldCBvZmZzZXQ9MDt3aGlsZShvZmZzZXQ8dmFsdWUubGVuZ3RoJiZ2YWx1ZVtvZmZzZXRdPT09XCIwXCIpe29mZnNldCsrfXJldHVyblwiMHhcIit2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KX1mdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLGxlbmd0aCl7aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcIil7dmFsdWU9aGV4bGlmeSh2YWx1ZSl9ZWxzZSBpZighaXNIZXhTdHJpbmcodmFsdWUpKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsXCJ2YWx1ZVwiLHZhbHVlKX1pZih2YWx1ZS5sZW5ndGg+MipsZW5ndGgrMil7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLFwidmFsdWVcIixhcmd1bWVudHNbMV0pfXdoaWxlKHZhbHVlLmxlbmd0aDwyKmxlbmd0aCsyKXt2YWx1ZT1cIjB4MFwiK3ZhbHVlLnN1YnN0cmluZygyKX1yZXR1cm4gdmFsdWV9ZnVuY3Rpb24gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKXtjb25zdCByZXN1bHQ9e3I6XCIweFwiLHM6XCIweFwiLF92czpcIjB4XCIscmVjb3ZlcnlQYXJhbTowLHY6MH07aWYoaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSl7Y29uc3QgYnl0ZXM9YXJyYXlpZnkoc2lnbmF0dXJlKTtpZihieXRlcy5sZW5ndGghPT02NSl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmF0dXJlIHN0cmluZzsgbXVzdCBiZSA2NSBieXRlc1wiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX1yZXN1bHQucj1oZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsMzIpKTtyZXN1bHQucz1oZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLDY0KSk7cmVzdWx0LnY9Ynl0ZXNbNjRdO2lmKHJlc3VsdC52PDI3KXtpZihyZXN1bHQudj09PTB8fHJlc3VsdC52PT09MSl7cmVzdWx0LnYrPTI3fWVsc2V7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIHYgYnl0ZVwiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX19cmVzdWx0LnJlY292ZXJ5UGFyYW09MS1yZXN1bHQudiUyO2lmKHJlc3VsdC5yZWNvdmVyeVBhcmFtKXtieXRlc1szMl18PTEyOH1yZXN1bHQuX3ZzPWhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsNjQpKX1lbHNle3Jlc3VsdC5yPXNpZ25hdHVyZS5yO3Jlc3VsdC5zPXNpZ25hdHVyZS5zO3Jlc3VsdC52PXNpZ25hdHVyZS52O3Jlc3VsdC5yZWNvdmVyeVBhcmFtPXNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO3Jlc3VsdC5fdnM9c2lnbmF0dXJlLl92cztpZihyZXN1bHQuX3ZzIT1udWxsKXtjb25zdCB2cz16ZXJvUGFkKGFycmF5aWZ5KHJlc3VsdC5fdnMpLDMyKTtyZXN1bHQuX3ZzPWhleGxpZnkodnMpO2NvbnN0IHJlY292ZXJ5UGFyYW09dnNbMF0+PTEyOD8xOjA7aWYocmVzdWx0LnJlY292ZXJ5UGFyYW09PW51bGwpe3Jlc3VsdC5yZWNvdmVyeVBhcmFtPXJlY292ZXJ5UGFyYW19ZWxzZSBpZihyZXN1bHQucmVjb3ZlcnlQYXJhbSE9PXJlY292ZXJ5UGFyYW0pe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCBfdnNcIixcInNpZ25hdHVyZVwiLHNpZ25hdHVyZSl9dnNbMF0mPTEyNztjb25zdCBzPWhleGxpZnkodnMpO2lmKHJlc3VsdC5zPT1udWxsKXtyZXN1bHQucz1zfWVsc2UgaWYocmVzdWx0LnMhPT1zKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfX1pZihyZXN1bHQucmVjb3ZlcnlQYXJhbT09bnVsbCl7aWYocmVzdWx0LnY9PW51bGwpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyB2IGFuZCByZWNvdmVyeVBhcmFtXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfWVsc2UgaWYocmVzdWx0LnY9PT0wfHxyZXN1bHQudj09PTEpe3Jlc3VsdC5yZWNvdmVyeVBhcmFtPXJlc3VsdC52fWVsc2V7cmVzdWx0LnJlY292ZXJ5UGFyYW09MS1yZXN1bHQudiUyfX1lbHNle2lmKHJlc3VsdC52PT1udWxsKXtyZXN1bHQudj0yNytyZXN1bHQucmVjb3ZlcnlQYXJhbX1lbHNlIGlmKHJlc3VsdC5yZWNvdmVyeVBhcmFtIT09MS1yZXN1bHQudiUyKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggdlwiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX19aWYocmVzdWx0LnI9PW51bGx8fCFpc0hleFN0cmluZyhyZXN1bHQucikpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIixcInNpZ25hdHVyZVwiLHNpZ25hdHVyZSl9ZWxzZXtyZXN1bHQucj1oZXhaZXJvUGFkKHJlc3VsdC5yLDMyKX1pZihyZXN1bHQucz09bnVsbHx8IWlzSGV4U3RyaW5nKHJlc3VsdC5zKSl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX1lbHNle3Jlc3VsdC5zPWhleFplcm9QYWQocmVzdWx0LnMsMzIpfWNvbnN0IHZzPWFycmF5aWZ5KHJlc3VsdC5zKTtpZih2c1swXT49MTI4KXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfWlmKHJlc3VsdC5yZWNvdmVyeVBhcmFtKXt2c1swXXw9MTI4fWNvbnN0IF92cz1oZXhsaWZ5KHZzKTtpZihyZXN1bHQuX3ZzKXtpZighaXNIZXhTdHJpbmcocmVzdWx0Ll92cykpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCBfdnNcIixcInNpZ25hdHVyZVwiLHNpZ25hdHVyZSl9cmVzdWx0Ll92cz1oZXhaZXJvUGFkKHJlc3VsdC5fdnMsMzIpfWlmKHJlc3VsdC5fdnM9PW51bGwpe3Jlc3VsdC5fdnM9X3ZzfWVsc2UgaWYocmVzdWx0Ll92cyE9PV92cyl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBfdnMgbWlzbWF0Y2ggdiBhbmQgc1wiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX19cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBqb2luU2lnbmF0dXJlKHNpZ25hdHVyZSl7c2lnbmF0dXJlPXNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7cmV0dXJuIGhleGxpZnkoY29uY2F0KFtzaWduYXR1cmUucixzaWduYXR1cmUucyxzaWduYXR1cmUucmVjb3ZlcnlQYXJhbT9cIjB4MWNcIjpcIjB4MWJcIl0pKX1jb25zdCB2ZXJzaW9uJDI9XCJiaWdudW1iZXIvNS4xLjFcIjtcInVzZSBzdHJpY3RcIjt2YXIgQk49Ym4uQk47Y29uc3QgbG9nZ2VyJDE9bmV3IExvZ2dlcih2ZXJzaW9uJDIpO2NvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkPXt9O2NvbnN0IE1BWF9TQUZFPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpe3JldHVybiB2YWx1ZSE9bnVsbCYmKEJpZ051bWJlci5pc0JpZ051bWJlcih2YWx1ZSl8fHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCImJnZhbHVlJTE9PT0wfHx0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiJiYhIXZhbHVlLm1hdGNoKC9eLT9bMC05XSskLyl8fGlzSGV4U3RyaW5nKHZhbHVlKXx8dHlwZW9mIHZhbHVlPT09XCJiaWdpbnRcInx8aXNCeXRlcyh2YWx1ZSkpfWxldCBfd2FybmVkVG9TdHJpbmdSYWRpeD1mYWxzZTtjbGFzcyBCaWdOdW1iZXJ7Y29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCxoZXgpe2xvZ2dlciQxLmNoZWNrTmV3KG5ldy50YXJnZXQsQmlnTnVtYmVyKTtpZihjb25zdHJ1Y3Rvckd1YXJkIT09X2NvbnN0cnVjdG9yR3VhcmQpe2xvZ2dlciQxLnRocm93RXJyb3IoXCJjYW5ub3QgY2FsbCBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIEJpZ051bWJlci5mcm9tXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm5ldyAoQmlnTnVtYmVyKVwifSl9dGhpcy5faGV4PWhleDt0aGlzLl9pc0JpZ051bWJlcj10cnVlO09iamVjdC5mcmVlemUodGhpcyl9ZnJvbVR3b3ModmFsdWUpe3JldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmZyb21Ud29zKHZhbHVlKSl9dG9Ud29zKHZhbHVlKXtyZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS50b1R3b3ModmFsdWUpKX1hYnMoKXtpZih0aGlzLl9oZXhbMF09PT1cIi1cIil7cmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpfXJldHVybiB0aGlzfWFkZChvdGhlcil7cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYWRkKHRvQk4ob3RoZXIpKSl9c3ViKG90aGVyKXtyZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zdWIodG9CTihvdGhlcikpKX1kaXYob3RoZXIpe2NvbnN0IG89QmlnTnVtYmVyLmZyb20ob3RoZXIpO2lmKG8uaXNaZXJvKCkpe3Rocm93RmF1bHQoXCJkaXZpc2lvbiBieSB6ZXJvXCIsXCJkaXZcIil9cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSl9bXVsKG90aGVyKXtyZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKX1tb2Qob3RoZXIpe2NvbnN0IHZhbHVlPXRvQk4ob3RoZXIpO2lmKHZhbHVlLmlzTmVnKCkpe3Rocm93RmF1bHQoXCJjYW5ub3QgbW9kdWxvIG5lZ2F0aXZlIHZhbHVlc1wiLFwibW9kXCIpfXJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnVtb2QodmFsdWUpKX1wb3cob3RoZXIpe2NvbnN0IHZhbHVlPXRvQk4ob3RoZXIpO2lmKHZhbHVlLmlzTmVnKCkpe3Rocm93RmF1bHQoXCJjYW5ub3QgcmFpc2UgdG8gbmVnYXRpdmUgdmFsdWVzXCIsXCJwb3dcIil9cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykucG93KHZhbHVlKSl9YW5kKG90aGVyKXtjb25zdCB2YWx1ZT10b0JOKG90aGVyKTtpZih0aGlzLmlzTmVnYXRpdmUoKXx8dmFsdWUuaXNOZWcoKSl7dGhyb3dGYXVsdChcImNhbm5vdCAnYW5kJyBuZWdhdGl2ZSB2YWx1ZXNcIixcImFuZFwiKX1yZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5hbmQodmFsdWUpKX1vcihvdGhlcil7Y29uc3QgdmFsdWU9dG9CTihvdGhlcik7aWYodGhpcy5pc05lZ2F0aXZlKCl8fHZhbHVlLmlzTmVnKCkpe3Rocm93RmF1bHQoXCJjYW5ub3QgJ29yJyBuZWdhdGl2ZSB2YWx1ZXNcIixcIm9yXCIpfXJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSl9eG9yKG90aGVyKXtjb25zdCB2YWx1ZT10b0JOKG90aGVyKTtpZih0aGlzLmlzTmVnYXRpdmUoKXx8dmFsdWUuaXNOZWcoKSl7dGhyb3dGYXVsdChcImNhbm5vdCAneG9yJyBuZWdhdGl2ZSB2YWx1ZXNcIixcInhvclwiKX1yZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS54b3IodmFsdWUpKX1tYXNrKHZhbHVlKXtpZih0aGlzLmlzTmVnYXRpdmUoKXx8dmFsdWU8MCl7dGhyb3dGYXVsdChcImNhbm5vdCBtYXNrIG5lZ2F0aXZlIHZhbHVlc1wiLFwibWFza1wiKX1yZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tYXNrbih2YWx1ZSkpfXNobCh2YWx1ZSl7aWYodGhpcy5pc05lZ2F0aXZlKCl8fHZhbHVlPDApe3Rocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsXCJzaGxcIil9cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hsbih2YWx1ZSkpfXNocih2YWx1ZSl7aWYodGhpcy5pc05lZ2F0aXZlKCl8fHZhbHVlPDApe3Rocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsXCJzaHJcIil9cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hybih2YWx1ZSkpfWVxKG90aGVyKXtyZXR1cm4gdG9CTih0aGlzKS5lcSh0b0JOKG90aGVyKSl9bHQob3RoZXIpe3JldHVybiB0b0JOKHRoaXMpLmx0KHRvQk4ob3RoZXIpKX1sdGUob3RoZXIpe3JldHVybiB0b0JOKHRoaXMpLmx0ZSh0b0JOKG90aGVyKSl9Z3Qob3RoZXIpe3JldHVybiB0b0JOKHRoaXMpLmd0KHRvQk4ob3RoZXIpKX1ndGUob3RoZXIpe3JldHVybiB0b0JOKHRoaXMpLmd0ZSh0b0JOKG90aGVyKSl9aXNOZWdhdGl2ZSgpe3JldHVybiB0aGlzLl9oZXhbMF09PT1cIi1cIn1pc1plcm8oKXtyZXR1cm4gdG9CTih0aGlzKS5pc1plcm8oKX10b051bWJlcigpe3RyeXtyZXR1cm4gdG9CTih0aGlzKS50b051bWJlcigpfWNhdGNoKGVycm9yKXt0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIixcInRvTnVtYmVyXCIsdGhpcy50b1N0cmluZygpKX1yZXR1cm4gbnVsbH10b0JpZ0ludCgpe3RyeXtyZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSl9Y2F0Y2goZSl7fXJldHVybiBsb2dnZXIkMS50aHJvd0Vycm9yKFwidGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEJpZ0ludFwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHt2YWx1ZTp0aGlzLnRvU3RyaW5nKCl9KX10b1N0cmluZygpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MCl7aWYoYXJndW1lbnRzWzBdPT09MTApe2lmKCFfd2FybmVkVG9TdHJpbmdSYWRpeCl7X3dhcm5lZFRvU3RyaW5nUmFkaXg9dHJ1ZTtsb2dnZXIkMS53YXJuKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgYmFzZS0xMCBpcyBhc3N1bWVkXCIpfX1lbHNlIGlmKGFyZ3VtZW50c1swXT09PTE2KXtsb2dnZXIkMS50aHJvd0Vycm9yKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgdXNlIGJpZ051bWJlci50b0hleFN0cmluZygpXCIsTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULHt9KX1lbHNle2xvZ2dlciQxLnRocm93RXJyb3IoXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlcnNcIixMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQse30pfX1yZXR1cm4gdG9CTih0aGlzKS50b1N0cmluZygxMCl9dG9IZXhTdHJpbmcoKXtyZXR1cm4gdGhpcy5faGV4fXRvSlNPTihrZXkpe3JldHVybnt0eXBlOlwiQmlnTnVtYmVyXCIsaGV4OnRoaXMudG9IZXhTdHJpbmcoKX19c3RhdGljIGZyb20odmFsdWUpe2lmKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKXtyZXR1cm4gdmFsdWV9aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7aWYodmFsdWUubWF0Y2goL14tPzB4WzAtOWEtZl0rJC9pKSl7cmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsdG9IZXgodmFsdWUpKX1pZih2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pKXtyZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCx0b0hleChuZXcgQk4odmFsdWUpKSl9cmV0dXJuIGxvZ2dlciQxLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHN0cmluZ1wiLFwidmFsdWVcIix2YWx1ZSl9aWYodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIil7aWYodmFsdWUlMSl7dGhyb3dGYXVsdChcInVuZGVyZmxvd1wiLFwiQmlnTnVtYmVyLmZyb21cIix2YWx1ZSl9aWYodmFsdWU+PU1BWF9TQUZFfHx2YWx1ZTw9LU1BWF9TQUZFKXt0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIixcIkJpZ051bWJlci5mcm9tXCIsdmFsdWUpfXJldHVybiBCaWdOdW1iZXIuZnJvbShTdHJpbmcodmFsdWUpKX1jb25zdCBhbnlWYWx1ZT12YWx1ZTtpZih0eXBlb2YgYW55VmFsdWU9PT1cImJpZ2ludFwiKXtyZXR1cm4gQmlnTnVtYmVyLmZyb20oYW55VmFsdWUudG9TdHJpbmcoKSl9aWYoaXNCeXRlcyhhbnlWYWx1ZSkpe3JldHVybiBCaWdOdW1iZXIuZnJvbShoZXhsaWZ5KGFueVZhbHVlKSl9aWYoYW55VmFsdWUpe2lmKGFueVZhbHVlLnRvSGV4U3RyaW5nKXtjb25zdCBoZXg9YW55VmFsdWUudG9IZXhTdHJpbmcoKTtpZih0eXBlb2YgaGV4PT09XCJzdHJpbmdcIil7cmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCl9fWVsc2V7bGV0IGhleD1hbnlWYWx1ZS5faGV4O2lmKGhleD09bnVsbCYmYW55VmFsdWUudHlwZT09PVwiQmlnTnVtYmVyXCIpe2hleD1hbnlWYWx1ZS5oZXh9aWYodHlwZW9mIGhleD09PVwic3RyaW5nXCIpe2lmKGlzSGV4U3RyaW5nKGhleCl8fGhleFswXT09PVwiLVwiJiZpc0hleFN0cmluZyhoZXguc3Vic3RyaW5nKDEpKSl7cmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCl9fX19cmV0dXJuIGxvZ2dlciQxLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHZhbHVlXCIsXCJ2YWx1ZVwiLHZhbHVlKX1zdGF0aWMgaXNCaWdOdW1iZXIodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNCaWdOdW1iZXIpfX1mdW5jdGlvbiB0b0hleCh2YWx1ZSl7aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcIil7cmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSl9aWYodmFsdWVbMF09PT1cIi1cIil7dmFsdWU9dmFsdWUuc3Vic3RyaW5nKDEpO2lmKHZhbHVlWzBdPT09XCItXCIpe2xvZ2dlciQxLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4XCIsXCJ2YWx1ZVwiLHZhbHVlKX12YWx1ZT10b0hleCh2YWx1ZSk7aWYodmFsdWU9PT1cIjB4MDBcIil7cmV0dXJuIHZhbHVlfXJldHVyblwiLVwiK3ZhbHVlfWlmKHZhbHVlLnN1YnN0cmluZygwLDIpIT09XCIweFwiKXt2YWx1ZT1cIjB4XCIrdmFsdWV9aWYodmFsdWU9PT1cIjB4XCIpe3JldHVyblwiMHgwMFwifWlmKHZhbHVlLmxlbmd0aCUyKXt2YWx1ZT1cIjB4MFwiK3ZhbHVlLnN1YnN0cmluZygyKX13aGlsZSh2YWx1ZS5sZW5ndGg+NCYmdmFsdWUuc3Vic3RyaW5nKDAsNCk9PT1cIjB4MDBcIil7dmFsdWU9XCIweFwiK3ZhbHVlLnN1YnN0cmluZyg0KX1yZXR1cm4gdmFsdWV9ZnVuY3Rpb24gdG9CaWdOdW1iZXIodmFsdWUpe3JldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpfWZ1bmN0aW9uIHRvQk4odmFsdWUpe2NvbnN0IGhleD1CaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtpZihoZXhbMF09PT1cIi1cIil7cmV0dXJuIG5ldyBCTihcIi1cIitoZXguc3Vic3RyaW5nKDMpLDE2KX1yZXR1cm4gbmV3IEJOKGhleC5zdWJzdHJpbmcoMiksMTYpfWZ1bmN0aW9uIHRocm93RmF1bHQoZmF1bHQsb3BlcmF0aW9uLHZhbHVlKXtjb25zdCBwYXJhbXM9e2ZhdWx0OmZhdWx0LG9wZXJhdGlvbjpvcGVyYXRpb259O2lmKHZhbHVlIT1udWxsKXtwYXJhbXMudmFsdWU9dmFsdWV9cmV0dXJuIGxvZ2dlciQxLnRocm93RXJyb3IoZmF1bHQsTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULHBhcmFtcyl9ZnVuY3Rpb24gX2Jhc2UzNlRvMTYodmFsdWUpe3JldHVybiBuZXcgQk4odmFsdWUsMzYpLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiBfYmFzZTE2VG8zNih2YWx1ZSl7cmV0dXJuIG5ldyBCTih2YWx1ZSwxNikudG9TdHJpbmcoMzYpfVwidXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciQyPW5ldyBMb2dnZXIodmVyc2lvbiQyKTtjb25zdCBfY29uc3RydWN0b3JHdWFyZCQxPXt9O2NvbnN0IFplcm89QmlnTnVtYmVyLmZyb20oMCk7Y29uc3QgTmVnYXRpdmVPbmU9QmlnTnVtYmVyLmZyb20oLTEpO2Z1bmN0aW9uIHRocm93RmF1bHQkMShtZXNzYWdlLGZhdWx0LG9wZXJhdGlvbix2YWx1ZSl7Y29uc3QgcGFyYW1zPXtmYXVsdDpmYXVsdCxvcGVyYXRpb246b3BlcmF0aW9ufTtpZih2YWx1ZSE9PXVuZGVmaW5lZCl7cGFyYW1zLnZhbHVlPXZhbHVlfXJldHVybiBsb2dnZXIkMi50aHJvd0Vycm9yKG1lc3NhZ2UsTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULHBhcmFtcyl9bGV0IHplcm9zPVwiMFwiO3doaWxlKHplcm9zLmxlbmd0aDwyNTYpe3plcm9zKz16ZXJvc31mdW5jdGlvbiBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKXtpZih0eXBlb2YgZGVjaW1hbHMhPT1cIm51bWJlclwiKXt0cnl7ZGVjaW1hbHM9QmlnTnVtYmVyLmZyb20oZGVjaW1hbHMpLnRvTnVtYmVyKCl9Y2F0Y2goZSl7fX1pZih0eXBlb2YgZGVjaW1hbHM9PT1cIm51bWJlclwiJiZkZWNpbWFscz49MCYmZGVjaW1hbHM8PTI1NiYmIShkZWNpbWFscyUxKSl7cmV0dXJuXCIxXCIremVyb3Muc3Vic3RyaW5nKDAsZGVjaW1hbHMpfXJldHVybiBsb2dnZXIkMi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgc2l6ZVwiLFwiZGVjaW1hbHNcIixkZWNpbWFscyl9ZnVuY3Rpb24gZm9ybWF0Rml4ZWQodmFsdWUsZGVjaW1hbHMpe2lmKGRlY2ltYWxzPT1udWxsKXtkZWNpbWFscz0wfWNvbnN0IG11bHRpcGxpZXI9Z2V0TXVsdGlwbGllcihkZWNpbWFscyk7dmFsdWU9QmlnTnVtYmVyLmZyb20odmFsdWUpO2NvbnN0IG5lZ2F0aXZlPXZhbHVlLmx0KFplcm8pO2lmKG5lZ2F0aXZlKXt2YWx1ZT12YWx1ZS5tdWwoTmVnYXRpdmVPbmUpfWxldCBmcmFjdGlvbj12YWx1ZS5tb2QobXVsdGlwbGllcikudG9TdHJpbmcoKTt3aGlsZShmcmFjdGlvbi5sZW5ndGg8bXVsdGlwbGllci5sZW5ndGgtMSl7ZnJhY3Rpb249XCIwXCIrZnJhY3Rpb259ZnJhY3Rpb249ZnJhY3Rpb24ubWF0Y2goL14oWzAtOV0qWzEtOV18MCkoMCopLylbMV07Y29uc3Qgd2hvbGU9dmFsdWUuZGl2KG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7dmFsdWU9d2hvbGUrXCIuXCIrZnJhY3Rpb247aWYobmVnYXRpdmUpe3ZhbHVlPVwiLVwiK3ZhbHVlfXJldHVybiB2YWx1ZX1mdW5jdGlvbiBwYXJzZUZpeGVkKHZhbHVlLGRlY2ltYWxzKXtpZihkZWNpbWFscz09bnVsbCl7ZGVjaW1hbHM9MH1jb25zdCBtdWx0aXBsaWVyPWdldE11bHRpcGxpZXIoZGVjaW1hbHMpO2lmKHR5cGVvZiB2YWx1ZSE9PVwic3RyaW5nXCJ8fCF2YWx1ZS5tYXRjaCgvXi0/WzAtOS4sXSskLykpe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCB2YWx1ZVwiLFwidmFsdWVcIix2YWx1ZSl9aWYobXVsdGlwbGllci5sZW5ndGgtMT09PTApe3JldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSl9Y29uc3QgbmVnYXRpdmU9dmFsdWUuc3Vic3RyaW5nKDAsMSk9PT1cIi1cIjtpZihuZWdhdGl2ZSl7dmFsdWU9dmFsdWUuc3Vic3RyaW5nKDEpfWlmKHZhbHVlPT09XCIuXCIpe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgdmFsdWVcIixcInZhbHVlXCIsdmFsdWUpfWNvbnN0IGNvbXBzPXZhbHVlLnNwbGl0KFwiLlwiKTtpZihjb21wcy5sZW5ndGg+Mil7bG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwidG9vIG1hbnkgZGVjaW1hbCBwb2ludHNcIixcInZhbHVlXCIsdmFsdWUpfWxldCB3aG9sZT1jb21wc1swXSxmcmFjdGlvbj1jb21wc1sxXTtpZighd2hvbGUpe3dob2xlPVwiMFwifWlmKCFmcmFjdGlvbil7ZnJhY3Rpb249XCIwXCJ9aWYoZnJhY3Rpb24ubGVuZ3RoPm11bHRpcGxpZXIubGVuZ3RoLTEpe3Rocm93RmF1bHQkMShcImZyYWN0aW9uYWwgY29tcG9uZW50IGV4Y2VlZHMgZGVjaW1hbHNcIixcInVuZGVyZmxvd1wiLFwicGFyc2VGaXhlZFwiKX13aGlsZShmcmFjdGlvbi5sZW5ndGg8bXVsdGlwbGllci5sZW5ndGgtMSl7ZnJhY3Rpb24rPVwiMFwifWNvbnN0IHdob2xlVmFsdWU9QmlnTnVtYmVyLmZyb20od2hvbGUpO2NvbnN0IGZyYWN0aW9uVmFsdWU9QmlnTnVtYmVyLmZyb20oZnJhY3Rpb24pO2xldCB3ZWk9d2hvbGVWYWx1ZS5tdWwobXVsdGlwbGllcikuYWRkKGZyYWN0aW9uVmFsdWUpO2lmKG5lZ2F0aXZlKXt3ZWk9d2VpLm11bChOZWdhdGl2ZU9uZSl9cmV0dXJuIHdlaX1jbGFzcyBGaXhlZEZvcm1hdHtjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLHNpZ25lZCx3aWR0aCxkZWNpbWFscyl7aWYoY29uc3RydWN0b3JHdWFyZCE9PV9jb25zdHJ1Y3Rvckd1YXJkJDEpe2xvZ2dlciQyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkRm9ybWF0IGNvbnN0cnVjdG9yOyB1c2UgRml4ZWRGb3JtYXQuZnJvbVwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJuZXcgRml4ZWRGb3JtYXRcIn0pfXRoaXMuc2lnbmVkPXNpZ25lZDt0aGlzLndpZHRoPXdpZHRoO3RoaXMuZGVjaW1hbHM9ZGVjaW1hbHM7dGhpcy5uYW1lPShzaWduZWQ/XCJcIjpcInVcIikrXCJmaXhlZFwiK1N0cmluZyh3aWR0aCkrXCJ4XCIrU3RyaW5nKGRlY2ltYWxzKTt0aGlzLl9tdWx0aXBsaWVyPWdldE11bHRpcGxpZXIoZGVjaW1hbHMpO09iamVjdC5mcmVlemUodGhpcyl9c3RhdGljIGZyb20odmFsdWUpe2lmKHZhbHVlIGluc3RhbmNlb2YgRml4ZWRGb3JtYXQpe3JldHVybiB2YWx1ZX1sZXQgc2lnbmVkPXRydWU7bGV0IHdpZHRoPTEyODtsZXQgZGVjaW1hbHM9MTg7aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7aWYodmFsdWU9PT1cImZpeGVkXCIpe31lbHNlIGlmKHZhbHVlPT09XCJ1Zml4ZWRcIil7c2lnbmVkPWZhbHNlfWVsc2UgaWYodmFsdWUhPW51bGwpe2NvbnN0IG1hdGNoPXZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7aWYoIW1hdGNoKXtsb2dnZXIkMi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLFwiZm9ybWF0XCIsdmFsdWUpfXNpZ25lZD1tYXRjaFsxXSE9PVwidVwiO3dpZHRoPXBhcnNlSW50KG1hdGNoWzJdKTtkZWNpbWFscz1wYXJzZUludChtYXRjaFszXSl9fWVsc2UgaWYodmFsdWUpe2NvbnN0IGNoZWNrPShrZXksdHlwZSxkZWZhdWx0VmFsdWUpPT57aWYodmFsdWVba2V5XT09bnVsbCl7cmV0dXJuIGRlZmF1bHRWYWx1ZX1pZih0eXBlb2YgdmFsdWVba2V5XSE9PXR5cGUpe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIitrZXkrXCIgbm90IFwiK3R5cGUrXCIpXCIsXCJmb3JtYXQuXCIra2V5LHZhbHVlW2tleV0pfXJldHVybiB2YWx1ZVtrZXldfTtzaWduZWQ9Y2hlY2soXCJzaWduZWRcIixcImJvb2xlYW5cIixzaWduZWQpO3dpZHRoPWNoZWNrKFwid2lkdGhcIixcIm51bWJlclwiLHdpZHRoKTtkZWNpbWFscz1jaGVjayhcImRlY2ltYWxzXCIsXCJudW1iZXJcIixkZWNpbWFscyl9aWYod2lkdGglOCl7bG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsXCJmb3JtYXQud2lkdGhcIix3aWR0aCl9aWYoZGVjaW1hbHM+ODApe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChkZWNpbWFscyB0b28gbGFyZ2UpXCIsXCJmb3JtYXQuZGVjaW1hbHNcIixkZWNpbWFscyl9cmV0dXJuIG5ldyBGaXhlZEZvcm1hdChfY29uc3RydWN0b3JHdWFyZCQxLHNpZ25lZCx3aWR0aCxkZWNpbWFscyl9fWNsYXNzIEZpeGVkTnVtYmVye2NvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsaGV4LHZhbHVlLGZvcm1hdCl7bG9nZ2VyJDIuY2hlY2tOZXcobmV3LnRhcmdldCxGaXhlZE51bWJlcik7aWYoY29uc3RydWN0b3JHdWFyZCE9PV9jb25zdHJ1Y3Rvckd1YXJkJDEpe2xvZ2dlciQyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkTnVtYmVyIGNvbnN0cnVjdG9yOyB1c2UgRml4ZWROdW1iZXIuZnJvbVwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJuZXcgRml4ZWRGb3JtYXRcIn0pfXRoaXMuZm9ybWF0PWZvcm1hdDt0aGlzLl9oZXg9aGV4O3RoaXMuX3ZhbHVlPXZhbHVlO3RoaXMuX2lzRml4ZWROdW1iZXI9dHJ1ZTtPYmplY3QuZnJlZXplKHRoaXMpfV9jaGVja0Zvcm1hdChvdGhlcil7aWYodGhpcy5mb3JtYXQubmFtZSE9PW90aGVyLmZvcm1hdC5uYW1lKXtsb2dnZXIkMi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIixcIm90aGVyXCIsb3RoZXIpfX1hZGRVbnNhZmUob3RoZXIpe3RoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtjb25zdCBhPXBhcnNlRml4ZWQodGhpcy5fdmFsdWUsdGhpcy5mb3JtYXQuZGVjaW1hbHMpO2NvbnN0IGI9cGFyc2VGaXhlZChvdGhlci5fdmFsdWUsb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtyZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuYWRkKGIpLHRoaXMuZm9ybWF0LmRlY2ltYWxzLHRoaXMuZm9ybWF0KX1zdWJVbnNhZmUob3RoZXIpe3RoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtjb25zdCBhPXBhcnNlRml4ZWQodGhpcy5fdmFsdWUsdGhpcy5mb3JtYXQuZGVjaW1hbHMpO2NvbnN0IGI9cGFyc2VGaXhlZChvdGhlci5fdmFsdWUsb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtyZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuc3ViKGIpLHRoaXMuZm9ybWF0LmRlY2ltYWxzLHRoaXMuZm9ybWF0KX1tdWxVbnNhZmUob3RoZXIpe3RoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtjb25zdCBhPXBhcnNlRml4ZWQodGhpcy5fdmFsdWUsdGhpcy5mb3JtYXQuZGVjaW1hbHMpO2NvbnN0IGI9cGFyc2VGaXhlZChvdGhlci5fdmFsdWUsb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtyZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKGIpLmRpdih0aGlzLmZvcm1hdC5fbXVsdGlwbGllciksdGhpcy5mb3JtYXQuZGVjaW1hbHMsdGhpcy5mb3JtYXQpfWRpdlVuc2FmZShvdGhlcil7dGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO2NvbnN0IGE9cGFyc2VGaXhlZCh0aGlzLl92YWx1ZSx0aGlzLmZvcm1hdC5kZWNpbWFscyk7Y29uc3QgYj1wYXJzZUZpeGVkKG90aGVyLl92YWx1ZSxvdGhlci5mb3JtYXQuZGVjaW1hbHMpO3JldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLmRpdihiKSx0aGlzLmZvcm1hdC5kZWNpbWFscyx0aGlzLmZvcm1hdCl9Zmxvb3IoKXtsZXQgY29tcHM9dGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtsZXQgcmVzdWx0PUZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sdGhpcy5mb3JtYXQpO2NvbnN0IGhhc0ZyYWN0aW9uPSFjb21wc1sxXS5tYXRjaCgvXigwKikkLyk7aWYodGhpcy5pc05lZ2F0aXZlKCkmJmhhc0ZyYWN0aW9uKXtyZXN1bHQ9cmVzdWx0LnN1YlVuc2FmZShPTkUpfXJldHVybiByZXN1bHR9Y2VpbGluZygpe2xldCBjb21wcz10aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO2xldCByZXN1bHQ9Rml4ZWROdW1iZXIuZnJvbShjb21wc1swXSx0aGlzLmZvcm1hdCk7Y29uc3QgaGFzRnJhY3Rpb249IWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtpZighdGhpcy5pc05lZ2F0aXZlKCkmJmhhc0ZyYWN0aW9uKXtyZXN1bHQ9cmVzdWx0LmFkZFVuc2FmZShPTkUpfXJldHVybiByZXN1bHR9cm91bmQoZGVjaW1hbHMpe2lmKGRlY2ltYWxzPT1udWxsKXtkZWNpbWFscz0wfWxldCBjb21wcz10aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO2lmKGRlY2ltYWxzPDB8fGRlY2ltYWxzPjgwfHxkZWNpbWFscyUxKXtsb2dnZXIkMi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgY291bnRcIixcImRlY2ltYWxzXCIsZGVjaW1hbHMpfWlmKGNvbXBzWzFdLmxlbmd0aDw9ZGVjaW1hbHMpe3JldHVybiB0aGlzfWNvbnN0IGZhY3Rvcj1GaXhlZE51bWJlci5mcm9tKFwiMVwiK3plcm9zLnN1YnN0cmluZygwLGRlY2ltYWxzKSk7cmV0dXJuIHRoaXMubXVsVW5zYWZlKGZhY3RvcikuYWRkVW5zYWZlKEJVTVApLmZsb29yKCkuZGl2VW5zYWZlKGZhY3Rvcil9aXNaZXJvKCl7cmV0dXJuIHRoaXMuX3ZhbHVlPT09XCIwLjBcIn1pc05lZ2F0aXZlKCl7cmV0dXJuIHRoaXMuX3ZhbHVlWzBdPT09XCItXCJ9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fdmFsdWV9dG9IZXhTdHJpbmcod2lkdGgpe2lmKHdpZHRoPT1udWxsKXtyZXR1cm4gdGhpcy5faGV4fWlmKHdpZHRoJTgpe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZSB3aWR0aFwiLFwid2lkdGhcIix3aWR0aCl9Y29uc3QgaGV4PUJpZ051bWJlci5mcm9tKHRoaXMuX2hleCkuZnJvbVR3b3ModGhpcy5mb3JtYXQud2lkdGgpLnRvVHdvcyh3aWR0aCkudG9IZXhTdHJpbmcoKTtyZXR1cm4gaGV4WmVyb1BhZChoZXgsd2lkdGgvOCl9dG9VbnNhZmVGbG9hdCgpe3JldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSl9dG9Gb3JtYXQoZm9ybWF0KXtyZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh0aGlzLl92YWx1ZSxmb3JtYXQpfXN0YXRpYyBmcm9tVmFsdWUodmFsdWUsZGVjaW1hbHMsZm9ybWF0KXtpZihmb3JtYXQ9PW51bGwmJmRlY2ltYWxzIT1udWxsJiYhaXNCaWdOdW1iZXJpc2goZGVjaW1hbHMpKXtmb3JtYXQ9ZGVjaW1hbHM7ZGVjaW1hbHM9bnVsbH1pZihkZWNpbWFscz09bnVsbCl7ZGVjaW1hbHM9MH1pZihmb3JtYXQ9PW51bGwpe2Zvcm1hdD1cImZpeGVkXCJ9cmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoZm9ybWF0Rml4ZWQodmFsdWUsZGVjaW1hbHMpLEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KSl9c3RhdGljIGZyb21TdHJpbmcodmFsdWUsZm9ybWF0KXtpZihmb3JtYXQ9PW51bGwpe2Zvcm1hdD1cImZpeGVkXCJ9Y29uc3QgZml4ZWRGb3JtYXQ9Rml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO2NvbnN0IG51bWVyaWM9cGFyc2VGaXhlZCh2YWx1ZSxmaXhlZEZvcm1hdC5kZWNpbWFscyk7aWYoIWZpeGVkRm9ybWF0LnNpZ25lZCYmbnVtZXJpYy5sdChaZXJvKSl7dGhyb3dGYXVsdCQxKFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsXCJvdmVyZmxvd1wiLFwidmFsdWVcIix2YWx1ZSl9bGV0IGhleD1udWxsO2lmKGZpeGVkRm9ybWF0LnNpZ25lZCl7aGV4PW51bWVyaWMudG9Ud29zKGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpfWVsc2V7aGV4PW51bWVyaWMudG9IZXhTdHJpbmcoKTtoZXg9aGV4WmVyb1BhZChoZXgsZml4ZWRGb3JtYXQud2lkdGgvOCl9Y29uc3QgZGVjaW1hbD1mb3JtYXRGaXhlZChudW1lcmljLGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtyZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkJDEsaGV4LGRlY2ltYWwsZml4ZWRGb3JtYXQpfXN0YXRpYyBmcm9tQnl0ZXModmFsdWUsZm9ybWF0KXtpZihmb3JtYXQ9PW51bGwpe2Zvcm1hdD1cImZpeGVkXCJ9Y29uc3QgZml4ZWRGb3JtYXQ9Rml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO2lmKGFycmF5aWZ5KHZhbHVlKS5sZW5ndGg+Zml4ZWRGb3JtYXQud2lkdGgvOCl7dGhyb3cgbmV3IEVycm9yKFwib3ZlcmZsb3dcIil9bGV0IG51bWVyaWM9QmlnTnVtYmVyLmZyb20odmFsdWUpO2lmKGZpeGVkRm9ybWF0LnNpZ25lZCl7bnVtZXJpYz1udW1lcmljLmZyb21Ud29zKGZpeGVkRm9ybWF0LndpZHRoKX1jb25zdCBoZXg9bnVtZXJpYy50b1R3b3MoKGZpeGVkRm9ybWF0LnNpZ25lZD8wOjEpK2ZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO2NvbnN0IGRlY2ltYWw9Zm9ybWF0Rml4ZWQobnVtZXJpYyxmaXhlZEZvcm1hdC5kZWNpbWFscyk7cmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCQxLGhleCxkZWNpbWFsLGZpeGVkRm9ybWF0KX1zdGF0aWMgZnJvbSh2YWx1ZSxmb3JtYXQpe2lmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe3JldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHZhbHVlLGZvcm1hdCl9aWYoaXNCeXRlcyh2YWx1ZSkpe3JldHVybiBGaXhlZE51bWJlci5mcm9tQnl0ZXModmFsdWUsZm9ybWF0KX10cnl7cmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwwLGZvcm1hdCl9Y2F0Y2goZXJyb3Ipe2lmKGVycm9yLmNvZGUhPT1Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQpe3Rocm93IGVycm9yfX1yZXR1cm4gbG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBGaXhlZE51bWJlciB2YWx1ZVwiLFwidmFsdWVcIix2YWx1ZSl9c3RhdGljIGlzRml4ZWROdW1iZXIodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNGaXhlZE51bWJlcil9fWNvbnN0IE9ORT1GaXhlZE51bWJlci5mcm9tKDEpO2NvbnN0IEJVTVA9Rml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtjb25zdCB2ZXJzaW9uJDM9XCJwcm9wZXJ0aWVzLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlcj13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJDM9bmV3IExvZ2dlcih2ZXJzaW9uJDMpO2Z1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCxuYW1lLHZhbHVlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LG5hbWUse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTp2YWx1ZSx3cml0YWJsZTpmYWxzZX0pfWZ1bmN0aW9uIGdldFN0YXRpYyhjdG9yLGtleSl7Zm9yKGxldCBpPTA7aTwzMjtpKyspe2lmKGN0b3Jba2V5XSl7cmV0dXJuIGN0b3Jba2V5XX1pZighY3Rvci5wcm90b3R5cGV8fHR5cGVvZiBjdG9yLnByb3RvdHlwZSE9PVwib2JqZWN0XCIpe2JyZWFrfWN0b3I9T2JqZWN0LmdldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlKS5jb25zdHJ1Y3Rvcn1yZXR1cm4gbnVsbH1mdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyhvYmplY3Qpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHByb21pc2VzPU9iamVjdC5rZXlzKG9iamVjdCkubWFwKGtleT0+e2NvbnN0IHZhbHVlPW9iamVjdFtrZXldO3JldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4odj0+KHtrZXk6a2V5LHZhbHVlOnZ9KSl9KTtjb25zdCByZXN1bHRzPXlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtyZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLHJlc3VsdCk9PnthY2N1bVtyZXN1bHQua2V5XT1yZXN1bHQudmFsdWU7cmV0dXJuIGFjY3VtfSx7fSl9KX1mdW5jdGlvbiBjaGVja1Byb3BlcnRpZXMob2JqZWN0LHByb3BlcnRpZXMpe2lmKCFvYmplY3R8fHR5cGVvZiBvYmplY3QhPT1cIm9iamVjdFwiKXtsb2dnZXIkMy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdFwiLFwib2JqZWN0XCIsb2JqZWN0KX1PYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goa2V5PT57aWYoIXByb3BlcnRpZXNba2V5XSl7bG9nZ2VyJDMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3Qga2V5IC0gXCIra2V5LFwidHJhbnNhY3Rpb246XCIra2V5LG9iamVjdCl9fSl9ZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqZWN0KXtjb25zdCByZXN1bHQ9e307Zm9yKGNvbnN0IGtleSBpbiBvYmplY3Qpe3Jlc3VsdFtrZXldPW9iamVjdFtrZXldfXJldHVybiByZXN1bHR9Y29uc3Qgb3BhcXVlPXtiaWdpbnQ6dHJ1ZSxib29sZWFuOnRydWUsZnVuY3Rpb246dHJ1ZSxudW1iZXI6dHJ1ZSxzdHJpbmc6dHJ1ZX07ZnVuY3Rpb24gX2lzRnJvemVuKG9iamVjdCl7aWYob2JqZWN0PT09dW5kZWZpbmVkfHxvYmplY3Q9PT1udWxsfHxvcGFxdWVbdHlwZW9mIG9iamVjdF0pe3JldHVybiB0cnVlfWlmKEFycmF5LmlzQXJyYXkob2JqZWN0KXx8dHlwZW9mIG9iamVjdD09PVwib2JqZWN0XCIpe2lmKCFPYmplY3QuaXNGcm96ZW4ob2JqZWN0KSl7cmV0dXJuIGZhbHNlfWNvbnN0IGtleXM9T2JqZWN0LmtleXMob2JqZWN0KTtmb3IobGV0IGk9MDtpPGtleXMubGVuZ3RoO2krKyl7aWYoIV9pc0Zyb3plbihvYmplY3Rba2V5c1tpXV0pKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfXJldHVybiBsb2dnZXIkMy50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiBvYmplY3R9YCxcIm9iamVjdFwiLG9iamVjdCl9ZnVuY3Rpb24gX2RlZXBDb3B5KG9iamVjdCl7aWYoX2lzRnJvemVuKG9iamVjdCkpe3JldHVybiBvYmplY3R9aWYoQXJyYXkuaXNBcnJheShvYmplY3QpKXtyZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QubWFwKGl0ZW09PmRlZXBDb3B5KGl0ZW0pKSl9aWYodHlwZW9mIG9iamVjdD09PVwib2JqZWN0XCIpe2NvbnN0IHJlc3VsdD17fTtmb3IoY29uc3Qga2V5IGluIG9iamVjdCl7Y29uc3QgdmFsdWU9b2JqZWN0W2tleV07aWYodmFsdWU9PT11bmRlZmluZWQpe2NvbnRpbnVlfWRlZmluZVJlYWRPbmx5KHJlc3VsdCxrZXksZGVlcENvcHkodmFsdWUpKX1yZXR1cm4gcmVzdWx0fXJldHVybiBsb2dnZXIkMy50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiBvYmplY3R9YCxcIm9iamVjdFwiLG9iamVjdCl9ZnVuY3Rpb24gZGVlcENvcHkob2JqZWN0KXtyZXR1cm4gX2RlZXBDb3B5KG9iamVjdCl9Y2xhc3MgRGVzY3JpcHRpb257Y29uc3RydWN0b3IoaW5mbyl7Zm9yKGNvbnN0IGtleSBpbiBpbmZvKXt0aGlzW2tleV09ZGVlcENvcHkoaW5mb1trZXldKX19fWNvbnN0IHZlcnNpb24kND1cImFiaS81LjEuMlwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciQ0PW5ldyBMb2dnZXIodmVyc2lvbiQ0KTtjb25zdCBfY29uc3RydWN0b3JHdWFyZCQyPXt9O2xldCBNb2RpZmllcnNCeXRlcz17Y2FsbGRhdGE6dHJ1ZSxtZW1vcnk6dHJ1ZSxzdG9yYWdlOnRydWV9O2xldCBNb2RpZmllcnNOZXN0PXtjYWxsZGF0YTp0cnVlLG1lbW9yeTp0cnVlfTtmdW5jdGlvbiBjaGVja01vZGlmaWVyKHR5cGUsbmFtZSl7aWYodHlwZT09PVwiYnl0ZXNcInx8dHlwZT09PVwic3RyaW5nXCIpe2lmKE1vZGlmaWVyc0J5dGVzW25hbWVdKXtyZXR1cm4gdHJ1ZX19ZWxzZSBpZih0eXBlPT09XCJhZGRyZXNzXCIpe2lmKG5hbWU9PT1cInBheWFibGVcIil7cmV0dXJuIHRydWV9fWVsc2UgaWYodHlwZS5pbmRleE9mKFwiW1wiKT49MHx8dHlwZT09PVwidHVwbGVcIil7aWYoTW9kaWZpZXJzTmVzdFtuYW1lXSl7cmV0dXJuIHRydWV9fWlmKE1vZGlmaWVyc0J5dGVzW25hbWVdfHxuYW1lPT09XCJwYXlhYmxlXCIpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbW9kaWZpZXJcIixcIm5hbWVcIixuYW1lKX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gcGFyc2VQYXJhbVR5cGUocGFyYW0sYWxsb3dJbmRleGVkKXtsZXQgb3JpZ2luYWxQYXJhbT1wYXJhbTtmdW5jdGlvbiB0aHJvd0Vycm9yKGkpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gJHtpfWAsXCJwYXJhbVwiLHBhcmFtKX1wYXJhbT1wYXJhbS5yZXBsYWNlKC9cXHMvZyxcIiBcIik7ZnVuY3Rpb24gbmV3Tm9kZShwYXJlbnQpe2xldCBub2RlPXt0eXBlOlwiXCIsbmFtZTpcIlwiLHBhcmVudDpwYXJlbnQsc3RhdGU6e2FsbG93VHlwZTp0cnVlfX07aWYoYWxsb3dJbmRleGVkKXtub2RlLmluZGV4ZWQ9ZmFsc2V9cmV0dXJuIG5vZGV9bGV0IHBhcmVudD17dHlwZTpcIlwiLG5hbWU6XCJcIixzdGF0ZTp7YWxsb3dUeXBlOnRydWV9fTtsZXQgbm9kZT1wYXJlbnQ7Zm9yKGxldCBpPTA7aTxwYXJhbS5sZW5ndGg7aSsrKXtsZXQgYz1wYXJhbVtpXTtzd2l0Y2goYyl7Y2FzZVwiKFwiOmlmKG5vZGUuc3RhdGUuYWxsb3dUeXBlJiZub2RlLnR5cGU9PT1cIlwiKXtub2RlLnR5cGU9XCJ0dXBsZVwifWVsc2UgaWYoIW5vZGUuc3RhdGUuYWxsb3dQYXJhbXMpe3Rocm93RXJyb3IoaSl9bm9kZS5zdGF0ZS5hbGxvd1R5cGU9ZmFsc2U7bm9kZS50eXBlPXZlcmlmeVR5cGUobm9kZS50eXBlKTtub2RlLmNvbXBvbmVudHM9W25ld05vZGUobm9kZSldO25vZGU9bm9kZS5jb21wb25lbnRzWzBdO2JyZWFrO2Nhc2VcIilcIjpkZWxldGUgbm9kZS5zdGF0ZTtpZihub2RlLm5hbWU9PT1cImluZGV4ZWRcIil7aWYoIWFsbG93SW5kZXhlZCl7dGhyb3dFcnJvcihpKX1ub2RlLmluZGV4ZWQ9dHJ1ZTtub2RlLm5hbWU9XCJcIn1pZihjaGVja01vZGlmaWVyKG5vZGUudHlwZSxub2RlLm5hbWUpKXtub2RlLm5hbWU9XCJcIn1ub2RlLnR5cGU9dmVyaWZ5VHlwZShub2RlLnR5cGUpO2xldCBjaGlsZD1ub2RlO25vZGU9bm9kZS5wYXJlbnQ7aWYoIW5vZGUpe3Rocm93RXJyb3IoaSl9ZGVsZXRlIGNoaWxkLnBhcmVudDtub2RlLnN0YXRlLmFsbG93UGFyYW1zPWZhbHNlO25vZGUuc3RhdGUuYWxsb3dOYW1lPXRydWU7bm9kZS5zdGF0ZS5hbGxvd0FycmF5PXRydWU7YnJlYWs7Y2FzZVwiLFwiOmRlbGV0ZSBub2RlLnN0YXRlO2lmKG5vZGUubmFtZT09PVwiaW5kZXhlZFwiKXtpZighYWxsb3dJbmRleGVkKXt0aHJvd0Vycm9yKGkpfW5vZGUuaW5kZXhlZD10cnVlO25vZGUubmFtZT1cIlwifWlmKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLG5vZGUubmFtZSkpe25vZGUubmFtZT1cIlwifW5vZGUudHlwZT12ZXJpZnlUeXBlKG5vZGUudHlwZSk7bGV0IHNpYmxpbmc9bmV3Tm9kZShub2RlLnBhcmVudCk7bm9kZS5wYXJlbnQuY29tcG9uZW50cy5wdXNoKHNpYmxpbmcpO2RlbGV0ZSBub2RlLnBhcmVudDtub2RlPXNpYmxpbmc7YnJlYWs7Y2FzZVwiIFwiOmlmKG5vZGUuc3RhdGUuYWxsb3dUeXBlKXtpZihub2RlLnR5cGUhPT1cIlwiKXtub2RlLnR5cGU9dmVyaWZ5VHlwZShub2RlLnR5cGUpO2RlbGV0ZSBub2RlLnN0YXRlLmFsbG93VHlwZTtub2RlLnN0YXRlLmFsbG93TmFtZT10cnVlO25vZGUuc3RhdGUuYWxsb3dQYXJhbXM9dHJ1ZX19aWYobm9kZS5zdGF0ZS5hbGxvd05hbWUpe2lmKG5vZGUubmFtZSE9PVwiXCIpe2lmKG5vZGUubmFtZT09PVwiaW5kZXhlZFwiKXtpZighYWxsb3dJbmRleGVkKXt0aHJvd0Vycm9yKGkpfWlmKG5vZGUuaW5kZXhlZCl7dGhyb3dFcnJvcihpKX1ub2RlLmluZGV4ZWQ9dHJ1ZTtub2RlLm5hbWU9XCJcIn1lbHNlIGlmKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLG5vZGUubmFtZSkpe25vZGUubmFtZT1cIlwifWVsc2V7bm9kZS5zdGF0ZS5hbGxvd05hbWU9ZmFsc2V9fX1icmVhaztjYXNlXCJbXCI6aWYoIW5vZGUuc3RhdGUuYWxsb3dBcnJheSl7dGhyb3dFcnJvcihpKX1ub2RlLnR5cGUrPWM7bm9kZS5zdGF0ZS5hbGxvd0FycmF5PWZhbHNlO25vZGUuc3RhdGUuYWxsb3dOYW1lPWZhbHNlO25vZGUuc3RhdGUucmVhZEFycmF5PXRydWU7YnJlYWs7Y2FzZVwiXVwiOmlmKCFub2RlLnN0YXRlLnJlYWRBcnJheSl7dGhyb3dFcnJvcihpKX1ub2RlLnR5cGUrPWM7bm9kZS5zdGF0ZS5yZWFkQXJyYXk9ZmFsc2U7bm9kZS5zdGF0ZS5hbGxvd0FycmF5PXRydWU7bm9kZS5zdGF0ZS5hbGxvd05hbWU9dHJ1ZTticmVhaztkZWZhdWx0OmlmKG5vZGUuc3RhdGUuYWxsb3dUeXBlKXtub2RlLnR5cGUrPWM7bm9kZS5zdGF0ZS5hbGxvd1BhcmFtcz10cnVlO25vZGUuc3RhdGUuYWxsb3dBcnJheT10cnVlfWVsc2UgaWYobm9kZS5zdGF0ZS5hbGxvd05hbWUpe25vZGUubmFtZSs9YztkZWxldGUgbm9kZS5zdGF0ZS5hbGxvd0FycmF5fWVsc2UgaWYobm9kZS5zdGF0ZS5yZWFkQXJyYXkpe25vZGUudHlwZSs9Y31lbHNle3Rocm93RXJyb3IoaSl9fX1pZihub2RlLnBhcmVudCl7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCBlb2ZcIixcInBhcmFtXCIscGFyYW0pfWRlbGV0ZSBwYXJlbnQuc3RhdGU7aWYobm9kZS5uYW1lPT09XCJpbmRleGVkXCIpe2lmKCFhbGxvd0luZGV4ZWQpe3Rocm93RXJyb3Iob3JpZ2luYWxQYXJhbS5sZW5ndGgtNyl9aWYobm9kZS5pbmRleGVkKXt0aHJvd0Vycm9yKG9yaWdpbmFsUGFyYW0ubGVuZ3RoLTcpfW5vZGUuaW5kZXhlZD10cnVlO25vZGUubmFtZT1cIlwifWVsc2UgaWYoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsbm9kZS5uYW1lKSl7bm9kZS5uYW1lPVwiXCJ9cGFyZW50LnR5cGU9dmVyaWZ5VHlwZShwYXJlbnQudHlwZSk7cmV0dXJuIHBhcmVudH1mdW5jdGlvbiBwb3B1bGF0ZShvYmplY3QscGFyYW1zKXtmb3IobGV0IGtleSBpbiBwYXJhbXMpe2RlZmluZVJlYWRPbmx5KG9iamVjdCxrZXkscGFyYW1zW2tleV0pfX1jb25zdCBGb3JtYXRUeXBlcz1PYmplY3QuZnJlZXplKHtzaWdoYXNoOlwic2lnaGFzaFwiLG1pbmltYWw6XCJtaW5pbWFsXCIsZnVsbDpcImZ1bGxcIixqc29uOlwianNvblwifSk7Y29uc3QgcGFyYW1UeXBlQXJyYXk9bmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtjbGFzcyBQYXJhbVR5cGV7Y29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCxwYXJhbXMpe2lmKGNvbnN0cnVjdG9yR3VhcmQhPT1fY29uc3RydWN0b3JHdWFyZCQyKXtsb2dnZXIkNC50aHJvd0Vycm9yKFwidXNlIGZyb21TdHJpbmdcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwibmV3IFBhcmFtVHlwZSgpXCJ9KX1wb3B1bGF0ZSh0aGlzLHBhcmFtcyk7bGV0IG1hdGNoPXRoaXMudHlwZS5tYXRjaChwYXJhbVR5cGVBcnJheSk7aWYobWF0Y2gpe3BvcHVsYXRlKHRoaXMse2FycmF5TGVuZ3RoOnBhcnNlSW50KG1hdGNoWzJdfHxcIi0xXCIpLGFycmF5Q2hpbGRyZW46UGFyYW1UeXBlLmZyb21PYmplY3Qoe3R5cGU6bWF0Y2hbMV0sY29tcG9uZW50czp0aGlzLmNvbXBvbmVudHN9KSxiYXNlVHlwZTpcImFycmF5XCJ9KX1lbHNle3BvcHVsYXRlKHRoaXMse2FycmF5TGVuZ3RoOm51bGwsYXJyYXlDaGlsZHJlbjpudWxsLGJhc2VUeXBlOnRoaXMuY29tcG9uZW50cyE9bnVsbD9cInR1cGxlXCI6dGhpcy50eXBlfSl9dGhpcy5faXNQYXJhbVR5cGU9dHJ1ZTtPYmplY3QuZnJlZXplKHRoaXMpfWZvcm1hdChmb3JtYXQpe2lmKCFmb3JtYXQpe2Zvcm1hdD1Gb3JtYXRUeXBlcy5zaWdoYXNofWlmKCFGb3JtYXRUeXBlc1tmb3JtYXRdKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsXCJmb3JtYXRcIixmb3JtYXQpfWlmKGZvcm1hdD09PUZvcm1hdFR5cGVzLmpzb24pe2xldCByZXN1bHQ9e3R5cGU6dGhpcy5iYXNlVHlwZT09PVwidHVwbGVcIj9cInR1cGxlXCI6dGhpcy50eXBlLG5hbWU6dGhpcy5uYW1lfHx1bmRlZmluZWR9O2lmKHR5cGVvZiB0aGlzLmluZGV4ZWQ9PT1cImJvb2xlYW5cIil7cmVzdWx0LmluZGV4ZWQ9dGhpcy5pbmRleGVkfWlmKHRoaXMuY29tcG9uZW50cyl7cmVzdWx0LmNvbXBvbmVudHM9dGhpcy5jb21wb25lbnRzLm1hcChjb21wPT5KU09OLnBhcnNlKGNvbXAuZm9ybWF0KGZvcm1hdCkpKX1yZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KX1sZXQgcmVzdWx0PVwiXCI7aWYodGhpcy5iYXNlVHlwZT09PVwiYXJyYXlcIil7cmVzdWx0Kz10aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KGZvcm1hdCk7cmVzdWx0Kz1cIltcIisodGhpcy5hcnJheUxlbmd0aDwwP1wiXCI6U3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKStcIl1cIn1lbHNle2lmKHRoaXMuYmFzZVR5cGU9PT1cInR1cGxlXCIpe2lmKGZvcm1hdCE9PUZvcm1hdFR5cGVzLnNpZ2hhc2gpe3Jlc3VsdCs9dGhpcy50eXBlfXJlc3VsdCs9XCIoXCIrdGhpcy5jb21wb25lbnRzLm1hcChjb21wPT5jb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKGZvcm1hdD09PUZvcm1hdFR5cGVzLmZ1bGw/XCIsIFwiOlwiLFwiKStcIilcIn1lbHNle3Jlc3VsdCs9dGhpcy50eXBlfX1pZihmb3JtYXQhPT1Gb3JtYXRUeXBlcy5zaWdoYXNoKXtpZih0aGlzLmluZGV4ZWQ9PT10cnVlKXtyZXN1bHQrPVwiIGluZGV4ZWRcIn1pZihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5mdWxsJiZ0aGlzLm5hbWUpe3Jlc3VsdCs9XCIgXCIrdGhpcy5uYW1lfX1yZXR1cm4gcmVzdWx0fXN0YXRpYyBmcm9tKHZhbHVlLGFsbG93SW5kZXhlZCl7aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7cmV0dXJuIFBhcmFtVHlwZS5mcm9tU3RyaW5nKHZhbHVlLGFsbG93SW5kZXhlZCl9cmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHZhbHVlKX1zdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSl7aWYoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKHZhbHVlKSl7cmV0dXJuIHZhbHVlfXJldHVybiBuZXcgUGFyYW1UeXBlKF9jb25zdHJ1Y3Rvckd1YXJkJDIse25hbWU6dmFsdWUubmFtZXx8bnVsbCx0eXBlOnZlcmlmeVR5cGUodmFsdWUudHlwZSksaW5kZXhlZDp2YWx1ZS5pbmRleGVkPT1udWxsP251bGw6ISF2YWx1ZS5pbmRleGVkLGNvbXBvbmVudHM6dmFsdWUuY29tcG9uZW50cz92YWx1ZS5jb21wb25lbnRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCk6bnVsbH0pfXN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLGFsbG93SW5kZXhlZCl7ZnVuY3Rpb24gUGFyYW1UeXBpZnkobm9kZSl7cmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtuYW1lOm5vZGUubmFtZSx0eXBlOm5vZGUudHlwZSxpbmRleGVkOm5vZGUuaW5kZXhlZCxjb21wb25lbnRzOm5vZGUuY29tcG9uZW50c30pfXJldHVybiBQYXJhbVR5cGlmeShwYXJzZVBhcmFtVHlwZSh2YWx1ZSwhIWFsbG93SW5kZXhlZCkpfXN0YXRpYyBpc1BhcmFtVHlwZSh2YWx1ZSl7cmV0dXJuISEodmFsdWUhPW51bGwmJnZhbHVlLl9pc1BhcmFtVHlwZSl9fWZ1bmN0aW9uIHBhcnNlUGFyYW1zKHZhbHVlLGFsbG93SW5kZXgpe3JldHVybiBzcGxpdE5lc3RpbmcodmFsdWUpLm1hcChwYXJhbT0+UGFyYW1UeXBlLmZyb21TdHJpbmcocGFyYW0sYWxsb3dJbmRleCkpfWNsYXNzIEZyYWdtZW50e2NvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQscGFyYW1zKXtpZihjb25zdHJ1Y3Rvckd1YXJkIT09X2NvbnN0cnVjdG9yR3VhcmQkMil7bG9nZ2VyJDQudGhyb3dFcnJvcihcInVzZSBhIHN0YXRpYyBmcm9tIG1ldGhvZFwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJuZXcgRnJhZ21lbnQoKVwifSl9cG9wdWxhdGUodGhpcyxwYXJhbXMpO3RoaXMuX2lzRnJhZ21lbnQ9dHJ1ZTtPYmplY3QuZnJlZXplKHRoaXMpfXN0YXRpYyBmcm9tKHZhbHVlKXtpZihGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKSl7cmV0dXJuIHZhbHVlfWlmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe3JldHVybiBGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKX1yZXR1cm4gRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSl9c3RhdGljIGZyb21PYmplY3QodmFsdWUpe2lmKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKXtyZXR1cm4gdmFsdWV9c3dpdGNoKHZhbHVlLnR5cGUpe2Nhc2VcImZ1bmN0aW9uXCI6cmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7Y2FzZVwiZXZlbnRcIjpyZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtjYXNlXCJjb25zdHJ1Y3RvclwiOnJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO2Nhc2VcImVycm9yXCI6Y2FzZVwiZmFsbGJhY2tcIjpjYXNlXCJyZWNlaXZlXCI6cmV0dXJuIG51bGx9cmV0dXJuIGxvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnJhZ21lbnQgb2JqZWN0XCIsXCJ2YWx1ZVwiLHZhbHVlKX1zdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSl7dmFsdWU9dmFsdWUucmVwbGFjZSgvXFxzL2csXCIgXCIpO3ZhbHVlPXZhbHVlLnJlcGxhY2UoL1xcKC9nLFwiIChcIikucmVwbGFjZSgvXFwpL2csXCIpIFwiKS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpO3ZhbHVlPXZhbHVlLnRyaW0oKTtpZih2YWx1ZS5zcGxpdChcIiBcIilbMF09PT1cImV2ZW50XCIpe3JldHVybiBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDUpLnRyaW0oKSl9ZWxzZSBpZih2YWx1ZS5zcGxpdChcIiBcIilbMF09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDgpLnRyaW0oKSl9ZWxzZSBpZih2YWx1ZS5zcGxpdChcIihcIilbMF0udHJpbSgpPT09XCJjb25zdHJ1Y3RvclwiKXtyZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnRyaW0oKSl9cmV0dXJuIGxvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGZyYWdtZW50XCIsXCJ2YWx1ZVwiLHZhbHVlKX1zdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSl7cmV0dXJuISEodmFsdWUmJnZhbHVlLl9pc0ZyYWdtZW50KX19Y2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50e2Zvcm1hdChmb3JtYXQpe2lmKCFmb3JtYXQpe2Zvcm1hdD1Gb3JtYXRUeXBlcy5zaWdoYXNofWlmKCFGb3JtYXRUeXBlc1tmb3JtYXRdKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsXCJmb3JtYXRcIixmb3JtYXQpfWlmKGZvcm1hdD09PUZvcm1hdFR5cGVzLmpzb24pe3JldHVybiBKU09OLnN0cmluZ2lmeSh7dHlwZTpcImV2ZW50XCIsYW5vbnltb3VzOnRoaXMuYW5vbnltb3VzLG5hbWU6dGhpcy5uYW1lLGlucHV0czp0aGlzLmlucHV0cy5tYXAoaW5wdXQ9PkpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKX0pfWxldCByZXN1bHQ9XCJcIjtpZihmb3JtYXQhPT1Gb3JtYXRUeXBlcy5zaWdoYXNoKXtyZXN1bHQrPVwiZXZlbnQgXCJ9cmVzdWx0Kz10aGlzLm5hbWUrXCIoXCIrdGhpcy5pbnB1dHMubWFwKGlucHV0PT5pbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5mdWxsP1wiLCBcIjpcIixcIikrXCIpIFwiO2lmKGZvcm1hdCE9PUZvcm1hdFR5cGVzLnNpZ2hhc2gpe2lmKHRoaXMuYW5vbnltb3VzKXtyZXN1bHQrPVwiYW5vbnltb3VzIFwifX1yZXR1cm4gcmVzdWx0LnRyaW0oKX1zdGF0aWMgZnJvbSh2YWx1ZSl7aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7cmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSl9cmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSl9c3RhdGljIGZyb21PYmplY3QodmFsdWUpe2lmKEV2ZW50RnJhZ21lbnQuaXNFdmVudEZyYWdtZW50KHZhbHVlKSl7cmV0dXJuIHZhbHVlfWlmKHZhbHVlLnR5cGUhPT1cImV2ZW50XCIpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXZlbnQgb2JqZWN0XCIsXCJ2YWx1ZVwiLHZhbHVlKX1jb25zdCBwYXJhbXM9e25hbWU6dmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxhbm9ueW1vdXM6dmFsdWUuYW5vbnltb3VzLGlucHV0czp2YWx1ZS5pbnB1dHM/dmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCk6W10sdHlwZTpcImV2ZW50XCJ9O3JldHVybiBuZXcgRXZlbnRGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCQyLHBhcmFtcyl9c3RhdGljIGZyb21TdHJpbmcodmFsdWUpe2xldCBtYXRjaD12YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtpZighbWF0Y2gpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXZlbnQgc3RyaW5nXCIsXCJ2YWx1ZVwiLHZhbHVlKX1sZXQgYW5vbnltb3VzPWZhbHNlO21hdGNoWzNdLnNwbGl0KFwiIFwiKS5mb3JFYWNoKG1vZGlmaWVyPT57c3dpdGNoKG1vZGlmaWVyLnRyaW0oKSl7Y2FzZVwiYW5vbnltb3VzXCI6YW5vbnltb3VzPXRydWU7YnJlYWs7Y2FzZVwiXCI6YnJlYWs7ZGVmYXVsdDpsb2dnZXIkNC53YXJuKFwidW5rbm93biBtb2RpZmllcjogXCIrbW9kaWZpZXIpfX0pO3JldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3Qoe25hbWU6bWF0Y2hbMV0udHJpbSgpLGFub255bW91czphbm9ueW1vdXMsaW5wdXRzOnBhcnNlUGFyYW1zKG1hdGNoWzJdLHRydWUpLHR5cGU6XCJldmVudFwifSl9c3RhdGljIGlzRXZlbnRGcmFnbWVudCh2YWx1ZSl7cmV0dXJuIHZhbHVlJiZ2YWx1ZS5faXNGcmFnbWVudCYmdmFsdWUudHlwZT09PVwiZXZlbnRcIn19ZnVuY3Rpb24gcGFyc2VHYXModmFsdWUscGFyYW1zKXtwYXJhbXMuZ2FzPW51bGw7bGV0IGNvbXBzPXZhbHVlLnNwbGl0KFwiQFwiKTtpZihjb21wcy5sZW5ndGghPT0xKXtpZihjb21wcy5sZW5ndGg+Mil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBodW1hbi1yZWFkYWJsZSBBQkkgc2lnbmF0dXJlXCIsXCJ2YWx1ZVwiLHZhbHVlKX1pZighY29tcHNbMV0ubWF0Y2goL15bMC05XSskLykpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZSBnYXNcIixcInZhbHVlXCIsdmFsdWUpfXBhcmFtcy5nYXM9QmlnTnVtYmVyLmZyb20oY29tcHNbMV0pO3JldHVybiBjb21wc1swXX1yZXR1cm4gdmFsdWV9ZnVuY3Rpb24gcGFyc2VNb2RpZmllcnModmFsdWUscGFyYW1zKXtwYXJhbXMuY29uc3RhbnQ9ZmFsc2U7cGFyYW1zLnBheWFibGU9ZmFsc2U7cGFyYW1zLnN0YXRlTXV0YWJpbGl0eT1cIm5vbnBheWFibGVcIjt2YWx1ZS5zcGxpdChcIiBcIikuZm9yRWFjaChtb2RpZmllcj0+e3N3aXRjaChtb2RpZmllci50cmltKCkpe2Nhc2VcImNvbnN0YW50XCI6cGFyYW1zLmNvbnN0YW50PXRydWU7YnJlYWs7Y2FzZVwicGF5YWJsZVwiOnBhcmFtcy5wYXlhYmxlPXRydWU7cGFyYW1zLnN0YXRlTXV0YWJpbGl0eT1cInBheWFibGVcIjticmVhaztjYXNlXCJub25wYXlhYmxlXCI6cGFyYW1zLnBheWFibGU9ZmFsc2U7cGFyYW1zLnN0YXRlTXV0YWJpbGl0eT1cIm5vbnBheWFibGVcIjticmVhaztjYXNlXCJwdXJlXCI6cGFyYW1zLmNvbnN0YW50PXRydWU7cGFyYW1zLnN0YXRlTXV0YWJpbGl0eT1cInB1cmVcIjticmVhaztjYXNlXCJ2aWV3XCI6cGFyYW1zLmNvbnN0YW50PXRydWU7cGFyYW1zLnN0YXRlTXV0YWJpbGl0eT1cInZpZXdcIjticmVhaztjYXNlXCJleHRlcm5hbFwiOmNhc2VcInB1YmxpY1wiOmNhc2VcIlwiOmJyZWFrO2RlZmF1bHQ6Y29uc29sZS5sb2coXCJ1bmtub3duIG1vZGlmaWVyOiBcIittb2RpZmllcil9fSl9ZnVuY3Rpb24gdmVyaWZ5U3RhdGUodmFsdWUpe2xldCByZXN1bHQ9e2NvbnN0YW50OmZhbHNlLHBheWFibGU6dHJ1ZSxzdGF0ZU11dGFiaWxpdHk6XCJwYXlhYmxlXCJ9O2lmKHZhbHVlLnN0YXRlTXV0YWJpbGl0eSE9bnVsbCl7cmVzdWx0LnN0YXRlTXV0YWJpbGl0eT12YWx1ZS5zdGF0ZU11dGFiaWxpdHk7cmVzdWx0LmNvbnN0YW50PXJlc3VsdC5zdGF0ZU11dGFiaWxpdHk9PT1cInZpZXdcInx8cmVzdWx0LnN0YXRlTXV0YWJpbGl0eT09PVwicHVyZVwiO2lmKHZhbHVlLmNvbnN0YW50IT1udWxsKXtpZighIXZhbHVlLmNvbnN0YW50IT09cmVzdWx0LmNvbnN0YW50KXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIrcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSxcInZhbHVlXCIsdmFsdWUpfX1yZXN1bHQucGF5YWJsZT1yZXN1bHQuc3RhdGVNdXRhYmlsaXR5PT09XCJwYXlhYmxlXCI7aWYodmFsdWUucGF5YWJsZSE9bnVsbCl7aWYoISF2YWx1ZS5wYXlhYmxlIT09cmVzdWx0LnBheWFibGUpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIHBheWFibGUgZnVuY3Rpb24gd2l0aCBtdXRhYmlsaXR5IFwiK3Jlc3VsdC5zdGF0ZU11dGFiaWxpdHksXCJ2YWx1ZVwiLHZhbHVlKX19fWVsc2UgaWYodmFsdWUucGF5YWJsZSE9bnVsbCl7cmVzdWx0LnBheWFibGU9ISF2YWx1ZS5wYXlhYmxlO2lmKHZhbHVlLmNvbnN0YW50PT1udWxsJiYhcmVzdWx0LnBheWFibGUmJnZhbHVlLnR5cGUhPT1cImNvbnN0cnVjdG9yXCIpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsXCJ2YWx1ZVwiLHZhbHVlKX1yZXN1bHQuY29uc3RhbnQ9ISF2YWx1ZS5jb25zdGFudDtpZihyZXN1bHQuY29uc3RhbnQpe3Jlc3VsdC5zdGF0ZU11dGFiaWxpdHk9XCJ2aWV3XCJ9ZWxzZXtyZXN1bHQuc3RhdGVNdXRhYmlsaXR5PXJlc3VsdC5wYXlhYmxlP1wicGF5YWJsZVwiOlwibm9ucGF5YWJsZVwifWlmKHJlc3VsdC5wYXlhYmxlJiZyZXN1bHQuY29uc3RhbnQpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IHBheWFibGUgZnVuY3Rpb25cIixcInZhbHVlXCIsdmFsdWUpfX1lbHNlIGlmKHZhbHVlLmNvbnN0YW50IT1udWxsKXtyZXN1bHQuY29uc3RhbnQ9ISF2YWx1ZS5jb25zdGFudDtyZXN1bHQucGF5YWJsZT0hcmVzdWx0LmNvbnN0YW50O3Jlc3VsdC5zdGF0ZU11dGFiaWxpdHk9cmVzdWx0LmNvbnN0YW50P1widmlld1wiOlwicGF5YWJsZVwifWVsc2UgaWYodmFsdWUudHlwZSE9PVwiY29uc3RydWN0b3JcIil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwidW5hYmxlIHRvIGRldGVybWluZSBzdGF0ZU11dGFiaWxpdHlcIixcInZhbHVlXCIsdmFsdWUpfXJldHVybiByZXN1bHR9Y2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50e2Zvcm1hdChmb3JtYXQpe2lmKCFmb3JtYXQpe2Zvcm1hdD1Gb3JtYXRUeXBlcy5zaWdoYXNofWlmKCFGb3JtYXRUeXBlc1tmb3JtYXRdKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsXCJmb3JtYXRcIixmb3JtYXQpfWlmKGZvcm1hdD09PUZvcm1hdFR5cGVzLmpzb24pe3JldHVybiBKU09OLnN0cmluZ2lmeSh7dHlwZTpcImNvbnN0cnVjdG9yXCIsc3RhdGVNdXRhYmlsaXR5OnRoaXMuc3RhdGVNdXRhYmlsaXR5IT09XCJub25wYXlhYmxlXCI/dGhpcy5zdGF0ZU11dGFiaWxpdHk6dW5kZWZpbmVkLHBheWFibGU6dGhpcy5wYXlhYmxlLGdhczp0aGlzLmdhcz90aGlzLmdhcy50b051bWJlcigpOnVuZGVmaW5lZCxpbnB1dHM6dGhpcy5pbnB1dHMubWFwKGlucHV0PT5KU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSl9KX1pZihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5zaWdoYXNoKXtsb2dnZXIkNC50aHJvd0Vycm9yKFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImZvcm1hdChzaWdoYXNoKVwifSl9bGV0IHJlc3VsdD1cImNvbnN0cnVjdG9yKFwiK3RoaXMuaW5wdXRzLm1hcChpbnB1dD0+aW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oZm9ybWF0PT09Rm9ybWF0VHlwZXMuZnVsbD9cIiwgXCI6XCIsXCIpK1wiKSBcIjtpZih0aGlzLnN0YXRlTXV0YWJpbGl0eSYmdGhpcy5zdGF0ZU11dGFiaWxpdHkhPT1cIm5vbnBheWFibGVcIil7cmVzdWx0Kz10aGlzLnN0YXRlTXV0YWJpbGl0eStcIiBcIn1yZXR1cm4gcmVzdWx0LnRyaW0oKX1zdGF0aWMgZnJvbSh2YWx1ZSl7aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7cmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSl9cmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSl9c3RhdGljIGZyb21PYmplY3QodmFsdWUpe2lmKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSl7cmV0dXJuIHZhbHVlfWlmKHZhbHVlLnR5cGUhPT1cImNvbnN0cnVjdG9yXCIpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igb2JqZWN0XCIsXCJ2YWx1ZVwiLHZhbHVlKX1sZXQgc3RhdGU9dmVyaWZ5U3RhdGUodmFsdWUpO2lmKHN0YXRlLmNvbnN0YW50KXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY29uc3RhbnRcIixcInZhbHVlXCIsdmFsdWUpfWNvbnN0IHBhcmFtcz17bmFtZTpudWxsLHR5cGU6dmFsdWUudHlwZSxpbnB1dHM6dmFsdWUuaW5wdXRzP3ZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpOltdLHBheWFibGU6c3RhdGUucGF5YWJsZSxzdGF0ZU11dGFiaWxpdHk6c3RhdGUuc3RhdGVNdXRhYmlsaXR5LGdhczp2YWx1ZS5nYXM/QmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKTpudWxsfTtyZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQkMixwYXJhbXMpfXN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKXtsZXQgcGFyYW1zPXt0eXBlOlwiY29uc3RydWN0b3JcIn07dmFsdWU9cGFyc2VHYXModmFsdWUscGFyYW1zKTtsZXQgcGFyZW5zPXZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO2lmKCFwYXJlbnN8fHBhcmVuc1sxXS50cmltKCkhPT1cImNvbnN0cnVjdG9yXCIpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igc3RyaW5nXCIsXCJ2YWx1ZVwiLHZhbHVlKX1wYXJhbXMuaW5wdXRzPXBhcnNlUGFyYW1zKHBhcmVuc1syXS50cmltKCksZmFsc2UpO3BhcnNlTW9kaWZpZXJzKHBhcmVuc1szXS50cmltKCkscGFyYW1zKTtyZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyl9c3RhdGljIGlzQ29uc3RydWN0b3JGcmFnbWVudCh2YWx1ZSl7cmV0dXJuIHZhbHVlJiZ2YWx1ZS5faXNGcmFnbWVudCYmdmFsdWUudHlwZT09PVwiY29uc3RydWN0b3JcIn19Y2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIENvbnN0cnVjdG9yRnJhZ21lbnR7Zm9ybWF0KGZvcm1hdCl7aWYoIWZvcm1hdCl7Zm9ybWF0PUZvcm1hdFR5cGVzLnNpZ2hhc2h9aWYoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIixcImZvcm1hdFwiLGZvcm1hdCl9aWYoZm9ybWF0PT09Rm9ybWF0VHlwZXMuanNvbil7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt0eXBlOlwiZnVuY3Rpb25cIixuYW1lOnRoaXMubmFtZSxjb25zdGFudDp0aGlzLmNvbnN0YW50LHN0YXRlTXV0YWJpbGl0eTp0aGlzLnN0YXRlTXV0YWJpbGl0eSE9PVwibm9ucGF5YWJsZVwiP3RoaXMuc3RhdGVNdXRhYmlsaXR5OnVuZGVmaW5lZCxwYXlhYmxlOnRoaXMucGF5YWJsZSxnYXM6dGhpcy5nYXM/dGhpcy5nYXMudG9OdW1iZXIoKTp1bmRlZmluZWQsaW5wdXRzOnRoaXMuaW5wdXRzLm1hcChpbnB1dD0+SlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLG91dHB1dHM6dGhpcy5vdXRwdXRzLm1hcChvdXRwdXQ9PkpTT04ucGFyc2Uob3V0cHV0LmZvcm1hdChmb3JtYXQpKSl9KX1sZXQgcmVzdWx0PVwiXCI7aWYoZm9ybWF0IT09Rm9ybWF0VHlwZXMuc2lnaGFzaCl7cmVzdWx0Kz1cImZ1bmN0aW9uIFwifXJlc3VsdCs9dGhpcy5uYW1lK1wiKFwiK3RoaXMuaW5wdXRzLm1hcChpbnB1dD0+aW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oZm9ybWF0PT09Rm9ybWF0VHlwZXMuZnVsbD9cIiwgXCI6XCIsXCIpK1wiKSBcIjtpZihmb3JtYXQhPT1Gb3JtYXRUeXBlcy5zaWdoYXNoKXtpZih0aGlzLnN0YXRlTXV0YWJpbGl0eSl7aWYodGhpcy5zdGF0ZU11dGFiaWxpdHkhPT1cIm5vbnBheWFibGVcIil7cmVzdWx0Kz10aGlzLnN0YXRlTXV0YWJpbGl0eStcIiBcIn19ZWxzZSBpZih0aGlzLmNvbnN0YW50KXtyZXN1bHQrPVwidmlldyBcIn1pZih0aGlzLm91dHB1dHMmJnRoaXMub3V0cHV0cy5sZW5ndGgpe3Jlc3VsdCs9XCJyZXR1cm5zIChcIit0aGlzLm91dHB1dHMubWFwKG91dHB1dD0+b3V0cHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKFwiLCBcIikrXCIpIFwifWlmKHRoaXMuZ2FzIT1udWxsKXtyZXN1bHQrPVwiQFwiK3RoaXMuZ2FzLnRvU3RyaW5nKCkrXCIgXCJ9fXJldHVybiByZXN1bHQudHJpbSgpfXN0YXRpYyBmcm9tKHZhbHVlKXtpZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtyZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKX1yZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKX1zdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSl7aWYoRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQodmFsdWUpKXtyZXR1cm4gdmFsdWV9aWYodmFsdWUudHlwZSE9PVwiZnVuY3Rpb25cIil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBvYmplY3RcIixcInZhbHVlXCIsdmFsdWUpfWxldCBzdGF0ZT12ZXJpZnlTdGF0ZSh2YWx1ZSk7Y29uc3QgcGFyYW1zPXt0eXBlOnZhbHVlLnR5cGUsbmFtZTp2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLGNvbnN0YW50OnN0YXRlLmNvbnN0YW50LGlucHV0czp2YWx1ZS5pbnB1dHM/dmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCk6W10sb3V0cHV0czp2YWx1ZS5vdXRwdXRzP3ZhbHVlLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KTpbXSxwYXlhYmxlOnN0YXRlLnBheWFibGUsc3RhdGVNdXRhYmlsaXR5OnN0YXRlLnN0YXRlTXV0YWJpbGl0eSxnYXM6dmFsdWUuZ2FzP0JpZ051bWJlci5mcm9tKHZhbHVlLmdhcyk6bnVsbH07cmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkJDIscGFyYW1zKX1zdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSl7bGV0IHBhcmFtcz17dHlwZTpcImZ1bmN0aW9uXCJ9O3ZhbHVlPXBhcnNlR2FzKHZhbHVlLHBhcmFtcyk7bGV0IGNvbXBzPXZhbHVlLnNwbGl0KFwiIHJldHVybnMgXCIpO2lmKGNvbXBzLmxlbmd0aD4yKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIHN0cmluZ1wiLFwidmFsdWVcIix2YWx1ZSl9bGV0IHBhcmVucz1jb21wc1swXS5tYXRjaChyZWdleFBhcmVuKTtpZighcGFyZW5zKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIHNpZ25hdHVyZVwiLFwidmFsdWVcIix2YWx1ZSl9cGFyYW1zLm5hbWU9cGFyZW5zWzFdLnRyaW0oKTtpZihwYXJhbXMubmFtZSl7dmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSl9cGFyYW1zLmlucHV0cz1wYXJzZVBhcmFtcyhwYXJlbnNbMl0sZmFsc2UpO3BhcnNlTW9kaWZpZXJzKHBhcmVuc1szXS50cmltKCkscGFyYW1zKTtpZihjb21wcy5sZW5ndGg+MSl7bGV0IHJldHVybnM9Y29tcHNbMV0ubWF0Y2gocmVnZXhQYXJlbik7aWYocmV0dXJuc1sxXS50cmltKCkhPVwiXCJ8fHJldHVybnNbM10udHJpbSgpIT1cIlwiKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIHRva2Vuc1wiLFwidmFsdWVcIix2YWx1ZSl9cGFyYW1zLm91dHB1dHM9cGFyc2VQYXJhbXMocmV0dXJuc1syXSxmYWxzZSl9ZWxzZXtwYXJhbXMub3V0cHV0cz1bXX1yZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyl9c3RhdGljIGlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSl7cmV0dXJuIHZhbHVlJiZ2YWx1ZS5faXNGcmFnbWVudCYmdmFsdWUudHlwZT09PVwiZnVuY3Rpb25cIn19ZnVuY3Rpb24gdmVyaWZ5VHlwZSh0eXBlKXtpZih0eXBlLm1hdGNoKC9edWludCgkfFteMS05XSkvKSl7dHlwZT1cInVpbnQyNTZcIit0eXBlLnN1YnN0cmluZyg0KX1lbHNlIGlmKHR5cGUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykpe3R5cGU9XCJpbnQyNTZcIit0eXBlLnN1YnN0cmluZygzKX1yZXR1cm4gdHlwZX1jb25zdCByZWdleElkZW50aWZpZXI9bmV3IFJlZ0V4cChcIl5bQS1aYS16X11bQS1aYS16MC05X10qJFwiKTtmdW5jdGlvbiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlKXtpZighdmFsdWV8fCF2YWx1ZS5tYXRjaChyZWdleElkZW50aWZpZXIpKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgaWRlbnRpZmllciBcIiR7dmFsdWV9XCJgLFwidmFsdWVcIix2YWx1ZSl9cmV0dXJuIHZhbHVlfWNvbnN0IHJlZ2V4UGFyZW49bmV3IFJlZ0V4cChcIl4oW14pKF0qKVxcXFwoKC4qKVxcXFwpKFteKShdKikkXCIpO2Z1bmN0aW9uIHNwbGl0TmVzdGluZyh2YWx1ZSl7dmFsdWU9dmFsdWUudHJpbSgpO2xldCByZXN1bHQ9W107bGV0IGFjY3VtPVwiXCI7bGV0IGRlcHRoPTA7Zm9yKGxldCBvZmZzZXQ9MDtvZmZzZXQ8dmFsdWUubGVuZ3RoO29mZnNldCsrKXtsZXQgYz12YWx1ZVtvZmZzZXRdO2lmKGM9PT1cIixcIiYmZGVwdGg9PT0wKXtyZXN1bHQucHVzaChhY2N1bSk7YWNjdW09XCJcIn1lbHNle2FjY3VtKz1jO2lmKGM9PT1cIihcIil7ZGVwdGgrK31lbHNlIGlmKGM9PT1cIilcIil7ZGVwdGgtLTtpZihkZXB0aD09PS0xKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhlc2lzXCIsXCJ2YWx1ZVwiLHZhbHVlKX19fX1pZihhY2N1bSl7cmVzdWx0LnB1c2goYWNjdW0pfXJldHVybiByZXN1bHR9XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJDU9bmV3IExvZ2dlcih2ZXJzaW9uJDQpO2Z1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCl7Y29uc3QgZXJyb3JzPVtdO2NvbnN0IGNoZWNrRXJyb3JzPWZ1bmN0aW9uKHBhdGgsb2JqZWN0KXtpZighQXJyYXkuaXNBcnJheShvYmplY3QpKXtyZXR1cm59Zm9yKGxldCBrZXkgaW4gb2JqZWN0KXtjb25zdCBjaGlsZFBhdGg9cGF0aC5zbGljZSgpO2NoaWxkUGF0aC5wdXNoKGtleSk7dHJ5e2NoZWNrRXJyb3JzKGNoaWxkUGF0aCxvYmplY3Rba2V5XSl9Y2F0Y2goZXJyb3Ipe2Vycm9ycy5wdXNoKHtwYXRoOmNoaWxkUGF0aCxlcnJvcjplcnJvcn0pfX19O2NoZWNrRXJyb3JzKFtdLHJlc3VsdCk7cmV0dXJuIGVycm9yc31jbGFzcyBDb2Rlcntjb25zdHJ1Y3RvcihuYW1lLHR5cGUsbG9jYWxOYW1lLGR5bmFtaWMpe3RoaXMubmFtZT1uYW1lO3RoaXMudHlwZT10eXBlO3RoaXMubG9jYWxOYW1lPWxvY2FsTmFtZTt0aGlzLmR5bmFtaWM9ZHluYW1pY31fdGhyb3dFcnJvcihtZXNzYWdlLHZhbHVlKXtsb2dnZXIkNS50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSx0aGlzLmxvY2FsTmFtZSx2YWx1ZSl9fWNsYXNzIFdyaXRlcntjb25zdHJ1Y3Rvcih3b3JkU2l6ZSl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIndvcmRTaXplXCIsd29yZFNpemV8fDMyKTt0aGlzLl9kYXRhPVtdO3RoaXMuX2RhdGFMZW5ndGg9MDt0aGlzLl9wYWRkaW5nPW5ldyBVaW50OEFycmF5KHdvcmRTaXplKX1nZXQgZGF0YSgpe3JldHVybiBoZXhDb25jYXQodGhpcy5fZGF0YSl9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9kYXRhTGVuZ3RofV93cml0ZURhdGEoZGF0YSl7dGhpcy5fZGF0YS5wdXNoKGRhdGEpO3RoaXMuX2RhdGFMZW5ndGgrPWRhdGEubGVuZ3RoO3JldHVybiBkYXRhLmxlbmd0aH1hcHBlbmRXcml0ZXIod3JpdGVyKXtyZXR1cm4gdGhpcy5fd3JpdGVEYXRhKGNvbmNhdCh3cml0ZXIuX2RhdGEpKX13cml0ZUJ5dGVzKHZhbHVlKXtsZXQgYnl0ZXM9YXJyYXlpZnkodmFsdWUpO2NvbnN0IHBhZGRpbmdPZmZzZXQ9Ynl0ZXMubGVuZ3RoJXRoaXMud29yZFNpemU7aWYocGFkZGluZ09mZnNldCl7Ynl0ZXM9Y29uY2F0KFtieXRlcyx0aGlzLl9wYWRkaW5nLnNsaWNlKHBhZGRpbmdPZmZzZXQpXSl9cmV0dXJuIHRoaXMuX3dyaXRlRGF0YShieXRlcyl9X2dldFZhbHVlKHZhbHVlKXtsZXQgYnl0ZXM9YXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odmFsdWUpKTtpZihieXRlcy5sZW5ndGg+dGhpcy53b3JkU2l6ZSl7bG9nZ2VyJDUudGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHtsZW5ndGg6dGhpcy53b3JkU2l6ZSxvZmZzZXQ6Ynl0ZXMubGVuZ3RofSl9aWYoYnl0ZXMubGVuZ3RoJXRoaXMud29yZFNpemUpe2J5dGVzPWNvbmNhdChbdGhpcy5fcGFkZGluZy5zbGljZShieXRlcy5sZW5ndGgldGhpcy53b3JkU2l6ZSksYnl0ZXNdKX1yZXR1cm4gYnl0ZXN9d3JpdGVWYWx1ZSh2YWx1ZSl7cmV0dXJuIHRoaXMuX3dyaXRlRGF0YSh0aGlzLl9nZXRWYWx1ZSh2YWx1ZSkpfXdyaXRlVXBkYXRhYmxlVmFsdWUoKXtjb25zdCBvZmZzZXQ9dGhpcy5fZGF0YS5sZW5ndGg7dGhpcy5fZGF0YS5wdXNoKHRoaXMuX3BhZGRpbmcpO3RoaXMuX2RhdGFMZW5ndGgrPXRoaXMud29yZFNpemU7cmV0dXJuIHZhbHVlPT57dGhpcy5fZGF0YVtvZmZzZXRdPXRoaXMuX2dldFZhbHVlKHZhbHVlKX19fWNsYXNzIFJlYWRlcntjb25zdHJ1Y3RvcihkYXRhLHdvcmRTaXplLGNvZXJjZUZ1bmMsYWxsb3dMb29zZSl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9kYXRhXCIsYXJyYXlpZnkoZGF0YSkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJ3b3JkU2l6ZVwiLHdvcmRTaXplfHwzMik7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9jb2VyY2VGdW5jXCIsY29lcmNlRnVuYyk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFsbG93TG9vc2VcIixhbGxvd0xvb3NlKTt0aGlzLl9vZmZzZXQ9MH1nZXQgZGF0YSgpe3JldHVybiBoZXhsaWZ5KHRoaXMuX2RhdGEpfWdldCBjb25zdW1lZCgpe3JldHVybiB0aGlzLl9vZmZzZXR9c3RhdGljIGNvZXJjZShuYW1lLHZhbHVlKXtsZXQgbWF0Y2g9bmFtZS5tYXRjaChcIl51P2ludChbMC05XSspJFwiKTtpZihtYXRjaCYmcGFyc2VJbnQobWF0Y2hbMV0pPD00OCl7dmFsdWU9dmFsdWUudG9OdW1iZXIoKX1yZXR1cm4gdmFsdWV9Y29lcmNlKG5hbWUsdmFsdWUpe2lmKHRoaXMuX2NvZXJjZUZ1bmMpe3JldHVybiB0aGlzLl9jb2VyY2VGdW5jKG5hbWUsdmFsdWUpfXJldHVybiBSZWFkZXIuY29lcmNlKG5hbWUsdmFsdWUpfV9wZWVrQnl0ZXMob2Zmc2V0LGxlbmd0aCxsb29zZSl7bGV0IGFsaWduZWRMZW5ndGg9TWF0aC5jZWlsKGxlbmd0aC90aGlzLndvcmRTaXplKSp0aGlzLndvcmRTaXplO2lmKHRoaXMuX29mZnNldCthbGlnbmVkTGVuZ3RoPnRoaXMuX2RhdGEubGVuZ3RoKXtpZih0aGlzLmFsbG93TG9vc2UmJmxvb3NlJiZ0aGlzLl9vZmZzZXQrbGVuZ3RoPD10aGlzLl9kYXRhLmxlbmd0aCl7YWxpZ25lZExlbmd0aD1sZW5ndGh9ZWxzZXtsb2dnZXIkNS50aHJvd0Vycm9yKFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTix7bGVuZ3RoOnRoaXMuX2RhdGEubGVuZ3RoLG9mZnNldDp0aGlzLl9vZmZzZXQrYWxpZ25lZExlbmd0aH0pfX1yZXR1cm4gdGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQsdGhpcy5fb2Zmc2V0K2FsaWduZWRMZW5ndGgpfXN1YlJlYWRlcihvZmZzZXQpe3JldHVybiBuZXcgUmVhZGVyKHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fb2Zmc2V0K29mZnNldCksdGhpcy53b3JkU2l6ZSx0aGlzLl9jb2VyY2VGdW5jLHRoaXMuYWxsb3dMb29zZSl9cmVhZEJ5dGVzKGxlbmd0aCxsb29zZSl7bGV0IGJ5dGVzPXRoaXMuX3BlZWtCeXRlcygwLGxlbmd0aCwhIWxvb3NlKTt0aGlzLl9vZmZzZXQrPWJ5dGVzLmxlbmd0aDtyZXR1cm4gYnl0ZXMuc2xpY2UoMCxsZW5ndGgpfXJlYWRWYWx1ZSgpe3JldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLnJlYWRCeXRlcyh0aGlzLndvcmRTaXplKSl9fXZhciBzaGEzPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKG1vZHVsZSl7KGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHJvb3Q9dHlwZW9mIHdpbmRvdz09PVwib2JqZWN0XCI/d2luZG93Ont9O3ZhciBOT0RFX0pTPSFyb290LkpTX1NIQTNfTk9fTk9ERV9KUyYmdHlwZW9mIHByb2Nlc3M9PT1cIm9iamVjdFwiJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGU7aWYoTk9ERV9KUyl7cm9vdD1jb21tb25qc0dsb2JhbH12YXIgQ09NTU9OX0pTPSFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTJiZcIm9iamVjdFwiPT09XCJvYmplY3RcIiYmbW9kdWxlLmV4cG9ydHM7dmFyIEhFWF9DSEFSUz1cIjAxMjM0NTY3ODlhYmNkZWZcIi5zcGxpdChcIlwiKTt2YXIgU0hBS0VfUEFERElORz1bMzEsNzkzNiwyMDMxNjE2LDUyMDA5MzY5Nl07dmFyIEtFQ0NBS19QQURESU5HPVsxLDI1Niw2NTUzNiwxNjc3NzIxNl07dmFyIFBBRERJTkc9WzYsMTUzNiwzOTMyMTYsMTAwNjYzMjk2XTt2YXIgU0hJRlQ9WzAsOCwxNiwyNF07dmFyIFJDPVsxLDAsMzI4OTgsMCwzMjkwNiwyMTQ3NDgzNjQ4LDIxNDc1MTY0MTYsMjE0NzQ4MzY0OCwzMjkwNywwLDIxNDc0ODM2NDksMCwyMTQ3NTE2NTQ1LDIxNDc0ODM2NDgsMzI3NzcsMjE0NzQ4MzY0OCwxMzgsMCwxMzYsMCwyMTQ3NTE2NDI1LDAsMjE0NzQ4MzY1OCwwLDIxNDc1MTY1NTUsMCwxMzksMjE0NzQ4MzY0OCwzMjkwNSwyMTQ3NDgzNjQ4LDMyNzcxLDIxNDc0ODM2NDgsMzI3NzAsMjE0NzQ4MzY0OCwxMjgsMjE0NzQ4MzY0OCwzMjc3OCwwLDIxNDc0ODM2NTgsMjE0NzQ4MzY0OCwyMTQ3NTE2NTQ1LDIxNDc0ODM2NDgsMzI4OTYsMjE0NzQ4MzY0OCwyMTQ3NDgzNjQ5LDAsMjE0NzUxNjQyNCwyMTQ3NDgzNjQ4XTt2YXIgQklUUz1bMjI0LDI1NiwzODQsNTEyXTt2YXIgU0hBS0VfQklUUz1bMTI4LDI1Nl07dmFyIE9VVFBVVF9UWVBFUz1bXCJoZXhcIixcImJ1ZmZlclwiLFwiYXJyYXlCdWZmZXJcIixcImFycmF5XCJdO3ZhciBjcmVhdGVPdXRwdXRNZXRob2Q9ZnVuY3Rpb24oYml0cyxwYWRkaW5nLG91dHB1dFR5cGUpe3JldHVybiBmdW5jdGlvbihtZXNzYWdlKXtyZXR1cm4gbmV3IEtlY2NhayhiaXRzLHBhZGRpbmcsYml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCl9fTt2YXIgY3JlYXRlU2hha2VPdXRwdXRNZXRob2Q9ZnVuY3Rpb24oYml0cyxwYWRkaW5nLG91dHB1dFR5cGUpe3JldHVybiBmdW5jdGlvbihtZXNzYWdlLG91dHB1dEJpdHMpe3JldHVybiBuZXcgS2VjY2FrKGJpdHMscGFkZGluZyxvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKX19O3ZhciBjcmVhdGVNZXRob2Q9ZnVuY3Rpb24oYml0cyxwYWRkaW5nKXt2YXIgbWV0aG9kPWNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLHBhZGRpbmcsXCJoZXhcIik7bWV0aG9kLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgS2VjY2FrKGJpdHMscGFkZGluZyxiaXRzKX07bWV0aG9kLnVwZGF0ZT1mdW5jdGlvbihtZXNzYWdlKXtyZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKX07Zm9yKHZhciBpPTA7aTxPVVRQVVRfVFlQRVMubGVuZ3RoOysraSl7dmFyIHR5cGU9T1VUUFVUX1RZUEVTW2ldO21ldGhvZFt0eXBlXT1jcmVhdGVPdXRwdXRNZXRob2QoYml0cyxwYWRkaW5nLHR5cGUpfXJldHVybiBtZXRob2R9O3ZhciBjcmVhdGVTaGFrZU1ldGhvZD1mdW5jdGlvbihiaXRzLHBhZGRpbmcpe3ZhciBtZXRob2Q9Y3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cyxwYWRkaW5nLFwiaGV4XCIpO21ldGhvZC5jcmVhdGU9ZnVuY3Rpb24ob3V0cHV0Qml0cyl7cmV0dXJuIG5ldyBLZWNjYWsoYml0cyxwYWRkaW5nLG91dHB1dEJpdHMpfTttZXRob2QudXBkYXRlPWZ1bmN0aW9uKG1lc3NhZ2Usb3V0cHV0Qml0cyl7cmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpfTtmb3IodmFyIGk9MDtpPE9VVFBVVF9UWVBFUy5sZW5ndGg7KytpKXt2YXIgdHlwZT1PVVRQVVRfVFlQRVNbaV07bWV0aG9kW3R5cGVdPWNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMscGFkZGluZyx0eXBlKX1yZXR1cm4gbWV0aG9kfTt2YXIgYWxnb3JpdGhtcz1be25hbWU6XCJrZWNjYWtcIixwYWRkaW5nOktFQ0NBS19QQURESU5HLGJpdHM6QklUUyxjcmVhdGVNZXRob2Q6Y3JlYXRlTWV0aG9kfSx7bmFtZTpcInNoYTNcIixwYWRkaW5nOlBBRERJTkcsYml0czpCSVRTLGNyZWF0ZU1ldGhvZDpjcmVhdGVNZXRob2R9LHtuYW1lOlwic2hha2VcIixwYWRkaW5nOlNIQUtFX1BBRERJTkcsYml0czpTSEFLRV9CSVRTLGNyZWF0ZU1ldGhvZDpjcmVhdGVTaGFrZU1ldGhvZH1dO3ZhciBtZXRob2RzPXt9LG1ldGhvZE5hbWVzPVtdO2Zvcih2YXIgaT0wO2k8YWxnb3JpdGhtcy5sZW5ndGg7KytpKXt2YXIgYWxnb3JpdGhtPWFsZ29yaXRobXNbaV07dmFyIGJpdHM9YWxnb3JpdGhtLmJpdHM7Zm9yKHZhciBqPTA7ajxiaXRzLmxlbmd0aDsrK2ope3ZhciBtZXRob2ROYW1lPWFsZ29yaXRobS5uYW1lK1wiX1wiK2JpdHNbal07bWV0aG9kTmFtZXMucHVzaChtZXRob2ROYW1lKTttZXRob2RzW21ldGhvZE5hbWVdPWFsZ29yaXRobS5jcmVhdGVNZXRob2QoYml0c1tqXSxhbGdvcml0aG0ucGFkZGluZyl9fWZ1bmN0aW9uIEtlY2NhayhiaXRzLHBhZGRpbmcsb3V0cHV0Qml0cyl7dGhpcy5ibG9ja3M9W107dGhpcy5zPVtdO3RoaXMucGFkZGluZz1wYWRkaW5nO3RoaXMub3V0cHV0Qml0cz1vdXRwdXRCaXRzO3RoaXMucmVzZXQ9dHJ1ZTt0aGlzLmJsb2NrPTA7dGhpcy5zdGFydD0wO3RoaXMuYmxvY2tDb3VudD0xNjAwLShiaXRzPDwxKT4+NTt0aGlzLmJ5dGVDb3VudD10aGlzLmJsb2NrQ291bnQ8PDI7dGhpcy5vdXRwdXRCbG9ja3M9b3V0cHV0Qml0cz4+NTt0aGlzLmV4dHJhQnl0ZXM9KG91dHB1dEJpdHMmMzEpPj4zO2Zvcih2YXIgaT0wO2k8NTA7KytpKXt0aGlzLnNbaV09MH19S2VjY2FrLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24obWVzc2FnZSl7dmFyIG5vdFN0cmluZz10eXBlb2YgbWVzc2FnZSE9PVwic3RyaW5nXCI7aWYobm90U3RyaW5nJiZtZXNzYWdlLmNvbnN0cnVjdG9yPT09QXJyYXlCdWZmZXIpe21lc3NhZ2U9bmV3IFVpbnQ4QXJyYXkobWVzc2FnZSl9dmFyIGxlbmd0aD1tZXNzYWdlLmxlbmd0aCxibG9ja3M9dGhpcy5ibG9ja3MsYnl0ZUNvdW50PXRoaXMuYnl0ZUNvdW50LGJsb2NrQ291bnQ9dGhpcy5ibG9ja0NvdW50LGluZGV4PTAscz10aGlzLnMsaSxjb2RlO3doaWxlKGluZGV4PGxlbmd0aCl7aWYodGhpcy5yZXNldCl7dGhpcy5yZXNldD1mYWxzZTtibG9ja3NbMF09dGhpcy5ibG9jaztmb3IoaT0xO2k8YmxvY2tDb3VudCsxOysraSl7YmxvY2tzW2ldPTB9fWlmKG5vdFN0cmluZyl7Zm9yKGk9dGhpcy5zdGFydDtpbmRleDxsZW5ndGgmJmk8Ynl0ZUNvdW50OysraW5kZXgpe2Jsb2Nrc1tpPj4yXXw9bWVzc2FnZVtpbmRleF08PFNISUZUW2krKyYzXX19ZWxzZXtmb3IoaT10aGlzLnN0YXJ0O2luZGV4PGxlbmd0aCYmaTxieXRlQ291bnQ7KytpbmRleCl7Y29kZT1tZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO2lmKGNvZGU8MTI4KXtibG9ja3NbaT4+Ml18PWNvZGU8PFNISUZUW2krKyYzXX1lbHNlIGlmKGNvZGU8MjA0OCl7YmxvY2tzW2k+PjJdfD0oMTkyfGNvZGU+PjYpPDxTSElGVFtpKysmM107YmxvY2tzW2k+PjJdfD0oMTI4fGNvZGUmNjMpPDxTSElGVFtpKysmM119ZWxzZSBpZihjb2RlPDU1Mjk2fHxjb2RlPj01NzM0NCl7YmxvY2tzW2k+PjJdfD0oMjI0fGNvZGU+PjEyKTw8U0hJRlRbaSsrJjNdO2Jsb2Nrc1tpPj4yXXw9KDEyOHxjb2RlPj42JjYzKTw8U0hJRlRbaSsrJjNdO2Jsb2Nrc1tpPj4yXXw9KDEyOHxjb2RlJjYzKTw8U0hJRlRbaSsrJjNdfWVsc2V7Y29kZT02NTUzNisoKGNvZGUmMTAyMyk8PDEwfG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSYxMDIzKTtibG9ja3NbaT4+Ml18PSgyNDB8Y29kZT4+MTgpPDxTSElGVFtpKysmM107YmxvY2tzW2k+PjJdfD0oMTI4fGNvZGU+PjEyJjYzKTw8U0hJRlRbaSsrJjNdO2Jsb2Nrc1tpPj4yXXw9KDEyOHxjb2RlPj42JjYzKTw8U0hJRlRbaSsrJjNdO2Jsb2Nrc1tpPj4yXXw9KDEyOHxjb2RlJjYzKTw8U0hJRlRbaSsrJjNdfX19dGhpcy5sYXN0Qnl0ZUluZGV4PWk7aWYoaT49Ynl0ZUNvdW50KXt0aGlzLnN0YXJ0PWktYnl0ZUNvdW50O3RoaXMuYmxvY2s9YmxvY2tzW2Jsb2NrQ291bnRdO2ZvcihpPTA7aTxibG9ja0NvdW50OysraSl7c1tpXV49YmxvY2tzW2ldfWYocyk7dGhpcy5yZXNldD10cnVlfWVsc2V7dGhpcy5zdGFydD1pfX1yZXR1cm4gdGhpc307S2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZT1mdW5jdGlvbigpe3ZhciBibG9ja3M9dGhpcy5ibG9ja3MsaT10aGlzLmxhc3RCeXRlSW5kZXgsYmxvY2tDb3VudD10aGlzLmJsb2NrQ291bnQscz10aGlzLnM7YmxvY2tzW2k+PjJdfD10aGlzLnBhZGRpbmdbaSYzXTtpZih0aGlzLmxhc3RCeXRlSW5kZXg9PT10aGlzLmJ5dGVDb3VudCl7YmxvY2tzWzBdPWJsb2Nrc1tibG9ja0NvdW50XTtmb3IoaT0xO2k8YmxvY2tDb3VudCsxOysraSl7YmxvY2tzW2ldPTB9fWJsb2Nrc1tibG9ja0NvdW50LTFdfD0yMTQ3NDgzNjQ4O2ZvcihpPTA7aTxibG9ja0NvdW50OysraSl7c1tpXV49YmxvY2tzW2ldfWYocyl9O0tlY2Nhay5wcm90b3R5cGUudG9TdHJpbmc9S2VjY2FrLnByb3RvdHlwZS5oZXg9ZnVuY3Rpb24oKXt0aGlzLmZpbmFsaXplKCk7dmFyIGJsb2NrQ291bnQ9dGhpcy5ibG9ja0NvdW50LHM9dGhpcy5zLG91dHB1dEJsb2Nrcz10aGlzLm91dHB1dEJsb2NrcyxleHRyYUJ5dGVzPXRoaXMuZXh0cmFCeXRlcyxpPTAsaj0wO3ZhciBoZXg9XCJcIixibG9jazt3aGlsZShqPG91dHB1dEJsb2Nrcyl7Zm9yKGk9MDtpPGJsb2NrQ291bnQmJmo8b3V0cHV0QmxvY2tzOysraSwrK2ope2Jsb2NrPXNbaV07aGV4Kz1IRVhfQ0hBUlNbYmxvY2s+PjQmMTVdK0hFWF9DSEFSU1tibG9jayYxNV0rSEVYX0NIQVJTW2Jsb2NrPj4xMiYxNV0rSEVYX0NIQVJTW2Jsb2NrPj44JjE1XStIRVhfQ0hBUlNbYmxvY2s+PjIwJjE1XStIRVhfQ0hBUlNbYmxvY2s+PjE2JjE1XStIRVhfQ0hBUlNbYmxvY2s+PjI4JjE1XStIRVhfQ0hBUlNbYmxvY2s+PjI0JjE1XX1pZihqJWJsb2NrQ291bnQ9PT0wKXtmKHMpO2k9MH19aWYoZXh0cmFCeXRlcyl7YmxvY2s9c1tpXTtpZihleHRyYUJ5dGVzPjApe2hleCs9SEVYX0NIQVJTW2Jsb2NrPj40JjE1XStIRVhfQ0hBUlNbYmxvY2smMTVdfWlmKGV4dHJhQnl0ZXM+MSl7aGV4Kz1IRVhfQ0hBUlNbYmxvY2s+PjEyJjE1XStIRVhfQ0hBUlNbYmxvY2s+PjgmMTVdfWlmKGV4dHJhQnl0ZXM+Mil7aGV4Kz1IRVhfQ0hBUlNbYmxvY2s+PjIwJjE1XStIRVhfQ0hBUlNbYmxvY2s+PjE2JjE1XX19cmV0dXJuIGhleH07S2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcj1mdW5jdGlvbigpe3RoaXMuZmluYWxpemUoKTt2YXIgYmxvY2tDb3VudD10aGlzLmJsb2NrQ291bnQscz10aGlzLnMsb3V0cHV0QmxvY2tzPXRoaXMub3V0cHV0QmxvY2tzLGV4dHJhQnl0ZXM9dGhpcy5leHRyYUJ5dGVzLGk9MCxqPTA7dmFyIGJ5dGVzPXRoaXMub3V0cHV0Qml0cz4+Mzt2YXIgYnVmZmVyO2lmKGV4dHJhQnl0ZXMpe2J1ZmZlcj1uZXcgQXJyYXlCdWZmZXIob3V0cHV0QmxvY2tzKzE8PDIpfWVsc2V7YnVmZmVyPW5ldyBBcnJheUJ1ZmZlcihieXRlcyl9dmFyIGFycmF5PW5ldyBVaW50MzJBcnJheShidWZmZXIpO3doaWxlKGo8b3V0cHV0QmxvY2tzKXtmb3IoaT0wO2k8YmxvY2tDb3VudCYmajxvdXRwdXRCbG9ja3M7KytpLCsrail7YXJyYXlbal09c1tpXX1pZihqJWJsb2NrQ291bnQ9PT0wKXtmKHMpfX1pZihleHRyYUJ5dGVzKXthcnJheVtpXT1zW2ldO2J1ZmZlcj1idWZmZXIuc2xpY2UoMCxieXRlcyl9cmV0dXJuIGJ1ZmZlcn07S2VjY2FrLnByb3RvdHlwZS5idWZmZXI9S2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcjtLZWNjYWsucHJvdG90eXBlLmRpZ2VzdD1LZWNjYWsucHJvdG90eXBlLmFycmF5PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO3ZhciBibG9ja0NvdW50PXRoaXMuYmxvY2tDb3VudCxzPXRoaXMucyxvdXRwdXRCbG9ja3M9dGhpcy5vdXRwdXRCbG9ja3MsZXh0cmFCeXRlcz10aGlzLmV4dHJhQnl0ZXMsaT0wLGo9MDt2YXIgYXJyYXk9W10sb2Zmc2V0LGJsb2NrO3doaWxlKGo8b3V0cHV0QmxvY2tzKXtmb3IoaT0wO2k8YmxvY2tDb3VudCYmajxvdXRwdXRCbG9ja3M7KytpLCsrail7b2Zmc2V0PWo8PDI7YmxvY2s9c1tpXTthcnJheVtvZmZzZXRdPWJsb2NrJjI1NTthcnJheVtvZmZzZXQrMV09YmxvY2s+PjgmMjU1O2FycmF5W29mZnNldCsyXT1ibG9jaz4+MTYmMjU1O2FycmF5W29mZnNldCszXT1ibG9jaz4+MjQmMjU1fWlmKGolYmxvY2tDb3VudD09PTApe2Yocyl9fWlmKGV4dHJhQnl0ZXMpe29mZnNldD1qPDwyO2Jsb2NrPXNbaV07aWYoZXh0cmFCeXRlcz4wKXthcnJheVtvZmZzZXRdPWJsb2NrJjI1NX1pZihleHRyYUJ5dGVzPjEpe2FycmF5W29mZnNldCsxXT1ibG9jaz4+OCYyNTV9aWYoZXh0cmFCeXRlcz4yKXthcnJheVtvZmZzZXQrMl09YmxvY2s+PjE2JjI1NX19cmV0dXJuIGFycmF5fTt2YXIgZj1mdW5jdGlvbihzKXt2YXIgaCxsLG4sYzAsYzEsYzIsYzMsYzQsYzUsYzYsYzcsYzgsYzksYjAsYjEsYjIsYjMsYjQsYjUsYjYsYjcsYjgsYjksYjEwLGIxMSxiMTIsYjEzLGIxNCxiMTUsYjE2LGIxNyxiMTgsYjE5LGIyMCxiMjEsYjIyLGIyMyxiMjQsYjI1LGIyNixiMjcsYjI4LGIyOSxiMzAsYjMxLGIzMixiMzMsYjM0LGIzNSxiMzYsYjM3LGIzOCxiMzksYjQwLGI0MSxiNDIsYjQzLGI0NCxiNDUsYjQ2LGI0NyxiNDgsYjQ5O2ZvcihuPTA7bjw0ODtuKz0yKXtjMD1zWzBdXnNbMTBdXnNbMjBdXnNbMzBdXnNbNDBdO2MxPXNbMV1ec1sxMV1ec1syMV1ec1szMV1ec1s0MV07YzI9c1syXV5zWzEyXV5zWzIyXV5zWzMyXV5zWzQyXTtjMz1zWzNdXnNbMTNdXnNbMjNdXnNbMzNdXnNbNDNdO2M0PXNbNF1ec1sxNF1ec1syNF1ec1szNF1ec1s0NF07YzU9c1s1XV5zWzE1XV5zWzI1XV5zWzM1XV5zWzQ1XTtjNj1zWzZdXnNbMTZdXnNbMjZdXnNbMzZdXnNbNDZdO2M3PXNbN11ec1sxN11ec1syN11ec1szN11ec1s0N107Yzg9c1s4XV5zWzE4XV5zWzI4XV5zWzM4XV5zWzQ4XTtjOT1zWzldXnNbMTldXnNbMjldXnNbMzldXnNbNDldO2g9YzheKGMyPDwxfGMzPj4+MzEpO2w9YzleKGMzPDwxfGMyPj4+MzEpO3NbMF1ePWg7c1sxXV49bDtzWzEwXV49aDtzWzExXV49bDtzWzIwXV49aDtzWzIxXV49bDtzWzMwXV49aDtzWzMxXV49bDtzWzQwXV49aDtzWzQxXV49bDtoPWMwXihjNDw8MXxjNT4+PjMxKTtsPWMxXihjNTw8MXxjND4+PjMxKTtzWzJdXj1oO3NbM11ePWw7c1sxMl1ePWg7c1sxM11ePWw7c1syMl1ePWg7c1syM11ePWw7c1szMl1ePWg7c1szM11ePWw7c1s0Ml1ePWg7c1s0M11ePWw7aD1jMl4oYzY8PDF8Yzc+Pj4zMSk7bD1jM14oYzc8PDF8YzY+Pj4zMSk7c1s0XV49aDtzWzVdXj1sO3NbMTRdXj1oO3NbMTVdXj1sO3NbMjRdXj1oO3NbMjVdXj1sO3NbMzRdXj1oO3NbMzVdXj1sO3NbNDRdXj1oO3NbNDVdXj1sO2g9YzReKGM4PDwxfGM5Pj4+MzEpO2w9YzVeKGM5PDwxfGM4Pj4+MzEpO3NbNl1ePWg7c1s3XV49bDtzWzE2XV49aDtzWzE3XV49bDtzWzI2XV49aDtzWzI3XV49bDtzWzM2XV49aDtzWzM3XV49bDtzWzQ2XV49aDtzWzQ3XV49bDtoPWM2XihjMDw8MXxjMT4+PjMxKTtsPWM3XihjMTw8MXxjMD4+PjMxKTtzWzhdXj1oO3NbOV1ePWw7c1sxOF1ePWg7c1sxOV1ePWw7c1syOF1ePWg7c1syOV1ePWw7c1szOF1ePWg7c1szOV1ePWw7c1s0OF1ePWg7c1s0OV1ePWw7YjA9c1swXTtiMT1zWzFdO2IzMj1zWzExXTw8NHxzWzEwXT4+PjI4O2IzMz1zWzEwXTw8NHxzWzExXT4+PjI4O2IxND1zWzIwXTw8M3xzWzIxXT4+PjI5O2IxNT1zWzIxXTw8M3xzWzIwXT4+PjI5O2I0Nj1zWzMxXTw8OXxzWzMwXT4+PjIzO2I0Nz1zWzMwXTw8OXxzWzMxXT4+PjIzO2IyOD1zWzQwXTw8MTh8c1s0MV0+Pj4xNDtiMjk9c1s0MV08PDE4fHNbNDBdPj4+MTQ7YjIwPXNbMl08PDF8c1szXT4+PjMxO2IyMT1zWzNdPDwxfHNbMl0+Pj4zMTtiMj1zWzEzXTw8MTJ8c1sxMl0+Pj4yMDtiMz1zWzEyXTw8MTJ8c1sxM10+Pj4yMDtiMzQ9c1syMl08PDEwfHNbMjNdPj4+MjI7YjM1PXNbMjNdPDwxMHxzWzIyXT4+PjIyO2IxNj1zWzMzXTw8MTN8c1szMl0+Pj4xOTtiMTc9c1szMl08PDEzfHNbMzNdPj4+MTk7YjQ4PXNbNDJdPDwyfHNbNDNdPj4+MzA7YjQ5PXNbNDNdPDwyfHNbNDJdPj4+MzA7YjQwPXNbNV08PDMwfHNbNF0+Pj4yO2I0MT1zWzRdPDwzMHxzWzVdPj4+MjtiMjI9c1sxNF08PDZ8c1sxNV0+Pj4yNjtiMjM9c1sxNV08PDZ8c1sxNF0+Pj4yNjtiND1zWzI1XTw8MTF8c1syNF0+Pj4yMTtiNT1zWzI0XTw8MTF8c1syNV0+Pj4yMTtiMzY9c1szNF08PDE1fHNbMzVdPj4+MTc7YjM3PXNbMzVdPDwxNXxzWzM0XT4+PjE3O2IxOD1zWzQ1XTw8Mjl8c1s0NF0+Pj4zO2IxOT1zWzQ0XTw8Mjl8c1s0NV0+Pj4zO2IxMD1zWzZdPDwyOHxzWzddPj4+NDtiMTE9c1s3XTw8Mjh8c1s2XT4+PjQ7YjQyPXNbMTddPDwyM3xzWzE2XT4+Pjk7YjQzPXNbMTZdPDwyM3xzWzE3XT4+Pjk7YjI0PXNbMjZdPDwyNXxzWzI3XT4+Pjc7YjI1PXNbMjddPDwyNXxzWzI2XT4+Pjc7YjY9c1szNl08PDIxfHNbMzddPj4+MTE7Yjc9c1szN108PDIxfHNbMzZdPj4+MTE7YjM4PXNbNDddPDwyNHxzWzQ2XT4+Pjg7YjM5PXNbNDZdPDwyNHxzWzQ3XT4+Pjg7YjMwPXNbOF08PDI3fHNbOV0+Pj41O2IzMT1zWzldPDwyN3xzWzhdPj4+NTtiMTI9c1sxOF08PDIwfHNbMTldPj4+MTI7YjEzPXNbMTldPDwyMHxzWzE4XT4+PjEyO2I0ND1zWzI5XTw8N3xzWzI4XT4+PjI1O2I0NT1zWzI4XTw8N3xzWzI5XT4+PjI1O2IyNj1zWzM4XTw8OHxzWzM5XT4+PjI0O2IyNz1zWzM5XTw8OHxzWzM4XT4+PjI0O2I4PXNbNDhdPDwxNHxzWzQ5XT4+PjE4O2I5PXNbNDldPDwxNHxzWzQ4XT4+PjE4O3NbMF09YjBefmIyJmI0O3NbMV09YjFefmIzJmI1O3NbMTBdPWIxMF5+YjEyJmIxNDtzWzExXT1iMTFefmIxMyZiMTU7c1syMF09YjIwXn5iMjImYjI0O3NbMjFdPWIyMV5+YjIzJmIyNTtzWzMwXT1iMzBefmIzMiZiMzQ7c1szMV09YjMxXn5iMzMmYjM1O3NbNDBdPWI0MF5+YjQyJmI0NDtzWzQxXT1iNDFefmI0MyZiNDU7c1syXT1iMl5+YjQmYjY7c1szXT1iM15+YjUmYjc7c1sxMl09YjEyXn5iMTQmYjE2O3NbMTNdPWIxM15+YjE1JmIxNztzWzIyXT1iMjJefmIyNCZiMjY7c1syM109YjIzXn5iMjUmYjI3O3NbMzJdPWIzMl5+YjM0JmIzNjtzWzMzXT1iMzNefmIzNSZiMzc7c1s0Ml09YjQyXn5iNDQmYjQ2O3NbNDNdPWI0M15+YjQ1JmI0NztzWzRdPWI0Xn5iNiZiODtzWzVdPWI1Xn5iNyZiOTtzWzE0XT1iMTRefmIxNiZiMTg7c1sxNV09YjE1Xn5iMTcmYjE5O3NbMjRdPWIyNF5+YjI2JmIyODtzWzI1XT1iMjVefmIyNyZiMjk7c1szNF09YjM0Xn5iMzYmYjM4O3NbMzVdPWIzNV5+YjM3JmIzOTtzWzQ0XT1iNDRefmI0NiZiNDg7c1s0NV09YjQ1Xn5iNDcmYjQ5O3NbNl09YjZefmI4JmIwO3NbN109YjdefmI5JmIxO3NbMTZdPWIxNl5+YjE4JmIxMDtzWzE3XT1iMTdefmIxOSZiMTE7c1syNl09YjI2Xn5iMjgmYjIwO3NbMjddPWIyN15+YjI5JmIyMTtzWzM2XT1iMzZefmIzOCZiMzA7c1szN109YjM3Xn5iMzkmYjMxO3NbNDZdPWI0Nl5+YjQ4JmI0MDtzWzQ3XT1iNDdefmI0OSZiNDE7c1s4XT1iOF5+YjAmYjI7c1s5XT1iOV5+YjEmYjM7c1sxOF09YjE4Xn5iMTAmYjEyO3NbMTldPWIxOV5+YjExJmIxMztzWzI4XT1iMjhefmIyMCZiMjI7c1syOV09YjI5Xn5iMjEmYjIzO3NbMzhdPWIzOF5+YjMwJmIzMjtzWzM5XT1iMzlefmIzMSZiMzM7c1s0OF09YjQ4Xn5iNDAmYjQyO3NbNDldPWI0OV5+YjQxJmI0MztzWzBdXj1SQ1tuXTtzWzFdXj1SQ1tuKzFdfX07aWYoQ09NTU9OX0pTKXttb2R1bGUuZXhwb3J0cz1tZXRob2RzfWVsc2V7Zm9yKHZhciBpPTA7aTxtZXRob2ROYW1lcy5sZW5ndGg7KytpKXtyb290W21ldGhvZE5hbWVzW2ldXT1tZXRob2RzW21ldGhvZE5hbWVzW2ldXX19fSkoKX0pO1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGtlY2NhazI1NihkYXRhKXtyZXR1cm5cIjB4XCIrc2hhMy5rZWNjYWtfMjU2KGFycmF5aWZ5KGRhdGEpKX1jb25zdCB2ZXJzaW9uJDU9XCJybHAvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkNj1uZXcgTG9nZ2VyKHZlcnNpb24kNSk7ZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKXtjb25zdCByZXN1bHQ9W107d2hpbGUodmFsdWUpe3Jlc3VsdC51bnNoaWZ0KHZhbHVlJjI1NSk7dmFsdWU+Pj04fXJldHVybiByZXN1bHR9ZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSxvZmZzZXQsbGVuZ3RoKXtsZXQgcmVzdWx0PTA7Zm9yKGxldCBpPTA7aTxsZW5ndGg7aSsrKXtyZXN1bHQ9cmVzdWx0KjI1NitkYXRhW29mZnNldCtpXX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KXtpZihBcnJheS5pc0FycmF5KG9iamVjdCkpe2xldCBwYXlsb2FkPVtdO29iamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKXtwYXlsb2FkPXBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKX0pO2lmKHBheWxvYWQubGVuZ3RoPD01NSl7cGF5bG9hZC51bnNoaWZ0KDE5MitwYXlsb2FkLmxlbmd0aCk7cmV0dXJuIHBheWxvYWR9Y29uc3QgbGVuZ3RoPWFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7bGVuZ3RoLnVuc2hpZnQoMjQ3K2xlbmd0aC5sZW5ndGgpO3JldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpfWlmKCFpc0J5dGVzTGlrZShvYmplY3QpKXtsb2dnZXIkNi50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsXCJvYmplY3RcIixvYmplY3QpfWNvbnN0IGRhdGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlpZnkob2JqZWN0KSk7aWYoZGF0YS5sZW5ndGg9PT0xJiZkYXRhWzBdPD0xMjcpe3JldHVybiBkYXRhfWVsc2UgaWYoZGF0YS5sZW5ndGg8PTU1KXtkYXRhLnVuc2hpZnQoMTI4K2RhdGEubGVuZ3RoKTtyZXR1cm4gZGF0YX1jb25zdCBsZW5ndGg9YXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtsZW5ndGgudW5zaGlmdCgxODMrbGVuZ3RoLmxlbmd0aCk7cmV0dXJuIGxlbmd0aC5jb25jYXQoZGF0YSl9ZnVuY3Rpb24gZW5jb2RlKG9iamVjdCl7cmV0dXJuIGhleGxpZnkoX2VuY29kZShvYmplY3QpKX1mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSxvZmZzZXQsY2hpbGRPZmZzZXQsbGVuZ3RoKXtjb25zdCByZXN1bHQ9W107d2hpbGUoY2hpbGRPZmZzZXQ8b2Zmc2V0KzErbGVuZ3RoKXtjb25zdCBkZWNvZGVkPV9kZWNvZGUoZGF0YSxjaGlsZE9mZnNldCk7cmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO2NoaWxkT2Zmc2V0Kz1kZWNvZGVkLmNvbnN1bWVkO2lmKGNoaWxkT2Zmc2V0Pm9mZnNldCsxK2xlbmd0aCl7bG9nZ2VyJDYudGhyb3dFcnJvcihcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTix7fSl9fXJldHVybntjb25zdW1lZDoxK2xlbmd0aCxyZXN1bHQ6cmVzdWx0fX1mdW5jdGlvbiBfZGVjb2RlKGRhdGEsb2Zmc2V0KXtpZihkYXRhLmxlbmd0aD09PTApe2xvZ2dlciQ2LnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4se30pfWlmKGRhdGFbb2Zmc2V0XT49MjQ4KXtjb25zdCBsZW5ndGhMZW5ndGg9ZGF0YVtvZmZzZXRdLTI0NztpZihvZmZzZXQrMStsZW5ndGhMZW5ndGg+ZGF0YS5sZW5ndGgpe2xvZ2dlciQ2LnRocm93RXJyb3IoXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTix7fSl9Y29uc3QgbGVuZ3RoPXVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsb2Zmc2V0KzEsbGVuZ3RoTGVuZ3RoKTtpZihvZmZzZXQrMStsZW5ndGhMZW5ndGgrbGVuZ3RoPmRhdGEubGVuZ3RoKXtsb2dnZXIkNi50aHJvd0Vycm9yKFwiZGF0YSBsb25nIHNlZ21lbnQgdG9vIHNob3J0XCIsTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTix7fSl9cmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLG9mZnNldCxvZmZzZXQrMStsZW5ndGhMZW5ndGgsbGVuZ3RoTGVuZ3RoK2xlbmd0aCl9ZWxzZSBpZihkYXRhW29mZnNldF0+PTE5Mil7Y29uc3QgbGVuZ3RoPWRhdGFbb2Zmc2V0XS0xOTI7aWYob2Zmc2V0KzErbGVuZ3RoPmRhdGEubGVuZ3RoKXtsb2dnZXIkNi50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHt9KX1yZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsb2Zmc2V0LG9mZnNldCsxLGxlbmd0aCl9ZWxzZSBpZihkYXRhW29mZnNldF0+PTE4NCl7Y29uc3QgbGVuZ3RoTGVuZ3RoPWRhdGFbb2Zmc2V0XS0xODM7aWYob2Zmc2V0KzErbGVuZ3RoTGVuZ3RoPmRhdGEubGVuZ3RoKXtsb2dnZXIkNi50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHt9KX1jb25zdCBsZW5ndGg9dW5hcnJheWlmeUludGVnZXIoZGF0YSxvZmZzZXQrMSxsZW5ndGhMZW5ndGgpO2lmKG9mZnNldCsxK2xlbmd0aExlbmd0aCtsZW5ndGg+ZGF0YS5sZW5ndGgpe2xvZ2dlciQ2LnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4se30pfWNvbnN0IHJlc3VsdD1oZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0KzErbGVuZ3RoTGVuZ3RoLG9mZnNldCsxK2xlbmd0aExlbmd0aCtsZW5ndGgpKTtyZXR1cm57Y29uc3VtZWQ6MStsZW5ndGhMZW5ndGgrbGVuZ3RoLHJlc3VsdDpyZXN1bHR9fWVsc2UgaWYoZGF0YVtvZmZzZXRdPj0xMjgpe2NvbnN0IGxlbmd0aD1kYXRhW29mZnNldF0tMTI4O2lmKG9mZnNldCsxK2xlbmd0aD5kYXRhLmxlbmd0aCl7bG9nZ2VyJDYudGhyb3dFcnJvcihcImRhdGEgdG9vIHNob3J0XCIsTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTix7fSl9Y29uc3QgcmVzdWx0PWhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQrMSxvZmZzZXQrMStsZW5ndGgpKTtyZXR1cm57Y29uc3VtZWQ6MStsZW5ndGgscmVzdWx0OnJlc3VsdH19cmV0dXJue2NvbnN1bWVkOjEscmVzdWx0OmhleGxpZnkoZGF0YVtvZmZzZXRdKX19ZnVuY3Rpb24gZGVjb2RlKGRhdGEpe2NvbnN0IGJ5dGVzPWFycmF5aWZ5KGRhdGEpO2NvbnN0IGRlY29kZWQ9X2RlY29kZShieXRlcywwKTtpZihkZWNvZGVkLmNvbnN1bWVkIT09Ynl0ZXMubGVuZ3RoKXtsb2dnZXIkNi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIsXCJkYXRhXCIsZGF0YSl9cmV0dXJuIGRlY29kZWQucmVzdWx0fXZhciBpbmRleD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxlbmNvZGU6ZW5jb2RlLGRlY29kZTpkZWNvZGV9KTtjb25zdCB2ZXJzaW9uJDY9XCJhZGRyZXNzLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJDc9bmV3IExvZ2dlcih2ZXJzaW9uJDYpO2Z1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKXtpZighaXNIZXhTdHJpbmcoYWRkcmVzcywyMCkpe2xvZ2dlciQ3LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLFwiYWRkcmVzc1wiLGFkZHJlc3MpfWFkZHJlc3M9YWRkcmVzcy50b0xvd2VyQ2FzZSgpO2NvbnN0IGNoYXJzPWFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO2NvbnN0IGV4cGFuZGVkPW5ldyBVaW50OEFycmF5KDQwKTtmb3IobGV0IGk9MDtpPDQwO2krKyl7ZXhwYW5kZWRbaV09Y2hhcnNbaV0uY2hhckNvZGVBdCgwKX1jb25zdCBoYXNoZWQ9YXJyYXlpZnkoa2VjY2FrMjU2KGV4cGFuZGVkKSk7Zm9yKGxldCBpPTA7aTw0MDtpKz0yKXtpZihoYXNoZWRbaT4+MV0+PjQ+PTgpe2NoYXJzW2ldPWNoYXJzW2ldLnRvVXBwZXJDYXNlKCl9aWYoKGhhc2hlZFtpPj4xXSYxNSk+PTgpe2NoYXJzW2krMV09Y2hhcnNbaSsxXS50b1VwcGVyQ2FzZSgpfX1yZXR1cm5cIjB4XCIrY2hhcnMuam9pbihcIlwiKX1jb25zdCBNQVhfU0FGRV9JTlRFR0VSPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gbG9nMTAoeCl7aWYoTWF0aC5sb2cxMCl7cmV0dXJuIE1hdGgubG9nMTAoeCl9cmV0dXJuIE1hdGgubG9nKHgpL01hdGguTE4xMH1jb25zdCBpYmFuTG9va3VwPXt9O2ZvcihsZXQgaT0wO2k8MTA7aSsrKXtpYmFuTG9va3VwW1N0cmluZyhpKV09U3RyaW5nKGkpfWZvcihsZXQgaT0wO2k8MjY7aSsrKXtpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUraSldPVN0cmluZygxMCtpKX1jb25zdCBzYWZlRGlnaXRzPU1hdGguZmxvb3IobG9nMTAoTUFYX1NBRkVfSU5URUdFUikpO2Z1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKXthZGRyZXNzPWFkZHJlc3MudG9VcHBlckNhc2UoKTthZGRyZXNzPWFkZHJlc3Muc3Vic3RyaW5nKDQpK2FkZHJlc3Muc3Vic3RyaW5nKDAsMikrXCIwMFwiO2xldCBleHBhbmRlZD1hZGRyZXNzLnNwbGl0KFwiXCIpLm1hcChjPT57cmV0dXJuIGliYW5Mb29rdXBbY119KS5qb2luKFwiXCIpO3doaWxlKGV4cGFuZGVkLmxlbmd0aD49c2FmZURpZ2l0cyl7bGV0IGJsb2NrPWV4cGFuZGVkLnN1YnN0cmluZygwLHNhZmVEaWdpdHMpO2V4cGFuZGVkPXBhcnNlSW50KGJsb2NrLDEwKSU5NytleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKX1sZXQgY2hlY2tzdW09U3RyaW5nKDk4LXBhcnNlSW50KGV4cGFuZGVkLDEwKSU5Nyk7d2hpbGUoY2hlY2tzdW0ubGVuZ3RoPDIpe2NoZWNrc3VtPVwiMFwiK2NoZWNrc3VtfXJldHVybiBjaGVja3N1bX1mdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3Mpe2xldCByZXN1bHQ9bnVsbDtpZih0eXBlb2YgYWRkcmVzcyE9PVwic3RyaW5nXCIpe2xvZ2dlciQ3LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLFwiYWRkcmVzc1wiLGFkZHJlc3MpfWlmKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSl7aWYoYWRkcmVzcy5zdWJzdHJpbmcoMCwyKSE9PVwiMHhcIil7YWRkcmVzcz1cIjB4XCIrYWRkcmVzc31yZXN1bHQ9Z2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO2lmKGFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykmJnJlc3VsdCE9PWFkZHJlc3Mpe2xvZ2dlciQ3LnRocm93QXJndW1lbnRFcnJvcihcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsXCJhZGRyZXNzXCIsYWRkcmVzcyl9fWVsc2UgaWYoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpe2lmKGFkZHJlc3Muc3Vic3RyaW5nKDIsNCkhPT1pYmFuQ2hlY2tzdW0oYWRkcmVzcykpe2xvZ2dlciQ3LnRocm93QXJndW1lbnRFcnJvcihcImJhZCBpY2FwIGNoZWNrc3VtXCIsXCJhZGRyZXNzXCIsYWRkcmVzcyl9cmVzdWx0PV9iYXNlMzZUbzE2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKTt3aGlsZShyZXN1bHQubGVuZ3RoPDQwKXtyZXN1bHQ9XCIwXCIrcmVzdWx0fXJlc3VsdD1nZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiK3Jlc3VsdCl9ZWxzZXtsb2dnZXIkNy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIixcImFkZHJlc3NcIixhZGRyZXNzKX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzKXt0cnl7Z2V0QWRkcmVzcyhhZGRyZXNzKTtyZXR1cm4gdHJ1ZX1jYXRjaChlcnJvcil7fXJldHVybiBmYWxzZX1mdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKXtsZXQgYmFzZTM2PV9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO3doaWxlKGJhc2UzNi5sZW5ndGg8MzApe2Jhc2UzNj1cIjBcIitiYXNlMzZ9cmV0dXJuXCJYRVwiK2liYW5DaGVja3N1bShcIlhFMDBcIitiYXNlMzYpK2Jhc2UzNn1mdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pe2xldCBmcm9tPW51bGw7dHJ5e2Zyb209Z2V0QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKX1jYXRjaChlcnJvcil7bG9nZ2VyJDcudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBmcm9tIGFkZHJlc3NcIixcInRyYW5zYWN0aW9uXCIsdHJhbnNhY3Rpb24pfWNvbnN0IG5vbmNlPXN0cmlwWmVyb3MoYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubm9uY2UpLnRvSGV4U3RyaW5nKCkpKTtyZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZShbZnJvbSxub25jZV0pKSwxMikpfWZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sc2FsdCxpbml0Q29kZUhhc2gpe2lmKGhleERhdGFMZW5ndGgoc2FsdCkhPT0zMil7bG9nZ2VyJDcudGhyb3dBcmd1bWVudEVycm9yKFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsXCJzYWx0XCIsc2FsdCl9aWYoaGV4RGF0YUxlbmd0aChpbml0Q29kZUhhc2gpIT09MzIpe2xvZ2dlciQ3LnRocm93QXJndW1lbnRFcnJvcihcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsXCJpbml0Q29kZUhhc2hcIixpbml0Q29kZUhhc2gpfXJldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIixnZXRBZGRyZXNzKGZyb20pLHNhbHQsaW5pdENvZGVIYXNoXSkpLDEyKSl9XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXJ7Y29uc3RydWN0b3IobG9jYWxOYW1lKXtzdXBlcihcImFkZHJlc3NcIixcImFkZHJlc3NcIixsb2NhbE5hbWUsZmFsc2UpfWRlZmF1bHRWYWx1ZSgpe3JldHVyblwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJ9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7dHJ5e2dldEFkZHJlc3ModmFsdWUpfWNhdGNoKGVycm9yKXt0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsdmFsdWUpfXJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSl9ZGVjb2RlKHJlYWRlcil7cmV0dXJuIGdldEFkZHJlc3MoaGV4WmVyb1BhZChyZWFkZXIucmVhZFZhbHVlKCkudG9IZXhTdHJpbmcoKSwyMCkpfX1cInVzZSBzdHJpY3RcIjtjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKGNvZGVyKXtzdXBlcihjb2Rlci5uYW1lLGNvZGVyLnR5cGUsdW5kZWZpbmVkLGNvZGVyLmR5bmFtaWMpO3RoaXMuY29kZXI9Y29kZXJ9ZGVmYXVsdFZhbHVlKCl7cmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCl9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7cmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlcix2YWx1ZSl9ZGVjb2RlKHJlYWRlcil7cmV0dXJuIHRoaXMuY29kZXIuZGVjb2RlKHJlYWRlcil9fVwidXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciQ4PW5ldyBMb2dnZXIodmVyc2lvbiQ0KTtmdW5jdGlvbiBwYWNrKHdyaXRlcixjb2RlcnMsdmFsdWVzKXtsZXQgYXJyYXlWYWx1ZXM9bnVsbDtpZihBcnJheS5pc0FycmF5KHZhbHVlcykpe2FycmF5VmFsdWVzPXZhbHVlc31lbHNlIGlmKHZhbHVlcyYmdHlwZW9mIHZhbHVlcz09PVwib2JqZWN0XCIpe2xldCB1bmlxdWU9e307YXJyYXlWYWx1ZXM9Y29kZXJzLm1hcChjb2Rlcj0+e2NvbnN0IG5hbWU9Y29kZXIubG9jYWxOYW1lO2lmKCFuYW1lKXtsb2dnZXIkOC50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIixMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwidmFsdWVzXCIsY29kZXI6Y29kZXIsdmFsdWU6dmFsdWVzfSl9aWYodW5pcXVlW25hbWVdKXtsb2dnZXIkOC50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJ2YWx1ZXNcIixjb2Rlcjpjb2Rlcix2YWx1ZTp2YWx1ZXN9KX11bmlxdWVbbmFtZV09dHJ1ZTtyZXR1cm4gdmFsdWVzW25hbWVdfSl9ZWxzZXtsb2dnZXIkOC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsXCJ0dXBsZVwiLHZhbHVlcyl9aWYoY29kZXJzLmxlbmd0aCE9PWFycmF5VmFsdWVzLmxlbmd0aCl7bG9nZ2VyJDgudGhyb3dBcmd1bWVudEVycm9yKFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsXCJ0dXBsZVwiLHZhbHVlcyl9bGV0IHN0YXRpY1dyaXRlcj1uZXcgV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7bGV0IGR5bmFtaWNXcml0ZXI9bmV3IFdyaXRlcih3cml0ZXIud29yZFNpemUpO2xldCB1cGRhdGVGdW5jcz1bXTtjb2RlcnMuZm9yRWFjaCgoY29kZXIsaW5kZXgpPT57bGV0IHZhbHVlPWFycmF5VmFsdWVzW2luZGV4XTtpZihjb2Rlci5keW5hbWljKXtsZXQgZHluYW1pY09mZnNldD1keW5hbWljV3JpdGVyLmxlbmd0aDtjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlcix2YWx1ZSk7bGV0IHVwZGF0ZUZ1bmM9c3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTt1cGRhdGVGdW5jcy5wdXNoKGJhc2VPZmZzZXQ9Pnt1cGRhdGVGdW5jKGJhc2VPZmZzZXQrZHluYW1pY09mZnNldCl9KX1lbHNle2NvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsdmFsdWUpfX0pO3VwZGF0ZUZ1bmNzLmZvckVhY2goZnVuYz0+e2Z1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCl9KTtsZXQgbGVuZ3RoPXdyaXRlci5hcHBlbmRXcml0ZXIoc3RhdGljV3JpdGVyKTtsZW5ndGgrPXdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7cmV0dXJuIGxlbmd0aH1mdW5jdGlvbiB1bnBhY2socmVhZGVyLGNvZGVycyl7bGV0IHZhbHVlcz1bXTtsZXQgYmFzZVJlYWRlcj1yZWFkZXIuc3ViUmVhZGVyKDApO2NvZGVycy5mb3JFYWNoKGNvZGVyPT57bGV0IHZhbHVlPW51bGw7aWYoY29kZXIuZHluYW1pYyl7bGV0IG9mZnNldD1yZWFkZXIucmVhZFZhbHVlKCk7bGV0IG9mZnNldFJlYWRlcj1iYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQudG9OdW1iZXIoKSk7dHJ5e3ZhbHVlPWNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpfWNhdGNoKGVycm9yKXtpZihlcnJvci5jb2RlPT09TG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTil7dGhyb3cgZXJyb3J9dmFsdWU9ZXJyb3I7dmFsdWUuYmFzZVR5cGU9Y29kZXIubmFtZTt2YWx1ZS5uYW1lPWNvZGVyLmxvY2FsTmFtZTt2YWx1ZS50eXBlPWNvZGVyLnR5cGV9fWVsc2V7dHJ5e3ZhbHVlPWNvZGVyLmRlY29kZShyZWFkZXIpfWNhdGNoKGVycm9yKXtpZihlcnJvci5jb2RlPT09TG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTil7dGhyb3cgZXJyb3J9dmFsdWU9ZXJyb3I7dmFsdWUuYmFzZVR5cGU9Y29kZXIubmFtZTt2YWx1ZS5uYW1lPWNvZGVyLmxvY2FsTmFtZTt2YWx1ZS50eXBlPWNvZGVyLnR5cGV9fWlmKHZhbHVlIT11bmRlZmluZWQpe3ZhbHVlcy5wdXNoKHZhbHVlKX19KTtjb25zdCB1bmlxdWVOYW1lcz1jb2RlcnMucmVkdWNlKChhY2N1bSxjb2Rlcik9Pntjb25zdCBuYW1lPWNvZGVyLmxvY2FsTmFtZTtpZihuYW1lKXtpZighYWNjdW1bbmFtZV0pe2FjY3VtW25hbWVdPTB9YWNjdW1bbmFtZV0rK31yZXR1cm4gYWNjdW19LHt9KTtjb2RlcnMuZm9yRWFjaCgoY29kZXIsaW5kZXgpPT57bGV0IG5hbWU9Y29kZXIubG9jYWxOYW1lO2lmKCFuYW1lfHx1bmlxdWVOYW1lc1tuYW1lXSE9PTEpe3JldHVybn1pZihuYW1lPT09XCJsZW5ndGhcIil7bmFtZT1cIl9sZW5ndGhcIn1pZih2YWx1ZXNbbmFtZV0hPW51bGwpe3JldHVybn1jb25zdCB2YWx1ZT12YWx1ZXNbaW5kZXhdO2lmKHZhbHVlIGluc3RhbmNlb2YgRXJyb3Ipe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsbmFtZSx7Z2V0OigpPT57dGhyb3cgdmFsdWV9fSl9ZWxzZXt2YWx1ZXNbbmFtZV09dmFsdWV9fSk7Zm9yKGxldCBpPTA7aTx2YWx1ZXMubGVuZ3RoO2krKyl7Y29uc3QgdmFsdWU9dmFsdWVzW2ldO2lmKHZhbHVlIGluc3RhbmNlb2YgRXJyb3Ipe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsaSx7Z2V0OigpPT57dGhyb3cgdmFsdWV9fSl9fXJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyl9Y2xhc3MgQXJyYXlDb2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKGNvZGVyLGxlbmd0aCxsb2NhbE5hbWUpe2NvbnN0IHR5cGU9Y29kZXIudHlwZStcIltcIisobGVuZ3RoPj0wP2xlbmd0aDpcIlwiKStcIl1cIjtjb25zdCBkeW5hbWljPWxlbmd0aD09PS0xfHxjb2Rlci5keW5hbWljO3N1cGVyKFwiYXJyYXlcIix0eXBlLGxvY2FsTmFtZSxkeW5hbWljKTt0aGlzLmNvZGVyPWNvZGVyO3RoaXMubGVuZ3RoPWxlbmd0aH1kZWZhdWx0VmFsdWUoKXtjb25zdCBkZWZhdWx0Q2hpbGQ9dGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtjb25zdCByZXN1bHQ9W107Zm9yKGxldCBpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3Jlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCl9cmV0dXJuIHJlc3VsdH1lbmNvZGUod3JpdGVyLHZhbHVlKXtpZighQXJyYXkuaXNBcnJheSh2YWx1ZSkpe3RoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLHZhbHVlKX1sZXQgY291bnQ9dGhpcy5sZW5ndGg7aWYoY291bnQ9PT0tMSl7Y291bnQ9dmFsdWUubGVuZ3RoO3dyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCl9bG9nZ2VyJDguY2hlY2tBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCxjb3VudCxcImNvZGVyIGFycmF5XCIrKHRoaXMubG9jYWxOYW1lP1wiIFwiK3RoaXMubG9jYWxOYW1lOlwiXCIpKTtsZXQgY29kZXJzPVtdO2ZvcihsZXQgaT0wO2k8dmFsdWUubGVuZ3RoO2krKyl7Y29kZXJzLnB1c2godGhpcy5jb2Rlcil9cmV0dXJuIHBhY2sod3JpdGVyLGNvZGVycyx2YWx1ZSl9ZGVjb2RlKHJlYWRlcil7bGV0IGNvdW50PXRoaXMubGVuZ3RoO2lmKGNvdW50PT09LTEpe2NvdW50PXJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpO2lmKGNvdW50KjMyPnJlYWRlci5fZGF0YS5sZW5ndGgpe2xvZ2dlciQ4LnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHtsZW5ndGg6cmVhZGVyLl9kYXRhLmxlbmd0aCxjb3VudDpjb3VudH0pfX1sZXQgY29kZXJzPVtdO2ZvcihsZXQgaT0wO2k8Y291bnQ7aSsrKXtjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpfXJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSx1bnBhY2socmVhZGVyLGNvZGVycykpfX1cInVzZSBzdHJpY3RcIjtjbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBDb2Rlcntjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpe3N1cGVyKFwiYm9vbFwiLFwiYm9vbFwiLGxvY2FsTmFtZSxmYWxzZSl9ZGVmYXVsdFZhbHVlKCl7cmV0dXJuIGZhbHNlfWVuY29kZSh3cml0ZXIsdmFsdWUpe3JldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZT8xOjApfWRlY29kZShyZWFkZXIpe3JldHVybiByZWFkZXIuY29lcmNlKHRoaXMudHlwZSwhcmVhZGVyLnJlYWRWYWx1ZSgpLmlzWmVybygpKX19XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2Rlcntjb25zdHJ1Y3Rvcih0eXBlLGxvY2FsTmFtZSl7c3VwZXIodHlwZSx0eXBlLGxvY2FsTmFtZSx0cnVlKX1kZWZhdWx0VmFsdWUoKXtyZXR1cm5cIjB4XCJ9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7dmFsdWU9YXJyYXlpZnkodmFsdWUpO2xldCBsZW5ndGg9d3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtsZW5ndGgrPXdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtyZXR1cm4gbGVuZ3RofWRlY29kZShyZWFkZXIpe3JldHVybiByZWFkZXIucmVhZEJ5dGVzKHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpLHRydWUpfX1jbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXJ7Y29uc3RydWN0b3IobG9jYWxOYW1lKXtzdXBlcihcImJ5dGVzXCIsbG9jYWxOYW1lKX1kZWNvZGUocmVhZGVyKXtyZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsaGV4bGlmeShzdXBlci5kZWNvZGUocmVhZGVyKSkpfX1cInVzZSBzdHJpY3RcIjtjbGFzcyBGaXhlZEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2Rlcntjb25zdHJ1Y3RvcihzaXplLGxvY2FsTmFtZSl7bGV0IG5hbWU9XCJieXRlc1wiK1N0cmluZyhzaXplKTtzdXBlcihuYW1lLG5hbWUsbG9jYWxOYW1lLGZhbHNlKTt0aGlzLnNpemU9c2l6ZX1kZWZhdWx0VmFsdWUoKXtyZXR1cm5cIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLnN1YnN0cmluZygwLDIrdGhpcy5zaXplKjIpfWVuY29kZSh3cml0ZXIsdmFsdWUpe2xldCBkYXRhPWFycmF5aWZ5KHZhbHVlKTtpZihkYXRhLmxlbmd0aCE9PXRoaXMuc2l6ZSl7dGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLHZhbHVlKX1yZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSl9ZGVjb2RlKHJlYWRlcil7cmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLGhleGxpZnkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKSl9fVwidXNlIHN0cmljdFwiO2NsYXNzIE51bGxDb2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKGxvY2FsTmFtZSl7c3VwZXIoXCJudWxsXCIsXCJcIixsb2NhbE5hbWUsZmFsc2UpfWRlZmF1bHRWYWx1ZSgpe3JldHVybiBudWxsfWVuY29kZSh3cml0ZXIsdmFsdWUpe2lmKHZhbHVlIT1udWxsKXt0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIix2YWx1ZSl9cmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKFtdKX1kZWNvZGUocmVhZGVyKXtyZWFkZXIucmVhZEJ5dGVzKDApO3JldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSxudWxsKX19Y29uc3QgQWRkcmVzc1plcm89XCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtjb25zdCBOZWdhdGl2ZU9uZSQxPUJpZ051bWJlci5mcm9tKC0xKTtjb25zdCBaZXJvJDE9QmlnTnVtYmVyLmZyb20oMCk7Y29uc3QgT25lPUJpZ051bWJlci5mcm9tKDEpO2NvbnN0IFR3bz1CaWdOdW1iZXIuZnJvbSgyKTtjb25zdCBXZWlQZXJFdGhlcj1CaWdOdW1iZXIuZnJvbShcIjEwMDAwMDAwMDAwMDAwMDAwMDBcIik7Y29uc3QgTWF4VWludDI1Nj1CaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtjb25zdCBIYXNoWmVybz1cIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO2NvbnN0IEV0aGVyU3ltYm9sPVwizp5cIjtcInVzZSBzdHJpY3RcIjt2YXIgaW5kZXgkMT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBZGRyZXNzWmVybzpBZGRyZXNzWmVybyxOZWdhdGl2ZU9uZTpOZWdhdGl2ZU9uZSQxLFplcm86WmVybyQxLE9uZTpPbmUsVHdvOlR3byxXZWlQZXJFdGhlcjpXZWlQZXJFdGhlcixNYXhVaW50MjU2Ok1heFVpbnQyNTYsSGFzaFplcm86SGFzaFplcm8sRXRoZXJTeW1ib2w6RXRoZXJTeW1ib2x9KTtcInVzZSBzdHJpY3RcIjtjbGFzcyBOdW1iZXJDb2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKHNpemUsc2lnbmVkLGxvY2FsTmFtZSl7Y29uc3QgbmFtZT0oc2lnbmVkP1wiaW50XCI6XCJ1aW50XCIpK3NpemUqODtzdXBlcihuYW1lLG5hbWUsbG9jYWxOYW1lLGZhbHNlKTt0aGlzLnNpemU9c2l6ZTt0aGlzLnNpZ25lZD1zaWduZWR9ZGVmYXVsdFZhbHVlKCl7cmV0dXJuIDB9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7bGV0IHY9QmlnTnVtYmVyLmZyb20odmFsdWUpO2xldCBtYXhVaW50VmFsdWU9TWF4VWludDI1Ni5tYXNrKHdyaXRlci53b3JkU2l6ZSo4KTtpZih0aGlzLnNpZ25lZCl7bGV0IGJvdW5kcz1tYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUqOC0xKTtpZih2Lmd0KGJvdW5kcyl8fHYubHQoYm91bmRzLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSQxKSkpe3RoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsdmFsdWUpfX1lbHNlIGlmKHYubHQoWmVybyQxKXx8di5ndChtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUqOCkpKXt0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLHZhbHVlKX12PXYudG9Ud29zKHRoaXMuc2l6ZSo4KS5tYXNrKHRoaXMuc2l6ZSo4KTtpZih0aGlzLnNpZ25lZCl7dj12LmZyb21Ud29zKHRoaXMuc2l6ZSo4KS50b1R3b3MoOCp3cml0ZXIud29yZFNpemUpfXJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2KX1kZWNvZGUocmVhZGVyKXtsZXQgdmFsdWU9cmVhZGVyLnJlYWRWYWx1ZSgpLm1hc2sodGhpcy5zaXplKjgpO2lmKHRoaXMuc2lnbmVkKXt2YWx1ZT12YWx1ZS5mcm9tVHdvcyh0aGlzLnNpemUqOCl9cmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLHZhbHVlKX19Y29uc3QgdmVyc2lvbiQ3PVwic3RyaW5ncy81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciQ5PW5ldyBMb2dnZXIodmVyc2lvbiQ3KTt2YXIgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtOyhmdW5jdGlvbihVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0pe1VuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl09XCJcIjtVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkNcIl09XCJORkNcIjtVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkRcIl09XCJORkRcIjtVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdPVwiTkZLQ1wiO1VuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0RcIl09XCJORktEXCJ9KShVbmljb2RlTm9ybWFsaXphdGlvbkZvcm18fChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm09e30pKTt2YXIgVXRmOEVycm9yUmVhc29uOyhmdW5jdGlvbihVdGY4RXJyb3JSZWFzb24pe1V0ZjhFcnJvclJlYXNvbltcIlVORVhQRUNURURfQ09OVElOVUVcIl09XCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7VXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXT1cImJhZCBjb2RlcG9pbnQgcHJlZml4XCI7VXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXT1cInN0cmluZyBvdmVycnVuXCI7VXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXT1cIm1pc3NpbmcgY29udGludWF0aW9uIGJ5dGVcIjtVdGY4RXJyb3JSZWFzb25bXCJPVVRfT0ZfUkFOR0VcIl09XCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtVdGY4RXJyb3JSZWFzb25bXCJVVEYxNl9TVVJST0dBVEVcIl09XCJVVEYtMTYgc3Vycm9nYXRlXCI7VXRmOEVycm9yUmVhc29uW1wiT1ZFUkxPTkdcIl09XCJvdmVybG9uZyByZXByZXNlbnRhdGlvblwifSkoVXRmOEVycm9yUmVhc29ufHwoVXRmOEVycm9yUmVhc29uPXt9KSk7ZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbixvZmZzZXQsYnl0ZXMsb3V0cHV0LGJhZENvZGVwb2ludCl7cmV0dXJuIGxvZ2dlciQ5LnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBjb2RlcG9pbnQgYXQgb2Zmc2V0ICR7b2Zmc2V0fTsgJHtyZWFzb259YCxcImJ5dGVzXCIsYnl0ZXMpfWZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLG9mZnNldCxieXRlcyxvdXRwdXQsYmFkQ29kZXBvaW50KXtpZihyZWFzb249PT1VdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWHx8cmVhc29uPT09VXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpe2xldCBpPTA7Zm9yKGxldCBvPW9mZnNldCsxO288Ynl0ZXMubGVuZ3RoO28rKyl7aWYoYnl0ZXNbb10+PjYhPT0yKXticmVha31pKyt9cmV0dXJuIGl9aWYocmVhc29uPT09VXRmOEVycm9yUmVhc29uLk9WRVJSVU4pe3JldHVybiBieXRlcy5sZW5ndGgtb2Zmc2V0LTF9cmV0dXJuIDB9ZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLG9mZnNldCxieXRlcyxvdXRwdXQsYmFkQ29kZXBvaW50KXtpZihyZWFzb249PT1VdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpe291dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7cmV0dXJuIDB9b3V0cHV0LnB1c2goNjU1MzMpO3JldHVybiBpZ25vcmVGdW5jKHJlYXNvbixvZmZzZXQsYnl0ZXMsb3V0cHV0LGJhZENvZGVwb2ludCl9Y29uc3QgVXRmOEVycm9yRnVuY3M9T2JqZWN0LmZyZWV6ZSh7ZXJyb3I6ZXJyb3JGdW5jLGlnbm9yZTppZ25vcmVGdW5jLHJlcGxhY2U6cmVwbGFjZUZ1bmN9KTtmdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcyxvbkVycm9yKXtpZihvbkVycm9yPT1udWxsKXtvbkVycm9yPVV0ZjhFcnJvckZ1bmNzLmVycm9yfWJ5dGVzPWFycmF5aWZ5KGJ5dGVzKTtjb25zdCByZXN1bHQ9W107bGV0IGk9MDt3aGlsZShpPGJ5dGVzLmxlbmd0aCl7Y29uc3QgYz1ieXRlc1tpKytdO2lmKGM+Pjc9PT0wKXtyZXN1bHQucHVzaChjKTtjb250aW51ZX1sZXQgZXh0cmFMZW5ndGg9bnVsbDtsZXQgb3ZlcmxvbmdNYXNrPW51bGw7aWYoKGMmMjI0KT09PTE5Mil7ZXh0cmFMZW5ndGg9MTtvdmVybG9uZ01hc2s9MTI3fWVsc2UgaWYoKGMmMjQwKT09PTIyNCl7ZXh0cmFMZW5ndGg9MjtvdmVybG9uZ01hc2s9MjA0N31lbHNlIGlmKChjJjI0OCk9PT0yNDApe2V4dHJhTGVuZ3RoPTM7b3ZlcmxvbmdNYXNrPTY1NTM1fWVsc2V7aWYoKGMmMTkyKT09PTEyOCl7aSs9b25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSxpLTEsYnl0ZXMscmVzdWx0KX1lbHNle2krPW9uRXJyb3IoVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVgsaS0xLGJ5dGVzLHJlc3VsdCl9Y29udGludWV9aWYoaS0xK2V4dHJhTGVuZ3RoPj1ieXRlcy5sZW5ndGgpe2krPW9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4saS0xLGJ5dGVzLHJlc3VsdCk7Y29udGludWV9bGV0IHJlcz1jJigxPDw4LWV4dHJhTGVuZ3RoLTEpLTE7Zm9yKGxldCBqPTA7ajxleHRyYUxlbmd0aDtqKyspe2xldCBuZXh0Q2hhcj1ieXRlc1tpXTtpZigobmV4dENoYXImMTkyKSE9MTI4KXtpKz1vbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLGksYnl0ZXMscmVzdWx0KTtyZXM9bnVsbDticmVha31yZXM9cmVzPDw2fG5leHRDaGFyJjYzO2krK31pZihyZXM9PT1udWxsKXtjb250aW51ZX1pZihyZXM+MTExNDExMSl7aSs9b25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLGktMS1leHRyYUxlbmd0aCxieXRlcyxyZXN1bHQscmVzKTtjb250aW51ZX1pZihyZXM+PTU1Mjk2JiZyZXM8PTU3MzQzKXtpKz1vbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VVEYxNl9TVVJST0dBVEUsaS0xLWV4dHJhTGVuZ3RoLGJ5dGVzLHJlc3VsdCxyZXMpO2NvbnRpbnVlfWlmKHJlczw9b3ZlcmxvbmdNYXNrKXtpKz1vbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORyxpLTEtZXh0cmFMZW5ndGgsYnl0ZXMscmVzdWx0LHJlcyk7Y29udGludWV9cmVzdWx0LnB1c2gocmVzKX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0cixmb3JtPVVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KXtpZihmb3JtIT1Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCl7bG9nZ2VyJDkuY2hlY2tOb3JtYWxpemUoKTtzdHI9c3RyLm5vcm1hbGl6ZShmb3JtKX1sZXQgcmVzdWx0PVtdO2ZvcihsZXQgaT0wO2k8c3RyLmxlbmd0aDtpKyspe2NvbnN0IGM9c3RyLmNoYXJDb2RlQXQoaSk7aWYoYzwxMjgpe3Jlc3VsdC5wdXNoKGMpfWVsc2UgaWYoYzwyMDQ4KXtyZXN1bHQucHVzaChjPj42fDE5Mik7cmVzdWx0LnB1c2goYyY2M3wxMjgpfWVsc2UgaWYoKGMmNjQ1MTIpPT01NTI5Nil7aSsrO2NvbnN0IGMyPXN0ci5jaGFyQ29kZUF0KGkpO2lmKGk+PXN0ci5sZW5ndGh8fChjMiY2NDUxMikhPT01NjMyMCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIil9Y29uc3QgcGFpcj02NTUzNisoKGMmMTAyMyk8PDEwKSsoYzImMTAyMyk7cmVzdWx0LnB1c2gocGFpcj4+MTh8MjQwKTtyZXN1bHQucHVzaChwYWlyPj4xMiY2M3wxMjgpO3Jlc3VsdC5wdXNoKHBhaXI+PjYmNjN8MTI4KTtyZXN1bHQucHVzaChwYWlyJjYzfDEyOCl9ZWxzZXtyZXN1bHQucHVzaChjPj4xMnwyMjQpO3Jlc3VsdC5wdXNoKGM+PjYmNjN8MTI4KTtyZXN1bHQucHVzaChjJjYzfDEyOCl9fXJldHVybiBhcnJheWlmeShyZXN1bHQpfWZ1bmN0aW9uIGVzY2FwZUNoYXIodmFsdWUpe2NvbnN0IGhleD1cIjAwMDBcIit2YWx1ZS50b1N0cmluZygxNik7cmV0dXJuXCJcXFxcdVwiK2hleC5zdWJzdHJpbmcoaGV4Lmxlbmd0aC00KX1mdW5jdGlvbiBfdG9Fc2NhcGVkVXRmOFN0cmluZyhieXRlcyxvbkVycm9yKXtyZXR1cm4nXCInK2dldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLG9uRXJyb3IpLm1hcChjb2RlUG9pbnQ9PntpZihjb2RlUG9pbnQ8MjU2KXtzd2l0Y2goY29kZVBvaW50KXtjYXNlIDg6cmV0dXJuXCJcXFxcYlwiO2Nhc2UgOTpyZXR1cm5cIlxcXFx0XCI7Y2FzZSAxMDpyZXR1cm5cIlxcXFxuXCI7Y2FzZSAxMzpyZXR1cm5cIlxcXFxyXCI7Y2FzZSAzNDpyZXR1cm4nXFxcXFwiJztjYXNlIDkyOnJldHVyblwiXFxcXFxcXFxcIn1pZihjb2RlUG9pbnQ+PTMyJiZjb2RlUG9pbnQ8MTI3KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpfX1pZihjb2RlUG9pbnQ8PTY1NTM1KXtyZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpfWNvZGVQb2ludC09NjU1MzY7cmV0dXJuIGVzY2FwZUNoYXIoKGNvZGVQb2ludD4+MTAmMTAyMykrNTUyOTYpK2VzY2FwZUNoYXIoKGNvZGVQb2ludCYxMDIzKSs1NjMyMCl9KS5qb2luKFwiXCIpKydcIid9ZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKXtyZXR1cm4gY29kZVBvaW50cy5tYXAoY29kZVBvaW50PT57aWYoY29kZVBvaW50PD02NTUzNSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KX1jb2RlUG9pbnQtPTY1NTM2O3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlUG9pbnQ+PjEwJjEwMjMpKzU1Mjk2LChjb2RlUG9pbnQmMTAyMykrNTYzMjApfSkuam9pbihcIlwiKX1mdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsb25FcnJvcil7cmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsb25FcnJvcikpfWZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLGZvcm09VW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpe3JldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsZm9ybSkpfVwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGZvcm1hdEJ5dGVzMzJTdHJpbmcodGV4dCl7Y29uc3QgYnl0ZXM9dG9VdGY4Qnl0ZXModGV4dCk7aWYoYnl0ZXMubGVuZ3RoPjMxKXt0aHJvdyBuZXcgRXJyb3IoXCJieXRlczMyIHN0cmluZyBtdXN0IGJlIGxlc3MgdGhhbiAzMiBieXRlc1wiKX1yZXR1cm4gaGV4bGlmeShjb25jYXQoW2J5dGVzLEhhc2haZXJvXSkuc2xpY2UoMCwzMikpfWZ1bmN0aW9uIHBhcnNlQnl0ZXMzMlN0cmluZyhieXRlcyl7Y29uc3QgZGF0YT1hcnJheWlmeShieXRlcyk7aWYoZGF0YS5sZW5ndGghPT0zMil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIC0gbm90IDMyIGJ5dGVzIGxvbmdcIil9aWYoZGF0YVszMV0hPT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgc3RyaW5nIC0gbm8gbnVsbCB0ZXJtaW5hdG9yXCIpfWxldCBsZW5ndGg9MzE7d2hpbGUoZGF0YVtsZW5ndGgtMV09PT0wKXtsZW5ndGgtLX1yZXR1cm4gdG9VdGY4U3RyaW5nKGRhdGEuc2xpY2UoMCxsZW5ndGgpKX1cInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBieXRlczIoZGF0YSl7aWYoZGF0YS5sZW5ndGglNCE9PTApe3Rocm93IG5ldyBFcnJvcihcImJhZCBkYXRhXCIpfWxldCByZXN1bHQ9W107Zm9yKGxldCBpPTA7aTxkYXRhLmxlbmd0aDtpKz00KXtyZXN1bHQucHVzaChwYXJzZUludChkYXRhLnN1YnN0cmluZyhpLGkrNCksMTYpKX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGRhdGEsZnVuYyl7aWYoIWZ1bmMpe2Z1bmM9ZnVuY3Rpb24odmFsdWUpe3JldHVybltwYXJzZUludCh2YWx1ZSwxNildfX1sZXQgbG89MDtsZXQgcmVzdWx0PXt9O2RhdGEuc3BsaXQoXCIsXCIpLmZvckVhY2gocGFpcj0+e2xldCBjb21wcz1wYWlyLnNwbGl0KFwiOlwiKTtsbys9cGFyc2VJbnQoY29tcHNbMF0sMTYpO3Jlc3VsdFtsb109ZnVuYyhjb21wc1sxXSl9KTtyZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIGNyZWF0ZVJhbmdlVGFibGUoZGF0YSl7bGV0IGhpPTA7cmV0dXJuIGRhdGEuc3BsaXQoXCIsXCIpLm1hcCh2PT57bGV0IGNvbXBzPXYuc3BsaXQoXCItXCIpO2lmKGNvbXBzLmxlbmd0aD09PTEpe2NvbXBzWzFdPVwiMFwifWVsc2UgaWYoY29tcHNbMV09PT1cIlwiKXtjb21wc1sxXT1cIjFcIn1sZXQgbG89aGkrcGFyc2VJbnQoY29tcHNbMF0sMTYpO2hpPXBhcnNlSW50KGNvbXBzWzFdLDE2KTtyZXR1cm57bDpsbyxoOmhpfX0pfWZ1bmN0aW9uIG1hdGNoTWFwKHZhbHVlLHJhbmdlcyl7bGV0IGxvPTA7Zm9yKGxldCBpPTA7aTxyYW5nZXMubGVuZ3RoO2krKyl7bGV0IHJhbmdlPXJhbmdlc1tpXTtsbys9cmFuZ2UubDtpZih2YWx1ZT49bG8mJnZhbHVlPD1sbytyYW5nZS5oJiYodmFsdWUtbG8pJShyYW5nZS5kfHwxKT09PTApe2lmKHJhbmdlLmUmJnJhbmdlLmUuaW5kZXhPZih2YWx1ZS1sbykhPT0tMSl7Y29udGludWV9cmV0dXJuIHJhbmdlfX1yZXR1cm4gbnVsbH1jb25zdCBUYWJsZV9BXzFfcmFuZ2VzPWNyZWF0ZVJhbmdlVGFibGUoXCIyMjEsMTMtMWIsNWYtLDQwLTEwLDUxLWYsMTEtMywzLTMsMi0yLDItNCw4LDIsMTUsMmQsMjgtOCw4OCw0OCwyNy0sMy01LDExLTIwLDI3LSw4LDI4LDMtNSwxMiwxOCxiLWEsMWMtNCw2LTE2LDItZCwyLTIsMiwxYi00LDE3LTksOGYtLDEwLGYsMWYtMiwxYy0zNCwzMy0xNGUsNCwzNi0sMTMtLDYtMiwxYS1mLDQsOS0sMy0sMTcsOCwyLTIsNS0sMiw4LSwzLSw0LTgsMi0zLDMsNi0sMTYtNiwyLSw3LTMsMy0sMTcsOCwzLDMsMy0sMiw2LTMsMy0sNC1hLDUsMi02LDEwLWIsNCw4LDIsNCwxNyw4LDMsNi0sYiw0LDQtLDItZSwyLTQsYi0xMCw0LDktLDMtLDE3LDgsMy0sNS0sOS0yLDMtLDQtNywzLTMsMyw0LTMsYy0xMCwzLDctMiw0LDUtMiwzLDIsMy0yLDMtMiw0LTIsOSw0LTMsNi0yLDQsNS04LDItZSxkLWQsNCw5LDQsMTgsYiw2LTMsOCw0LDUtNiwzLTgsMy0zLGItMTEsMyw5LDQsMTgsYiw2LTMsOCw0LDUtNiwzLTYsMiwzLTMsYi0xMSwzLDksNCwxOCwxMS0zLDctLDQsNS04LDItNywzLTMsYi0xMSwzLDEzLTIsMTksYSwyLSw4LTIsMi0zLDcsMiw5LTExLDQtYiwzYi0zLDFlLTI0LDMsMi0sMywyLSwyLTUsNSw4LDQsMiwyLSwzLGUsNC0sNiwyLDctLGItLDMtMjEsNDksMjMtNSwxYy0zLDksMjUsMTAtLDItMmYsMjMsNiwzLDgtMiw1LTUsMWItNDUsMjctOSwyYS0sMi0zLDViLTQsNDUtNCw1My01LDgsNDAsMiw1LSw4LDIsNS0sMjgsMiw1LSwyMCwyLDUtLDgsMiw1LSw4LDgsMTgsMjAsMiw1LSw4LDI4LDE0LTUsMWQtMjIsNTYtYiwyNzctOCwxZS0yLDUyLWUsZSw4LWEsMTgtOCwxNS1iLGUsNCwzLWIsNWUtMixiLTE1LDEwLGItNSw1OS03LDJiLTU1NSw5ZC0zLDViLTUsMTctLDctLDI3LSw3LSw5LDIsMiwyLDIwLSwzNiwxMCxmLSw3LDE0LSw0LGEsNTQtMywyLTYsNi01LDktLDFjLTEwLDEzLTFkLDFjLTE0LDNjLSwxMC02LDMyLWIsMjQwLTMwLDI4LTE4LGMtMTQsYTAsMTE1LSwzLDY2LSxiLTc2LDUsNS0sMWQsMjQsMiw1LTIsMiw4LSwzNS0yLDE5LGYtMTAsMWQtMywzMTEtMzdmLDFiLDVhLWIsZDctMTksZC0zLDQxLDU3LSw2OC00LDI5LTMsNWYsMjktMzcsMmUtMiwyNS1jLDJjLTIsNGUtMywzMCw3OC0zLDY0LSwyMCwxOWI3LTQ5LDUxYTctNTksNDhlLTIsMzgtNzM4LDJiYTUtNWIsMjIyZi0sM2MtOTQsOC1iLDYtNCwxYiw2LDIsMywzLDZkLTIwLDE2ZS1mLDQxLSwzNy03LDJlLTIsMTEtZiw1LWIsMTgtLGIsMTQsNS0zLDYsODgtLDIsYmYtMiw3LSw3LSw3LSw0LTIsOCw4LTksOC0yZmYsMjAsNS1iLDFjLWI0LDI3LSwyNy1jYmIxLGY3LTksMjgtMixiNS0yMjEsNTYsNDgsMy0sMi0sMy0sNSxkLDIsNSwzLDQyLDUtLDksOCwxZCw1LDYsMi0yLDgsMTUzLTMsMTIzLTMsMzMtMjdmZCxhNmRhLTUxMjgsMjFmLTVkZiwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMsMi0xZCw2MS1mZjdkXCIpO2NvbnN0IFRhYmxlX0JfMV9mbGFncz1cImFkLDM0ZiwxODA2LDE4MGIsMTgwYywxODBkLDIwMGIsMjAwYywyMDBkLDIwNjAsZmVmZlwiLnNwbGl0KFwiLFwiKS5tYXAodj0+cGFyc2VJbnQodiwxNikpO2NvbnN0IFRhYmxlX0JfMl9yYW5nZXM9W3toOjI1LHM6MzIsbDo2NX0se2g6MzAsczozMixlOlsyM10sbDoxMjd9LHtoOjU0LHM6MSxlOls0OF0sbDo2NCxkOjJ9LHtoOjE0LHM6MSxsOjU3LGQ6Mn0se2g6NDQsczoxLGw6MTcsZDoyfSx7aDoxMCxzOjEsZTpbMiw2LDhdLGw6NjEsZDoyfSx7aDoxNixzOjEsbDo2OCxkOjJ9LHtoOjg0LHM6MSxlOlsxOCwyNCw2Nl0sbDoxOSxkOjJ9LHtoOjI2LHM6MzIsZTpbMTddLGw6NDM1fSx7aDoyMixzOjEsbDo3MSxkOjJ9LHtoOjE1LHM6ODAsbDo0MH0se2g6MzEsczozMixsOjE2fSx7aDozMixzOjEsbDo4MCxkOjJ9LHtoOjUyLHM6MSxsOjQyLGQ6Mn0se2g6MTIsczoxLGw6NTUsZDoyfSx7aDo0MCxzOjEsZTpbMzhdLGw6MTUsZDoyfSx7aDoxNCxzOjEsbDo0OCxkOjJ9LHtoOjM3LHM6NDgsbDo0OX0se2g6MTQ4LHM6MSxsOjYzNTEsZDoyfSx7aDo4OCxzOjEsbDoxNjAsZDoyfSx7aDoxNSxzOjE2LGw6NzA0fSx7aDoyNSxzOjI2LGw6ODU0fSx7aDoyNSxzOjMyLGw6NTU5MTV9LHtoOjM3LHM6NDAsbDoxMjQ3fSx7aDoyNSxzOi0xMTk3MTEsbDo1MzI0OH0se2g6MjUsczotMTE5NzYzLGw6NTJ9LHtoOjI1LHM6LTExOTgxNSxsOjUyfSx7aDoyNSxzOi0xMTk4NjcsZTpbMSw0LDUsNyw4LDExLDEyLDE3XSxsOjUyfSx7aDoyNSxzOi0xMTk5MTksbDo1Mn0se2g6MjQsczotMTE5OTcxLGU6WzIsNyw4LDE3XSxsOjUyfSx7aDoyNCxzOi0xMjAwMjMsZTpbMiw3LDEzLDE1LDE2LDE3XSxsOjUyfSx7aDoyNSxzOi0xMjAwNzUsbDo1Mn0se2g6MjUsczotMTIwMTI3LGw6NTJ9LHtoOjI1LHM6LTEyMDE3OSxsOjUyfSx7aDoyNSxzOi0xMjAyMzEsbDo1Mn0se2g6MjUsczotMTIwMjgzLGw6NTJ9LHtoOjI1LHM6LTEyMDMzNSxsOjUyfSx7aDoyNCxzOi0xMTk1NDMsZTpbMTddLGw6NTZ9LHtoOjI0LHM6LTExOTYwMSxlOlsxN10sbDo1OH0se2g6MjQsczotMTE5NjU5LGU6WzE3XSxsOjU4fSx7aDoyNCxzOi0xMTk3MTcsZTpbMTddLGw6NTh9LHtoOjI0LHM6LTExOTc3NSxlOlsxN10sbDo1OH1dO2NvbnN0IFRhYmxlX0JfMl9sdXRfYWJzPWNyZWF0ZVRhYmxlKFwiYjU6M2JjLGMzOmZmLDc6NzMsMjoyNTMsNToyNTQsMzoyNTYsMToyNTcsNToyNTksMToyNWIsMzoyNjAsMToyNjMsMjoyNjksMToyNjgsNToyNmYsMToyNzIsMjoyNzUsNzoyODAsMzoyODMsNToyODgsMzoyOGEsMToyOGIsNToyOTIsM2Y6MTk1LDE6MWJmLDI5OjE5ZSwxMjU6M2I5LDhiOjNiMiwxOjNiOCwxOjNjNSwzOjNjNiwxOjNjMCwxYTozYmEsMTozYzEsMTozYzMsMjozYjgsMTozYjUsMWJjOTozYjksMWM6MWY3NiwxOjFmNzcsZjoxZjdhLDE6MWY3YixkOjFmNzgsMToxZjc5LDE6MWY3YywxOjFmN2QsMTA3OjYzLDU6MjViLDQ6NjgsMTo2OCwxOjY4LDM6NjksMTo2OSwxOjZjLDM6NmUsNDo3MCwxOjcxLDE6NzIsMTo3MiwxOjcyLDc6N2EsMjozYzksMjo3YSwyOjZiLDE6ZTUsMTo2MiwxOjYzLDM6NjUsMTo2NiwyOjZkLGI6M2IzLDE6M2MwLDY6NjQsMWI1NzQ6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzXCIpO2NvbnN0IFRhYmxlX0JfMl9sdXRfcmVsPWNyZWF0ZVRhYmxlKFwiMTc5OjEsMjoxLDI6MSw1OjEsMjoxLGE6NGYsYToxLDg6MSwyOjEsMjoxLDM6MSw1OjEsMzoxLDQ6MSwyOjEsMzoxLDQ6MSw4OjIsMToxLDI6MiwxOjEsMjoyLDI3OjIsMTk1OjI2LDI6MjUsMToyNSwxOjI1LDI6NDAsMjozZiwxOjNmLDMzOjEsMTE6LTYsMTotOSwxYWM3Oi0zYSw2ZDotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LGI6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYzotOCwyOi04LDI6LTgsMjotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsNDk6LTgsMTotOCwxOi00YSwxOi00YSxkOi01NiwxOi01NiwxOi01NiwxOi01NixkOi04LDE6LTgsZjotOCwxOi04LDM6LTdcIik7Y29uc3QgVGFibGVfQl8yX2NvbXBsZXg9Y3JlYXRlVGFibGUoXCJkZjowMDczMDA3Myw1MTowMDY5MDMwNywxOTowMkJDMDA2RSxhNzowMDZBMDMwQywxOGE6MDAyMDAzQjksMTY6MDNCOTAzMDgwMzAxLDIwOjAzQzUwMzA4MDMwMSwxZDc6MDU2NTA1ODIsMTkwZjowMDY4MDMzMSwxOjAwNzQwMzA4LDE6MDA3NzAzMEEsMTowMDc5MDMwQSwxOjAwNjEwMkJFLGI2OjAzQzUwMzEzLDI6MDNDNTAzMTMwMzAwLDI6MDNDNTAzMTMwMzAxLDI6MDNDNTAzMTMwMzQyLDJhOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjAwMDNCOSwxOjFGMDEwM0I5LDE6MUYwMjAzQjksMToxRjAzMDNCOSwxOjFGMDQwM0I5LDE6MUYwNTAzQjksMToxRjA2MDNCOSwxOjFGMDcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGMjAwM0I5LDE6MUYyMTAzQjksMToxRjIyMDNCOSwxOjFGMjMwM0I5LDE6MUYyNDAzQjksMToxRjI1MDNCOSwxOjFGMjYwM0I5LDE6MUYyNzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDE6MUY2MDAzQjksMToxRjYxMDNCOSwxOjFGNjIwM0I5LDE6MUY2MzAzQjksMToxRjY0MDNCOSwxOjFGNjUwM0I5LDE6MUY2NjAzQjksMToxRjY3MDNCOSwzOjFGNzAwM0I5LDE6MDNCMTAzQjksMTowM0FDMDNCOSwyOjAzQjEwMzQyLDE6MDNCMTAzNDIwM0I5LDU6MDNCMTAzQjksNjoxRjc0MDNCOSwxOjAzQjcwM0I5LDE6MDNBRTAzQjksMjowM0I3MDM0MiwxOjAzQjcwMzQyMDNCOSw1OjAzQjcwM0I5LDY6MDNCOTAzMDgwMzAwLDE6MDNCOTAzMDgwMzAxLDM6MDNCOTAzNDIsMTowM0I5MDMwODAzNDIsYjowM0M1MDMwODAzMDAsMTowM0M1MDMwODAzMDEsMTowM0MxMDMxMywyOjAzQzUwMzQyLDE6MDNDNTAzMDgwMzQyLGI6MUY3QzAzQjksMTowM0M5MDNCOSwxOjAzQ0UwM0I5LDI6MDNDOTAzNDIsMTowM0M5MDM0MjAzQjksNTowM0M5MDNCOSxhYzowMDcyMDA3Myw1YjowMEIwMDA2Myw2OjAwQjAwMDY2LGQ6MDA2RTAwNkYsYTowMDczMDA2RCwxOjAwNzQwMDY1MDA2QywxOjAwNzQwMDZELDEyNGY6MDA2ODAwNzAwMDYxLDI6MDA2MTAwNzUsMjowMDZGMDA3NixiOjAwNzAwMDYxLDE6MDA2RTAwNjEsMTowM0JDMDA2MSwxOjAwNkQwMDYxLDE6MDA2QjAwNjEsMTowMDZCMDA2MiwxOjAwNkQwMDYyLDE6MDA2NzAwNjIsMzowMDcwMDA2NiwxOjAwNkUwMDY2LDE6MDNCQzAwNjYsNDowMDY4MDA3QSwxOjAwNkIwMDY4MDA3QSwxOjAwNkQwMDY4MDA3QSwxOjAwNjcwMDY4MDA3QSwxOjAwNzQwMDY4MDA3QSwxNTowMDcwMDA2MSwxOjAwNkIwMDcwMDA2MSwxOjAwNkQwMDcwMDA2MSwxOjAwNjcwMDcwMDA2MSw4OjAwNzAwMDc2LDE6MDA2RTAwNzYsMTowM0JDMDA3NiwxOjAwNkQwMDc2LDE6MDA2QjAwNzYsMTowMDZEMDA3NiwxOjAwNzAwMDc3LDE6MDA2RTAwNzcsMTowM0JDMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAwNzcsMTowMDZEMDA3NywxOjAwNkIwM0M5LDE6MDA2RDAzQzksMjowMDYyMDA3MSwzOjAwNjMyMjE1MDA2QjAwNjcsMTowMDYzMDA2RjAwMkUsMTowMDY0MDA2MiwxOjAwNjcwMDc5LDI6MDA2ODAwNzAsMjowMDZCMDA2QiwxOjAwNkIwMDZELDk6MDA3MDAwNjgsMjowMDcwMDA3MDAwNkQsMTowMDcwMDA3MiwyOjAwNzMwMDc2LDE6MDA3NzAwNjIsYzcyMzowMDY2MDA2NiwxOjAwNjYwMDY5LDE6MDA2NjAwNkMsMTowMDY2MDA2NjAwNjksMTowMDY2MDA2NjAwNkMsMTowMDczMDA3NCwxOjAwNzMwMDc0LGQ6MDU3NDA1NzYsMTowNTc0MDU2NSwxOjA1NzQwNTZCLDE6MDU3RTA1NzYsMTowNTc0MDU2RFwiLGJ5dGVzMik7Y29uc3QgVGFibGVfQ19yYW5nZXM9Y3JlYXRlUmFuZ2VUYWJsZShcIjgwLTIwLDJhMC0sMzljLDMyLGY3MSwxOGUsN2YyLWYsMTktNywzMC00LDctNSxmODEtYiw1LGE4MDAtMjBmZiw0ZDEtMWYsMTEwLGZhLTYsZDE3NC03LDJlODQtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLDIsMWYtNWYsZmY3Zi0yMDAwMVwiKTtmdW5jdGlvbiBmbGF0dGVuKHZhbHVlcyl7cmV0dXJuIHZhbHVlcy5yZWR1Y2UoKGFjY3VtLHZhbHVlKT0+e3ZhbHVlLmZvckVhY2godmFsdWU9PnthY2N1bS5wdXNoKHZhbHVlKX0pO3JldHVybiBhY2N1bX0sW10pfWZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQTEoY29kZXBvaW50KXtyZXR1cm4hIW1hdGNoTWFwKGNvZGVwb2ludCxUYWJsZV9BXzFfcmFuZ2VzKX1mdW5jdGlvbiBfbmFtZXByZXBUYWJsZUIyKGNvZGVwb2ludCl7bGV0IHJhbmdlPW1hdGNoTWFwKGNvZGVwb2ludCxUYWJsZV9CXzJfcmFuZ2VzKTtpZihyYW5nZSl7cmV0dXJuW2NvZGVwb2ludCtyYW5nZS5zXX1sZXQgY29kZXM9VGFibGVfQl8yX2x1dF9hYnNbY29kZXBvaW50XTtpZihjb2Rlcyl7cmV0dXJuIGNvZGVzfWxldCBzaGlmdD1UYWJsZV9CXzJfbHV0X3JlbFtjb2RlcG9pbnRdO2lmKHNoaWZ0KXtyZXR1cm5bY29kZXBvaW50K3NoaWZ0WzBdXX1sZXQgY29tcGxleD1UYWJsZV9CXzJfY29tcGxleFtjb2RlcG9pbnRdO2lmKGNvbXBsZXgpe3JldHVybiBjb21wbGV4fXJldHVybiBudWxsfWZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQyhjb2RlcG9pbnQpe3JldHVybiEhbWF0Y2hNYXAoY29kZXBvaW50LFRhYmxlX0NfcmFuZ2VzKX1mdW5jdGlvbiBuYW1lcHJlcCh2YWx1ZSl7aWYodmFsdWUubWF0Y2goL15bYS16MC05LV0qJC9pKSYmdmFsdWUubGVuZ3RoPD01OSl7cmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCl9bGV0IGNvZGVzPXRvVXRmOENvZGVQb2ludHModmFsdWUpO2NvZGVzPWZsYXR0ZW4oY29kZXMubWFwKGNvZGU9PntpZihUYWJsZV9CXzFfZmxhZ3MuaW5kZXhPZihjb2RlKT49MCl7cmV0dXJuW119aWYoY29kZT49NjUwMjQmJmNvZGU8PTY1MDM5KXtyZXR1cm5bXX1sZXQgY29kZXNUYWJsZUIyPV9uYW1lcHJlcFRhYmxlQjIoY29kZSk7aWYoY29kZXNUYWJsZUIyKXtyZXR1cm4gY29kZXNUYWJsZUIyfXJldHVybltjb2RlXX0pKTtjb2Rlcz10b1V0ZjhDb2RlUG9pbnRzKF90b1V0ZjhTdHJpbmcoY29kZXMpLFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktDKTtjb2Rlcy5mb3JFYWNoKGNvZGU9PntpZihfbmFtZXByZXBUYWJsZUMoY29kZSkpe3Rocm93IG5ldyBFcnJvcihcIlNUUklOR1BSRVBfQ09OVEFJTlNfUFJPSElCSVRFRFwiKX19KTtjb2Rlcy5mb3JFYWNoKGNvZGU9PntpZihfbmFtZXByZXBUYWJsZUExKGNvZGUpKXt0aHJvdyBuZXcgRXJyb3IoXCJTVFJJTkdQUkVQX0NPTlRBSU5TX1VOQVNTSUdORURcIil9fSk7bGV0IG5hbWU9X3RvVXRmOFN0cmluZyhjb2Rlcyk7aWYobmFtZS5zdWJzdHJpbmcoMCwxKT09PVwiLVwifHxuYW1lLnN1YnN0cmluZygyLDQpPT09XCItLVwifHxuYW1lLnN1YnN0cmluZyhuYW1lLmxlbmd0aC0xKT09PVwiLVwiKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGh5cGhlblwiKX1pZihuYW1lLmxlbmd0aD42Myl7dGhyb3cgbmV3IEVycm9yKFwidG9vIGxvbmdcIil9cmV0dXJuIG5hbWV9XCJ1c2Ugc3RyaWN0XCI7XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgU3RyaW5nQ29kZXIgZXh0ZW5kcyBEeW5hbWljQnl0ZXNDb2Rlcntjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpe3N1cGVyKFwic3RyaW5nXCIsbG9jYWxOYW1lKX1kZWZhdWx0VmFsdWUoKXtyZXR1cm5cIlwifWVuY29kZSh3cml0ZXIsdmFsdWUpe3JldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLHRvVXRmOEJ5dGVzKHZhbHVlKSl9ZGVjb2RlKHJlYWRlcil7cmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSl9fVwidXNlIHN0cmljdFwiO2NsYXNzIFR1cGxlQ29kZXIgZXh0ZW5kcyBDb2Rlcntjb25zdHJ1Y3Rvcihjb2RlcnMsbG9jYWxOYW1lKXtsZXQgZHluYW1pYz1mYWxzZTtjb25zdCB0eXBlcz1bXTtjb2RlcnMuZm9yRWFjaChjb2Rlcj0+e2lmKGNvZGVyLmR5bmFtaWMpe2R5bmFtaWM9dHJ1ZX10eXBlcy5wdXNoKGNvZGVyLnR5cGUpfSk7Y29uc3QgdHlwZT1cInR1cGxlKFwiK3R5cGVzLmpvaW4oXCIsXCIpK1wiKVwiO3N1cGVyKFwidHVwbGVcIix0eXBlLGxvY2FsTmFtZSxkeW5hbWljKTt0aGlzLmNvZGVycz1jb2RlcnN9ZGVmYXVsdFZhbHVlKCl7Y29uc3QgdmFsdWVzPVtdO3RoaXMuY29kZXJzLmZvckVhY2goY29kZXI9Pnt2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSl9KTtjb25zdCB1bmlxdWVOYW1lcz10aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLGNvZGVyKT0+e2NvbnN0IG5hbWU9Y29kZXIubG9jYWxOYW1lO2lmKG5hbWUpe2lmKCFhY2N1bVtuYW1lXSl7YWNjdW1bbmFtZV09MH1hY2N1bVtuYW1lXSsrfXJldHVybiBhY2N1bX0se30pO3RoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLGluZGV4KT0+e2xldCBuYW1lPWNvZGVyLmxvY2FsTmFtZTtpZighbmFtZXx8dW5pcXVlTmFtZXNbbmFtZV0hPT0xKXtyZXR1cm59aWYobmFtZT09PVwibGVuZ3RoXCIpe25hbWU9XCJfbGVuZ3RoXCJ9aWYodmFsdWVzW25hbWVdIT1udWxsKXtyZXR1cm59dmFsdWVzW25hbWVdPXZhbHVlc1tpbmRleF19KTtyZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpfWVuY29kZSh3cml0ZXIsdmFsdWUpe3JldHVybiBwYWNrKHdyaXRlcix0aGlzLmNvZGVycyx2YWx1ZSl9ZGVjb2RlKHJlYWRlcil7cmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLHVucGFjayhyZWFkZXIsdGhpcy5jb2RlcnMpKX19XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJGE9bmV3IExvZ2dlcih2ZXJzaW9uJDQpO2NvbnN0IHBhcmFtVHlwZUJ5dGVzPW5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO2NvbnN0IHBhcmFtVHlwZU51bWJlcj1uZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO2NsYXNzIEFiaUNvZGVye2NvbnN0cnVjdG9yKGNvZXJjZUZ1bmMpe2xvZ2dlciRhLmNoZWNrTmV3KG5ldy50YXJnZXQsQWJpQ29kZXIpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJjb2VyY2VGdW5jXCIsY29lcmNlRnVuY3x8bnVsbCl9X2dldENvZGVyKHBhcmFtKXtzd2l0Y2gocGFyYW0uYmFzZVR5cGUpe2Nhc2VcImFkZHJlc3NcIjpyZXR1cm4gbmV3IEFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtjYXNlXCJib29sXCI6cmV0dXJuIG5ldyBCb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIG5ldyBTdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtjYXNlXCJieXRlc1wiOnJldHVybiBuZXcgQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtjYXNlXCJhcnJheVwiOnJldHVybiBuZXcgQXJyYXlDb2Rlcih0aGlzLl9nZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSxwYXJhbS5hcnJheUxlbmd0aCxwYXJhbS5uYW1lKTtjYXNlXCJ0dXBsZVwiOnJldHVybiBuZXcgVHVwbGVDb2RlcigocGFyYW0uY29tcG9uZW50c3x8W10pLm1hcChjb21wb25lbnQ9PntyZXR1cm4gdGhpcy5fZ2V0Q29kZXIoY29tcG9uZW50KX0pLHBhcmFtLm5hbWUpO2Nhc2VcIlwiOnJldHVybiBuZXcgTnVsbENvZGVyKHBhcmFtLm5hbWUpfWxldCBtYXRjaD1wYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7aWYobWF0Y2gpe2xldCBzaXplPXBhcnNlSW50KG1hdGNoWzJdfHxcIjI1NlwiKTtpZihzaXplPT09MHx8c2l6ZT4yNTZ8fHNpemUlOCE9PTApe2xvZ2dlciRhLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgXCIrbWF0Y2hbMV0rXCIgYml0IGxlbmd0aFwiLFwicGFyYW1cIixwYXJhbSl9cmV0dXJuIG5ldyBOdW1iZXJDb2RlcihzaXplLzgsbWF0Y2hbMV09PT1cImludFwiLHBhcmFtLm5hbWUpfW1hdGNoPXBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO2lmKG1hdGNoKXtsZXQgc2l6ZT1wYXJzZUludChtYXRjaFsxXSk7aWYoc2l6ZT09PTB8fHNpemU+MzIpe2xvZ2dlciRhLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsXCJwYXJhbVwiLHBhcmFtKX1yZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLHBhcmFtLm5hbWUpfXJldHVybiBsb2dnZXIkYS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR5cGVcIixcInR5cGVcIixwYXJhbS50eXBlKX1fZ2V0V29yZFNpemUoKXtyZXR1cm4gMzJ9X2dldFJlYWRlcihkYXRhLGFsbG93TG9vc2Upe3JldHVybiBuZXcgUmVhZGVyKGRhdGEsdGhpcy5fZ2V0V29yZFNpemUoKSx0aGlzLmNvZXJjZUZ1bmMsYWxsb3dMb29zZSl9X2dldFdyaXRlcigpe3JldHVybiBuZXcgV3JpdGVyKHRoaXMuX2dldFdvcmRTaXplKCkpfWdldERlZmF1bHRWYWx1ZSh0eXBlcyl7Y29uc3QgY29kZXJzPXR5cGVzLm1hcCh0eXBlPT50aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO2NvbnN0IGNvZGVyPW5ldyBUdXBsZUNvZGVyKGNvZGVycyxcIl9cIik7cmV0dXJuIGNvZGVyLmRlZmF1bHRWYWx1ZSgpfWVuY29kZSh0eXBlcyx2YWx1ZXMpe2lmKHR5cGVzLmxlbmd0aCE9PXZhbHVlcy5sZW5ndGgpe2xvZ2dlciRhLnRocm93RXJyb3IoXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIsTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULHtjb3VudDp7dHlwZXM6dHlwZXMubGVuZ3RoLHZhbHVlczp2YWx1ZXMubGVuZ3RofSx2YWx1ZTp7dHlwZXM6dHlwZXMsdmFsdWVzOnZhbHVlc319KX1jb25zdCBjb2RlcnM9dHlwZXMubWFwKHR5cGU9PnRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7Y29uc3QgY29kZXI9bmV3IFR1cGxlQ29kZXIoY29kZXJzLFwiX1wiKTtjb25zdCB3cml0ZXI9dGhpcy5fZ2V0V3JpdGVyKCk7Y29kZXIuZW5jb2RlKHdyaXRlcix2YWx1ZXMpO3JldHVybiB3cml0ZXIuZGF0YX1kZWNvZGUodHlwZXMsZGF0YSxsb29zZSl7Y29uc3QgY29kZXJzPXR5cGVzLm1hcCh0eXBlPT50aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO2NvbnN0IGNvZGVyPW5ldyBUdXBsZUNvZGVyKGNvZGVycyxcIl9cIik7cmV0dXJuIGNvZGVyLmRlY29kZSh0aGlzLl9nZXRSZWFkZXIoYXJyYXlpZnkoZGF0YSksbG9vc2UpKX19Y29uc3QgZGVmYXVsdEFiaUNvZGVyPW5ldyBBYmlDb2RlcjtmdW5jdGlvbiBpZCh0ZXh0KXtyZXR1cm4ga2VjY2FrMjU2KHRvVXRmOEJ5dGVzKHRleHQpKX1jb25zdCB2ZXJzaW9uJDg9XCJoYXNoLzUuMS4wXCI7Y29uc3QgbG9nZ2VyJGI9bmV3IExvZ2dlcih2ZXJzaW9uJDgpO2NvbnN0IFplcm9zPW5ldyBVaW50OEFycmF5KDMyKTtaZXJvcy5maWxsKDApO2NvbnN0IFBhcnRpdGlvbj1uZXcgUmVnRXhwKFwiXigoLiopXFxcXC4pPyhbXi5dKykkXCIpO2Z1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpe3RyeXtjb25zdCBjb21wcz1uYW1lLnNwbGl0KFwiLlwiKTtmb3IobGV0IGk9MDtpPGNvbXBzLmxlbmd0aDtpKyspe2lmKG5hbWVwcmVwKGNvbXBzW2ldKS5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eVwiKX19cmV0dXJuIHRydWV9Y2F0Y2goZXJyb3Ipe31yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gbmFtZWhhc2gobmFtZSl7aWYodHlwZW9mIG5hbWUhPT1cInN0cmluZ1wiKXtsb2dnZXIkYi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3MgLSBcIitTdHJpbmcobmFtZSksXCJuYW1lXCIsbmFtZSl9bGV0IHJlc3VsdD1aZXJvczt3aGlsZShuYW1lLmxlbmd0aCl7Y29uc3QgcGFydGl0aW9uPW5hbWUubWF0Y2goUGFydGl0aW9uKTtjb25zdCBsYWJlbD10b1V0ZjhCeXRlcyhuYW1lcHJlcChwYXJ0aXRpb25bM10pKTtyZXN1bHQ9a2VjY2FrMjU2KGNvbmNhdChbcmVzdWx0LGtlY2NhazI1NihsYWJlbCldKSk7bmFtZT1wYXJ0aXRpb25bMl18fFwiXCJ9cmV0dXJuIGhleGxpZnkocmVzdWx0KX1jb25zdCBtZXNzYWdlUHJlZml4PVwiXHUwMDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCI7ZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSl7aWYodHlwZW9mIG1lc3NhZ2U9PT1cInN0cmluZ1wiKXttZXNzYWdlPXRvVXRmOEJ5dGVzKG1lc3NhZ2UpfXJldHVybiBrZWNjYWsyNTYoY29uY2F0KFt0b1V0ZjhCeXRlcyhtZXNzYWdlUHJlZml4KSx0b1V0ZjhCeXRlcyhTdHJpbmcobWVzc2FnZS5sZW5ndGgpKSxtZXNzYWdlXSkpfXZhciBfX2F3YWl0ZXIkMT13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJGM9bmV3IExvZ2dlcih2ZXJzaW9uJDgpO2NvbnN0IHBhZGRpbmc9bmV3IFVpbnQ4QXJyYXkoMzIpO3BhZGRpbmcuZmlsbCgwKTtjb25zdCBOZWdhdGl2ZU9uZSQyPUJpZ051bWJlci5mcm9tKC0xKTtjb25zdCBaZXJvJDI9QmlnTnVtYmVyLmZyb20oMCk7Y29uc3QgT25lJDE9QmlnTnVtYmVyLmZyb20oMSk7Y29uc3QgTWF4VWludDI1NiQxPUJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO2Z1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKXtjb25zdCBieXRlcz1hcnJheWlmeSh2YWx1ZSk7Y29uc3QgcGFkT2Zmc2V0PWJ5dGVzLmxlbmd0aCUzMjtpZihwYWRPZmZzZXQpe3JldHVybiBoZXhDb25jYXQoW2J5dGVzLHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pfXJldHVybiBoZXhsaWZ5KGJ5dGVzKX1jb25zdCBoZXhUcnVlPWhleFplcm9QYWQoT25lJDEudG9IZXhTdHJpbmcoKSwzMik7Y29uc3QgaGV4RmFsc2U9aGV4WmVyb1BhZChaZXJvJDIudG9IZXhTdHJpbmcoKSwzMik7Y29uc3QgZG9tYWluRmllbGRUeXBlcz17bmFtZTpcInN0cmluZ1wiLHZlcnNpb246XCJzdHJpbmdcIixjaGFpbklkOlwidWludDI1NlwiLHZlcmlmeWluZ0NvbnRyYWN0OlwiYWRkcmVzc1wiLHNhbHQ6XCJieXRlczMyXCJ9O2NvbnN0IGRvbWFpbkZpZWxkTmFtZXM9W1wibmFtZVwiLFwidmVyc2lvblwiLFwiY2hhaW5JZFwiLFwidmVyaWZ5aW5nQ29udHJhY3RcIixcInNhbHRcIl07ZnVuY3Rpb24gY2hlY2tTdHJpbmcoa2V5KXtyZXR1cm4gZnVuY3Rpb24odmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PVwic3RyaW5nXCIpe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLGBkb21haW4uJHtrZXl9YCx2YWx1ZSl9cmV0dXJuIHZhbHVlfX1jb25zdCBkb21haW5DaGVja3M9e25hbWU6Y2hlY2tTdHJpbmcoXCJuYW1lXCIpLHZlcnNpb246Y2hlY2tTdHJpbmcoXCJ2ZXJzaW9uXCIpLGNoYWluSWQ6ZnVuY3Rpb24odmFsdWUpe3RyeXtyZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCl9Y2F0Y2goZXJyb3Ipe31yZXR1cm4gbG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgXCJjaGFpbklkXCJgLFwiZG9tYWluLmNoYWluSWRcIix2YWx1ZSl9LHZlcmlmeWluZ0NvbnRyYWN0OmZ1bmN0aW9uKHZhbHVlKXt0cnl7cmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCl9Y2F0Y2goZXJyb3Ipe31yZXR1cm4gbG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsdmFsdWUpfSxzYWx0OmZ1bmN0aW9uKHZhbHVlKXt0cnl7Y29uc3QgYnl0ZXM9YXJyYXlpZnkodmFsdWUpO2lmKGJ5dGVzLmxlbmd0aCE9PTMyKXt0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbGVuZ3RoXCIpfXJldHVybiBoZXhsaWZ5KGJ5dGVzKX1jYXRjaChlcnJvcil7fXJldHVybiBsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCxcImRvbWFpbi5zYWx0XCIsdmFsdWUpfX07ZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSl7e2NvbnN0IG1hdGNoPXR5cGUubWF0Y2goL14odT8paW50KFxcZCopJC8pO2lmKG1hdGNoKXtjb25zdCBzaWduZWQ9bWF0Y2hbMV09PT1cIlwiO2NvbnN0IHdpZHRoPXBhcnNlSW50KG1hdGNoWzJdfHxcIjI1NlwiKTtpZih3aWR0aCU4IT09MHx8d2lkdGg+MjU2fHxtYXRjaFsyXSYmbWF0Y2hbMl0hPT1TdHJpbmcod2lkdGgpKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIixcInR5cGVcIix0eXBlKX1jb25zdCBib3VuZHNVcHBlcj1NYXhVaW50MjU2JDEubWFzayhzaWduZWQ/d2lkdGgtMTp3aWR0aCk7Y29uc3QgYm91bmRzTG93ZXI9c2lnbmVkP2JvdW5kc1VwcGVyLmFkZChPbmUkMSkubXVsKE5lZ2F0aXZlT25lJDIpOlplcm8kMjtyZXR1cm4gZnVuY3Rpb24odmFsdWUpe2NvbnN0IHY9QmlnTnVtYmVyLmZyb20odmFsdWUpO2lmKHYubHQoYm91bmRzTG93ZXIpfHx2Lmd0KGJvdW5kc1VwcGVyKSl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGB2YWx1ZSBvdXQtb2YtYm91bmRzIGZvciAke3R5cGV9YCxcInZhbHVlXCIsdmFsdWUpfXJldHVybiBoZXhaZXJvUGFkKHYudG9Ud29zKDI1NikudG9IZXhTdHJpbmcoKSwzMil9fX17Y29uc3QgbWF0Y2g9dHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO2lmKG1hdGNoKXtjb25zdCB3aWR0aD1wYXJzZUludChtYXRjaFsxXSk7aWYod2lkdGg9PT0wfHx3aWR0aD4zMnx8bWF0Y2hbMV0hPT1TdHJpbmcod2lkdGgpKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsXCJ0eXBlXCIsdHlwZSl9cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKXtjb25zdCBieXRlcz1hcnJheWlmeSh2YWx1ZSk7aWYoYnl0ZXMubGVuZ3RoIT09d2lkdGgpe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLFwidmFsdWVcIix2YWx1ZSl9cmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKX19fXN3aXRjaCh0eXBlKXtjYXNlXCJhZGRyZXNzXCI6cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gaGV4WmVyb1BhZChnZXRBZGRyZXNzKHZhbHVlKSwzMil9O2Nhc2VcImJvb2xcIjpyZXR1cm4gZnVuY3Rpb24odmFsdWUpe3JldHVybiF2YWx1ZT9oZXhGYWxzZTpoZXhUcnVlfTtjYXNlXCJieXRlc1wiOnJldHVybiBmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGtlY2NhazI1Nih2YWx1ZSl9O2Nhc2VcInN0cmluZ1wiOnJldHVybiBmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGlkKHZhbHVlKX19cmV0dXJuIG51bGx9ZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLGZpZWxkcyl7cmV0dXJuYCR7bmFtZX0oJHtmaWVsZHMubWFwKCh7bmFtZTpuYW1lLHR5cGU6dHlwZX0pPT50eXBlK1wiIFwiK25hbWUpLmpvaW4oXCIsXCIpfSlgfWNsYXNzIFR5cGVkRGF0YUVuY29kZXJ7Y29uc3RydWN0b3IodHlwZXMpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJ0eXBlc1wiLE9iamVjdC5mcmVlemUoZGVlcENvcHkodHlwZXMpKSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9lbmNvZGVyQ2FjaGVcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl90eXBlc1wiLHt9KTtjb25zdCBsaW5rcz17fTtjb25zdCBwYXJlbnRzPXt9O2NvbnN0IHN1YnR5cGVzPXt9O09iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKHR5cGU9PntsaW5rc1t0eXBlXT17fTtwYXJlbnRzW3R5cGVdPVtdO3N1YnR5cGVzW3R5cGVdPXt9fSk7Zm9yKGNvbnN0IG5hbWUgaW4gdHlwZXMpe2NvbnN0IHVuaXF1ZU5hbWVzPXt9O3R5cGVzW25hbWVdLmZvckVhY2goZmllbGQ9PntpZih1bmlxdWVOYW1lc1tmaWVsZC5uYW1lXSl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsXCJ0eXBlc1wiLHR5cGVzKX11bmlxdWVOYW1lc1tmaWVsZC5uYW1lXT10cnVlO2NvbnN0IGJhc2VUeXBlPWZpZWxkLnR5cGUubWF0Y2goL14oW15cXHg1Yl0qKShcXHg1YnwkKS8pWzFdO2lmKGJhc2VUeXBlPT09bmFtZSl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLFwidHlwZXNcIix0eXBlcyl9Y29uc3QgZW5jb2Rlcj1nZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7aWYoZW5jb2Rlcil7cmV0dXJufWlmKCFwYXJlbnRzW2Jhc2VUeXBlXSl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCxcInR5cGVzXCIsdHlwZXMpfXBhcmVudHNbYmFzZVR5cGVdLnB1c2gobmFtZSk7bGlua3NbbmFtZV1bYmFzZVR5cGVdPXRydWV9KX1jb25zdCBwcmltYXJ5VHlwZXM9T2JqZWN0LmtleXMocGFyZW50cykuZmlsdGVyKG49PnBhcmVudHNbbl0ubGVuZ3RoPT09MCk7aWYocHJpbWFyeVR5cGVzLmxlbmd0aD09PTApe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsXCJ0eXBlc1wiLHR5cGVzKX1lbHNlIGlmKHByaW1hcnlUeXBlcy5sZW5ndGg+MSl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCh0PT5KU09OLnN0cmluZ2lmeSh0KSkuam9pbihcIiwgXCIpfWAsXCJ0eXBlc1wiLHR5cGVzKX1kZWZpbmVSZWFkT25seSh0aGlzLFwicHJpbWFyeVR5cGVcIixwcmltYXJ5VHlwZXNbMF0pO2Z1bmN0aW9uIGNoZWNrQ2lyY3VsYXIodHlwZSxmb3VuZCl7aWYoZm91bmRbdHlwZV0pe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLFwidHlwZXNcIix0eXBlcyl9Zm91bmRbdHlwZV09dHJ1ZTtPYmplY3Qua2V5cyhsaW5rc1t0eXBlXSkuZm9yRWFjaChjaGlsZD0+e2lmKCFwYXJlbnRzW2NoaWxkXSl7cmV0dXJufWNoZWNrQ2lyY3VsYXIoY2hpbGQsZm91bmQpO09iamVjdC5rZXlzKGZvdW5kKS5mb3JFYWNoKHN1YnR5cGU9PntzdWJ0eXBlc1tzdWJ0eXBlXVtjaGlsZF09dHJ1ZX0pfSk7ZGVsZXRlIGZvdW5kW3R5cGVdfWNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSx7fSk7Zm9yKGNvbnN0IG5hbWUgaW4gc3VidHlwZXMpe2NvbnN0IHN0PU9iamVjdC5rZXlzKHN1YnR5cGVzW25hbWVdKTtzdC5zb3J0KCk7dGhpcy5fdHlwZXNbbmFtZV09ZW5jb2RlVHlwZShuYW1lLHR5cGVzW25hbWVdKStzdC5tYXAodD0+ZW5jb2RlVHlwZSh0LHR5cGVzW3RdKSkuam9pbihcIlwiKX19Z2V0RW5jb2Rlcih0eXBlKXtsZXQgZW5jb2Rlcj10aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV07aWYoIWVuY29kZXIpe2VuY29kZXI9dGhpcy5fZW5jb2RlckNhY2hlW3R5cGVdPXRoaXMuX2dldEVuY29kZXIodHlwZSl9cmV0dXJuIGVuY29kZXJ9X2dldEVuY29kZXIodHlwZSl7e2NvbnN0IGVuY29kZXI9Z2V0QmFzZUVuY29kZXIodHlwZSk7aWYoZW5jb2Rlcil7cmV0dXJuIGVuY29kZXJ9fWNvbnN0IG1hdGNoPXR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO2lmKG1hdGNoKXtjb25zdCBzdWJ0eXBlPW1hdGNoWzFdO2NvbnN0IHN1YkVuY29kZXI9dGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO2NvbnN0IGxlbmd0aD1wYXJzZUludChtYXRjaFszXSk7cmV0dXJuIHZhbHVlPT57aWYobGVuZ3RoPj0wJiZ2YWx1ZS5sZW5ndGghPT1sZW5ndGgpe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIixcInZhbHVlXCIsdmFsdWUpfWxldCByZXN1bHQ9dmFsdWUubWFwKHN1YkVuY29kZXIpO2lmKHRoaXMuX3R5cGVzW3N1YnR5cGVdKXtyZXN1bHQ9cmVzdWx0Lm1hcChrZWNjYWsyNTYpfXJldHVybiBrZWNjYWsyNTYoaGV4Q29uY2F0KHJlc3VsdCkpfX1jb25zdCBmaWVsZHM9dGhpcy50eXBlc1t0eXBlXTtpZihmaWVsZHMpe2NvbnN0IGVuY29kZWRUeXBlPWlkKHRoaXMuX3R5cGVzW3R5cGVdKTtyZXR1cm4gdmFsdWU9Pntjb25zdCB2YWx1ZXM9ZmllbGRzLm1hcCgoe25hbWU6bmFtZSx0eXBlOnR5cGV9KT0+e2NvbnN0IHJlc3VsdD10aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWVbbmFtZV0pO2lmKHRoaXMuX3R5cGVzW3R5cGVdKXtyZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCl9cmV0dXJuIHJlc3VsdH0pO3ZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtyZXR1cm4gaGV4Q29uY2F0KHZhbHVlcyl9fXJldHVybiBsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHt0eXBlfWAsXCJ0eXBlXCIsdHlwZSl9ZW5jb2RlVHlwZShuYW1lKXtjb25zdCByZXN1bHQ9dGhpcy5fdHlwZXNbbmFtZV07aWYoIXJlc3VsdCl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCxcIm5hbWVcIixuYW1lKX1yZXR1cm4gcmVzdWx0fWVuY29kZURhdGEodHlwZSx2YWx1ZSl7cmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSl9aGFzaFN0cnVjdChuYW1lLHZhbHVlKXtyZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLHZhbHVlKSl9ZW5jb2RlKHZhbHVlKXtyZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsdmFsdWUpfWhhc2godmFsdWUpe3JldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSx2YWx1ZSl9X3Zpc2l0KHR5cGUsdmFsdWUsY2FsbGJhY2spe3tjb25zdCBlbmNvZGVyPWdldEJhc2VFbmNvZGVyKHR5cGUpO2lmKGVuY29kZXIpe3JldHVybiBjYWxsYmFjayh0eXBlLHZhbHVlKX19Y29uc3QgbWF0Y2g9dHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7aWYobWF0Y2gpe2NvbnN0IHN1YnR5cGU9bWF0Y2hbMV07Y29uc3QgbGVuZ3RoPXBhcnNlSW50KG1hdGNoWzNdKTtpZihsZW5ndGg+PTAmJnZhbHVlLmxlbmd0aCE9PWxlbmd0aCl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHsgYXJyYXlMZW5ndGggfVwiLFwidmFsdWVcIix2YWx1ZSl9cmV0dXJuIHZhbHVlLm1hcCh2PT50aGlzLl92aXNpdChzdWJ0eXBlLHYsY2FsbGJhY2spKX1jb25zdCBmaWVsZHM9dGhpcy50eXBlc1t0eXBlXTtpZihmaWVsZHMpe3JldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSx7bmFtZTpuYW1lLHR5cGU6dHlwZX0pPT57YWNjdW1bbmFtZV09dGhpcy5fdmlzaXQodHlwZSx2YWx1ZVtuYW1lXSxjYWxsYmFjayk7cmV0dXJuIGFjY3VtfSx7fSl9cmV0dXJuIGxvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke3R5cGV9YCxcInR5cGVcIix0eXBlKX12aXNpdCh2YWx1ZSxjYWxsYmFjayl7cmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsdmFsdWUsY2FsbGJhY2spfXN0YXRpYyBmcm9tKHR5cGVzKXtyZXR1cm4gbmV3IFR5cGVkRGF0YUVuY29kZXIodHlwZXMpfXN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcyl7cmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykucHJpbWFyeVR5cGV9c3RhdGljIGhhc2hTdHJ1Y3QobmFtZSx0eXBlcyx2YWx1ZSl7cmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLHZhbHVlKX1zdGF0aWMgaGFzaERvbWFpbihkb21haW4pe2NvbnN0IGRvbWFpbkZpZWxkcz1bXTtmb3IoY29uc3QgbmFtZSBpbiBkb21haW4pe2NvbnN0IHR5cGU9ZG9tYWluRmllbGRUeXBlc1tuYW1lXTtpZighdHlwZSl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLFwiZG9tYWluXCIsZG9tYWluKX1kb21haW5GaWVsZHMucHVzaCh7bmFtZTpuYW1lLHR5cGU6dHlwZX0pfWRvbWFpbkZpZWxkcy5zb3J0KChhLGIpPT57cmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpLWRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpfSk7cmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLHtFSVA3MTJEb21haW46ZG9tYWluRmllbGRzfSxkb21haW4pfXN0YXRpYyBlbmNvZGUoZG9tYWluLHR5cGVzLHZhbHVlKXtyZXR1cm4gaGV4Q29uY2F0KFtcIjB4MTkwMVwiLFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaCh2YWx1ZSldKX1zdGF0aWMgaGFzaChkb21haW4sdHlwZXMsdmFsdWUpe3JldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLHR5cGVzLHZhbHVlKSl9c3RhdGljIHJlc29sdmVOYW1lcyhkb21haW4sdHlwZXMsdmFsdWUscmVzb2x2ZU5hbWUpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7ZG9tYWluPXNoYWxsb3dDb3B5KGRvbWFpbik7Y29uc3QgZW5zQ2FjaGU9e307aWYoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0JiYhaXNIZXhTdHJpbmcoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LDIwKSl7ZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XT1cIjB4XCJ9Y29uc3QgZW5jb2Rlcj1UeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO2VuY29kZXIudmlzaXQodmFsdWUsKHR5cGUsdmFsdWUpPT57aWYodHlwZT09PVwiYWRkcmVzc1wiJiYhaXNIZXhTdHJpbmcodmFsdWUsMjApKXtlbnNDYWNoZVt2YWx1ZV09XCIweFwifXJldHVybiB2YWx1ZX0pO2Zvcihjb25zdCBuYW1lIGluIGVuc0NhY2hlKXtlbnNDYWNoZVtuYW1lXT15aWVsZCByZXNvbHZlTmFtZShuYW1lKX1pZihkb21haW4udmVyaWZ5aW5nQ29udHJhY3QmJmVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pe2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdD1lbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdfXZhbHVlPWVuY29kZXIudmlzaXQodmFsdWUsKHR5cGUsdmFsdWUpPT57aWYodHlwZT09PVwiYWRkcmVzc1wiJiZlbnNDYWNoZVt2YWx1ZV0pe3JldHVybiBlbnNDYWNoZVt2YWx1ZV19cmV0dXJuIHZhbHVlfSk7cmV0dXJue2RvbWFpbjpkb21haW4sdmFsdWU6dmFsdWV9fSl9c3RhdGljIGdldFBheWxvYWQoZG9tYWluLHR5cGVzLHZhbHVlKXtUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtjb25zdCBkb21haW5WYWx1ZXM9e307Y29uc3QgZG9tYWluVHlwZXM9W107ZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKG5hbWU9Pntjb25zdCB2YWx1ZT1kb21haW5bbmFtZV07aWYodmFsdWU9PW51bGwpe3JldHVybn1kb21haW5WYWx1ZXNbbmFtZV09ZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtkb21haW5UeXBlcy5wdXNoKHtuYW1lOm5hbWUsdHlwZTpkb21haW5GaWVsZFR5cGVzW25hbWVdfSl9KTtjb25zdCBlbmNvZGVyPVR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7Y29uc3QgdHlwZXNXaXRoRG9tYWluPXNoYWxsb3dDb3B5KHR5cGVzKTtpZih0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsXCJ0eXBlcy5FSVA3MTJEb21haW5cIix0eXBlcyl9ZWxzZXt0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluPWRvbWFpblR5cGVzfWVuY29kZXIuZW5jb2RlKHZhbHVlKTtyZXR1cm57dHlwZXM6dHlwZXNXaXRoRG9tYWluLGRvbWFpbjpkb21haW5WYWx1ZXMscHJpbWFyeVR5cGU6ZW5jb2Rlci5wcmltYXJ5VHlwZSxtZXNzYWdlOmVuY29kZXIudmlzaXQodmFsdWUsKHR5cGUsdmFsdWUpPT57aWYodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpe3JldHVybiBoZXhsaWZ5KGFycmF5aWZ5KHZhbHVlKSl9aWYodHlwZS5tYXRjaCgvXnU/aW50Lykpe3JldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoKX1zd2l0Y2godHlwZSl7Y2FzZVwiYWRkcmVzc1wiOnJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO2Nhc2VcImJvb2xcIjpyZXR1cm4hIXZhbHVlO2Nhc2VcInN0cmluZ1wiOmlmKHR5cGVvZiB2YWx1ZSE9PVwic3RyaW5nXCIpe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBzdHJpbmdgLFwidmFsdWVcIix2YWx1ZSl9cmV0dXJuIHZhbHVlfXJldHVybiBsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCB0eXBlXCIsXCJ0eXBlXCIsdHlwZSl9KX19fVwidXNlIHN0cmljdFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRkPW5ldyBMb2dnZXIodmVyc2lvbiQ0KTtjbGFzcyBMb2dEZXNjcmlwdGlvbiBleHRlbmRzIERlc2NyaXB0aW9ue31jbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb257fWNsYXNzIEluZGV4ZWQgZXh0ZW5kcyBEZXNjcmlwdGlvbntzdGF0aWMgaXNJbmRleGVkKHZhbHVlKXtyZXR1cm4hISh2YWx1ZSYmdmFsdWUuX2lzSW5kZXhlZCl9fWZ1bmN0aW9uIHdyYXBBY2Nlc3NFcnJvcihwcm9wZXJ0eSxlcnJvcil7Y29uc3Qgd3JhcD1uZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke3Byb3BlcnR5fWApO3dyYXAuZXJyb3I9ZXJyb3I7cmV0dXJuIHdyYXB9Y2xhc3MgSW50ZXJmYWNle2NvbnN0cnVjdG9yKGZyYWdtZW50cyl7bG9nZ2VyJGQuY2hlY2tOZXcobmV3LnRhcmdldCxJbnRlcmZhY2UpO2xldCBhYmk9W107aWYodHlwZW9mIGZyYWdtZW50cz09PVwic3RyaW5nXCIpe2FiaT1KU09OLnBhcnNlKGZyYWdtZW50cyl9ZWxzZXthYmk9ZnJhZ21lbnRzfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJmcmFnbWVudHNcIixhYmkubWFwKGZyYWdtZW50PT57cmV0dXJuIEZyYWdtZW50LmZyb20oZnJhZ21lbnQpfSkuZmlsdGVyKGZyYWdtZW50PT5mcmFnbWVudCE9bnVsbCkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfYWJpQ29kZXJcIixnZXRTdGF0aWMobmV3LnRhcmdldCxcImdldEFiaUNvZGVyXCIpKCkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJmdW5jdGlvbnNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImVycm9yc1wiLHt9KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiZXZlbnRzXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJzdHJ1Y3RzXCIse30pO3RoaXMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQ9PntsZXQgYnVja2V0PW51bGw7c3dpdGNoKGZyYWdtZW50LnR5cGUpe2Nhc2VcImNvbnN0cnVjdG9yXCI6aWYodGhpcy5kZXBsb3kpe2xvZ2dlciRkLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO3JldHVybn1kZWZpbmVSZWFkT25seSh0aGlzLFwiZGVwbG95XCIsZnJhZ21lbnQpO3JldHVybjtjYXNlXCJmdW5jdGlvblwiOmJ1Y2tldD10aGlzLmZ1bmN0aW9uczticmVhaztjYXNlXCJldmVudFwiOmJ1Y2tldD10aGlzLmV2ZW50czticmVhaztkZWZhdWx0OnJldHVybn1sZXQgc2lnbmF0dXJlPWZyYWdtZW50LmZvcm1hdCgpO2lmKGJ1Y2tldFtzaWduYXR1cmVdKXtsb2dnZXIkZC53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBcIitzaWduYXR1cmUpO3JldHVybn1idWNrZXRbc2lnbmF0dXJlXT1mcmFnbWVudH0pO2lmKCF0aGlzLmRlcGxveSl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImRlcGxveVwiLENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbSh7cGF5YWJsZTpmYWxzZSx0eXBlOlwiY29uc3RydWN0b3JcIn0pKX1kZWZpbmVSZWFkT25seSh0aGlzLFwiX2lzSW50ZXJmYWNlXCIsdHJ1ZSl9Zm9ybWF0KGZvcm1hdCl7aWYoIWZvcm1hdCl7Zm9ybWF0PUZvcm1hdFR5cGVzLmZ1bGx9aWYoZm9ybWF0PT09Rm9ybWF0VHlwZXMuc2lnaGFzaCl7bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwiaW50ZXJmYWNlIGRvZXMgbm90IHN1cHBvcnQgZm9ybWF0dGluZyBzaWdoYXNoXCIsXCJmb3JtYXRcIixmb3JtYXQpfWNvbnN0IGFiaT10aGlzLmZyYWdtZW50cy5tYXAoZnJhZ21lbnQ9PmZyYWdtZW50LmZvcm1hdChmb3JtYXQpKTtpZihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5qc29uKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcChqPT5KU09OLnBhcnNlKGopKSl9cmV0dXJuIGFiaX1zdGF0aWMgZ2V0QWJpQ29kZXIoKXtyZXR1cm4gZGVmYXVsdEFiaUNvZGVyfXN0YXRpYyBnZXRBZGRyZXNzKGFkZHJlc3Mpe3JldHVybiBnZXRBZGRyZXNzKGFkZHJlc3MpfXN0YXRpYyBnZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpe3JldHVybiBoZXhEYXRhU2xpY2UoaWQoZnVuY3Rpb25GcmFnbWVudC5mb3JtYXQoKSksMCw0KX1zdGF0aWMgZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KXtyZXR1cm4gaWQoZXZlbnRGcmFnbWVudC5mb3JtYXQoKSl9Z2V0RnVuY3Rpb24obmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKXtpZihpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKXtmb3IoY29uc3QgbmFtZSBpbiB0aGlzLmZ1bmN0aW9ucyl7aWYobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoPT09dGhpcy5nZXRTaWdoYXNoKG5hbWUpKXtyZXR1cm4gdGhpcy5mdW5jdGlvbnNbbmFtZV19fWxvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsXCJzaWdoYXNoXCIsbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKX1pZihuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2guaW5kZXhPZihcIihcIik9PT0tMSl7Y29uc3QgbmFtZT1uYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gudHJpbSgpO2NvbnN0IG1hdGNoaW5nPU9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoZj0+Zi5zcGxpdChcIihcIilbMF09PT1uYW1lKTtpZihtYXRjaGluZy5sZW5ndGg9PT0wKXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLFwibmFtZVwiLG5hbWUpfWVsc2UgaWYobWF0Y2hpbmcubGVuZ3RoPjEpe2xvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGZ1bmN0aW9uc1wiLFwibmFtZVwiLG5hbWUpfXJldHVybiB0aGlzLmZ1bmN0aW9uc1ttYXRjaGluZ1swXV19Y29uc3QgcmVzdWx0PXRoaXMuZnVuY3Rpb25zW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtpZighcmVzdWx0KXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLFwic2lnbmF0dXJlXCIsbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKX1yZXR1cm4gcmVzdWx0fWdldEV2ZW50KG5hbWVPclNpZ25hdHVyZU9yVG9waWMpe2lmKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpKXtjb25zdCB0b3BpY2hhc2g9bmFtZU9yU2lnbmF0dXJlT3JUb3BpYy50b0xvd2VyQ2FzZSgpO2Zvcihjb25zdCBuYW1lIGluIHRoaXMuZXZlbnRzKXtpZih0b3BpY2hhc2g9PT10aGlzLmdldEV2ZW50VG9waWMobmFtZSkpe3JldHVybiB0aGlzLmV2ZW50c1tuYW1lXX19bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIixcInRvcGljaGFzaFwiLHRvcGljaGFzaCl9aWYobmFtZU9yU2lnbmF0dXJlT3JUb3BpYy5pbmRleE9mKFwiKFwiKT09PS0xKXtjb25zdCBuYW1lPW5hbWVPclNpZ25hdHVyZU9yVG9waWMudHJpbSgpO2NvbnN0IG1hdGNoaW5nPU9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKS5maWx0ZXIoZj0+Zi5zcGxpdChcIihcIilbMF09PT1uYW1lKTtpZihtYXRjaGluZy5sZW5ndGg9PT0wKXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLFwibmFtZVwiLG5hbWUpfWVsc2UgaWYobWF0Y2hpbmcubGVuZ3RoPjEpe2xvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGV2ZW50c1wiLFwibmFtZVwiLG5hbWUpfXJldHVybiB0aGlzLmV2ZW50c1ttYXRjaGluZ1swXV19Y29uc3QgcmVzdWx0PXRoaXMuZXZlbnRzW0V2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclRvcGljKS5mb3JtYXQoKV07aWYoIXJlc3VsdCl7bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIixcInNpZ25hdHVyZVwiLG5hbWVPclNpZ25hdHVyZU9yVG9waWMpfXJldHVybiByZXN1bHR9Z2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KXtpZih0eXBlb2YgZnVuY3Rpb25GcmFnbWVudD09PVwic3RyaW5nXCIpe2Z1bmN0aW9uRnJhZ21lbnQ9dGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KX1yZXR1cm4gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsXCJnZXRTaWdoYXNoXCIpKGZ1bmN0aW9uRnJhZ21lbnQpfWdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCl7aWYodHlwZW9mIGV2ZW50RnJhZ21lbnQ9PT1cInN0cmluZ1wiKXtldmVudEZyYWdtZW50PXRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCl9cmV0dXJuIGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLFwiZ2V0RXZlbnRUb3BpY1wiKShldmVudEZyYWdtZW50KX1fZGVjb2RlUGFyYW1zKHBhcmFtcyxkYXRhKXtyZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKHBhcmFtcyxkYXRhKX1fZW5jb2RlUGFyYW1zKHBhcmFtcyx2YWx1ZXMpe3JldHVybiB0aGlzLl9hYmlDb2Rlci5lbmNvZGUocGFyYW1zLHZhbHVlcyl9ZW5jb2RlRGVwbG95KHZhbHVlcyl7cmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsdmFsdWVzfHxbXSl9ZGVjb2RlRnVuY3Rpb25EYXRhKGZ1bmN0aW9uRnJhZ21lbnQsZGF0YSl7aWYodHlwZW9mIGZ1bmN0aW9uRnJhZ21lbnQ9PT1cInN0cmluZ1wiKXtmdW5jdGlvbkZyYWdtZW50PXRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCl9Y29uc3QgYnl0ZXM9YXJyYXlpZnkoZGF0YSk7aWYoaGV4bGlmeShieXRlcy5zbGljZSgwLDQpKSE9PXRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSl7bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBmdW5jdGlvbiAke2Z1bmN0aW9uRnJhZ21lbnQubmFtZX0uYCxcImRhdGFcIixoZXhsaWZ5KGJ5dGVzKSl9cmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cyxieXRlcy5zbGljZSg0KSl9ZW5jb2RlRnVuY3Rpb25EYXRhKGZ1bmN0aW9uRnJhZ21lbnQsdmFsdWVzKXtpZih0eXBlb2YgZnVuY3Rpb25GcmFnbWVudD09PVwic3RyaW5nXCIpe2Z1bmN0aW9uRnJhZ21lbnQ9dGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KX1yZXR1cm4gaGV4bGlmeShjb25jYXQoW3RoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSx0aGlzLl9lbmNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsdmFsdWVzfHxbXSldKSl9ZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnVuY3Rpb25GcmFnbWVudCxkYXRhKXtpZih0eXBlb2YgZnVuY3Rpb25GcmFnbWVudD09PVwic3RyaW5nXCIpe2Z1bmN0aW9uRnJhZ21lbnQ9dGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KX1sZXQgYnl0ZXM9YXJyYXlpZnkoZGF0YSk7bGV0IHJlYXNvbj1udWxsO2xldCBlcnJvclNpZ25hdHVyZT1udWxsO3N3aXRjaChieXRlcy5sZW5ndGgldGhpcy5fYWJpQ29kZXIuX2dldFdvcmRTaXplKCkpe2Nhc2UgMDp0cnl7cmV0dXJuIHRoaXMuX2FiaUNvZGVyLmRlY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsYnl0ZXMpfWNhdGNoKGVycm9yKXt9YnJlYWs7Y2FzZSA0OmlmKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCw0KSk9PT1cIjB4MDhjMzc5YTBcIil7ZXJyb3JTaWduYXR1cmU9XCJFcnJvcihzdHJpbmcpXCI7cmVhc29uPXRoaXMuX2FiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sYnl0ZXMuc2xpY2UoNCkpWzBdfWJyZWFrfXJldHVybiBsb2dnZXIkZC50aHJvd0Vycm9yKFwiY2FsbCByZXZlcnQgZXhjZXB0aW9uXCIsTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTix7bWV0aG9kOmZ1bmN0aW9uRnJhZ21lbnQuZm9ybWF0KCksZXJyb3JTaWduYXR1cmU6ZXJyb3JTaWduYXR1cmUsZXJyb3JBcmdzOltyZWFzb25dLHJlYXNvbjpyZWFzb259KX1lbmNvZGVGdW5jdGlvblJlc3VsdChmdW5jdGlvbkZyYWdtZW50LHZhbHVlcyl7aWYodHlwZW9mIGZ1bmN0aW9uRnJhZ21lbnQ9PT1cInN0cmluZ1wiKXtmdW5jdGlvbkZyYWdtZW50PXRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCl9cmV0dXJuIGhleGxpZnkodGhpcy5fYWJpQ29kZXIuZW5jb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cyx2YWx1ZXN8fFtdKSl9ZW5jb2RlRmlsdGVyVG9waWNzKGV2ZW50RnJhZ21lbnQsdmFsdWVzKXtpZih0eXBlb2YgZXZlbnRGcmFnbWVudD09PVwic3RyaW5nXCIpe2V2ZW50RnJhZ21lbnQ9dGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KX1pZih2YWx1ZXMubGVuZ3RoPmV2ZW50RnJhZ21lbnQuaW5wdXRzLmxlbmd0aCl7bG9nZ2VyJGQudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50cyBmb3IgXCIrZXZlbnRGcmFnbWVudC5mb3JtYXQoKSxMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQse2FyZ3VtZW50OlwidmFsdWVzXCIsdmFsdWU6dmFsdWVzfSl9bGV0IHRvcGljcz1bXTtpZighZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpe3RvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSl9Y29uc3QgZW5jb2RlVG9waWM9KHBhcmFtLHZhbHVlKT0+e2lmKHBhcmFtLnR5cGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gaWQodmFsdWUpfWVsc2UgaWYocGFyYW0udHlwZT09PVwiYnl0ZXNcIil7cmV0dXJuIGtlY2NhazI1NihoZXhsaWZ5KHZhbHVlKSl9aWYocGFyYW0udHlwZT09PVwiYWRkcmVzc1wiKXt0aGlzLl9hYmlDb2Rlci5lbmNvZGUoW1wiYWRkcmVzc1wiXSxbdmFsdWVdKX1yZXR1cm4gaGV4WmVyb1BhZChoZXhsaWZ5KHZhbHVlKSwzMil9O3ZhbHVlcy5mb3JFYWNoKCh2YWx1ZSxpbmRleCk9PntsZXQgcGFyYW09ZXZlbnRGcmFnbWVudC5pbnB1dHNbaW5kZXhdO2lmKCFwYXJhbS5pbmRleGVkKXtpZih2YWx1ZSE9bnVsbCl7bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIixcImNvbnRyYWN0LlwiK3BhcmFtLm5hbWUsdmFsdWUpfXJldHVybn1pZih2YWx1ZT09bnVsbCl7dG9waWNzLnB1c2gobnVsbCl9ZWxzZSBpZihwYXJhbS5iYXNlVHlwZT09PVwiYXJyYXlcInx8cGFyYW0uYmFzZVR5cGU9PT1cInR1cGxlXCIpe2xvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLFwiY29udHJhY3QuXCIrcGFyYW0ubmFtZSx2YWx1ZSl9ZWxzZSBpZihBcnJheS5pc0FycmF5KHZhbHVlKSl7dG9waWNzLnB1c2godmFsdWUubWFwKHZhbHVlPT5lbmNvZGVUb3BpYyhwYXJhbSx2YWx1ZSkpKX1lbHNle3RvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLHZhbHVlKSl9fSk7d2hpbGUodG9waWNzLmxlbmd0aCYmdG9waWNzW3RvcGljcy5sZW5ndGgtMV09PT1udWxsKXt0b3BpY3MucG9wKCl9cmV0dXJuIHRvcGljc31lbmNvZGVFdmVudExvZyhldmVudEZyYWdtZW50LHZhbHVlcyl7aWYodHlwZW9mIGV2ZW50RnJhZ21lbnQ9PT1cInN0cmluZ1wiKXtldmVudEZyYWdtZW50PXRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCl9Y29uc3QgdG9waWNzPVtdO2NvbnN0IGRhdGFUeXBlcz1bXTtjb25zdCBkYXRhVmFsdWVzPVtdO2lmKCFldmVudEZyYWdtZW50LmFub255bW91cyl7dG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKX1pZih2YWx1ZXMubGVuZ3RoIT09ZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsXCJ2YWx1ZXNcIix2YWx1ZXMpfWV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLGluZGV4KT0+e2NvbnN0IHZhbHVlPXZhbHVlc1tpbmRleF07aWYocGFyYW0uaW5kZXhlZCl7aWYocGFyYW0udHlwZT09PVwic3RyaW5nXCIpe3RvcGljcy5wdXNoKGlkKHZhbHVlKSl9ZWxzZSBpZihwYXJhbS50eXBlPT09XCJieXRlc1wiKXt0b3BpY3MucHVzaChrZWNjYWsyNTYodmFsdWUpKX1lbHNlIGlmKHBhcmFtLmJhc2VUeXBlPT09XCJ0dXBsZVwifHxwYXJhbS5iYXNlVHlwZT09PVwiYXJyYXlcIil7dGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpfWVsc2V7dG9waWNzLnB1c2godGhpcy5fYWJpQ29kZXIuZW5jb2RlKFtwYXJhbS50eXBlXSxbdmFsdWVdKSl9fWVsc2V7ZGF0YVR5cGVzLnB1c2gocGFyYW0pO2RhdGFWYWx1ZXMucHVzaCh2YWx1ZSl9fSk7cmV0dXJue2RhdGE6dGhpcy5fYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcyxkYXRhVmFsdWVzKSx0b3BpY3M6dG9waWNzfX1kZWNvZGVFdmVudExvZyhldmVudEZyYWdtZW50LGRhdGEsdG9waWNzKXtpZih0eXBlb2YgZXZlbnRGcmFnbWVudD09PVwic3RyaW5nXCIpe2V2ZW50RnJhZ21lbnQ9dGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KX1pZih0b3BpY3MhPW51bGwmJiFldmVudEZyYWdtZW50LmFub255bW91cyl7bGV0IHRvcGljSGFzaD10aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCk7aWYoIWlzSGV4U3RyaW5nKHRvcGljc1swXSwzMil8fHRvcGljc1swXS50b0xvd2VyQ2FzZSgpIT09dG9waWNIYXNoKXtsb2dnZXIkZC50aHJvd0Vycm9yKFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIixMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwidG9waWNzWzBdXCIsZXhwZWN0ZWQ6dG9waWNIYXNoLHZhbHVlOnRvcGljc1swXX0pfXRvcGljcz10b3BpY3Muc2xpY2UoMSl9bGV0IGluZGV4ZWQ9W107bGV0IG5vbkluZGV4ZWQ9W107bGV0IGR5bmFtaWM9W107ZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0saW5kZXgpPT57aWYocGFyYW0uaW5kZXhlZCl7aWYocGFyYW0udHlwZT09PVwic3RyaW5nXCJ8fHBhcmFtLnR5cGU9PT1cImJ5dGVzXCJ8fHBhcmFtLmJhc2VUeXBlPT09XCJ0dXBsZVwifHxwYXJhbS5iYXNlVHlwZT09PVwiYXJyYXlcIil7aW5kZXhlZC5wdXNoKFBhcmFtVHlwZS5mcm9tT2JqZWN0KHt0eXBlOlwiYnl0ZXMzMlwiLG5hbWU6cGFyYW0ubmFtZX0pKTtkeW5hbWljLnB1c2godHJ1ZSl9ZWxzZXtpbmRleGVkLnB1c2gocGFyYW0pO2R5bmFtaWMucHVzaChmYWxzZSl9fWVsc2V7bm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtkeW5hbWljLnB1c2goZmFsc2UpfX0pO2xldCByZXN1bHRJbmRleGVkPXRvcGljcyE9bnVsbD90aGlzLl9hYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCxjb25jYXQodG9waWNzKSk6bnVsbDtsZXQgcmVzdWx0Tm9uSW5kZXhlZD10aGlzLl9hYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCxkYXRhLHRydWUpO2xldCByZXN1bHQ9W107bGV0IG5vbkluZGV4ZWRJbmRleD0wLGluZGV4ZWRJbmRleD0wO2V2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLGluZGV4KT0+e2lmKHBhcmFtLmluZGV4ZWQpe2lmKHJlc3VsdEluZGV4ZWQ9PW51bGwpe3Jlc3VsdFtpbmRleF09bmV3IEluZGV4ZWQoe19pc0luZGV4ZWQ6dHJ1ZSxoYXNoOm51bGx9KX1lbHNlIGlmKGR5bmFtaWNbaW5kZXhdKXtyZXN1bHRbaW5kZXhdPW5ldyBJbmRleGVkKHtfaXNJbmRleGVkOnRydWUsaGFzaDpyZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXX0pfWVsc2V7dHJ5e3Jlc3VsdFtpbmRleF09cmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK119Y2F0Y2goZXJyb3Ipe3Jlc3VsdFtpbmRleF09ZXJyb3J9fX1lbHNle3RyeXtyZXN1bHRbaW5kZXhdPXJlc3VsdE5vbkluZGV4ZWRbbm9uSW5kZXhlZEluZGV4KytdfWNhdGNoKGVycm9yKXtyZXN1bHRbaW5kZXhdPWVycm9yfX1pZihwYXJhbS5uYW1lJiZyZXN1bHRbcGFyYW0ubmFtZV09PW51bGwpe2NvbnN0IHZhbHVlPXJlc3VsdFtpbmRleF07aWYodmFsdWUgaW5zdGFuY2VvZiBFcnJvcil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCxwYXJhbS5uYW1lLHtnZXQ6KCk9Pnt0aHJvdyB3cmFwQWNjZXNzRXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSl9YCx2YWx1ZSl9fSl9ZWxzZXtyZXN1bHRbcGFyYW0ubmFtZV09dmFsdWV9fX0pO2ZvcihsZXQgaT0wO2k8cmVzdWx0Lmxlbmd0aDtpKyspe2NvbnN0IHZhbHVlPXJlc3VsdFtpXTtpZih2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKXtPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LGkse2dldDooKT0+e3Rocm93IHdyYXBBY2Nlc3NFcnJvcihgaW5kZXggJHtpfWAsdmFsdWUpfX0pfX1yZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpfXBhcnNlVHJhbnNhY3Rpb24odHgpe2xldCBmcmFnbWVudD10aGlzLmdldEZ1bmN0aW9uKHR4LmRhdGEuc3Vic3RyaW5nKDAsMTApLnRvTG93ZXJDYXNlKCkpO2lmKCFmcmFnbWVudCl7cmV0dXJuIG51bGx9cmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKHthcmdzOnRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsXCIweFwiK3R4LmRhdGEuc3Vic3RyaW5nKDEwKSksZnVuY3Rpb25GcmFnbWVudDpmcmFnbWVudCxuYW1lOmZyYWdtZW50Lm5hbWUsc2lnbmF0dXJlOmZyYWdtZW50LmZvcm1hdCgpLHNpZ2hhc2g6dGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSx2YWx1ZTpCaWdOdW1iZXIuZnJvbSh0eC52YWx1ZXx8XCIwXCIpfSl9cGFyc2VMb2cobG9nKXtsZXQgZnJhZ21lbnQ9dGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtpZighZnJhZ21lbnR8fGZyYWdtZW50LmFub255bW91cyl7cmV0dXJuIG51bGx9cmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbih7ZXZlbnRGcmFnbWVudDpmcmFnbWVudCxuYW1lOmZyYWdtZW50Lm5hbWUsc2lnbmF0dXJlOmZyYWdtZW50LmZvcm1hdCgpLHRvcGljOnRoaXMuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCksYXJnczp0aGlzLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LGxvZy5kYXRhLGxvZy50b3BpY3MpfSl9c3RhdGljIGlzSW50ZXJmYWNlKHZhbHVlKXtyZXR1cm4hISh2YWx1ZSYmdmFsdWUuX2lzSW50ZXJmYWNlKX19XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgdmVyc2lvbiQ5PVwiYWJzdHJhY3QtcHJvdmlkZXIvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkZT1uZXcgTG9nZ2VyKHZlcnNpb24kOSk7Y2xhc3MgRm9ya0V2ZW50IGV4dGVuZHMgRGVzY3JpcHRpb257c3RhdGljIGlzRm9ya0V2ZW50KHZhbHVlKXtyZXR1cm4hISh2YWx1ZSYmdmFsdWUuX2lzRm9ya0V2ZW50KX19Y2xhc3MgQmxvY2tGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnR7Y29uc3RydWN0b3IoYmxvY2tIYXNoLGV4cGlyeSl7aWYoIWlzSGV4U3RyaW5nKGJsb2NrSGFzaCwzMikpe2xvZ2dlciRlLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2tIYXNoXCIsXCJibG9ja0hhc2hcIixibG9ja0hhc2gpfXN1cGVyKHtfaXNGb3JrRXZlbnQ6dHJ1ZSxfaXNCbG9ja0ZvcmtFdmVudDp0cnVlLGV4cGlyeTpleHBpcnl8fDAsYmxvY2tIYXNoOmJsb2NrSGFzaH0pfX1jbGFzcyBUcmFuc2FjdGlvbkZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudHtjb25zdHJ1Y3RvcihoYXNoLGV4cGlyeSl7aWYoIWlzSGV4U3RyaW5nKGhhc2gsMzIpKXtsb2dnZXIkZS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIixcImhhc2hcIixoYXNoKX1zdXBlcih7X2lzRm9ya0V2ZW50OnRydWUsX2lzVHJhbnNhY3Rpb25Gb3JrRXZlbnQ6dHJ1ZSxleHBpcnk6ZXhwaXJ5fHwwLGhhc2g6aGFzaH0pfX1jbGFzcyBUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50e2NvbnN0cnVjdG9yKGJlZm9yZUhhc2gsYWZ0ZXJIYXNoLGV4cGlyeSl7aWYoIWlzSGV4U3RyaW5nKGJlZm9yZUhhc2gsMzIpKXtsb2dnZXIkZS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIixcImJlZm9yZUhhc2hcIixiZWZvcmVIYXNoKX1pZighaXNIZXhTdHJpbmcoYWZ0ZXJIYXNoLDMyKSl7bG9nZ2VyJGUudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsXCJhZnRlckhhc2hcIixhZnRlckhhc2gpfXN1cGVyKHtfaXNGb3JrRXZlbnQ6dHJ1ZSxfaXNUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50OnRydWUsZXhwaXJ5OmV4cGlyeXx8MCxiZWZvcmVIYXNoOmJlZm9yZUhhc2gsYWZ0ZXJIYXNoOmFmdGVySGFzaH0pfX1jbGFzcyBQcm92aWRlcntjb25zdHJ1Y3Rvcigpe2xvZ2dlciRlLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCxQcm92aWRlcik7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9pc1Byb3ZpZGVyXCIsdHJ1ZSl9YWRkTGlzdGVuZXIoZXZlbnROYW1lLGxpc3RlbmVyKXtyZXR1cm4gdGhpcy5vbihldmVudE5hbWUsbGlzdGVuZXIpfXJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSxsaXN0ZW5lcil7cmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSxsaXN0ZW5lcil9c3RhdGljIGlzUHJvdmlkZXIodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNQcm92aWRlcil9fWNvbnN0IHZlcnNpb24kYT1cImFic3RyYWN0LXNpZ25lci81LjEuMFwiO1widXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkMj13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJGY9bmV3IExvZ2dlcih2ZXJzaW9uJGEpO2NvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXM9W1wiYWNjZXNzTGlzdFwiLFwiY2hhaW5JZFwiLFwiZGF0YVwiLFwiZnJvbVwiLFwiZ2FzTGltaXRcIixcImdhc1ByaWNlXCIsXCJub25jZVwiLFwidG9cIixcInR5cGVcIixcInZhbHVlXCJdO2NvbnN0IGZvcndhcmRFcnJvcnM9W0xvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCxMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXTtjbGFzcyBTaWduZXJ7Y29uc3RydWN0b3IoKXtsb2dnZXIkZi5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsU2lnbmVyKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2lzU2lnbmVyXCIsdHJ1ZSl9Z2V0QmFsYW5jZShibG9ja1RhZyl7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0QmFsYW5jZVwiKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKHRoaXMuZ2V0QWRkcmVzcygpLGJsb2NrVGFnKX0pfWdldFRyYW5zYWN0aW9uQ291bnQoYmxvY2tUYWcpe3JldHVybiBfX2F3YWl0ZXIkMih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7dGhpcy5fY2hlY2tQcm92aWRlcihcImdldFRyYW5zYWN0aW9uQ291bnRcIik7cmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmdldEFkZHJlc3MoKSxibG9ja1RhZyl9KX1lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbil7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZXN0aW1hdGVHYXNcIik7Y29uc3QgdHg9eWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7cmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXModHgpfSl9Y2FsbCh0cmFuc2FjdGlvbixibG9ja1RhZyl7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt0aGlzLl9jaGVja1Byb3ZpZGVyKFwiY2FsbFwiKTtjb25zdCB0eD15aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4LGJsb2NrVGFnKX0pfXNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbil7dGhpcy5fY2hlY2tQcm92aWRlcihcInNlbmRUcmFuc2FjdGlvblwiKTtyZXR1cm4gdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKHR4PT57cmV0dXJuIHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4KS50aGVuKHNpZ25lZFR4PT57cmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KX0pfSl9Z2V0Q2hhaW5JZCgpe3JldHVybiBfX2F3YWl0ZXIkMih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7dGhpcy5fY2hlY2tQcm92aWRlcihcImdldENoYWluSWRcIik7Y29uc3QgbmV0d29yaz15aWVsZCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtyZXR1cm4gbmV0d29yay5jaGFpbklkfSl9Z2V0R2FzUHJpY2UoKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3RoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRHYXNQcmljZVwiKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpfSl9cmVzb2x2ZU5hbWUobmFtZSl7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt0aGlzLl9jaGVja1Byb3ZpZGVyKFwicmVzb2x2ZU5hbWVcIik7cmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSl9KX1jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKXtmb3IoY29uc3Qga2V5IGluIHRyYW5zYWN0aW9uKXtpZihhbGxvd2VkVHJhbnNhY3Rpb25LZXlzLmluZGV4T2Yoa2V5KT09PS0xKXtsb2dnZXIkZi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGtleTogXCIra2V5LFwidHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvbil9fWNvbnN0IHR4PXNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtpZih0eC5mcm9tPT1udWxsKXt0eC5mcm9tPXRoaXMuZ2V0QWRkcmVzcygpfWVsc2V7dHguZnJvbT1Qcm9taXNlLmFsbChbUHJvbWlzZS5yZXNvbHZlKHR4LmZyb20pLHRoaXMuZ2V0QWRkcmVzcygpXSkudGhlbihyZXN1bHQ9PntpZihyZXN1bHRbMF0udG9Mb3dlckNhc2UoKSE9PXJlc3VsdFsxXS50b0xvd2VyQ2FzZSgpKXtsb2dnZXIkZi50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIixcInRyYW5zYWN0aW9uXCIsdHJhbnNhY3Rpb24pfXJldHVybiByZXN1bHRbMF19KX1yZXR1cm4gdHh9cG9wdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbil7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCB0eD15aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtpZih0eC50byE9bnVsbCl7dHgudG89UHJvbWlzZS5yZXNvbHZlKHR4LnRvKS50aGVuKHRvPT5fX2F3YWl0ZXIkMih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYodG89PW51bGwpe3JldHVybiBudWxsfWNvbnN0IGFkZHJlc3M9eWllbGQgdGhpcy5yZXNvbHZlTmFtZSh0byk7aWYoYWRkcmVzcz09bnVsbCl7bG9nZ2VyJGYudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZWQgRU5TIG5hbWUgcmVzb2x2ZXMgdG8gbnVsbFwiLFwidHgudG9cIix0byl9cmV0dXJuIGFkZHJlc3N9KSl9aWYodHguZ2FzUHJpY2U9PW51bGwpe3R4Lmdhc1ByaWNlPXRoaXMuZ2V0R2FzUHJpY2UoKX1pZih0eC5ub25jZT09bnVsbCl7dHgubm9uY2U9dGhpcy5nZXRUcmFuc2FjdGlvbkNvdW50KFwicGVuZGluZ1wiKX1pZih0eC5nYXNMaW1pdD09bnVsbCl7dHguZ2FzTGltaXQ9dGhpcy5lc3RpbWF0ZUdhcyh0eCkuY2F0Y2goZXJyb3I9PntpZihmb3J3YXJkRXJyb3JzLmluZGV4T2YoZXJyb3IuY29kZSk+PTApe3Rocm93IGVycm9yfXJldHVybiBsb2dnZXIkZi50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQse2Vycm9yOmVycm9yLHR4OnR4fSl9KX1pZih0eC5jaGFpbklkPT1udWxsKXt0eC5jaGFpbklkPXRoaXMuZ2V0Q2hhaW5JZCgpfWVsc2V7dHguY2hhaW5JZD1Qcm9taXNlLmFsbChbUHJvbWlzZS5yZXNvbHZlKHR4LmNoYWluSWQpLHRoaXMuZ2V0Q2hhaW5JZCgpXSkudGhlbihyZXN1bHRzPT57aWYocmVzdWx0c1sxXSE9PTAmJnJlc3VsdHNbMF0hPT1yZXN1bHRzWzFdKXtsb2dnZXIkZi50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIixcInRyYW5zYWN0aW9uXCIsdHJhbnNhY3Rpb24pfXJldHVybiByZXN1bHRzWzBdfSl9cmV0dXJuIHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHR4KX0pfV9jaGVja1Byb3ZpZGVyKG9wZXJhdGlvbil7aWYoIXRoaXMucHJvdmlkZXIpe2xvZ2dlciRmLnRocm93RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpvcGVyYXRpb258fFwiX2NoZWNrUHJvdmlkZXJcIn0pfX1zdGF0aWMgaXNTaWduZXIodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNTaWduZXIpfX1jbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgU2lnbmVye2NvbnN0cnVjdG9yKGFkZHJlc3MscHJvdmlkZXIpe2xvZ2dlciRmLmNoZWNrTmV3KG5ldy50YXJnZXQsVm9pZFNpZ25lcik7c3VwZXIoKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYWRkcmVzc1wiLGFkZHJlc3MpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHByb3ZpZGVyfHxudWxsKX1nZXRBZGRyZXNzKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFkZHJlc3MpfV9mYWlsKG1lc3NhZ2Usb3BlcmF0aW9uKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e2xvZ2dlciRmLnRocm93RXJyb3IobWVzc2FnZSxMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOm9wZXJhdGlvbn0pfSl9c2lnbk1lc3NhZ2UobWVzc2FnZSl7cmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIG1lc3NhZ2VzXCIsXCJzaWduTWVzc2FnZVwiKX1zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pe3JldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0cmFuc2FjdGlvbnNcIixcInNpZ25UcmFuc2FjdGlvblwiKX1fc2lnblR5cGVkRGF0YShkb21haW4sdHlwZXMsdmFsdWUpe3JldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0eXBlZCBkYXRhXCIsXCJzaWduVHlwZWREYXRhXCIpfWNvbm5lY3QocHJvdmlkZXIpe3JldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MscHJvdmlkZXIpfX12YXIgbWluaW1hbGlzdGljQXNzZXJ0PWFzc2VydDtmdW5jdGlvbiBhc3NlcnQodmFsLG1zZyl7aWYoIXZhbCl0aHJvdyBuZXcgRXJyb3IobXNnfHxcIkFzc2VydGlvbiBmYWlsZWRcIil9YXNzZXJ0LmVxdWFsPWZ1bmN0aW9uIGFzc2VydEVxdWFsKGwscixtc2cpe2lmKGwhPXIpdGhyb3cgbmV3IEVycm9yKG1zZ3x8XCJBc3NlcnRpb24gZmFpbGVkOiBcIitsK1wiICE9IFwiK3IpfTt2YXIgaW5oZXJpdHNfYnJvd3Nlcj1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihtb2R1bGUpe2lmKHR5cGVvZiBPYmplY3QuY3JlYXRlPT09XCJmdW5jdGlvblwiKXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhjdG9yLHN1cGVyQ3Rvcil7aWYoc3VwZXJDdG9yKXtjdG9yLnN1cGVyXz1zdXBlckN0b3I7Y3Rvci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6Y3RvcixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKGN0b3Isc3VwZXJDdG9yKXtpZihzdXBlckN0b3Ipe2N0b3Iuc3VwZXJfPXN1cGVyQ3Rvcjt2YXIgVGVtcEN0b3I9ZnVuY3Rpb24oKXt9O1RlbXBDdG9yLnByb3RvdHlwZT1zdXBlckN0b3IucHJvdG90eXBlO2N0b3IucHJvdG90eXBlPW5ldyBUZW1wQ3RvcjtjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1jdG9yfX19fSk7dmFyIGluaGVyaXRzPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKG1vZHVsZSl7dHJ5e3ZhciB1dGlsPW51bGw7aWYodHlwZW9mIHV0aWwuaW5oZXJpdHMhPT1cImZ1bmN0aW9uXCIpdGhyb3dcIlwiO21vZHVsZS5leHBvcnRzPXV0aWwuaW5oZXJpdHN9Y2F0Y2goZSl7bW9kdWxlLmV4cG9ydHM9aW5oZXJpdHNfYnJvd3Nlcn19KTtcInVzZSBzdHJpY3RcIjt2YXIgaW5oZXJpdHNfMT1pbmhlcml0cztmdW5jdGlvbiB0b0FycmF5KG1zZyxlbmMpe2lmKEFycmF5LmlzQXJyYXkobXNnKSlyZXR1cm4gbXNnLnNsaWNlKCk7aWYoIW1zZylyZXR1cm5bXTt2YXIgcmVzPVtdO2lmKHR5cGVvZiBtc2c9PT1cInN0cmluZ1wiKXtpZighZW5jKXtmb3IodmFyIGk9MDtpPG1zZy5sZW5ndGg7aSsrKXt2YXIgYz1tc2cuY2hhckNvZGVBdChpKTt2YXIgaGk9Yz4+ODt2YXIgbG89YyYyNTU7aWYoaGkpcmVzLnB1c2goaGksbG8pO2Vsc2UgcmVzLnB1c2gobG8pfX1lbHNlIGlmKGVuYz09PVwiaGV4XCIpe21zZz1tc2cucmVwbGFjZSgvW15hLXowLTldKy9naSxcIlwiKTtpZihtc2cubGVuZ3RoJTIhPT0wKW1zZz1cIjBcIittc2c7Zm9yKGk9MDtpPG1zZy5sZW5ndGg7aSs9MilyZXMucHVzaChwYXJzZUludChtc2dbaV0rbXNnW2krMV0sMTYpKX19ZWxzZXtmb3IoaT0wO2k8bXNnLmxlbmd0aDtpKyspcmVzW2ldPW1zZ1tpXXwwfXJldHVybiByZXN9dmFyIHRvQXJyYXlfMT10b0FycmF5O2Z1bmN0aW9uIHRvSGV4JDEobXNnKXt2YXIgcmVzPVwiXCI7Zm9yKHZhciBpPTA7aTxtc2cubGVuZ3RoO2krKylyZXMrPXplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO3JldHVybiByZXN9dmFyIHRvSGV4XzE9dG9IZXgkMTtmdW5jdGlvbiBodG9ubCh3KXt2YXIgcmVzPXc+Pj4yNHx3Pj4+OCY2NTI4MHx3PDw4JjE2NzExNjgwfCh3JjI1NSk8PDI0O3JldHVybiByZXM+Pj4wfXZhciBodG9ubF8xPWh0b25sO2Z1bmN0aW9uIHRvSGV4MzIobXNnLGVuZGlhbil7dmFyIHJlcz1cIlwiO2Zvcih2YXIgaT0wO2k8bXNnLmxlbmd0aDtpKyspe3ZhciB3PW1zZ1tpXTtpZihlbmRpYW49PT1cImxpdHRsZVwiKXc9aHRvbmwodyk7cmVzKz16ZXJvOCh3LnRvU3RyaW5nKDE2KSl9cmV0dXJuIHJlc312YXIgdG9IZXgzMl8xPXRvSGV4MzI7ZnVuY3Rpb24gemVybzIod29yZCl7aWYod29yZC5sZW5ndGg9PT0xKXJldHVyblwiMFwiK3dvcmQ7ZWxzZSByZXR1cm4gd29yZH12YXIgemVybzJfMT16ZXJvMjtmdW5jdGlvbiB6ZXJvOCh3b3JkKXtpZih3b3JkLmxlbmd0aD09PTcpcmV0dXJuXCIwXCIrd29yZDtlbHNlIGlmKHdvcmQubGVuZ3RoPT09NilyZXR1cm5cIjAwXCIrd29yZDtlbHNlIGlmKHdvcmQubGVuZ3RoPT09NSlyZXR1cm5cIjAwMFwiK3dvcmQ7ZWxzZSBpZih3b3JkLmxlbmd0aD09PTQpcmV0dXJuXCIwMDAwXCIrd29yZDtlbHNlIGlmKHdvcmQubGVuZ3RoPT09MylyZXR1cm5cIjAwMDAwXCIrd29yZDtlbHNlIGlmKHdvcmQubGVuZ3RoPT09MilyZXR1cm5cIjAwMDAwMFwiK3dvcmQ7ZWxzZSBpZih3b3JkLmxlbmd0aD09PTEpcmV0dXJuXCIwMDAwMDAwXCIrd29yZDtlbHNlIHJldHVybiB3b3JkfXZhciB6ZXJvOF8xPXplcm84O2Z1bmN0aW9uIGpvaW4zMihtc2csc3RhcnQsZW5kLGVuZGlhbil7dmFyIGxlbj1lbmQtc3RhcnQ7bWluaW1hbGlzdGljQXNzZXJ0KGxlbiU0PT09MCk7dmFyIHJlcz1uZXcgQXJyYXkobGVuLzQpO2Zvcih2YXIgaT0wLGs9c3RhcnQ7aTxyZXMubGVuZ3RoO2krKyxrKz00KXt2YXIgdztpZihlbmRpYW49PT1cImJpZ1wiKXc9bXNnW2tdPDwyNHxtc2dbaysxXTw8MTZ8bXNnW2srMl08PDh8bXNnW2srM107ZWxzZSB3PW1zZ1trKzNdPDwyNHxtc2dbaysyXTw8MTZ8bXNnW2srMV08PDh8bXNnW2tdO3Jlc1tpXT13Pj4+MH1yZXR1cm4gcmVzfXZhciBqb2luMzJfMT1qb2luMzI7ZnVuY3Rpb24gc3BsaXQzMihtc2csZW5kaWFuKXt2YXIgcmVzPW5ldyBBcnJheShtc2cubGVuZ3RoKjQpO2Zvcih2YXIgaT0wLGs9MDtpPG1zZy5sZW5ndGg7aSsrLGsrPTQpe3ZhciBtPW1zZ1tpXTtpZihlbmRpYW49PT1cImJpZ1wiKXtyZXNba109bT4+PjI0O3Jlc1trKzFdPW0+Pj4xNiYyNTU7cmVzW2srMl09bT4+PjgmMjU1O3Jlc1trKzNdPW0mMjU1fWVsc2V7cmVzW2srM109bT4+PjI0O3Jlc1trKzJdPW0+Pj4xNiYyNTU7cmVzW2srMV09bT4+PjgmMjU1O3Jlc1trXT1tJjI1NX19cmV0dXJuIHJlc312YXIgc3BsaXQzMl8xPXNwbGl0MzI7ZnVuY3Rpb24gcm90cjMyKHcsYil7cmV0dXJuIHc+Pj5ifHc8PDMyLWJ9dmFyIHJvdHIzMl8xPXJvdHIzMjtmdW5jdGlvbiByb3RsMzIodyxiKXtyZXR1cm4gdzw8Ynx3Pj4+MzItYn12YXIgcm90bDMyXzE9cm90bDMyO2Z1bmN0aW9uIHN1bTMyKGEsYil7cmV0dXJuIGErYj4+PjB9dmFyIHN1bTMyXzE9c3VtMzI7ZnVuY3Rpb24gc3VtMzJfMyhhLGIsYyl7cmV0dXJuIGErYitjPj4+MH12YXIgc3VtMzJfM18xPXN1bTMyXzM7ZnVuY3Rpb24gc3VtMzJfNChhLGIsYyxkKXtyZXR1cm4gYStiK2MrZD4+PjB9dmFyIHN1bTMyXzRfMT1zdW0zMl80O2Z1bmN0aW9uIHN1bTMyXzUoYSxiLGMsZCxlKXtyZXR1cm4gYStiK2MrZCtlPj4+MH12YXIgc3VtMzJfNV8xPXN1bTMyXzU7ZnVuY3Rpb24gc3VtNjQoYnVmLHBvcyxhaCxhbCl7dmFyIGJoPWJ1Zltwb3NdO3ZhciBibD1idWZbcG9zKzFdO3ZhciBsbz1hbCtibD4+PjA7dmFyIGhpPShsbzxhbD8xOjApK2FoK2JoO2J1Zltwb3NdPWhpPj4+MDtidWZbcG9zKzFdPWxvfXZhciBzdW02NF8xPXN1bTY0O2Z1bmN0aW9uIHN1bTY0X2hpKGFoLGFsLGJoLGJsKXt2YXIgbG89YWwrYmw+Pj4wO3ZhciBoaT0obG88YWw/MTowKSthaCtiaDtyZXR1cm4gaGk+Pj4wfXZhciBzdW02NF9oaV8xPXN1bTY0X2hpO2Z1bmN0aW9uIHN1bTY0X2xvKGFoLGFsLGJoLGJsKXt2YXIgbG89YWwrYmw7cmV0dXJuIGxvPj4+MH12YXIgc3VtNjRfbG9fMT1zdW02NF9sbztmdW5jdGlvbiBzdW02NF80X2hpKGFoLGFsLGJoLGJsLGNoLGNsLGRoLGRsKXt2YXIgY2Fycnk9MDt2YXIgbG89YWw7bG89bG8rYmw+Pj4wO2NhcnJ5Kz1sbzxhbD8xOjA7bG89bG8rY2w+Pj4wO2NhcnJ5Kz1sbzxjbD8xOjA7bG89bG8rZGw+Pj4wO2NhcnJ5Kz1sbzxkbD8xOjA7dmFyIGhpPWFoK2JoK2NoK2RoK2NhcnJ5O3JldHVybiBoaT4+PjB9dmFyIHN1bTY0XzRfaGlfMT1zdW02NF80X2hpO2Z1bmN0aW9uIHN1bTY0XzRfbG8oYWgsYWwsYmgsYmwsY2gsY2wsZGgsZGwpe3ZhciBsbz1hbCtibCtjbCtkbDtyZXR1cm4gbG8+Pj4wfXZhciBzdW02NF80X2xvXzE9c3VtNjRfNF9sbztmdW5jdGlvbiBzdW02NF81X2hpKGFoLGFsLGJoLGJsLGNoLGNsLGRoLGRsLGVoLGVsKXt2YXIgY2Fycnk9MDt2YXIgbG89YWw7bG89bG8rYmw+Pj4wO2NhcnJ5Kz1sbzxhbD8xOjA7bG89bG8rY2w+Pj4wO2NhcnJ5Kz1sbzxjbD8xOjA7bG89bG8rZGw+Pj4wO2NhcnJ5Kz1sbzxkbD8xOjA7bG89bG8rZWw+Pj4wO2NhcnJ5Kz1sbzxlbD8xOjA7dmFyIGhpPWFoK2JoK2NoK2RoK2VoK2NhcnJ5O3JldHVybiBoaT4+PjB9dmFyIHN1bTY0XzVfaGlfMT1zdW02NF81X2hpO2Z1bmN0aW9uIHN1bTY0XzVfbG8oYWgsYWwsYmgsYmwsY2gsY2wsZGgsZGwsZWgsZWwpe3ZhciBsbz1hbCtibCtjbCtkbCtlbDtyZXR1cm4gbG8+Pj4wfXZhciBzdW02NF81X2xvXzE9c3VtNjRfNV9sbztmdW5jdGlvbiByb3RyNjRfaGkoYWgsYWwsbnVtKXt2YXIgcj1hbDw8MzItbnVtfGFoPj4+bnVtO3JldHVybiByPj4+MH12YXIgcm90cjY0X2hpXzE9cm90cjY0X2hpO2Z1bmN0aW9uIHJvdHI2NF9sbyhhaCxhbCxudW0pe3ZhciByPWFoPDwzMi1udW18YWw+Pj5udW07cmV0dXJuIHI+Pj4wfXZhciByb3RyNjRfbG9fMT1yb3RyNjRfbG87ZnVuY3Rpb24gc2hyNjRfaGkoYWgsYWwsbnVtKXtyZXR1cm4gYWg+Pj5udW19dmFyIHNocjY0X2hpXzE9c2hyNjRfaGk7ZnVuY3Rpb24gc2hyNjRfbG8oYWgsYWwsbnVtKXt2YXIgcj1haDw8MzItbnVtfGFsPj4+bnVtO3JldHVybiByPj4+MH12YXIgc2hyNjRfbG9fMT1zaHI2NF9sbzt2YXIgdXRpbHM9e2luaGVyaXRzOmluaGVyaXRzXzEsdG9BcnJheTp0b0FycmF5XzEsdG9IZXg6dG9IZXhfMSxodG9ubDpodG9ubF8xLHRvSGV4MzI6dG9IZXgzMl8xLHplcm8yOnplcm8yXzEsemVybzg6emVybzhfMSxqb2luMzI6am9pbjMyXzEsc3BsaXQzMjpzcGxpdDMyXzEscm90cjMyOnJvdHIzMl8xLHJvdGwzMjpyb3RsMzJfMSxzdW0zMjpzdW0zMl8xLHN1bTMyXzM6c3VtMzJfM18xLHN1bTMyXzQ6c3VtMzJfNF8xLHN1bTMyXzU6c3VtMzJfNV8xLHN1bTY0OnN1bTY0XzEsc3VtNjRfaGk6c3VtNjRfaGlfMSxzdW02NF9sbzpzdW02NF9sb18xLHN1bTY0XzRfaGk6c3VtNjRfNF9oaV8xLHN1bTY0XzRfbG86c3VtNjRfNF9sb18xLHN1bTY0XzVfaGk6c3VtNjRfNV9oaV8xLHN1bTY0XzVfbG86c3VtNjRfNV9sb18xLHJvdHI2NF9oaTpyb3RyNjRfaGlfMSxyb3RyNjRfbG86cm90cjY0X2xvXzEsc2hyNjRfaGk6c2hyNjRfaGlfMSxzaHI2NF9sbzpzaHI2NF9sb18xfTtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBCbG9ja0hhc2goKXt0aGlzLnBlbmRpbmc9bnVsbDt0aGlzLnBlbmRpbmdUb3RhbD0wO3RoaXMuYmxvY2tTaXplPXRoaXMuY29uc3RydWN0b3IuYmxvY2tTaXplO3RoaXMub3V0U2l6ZT10aGlzLmNvbnN0cnVjdG9yLm91dFNpemU7dGhpcy5obWFjU3RyZW5ndGg9dGhpcy5jb25zdHJ1Y3Rvci5obWFjU3RyZW5ndGg7dGhpcy5wYWRMZW5ndGg9dGhpcy5jb25zdHJ1Y3Rvci5wYWRMZW5ndGgvODt0aGlzLmVuZGlhbj1cImJpZ1wiO3RoaXMuX2RlbHRhOD10aGlzLmJsb2NrU2l6ZS84O3RoaXMuX2RlbHRhMzI9dGhpcy5ibG9ja1NpemUvMzJ9dmFyIEJsb2NrSGFzaF8xPUJsb2NrSGFzaDtCbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbiB1cGRhdGUobXNnLGVuYyl7bXNnPXV0aWxzLnRvQXJyYXkobXNnLGVuYyk7aWYoIXRoaXMucGVuZGluZyl0aGlzLnBlbmRpbmc9bXNnO2Vsc2UgdGhpcy5wZW5kaW5nPXRoaXMucGVuZGluZy5jb25jYXQobXNnKTt0aGlzLnBlbmRpbmdUb3RhbCs9bXNnLmxlbmd0aDtpZih0aGlzLnBlbmRpbmcubGVuZ3RoPj10aGlzLl9kZWx0YTgpe21zZz10aGlzLnBlbmRpbmc7dmFyIHI9bXNnLmxlbmd0aCV0aGlzLl9kZWx0YTg7dGhpcy5wZW5kaW5nPW1zZy5zbGljZShtc2cubGVuZ3RoLXIsbXNnLmxlbmd0aCk7aWYodGhpcy5wZW5kaW5nLmxlbmd0aD09PTApdGhpcy5wZW5kaW5nPW51bGw7bXNnPXV0aWxzLmpvaW4zMihtc2csMCxtc2cubGVuZ3RoLXIsdGhpcy5lbmRpYW4pO2Zvcih2YXIgaT0wO2k8bXNnLmxlbmd0aDtpKz10aGlzLl9kZWx0YTMyKXRoaXMuX3VwZGF0ZShtc2csaSxpK3RoaXMuX2RlbHRhMzIpfXJldHVybiB0aGlzfTtCbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXt0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7bWluaW1hbGlzdGljQXNzZXJ0KHRoaXMucGVuZGluZz09PW51bGwpO3JldHVybiB0aGlzLl9kaWdlc3QoZW5jKX07QmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkPWZ1bmN0aW9uIHBhZCgpe3ZhciBsZW49dGhpcy5wZW5kaW5nVG90YWw7dmFyIGJ5dGVzPXRoaXMuX2RlbHRhODt2YXIgaz1ieXRlcy0obGVuK3RoaXMucGFkTGVuZ3RoKSVieXRlczt2YXIgcmVzPW5ldyBBcnJheShrK3RoaXMucGFkTGVuZ3RoKTtyZXNbMF09MTI4O2Zvcih2YXIgaT0xO2k8aztpKyspcmVzW2ldPTA7bGVuPDw9MztpZih0aGlzLmVuZGlhbj09PVwiYmlnXCIpe2Zvcih2YXIgdD04O3Q8dGhpcy5wYWRMZW5ndGg7dCsrKXJlc1tpKytdPTA7cmVzW2krK109MDtyZXNbaSsrXT0wO3Jlc1tpKytdPTA7cmVzW2krK109MDtyZXNbaSsrXT1sZW4+Pj4yNCYyNTU7cmVzW2krK109bGVuPj4+MTYmMjU1O3Jlc1tpKytdPWxlbj4+PjgmMjU1O3Jlc1tpKytdPWxlbiYyNTV9ZWxzZXtyZXNbaSsrXT1sZW4mMjU1O3Jlc1tpKytdPWxlbj4+PjgmMjU1O3Jlc1tpKytdPWxlbj4+PjE2JjI1NTtyZXNbaSsrXT1sZW4+Pj4yNCYyNTU7cmVzW2krK109MDtyZXNbaSsrXT0wO3Jlc1tpKytdPTA7cmVzW2krK109MDtmb3IodD04O3Q8dGhpcy5wYWRMZW5ndGg7dCsrKXJlc1tpKytdPTB9cmV0dXJuIHJlc307dmFyIGNvbW1vbj17QmxvY2tIYXNoOkJsb2NrSGFzaF8xfTtcInVzZSBzdHJpY3RcIjt2YXIgcm90cjMyJDE9dXRpbHMucm90cjMyO2Z1bmN0aW9uIGZ0XzEocyx4LHkseil7aWYocz09PTApcmV0dXJuIGNoMzIoeCx5LHopO2lmKHM9PT0xfHxzPT09MylyZXR1cm4gcDMyKHgseSx6KTtpZihzPT09MilyZXR1cm4gbWFqMzIoeCx5LHopfXZhciBmdF8xXzE9ZnRfMTtmdW5jdGlvbiBjaDMyKHgseSx6KXtyZXR1cm4geCZ5Xn54Jnp9dmFyIGNoMzJfMT1jaDMyO2Z1bmN0aW9uIG1hajMyKHgseSx6KXtyZXR1cm4geCZ5Xngmel55Jnp9dmFyIG1hajMyXzE9bWFqMzI7ZnVuY3Rpb24gcDMyKHgseSx6KXtyZXR1cm4geF55Xnp9dmFyIHAzMl8xPXAzMjtmdW5jdGlvbiBzMF8yNTYoeCl7cmV0dXJuIHJvdHIzMiQxKHgsMilecm90cjMyJDEoeCwxMylecm90cjMyJDEoeCwyMil9dmFyIHMwXzI1Nl8xPXMwXzI1NjtmdW5jdGlvbiBzMV8yNTYoeCl7cmV0dXJuIHJvdHIzMiQxKHgsNilecm90cjMyJDEoeCwxMSlecm90cjMyJDEoeCwyNSl9dmFyIHMxXzI1Nl8xPXMxXzI1NjtmdW5jdGlvbiBnMF8yNTYoeCl7cmV0dXJuIHJvdHIzMiQxKHgsNylecm90cjMyJDEoeCwxOCleeD4+PjN9dmFyIGcwXzI1Nl8xPWcwXzI1NjtmdW5jdGlvbiBnMV8yNTYoeCl7cmV0dXJuIHJvdHIzMiQxKHgsMTcpXnJvdHIzMiQxKHgsMTkpXng+Pj4xMH12YXIgZzFfMjU2XzE9ZzFfMjU2O3ZhciBjb21tb24kMT17ZnRfMTpmdF8xXzEsY2gzMjpjaDMyXzEsbWFqMzI6bWFqMzJfMSxwMzI6cDMyXzEsczBfMjU2OnMwXzI1Nl8xLHMxXzI1NjpzMV8yNTZfMSxnMF8yNTY6ZzBfMjU2XzEsZzFfMjU2OmcxXzI1Nl8xfTtcInVzZSBzdHJpY3RcIjt2YXIgcm90bDMyJDE9dXRpbHMucm90bDMyO3ZhciBzdW0zMiQxPXV0aWxzLnN1bTMyO3ZhciBzdW0zMl81JDE9dXRpbHMuc3VtMzJfNTt2YXIgZnRfMSQxPWNvbW1vbiQxLmZ0XzE7dmFyIEJsb2NrSGFzaCQxPWNvbW1vbi5CbG9ja0hhc2g7dmFyIHNoYTFfSz1bMTUxODUwMDI0OSwxODU5Nzc1MzkzLDI0MDA5NTk3MDgsMzM5NTQ2OTc4Ml07ZnVuY3Rpb24gU0hBMSgpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKXJldHVybiBuZXcgU0hBMTtCbG9ja0hhc2gkMS5jYWxsKHRoaXMpO3RoaXMuaD1bMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdO3RoaXMuVz1uZXcgQXJyYXkoODApfXV0aWxzLmluaGVyaXRzKFNIQTEsQmxvY2tIYXNoJDEpO3ZhciBfMT1TSEExO1NIQTEuYmxvY2tTaXplPTUxMjtTSEExLm91dFNpemU9MTYwO1NIQTEuaG1hY1N0cmVuZ3RoPTgwO1NIQTEucGFkTGVuZ3RoPTY0O1NIQTEucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24gX3VwZGF0ZShtc2csc3RhcnQpe3ZhciBXPXRoaXMuVztmb3IodmFyIGk9MDtpPDE2O2krKylXW2ldPW1zZ1tzdGFydCtpXTtmb3IoO2k8Vy5sZW5ndGg7aSsrKVdbaV09cm90bDMyJDEoV1tpLTNdXldbaS04XV5XW2ktMTRdXldbaS0xNl0sMSk7dmFyIGE9dGhpcy5oWzBdO3ZhciBiPXRoaXMuaFsxXTt2YXIgYz10aGlzLmhbMl07dmFyIGQ9dGhpcy5oWzNdO3ZhciBlPXRoaXMuaFs0XTtmb3IoaT0wO2k8Vy5sZW5ndGg7aSsrKXt2YXIgcz1+fihpLzIwKTt2YXIgdD1zdW0zMl81JDEocm90bDMyJDEoYSw1KSxmdF8xJDEocyxiLGMsZCksZSxXW2ldLHNoYTFfS1tzXSk7ZT1kO2Q9YztjPXJvdGwzMiQxKGIsMzApO2I9YTthPXR9dGhpcy5oWzBdPXN1bTMyJDEodGhpcy5oWzBdLGEpO3RoaXMuaFsxXT1zdW0zMiQxKHRoaXMuaFsxXSxiKTt0aGlzLmhbMl09c3VtMzIkMSh0aGlzLmhbMl0sYyk7dGhpcy5oWzNdPXN1bTMyJDEodGhpcy5oWzNdLGQpO3RoaXMuaFs0XT1zdW0zMiQxKHRoaXMuaFs0XSxlKX07U0hBMS5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCxcImJpZ1wiKTtlbHNlIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCxcImJpZ1wiKX07XCJ1c2Ugc3RyaWN0XCI7dmFyIHN1bTMyJDI9dXRpbHMuc3VtMzI7dmFyIHN1bTMyXzQkMT11dGlscy5zdW0zMl80O3ZhciBzdW0zMl81JDI9dXRpbHMuc3VtMzJfNTt2YXIgY2gzMiQxPWNvbW1vbiQxLmNoMzI7dmFyIG1hajMyJDE9Y29tbW9uJDEubWFqMzI7dmFyIHMwXzI1NiQxPWNvbW1vbiQxLnMwXzI1Njt2YXIgczFfMjU2JDE9Y29tbW9uJDEuczFfMjU2O3ZhciBnMF8yNTYkMT1jb21tb24kMS5nMF8yNTY7dmFyIGcxXzI1NiQxPWNvbW1vbiQxLmcxXzI1Njt2YXIgQmxvY2tIYXNoJDI9Y29tbW9uLkJsb2NrSGFzaDt2YXIgc2hhMjU2X0s9WzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF07ZnVuY3Rpb24gU0hBMjU2KCl7aWYoISh0aGlzIGluc3RhbmNlb2YgU0hBMjU2KSlyZXR1cm4gbmV3IFNIQTI1NjtCbG9ja0hhc2gkMi5jYWxsKHRoaXMpO3RoaXMuaD1bMTc3OTAzMzcwMywzMTQ0MTM0Mjc3LDEwMTM5MDQyNDIsMjc3MzQ4MDc2MiwxMzU5ODkzMTE5LDI2MDA4MjI5MjQsNTI4NzM0NjM1LDE1NDE0NTkyMjVdO3RoaXMuaz1zaGEyNTZfSzt0aGlzLlc9bmV3IEFycmF5KDY0KX11dGlscy5pbmhlcml0cyhTSEEyNTYsQmxvY2tIYXNoJDIpO3ZhciBfMjU2PVNIQTI1NjtTSEEyNTYuYmxvY2tTaXplPTUxMjtTSEEyNTYub3V0U2l6ZT0yNTY7U0hBMjU2LmhtYWNTdHJlbmd0aD0xOTI7U0hBMjU2LnBhZExlbmd0aD02NDtTSEEyNTYucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24gX3VwZGF0ZShtc2csc3RhcnQpe3ZhciBXPXRoaXMuVztmb3IodmFyIGk9MDtpPDE2O2krKylXW2ldPW1zZ1tzdGFydCtpXTtmb3IoO2k8Vy5sZW5ndGg7aSsrKVdbaV09c3VtMzJfNCQxKGcxXzI1NiQxKFdbaS0yXSksV1tpLTddLGcwXzI1NiQxKFdbaS0xNV0pLFdbaS0xNl0pO3ZhciBhPXRoaXMuaFswXTt2YXIgYj10aGlzLmhbMV07dmFyIGM9dGhpcy5oWzJdO3ZhciBkPXRoaXMuaFszXTt2YXIgZT10aGlzLmhbNF07dmFyIGY9dGhpcy5oWzVdO3ZhciBnPXRoaXMuaFs2XTt2YXIgaD10aGlzLmhbN107bWluaW1hbGlzdGljQXNzZXJ0KHRoaXMuay5sZW5ndGg9PT1XLmxlbmd0aCk7Zm9yKGk9MDtpPFcubGVuZ3RoO2krKyl7dmFyIFQxPXN1bTMyXzUkMihoLHMxXzI1NiQxKGUpLGNoMzIkMShlLGYsZyksdGhpcy5rW2ldLFdbaV0pO3ZhciBUMj1zdW0zMiQyKHMwXzI1NiQxKGEpLG1hajMyJDEoYSxiLGMpKTtoPWc7Zz1mO2Y9ZTtlPXN1bTMyJDIoZCxUMSk7ZD1jO2M9YjtiPWE7YT1zdW0zMiQyKFQxLFQyKX10aGlzLmhbMF09c3VtMzIkMih0aGlzLmhbMF0sYSk7dGhpcy5oWzFdPXN1bTMyJDIodGhpcy5oWzFdLGIpO3RoaXMuaFsyXT1zdW0zMiQyKHRoaXMuaFsyXSxjKTt0aGlzLmhbM109c3VtMzIkMih0aGlzLmhbM10sZCk7dGhpcy5oWzRdPXN1bTMyJDIodGhpcy5oWzRdLGUpO3RoaXMuaFs1XT1zdW0zMiQyKHRoaXMuaFs1XSxmKTt0aGlzLmhbNl09c3VtMzIkMih0aGlzLmhbNl0sZyk7dGhpcy5oWzddPXN1bTMyJDIodGhpcy5oWzddLGgpfTtTSEEyNTYucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24gZGlnZXN0KGVuYyl7aWYoZW5jPT09XCJoZXhcIilyZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsXCJiaWdcIik7ZWxzZSByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsXCJiaWdcIil9O1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIFNIQTIyNCgpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNIQTIyNCkpcmV0dXJuIG5ldyBTSEEyMjQ7XzI1Ni5jYWxsKHRoaXMpO3RoaXMuaD1bMzIzODM3MTAzMiw5MTQxNTA2NjMsODEyNzAyOTk5LDQxNDQ5MTI2OTcsNDI5MDc3NTg1NywxNzUwNjAzMDI1LDE2OTQwNzY4MzksMzIwNDA3NTQyOF19dXRpbHMuaW5oZXJpdHMoU0hBMjI0LF8yNTYpO3ZhciBfMjI0PVNIQTIyNDtTSEEyMjQuYmxvY2tTaXplPTUxMjtTSEEyMjQub3V0U2l6ZT0yMjQ7U0hBMjI0LmhtYWNTdHJlbmd0aD0xOTI7U0hBMjI0LnBhZExlbmd0aD02NDtTSEEyMjQucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24gZGlnZXN0KGVuYyl7aWYoZW5jPT09XCJoZXhcIilyZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCw3KSxcImJpZ1wiKTtlbHNlIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLDcpLFwiYmlnXCIpfTtcInVzZSBzdHJpY3RcIjt2YXIgcm90cjY0X2hpJDE9dXRpbHMucm90cjY0X2hpO3ZhciByb3RyNjRfbG8kMT11dGlscy5yb3RyNjRfbG87dmFyIHNocjY0X2hpJDE9dXRpbHMuc2hyNjRfaGk7dmFyIHNocjY0X2xvJDE9dXRpbHMuc2hyNjRfbG87dmFyIHN1bTY0JDE9dXRpbHMuc3VtNjQ7dmFyIHN1bTY0X2hpJDE9dXRpbHMuc3VtNjRfaGk7dmFyIHN1bTY0X2xvJDE9dXRpbHMuc3VtNjRfbG87dmFyIHN1bTY0XzRfaGkkMT11dGlscy5zdW02NF80X2hpO3ZhciBzdW02NF80X2xvJDE9dXRpbHMuc3VtNjRfNF9sbzt2YXIgc3VtNjRfNV9oaSQxPXV0aWxzLnN1bTY0XzVfaGk7dmFyIHN1bTY0XzVfbG8kMT11dGlscy5zdW02NF81X2xvO3ZhciBCbG9ja0hhc2gkMz1jb21tb24uQmxvY2tIYXNoO3ZhciBzaGE1MTJfSz1bMTExNjM1MjQwOCwzNjA5NzY3NDU4LDE4OTk0NDc0NDEsNjAyODkxNzI1LDMwNDkzMjM0NzEsMzk2NDQ4NDM5OSwzOTIxMDA5NTczLDIxNzMyOTU1NDgsOTYxOTg3MTYzLDQwODE2Mjg0NzIsMTUwODk3MDk5MywzMDUzODM0MjY1LDI0NTM2MzU3NDgsMjkzNzY3MTU3OSwyODcwNzYzMjIxLDM2NjQ2MDk1NjAsMzYyNDM4MTA4MCwyNzM0ODgzMzk0LDMxMDU5ODQwMSwxMTY0OTk2NTQyLDYwNzIyNTI3OCwxMzIzNjEwNzY0LDE0MjY4ODE5ODcsMzU5MDMwNDk5NCwxOTI1MDc4Mzg4LDQwNjgxODIzODMsMjE2MjA3ODIwNiw5OTEzMzYxMTMsMjYxNDg4ODEwMyw2MzM4MDMzMTcsMzI0ODIyMjU4MCwzNDc5Nzc0ODY4LDM4MzUzOTA0MDEsMjY2NjYxMzQ1OCw0MDIyMjI0Nzc0LDk0NDcxMTEzOSwyNjQzNDcwNzgsMjM0MTI2Mjc3Myw2MDQ4MDc2MjgsMjAwNzgwMDkzMyw3NzAyNTU5ODMsMTQ5NTk5MDkwMSwxMjQ5MTUwMTIyLDE4NTY0MzEyMzUsMTU1NTA4MTY5MiwzMTc1MjE4MTMyLDE5OTYwNjQ5ODYsMjE5ODk1MDgzNywyNTU0MjIwODgyLDM5OTk3MTkzMzksMjgyMTgzNDM0OSw3NjY3ODQwMTYsMjk1Mjk5NjgwOCwyNTY2NTk0ODc5LDMyMTAzMTM2NzEsMzIwMzMzNzk1NiwzMzM2NTcxODkxLDEwMzQ0NTcwMjYsMzU4NDUyODcxMSwyNDY2OTQ4OTAxLDExMzkyNjk5MywzNzU4MzI2MzgzLDMzODI0MTg5NSwxNjg3MTc5MzYsNjY2MzA3MjA1LDExODgxNzk5NjQsNzczNTI5OTEyLDE1NDYwNDU3MzQsMTI5NDc1NzM3MiwxNTIyODA1NDg1LDEzOTYxODIyOTEsMjY0MzgzMzgyMywxNjk1MTgzNzAwLDIzNDM1MjczOTAsMTk4NjY2MTA1MSwxMDE0NDc3NDgwLDIxNzcwMjYzNTAsMTIwNjc1OTE0MiwyNDU2OTU2MDM3LDM0NDA3NzYyNywyNzMwNDg1OTIxLDEyOTA4NjM0NjAsMjgyMDMwMjQxMSwzMTU4NDU0MjczLDMyNTk3MzA4MDAsMzUwNTk1MjY1NywzMzQ1NzY0NzcxLDEwNjIxNzAwOCwzNTE2MDY1ODE3LDM2MDYwMDgzNDQsMzYwMDM1MjgwNCwxNDMyNzI1Nzc2LDQwOTQ1NzE5MDksMTQ2NzAzMTU5NCwyNzU0MjMzNDQsODUxMTY5NzIwLDQzMDIyNzczNCwzMTAwODIzNzUyLDUwNjk0ODYxNiwxMzYzMjU4MTk1LDY1OTA2MDU1NiwzNzUwNjg1NTkzLDg4Mzk5Nzg3NywzNzg1MDUwMjgwLDk1ODEzOTU3MSwzMzE4MzA3NDI3LDEzMjI4MjIyMTgsMzgxMjcyMzQwMywxNTM3MDAyMDYzLDIwMDMwMzQ5OTUsMTc0Nzg3Mzc3OSwzNjAyMDM2ODk5LDE5NTU1NjIyMjIsMTU3NTk5MDAxMiwyMDI0MTA0ODE1LDExMjU1OTI5MjgsMjIyNzczMDQ1MiwyNzE2OTA0MzA2LDIzNjE4NTI0MjQsNDQyNzc2MDQ0LDI0Mjg0MzY0NzQsNTkzNjk4MzQ0LDI3NTY3MzQxODcsMzczMzExMDI0OSwzMjA0MDMxNDc5LDI5OTkzNTE1NzMsMzMyOTMyNTI5OCwzODE1OTIwNDI3LDMzOTE1Njk2MTQsMzkyODM4MzkwMCwzNTE1MjY3MjcxLDU2NjI4MDcxMSwzOTQwMTg3NjA2LDM0NTQwNjk1MzQsNDExODYzMDI3MSw0MDAwMjM5OTkyLDExNjQxODQ3NCwxOTE0MTM4NTU0LDE3NDI5MjQyMSwyNzMxMDU1MjcwLDI4OTM4MDM1NiwzMjAzOTkzMDA2LDQ2MDM5MzI2OSwzMjA2MjAzMTUsNjg1NDcxNzMzLDU4NzQ5NjgzNiw4NTIxNDI5NzEsMTA4Njc5Mjg1MSwxMDE3MDM2Mjk4LDM2NTU0MzEwMCwxMTI2MDAwNTgwLDI2MTgyOTc2NzYsMTI4ODAzMzQ3MCwzNDA5ODU1MTU4LDE1MDE1MDU5NDgsNDIzNDUwOTg2NiwxNjA3MTY3OTE1LDk4NzE2NzQ2OCwxODE2NDAyMzE2LDEyNDYxODk1OTFdO2Z1bmN0aW9uIFNIQTUxMigpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpcmV0dXJuIG5ldyBTSEE1MTI7QmxvY2tIYXNoJDMuY2FsbCh0aGlzKTt0aGlzLmg9WzE3NzkwMzM3MDMsNDA4OTIzNTcyMCwzMTQ0MTM0Mjc3LDIyMjc4NzM1OTUsMTAxMzkwNDI0Miw0MjcxMTc1NzIzLDI3NzM0ODA3NjIsMTU5NTc1MDEyOSwxMzU5ODkzMTE5LDI5MTc1NjUxMzcsMjYwMDgyMjkyNCw3MjU1MTExOTksNTI4NzM0NjM1LDQyMTUzODk1NDcsMTU0MTQ1OTIyNSwzMjcwMzMyMDldO3RoaXMuaz1zaGE1MTJfSzt0aGlzLlc9bmV3IEFycmF5KDE2MCl9dXRpbHMuaW5oZXJpdHMoU0hBNTEyLEJsb2NrSGFzaCQzKTt2YXIgXzUxMj1TSEE1MTI7U0hBNTEyLmJsb2NrU2l6ZT0xMDI0O1NIQTUxMi5vdXRTaXplPTUxMjtTSEE1MTIuaG1hY1N0cmVuZ3RoPTE5MjtTSEE1MTIucGFkTGVuZ3RoPTEyODtTSEE1MTIucHJvdG90eXBlLl9wcmVwYXJlQmxvY2s9ZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csc3RhcnQpe3ZhciBXPXRoaXMuVztmb3IodmFyIGk9MDtpPDMyO2krKylXW2ldPW1zZ1tzdGFydCtpXTtmb3IoO2k8Vy5sZW5ndGg7aSs9Mil7dmFyIGMwX2hpPWcxXzUxMl9oaShXW2ktNF0sV1tpLTNdKTt2YXIgYzBfbG89ZzFfNTEyX2xvKFdbaS00XSxXW2ktM10pO3ZhciBjMV9oaT1XW2ktMTRdO3ZhciBjMV9sbz1XW2ktMTNdO3ZhciBjMl9oaT1nMF81MTJfaGkoV1tpLTMwXSxXW2ktMjldKTt2YXIgYzJfbG89ZzBfNTEyX2xvKFdbaS0zMF0sV1tpLTI5XSk7dmFyIGMzX2hpPVdbaS0zMl07dmFyIGMzX2xvPVdbaS0zMV07V1tpXT1zdW02NF80X2hpJDEoYzBfaGksYzBfbG8sYzFfaGksYzFfbG8sYzJfaGksYzJfbG8sYzNfaGksYzNfbG8pO1dbaSsxXT1zdW02NF80X2xvJDEoYzBfaGksYzBfbG8sYzFfaGksYzFfbG8sYzJfaGksYzJfbG8sYzNfaGksYzNfbG8pfX07U0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uIF91cGRhdGUobXNnLHN0YXJ0KXt0aGlzLl9wcmVwYXJlQmxvY2sobXNnLHN0YXJ0KTt2YXIgVz10aGlzLlc7dmFyIGFoPXRoaXMuaFswXTt2YXIgYWw9dGhpcy5oWzFdO3ZhciBiaD10aGlzLmhbMl07dmFyIGJsPXRoaXMuaFszXTt2YXIgY2g9dGhpcy5oWzRdO3ZhciBjbD10aGlzLmhbNV07dmFyIGRoPXRoaXMuaFs2XTt2YXIgZGw9dGhpcy5oWzddO3ZhciBlaD10aGlzLmhbOF07dmFyIGVsPXRoaXMuaFs5XTt2YXIgZmg9dGhpcy5oWzEwXTt2YXIgZmw9dGhpcy5oWzExXTt2YXIgZ2g9dGhpcy5oWzEyXTt2YXIgZ2w9dGhpcy5oWzEzXTt2YXIgaGg9dGhpcy5oWzE0XTt2YXIgaGw9dGhpcy5oWzE1XTttaW5pbWFsaXN0aWNBc3NlcnQodGhpcy5rLmxlbmd0aD09PVcubGVuZ3RoKTtmb3IodmFyIGk9MDtpPFcubGVuZ3RoO2krPTIpe3ZhciBjMF9oaT1oaDt2YXIgYzBfbG89aGw7dmFyIGMxX2hpPXMxXzUxMl9oaShlaCxlbCk7dmFyIGMxX2xvPXMxXzUxMl9sbyhlaCxlbCk7dmFyIGMyX2hpPWNoNjRfaGkoZWgsZWwsZmgsZmwsZ2gsZ2wpO3ZhciBjMl9sbz1jaDY0X2xvKGVoLGVsLGZoLGZsLGdoLGdsKTt2YXIgYzNfaGk9dGhpcy5rW2ldO3ZhciBjM19sbz10aGlzLmtbaSsxXTt2YXIgYzRfaGk9V1tpXTt2YXIgYzRfbG89V1tpKzFdO3ZhciBUMV9oaT1zdW02NF81X2hpJDEoYzBfaGksYzBfbG8sYzFfaGksYzFfbG8sYzJfaGksYzJfbG8sYzNfaGksYzNfbG8sYzRfaGksYzRfbG8pO3ZhciBUMV9sbz1zdW02NF81X2xvJDEoYzBfaGksYzBfbG8sYzFfaGksYzFfbG8sYzJfaGksYzJfbG8sYzNfaGksYzNfbG8sYzRfaGksYzRfbG8pO2MwX2hpPXMwXzUxMl9oaShhaCxhbCk7YzBfbG89czBfNTEyX2xvKGFoLGFsKTtjMV9oaT1tYWo2NF9oaShhaCxhbCxiaCxibCxjaCxjbCk7YzFfbG89bWFqNjRfbG8oYWgsYWwsYmgsYmwsY2gsY2wpO3ZhciBUMl9oaT1zdW02NF9oaSQxKGMwX2hpLGMwX2xvLGMxX2hpLGMxX2xvKTt2YXIgVDJfbG89c3VtNjRfbG8kMShjMF9oaSxjMF9sbyxjMV9oaSxjMV9sbyk7aGg9Z2g7aGw9Z2w7Z2g9Zmg7Z2w9Zmw7Zmg9ZWg7Zmw9ZWw7ZWg9c3VtNjRfaGkkMShkaCxkbCxUMV9oaSxUMV9sbyk7ZWw9c3VtNjRfbG8kMShkbCxkbCxUMV9oaSxUMV9sbyk7ZGg9Y2g7ZGw9Y2w7Y2g9Ymg7Y2w9Ymw7Ymg9YWg7Ymw9YWw7YWg9c3VtNjRfaGkkMShUMV9oaSxUMV9sbyxUMl9oaSxUMl9sbyk7YWw9c3VtNjRfbG8kMShUMV9oaSxUMV9sbyxUMl9oaSxUMl9sbyl9c3VtNjQkMSh0aGlzLmgsMCxhaCxhbCk7c3VtNjQkMSh0aGlzLmgsMixiaCxibCk7c3VtNjQkMSh0aGlzLmgsNCxjaCxjbCk7c3VtNjQkMSh0aGlzLmgsNixkaCxkbCk7c3VtNjQkMSh0aGlzLmgsOCxlaCxlbCk7c3VtNjQkMSh0aGlzLmgsMTAsZmgsZmwpO3N1bTY0JDEodGhpcy5oLDEyLGdoLGdsKTtzdW02NCQxKHRoaXMuaCwxNCxoaCxobCl9O1NIQTUxMi5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCxcImJpZ1wiKTtlbHNlIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCxcImJpZ1wiKX07ZnVuY3Rpb24gY2g2NF9oaSh4aCx4bCx5aCx5bCx6aCl7dmFyIHI9eGgmeWhefnhoJnpoO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIGNoNjRfbG8oeGgseGwseWgseWwsemgsemwpe3ZhciByPXhsJnlsXn54bCZ6bDtpZihyPDApcis9NDI5NDk2NzI5NjtyZXR1cm4gcn1mdW5jdGlvbiBtYWo2NF9oaSh4aCx4bCx5aCx5bCx6aCl7dmFyIHI9eGgmeWheeGgmemheeWgmemg7aWYocjwwKXIrPTQyOTQ5NjcyOTY7cmV0dXJuIHJ9ZnVuY3Rpb24gbWFqNjRfbG8oeGgseGwseWgseWwsemgsemwpe3ZhciByPXhsJnlsXnhsJnpsXnlsJnpsO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIHMwXzUxMl9oaSh4aCx4bCl7dmFyIGMwX2hpPXJvdHI2NF9oaSQxKHhoLHhsLDI4KTt2YXIgYzFfaGk9cm90cjY0X2hpJDEoeGwseGgsMik7dmFyIGMyX2hpPXJvdHI2NF9oaSQxKHhsLHhoLDcpO3ZhciByPWMwX2hpXmMxX2hpXmMyX2hpO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIHMwXzUxMl9sbyh4aCx4bCl7dmFyIGMwX2xvPXJvdHI2NF9sbyQxKHhoLHhsLDI4KTt2YXIgYzFfbG89cm90cjY0X2xvJDEoeGwseGgsMik7dmFyIGMyX2xvPXJvdHI2NF9sbyQxKHhsLHhoLDcpO3ZhciByPWMwX2xvXmMxX2xvXmMyX2xvO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIHMxXzUxMl9oaSh4aCx4bCl7dmFyIGMwX2hpPXJvdHI2NF9oaSQxKHhoLHhsLDE0KTt2YXIgYzFfaGk9cm90cjY0X2hpJDEoeGgseGwsMTgpO3ZhciBjMl9oaT1yb3RyNjRfaGkkMSh4bCx4aCw5KTt2YXIgcj1jMF9oaV5jMV9oaV5jMl9oaTtpZihyPDApcis9NDI5NDk2NzI5NjtyZXR1cm4gcn1mdW5jdGlvbiBzMV81MTJfbG8oeGgseGwpe3ZhciBjMF9sbz1yb3RyNjRfbG8kMSh4aCx4bCwxNCk7dmFyIGMxX2xvPXJvdHI2NF9sbyQxKHhoLHhsLDE4KTt2YXIgYzJfbG89cm90cjY0X2xvJDEoeGwseGgsOSk7dmFyIHI9YzBfbG9eYzFfbG9eYzJfbG87aWYocjwwKXIrPTQyOTQ5NjcyOTY7cmV0dXJuIHJ9ZnVuY3Rpb24gZzBfNTEyX2hpKHhoLHhsKXt2YXIgYzBfaGk9cm90cjY0X2hpJDEoeGgseGwsMSk7dmFyIGMxX2hpPXJvdHI2NF9oaSQxKHhoLHhsLDgpO3ZhciBjMl9oaT1zaHI2NF9oaSQxKHhoLHhsLDcpO3ZhciByPWMwX2hpXmMxX2hpXmMyX2hpO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIGcwXzUxMl9sbyh4aCx4bCl7dmFyIGMwX2xvPXJvdHI2NF9sbyQxKHhoLHhsLDEpO3ZhciBjMV9sbz1yb3RyNjRfbG8kMSh4aCx4bCw4KTt2YXIgYzJfbG89c2hyNjRfbG8kMSh4aCx4bCw3KTt2YXIgcj1jMF9sb15jMV9sb15jMl9sbztpZihyPDApcis9NDI5NDk2NzI5NjtyZXR1cm4gcn1mdW5jdGlvbiBnMV81MTJfaGkoeGgseGwpe3ZhciBjMF9oaT1yb3RyNjRfaGkkMSh4aCx4bCwxOSk7dmFyIGMxX2hpPXJvdHI2NF9oaSQxKHhsLHhoLDI5KTt2YXIgYzJfaGk9c2hyNjRfaGkkMSh4aCx4bCw2KTt2YXIgcj1jMF9oaV5jMV9oaV5jMl9oaTtpZihyPDApcis9NDI5NDk2NzI5NjtyZXR1cm4gcn1mdW5jdGlvbiBnMV81MTJfbG8oeGgseGwpe3ZhciBjMF9sbz1yb3RyNjRfbG8kMSh4aCx4bCwxOSk7dmFyIGMxX2xvPXJvdHI2NF9sbyQxKHhsLHhoLDI5KTt2YXIgYzJfbG89c2hyNjRfbG8kMSh4aCx4bCw2KTt2YXIgcj1jMF9sb15jMV9sb15jMl9sbztpZihyPDApcis9NDI5NDk2NzI5NjtyZXR1cm4gcn1cInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBTSEEzODQoKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTSEEzODQpKXJldHVybiBuZXcgU0hBMzg0O181MTIuY2FsbCh0aGlzKTt0aGlzLmg9WzM0MTgwNzAzNjUsMzIzODM3MTAzMiwxNjU0MjcwMjUwLDkxNDE1MDY2MywyNDM4NTI5MzcwLDgxMjcwMjk5OSwzNTU0NjIzNjAsNDE0NDkxMjY5NywxNzMxNDA1NDE1LDQyOTA3NzU4NTcsMjM5NDE4MDIzMSwxNzUwNjAzMDI1LDM2NzUwMDg1MjUsMTY5NDA3NjgzOSwxMjAzMDYyODEzLDMyMDQwNzU0MjhdfXV0aWxzLmluaGVyaXRzKFNIQTM4NCxfNTEyKTt2YXIgXzM4ND1TSEEzODQ7U0hBMzg0LmJsb2NrU2l6ZT0xMDI0O1NIQTM4NC5vdXRTaXplPTM4NDtTSEEzODQuaG1hY1N0cmVuZ3RoPTE5MjtTSEEzODQucGFkTGVuZ3RoPTEyODtTSEEzODQucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24gZGlnZXN0KGVuYyl7aWYoZW5jPT09XCJoZXhcIilyZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwxMiksXCJiaWdcIik7ZWxzZSByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwxMiksXCJiaWdcIil9O1widXNlIHN0cmljdFwiO3ZhciBzaGExPV8xO3ZhciBzaGEyMjQ9XzIyNDt2YXIgc2hhMjU2PV8yNTY7dmFyIHNoYTM4ND1fMzg0O3ZhciBzaGE1MTI9XzUxMjt2YXIgc2hhPXtzaGExOnNoYTEsc2hhMjI0OnNoYTIyNCxzaGEyNTY6c2hhMjU2LHNoYTM4NDpzaGEzODQsc2hhNTEyOnNoYTUxMn07XCJ1c2Ugc3RyaWN0XCI7dmFyIHJvdGwzMiQyPXV0aWxzLnJvdGwzMjt2YXIgc3VtMzIkMz11dGlscy5zdW0zMjt2YXIgc3VtMzJfMyQxPXV0aWxzLnN1bTMyXzM7dmFyIHN1bTMyXzQkMj11dGlscy5zdW0zMl80O3ZhciBCbG9ja0hhc2gkND1jb21tb24uQmxvY2tIYXNoO2Z1bmN0aW9uIFJJUEVNRDE2MCgpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpcmV0dXJuIG5ldyBSSVBFTUQxNjA7QmxvY2tIYXNoJDQuY2FsbCh0aGlzKTt0aGlzLmg9WzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OCwzMjg1Mzc3NTIwXTt0aGlzLmVuZGlhbj1cImxpdHRsZVwifXV0aWxzLmluaGVyaXRzKFJJUEVNRDE2MCxCbG9ja0hhc2gkNCk7dmFyIHJpcGVtZDE2MD1SSVBFTUQxNjA7UklQRU1EMTYwLmJsb2NrU2l6ZT01MTI7UklQRU1EMTYwLm91dFNpemU9MTYwO1JJUEVNRDE2MC5obWFjU3RyZW5ndGg9MTkyO1JJUEVNRDE2MC5wYWRMZW5ndGg9NjQ7UklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uIHVwZGF0ZShtc2csc3RhcnQpe3ZhciBBPXRoaXMuaFswXTt2YXIgQj10aGlzLmhbMV07dmFyIEM9dGhpcy5oWzJdO3ZhciBEPXRoaXMuaFszXTt2YXIgRT10aGlzLmhbNF07dmFyIEFoPUE7dmFyIEJoPUI7dmFyIENoPUM7dmFyIERoPUQ7dmFyIEVoPUU7Zm9yKHZhciBqPTA7ajw4MDtqKyspe3ZhciBUPXN1bTMyJDMocm90bDMyJDIoc3VtMzJfNCQyKEEsZihqLEIsQyxEKSxtc2dbcltqXStzdGFydF0sSyhqKSksc1tqXSksRSk7QT1FO0U9RDtEPXJvdGwzMiQyKEMsMTApO0M9QjtCPVQ7VD1zdW0zMiQzKHJvdGwzMiQyKHN1bTMyXzQkMihBaCxmKDc5LWosQmgsQ2gsRGgpLG1zZ1tyaFtqXStzdGFydF0sS2goaikpLHNoW2pdKSxFaCk7QWg9RWg7RWg9RGg7RGg9cm90bDMyJDIoQ2gsMTApO0NoPUJoO0JoPVR9VD1zdW0zMl8zJDEodGhpcy5oWzFdLEMsRGgpO3RoaXMuaFsxXT1zdW0zMl8zJDEodGhpcy5oWzJdLEQsRWgpO3RoaXMuaFsyXT1zdW0zMl8zJDEodGhpcy5oWzNdLEUsQWgpO3RoaXMuaFszXT1zdW0zMl8zJDEodGhpcy5oWzRdLEEsQmgpO3RoaXMuaFs0XT1zdW0zMl8zJDEodGhpcy5oWzBdLEIsQ2gpO3RoaXMuaFswXT1UfTtSSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24gZGlnZXN0KGVuYyl7aWYoZW5jPT09XCJoZXhcIilyZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsXCJsaXR0bGVcIik7ZWxzZSByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsXCJsaXR0bGVcIil9O2Z1bmN0aW9uIGYoaix4LHkseil7aWYoajw9MTUpcmV0dXJuIHheeV56O2Vsc2UgaWYoajw9MzEpcmV0dXJuIHgmeXx+eCZ6O2Vsc2UgaWYoajw9NDcpcmV0dXJuKHh8fnkpXno7ZWxzZSBpZihqPD02MylyZXR1cm4geCZ6fHkmfno7ZWxzZSByZXR1cm4geF4oeXx+eil9ZnVuY3Rpb24gSyhqKXtpZihqPD0xNSlyZXR1cm4gMDtlbHNlIGlmKGo8PTMxKXJldHVybiAxNTE4NTAwMjQ5O2Vsc2UgaWYoajw9NDcpcmV0dXJuIDE4NTk3NzUzOTM7ZWxzZSBpZihqPD02MylyZXR1cm4gMjQwMDk1OTcwODtlbHNlIHJldHVybiAyODQwODUzODM4fWZ1bmN0aW9uIEtoKGope2lmKGo8PTE1KXJldHVybiAxMzUyODI5OTI2O2Vsc2UgaWYoajw9MzEpcmV0dXJuIDE1NDg2MDM2ODQ7ZWxzZSBpZihqPD00NylyZXR1cm4gMTgzNjA3MjY5MTtlbHNlIGlmKGo8PTYzKXJldHVybiAyMDUzOTk0MjE3O2Vsc2UgcmV0dXJuIDB9dmFyIHI9WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsNyw0LDEzLDEsMTAsNiwxNSwzLDEyLDAsOSw1LDIsMTQsMTEsOCwzLDEwLDE0LDQsOSwxNSw4LDEsMiw3LDAsNiwxMywxMSw1LDEyLDEsOSwxMSwxMCwwLDgsMTIsNCwxMywzLDcsMTUsMTQsNSw2LDIsNCwwLDUsOSw3LDEyLDIsMTAsMTQsMSwzLDgsMTEsNiwxNSwxM107dmFyIHJoPVs1LDE0LDcsMCw5LDIsMTEsNCwxMyw2LDE1LDgsMSwxMCwzLDEyLDYsMTEsMyw3LDAsMTMsNSwxMCwxNCwxNSw4LDEyLDQsOSwxLDIsMTUsNSwxLDMsNywxNCw2LDksMTEsOCwxMiwyLDEwLDAsNCwxMyw4LDYsNCwxLDMsMTEsMTUsMCw1LDEyLDIsMTMsOSw3LDEwLDE0LDEyLDE1LDEwLDQsMSw1LDgsNyw2LDIsMTMsMTQsMCwzLDksMTFdO3ZhciBzPVsxMSwxNCwxNSwxMiw1LDgsNyw5LDExLDEzLDE0LDE1LDYsNyw5LDgsNyw2LDgsMTMsMTEsOSw3LDE1LDcsMTIsMTUsOSwxMSw3LDEzLDEyLDExLDEzLDYsNywxNCw5LDEzLDE1LDE0LDgsMTMsNiw1LDEyLDcsNSwxMSwxMiwxNCwxNSwxNCwxNSw5LDgsOSwxNCw1LDYsOCw2LDUsMTIsOSwxNSw1LDExLDYsOCwxMywxMiw1LDEyLDEzLDE0LDExLDgsNSw2XTt2YXIgc2g9WzgsOSw5LDExLDEzLDE1LDE1LDUsNyw3LDgsMTEsMTQsMTQsMTIsNiw5LDEzLDE1LDcsMTIsOCw5LDExLDcsNywxMiw3LDYsMTUsMTMsMTEsOSw3LDE1LDExLDgsNiw2LDE0LDEyLDEzLDUsMTQsMTMsMTMsNyw1LDE1LDUsOCwxMSwxNCwxNCw2LDE0LDYsOSwxMiw5LDEyLDUsMTUsOCw4LDUsMTIsOSwxMiw1LDE0LDYsOCwxMyw2LDUsMTUsMTMsMTEsMTFdO3ZhciByaXBlbWQ9e3JpcGVtZDE2MDpyaXBlbWQxNjB9O1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIEhtYWMoaGFzaCxrZXksZW5jKXtpZighKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlyZXR1cm4gbmV3IEhtYWMoaGFzaCxrZXksZW5jKTt0aGlzLkhhc2g9aGFzaDt0aGlzLmJsb2NrU2l6ZT1oYXNoLmJsb2NrU2l6ZS84O3RoaXMub3V0U2l6ZT1oYXNoLm91dFNpemUvODt0aGlzLmlubmVyPW51bGw7dGhpcy5vdXRlcj1udWxsO3RoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksZW5jKSl9dmFyIGhtYWM9SG1hYztIbWFjLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbiBpbml0KGtleSl7aWYoa2V5Lmxlbmd0aD50aGlzLmJsb2NrU2l6ZSlrZXk9KG5ldyB0aGlzLkhhc2gpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO21pbmltYWxpc3RpY0Fzc2VydChrZXkubGVuZ3RoPD10aGlzLmJsb2NrU2l6ZSk7Zm9yKHZhciBpPWtleS5sZW5ndGg7aTx0aGlzLmJsb2NrU2l6ZTtpKyspa2V5LnB1c2goMCk7Zm9yKGk9MDtpPGtleS5sZW5ndGg7aSsrKWtleVtpXV49NTQ7dGhpcy5pbm5lcj0obmV3IHRoaXMuSGFzaCkudXBkYXRlKGtleSk7Zm9yKGk9MDtpPGtleS5sZW5ndGg7aSsrKWtleVtpXV49MTA2O3RoaXMub3V0ZXI9KG5ldyB0aGlzLkhhc2gpLnVwZGF0ZShrZXkpfTtIbWFjLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24gdXBkYXRlKG1zZyxlbmMpe3RoaXMuaW5uZXIudXBkYXRlKG1zZyxlbmMpO3JldHVybiB0aGlzfTtIbWFjLnByb3RvdHlwZS5kaWdlc3Q9ZnVuY3Rpb24gZGlnZXN0KGVuYyl7dGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7cmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyl9O3ZhciBoYXNoXzE9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe3ZhciBoYXNoPWV4cG9ydHM7aGFzaC51dGlscz11dGlscztoYXNoLmNvbW1vbj1jb21tb247aGFzaC5zaGE9c2hhO2hhc2gucmlwZW1kPXJpcGVtZDtoYXNoLmhtYWM9aG1hYztoYXNoLnNoYTE9aGFzaC5zaGEuc2hhMTtoYXNoLnNoYTI1Nj1oYXNoLnNoYS5zaGEyNTY7aGFzaC5zaGEyMjQ9aGFzaC5zaGEuc2hhMjI0O2hhc2guc2hhMzg0PWhhc2guc2hhLnNoYTM4NDtoYXNoLnNoYTUxMj1oYXNoLnNoYS5zaGE1MTI7aGFzaC5yaXBlbWQxNjA9aGFzaC5yaXBlbWQucmlwZW1kMTYwfSk7dmFyIGNvbW1vbmpzR2xvYmFsJDE9dHlwZW9mIGdsb2JhbFRoaXMhPT1cInVuZGVmaW5lZFwiP2dsb2JhbFRoaXM6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93OnR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiP2dsb2JhbDp0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp7fTtmdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyQxKHgpe3JldHVybiB4JiZ4Ll9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LFwiZGVmYXVsdFwiKT94W1wiZGVmYXVsdFwiXTp4fWZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZm4sYmFzZWRpcixtb2R1bGUpe3JldHVybiBtb2R1bGU9e3BhdGg6YmFzZWRpcixleHBvcnRzOnt9LHJlcXVpcmU6ZnVuY3Rpb24ocGF0aCxiYXNlKXtyZXR1cm4gY29tbW9uanNSZXF1aXJlJDEocGF0aCxiYXNlPT09dW5kZWZpbmVkfHxiYXNlPT09bnVsbD9tb2R1bGUucGF0aDpiYXNlKX19LGZuKG1vZHVsZSxtb2R1bGUuZXhwb3J0cyksbW9kdWxlLmV4cG9ydHN9ZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZlByZXNlbnQkMShuKXtyZXR1cm4gbiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJkZWZhdWx0XCIpP25bXCJkZWZhdWx0XCJdOm59ZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZk5vdE5hbWVkJDEobil7cmV0dXJuIG4mJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiZGVmYXVsdFwiKSYmT2JqZWN0LmtleXMobikubGVuZ3RoPT09MT9uW1wiZGVmYXVsdFwiXTpufWZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZSQxKG4pe2lmKG4uX19lc01vZHVsZSlyZXR1cm4gbjt2YXIgYT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKGspe3ZhciBkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobixrKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxrLGQuZ2V0P2Q6e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbltrXX19KX0pO3JldHVybiBhfWZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSQxKCl7dGhyb3cgbmV3IEVycm9yKFwiRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgQHJvbGx1cC9wbHVnaW4tY29tbW9uanNcIil9dmFyIG1pbmltYWxpc3RpY0Fzc2VydCQxPWFzc2VydCQxO2Z1bmN0aW9uIGFzc2VydCQxKHZhbCxtc2cpe2lmKCF2YWwpdGhyb3cgbmV3IEVycm9yKG1zZ3x8XCJBc3NlcnRpb24gZmFpbGVkXCIpfWFzc2VydCQxLmVxdWFsPWZ1bmN0aW9uIGFzc2VydEVxdWFsKGwscixtc2cpe2lmKGwhPXIpdGhyb3cgbmV3IEVycm9yKG1zZ3x8XCJBc3NlcnRpb24gZmFpbGVkOiBcIitsK1wiICE9IFwiK3IpfTt2YXIgdXRpbHNfMT1jcmVhdGVDb21tb25qc01vZHVsZSQxKGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgdXRpbHM9ZXhwb3J0cztmdW5jdGlvbiB0b0FycmF5KG1zZyxlbmMpe2lmKEFycmF5LmlzQXJyYXkobXNnKSlyZXR1cm4gbXNnLnNsaWNlKCk7aWYoIW1zZylyZXR1cm5bXTt2YXIgcmVzPVtdO2lmKHR5cGVvZiBtc2chPT1cInN0cmluZ1wiKXtmb3IodmFyIGk9MDtpPG1zZy5sZW5ndGg7aSsrKXJlc1tpXT1tc2dbaV18MDtyZXR1cm4gcmVzfWlmKGVuYz09PVwiaGV4XCIpe21zZz1tc2cucmVwbGFjZSgvW15hLXowLTldKy9naSxcIlwiKTtpZihtc2cubGVuZ3RoJTIhPT0wKW1zZz1cIjBcIittc2c7Zm9yKHZhciBpPTA7aTxtc2cubGVuZ3RoO2krPTIpcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldK21zZ1tpKzFdLDE2KSl9ZWxzZXtmb3IodmFyIGk9MDtpPG1zZy5sZW5ndGg7aSsrKXt2YXIgYz1tc2cuY2hhckNvZGVBdChpKTt2YXIgaGk9Yz4+ODt2YXIgbG89YyYyNTU7aWYoaGkpcmVzLnB1c2goaGksbG8pO2Vsc2UgcmVzLnB1c2gobG8pfX1yZXR1cm4gcmVzfXV0aWxzLnRvQXJyYXk9dG9BcnJheTtmdW5jdGlvbiB6ZXJvMih3b3JkKXtpZih3b3JkLmxlbmd0aD09PTEpcmV0dXJuXCIwXCIrd29yZDtlbHNlIHJldHVybiB3b3JkfXV0aWxzLnplcm8yPXplcm8yO2Z1bmN0aW9uIHRvSGV4KG1zZyl7dmFyIHJlcz1cIlwiO2Zvcih2YXIgaT0wO2k8bXNnLmxlbmd0aDtpKyspcmVzKz16ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtyZXR1cm4gcmVzfXV0aWxzLnRvSGV4PXRvSGV4O3V0aWxzLmVuY29kZT1mdW5jdGlvbiBlbmNvZGUoYXJyLGVuYyl7aWYoZW5jPT09XCJoZXhcIilyZXR1cm4gdG9IZXgoYXJyKTtlbHNlIHJldHVybiBhcnJ9fSk7dmFyIHV0aWxzXzEkMT1jcmVhdGVDb21tb25qc01vZHVsZSQxKGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgdXRpbHM9ZXhwb3J0czt1dGlscy5hc3NlcnQ9bWluaW1hbGlzdGljQXNzZXJ0JDE7dXRpbHMudG9BcnJheT11dGlsc18xLnRvQXJyYXk7dXRpbHMuemVybzI9dXRpbHNfMS56ZXJvMjt1dGlscy50b0hleD11dGlsc18xLnRvSGV4O3V0aWxzLmVuY29kZT11dGlsc18xLmVuY29kZTtmdW5jdGlvbiBnZXROQUYobnVtLHcsYml0cyl7dmFyIG5hZj1uZXcgQXJyYXkoTWF0aC5tYXgobnVtLmJpdExlbmd0aCgpLGJpdHMpKzEpO25hZi5maWxsKDApO3ZhciB3cz0xPDx3KzE7dmFyIGs9bnVtLmNsb25lKCk7Zm9yKHZhciBpPTA7aTxuYWYubGVuZ3RoO2krKyl7dmFyIHo7dmFyIG1vZD1rLmFuZGxuKHdzLTEpO2lmKGsuaXNPZGQoKSl7aWYobW9kPih3cz4+MSktMSl6PSh3cz4+MSktbW9kO2Vsc2Ugej1tb2Q7ay5pc3Vibih6KX1lbHNle3o9MH1uYWZbaV09ejtrLml1c2hybigxKX1yZXR1cm4gbmFmfXV0aWxzLmdldE5BRj1nZXROQUY7ZnVuY3Rpb24gZ2V0SlNGKGsxLGsyKXt2YXIganNmPVtbXSxbXV07azE9azEuY2xvbmUoKTtrMj1rMi5jbG9uZSgpO3ZhciBkMT0wO3ZhciBkMj0wO3ZhciBtODt3aGlsZShrMS5jbXBuKC1kMSk+MHx8azIuY21wbigtZDIpPjApe3ZhciBtMTQ9azEuYW5kbG4oMykrZDEmMzt2YXIgbTI0PWsyLmFuZGxuKDMpK2QyJjM7aWYobTE0PT09MyltMTQ9LTE7aWYobTI0PT09MyltMjQ9LTE7dmFyIHUxO2lmKChtMTQmMSk9PT0wKXt1MT0wfWVsc2V7bTg9azEuYW5kbG4oNykrZDEmNztpZigobTg9PT0zfHxtOD09PTUpJiZtMjQ9PT0yKXUxPS1tMTQ7ZWxzZSB1MT1tMTR9anNmWzBdLnB1c2godTEpO3ZhciB1MjtpZigobTI0JjEpPT09MCl7dTI9MH1lbHNle204PWsyLmFuZGxuKDcpK2QyJjc7aWYoKG04PT09M3x8bTg9PT01KSYmbTE0PT09Mil1Mj0tbTI0O2Vsc2UgdTI9bTI0fWpzZlsxXS5wdXNoKHUyKTtpZigyKmQxPT09dTErMSlkMT0xLWQxO2lmKDIqZDI9PT11MisxKWQyPTEtZDI7azEuaXVzaHJuKDEpO2syLml1c2hybigxKX1yZXR1cm4ganNmfXV0aWxzLmdldEpTRj1nZXRKU0Y7ZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLG5hbWUsY29tcHV0ZXIpe3ZhciBrZXk9XCJfXCIrbmFtZTtvYmoucHJvdG90eXBlW25hbWVdPWZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCl7cmV0dXJuIHRoaXNba2V5XSE9PXVuZGVmaW5lZD90aGlzW2tleV06dGhpc1trZXldPWNvbXB1dGVyLmNhbGwodGhpcyl9fXV0aWxzLmNhY2hlZFByb3BlcnR5PWNhY2hlZFByb3BlcnR5O2Z1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpe3JldHVybiB0eXBlb2YgYnl0ZXM9PT1cInN0cmluZ1wiP3V0aWxzLnRvQXJyYXkoYnl0ZXMsXCJoZXhcIik6Ynl0ZXN9dXRpbHMucGFyc2VCeXRlcz1wYXJzZUJ5dGVzO2Z1bmN0aW9uIGludEZyb21MRShieXRlcyl7cmV0dXJuIG5ldyBibihieXRlcyxcImhleFwiLFwibGVcIil9dXRpbHMuaW50RnJvbUxFPWludEZyb21MRX0pO1widXNlIHN0cmljdFwiO3ZhciBnZXROQUY9dXRpbHNfMSQxLmdldE5BRjt2YXIgZ2V0SlNGPXV0aWxzXzEkMS5nZXRKU0Y7dmFyIGFzc2VydCQxJDE9dXRpbHNfMSQxLmFzc2VydDtmdW5jdGlvbiBCYXNlQ3VydmUodHlwZSxjb25mKXt0aGlzLnR5cGU9dHlwZTt0aGlzLnA9bmV3IGJuKGNvbmYucCwxNik7dGhpcy5yZWQ9Y29uZi5wcmltZT9ibi5yZWQoY29uZi5wcmltZSk6Ym4ubW9udCh0aGlzLnApO3RoaXMuemVybz1uZXcgYm4oMCkudG9SZWQodGhpcy5yZWQpO3RoaXMub25lPW5ldyBibigxKS50b1JlZCh0aGlzLnJlZCk7dGhpcy50d289bmV3IGJuKDIpLnRvUmVkKHRoaXMucmVkKTt0aGlzLm49Y29uZi5uJiZuZXcgYm4oY29uZi5uLDE2KTt0aGlzLmc9Y29uZi5nJiZ0aGlzLnBvaW50RnJvbUpTT04oY29uZi5nLGNvbmYuZ1JlZCk7dGhpcy5fd25hZlQxPW5ldyBBcnJheSg0KTt0aGlzLl93bmFmVDI9bmV3IEFycmF5KDQpO3RoaXMuX3duYWZUMz1uZXcgQXJyYXkoNCk7dGhpcy5fd25hZlQ0PW5ldyBBcnJheSg0KTt0aGlzLl9iaXRMZW5ndGg9dGhpcy5uP3RoaXMubi5iaXRMZW5ndGgoKTowO3ZhciBhZGp1c3RDb3VudD10aGlzLm4mJnRoaXMucC5kaXYodGhpcy5uKTtpZighYWRqdXN0Q291bnR8fGFkanVzdENvdW50LmNtcG4oMTAwKT4wKXt0aGlzLnJlZE49bnVsbH1lbHNle3RoaXMuX21heHdlbGxUcmljaz10cnVlO3RoaXMucmVkTj10aGlzLm4udG9SZWQodGhpcy5yZWQpfX12YXIgYmFzZT1CYXNlQ3VydmU7QmFzZUN1cnZlLnByb3RvdHlwZS5wb2ludD1mdW5jdGlvbiBwb2ludCgpe3Rocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKX07QmFzZUN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbiB2YWxpZGF0ZSgpe3Rocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKX07QmFzZUN1cnZlLnByb3RvdHlwZS5fZml4ZWROYWZNdWw9ZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsayl7YXNzZXJ0JDEkMShwLnByZWNvbXB1dGVkKTt2YXIgZG91Ymxlcz1wLl9nZXREb3VibGVzKCk7dmFyIG5hZj1nZXROQUYoaywxLHRoaXMuX2JpdExlbmd0aCk7dmFyIEk9KDE8PGRvdWJsZXMuc3RlcCsxKS0oZG91Ymxlcy5zdGVwJTI9PT0wPzI6MSk7SS89Mzt2YXIgcmVwcj1bXTt2YXIgajt2YXIgbmFmVztmb3Ioaj0wO2o8bmFmLmxlbmd0aDtqKz1kb3VibGVzLnN0ZXApe25hZlc9MDtmb3IodmFyIGw9aitkb3VibGVzLnN0ZXAtMTtsPj1qO2wtLSluYWZXPShuYWZXPDwxKStuYWZbbF07cmVwci5wdXNoKG5hZlcpfXZhciBhPXRoaXMuanBvaW50KG51bGwsbnVsbCxudWxsKTt2YXIgYj10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCk7Zm9yKHZhciBpPUk7aT4wO2ktLSl7Zm9yKGo9MDtqPHJlcHIubGVuZ3RoO2orKyl7bmFmVz1yZXByW2pdO2lmKG5hZlc9PT1pKWI9Yi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXSk7ZWxzZSBpZihuYWZXPT09LWkpYj1iLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKX1hPWEuYWRkKGIpfXJldHVybiBhLnRvUCgpfTtCYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsPWZ1bmN0aW9uIF93bmFmTXVsKHAsayl7dmFyIHc9NDt2YXIgbmFmUG9pbnRzPXAuX2dldE5BRlBvaW50cyh3KTt3PW5hZlBvaW50cy53bmQ7dmFyIHduZD1uYWZQb2ludHMucG9pbnRzO3ZhciBuYWY9Z2V0TkFGKGssdyx0aGlzLl9iaXRMZW5ndGgpO3ZhciBhY2M9dGhpcy5qcG9pbnQobnVsbCxudWxsLG51bGwpO2Zvcih2YXIgaT1uYWYubGVuZ3RoLTE7aT49MDtpLS0pe2Zvcih2YXIgbD0wO2k+PTAmJm5hZltpXT09PTA7aS0tKWwrKztpZihpPj0wKWwrKzthY2M9YWNjLmRibHAobCk7aWYoaTwwKWJyZWFrO3ZhciB6PW5hZltpXTthc3NlcnQkMSQxKHohPT0wKTtpZihwLnR5cGU9PT1cImFmZmluZVwiKXtpZih6PjApYWNjPWFjYy5taXhlZEFkZCh3bmRbei0xPj4xXSk7ZWxzZSBhY2M9YWNjLm1peGVkQWRkKHduZFstei0xPj4xXS5uZWcoKSl9ZWxzZXtpZih6PjApYWNjPWFjYy5hZGQod25kW3otMT4+MV0pO2Vsc2UgYWNjPWFjYy5hZGQod25kWy16LTE+PjFdLm5lZygpKX19cmV0dXJuIHAudHlwZT09PVwiYWZmaW5lXCI/YWNjLnRvUCgpOmFjY307QmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZD1mdW5jdGlvbiBfd25hZk11bEFkZChkZWZXLHBvaW50cyxjb2VmZnMsbGVuLGphY29iaWFuUmVzdWx0KXt2YXIgd25kV2lkdGg9dGhpcy5fd25hZlQxO3ZhciB3bmQ9dGhpcy5fd25hZlQyO3ZhciBuYWY9dGhpcy5fd25hZlQzO3ZhciBtYXg9MDt2YXIgaTt2YXIgajt2YXIgcDtmb3IoaT0wO2k8bGVuO2krKyl7cD1wb2ludHNbaV07dmFyIG5hZlBvaW50cz1wLl9nZXROQUZQb2ludHMoZGVmVyk7d25kV2lkdGhbaV09bmFmUG9pbnRzLnduZDt3bmRbaV09bmFmUG9pbnRzLnBvaW50c31mb3IoaT1sZW4tMTtpPj0xO2ktPTIpe3ZhciBhPWktMTt2YXIgYj1pO2lmKHduZFdpZHRoW2FdIT09MXx8d25kV2lkdGhbYl0hPT0xKXtuYWZbYV09Z2V0TkFGKGNvZWZmc1thXSx3bmRXaWR0aFthXSx0aGlzLl9iaXRMZW5ndGgpO25hZltiXT1nZXROQUYoY29lZmZzW2JdLHduZFdpZHRoW2JdLHRoaXMuX2JpdExlbmd0aCk7bWF4PU1hdGgubWF4KG5hZlthXS5sZW5ndGgsbWF4KTttYXg9TWF0aC5tYXgobmFmW2JdLmxlbmd0aCxtYXgpO2NvbnRpbnVlfXZhciBjb21iPVtwb2ludHNbYV0sbnVsbCxudWxsLHBvaW50c1tiXV07aWYocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KT09PTApe2NvbWJbMV09cG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO2NvbWJbMl09cG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSl9ZWxzZSBpZihwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpPT09MCl7Y29tYlsxXT1wb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtjb21iWzJdPXBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKX1lbHNle2NvbWJbMV09cG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7Y29tYlsyXT1wb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKX12YXIgaW5kZXg9Wy0zLC0xLC01LC03LDAsNyw1LDEsM107dmFyIGpzZj1nZXRKU0YoY29lZmZzW2FdLGNvZWZmc1tiXSk7bWF4PU1hdGgubWF4KGpzZlswXS5sZW5ndGgsbWF4KTtuYWZbYV09bmV3IEFycmF5KG1heCk7bmFmW2JdPW5ldyBBcnJheShtYXgpO2ZvcihqPTA7ajxtYXg7aisrKXt2YXIgamE9anNmWzBdW2pdfDA7dmFyIGpiPWpzZlsxXVtqXXwwO25hZlthXVtqXT1pbmRleFsoamErMSkqMysoamIrMSldO25hZltiXVtqXT0wO3duZFthXT1jb21ifX12YXIgYWNjPXRoaXMuanBvaW50KG51bGwsbnVsbCxudWxsKTt2YXIgdG1wPXRoaXMuX3duYWZUNDtmb3IoaT1tYXg7aT49MDtpLS0pe3ZhciBrPTA7d2hpbGUoaT49MCl7dmFyIHplcm89dHJ1ZTtmb3Ioaj0wO2o8bGVuO2orKyl7dG1wW2pdPW5hZltqXVtpXXwwO2lmKHRtcFtqXSE9PTApemVybz1mYWxzZX1pZighemVybylicmVhaztrKys7aS0tfWlmKGk+PTApaysrO2FjYz1hY2MuZGJscChrKTtpZihpPDApYnJlYWs7Zm9yKGo9MDtqPGxlbjtqKyspe3ZhciB6PXRtcFtqXTtwO2lmKHo9PT0wKWNvbnRpbnVlO2Vsc2UgaWYoej4wKXA9d25kW2pdW3otMT4+MV07ZWxzZSBpZih6PDApcD13bmRbal1bLXotMT4+MV0ubmVnKCk7aWYocC50eXBlPT09XCJhZmZpbmVcIilhY2M9YWNjLm1peGVkQWRkKHApO2Vsc2UgYWNjPWFjYy5hZGQocCl9fWZvcihpPTA7aTxsZW47aSsrKXduZFtpXT1udWxsO2lmKGphY29iaWFuUmVzdWx0KXJldHVybiBhY2M7ZWxzZSByZXR1cm4gYWNjLnRvUCgpfTtmdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsdHlwZSl7dGhpcy5jdXJ2ZT1jdXJ2ZTt0aGlzLnR5cGU9dHlwZTt0aGlzLnByZWNvbXB1dGVkPW51bGx9QmFzZUN1cnZlLkJhc2VQb2ludD1CYXNlUG9pbnQ7QmFzZVBvaW50LnByb3RvdHlwZS5lcT1mdW5jdGlvbiBlcSgpe3Rocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKX07QmFzZVBvaW50LnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbiB2YWxpZGF0ZSgpe3JldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpfTtCYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50PWZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLGVuYyl7Ynl0ZXM9dXRpbHNfMSQxLnRvQXJyYXkoYnl0ZXMsZW5jKTt2YXIgbGVuPXRoaXMucC5ieXRlTGVuZ3RoKCk7aWYoKGJ5dGVzWzBdPT09NHx8Ynl0ZXNbMF09PT02fHxieXRlc1swXT09PTcpJiZieXRlcy5sZW5ndGgtMT09PTIqbGVuKXtpZihieXRlc1swXT09PTYpYXNzZXJ0JDEkMShieXRlc1tieXRlcy5sZW5ndGgtMV0lMj09PTApO2Vsc2UgaWYoYnl0ZXNbMF09PT03KWFzc2VydCQxJDEoYnl0ZXNbYnl0ZXMubGVuZ3RoLTFdJTI9PT0xKTt2YXIgcmVzPXRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwxK2xlbiksYnl0ZXMuc2xpY2UoMStsZW4sMSsyKmxlbikpO3JldHVybiByZXN9ZWxzZSBpZigoYnl0ZXNbMF09PT0yfHxieXRlc1swXT09PTMpJiZieXRlcy5sZW5ndGgtMT09PWxlbil7cmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLDErbGVuKSxieXRlc1swXT09PTMpfXRocm93IG5ldyBFcnJvcihcIlVua25vd24gcG9pbnQgZm9ybWF0XCIpfTtCYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQ9ZnVuY3Rpb24gZW5jb2RlQ29tcHJlc3NlZChlbmMpe3JldHVybiB0aGlzLmVuY29kZShlbmMsdHJ1ZSl9O0Jhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZT1mdW5jdGlvbiBfZW5jb2RlKGNvbXBhY3Qpe3ZhciBsZW49dGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTt2YXIgeD10aGlzLmdldFgoKS50b0FycmF5KFwiYmVcIixsZW4pO2lmKGNvbXBhY3QpcmV0dXJuW3RoaXMuZ2V0WSgpLmlzRXZlbigpPzI6M10uY29uY2F0KHgpO3JldHVybls0XS5jb25jYXQoeCx0aGlzLmdldFkoKS50b0FycmF5KFwiYmVcIixsZW4pKX07QmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24gZW5jb2RlKGVuYyxjb21wYWN0KXtyZXR1cm4gdXRpbHNfMSQxLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksZW5jKX07QmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlPWZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpe2lmKHRoaXMucHJlY29tcHV0ZWQpcmV0dXJuIHRoaXM7dmFyIHByZWNvbXB1dGVkPXtkb3VibGVzOm51bGwsbmFmOm51bGwsYmV0YTpudWxsfTtwcmVjb21wdXRlZC5uYWY9dGhpcy5fZ2V0TkFGUG9pbnRzKDgpO3ByZWNvbXB1dGVkLmRvdWJsZXM9dGhpcy5fZ2V0RG91Ymxlcyg0LHBvd2VyKTtwcmVjb21wdXRlZC5iZXRhPXRoaXMuX2dldEJldGEoKTt0aGlzLnByZWNvbXB1dGVkPXByZWNvbXB1dGVkO3JldHVybiB0aGlzfTtCYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzPWZ1bmN0aW9uIF9oYXNEb3VibGVzKGspe2lmKCF0aGlzLnByZWNvbXB1dGVkKXJldHVybiBmYWxzZTt2YXIgZG91Ymxlcz10aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7aWYoIWRvdWJsZXMpcmV0dXJuIGZhbHNlO3JldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGg+PU1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSsxKS9kb3VibGVzLnN0ZXApfTtCYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzPWZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAscG93ZXIpe2lmKHRoaXMucHJlY29tcHV0ZWQmJnRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylyZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO3ZhciBkb3VibGVzPVt0aGlzXTt2YXIgYWNjPXRoaXM7Zm9yKHZhciBpPTA7aTxwb3dlcjtpKz1zdGVwKXtmb3IodmFyIGo9MDtqPHN0ZXA7aisrKWFjYz1hY2MuZGJsKCk7ZG91Ymxlcy5wdXNoKGFjYyl9cmV0dXJue3N0ZXA6c3RlcCxwb2ludHM6ZG91Ymxlc319O0Jhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cz1mdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCl7aWYodGhpcy5wcmVjb21wdXRlZCYmdGhpcy5wcmVjb21wdXRlZC5uYWYpcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO3ZhciByZXM9W3RoaXNdO3ZhciBtYXg9KDE8PHduZCktMTt2YXIgZGJsPW1heD09PTE/bnVsbDp0aGlzLmRibCgpO2Zvcih2YXIgaT0xO2k8bWF4O2krKylyZXNbaV09cmVzW2ktMV0uYWRkKGRibCk7cmV0dXJue3duZDp3bmQscG9pbnRzOnJlc319O0Jhc2VQb2ludC5wcm90b3R5cGUuX2dldEJldGE9ZnVuY3Rpb24gX2dldEJldGEoKXtyZXR1cm4gbnVsbH07QmFzZVBvaW50LnByb3RvdHlwZS5kYmxwPWZ1bmN0aW9uIGRibHAoayl7dmFyIHI9dGhpcztmb3IodmFyIGk9MDtpPGs7aSsrKXI9ci5kYmwoKTtyZXR1cm4gcn07dmFyIGluaGVyaXRzX2Jyb3dzZXIkMT1jcmVhdGVDb21tb25qc01vZHVsZSQxKGZ1bmN0aW9uKG1vZHVsZSl7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PT1cImZ1bmN0aW9uXCIpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKGN0b3Isc3VwZXJDdG9yKXtpZihzdXBlckN0b3Ipe2N0b3Iuc3VwZXJfPXN1cGVyQ3RvcjtjdG9yLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpjdG9yLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KX19fWVsc2V7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMoY3RvcixzdXBlckN0b3Ipe2lmKHN1cGVyQ3Rvcil7Y3Rvci5zdXBlcl89c3VwZXJDdG9yO3ZhciBUZW1wQ3Rvcj1mdW5jdGlvbigpe307VGVtcEN0b3IucHJvdG90eXBlPXN1cGVyQ3Rvci5wcm90b3R5cGU7Y3Rvci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO2N0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPWN0b3J9fX19KTtcInVzZSBzdHJpY3RcIjt2YXIgYXNzZXJ0JDI9dXRpbHNfMSQxLmFzc2VydDtmdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpe2Jhc2UuY2FsbCh0aGlzLFwic2hvcnRcIixjb25mKTt0aGlzLmE9bmV3IGJuKGNvbmYuYSwxNikudG9SZWQodGhpcy5yZWQpO3RoaXMuYj1uZXcgYm4oY29uZi5iLDE2KS50b1JlZCh0aGlzLnJlZCk7dGhpcy50aW52PXRoaXMudHdvLnJlZEludm0oKTt0aGlzLnplcm9BPXRoaXMuYS5mcm9tUmVkKCkuY21wbigwKT09PTA7dGhpcy50aHJlZUE9dGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKT09PTA7dGhpcy5lbmRvPXRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTt0aGlzLl9lbmRvV25hZlQxPW5ldyBBcnJheSg0KTt0aGlzLl9lbmRvV25hZlQyPW5ldyBBcnJheSg0KX1pbmhlcml0c19icm93c2VyJDEoU2hvcnRDdXJ2ZSxiYXNlKTt2YXIgc2hvcnRfMT1TaG9ydEN1cnZlO1Nob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc209ZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKXtpZighdGhpcy56ZXJvQXx8IXRoaXMuZ3x8IXRoaXMubnx8dGhpcy5wLm1vZG4oMykhPT0xKXJldHVybjt2YXIgYmV0YTt2YXIgbGFtYmRhO2lmKGNvbmYuYmV0YSl7YmV0YT1uZXcgYm4oY29uZi5iZXRhLDE2KS50b1JlZCh0aGlzLnJlZCl9ZWxzZXt2YXIgYmV0YXM9dGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7YmV0YT1iZXRhc1swXS5jbXAoYmV0YXNbMV0pPDA/YmV0YXNbMF06YmV0YXNbMV07YmV0YT1iZXRhLnRvUmVkKHRoaXMucmVkKX1pZihjb25mLmxhbWJkYSl7bGFtYmRhPW5ldyBibihjb25mLmxhbWJkYSwxNil9ZWxzZXt2YXIgbGFtYmRhcz10aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtpZih0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSk9PT0wKXtsYW1iZGE9bGFtYmRhc1swXX1lbHNle2xhbWJkYT1sYW1iZGFzWzFdO2Fzc2VydCQyKHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpPT09MCl9fXZhciBiYXNpcztpZihjb25mLmJhc2lzKXtiYXNpcz1jb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpe3JldHVybnthOm5ldyBibih2ZWMuYSwxNiksYjpuZXcgYm4odmVjLmIsMTYpfX0pfWVsc2V7YmFzaXM9dGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSl9cmV0dXJue2JldGE6YmV0YSxsYW1iZGE6bGFtYmRhLGJhc2lzOmJhc2lzfX07U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9Sb290cz1mdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSl7dmFyIHJlZD1udW09PT10aGlzLnA/dGhpcy5yZWQ6Ym4ubW9udChudW0pO3ZhciB0aW52PW5ldyBibigyKS50b1JlZChyZWQpLnJlZEludm0oKTt2YXIgbnRpbnY9dGludi5yZWROZWcoKTt2YXIgcz1uZXcgYm4oMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO3ZhciBsMT1udGludi5yZWRBZGQocykuZnJvbVJlZCgpO3ZhciBsMj1udGludi5yZWRTdWIocykuZnJvbVJlZCgpO3JldHVybltsMSxsMl19O1Nob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXM9ZnVuY3Rpb24gX2dldEVuZG9CYXNpcyhsYW1iZGEpe3ZhciBhcHJ4U3FydD10aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkvMikpO3ZhciB1PWxhbWJkYTt2YXIgdj10aGlzLm4uY2xvbmUoKTt2YXIgeDE9bmV3IGJuKDEpO3ZhciB5MT1uZXcgYm4oMCk7dmFyIHgyPW5ldyBibigwKTt2YXIgeTI9bmV3IGJuKDEpO3ZhciBhMDt2YXIgYjA7dmFyIGExO3ZhciBiMTt2YXIgYTI7dmFyIGIyO3ZhciBwcmV2Ujt2YXIgaT0wO3ZhciByO3ZhciB4O3doaWxlKHUuY21wbigwKSE9PTApe3ZhciBxPXYuZGl2KHUpO3I9di5zdWIocS5tdWwodSkpO3g9eDIuc3ViKHEubXVsKHgxKSk7dmFyIHk9eTIuc3ViKHEubXVsKHkxKSk7aWYoIWExJiZyLmNtcChhcHJ4U3FydCk8MCl7YTA9cHJldlIubmVnKCk7YjA9eDE7YTE9ci5uZWcoKTtiMT14fWVsc2UgaWYoYTEmJisraT09PTIpe2JyZWFrfXByZXZSPXI7dj11O3U9cjt4Mj14MTt4MT14O3kyPXkxO3kxPXl9YTI9ci5uZWcoKTtiMj14O3ZhciBsZW4xPWExLnNxcigpLmFkZChiMS5zcXIoKSk7dmFyIGxlbjI9YTIuc3FyKCkuYWRkKGIyLnNxcigpKTtpZihsZW4yLmNtcChsZW4xKT49MCl7YTI9YTA7YjI9YjB9aWYoYTEubmVnYXRpdmUpe2ExPWExLm5lZygpO2IxPWIxLm5lZygpfWlmKGEyLm5lZ2F0aXZlKXthMj1hMi5uZWcoKTtiMj1iMi5uZWcoKX1yZXR1cm5be2E6YTEsYjpiMX0se2E6YTIsYjpiMn1dfTtTaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0PWZ1bmN0aW9uIF9lbmRvU3BsaXQoayl7dmFyIGJhc2lzPXRoaXMuZW5kby5iYXNpczt2YXIgdjE9YmFzaXNbMF07dmFyIHYyPWJhc2lzWzFdO3ZhciBjMT12Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO3ZhciBjMj12MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO3ZhciBwMT1jMS5tdWwodjEuYSk7dmFyIHAyPWMyLm11bCh2Mi5hKTt2YXIgcTE9YzEubXVsKHYxLmIpO3ZhciBxMj1jMi5tdWwodjIuYik7dmFyIGsxPWsuc3ViKHAxKS5zdWIocDIpO3ZhciBrMj1xMS5hZGQocTIpLm5lZygpO3JldHVybntrMTprMSxrMjprMn19O1Nob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbVg9ZnVuY3Rpb24gcG9pbnRGcm9tWCh4LG9kZCl7eD1uZXcgYm4oeCwxNik7aWYoIXgucmVkKXg9eC50b1JlZCh0aGlzLnJlZCk7dmFyIHkyPXgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoeC5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpO3ZhciB5PXkyLnJlZFNxcnQoKTtpZih5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykhPT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnRcIik7dmFyIGlzT2RkPXkuZnJvbVJlZCgpLmlzT2RkKCk7aWYob2RkJiYhaXNPZGR8fCFvZGQmJmlzT2RkKXk9eS5yZWROZWcoKTtyZXR1cm4gdGhpcy5wb2ludCh4LHkpfTtTaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbiB2YWxpZGF0ZShwb2ludCl7aWYocG9pbnQuaW5mKXJldHVybiB0cnVlO3ZhciB4PXBvaW50Lng7dmFyIHk9cG9pbnQueTt2YXIgYXg9dGhpcy5hLnJlZE11bCh4KTt2YXIgcmhzPXgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtyZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKT09PTB9O1Nob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZD1mdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLGNvZWZmcyxqYWNvYmlhblJlc3VsdCl7dmFyIG5wb2ludHM9dGhpcy5fZW5kb1duYWZUMTt2YXIgbmNvZWZmcz10aGlzLl9lbmRvV25hZlQyO2Zvcih2YXIgaT0wO2k8cG9pbnRzLmxlbmd0aDtpKyspe3ZhciBzcGxpdD10aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTt2YXIgcD1wb2ludHNbaV07dmFyIGJldGE9cC5fZ2V0QmV0YSgpO2lmKHNwbGl0LmsxLm5lZ2F0aXZlKXtzcGxpdC5rMS5pbmVnKCk7cD1wLm5lZyh0cnVlKX1pZihzcGxpdC5rMi5uZWdhdGl2ZSl7c3BsaXQuazIuaW5lZygpO2JldGE9YmV0YS5uZWcodHJ1ZSl9bnBvaW50c1tpKjJdPXA7bnBvaW50c1tpKjIrMV09YmV0YTtuY29lZmZzW2kqMl09c3BsaXQuazE7bmNvZWZmc1tpKjIrMV09c3BsaXQuazJ9dmFyIHJlcz10aGlzLl93bmFmTXVsQWRkKDEsbnBvaW50cyxuY29lZmZzLGkqMixqYWNvYmlhblJlc3VsdCk7Zm9yKHZhciBqPTA7ajxpKjI7aisrKXtucG9pbnRzW2pdPW51bGw7bmNvZWZmc1tqXT1udWxsfXJldHVybiByZXN9O2Z1bmN0aW9uIFBvaW50KGN1cnZlLHgseSxpc1JlZCl7YmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLGN1cnZlLFwiYWZmaW5lXCIpO2lmKHg9PT1udWxsJiZ5PT09bnVsbCl7dGhpcy54PW51bGw7dGhpcy55PW51bGw7dGhpcy5pbmY9dHJ1ZX1lbHNle3RoaXMueD1uZXcgYm4oeCwxNik7dGhpcy55PW5ldyBibih5LDE2KTtpZihpc1JlZCl7dGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTt0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpfWlmKCF0aGlzLngucmVkKXRoaXMueD10aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO2lmKCF0aGlzLnkucmVkKXRoaXMueT10aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO3RoaXMuaW5mPWZhbHNlfX1pbmhlcml0c19icm93c2VyJDEoUG9pbnQsYmFzZS5CYXNlUG9pbnQpO1Nob3J0Q3VydmUucHJvdG90eXBlLnBvaW50PWZ1bmN0aW9uIHBvaW50KHgseSxpc1JlZCl7cmV0dXJuIG5ldyBQb2ludCh0aGlzLHgseSxpc1JlZCl9O1Nob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT049ZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmoscmVkKXtyZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcyxvYmoscmVkKX07UG9pbnQucHJvdG90eXBlLl9nZXRCZXRhPWZ1bmN0aW9uIF9nZXRCZXRhKCl7aWYoIXRoaXMuY3VydmUuZW5kbylyZXR1cm47dmFyIHByZT10aGlzLnByZWNvbXB1dGVkO2lmKHByZSYmcHJlLmJldGEpcmV0dXJuIHByZS5iZXRhO3ZhciBiZXRhPXRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksdGhpcy55KTtpZihwcmUpe3ZhciBjdXJ2ZT10aGlzLmN1cnZlO3ZhciBlbmRvTXVsPWZ1bmN0aW9uKHApe3JldHVybiBjdXJ2ZS5wb2ludChwLngucmVkTXVsKGN1cnZlLmVuZG8uYmV0YSkscC55KX07cHJlLmJldGE9YmV0YTtiZXRhLnByZWNvbXB1dGVkPXtiZXRhOm51bGwsbmFmOnByZS5uYWYmJnt3bmQ6cHJlLm5hZi53bmQscG9pbnRzOnByZS5uYWYucG9pbnRzLm1hcChlbmRvTXVsKX0sZG91YmxlczpwcmUuZG91YmxlcyYme3N0ZXA6cHJlLmRvdWJsZXMuc3RlcCxwb2ludHM6cHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKX19fXJldHVybiBiZXRhfTtQb2ludC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe2lmKCF0aGlzLnByZWNvbXB1dGVkKXJldHVyblt0aGlzLngsdGhpcy55XTtyZXR1cm5bdGhpcy54LHRoaXMueSx0aGlzLnByZWNvbXB1dGVkJiZ7ZG91Ymxlczp0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMmJntzdGVwOnRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLHBvaW50czp0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpfSxuYWY6dGhpcy5wcmVjb21wdXRlZC5uYWYmJnt3bmQ6dGhpcy5wcmVjb21wdXRlZC5uYWYud25kLHBvaW50czp0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSl9fV19O1BvaW50LmZyb21KU09OPWZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLG9iaixyZWQpe2lmKHR5cGVvZiBvYmo9PT1cInN0cmluZ1wiKW9iaj1KU09OLnBhcnNlKG9iaik7dmFyIHJlcz1jdXJ2ZS5wb2ludChvYmpbMF0sb2JqWzFdLHJlZCk7aWYoIW9ialsyXSlyZXR1cm4gcmVzO2Z1bmN0aW9uIG9iajJwb2ludChvYmope3JldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sb2JqWzFdLHJlZCl9dmFyIHByZT1vYmpbMl07cmVzLnByZWNvbXB1dGVkPXtiZXRhOm51bGwsZG91YmxlczpwcmUuZG91YmxlcyYme3N0ZXA6cHJlLmRvdWJsZXMuc3RlcCxwb2ludHM6W3Jlc10uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSl9LG5hZjpwcmUubmFmJiZ7d25kOnByZS5uYWYud25kLHBvaW50czpbcmVzXS5jb25jYXQocHJlLm5hZi5wb2ludHMubWFwKG9iajJwb2ludCkpfX07cmV0dXJuIHJlc307UG9pbnQucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVyblwiPEVDIFBvaW50IEluZmluaXR5PlwiO3JldHVyblwiPEVDIFBvaW50IHg6IFwiK3RoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsMikrXCIgeTogXCIrdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwyKStcIj5cIn07UG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHk9ZnVuY3Rpb24gaXNJbmZpbml0eSgpe3JldHVybiB0aGlzLmluZn07UG9pbnQucHJvdG90eXBlLmFkZD1mdW5jdGlvbiBhZGQocCl7aWYodGhpcy5pbmYpcmV0dXJuIHA7aWYocC5pbmYpcmV0dXJuIHRoaXM7aWYodGhpcy5lcShwKSlyZXR1cm4gdGhpcy5kYmwoKTtpZih0aGlzLm5lZygpLmVxKHApKXJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsbnVsbCk7aWYodGhpcy54LmNtcChwLngpPT09MClyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLG51bGwpO3ZhciBjPXRoaXMueS5yZWRTdWIocC55KTtpZihjLmNtcG4oMCkhPT0wKWM9Yy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7dmFyIG54PWMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTt2YXIgbnk9Yy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCxueSl9O1BvaW50LnByb3RvdHlwZS5kYmw9ZnVuY3Rpb24gZGJsKCl7aWYodGhpcy5pbmYpcmV0dXJuIHRoaXM7dmFyIHlzMT10aGlzLnkucmVkQWRkKHRoaXMueSk7aWYoeXMxLmNtcG4oMCk9PT0wKXJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsbnVsbCk7dmFyIGE9dGhpcy5jdXJ2ZS5hO3ZhciB4Mj10aGlzLngucmVkU3FyKCk7dmFyIGR5aW52PXlzMS5yZWRJbnZtKCk7dmFyIGM9eDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7dmFyIG54PWMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpO3ZhciBueT1jLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO3JldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LG55KX07UG9pbnQucHJvdG90eXBlLmdldFg9ZnVuY3Rpb24gZ2V0WCgpe3JldHVybiB0aGlzLnguZnJvbVJlZCgpfTtQb2ludC5wcm90b3R5cGUuZ2V0WT1mdW5jdGlvbiBnZXRZKCl7cmV0dXJuIHRoaXMueS5mcm9tUmVkKCl9O1BvaW50LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24gbXVsKGspe2s9bmV3IGJuKGssMTYpO2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2Vsc2UgaWYodGhpcy5faGFzRG91YmxlcyhrKSlyZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcyxrKTtlbHNlIGlmKHRoaXMuY3VydmUuZW5kbylyZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoW3RoaXNdLFtrXSk7ZWxzZSByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLGspfTtQb2ludC5wcm90b3R5cGUubXVsQWRkPWZ1bmN0aW9uIG11bEFkZChrMSxwMixrMil7dmFyIHBvaW50cz1bdGhpcyxwMl07dmFyIGNvZWZmcz1bazEsazJdO2lmKHRoaXMuY3VydmUuZW5kbylyZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLGNvZWZmcyk7ZWxzZSByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLHBvaW50cyxjb2VmZnMsMil9O1BvaW50LnByb3RvdHlwZS5qbXVsQWRkPWZ1bmN0aW9uIGptdWxBZGQoazEscDIsazIpe3ZhciBwb2ludHM9W3RoaXMscDJdO3ZhciBjb2VmZnM9W2sxLGsyXTtpZih0aGlzLmN1cnZlLmVuZG8pcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cyxjb2VmZnMsdHJ1ZSk7ZWxzZSByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLHBvaW50cyxjb2VmZnMsMix0cnVlKX07UG9pbnQucHJvdG90eXBlLmVxPWZ1bmN0aW9uIGVxKHApe3JldHVybiB0aGlzPT09cHx8dGhpcy5pbmY9PT1wLmluZiYmKHRoaXMuaW5mfHx0aGlzLnguY21wKHAueCk9PT0wJiZ0aGlzLnkuY21wKHAueSk9PT0wKX07UG9pbnQucHJvdG90eXBlLm5lZz1mdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpe2lmKHRoaXMuaW5mKXJldHVybiB0aGlzO3ZhciByZXM9dGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsdGhpcy55LnJlZE5lZygpKTtpZihfcHJlY29tcHV0ZSYmdGhpcy5wcmVjb21wdXRlZCl7dmFyIHByZT10aGlzLnByZWNvbXB1dGVkO3ZhciBuZWdhdGU9ZnVuY3Rpb24ocCl7cmV0dXJuIHAubmVnKCl9O3Jlcy5wcmVjb21wdXRlZD17bmFmOnByZS5uYWYmJnt3bmQ6cHJlLm5hZi53bmQscG9pbnRzOnByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpfSxkb3VibGVzOnByZS5kb3VibGVzJiZ7c3RlcDpwcmUuZG91Ymxlcy5zdGVwLHBvaW50czpwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSl9fX1yZXR1cm4gcmVzfTtQb2ludC5wcm90b3R5cGUudG9KPWZ1bmN0aW9uIHRvSigpe2lmKHRoaXMuaW5mKXJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLG51bGwsbnVsbCk7dmFyIHJlcz10aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsdGhpcy55LHRoaXMuY3VydmUub25lKTtyZXR1cm4gcmVzfTtmdW5jdGlvbiBKUG9pbnQoY3VydmUseCx5LHope2Jhc2UuQmFzZVBvaW50LmNhbGwodGhpcyxjdXJ2ZSxcImphY29iaWFuXCIpO2lmKHg9PT1udWxsJiZ5PT09bnVsbCYmej09PW51bGwpe3RoaXMueD10aGlzLmN1cnZlLm9uZTt0aGlzLnk9dGhpcy5jdXJ2ZS5vbmU7dGhpcy56PW5ldyBibigwKX1lbHNle3RoaXMueD1uZXcgYm4oeCwxNik7dGhpcy55PW5ldyBibih5LDE2KTt0aGlzLno9bmV3IGJuKHosMTYpfWlmKCF0aGlzLngucmVkKXRoaXMueD10aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO2lmKCF0aGlzLnkucmVkKXRoaXMueT10aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO2lmKCF0aGlzLnoucmVkKXRoaXMuej10aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO3RoaXMuek9uZT10aGlzLno9PT10aGlzLmN1cnZlLm9uZX1pbmhlcml0c19icm93c2VyJDEoSlBvaW50LGJhc2UuQmFzZVBvaW50KTtTaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQ9ZnVuY3Rpb24ganBvaW50KHgseSx6KXtyZXR1cm4gbmV3IEpQb2ludCh0aGlzLHgseSx6KX07SlBvaW50LnByb3RvdHlwZS50b1A9ZnVuY3Rpb24gdG9QKCl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCxudWxsKTt2YXIgemludj10aGlzLnoucmVkSW52bSgpO3ZhciB6aW52Mj16aW52LnJlZFNxcigpO3ZhciBheD10aGlzLngucmVkTXVsKHppbnYyKTt2YXIgYXk9dGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO3JldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LGF5KX07SlBvaW50LnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24gbmVnKCl7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCx0aGlzLnkucmVkTmVnKCksdGhpcy56KX07SlBvaW50LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24gYWRkKHApe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiBwO2lmKHAuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO3ZhciBwejI9cC56LnJlZFNxcigpO3ZhciB6Mj10aGlzLnoucmVkU3FyKCk7dmFyIHUxPXRoaXMueC5yZWRNdWwocHoyKTt2YXIgdTI9cC54LnJlZE11bCh6Mik7dmFyIHMxPXRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTt2YXIgczI9cC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7dmFyIGg9dTEucmVkU3ViKHUyKTt2YXIgcj1zMS5yZWRTdWIoczIpO2lmKGguY21wbigwKT09PTApe2lmKHIuY21wbigwKSE9PTApcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsbnVsbCxudWxsKTtlbHNlIHJldHVybiB0aGlzLmRibCgpfXZhciBoMj1oLnJlZFNxcigpO3ZhciBoMz1oMi5yZWRNdWwoaCk7dmFyIHY9dTEucmVkTXVsKGgyKTt2YXIgbng9ci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7dmFyIG55PXIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7dmFyIG56PXRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LG55LG56KX07SlBvaW50LnByb3RvdHlwZS5taXhlZEFkZD1mdW5jdGlvbiBtaXhlZEFkZChwKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gcC50b0ooKTtpZihwLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpczt2YXIgejI9dGhpcy56LnJlZFNxcigpO3ZhciB1MT10aGlzLng7dmFyIHUyPXAueC5yZWRNdWwoejIpO3ZhciBzMT10aGlzLnk7dmFyIHMyPXAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopO3ZhciBoPXUxLnJlZFN1Yih1Mik7dmFyIHI9czEucmVkU3ViKHMyKTtpZihoLmNtcG4oMCk9PT0wKXtpZihyLmNtcG4oMCkhPT0wKXJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLG51bGwsbnVsbCk7ZWxzZSByZXR1cm4gdGhpcy5kYmwoKX12YXIgaDI9aC5yZWRTcXIoKTt2YXIgaDM9aDIucmVkTXVsKGgpO3ZhciB2PXUxLnJlZE11bChoMik7dmFyIG54PXIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO3ZhciBueT1yLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO3ZhciBuej10aGlzLnoucmVkTXVsKGgpO3JldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCxueSxueil9O0pQb2ludC5wcm90b3R5cGUuZGJscD1mdW5jdGlvbiBkYmxwKHBvdyl7aWYocG93PT09MClyZXR1cm4gdGhpcztpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZighcG93KXJldHVybiB0aGlzLmRibCgpO3ZhciBpO2lmKHRoaXMuY3VydmUuemVyb0F8fHRoaXMuY3VydmUudGhyZWVBKXt2YXIgcj10aGlzO2ZvcihpPTA7aTxwb3c7aSsrKXI9ci5kYmwoKTtyZXR1cm4gcn12YXIgYT10aGlzLmN1cnZlLmE7dmFyIHRpbnY9dGhpcy5jdXJ2ZS50aW52O3ZhciBqeD10aGlzLng7dmFyIGp5PXRoaXMueTt2YXIgano9dGhpcy56O3ZhciBqejQ9anoucmVkU3FyKCkucmVkU3FyKCk7dmFyIGp5ZD1qeS5yZWRBZGQoankpO2ZvcihpPTA7aTxwb3c7aSsrKXt2YXIgangyPWp4LnJlZFNxcigpO3ZhciBqeWQyPWp5ZC5yZWRTcXIoKTt2YXIganlkND1qeWQyLnJlZFNxcigpO3ZhciBjPWp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTt2YXIgdDE9angucmVkTXVsKGp5ZDIpO3ZhciBueD1jLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7dmFyIHQyPXQxLnJlZElTdWIobngpO3ZhciBkbnk9Yy5yZWRNdWwodDIpO2RueT1kbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7dmFyIG56PWp5ZC5yZWRNdWwoanopO2lmKGkrMTxwb3cpano0PWp6NC5yZWRNdWwoanlkNCk7ang9bng7ano9bno7anlkPWRueX1yZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsanlkLnJlZE11bCh0aW52KSxqeil9O0pQb2ludC5wcm90b3R5cGUuZGJsPWZ1bmN0aW9uIGRibCgpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2lmKHRoaXMuY3VydmUuemVyb0EpcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtlbHNlIGlmKHRoaXMuY3VydmUudGhyZWVBKXJldHVybiB0aGlzLl90aHJlZURibCgpO2Vsc2UgcmV0dXJuIHRoaXMuX2RibCgpfTtKUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsPWZ1bmN0aW9uIF96ZXJvRGJsKCl7dmFyIG54O3ZhciBueTt2YXIgbno7aWYodGhpcy56T25lKXt2YXIgeHg9dGhpcy54LnJlZFNxcigpO3ZhciB5eT10aGlzLnkucmVkU3FyKCk7dmFyIHl5eXk9eXkucmVkU3FyKCk7dmFyIHM9dGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtzPXMucmVkSUFkZChzKTt2YXIgbT14eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO3ZhciB0PW0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO3ZhciB5eXl5OD15eXl5LnJlZElBZGQoeXl5eSk7eXl5eTg9eXl5eTgucmVkSUFkZCh5eXl5OCk7eXl5eTg9eXl5eTgucmVkSUFkZCh5eXl5OCk7bng9dDtueT1tLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO256PXRoaXMueS5yZWRBZGQodGhpcy55KX1lbHNle3ZhciBhPXRoaXMueC5yZWRTcXIoKTt2YXIgYj10aGlzLnkucmVkU3FyKCk7dmFyIGM9Yi5yZWRTcXIoKTt2YXIgZD10aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKTtkPWQucmVkSUFkZChkKTt2YXIgZT1hLnJlZEFkZChhKS5yZWRJQWRkKGEpO3ZhciBmPWUucmVkU3FyKCk7dmFyIGM4PWMucmVkSUFkZChjKTtjOD1jOC5yZWRJQWRkKGM4KTtjOD1jOC5yZWRJQWRkKGM4KTtueD1mLnJlZElTdWIoZCkucmVkSVN1YihkKTtueT1lLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtuej10aGlzLnkucmVkTXVsKHRoaXMueik7bno9bnoucmVkSUFkZChueil9cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LG55LG56KX07SlBvaW50LnByb3RvdHlwZS5fdGhyZWVEYmw9ZnVuY3Rpb24gX3RocmVlRGJsKCl7dmFyIG54O3ZhciBueTt2YXIgbno7aWYodGhpcy56T25lKXt2YXIgeHg9dGhpcy54LnJlZFNxcigpO3ZhciB5eT10aGlzLnkucmVkU3FyKCk7dmFyIHl5eXk9eXkucmVkU3FyKCk7dmFyIHM9dGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtzPXMucmVkSUFkZChzKTt2YXIgbT14eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTt2YXIgdD1tLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtueD10O3ZhciB5eXl5OD15eXl5LnJlZElBZGQoeXl5eSk7eXl5eTg9eXl5eTgucmVkSUFkZCh5eXl5OCk7eXl5eTg9eXl5eTgucmVkSUFkZCh5eXl5OCk7bnk9bS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtuej10aGlzLnkucmVkQWRkKHRoaXMueSl9ZWxzZXt2YXIgZGVsdGE9dGhpcy56LnJlZFNxcigpO3ZhciBnYW1tYT10aGlzLnkucmVkU3FyKCk7dmFyIGJldGE9dGhpcy54LnJlZE11bChnYW1tYSk7dmFyIGFscGhhPXRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7YWxwaGE9YWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTt2YXIgYmV0YTQ9YmV0YS5yZWRJQWRkKGJldGEpO2JldGE0PWJldGE0LnJlZElBZGQoYmV0YTQpO3ZhciBiZXRhOD1iZXRhNC5yZWRBZGQoYmV0YTQpO254PWFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO256PXRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGdhbW1hKS5yZWRJU3ViKGRlbHRhKTt2YXIgZ2dhbW1hOD1nYW1tYS5yZWRTcXIoKTtnZ2FtbWE4PWdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtnZ2FtbWE4PWdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtnZ2FtbWE4PWdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtueT1hbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCl9cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LG55LG56KX07SlBvaW50LnByb3RvdHlwZS5fZGJsPWZ1bmN0aW9uIF9kYmwoKXt2YXIgYT10aGlzLmN1cnZlLmE7dmFyIGp4PXRoaXMueDt2YXIgank9dGhpcy55O3ZhciBqej10aGlzLno7dmFyIGp6ND1qei5yZWRTcXIoKS5yZWRTcXIoKTt2YXIgangyPWp4LnJlZFNxcigpO3ZhciBqeTI9ankucmVkU3FyKCk7dmFyIGM9angyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO3ZhciBqeGQ0PWp4LnJlZEFkZChqeCk7anhkND1qeGQ0LnJlZElBZGQoanhkNCk7dmFyIHQxPWp4ZDQucmVkTXVsKGp5Mik7dmFyIG54PWMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTt2YXIgdDI9dDEucmVkSVN1YihueCk7dmFyIGp5ZDg9ankyLnJlZFNxcigpO2p5ZDg9anlkOC5yZWRJQWRkKGp5ZDgpO2p5ZDg9anlkOC5yZWRJQWRkKGp5ZDgpO2p5ZDg9anlkOC5yZWRJQWRkKGp5ZDgpO3ZhciBueT1jLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTt2YXIgbno9ankucmVkQWRkKGp5KS5yZWRNdWwoanopO3JldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCxueSxueil9O0pQb2ludC5wcm90b3R5cGUudHJwbD1mdW5jdGlvbiB0cnBsKCl7aWYoIXRoaXMuY3VydmUuemVyb0EpcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO3ZhciB4eD10aGlzLngucmVkU3FyKCk7dmFyIHl5PXRoaXMueS5yZWRTcXIoKTt2YXIgeno9dGhpcy56LnJlZFNxcigpO3ZhciB5eXl5PXl5LnJlZFNxcigpO3ZhciBtPXh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7dmFyIG1tPW0ucmVkU3FyKCk7dmFyIGU9dGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtlPWUucmVkSUFkZChlKTtlPWUucmVkQWRkKGUpLnJlZElBZGQoZSk7ZT1lLnJlZElTdWIobW0pO3ZhciBlZT1lLnJlZFNxcigpO3ZhciB0PXl5eXkucmVkSUFkZCh5eXl5KTt0PXQucmVkSUFkZCh0KTt0PXQucmVkSUFkZCh0KTt0PXQucmVkSUFkZCh0KTt2YXIgdT1tLnJlZElBZGQoZSkucmVkU3FyKCkucmVkSVN1YihtbSkucmVkSVN1YihlZSkucmVkSVN1Yih0KTt2YXIgeXl1ND15eS5yZWRNdWwodSk7eXl1ND15eXU0LnJlZElBZGQoeXl1NCk7eXl1ND15eXU0LnJlZElBZGQoeXl1NCk7dmFyIG54PXRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7bng9bngucmVkSUFkZChueCk7bng9bngucmVkSUFkZChueCk7dmFyIG55PXRoaXMueS5yZWRNdWwodS5yZWRNdWwodC5yZWRJU3ViKHUpKS5yZWRJU3ViKGUucmVkTXVsKGVlKSkpO255PW55LnJlZElBZGQobnkpO255PW55LnJlZElBZGQobnkpO255PW55LnJlZElBZGQobnkpO3ZhciBuej10aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO3JldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCxueSxueil9O0pQb2ludC5wcm90b3R5cGUubXVsPWZ1bmN0aW9uIG11bChrLGtiYXNlKXtrPW5ldyBibihrLGtiYXNlKTtyZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLGspfTtKUG9pbnQucHJvdG90eXBlLmVxPWZ1bmN0aW9uIGVxKHApe2lmKHAudHlwZT09PVwiYWZmaW5lXCIpcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7aWYodGhpcz09PXApcmV0dXJuIHRydWU7dmFyIHoyPXRoaXMuei5yZWRTcXIoKTt2YXIgcHoyPXAuei5yZWRTcXIoKTtpZih0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSE9PTApcmV0dXJuIGZhbHNlO3ZhciB6Mz16Mi5yZWRNdWwodGhpcy56KTt2YXIgcHozPXB6Mi5yZWRNdWwocC56KTtyZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCk9PT0wfTtKUG9pbnQucHJvdG90eXBlLmVxWFRvUD1mdW5jdGlvbiBlcVhUb1AoeCl7dmFyIHpzPXRoaXMuei5yZWRTcXIoKTt2YXIgcng9eC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHpzKTtpZih0aGlzLnguY21wKHJ4KT09PTApcmV0dXJuIHRydWU7dmFyIHhjPXguY2xvbmUoKTt2YXIgdD10aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHpzKTtmb3IoOzspe3hjLmlhZGQodGhpcy5jdXJ2ZS5uKTtpZih4Yy5jbXAodGhpcy5jdXJ2ZS5wKT49MClyZXR1cm4gZmFsc2U7cngucmVkSUFkZCh0KTtpZih0aGlzLnguY21wKHJ4KT09PTApcmV0dXJuIHRydWV9fTtKUG9pbnQucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVyblwiPEVDIEpQb2ludCBJbmZpbml0eT5cIjtyZXR1cm5cIjxFQyBKUG9pbnQgeDogXCIrdGhpcy54LnRvU3RyaW5nKDE2LDIpK1wiIHk6IFwiK3RoaXMueS50b1N0cmluZygxNiwyKStcIiB6OiBcIit0aGlzLnoudG9TdHJpbmcoMTYsMikrXCI+XCJ9O0pQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eT1mdW5jdGlvbiBpc0luZmluaXR5KCl7cmV0dXJuIHRoaXMuei5jbXBuKDApPT09MH07dmFyIGN1cnZlXzE9Y3JlYXRlQ29tbW9uanNNb2R1bGUkMShmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGN1cnZlPWV4cG9ydHM7Y3VydmUuYmFzZT1iYXNlO2N1cnZlLnNob3J0PXNob3J0XzE7Y3VydmUubW9udD1udWxsO2N1cnZlLmVkd2FyZHM9bnVsbH0pO3ZhciBjdXJ2ZXNfMT1jcmVhdGVDb21tb25qc01vZHVsZSQxKGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgY3VydmVzPWV4cG9ydHM7dmFyIGFzc2VydD11dGlsc18xJDEuYXNzZXJ0O2Z1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpe2lmKG9wdGlvbnMudHlwZT09PVwic2hvcnRcIil0aGlzLmN1cnZlPW5ldyBjdXJ2ZV8xLnNob3J0KG9wdGlvbnMpO2Vsc2UgaWYob3B0aW9ucy50eXBlPT09XCJlZHdhcmRzXCIpdGhpcy5jdXJ2ZT1uZXcgY3VydmVfMS5lZHdhcmRzKG9wdGlvbnMpO2Vsc2UgdGhpcy5jdXJ2ZT1uZXcgY3VydmVfMS5tb250KG9wdGlvbnMpO3RoaXMuZz10aGlzLmN1cnZlLmc7dGhpcy5uPXRoaXMuY3VydmUubjt0aGlzLmhhc2g9b3B0aW9ucy5oYXNoO2Fzc2VydCh0aGlzLmcudmFsaWRhdGUoKSxcIkludmFsaWQgY3VydmVcIik7YXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksXCJJbnZhbGlkIGN1cnZlLCBHKk4gIT0gT1wiKX1jdXJ2ZXMuUHJlc2V0Q3VydmU9UHJlc2V0Q3VydmU7ZnVuY3Rpb24gZGVmaW5lQ3VydmUobmFtZSxvcHRpb25zKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLG5hbWUse2NvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXt2YXIgY3VydmU9bmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsbmFtZSx7Y29uZmlndXJhYmxlOnRydWUsZW51bWVyYWJsZTp0cnVlLHZhbHVlOmN1cnZlfSk7cmV0dXJuIGN1cnZlfX0pfWRlZmluZUN1cnZlKFwicDE5MlwiLHt0eXBlOlwic2hvcnRcIixwcmltZTpcInAxOTJcIixwOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmZcIixhOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmNcIixiOlwiNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjFcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzFcIixoYXNoOmhhc2hfMS5zaGEyNTYsZ1JlZDpmYWxzZSxnOltcIjE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyXCIsXCIwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMVwiXX0pO2RlZmluZUN1cnZlKFwicDIyNFwiLHt0eXBlOlwic2hvcnRcIixwcmltZTpcInAyMjRcIixwOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcIixhOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmVcIixiOlwiYjQwNTBhODUgMGMwNGIzYWIgZjU0MTMyNTYgNTA0NGIwYjcgZDdiZmQ4YmEgMjcwYjM5NDMgMjM1NWZmYjRcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2RcIixoYXNoOmhhc2hfMS5zaGEyNTYsZ1JlZDpmYWxzZSxnOltcImI3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxXCIsXCJiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNFwiXX0pO2RlZmluZUN1cnZlKFwicDI1NlwiLHt0eXBlOlwic2hvcnRcIixwcmltZTpudWxsLHA6XCJmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZlwiLGE6XCJmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmY1wiLGI6XCI1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YlwiLG46XCJmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MVwiLGhhc2g6aGFzaF8xLnNoYTI1NixnUmVkOmZhbHNlLGc6W1wiNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTZcIixcIjRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1XCJdfSk7ZGVmaW5lQ3VydmUoXCJwMzg0XCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOm51bGwscDpcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIFwiK1wiZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmZcIixhOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgXCIrXCJmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmY1wiLGI6XCJiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOSAxODFkOWM2ZSBmZTgxNDExMiAwMzE0MDg4ZiBcIitcIjUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmXCIsbjpcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxIFwiK1wiZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzNcIixoYXNoOmhhc2hfMS5zaGEzODQsZ1JlZDpmYWxzZSxnOltcImFhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4IFwiK1wiNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjdcIixcIjM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwIFwiK1wiMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWZcIl19KTtkZWZpbmVDdXJ2ZShcInA1MjFcIix7dHlwZTpcInNob3J0XCIscHJpbWU6bnVsbCxwOlwiMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgXCIrXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBcIitcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmXCIsYTpcIjAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIFwiK1wiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgXCIrXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmY1wiLGI6XCIwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiBcIitcIjk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkIFwiK1wiM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDBcIixuOlwiMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgXCIrXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCBcIitcImY3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5XCIsaGFzaDpoYXNoXzEuc2hhNTEyLGdSZWQ6ZmFsc2UsZzpbXCIwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSBcIitcIjA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3IFwiK1wiYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjZcIixcIjAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5IFwiK1wiNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgXCIrXCIzZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MFwiXX0pO2RlZmluZUN1cnZlKFwiY3VydmUyNTUxOVwiLHt0eXBlOlwibW9udFwiLHByaW1lOlwicDI1NTE5XCIscDpcIjdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWRcIixhOlwiNzZkMDZcIixiOlwiMVwiLG46XCIxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkXCIsaGFzaDpoYXNoXzEuc2hhMjU2LGdSZWQ6ZmFsc2UsZzpbXCI5XCJdfSk7ZGVmaW5lQ3VydmUoXCJlZDI1NTE5XCIse3R5cGU6XCJlZHdhcmRzXCIscHJpbWU6XCJwMjU1MTlcIixwOlwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiLGE6XCItMVwiLGM6XCIxXCIsZDpcIjUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTNcIixuOlwiMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZFwiLGhhc2g6aGFzaF8xLnNoYTI1NixnUmVkOmZhbHNlLGc6W1wiMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYVwiLFwiNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OFwiXX0pO3ZhciBwcmU7dHJ5e3ByZT1udWxsLmNyYXNoKCl9Y2F0Y2goZSl7cHJlPXVuZGVmaW5lZH1kZWZpbmVDdXJ2ZShcInNlY3AyNTZrMVwiLHt0eXBlOlwic2hvcnRcIixwcmltZTpcImsyNTZcIixwOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIixhOlwiMFwiLGI6XCI3XCIsbjpcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxXCIsaDpcIjFcIixoYXNoOmhhc2hfMS5zaGEyNTYsYmV0YTpcIjdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWVcIixsYW1iZGE6XCI1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyXCIsYmFzaXM6W3thOlwiMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIixiOlwiLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzXCJ9LHthOlwiMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4XCIsYjpcIjMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1XCJ9XSxnUmVkOmZhbHNlLGc6W1wiNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OFwiLFwiNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOFwiLHByZV19KX0pO1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlyZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO3RoaXMuaGFzaD1vcHRpb25zLmhhc2g7dGhpcy5wcmVkUmVzaXN0PSEhb3B0aW9ucy5wcmVkUmVzaXN0O3RoaXMub3V0TGVuPXRoaXMuaGFzaC5vdXRTaXplO3RoaXMubWluRW50cm9weT1vcHRpb25zLm1pbkVudHJvcHl8fHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7dGhpcy5fcmVzZWVkPW51bGw7dGhpcy5yZXNlZWRJbnRlcnZhbD1udWxsO3RoaXMuSz1udWxsO3RoaXMuVj1udWxsO3ZhciBlbnRyb3B5PXV0aWxzXzEudG9BcnJheShvcHRpb25zLmVudHJvcHksb3B0aW9ucy5lbnRyb3B5RW5jfHxcImhleFwiKTt2YXIgbm9uY2U9dXRpbHNfMS50b0FycmF5KG9wdGlvbnMubm9uY2Usb3B0aW9ucy5ub25jZUVuY3x8XCJoZXhcIik7dmFyIHBlcnM9dXRpbHNfMS50b0FycmF5KG9wdGlvbnMucGVycyxvcHRpb25zLnBlcnNFbmN8fFwiaGV4XCIpO21pbmltYWxpc3RpY0Fzc2VydCQxKGVudHJvcHkubGVuZ3RoPj10aGlzLm1pbkVudHJvcHkvOCxcIk5vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogXCIrdGhpcy5taW5FbnRyb3B5K1wiIGJpdHNcIik7dGhpcy5faW5pdChlbnRyb3B5LG5vbmNlLHBlcnMpfXZhciBobWFjRHJiZz1IbWFjRFJCRztIbWFjRFJCRy5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24gaW5pdChlbnRyb3B5LG5vbmNlLHBlcnMpe3ZhciBzZWVkPWVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7dGhpcy5LPW5ldyBBcnJheSh0aGlzLm91dExlbi84KTt0aGlzLlY9bmV3IEFycmF5KHRoaXMub3V0TGVuLzgpO2Zvcih2YXIgaT0wO2k8dGhpcy5WLmxlbmd0aDtpKyspe3RoaXMuS1tpXT0wO3RoaXMuVltpXT0xfXRoaXMuX3VwZGF0ZShzZWVkKTt0aGlzLl9yZXNlZWQ9MTt0aGlzLnJlc2VlZEludGVydmFsPTI4MTQ3NDk3NjcxMDY1Nn07SG1hY0RSQkcucHJvdG90eXBlLl9obWFjPWZ1bmN0aW9uIGhtYWMoKXtyZXR1cm4gbmV3IGhhc2hfMS5obWFjKHRoaXMuaGFzaCx0aGlzLkspfTtIbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbiB1cGRhdGUoc2VlZCl7dmFyIGttYWM9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMF0pO2lmKHNlZWQpa21hYz1rbWFjLnVwZGF0ZShzZWVkKTt0aGlzLks9a21hYy5kaWdlc3QoKTt0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO2lmKCFzZWVkKXJldHVybjt0aGlzLks9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMV0pLnVwZGF0ZShzZWVkKS5kaWdlc3QoKTt0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpfTtIbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkPWZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LGVudHJvcHlFbmMsYWRkLGFkZEVuYyl7aWYodHlwZW9mIGVudHJvcHlFbmMhPT1cInN0cmluZ1wiKXthZGRFbmM9YWRkO2FkZD1lbnRyb3B5RW5jO2VudHJvcHlFbmM9bnVsbH1lbnRyb3B5PXV0aWxzXzEudG9BcnJheShlbnRyb3B5LGVudHJvcHlFbmMpO2FkZD11dGlsc18xLnRvQXJyYXkoYWRkLGFkZEVuYyk7bWluaW1hbGlzdGljQXNzZXJ0JDEoZW50cm9weS5sZW5ndGg+PXRoaXMubWluRW50cm9weS84LFwiTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiBcIit0aGlzLm1pbkVudHJvcHkrXCIgYml0c1wiKTt0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkfHxbXSkpO3RoaXMuX3Jlc2VlZD0xfTtIbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGU9ZnVuY3Rpb24gZ2VuZXJhdGUobGVuLGVuYyxhZGQsYWRkRW5jKXtpZih0aGlzLl9yZXNlZWQ+dGhpcy5yZXNlZWRJbnRlcnZhbCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNlZWQgaXMgcmVxdWlyZWRcIik7aWYodHlwZW9mIGVuYyE9PVwic3RyaW5nXCIpe2FkZEVuYz1hZGQ7YWRkPWVuYztlbmM9bnVsbH1pZihhZGQpe2FkZD11dGlsc18xLnRvQXJyYXkoYWRkLGFkZEVuY3x8XCJoZXhcIik7dGhpcy5fdXBkYXRlKGFkZCl9dmFyIHRlbXA9W107d2hpbGUodGVtcC5sZW5ndGg8bGVuKXt0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO3RlbXA9dGVtcC5jb25jYXQodGhpcy5WKX12YXIgcmVzPXRlbXAuc2xpY2UoMCxsZW4pO3RoaXMuX3VwZGF0ZShhZGQpO3RoaXMuX3Jlc2VlZCsrO3JldHVybiB1dGlsc18xLmVuY29kZShyZXMsZW5jKX07XCJ1c2Ugc3RyaWN0XCI7dmFyIGFzc2VydCQzPXV0aWxzXzEkMS5hc3NlcnQ7ZnVuY3Rpb24gS2V5UGFpcihlYyxvcHRpb25zKXt0aGlzLmVjPWVjO3RoaXMucHJpdj1udWxsO3RoaXMucHViPW51bGw7aWYob3B0aW9ucy5wcml2KXRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LG9wdGlvbnMucHJpdkVuYyk7aWYob3B0aW9ucy5wdWIpdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLG9wdGlvbnMucHViRW5jKX12YXIga2V5PUtleVBhaXI7S2V5UGFpci5mcm9tUHVibGljPWZ1bmN0aW9uIGZyb21QdWJsaWMoZWMscHViLGVuYyl7aWYocHViIGluc3RhbmNlb2YgS2V5UGFpcilyZXR1cm4gcHViO3JldHVybiBuZXcgS2V5UGFpcihlYyx7cHViOnB1YixwdWJFbmM6ZW5jfSl9O0tleVBhaXIuZnJvbVByaXZhdGU9ZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMscHJpdixlbmMpe2lmKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKXJldHVybiBwcml2O3JldHVybiBuZXcgS2V5UGFpcihlYyx7cHJpdjpwcml2LHByaXZFbmM6ZW5jfSl9O0tleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uIHZhbGlkYXRlKCl7dmFyIHB1Yj10aGlzLmdldFB1YmxpYygpO2lmKHB1Yi5pc0luZmluaXR5KCkpcmV0dXJue3Jlc3VsdDpmYWxzZSxyZWFzb246XCJJbnZhbGlkIHB1YmxpYyBrZXlcIn07aWYoIXB1Yi52YWxpZGF0ZSgpKXJldHVybntyZXN1bHQ6ZmFsc2UscmVhc29uOlwiUHVibGljIGtleSBpcyBub3QgYSBwb2ludFwifTtpZighcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlyZXR1cm57cmVzdWx0OmZhbHNlLHJlYXNvbjpcIlB1YmxpYyBrZXkgKiBOICE9IE9cIn07cmV0dXJue3Jlc3VsdDp0cnVlLHJlYXNvbjpudWxsfX07S2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljPWZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LGVuYyl7aWYodHlwZW9mIGNvbXBhY3Q9PT1cInN0cmluZ1wiKXtlbmM9Y29tcGFjdDtjb21wYWN0PW51bGx9aWYoIXRoaXMucHViKXRoaXMucHViPXRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtpZighZW5jKXJldHVybiB0aGlzLnB1YjtyZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYyxjb21wYWN0KX07S2V5UGFpci5wcm90b3R5cGUuZ2V0UHJpdmF0ZT1mdW5jdGlvbiBnZXRQcml2YXRlKGVuYyl7aWYoZW5jPT09XCJoZXhcIilyZXR1cm4gdGhpcy5wcml2LnRvU3RyaW5nKDE2LDIpO2Vsc2UgcmV0dXJuIHRoaXMucHJpdn07S2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGU9ZnVuY3Rpb24gX2ltcG9ydFByaXZhdGUoa2V5LGVuYyl7dGhpcy5wcml2PW5ldyBibihrZXksZW5jfHwxNik7dGhpcy5wcml2PXRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubil9O0tleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWM9ZnVuY3Rpb24gX2ltcG9ydFB1YmxpYyhrZXksZW5jKXtpZihrZXkueHx8a2V5Lnkpe2lmKHRoaXMuZWMuY3VydmUudHlwZT09PVwibW9udFwiKXthc3NlcnQkMyhrZXkueCxcIk5lZWQgeCBjb29yZGluYXRlXCIpfWVsc2UgaWYodGhpcy5lYy5jdXJ2ZS50eXBlPT09XCJzaG9ydFwifHx0aGlzLmVjLmN1cnZlLnR5cGU9PT1cImVkd2FyZHNcIil7YXNzZXJ0JDMoa2V5LngmJmtleS55LFwiTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZVwiKX10aGlzLnB1Yj10aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LGtleS55KTtyZXR1cm59dGhpcy5wdWI9dGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChrZXksZW5jKX07S2V5UGFpci5wcm90b3R5cGUuZGVyaXZlPWZ1bmN0aW9uIGRlcml2ZShwdWIpe2lmKCFwdWIudmFsaWRhdGUoKSl7YXNzZXJ0JDMocHViLnZhbGlkYXRlKCksXCJwdWJsaWMgcG9pbnQgbm90IHZhbGlkYXRlZFwiKX1yZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKX07S2V5UGFpci5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbiBzaWduKG1zZyxlbmMsb3B0aW9ucyl7cmV0dXJuIHRoaXMuZWMuc2lnbihtc2csdGhpcyxlbmMsb3B0aW9ucyl9O0tleVBhaXIucHJvdG90eXBlLnZlcmlmeT1mdW5jdGlvbiB2ZXJpZnkobXNnLHNpZ25hdHVyZSl7cmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZyxzaWduYXR1cmUsdGhpcyl9O0tleVBhaXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3JldHVyblwiPEtleSBwcml2OiBcIisodGhpcy5wcml2JiZ0aGlzLnByaXYudG9TdHJpbmcoMTYsMikpK1wiIHB1YjogXCIrKHRoaXMucHViJiZ0aGlzLnB1Yi5pbnNwZWN0KCkpK1wiID5cIn07XCJ1c2Ugc3RyaWN0XCI7dmFyIGFzc2VydCQ0PXV0aWxzXzEkMS5hc3NlcnQ7ZnVuY3Rpb24gU2lnbmF0dXJlKG9wdGlvbnMsZW5jKXtpZihvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKXJldHVybiBvcHRpb25zO2lmKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLGVuYykpcmV0dXJuO2Fzc2VydCQ0KG9wdGlvbnMuciYmb3B0aW9ucy5zLFwiU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzXCIpO3RoaXMucj1uZXcgYm4ob3B0aW9ucy5yLDE2KTt0aGlzLnM9bmV3IGJuKG9wdGlvbnMucywxNik7aWYob3B0aW9ucy5yZWNvdmVyeVBhcmFtPT09dW5kZWZpbmVkKXRoaXMucmVjb3ZlcnlQYXJhbT1udWxsO2Vsc2UgdGhpcy5yZWNvdmVyeVBhcmFtPW9wdGlvbnMucmVjb3ZlcnlQYXJhbX12YXIgc2lnbmF0dXJlPVNpZ25hdHVyZTtmdW5jdGlvbiBQb3NpdGlvbigpe3RoaXMucGxhY2U9MH1mdW5jdGlvbiBnZXRMZW5ndGgoYnVmLHApe3ZhciBpbml0aWFsPWJ1ZltwLnBsYWNlKytdO2lmKCEoaW5pdGlhbCYxMjgpKXtyZXR1cm4gaW5pdGlhbH12YXIgb2N0ZXRMZW49aW5pdGlhbCYxNTtpZihvY3RldExlbj09PTB8fG9jdGV0TGVuPjQpe3JldHVybiBmYWxzZX12YXIgdmFsPTA7Zm9yKHZhciBpPTAsb2ZmPXAucGxhY2U7aTxvY3RldExlbjtpKyssb2ZmKyspe3ZhbDw8PTg7dmFsfD1idWZbb2ZmXTt2YWw+Pj49MH1pZih2YWw8PTEyNyl7cmV0dXJuIGZhbHNlfXAucGxhY2U9b2ZmO3JldHVybiB2YWx9ZnVuY3Rpb24gcm1QYWRkaW5nKGJ1Zil7dmFyIGk9MDt2YXIgbGVuPWJ1Zi5sZW5ndGgtMTt3aGlsZSghYnVmW2ldJiYhKGJ1ZltpKzFdJjEyOCkmJmk8bGVuKXtpKyt9aWYoaT09PTApe3JldHVybiBidWZ9cmV0dXJuIGJ1Zi5zbGljZShpKX1TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVI9ZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLGVuYyl7ZGF0YT11dGlsc18xJDEudG9BcnJheShkYXRhLGVuYyk7dmFyIHA9bmV3IFBvc2l0aW9uO2lmKGRhdGFbcC5wbGFjZSsrXSE9PTQ4KXtyZXR1cm4gZmFsc2V9dmFyIGxlbj1nZXRMZW5ndGgoZGF0YSxwKTtpZihsZW49PT1mYWxzZSl7cmV0dXJuIGZhbHNlfWlmKGxlbitwLnBsYWNlIT09ZGF0YS5sZW5ndGgpe3JldHVybiBmYWxzZX1pZihkYXRhW3AucGxhY2UrK10hPT0yKXtyZXR1cm4gZmFsc2V9dmFyIHJsZW49Z2V0TGVuZ3RoKGRhdGEscCk7aWYocmxlbj09PWZhbHNlKXtyZXR1cm4gZmFsc2V9dmFyIHI9ZGF0YS5zbGljZShwLnBsYWNlLHJsZW4rcC5wbGFjZSk7cC5wbGFjZSs9cmxlbjtpZihkYXRhW3AucGxhY2UrK10hPT0yKXtyZXR1cm4gZmFsc2V9dmFyIHNsZW49Z2V0TGVuZ3RoKGRhdGEscCk7aWYoc2xlbj09PWZhbHNlKXtyZXR1cm4gZmFsc2V9aWYoZGF0YS5sZW5ndGghPT1zbGVuK3AucGxhY2Upe3JldHVybiBmYWxzZX12YXIgcz1kYXRhLnNsaWNlKHAucGxhY2Usc2xlbitwLnBsYWNlKTtpZihyWzBdPT09MCl7aWYoclsxXSYxMjgpe3I9ci5zbGljZSgxKX1lbHNle3JldHVybiBmYWxzZX19aWYoc1swXT09PTApe2lmKHNbMV0mMTI4KXtzPXMuc2xpY2UoMSl9ZWxzZXtyZXR1cm4gZmFsc2V9fXRoaXMucj1uZXcgYm4ocik7dGhpcy5zPW5ldyBibihzKTt0aGlzLnJlY292ZXJ5UGFyYW09bnVsbDtyZXR1cm4gdHJ1ZX07ZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFycixsZW4pe2lmKGxlbjwxMjgpe2Fyci5wdXNoKGxlbik7cmV0dXJufXZhciBvY3RldHM9MSsoTWF0aC5sb2cobGVuKS9NYXRoLkxOMj4+PjMpO2Fyci5wdXNoKG9jdGV0c3wxMjgpO3doaWxlKC0tb2N0ZXRzKXthcnIucHVzaChsZW4+Pj4ob2N0ZXRzPDwzKSYyNTUpfWFyci5wdXNoKGxlbil9U2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUj1mdW5jdGlvbiB0b0RFUihlbmMpe3ZhciByPXRoaXMuci50b0FycmF5KCk7dmFyIHM9dGhpcy5zLnRvQXJyYXkoKTtpZihyWzBdJjEyOClyPVswXS5jb25jYXQocik7aWYoc1swXSYxMjgpcz1bMF0uY29uY2F0KHMpO3I9cm1QYWRkaW5nKHIpO3M9cm1QYWRkaW5nKHMpO3doaWxlKCFzWzBdJiYhKHNbMV0mMTI4KSl7cz1zLnNsaWNlKDEpfXZhciBhcnI9WzJdO2NvbnN0cnVjdExlbmd0aChhcnIsci5sZW5ndGgpO2Fycj1hcnIuY29uY2F0KHIpO2Fyci5wdXNoKDIpO2NvbnN0cnVjdExlbmd0aChhcnIscy5sZW5ndGgpO3ZhciBiYWNrSGFsZj1hcnIuY29uY2F0KHMpO3ZhciByZXM9WzQ4XTtjb25zdHJ1Y3RMZW5ndGgocmVzLGJhY2tIYWxmLmxlbmd0aCk7cmVzPXJlcy5jb25jYXQoYmFja0hhbGYpO3JldHVybiB1dGlsc18xJDEuZW5jb2RlKHJlcyxlbmMpfTtcInVzZSBzdHJpY3RcIjt2YXIgcmFuZD1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkXCIpfTt2YXIgYXNzZXJ0JDU9dXRpbHNfMSQxLmFzc2VydDtmdW5jdGlvbiBFQyhvcHRpb25zKXtpZighKHRoaXMgaW5zdGFuY2VvZiBFQykpcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtpZih0eXBlb2Ygb3B0aW9ucz09PVwic3RyaW5nXCIpe2Fzc2VydCQ1KE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJ2ZXNfMSxvcHRpb25zKSxcIlVua25vd24gY3VydmUgXCIrb3B0aW9ucyk7b3B0aW9ucz1jdXJ2ZXNfMVtvcHRpb25zXX1pZihvcHRpb25zIGluc3RhbmNlb2YgY3VydmVzXzEuUHJlc2V0Q3VydmUpb3B0aW9ucz17Y3VydmU6b3B0aW9uc307dGhpcy5jdXJ2ZT1vcHRpb25zLmN1cnZlLmN1cnZlO3RoaXMubj10aGlzLmN1cnZlLm47dGhpcy5uaD10aGlzLm4udXNocm4oMSk7dGhpcy5nPXRoaXMuY3VydmUuZzt0aGlzLmc9b3B0aW9ucy5jdXJ2ZS5nO3RoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSsxKTt0aGlzLmhhc2g9b3B0aW9ucy5oYXNofHxvcHRpb25zLmN1cnZlLmhhc2h9dmFyIGVjPUVDO0VDLnByb3RvdHlwZS5rZXlQYWlyPWZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucyl7cmV0dXJuIG5ldyBrZXkodGhpcyxvcHRpb25zKX07RUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlPWZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsZW5jKXtyZXR1cm4ga2V5LmZyb21Qcml2YXRlKHRoaXMscHJpdixlbmMpfTtFQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYz1mdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1YixlbmMpe3JldHVybiBrZXkuZnJvbVB1YmxpYyh0aGlzLHB1YixlbmMpfTtFQy5wcm90b3R5cGUuZ2VuS2V5UGFpcj1mdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpe2lmKCFvcHRpb25zKW9wdGlvbnM9e307dmFyIGRyYmc9bmV3IGhtYWNEcmJnKHtoYXNoOnRoaXMuaGFzaCxwZXJzOm9wdGlvbnMucGVycyxwZXJzRW5jOm9wdGlvbnMucGVyc0VuY3x8XCJ1dGY4XCIsZW50cm9weTpvcHRpb25zLmVudHJvcHl8fHJhbmQodGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksZW50cm9weUVuYzpvcHRpb25zLmVudHJvcHkmJm9wdGlvbnMuZW50cm9weUVuY3x8XCJ1dGY4XCIsbm9uY2U6dGhpcy5uLnRvQXJyYXkoKX0pO3ZhciBieXRlcz10aGlzLm4uYnl0ZUxlbmd0aCgpO3ZhciBuczI9dGhpcy5uLnN1YihuZXcgYm4oMikpO2Zvcig7Oyl7dmFyIHByaXY9bmV3IGJuKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtpZihwcml2LmNtcChuczIpPjApY29udGludWU7cHJpdi5pYWRkbigxKTtyZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KX19O0VDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb049ZnVuY3Rpb24gX3RydW5jYXRlVG9OKG1zZyx0cnVuY09ubHkpe3ZhciBkZWx0YT1tc2cuYnl0ZUxlbmd0aCgpKjgtdGhpcy5uLmJpdExlbmd0aCgpO2lmKGRlbHRhPjApbXNnPW1zZy51c2hybihkZWx0YSk7aWYoIXRydW5jT25seSYmbXNnLmNtcCh0aGlzLm4pPj0wKXJldHVybiBtc2cuc3ViKHRoaXMubik7ZWxzZSByZXR1cm4gbXNnfTtFQy5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbiBzaWduKG1zZyxrZXksZW5jLG9wdGlvbnMpe2lmKHR5cGVvZiBlbmM9PT1cIm9iamVjdFwiKXtvcHRpb25zPWVuYztlbmM9bnVsbH1pZighb3B0aW9ucylvcHRpb25zPXt9O2tleT10aGlzLmtleUZyb21Qcml2YXRlKGtleSxlbmMpO21zZz10aGlzLl90cnVuY2F0ZVRvTihuZXcgYm4obXNnLDE2KSk7dmFyIGJ5dGVzPXRoaXMubi5ieXRlTGVuZ3RoKCk7dmFyIGJrZXk9a2V5LmdldFByaXZhdGUoKS50b0FycmF5KFwiYmVcIixieXRlcyk7dmFyIG5vbmNlPW1zZy50b0FycmF5KFwiYmVcIixieXRlcyk7dmFyIGRyYmc9bmV3IGhtYWNEcmJnKHtoYXNoOnRoaXMuaGFzaCxlbnRyb3B5OmJrZXksbm9uY2U6bm9uY2UscGVyczpvcHRpb25zLnBlcnMscGVyc0VuYzpvcHRpb25zLnBlcnNFbmN8fFwidXRmOFwifSk7dmFyIG5zMT10aGlzLm4uc3ViKG5ldyBibigxKSk7Zm9yKHZhciBpdGVyPTA7O2l0ZXIrKyl7dmFyIGs9b3B0aW9ucy5rP29wdGlvbnMuayhpdGVyKTpuZXcgYm4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7az10aGlzLl90cnVuY2F0ZVRvTihrLHRydWUpO2lmKGsuY21wbigxKTw9MHx8ay5jbXAobnMxKT49MCljb250aW51ZTt2YXIga3A9dGhpcy5nLm11bChrKTtpZihrcC5pc0luZmluaXR5KCkpY29udGludWU7dmFyIGtwWD1rcC5nZXRYKCk7dmFyIHI9a3BYLnVtb2QodGhpcy5uKTtpZihyLmNtcG4oMCk9PT0wKWNvbnRpbnVlO3ZhciBzPWsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO3M9cy51bW9kKHRoaXMubik7aWYocy5jbXBuKDApPT09MCljb250aW51ZTt2YXIgcmVjb3ZlcnlQYXJhbT0oa3AuZ2V0WSgpLmlzT2RkKCk/MTowKXwoa3BYLmNtcChyKSE9PTA/MjowKTtpZihvcHRpb25zLmNhbm9uaWNhbCYmcy5jbXAodGhpcy5uaCk+MCl7cz10aGlzLm4uc3ViKHMpO3JlY292ZXJ5UGFyYW1ePTF9cmV0dXJuIG5ldyBzaWduYXR1cmUoe3I6cixzOnMscmVjb3ZlcnlQYXJhbTpyZWNvdmVyeVBhcmFtfSl9fTtFQy5wcm90b3R5cGUudmVyaWZ5PWZ1bmN0aW9uIHZlcmlmeShtc2csc2lnbmF0dXJlJDEsa2V5LGVuYyl7bXNnPXRoaXMuX3RydW5jYXRlVG9OKG5ldyBibihtc2csMTYpKTtrZXk9dGhpcy5rZXlGcm9tUHVibGljKGtleSxlbmMpO3NpZ25hdHVyZSQxPW5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsXCJoZXhcIik7dmFyIHI9c2lnbmF0dXJlJDEucjt2YXIgcz1zaWduYXR1cmUkMS5zO2lmKHIuY21wbigxKTwwfHxyLmNtcCh0aGlzLm4pPj0wKXJldHVybiBmYWxzZTtpZihzLmNtcG4oMSk8MHx8cy5jbXAodGhpcy5uKT49MClyZXR1cm4gZmFsc2U7dmFyIHNpbnY9cy5pbnZtKHRoaXMubik7dmFyIHUxPXNpbnYubXVsKG1zZykudW1vZCh0aGlzLm4pO3ZhciB1Mj1zaW52Lm11bChyKS51bW9kKHRoaXMubik7dmFyIHA7aWYoIXRoaXMuY3VydmUuX21heHdlbGxUcmljayl7cD10aGlzLmcubXVsQWRkKHUxLGtleS5nZXRQdWJsaWMoKSx1Mik7aWYocC5pc0luZmluaXR5KCkpcmV0dXJuIGZhbHNlO3JldHVybiBwLmdldFgoKS51bW9kKHRoaXMubikuY21wKHIpPT09MH1wPXRoaXMuZy5qbXVsQWRkKHUxLGtleS5nZXRQdWJsaWMoKSx1Mik7aWYocC5pc0luZmluaXR5KCkpcmV0dXJuIGZhbHNlO3JldHVybiBwLmVxWFRvUChyKX07RUMucHJvdG90eXBlLnJlY292ZXJQdWJLZXk9ZnVuY3Rpb24obXNnLHNpZ25hdHVyZSQxLGosZW5jKXthc3NlcnQkNSgoMyZqKT09PWosXCJUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzXCIpO3NpZ25hdHVyZSQxPW5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsZW5jKTt2YXIgbj10aGlzLm47dmFyIGU9bmV3IGJuKG1zZyk7dmFyIHI9c2lnbmF0dXJlJDEucjt2YXIgcz1zaWduYXR1cmUkMS5zO3ZhciBpc1lPZGQ9aiYxO3ZhciBpc1NlY29uZEtleT1qPj4xO2lmKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpPj0wJiZpc1NlY29uZEtleSl0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGVcIik7aWYoaXNTZWNvbmRLZXkpcj10aGlzLmN1cnZlLnBvaW50RnJvbVgoci5hZGQodGhpcy5jdXJ2ZS5uKSxpc1lPZGQpO2Vsc2Ugcj10aGlzLmN1cnZlLnBvaW50RnJvbVgocixpc1lPZGQpO3ZhciBySW52PXNpZ25hdHVyZSQxLnIuaW52bShuKTt2YXIgczE9bi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7dmFyIHMyPXMubXVsKHJJbnYpLnVtb2Qobik7cmV0dXJuIHRoaXMuZy5tdWxBZGQoczEscixzMil9O0VDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtPWZ1bmN0aW9uKGUsc2lnbmF0dXJlJDEsUSxlbmMpe3NpZ25hdHVyZSQxPW5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsZW5jKTtpZihzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtIT09bnVsbClyZXR1cm4gc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbTtmb3IodmFyIGk9MDtpPDQ7aSsrKXt2YXIgUXByaW1lO3RyeXtRcHJpbWU9dGhpcy5yZWNvdmVyUHViS2V5KGUsc2lnbmF0dXJlJDEsaSl9Y2F0Y2goZSl7Y29udGludWV9aWYoUXByaW1lLmVxKFEpKXJldHVybiBpfXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvclwiKX07dmFyIGVsbGlwdGljXzE9Y3JlYXRlQ29tbW9uanNNb2R1bGUkMShmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGVsbGlwdGljPWV4cG9ydHM7ZWxsaXB0aWMudmVyc2lvbj17dmVyc2lvbjpcIjYuNS40XCJ9LnZlcnNpb247ZWxsaXB0aWMudXRpbHM9dXRpbHNfMSQxO2VsbGlwdGljLnJhbmQ9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZFwiKX07ZWxsaXB0aWMuY3VydmU9Y3VydmVfMTtlbGxpcHRpYy5jdXJ2ZXM9Y3VydmVzXzE7ZWxsaXB0aWMuZWM9ZWM7ZWxsaXB0aWMuZWRkc2E9bnVsbH0pO3ZhciBFQyQxPWVsbGlwdGljXzEuZWM7Y29uc3QgdmVyc2lvbiRiPVwic2lnbmluZy1rZXkvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkZz1uZXcgTG9nZ2VyKHZlcnNpb24kYik7bGV0IF9jdXJ2ZT1udWxsO2Z1bmN0aW9uIGdldEN1cnZlKCl7aWYoIV9jdXJ2ZSl7X2N1cnZlPW5ldyBFQyQxKFwic2VjcDI1NmsxXCIpfXJldHVybiBfY3VydmV9Y2xhc3MgU2lnbmluZ0tleXtjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KXtkZWZpbmVSZWFkT25seSh0aGlzLFwiY3VydmVcIixcInNlY3AyNTZrMVwiKTtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJpdmF0ZUtleVwiLGhleGxpZnkocHJpdmF0ZUtleSkpO2NvbnN0IGtleVBhaXI9Z2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwicHVibGljS2V5XCIsXCIweFwiK2tleVBhaXIuZ2V0UHVibGljKGZhbHNlLFwiaGV4XCIpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiY29tcHJlc3NlZFB1YmxpY0tleVwiLFwiMHhcIitrZXlQYWlyLmdldFB1YmxpYyh0cnVlLFwiaGV4XCIpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2lzU2lnbmluZ0tleVwiLHRydWUpfV9hZGRQb2ludChvdGhlcil7Y29uc3QgcDA9Z2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KHRoaXMucHVibGljS2V5KSk7Y29uc3QgcDE9Z2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KG90aGVyKSk7cmV0dXJuXCIweFwiK3AwLnB1Yi5hZGQocDEucHViKS5lbmNvZGVDb21wcmVzc2VkKFwiaGV4XCIpfXNpZ25EaWdlc3QoZGlnZXN0KXtjb25zdCBrZXlQYWlyPWdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7Y29uc3QgZGlnZXN0Qnl0ZXM9YXJyYXlpZnkoZGlnZXN0KTtpZihkaWdlc3RCeXRlcy5sZW5ndGghPT0zMil7bG9nZ2VyJGcudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGRpZ2VzdCBsZW5ndGhcIixcImRpZ2VzdFwiLGRpZ2VzdCl9Y29uc3Qgc2lnbmF0dXJlPWtleVBhaXIuc2lnbihkaWdlc3RCeXRlcyx7Y2Fub25pY2FsOnRydWV9KTtyZXR1cm4gc3BsaXRTaWduYXR1cmUoe3JlY292ZXJ5UGFyYW06c2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0scjpoZXhaZXJvUGFkKFwiMHhcIitzaWduYXR1cmUuci50b1N0cmluZygxNiksMzIpLHM6aGV4WmVyb1BhZChcIjB4XCIrc2lnbmF0dXJlLnMudG9TdHJpbmcoMTYpLDMyKX0pfWNvbXB1dGVTaGFyZWRTZWNyZXQob3RoZXJLZXkpe2NvbnN0IGtleVBhaXI9Z2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtjb25zdCBvdGhlcktleVBhaXI9Z2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KGNvbXB1dGVQdWJsaWNLZXkob3RoZXJLZXkpKSk7cmV0dXJuIGhleFplcm9QYWQoXCIweFwiK2tleVBhaXIuZGVyaXZlKG90aGVyS2V5UGFpci5nZXRQdWJsaWMoKSkudG9TdHJpbmcoMTYpLDMyKX1zdGF0aWMgaXNTaWduaW5nS2V5KHZhbHVlKXtyZXR1cm4hISh2YWx1ZSYmdmFsdWUuX2lzU2lnbmluZ0tleSl9fWZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LHNpZ25hdHVyZSl7Y29uc3Qgc2lnPXNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7Y29uc3QgcnM9e3I6YXJyYXlpZnkoc2lnLnIpLHM6YXJyYXlpZnkoc2lnLnMpfTtyZXR1cm5cIjB4XCIrZ2V0Q3VydmUoKS5yZWNvdmVyUHViS2V5KGFycmF5aWZ5KGRpZ2VzdCkscnMsc2lnLnJlY292ZXJ5UGFyYW0pLmVuY29kZShcImhleFwiLGZhbHNlKX1mdW5jdGlvbiBjb21wdXRlUHVibGljS2V5KGtleSxjb21wcmVzc2VkKXtjb25zdCBieXRlcz1hcnJheWlmeShrZXkpO2lmKGJ5dGVzLmxlbmd0aD09PTMyKXtjb25zdCBzaWduaW5nS2V5PW5ldyBTaWduaW5nS2V5KGJ5dGVzKTtpZihjb21wcmVzc2VkKXtyZXR1cm5cIjB4XCIrZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShieXRlcykuZ2V0UHVibGljKHRydWUsXCJoZXhcIil9cmV0dXJuIHNpZ25pbmdLZXkucHVibGljS2V5fWVsc2UgaWYoYnl0ZXMubGVuZ3RoPT09MzMpe2lmKGNvbXByZXNzZWQpe3JldHVybiBoZXhsaWZ5KGJ5dGVzKX1yZXR1cm5cIjB4XCIrZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWMoZmFsc2UsXCJoZXhcIil9ZWxzZSBpZihieXRlcy5sZW5ndGg9PT02NSl7aWYoIWNvbXByZXNzZWQpe3JldHVybiBoZXhsaWZ5KGJ5dGVzKX1yZXR1cm5cIjB4XCIrZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSxcImhleFwiKX1yZXR1cm4gbG9nZ2VyJGcudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwdWJsaWMgb3IgcHJpdmF0ZSBrZXlcIixcImtleVwiLFwiW1JFREFDVEVEXVwiKX1jb25zdCB2ZXJzaW9uJGM9XCJ0cmFuc2FjdGlvbnMvNS4xLjFcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkaD1uZXcgTG9nZ2VyKHZlcnNpb24kYyk7ZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSl7aWYodmFsdWU9PT1cIjB4XCIpe3JldHVybiBudWxsfXJldHVybiBnZXRBZGRyZXNzKHZhbHVlKX1mdW5jdGlvbiBoYW5kbGVOdW1iZXIodmFsdWUpe2lmKHZhbHVlPT09XCIweFwiKXtyZXR1cm4gWmVybyQxfXJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSl9Y29uc3QgdHJhbnNhY3Rpb25GaWVsZHM9W3tuYW1lOlwibm9uY2VcIixtYXhMZW5ndGg6MzIsbnVtZXJpYzp0cnVlfSx7bmFtZTpcImdhc1ByaWNlXCIsbWF4TGVuZ3RoOjMyLG51bWVyaWM6dHJ1ZX0se25hbWU6XCJnYXNMaW1pdFwiLG1heExlbmd0aDozMixudW1lcmljOnRydWV9LHtuYW1lOlwidG9cIixsZW5ndGg6MjB9LHtuYW1lOlwidmFsdWVcIixtYXhMZW5ndGg6MzIsbnVtZXJpYzp0cnVlfSx7bmFtZTpcImRhdGFcIn1dO2NvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMkMT17Y2hhaW5JZDp0cnVlLGRhdGE6dHJ1ZSxnYXNMaW1pdDp0cnVlLGdhc1ByaWNlOnRydWUsbm9uY2U6dHJ1ZSx0bzp0cnVlLHZhbHVlOnRydWV9O2Z1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSl7Y29uc3QgcHVibGljS2V5PWNvbXB1dGVQdWJsaWNLZXkoa2V5KTtyZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGhleERhdGFTbGljZShwdWJsaWNLZXksMSkpLDEyKSl9ZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LHNpZ25hdHVyZSl7cmV0dXJuIGNvbXB1dGVBZGRyZXNzKHJlY292ZXJQdWJsaWNLZXkoYXJyYXlpZnkoZGlnZXN0KSxzaWduYXR1cmUpKX1mdW5jdGlvbiBmb3JtYXROdW1iZXIodmFsdWUsbmFtZSl7Y29uc3QgcmVzdWx0PXN0cmlwWmVyb3MoQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCkpO2lmKHJlc3VsdC5sZW5ndGg+MzIpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIituYW1lLFwidHJhbnNhY3Rpb246XCIrbmFtZSx2YWx1ZSl9cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBhY2Nlc3NTZXRpZnkoYWRkcixzdG9yYWdlS2V5cyl7cmV0dXJue2FkZHJlc3M6Z2V0QWRkcmVzcyhhZGRyKSxzdG9yYWdlS2V5czooc3RvcmFnZUtleXN8fFtdKS5tYXAoKHN0b3JhZ2VLZXksaW5kZXgpPT57aWYoaGV4RGF0YUxlbmd0aChzdG9yYWdlS2V5KSE9PTMyKXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFjY2VzcyBsaXN0IHN0b3JhZ2VLZXlcIixgYWNjZXNzTGlzdFske2FkZHJ9OiR7aW5kZXh9XWAsc3RvcmFnZUtleSl9cmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKX0pfX1mdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKXtpZihBcnJheS5pc0FycmF5KHZhbHVlKSl7cmV0dXJuIHZhbHVlLm1hcCgoc2V0LGluZGV4KT0+e2lmKEFycmF5LmlzQXJyYXkoc2V0KSl7aWYoc2V0Lmxlbmd0aD4yKXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJhY2Nlc3MgbGlzdCBleHBlY3RlZCB0byBiZSBbIGFkZHJlc3MsIHN0b3JhZ2VLZXlzW10gXVwiLGB2YWx1ZVske2luZGV4fV1gLHNldCl9cmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sc2V0WzFdKX1yZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLHNldC5zdG9yYWdlS2V5cyl9KX1jb25zdCByZXN1bHQ9T2JqZWN0LmtleXModmFsdWUpLm1hcChhZGRyPT57Y29uc3Qgc3RvcmFnZUtleXM9dmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSxzdG9yYWdlS2V5KT0+e2FjY3VtW3N0b3JhZ2VLZXldPXRydWU7cmV0dXJuIGFjY3VtfSx7fSk7cmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpfSk7cmVzdWx0LnNvcnQoKGEsYik9PmEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpO3JldHVybiByZXN1bHR9ZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSl7cmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpLm1hcChzZXQ9PltzZXQuYWRkcmVzcyxzZXQuc3RvcmFnZUtleXNdKX1mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbixzaWduYXR1cmUpe2NvbnN0IGZpZWxkcz1bZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWR8fDAsXCJjaGFpbklkXCIpLGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZXx8MCxcIm5vbmNlXCIpLGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNQcmljZXx8MCxcImdhc1ByaWNlXCIpLGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNMaW1pdHx8MCxcImdhc0xpbWl0XCIpLHRyYW5zYWN0aW9uLnRvIT1udWxsP2dldEFkZHJlc3ModHJhbnNhY3Rpb24udG8pOlwiMHhcIixmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24udmFsdWV8fDAsXCJ2YWx1ZVwiKSx0cmFuc2FjdGlvbi5kYXRhfHxcIjB4XCIsZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0fHxbXSldO2lmKHNpZ25hdHVyZSl7Y29uc3Qgc2lnPXNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7ZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLFwicmVjb3ZlcnlQYXJhbVwiKSk7ZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucikpO2ZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnMpKX1yZXR1cm4gaGV4Q29uY2F0KFtcIjB4MDFcIixlbmNvZGUoZmllbGRzKV0pfWZ1bmN0aW9uIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sc2lnbmF0dXJlKXtjaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyQxKTtjb25zdCByYXc9W107dHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbihmaWVsZEluZm8pe2xldCB2YWx1ZT10cmFuc2FjdGlvbltmaWVsZEluZm8ubmFtZV18fFtdO2NvbnN0IG9wdGlvbnM9e307aWYoZmllbGRJbmZvLm51bWVyaWMpe29wdGlvbnMuaGV4UGFkPVwibGVmdFwifXZhbHVlPWFycmF5aWZ5KGhleGxpZnkodmFsdWUsb3B0aW9ucykpO2lmKGZpZWxkSW5mby5sZW5ndGgmJnZhbHVlLmxlbmd0aCE9PWZpZWxkSW5mby5sZW5ndGgmJnZhbHVlLmxlbmd0aD4wKXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIrZmllbGRJbmZvLm5hbWUsXCJ0cmFuc2FjdGlvbjpcIitmaWVsZEluZm8ubmFtZSx2YWx1ZSl9aWYoZmllbGRJbmZvLm1heExlbmd0aCl7dmFsdWU9c3RyaXBaZXJvcyh2YWx1ZSk7aWYodmFsdWUubGVuZ3RoPmZpZWxkSW5mby5tYXhMZW5ndGgpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIitmaWVsZEluZm8ubmFtZSxcInRyYW5zYWN0aW9uOlwiK2ZpZWxkSW5mby5uYW1lLHZhbHVlKX19cmF3LnB1c2goaGV4bGlmeSh2YWx1ZSkpfSk7bGV0IGNoYWluSWQ9MDtpZih0cmFuc2FjdGlvbi5jaGFpbklkIT1udWxsKXtjaGFpbklkPXRyYW5zYWN0aW9uLmNoYWluSWQ7aWYodHlwZW9mIGNoYWluSWQhPT1cIm51bWJlclwiKXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uLmNoYWluSWRcIixcInRyYW5zYWN0aW9uXCIsdHJhbnNhY3Rpb24pfX1lbHNlIGlmKHNpZ25hdHVyZSYmIWlzQnl0ZXNMaWtlKHNpZ25hdHVyZSkmJnNpZ25hdHVyZS52PjI4KXtjaGFpbklkPU1hdGguZmxvb3IoKHNpZ25hdHVyZS52LTM1KS8yKX1pZihjaGFpbklkIT09MCl7cmF3LnB1c2goaGV4bGlmeShjaGFpbklkKSk7cmF3LnB1c2goXCIweFwiKTtyYXcucHVzaChcIjB4XCIpfWlmKCFzaWduYXR1cmUpe3JldHVybiBlbmNvZGUocmF3KX1jb25zdCBzaWc9c3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtsZXQgdj0yNytzaWcucmVjb3ZlcnlQYXJhbTtpZihjaGFpbklkIT09MCl7cmF3LnBvcCgpO3Jhdy5wb3AoKTtyYXcucG9wKCk7dis9Y2hhaW5JZCoyKzg7aWYoc2lnLnY+MjgmJnNpZy52IT09dil7bG9nZ2VyJGgudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX19ZWxzZSBpZihzaWcudiE9PXYpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIixcInNpZ25hdHVyZVwiLHNpZ25hdHVyZSl9cmF3LnB1c2goaGV4bGlmeSh2KSk7cmF3LnB1c2goc3RyaXBaZXJvcyhhcnJheWlmeShzaWcucikpKTtyYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5zKSkpO3JldHVybiBlbmNvZGUocmF3KX1mdW5jdGlvbiBzZXJpYWxpemUodHJhbnNhY3Rpb24sc2lnbmF0dXJlKXtpZih0cmFuc2FjdGlvbi50eXBlPT1udWxsKXtpZih0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IT1udWxsKXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnR5cGVkIHRyYW5zYWN0aW9ucyBkbyBub3Qgc3VwcG9ydCBhY2Nlc3NMaXN0OyBpbmNsdWRlIHR5cGU6IDFcIixcInRyYW5zYWN0aW9uXCIsdHJhbnNhY3Rpb24pfXJldHVybiBfc2VyaWFsaXplKHRyYW5zYWN0aW9uLHNpZ25hdHVyZSl9c3dpdGNoKHRyYW5zYWN0aW9uLnR5cGUpe2Nhc2UgMTpyZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodHJhbnNhY3Rpb24sc2lnbmF0dXJlKTtkZWZhdWx0OmJyZWFrfXJldHVybiBsb2dnZXIkaC50aHJvd0Vycm9yKGB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3RyYW5zYWN0aW9uLnR5cGV9YCxMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2VyaWFsaXplVHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvblR5cGU6dHJhbnNhY3Rpb24udHlwZX0pfWZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAocGF5bG9hZCl7Y29uc3QgdHJhbnNhY3Rpb249ZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO2lmKHRyYW5zYWN0aW9uLmxlbmd0aCE9PTgmJnRyYW5zYWN0aW9uLmxlbmd0aCE9PTExKXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbXBvbmVudCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLFwicGF5bG9hZFwiLGhleGxpZnkocGF5bG9hZCkpfWNvbnN0IHR4PXt0eXBlOjEsY2hhaW5JZDpoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksbm9uY2U6aGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLGdhc1ByaWNlOmhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksZ2FzTGltaXQ6aGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzNdKSx0bzpoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzRdKSx2YWx1ZTpoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNV0pLGRhdGE6dHJhbnNhY3Rpb25bNl0sYWNjZXNzTGlzdDphY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzddKX07aWYodHJhbnNhY3Rpb24ubGVuZ3RoPT09OCl7cmV0dXJuIHR4fXRyeXtjb25zdCByZWNpZD1oYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bOF0pLnRvTnVtYmVyKCk7aWYocmVjaWQhPT0wJiZyZWNpZCE9PTEpe3Rocm93IG5ldyBFcnJvcihcImJhZCByZWNpZFwiKX10eC52PXJlY2lkfWNhdGNoKGVycm9yKXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHYgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIixcInZcIix0cmFuc2FjdGlvbls4XSl9dHgucj1oZXhaZXJvUGFkKHRyYW5zYWN0aW9uWzldLDMyKTt0eC5zPWhleFplcm9QYWQodHJhbnNhY3Rpb25bMTBdLDMyKTt0cnl7Y29uc3QgZGlnZXN0PWtlY2NhazI1Nihfc2VyaWFsaXplRWlwMjkzMCh0eCkpO3R4LmZyb209cmVjb3ZlckFkZHJlc3MoZGlnZXN0LHtyOnR4LnIsczp0eC5zLHJlY292ZXJ5UGFyYW06dHgudn0pfWNhdGNoKGVycm9yKXtjb25zb2xlLmxvZyhlcnJvcil9dHguaGFzaD1rZWNjYWsyNTYocGF5bG9hZCk7cmV0dXJuIHR4fWZ1bmN0aW9uIF9wYXJzZShyYXdUcmFuc2FjdGlvbil7Y29uc3QgdHJhbnNhY3Rpb249ZGVjb2RlKHJhd1RyYW5zYWN0aW9uKTtpZih0cmFuc2FjdGlvbi5sZW5ndGghPT05JiZ0cmFuc2FjdGlvbi5sZW5ndGghPT02KXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJhdyB0cmFuc2FjdGlvblwiLFwicmF3VHJhbnNhY3Rpb25cIixyYXdUcmFuc2FjdGlvbil9Y29uc3QgdHg9e25vbmNlOmhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxnYXNQcmljZTpoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMV0pLGdhc0xpbWl0OmhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksdG86aGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvblszXSksdmFsdWU6aGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzRdKSxkYXRhOnRyYW5zYWN0aW9uWzVdLGNoYWluSWQ6MH07aWYodHJhbnNhY3Rpb24ubGVuZ3RoPT09Nil7cmV0dXJuIHR4fXRyeXt0eC52PUJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uWzZdKS50b051bWJlcigpfWNhdGNoKGVycm9yKXtjb25zb2xlLmxvZyhlcnJvcik7cmV0dXJuIHR4fXR4LnI9aGV4WmVyb1BhZCh0cmFuc2FjdGlvbls3XSwzMik7dHgucz1oZXhaZXJvUGFkKHRyYW5zYWN0aW9uWzhdLDMyKTtpZihCaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSYmQmlnTnVtYmVyLmZyb20odHgucykuaXNaZXJvKCkpe3R4LmNoYWluSWQ9dHgudjt0eC52PTB9ZWxzZXt0eC5jaGFpbklkPU1hdGguZmxvb3IoKHR4LnYtMzUpLzIpO2lmKHR4LmNoYWluSWQ8MCl7dHguY2hhaW5JZD0wfWxldCByZWNvdmVyeVBhcmFtPXR4LnYtMjc7Y29uc3QgcmF3PXRyYW5zYWN0aW9uLnNsaWNlKDAsNik7aWYodHguY2hhaW5JZCE9PTApe3Jhdy5wdXNoKGhleGxpZnkodHguY2hhaW5JZCkpO3Jhdy5wdXNoKFwiMHhcIik7cmF3LnB1c2goXCIweFwiKTtyZWNvdmVyeVBhcmFtLT10eC5jaGFpbklkKjIrOH1jb25zdCBkaWdlc3Q9a2VjY2FrMjU2KGVuY29kZShyYXcpKTt0cnl7dHguZnJvbT1yZWNvdmVyQWRkcmVzcyhkaWdlc3Qse3I6aGV4bGlmeSh0eC5yKSxzOmhleGxpZnkodHgucykscmVjb3ZlcnlQYXJhbTpyZWNvdmVyeVBhcmFtfSl9Y2F0Y2goZXJyb3Ipe2NvbnNvbGUubG9nKGVycm9yKX10eC5oYXNoPWtlY2NhazI1NihyYXdUcmFuc2FjdGlvbil9dHgudHlwZT1udWxsO3JldHVybiB0eH1mdW5jdGlvbiBwYXJzZShyYXdUcmFuc2FjdGlvbil7Y29uc3QgcGF5bG9hZD1hcnJheWlmeShyYXdUcmFuc2FjdGlvbik7aWYocGF5bG9hZFswXT4xMjcpe3JldHVybiBfcGFyc2UocGF5bG9hZCl9c3dpdGNoKHBheWxvYWRbMF0pe2Nhc2UgMTpyZXR1cm4gX3BhcnNlRWlwMjkzMChwYXlsb2FkKTtkZWZhdWx0OmJyZWFrfXJldHVybiBsb2dnZXIkaC50aHJvd0Vycm9yKGB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3BheWxvYWRbMF19YCxMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwicGFyc2VUcmFuc2FjdGlvblwiLHRyYW5zYWN0aW9uVHlwZTpwYXlsb2FkWzBdfSl9Y29uc3QgdmVyc2lvbiRkPVwiY29udHJhY3RzLzUuMS4xXCI7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciQzPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkaT1uZXcgTG9nZ2VyKHZlcnNpb24kZCk7Y29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyQyPXtjaGFpbklkOnRydWUsZGF0YTp0cnVlLGZyb206dHJ1ZSxnYXNMaW1pdDp0cnVlLGdhc1ByaWNlOnRydWUsbm9uY2U6dHJ1ZSx0bzp0cnVlLHZhbHVlOnRydWUsdHlwZTp0cnVlLGFjY2Vzc0xpc3Q6dHJ1ZX07ZnVuY3Rpb24gcmVzb2x2ZU5hbWUocmVzb2x2ZXIsbmFtZU9yUHJvbWlzZSl7cmV0dXJuIF9fYXdhaXRlciQzKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBuYW1lPXlpZWxkIG5hbWVPclByb21pc2U7dHJ5e3JldHVybiBnZXRBZGRyZXNzKG5hbWUpfWNhdGNoKGVycm9yKXt9aWYoIXJlc29sdmVyKXtsb2dnZXIkaS50aHJvd0Vycm9yKFwiYSBwcm92aWRlciBvciBzaWduZXIgaXMgbmVlZGVkIHRvIHJlc29sdmUgRU5TIG5hbWVzXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInJlc29sdmVOYW1lXCJ9KX1jb25zdCBhZGRyZXNzPXlpZWxkIHJlc29sdmVyLnJlc29sdmVOYW1lKG5hbWUpO2lmKGFkZHJlc3M9PW51bGwpe2xvZ2dlciRpLnRocm93QXJndW1lbnRFcnJvcihcInJlc29sdmVyIG9yIGFkZHIgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIEVOUyBuYW1lXCIsXCJuYW1lXCIsbmFtZSl9cmV0dXJuIGFkZHJlc3N9KX1mdW5jdGlvbiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLHZhbHVlLHBhcmFtVHlwZSl7cmV0dXJuIF9fYXdhaXRlciQzKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZihBcnJheS5pc0FycmF5KHBhcmFtVHlwZSkpe3JldHVybiB5aWVsZCBQcm9taXNlLmFsbChwYXJhbVR5cGUubWFwKChwYXJhbVR5cGUsaW5kZXgpPT57cmV0dXJuIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsQXJyYXkuaXNBcnJheSh2YWx1ZSk/dmFsdWVbaW5kZXhdOnZhbHVlW3BhcmFtVHlwZS5uYW1lXSxwYXJhbVR5cGUpfSkpfWlmKHBhcmFtVHlwZS50eXBlPT09XCJhZGRyZXNzXCIpe3JldHVybiB5aWVsZCByZXNvbHZlTmFtZShyZXNvbHZlcix2YWx1ZSl9aWYocGFyYW1UeXBlLnR5cGU9PT1cInR1cGxlXCIpe3JldHVybiB5aWVsZCByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLHZhbHVlLHBhcmFtVHlwZS5jb21wb25lbnRzKX1pZihwYXJhbVR5cGUuYmFzZVR5cGU9PT1cImFycmF5XCIpe2lmKCFBcnJheS5pc0FycmF5KHZhbHVlKSl7cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgdmFsdWUgZm9yIGFycmF5XCIpKX1yZXR1cm4geWllbGQgUHJvbWlzZS5hbGwodmFsdWUubWFwKHY9PnJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsdixwYXJhbVR5cGUuYXJyYXlDaGlsZHJlbikpKX1yZXR1cm4gdmFsdWV9KX1mdW5jdGlvbiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LGZyYWdtZW50LGFyZ3Mpe3JldHVybiBfX2F3YWl0ZXIkMyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7bGV0IG92ZXJyaWRlcz17fTtpZihhcmdzLmxlbmd0aD09PWZyYWdtZW50LmlucHV0cy5sZW5ndGgrMSYmdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGgtMV09PT1cIm9iamVjdFwiKXtvdmVycmlkZXM9c2hhbGxvd0NvcHkoYXJncy5wb3AoKSl9bG9nZ2VyJGkuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLGZyYWdtZW50LmlucHV0cy5sZW5ndGgsXCJwYXNzZWQgdG8gY29udHJhY3RcIik7aWYoY29udHJhY3Quc2lnbmVyKXtpZihvdmVycmlkZXMuZnJvbSl7b3ZlcnJpZGVzLmZyb209cmVzb2x2ZVByb3BlcnRpZXMoe292ZXJyaWRlOnJlc29sdmVOYW1lKGNvbnRyYWN0LnNpZ25lcixvdmVycmlkZXMuZnJvbSksc2lnbmVyOmNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKCl9KS50aGVuKGNoZWNrPT5fX2F3YWl0ZXIkMyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYoZ2V0QWRkcmVzcyhjaGVjay5zaWduZXIpIT09Y2hlY2sub3ZlcnJpZGUpe2xvZ2dlciRpLnRocm93RXJyb3IoXCJDb250cmFjdCB3aXRoIGEgU2lnbmVyIGNhbm5vdCBvdmVycmlkZSBmcm9tXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm92ZXJyaWRlcy5mcm9tXCJ9KX1yZXR1cm4gY2hlY2sub3ZlcnJpZGV9KSl9ZWxzZXtvdmVycmlkZXMuZnJvbT1jb250cmFjdC5zaWduZXIuZ2V0QWRkcmVzcygpfX1lbHNlIGlmKG92ZXJyaWRlcy5mcm9tKXtvdmVycmlkZXMuZnJvbT1yZXNvbHZlTmFtZShjb250cmFjdC5wcm92aWRlcixvdmVycmlkZXMuZnJvbSl9Y29uc3QgcmVzb2x2ZWQ9eWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe2FyZ3M6cmVzb2x2ZUFkZHJlc3Nlcyhjb250cmFjdC5zaWduZXJ8fGNvbnRyYWN0LnByb3ZpZGVyLGFyZ3MsZnJhZ21lbnQuaW5wdXRzKSxhZGRyZXNzOmNvbnRyYWN0LnJlc29sdmVkQWRkcmVzcyxvdmVycmlkZXM6cmVzb2x2ZVByb3BlcnRpZXMob3ZlcnJpZGVzKXx8e319KTtjb25zdCBkYXRhPWNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQscmVzb2x2ZWQuYXJncyk7Y29uc3QgdHg9e2RhdGE6ZGF0YSx0bzpyZXNvbHZlZC5hZGRyZXNzfTtjb25zdCBybz1yZXNvbHZlZC5vdmVycmlkZXM7aWYocm8ubm9uY2UhPW51bGwpe3R4Lm5vbmNlPUJpZ051bWJlci5mcm9tKHJvLm5vbmNlKS50b051bWJlcigpfWlmKHJvLmdhc0xpbWl0IT1udWxsKXt0eC5nYXNMaW1pdD1CaWdOdW1iZXIuZnJvbShyby5nYXNMaW1pdCl9aWYocm8uZ2FzUHJpY2UhPW51bGwpe3R4Lmdhc1ByaWNlPUJpZ051bWJlci5mcm9tKHJvLmdhc1ByaWNlKX1pZihyby5mcm9tIT1udWxsKXt0eC5mcm9tPXJvLmZyb219aWYocm8udHlwZSE9bnVsbCl7dHgudHlwZT1yby50eXBlfWlmKHJvLmFjY2Vzc0xpc3QhPW51bGwpe3R4LmFjY2Vzc0xpc3Q9YWNjZXNzTGlzdGlmeShyby5hY2Nlc3NMaXN0KX1pZih0eC5nYXNMaW1pdD09bnVsbCYmZnJhZ21lbnQuZ2FzIT1udWxsKXtsZXQgaW50cmluc2ljPTIxZTM7Y29uc3QgYnl0ZXM9YXJyYXlpZnkoZGF0YSk7Zm9yKGxldCBpPTA7aTxieXRlcy5sZW5ndGg7aSsrKXtpbnRyaW5zaWMrPTQ7aWYoYnl0ZXNbaV0pe2ludHJpbnNpYys9NjR9fXR4Lmdhc0xpbWl0PUJpZ051bWJlci5mcm9tKGZyYWdtZW50LmdhcykuYWRkKGludHJpbnNpYyl9aWYocm8udmFsdWUpe2NvbnN0IHJvVmFsdWU9QmlnTnVtYmVyLmZyb20ocm8udmFsdWUpO2lmKCFyb1ZhbHVlLmlzWmVybygpJiYhZnJhZ21lbnQucGF5YWJsZSl7bG9nZ2VyJGkudGhyb3dFcnJvcihcIm5vbi1wYXlhYmxlIG1ldGhvZCBjYW5ub3Qgb3ZlcnJpZGUgdmFsdWVcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwib3ZlcnJpZGVzLnZhbHVlXCIsdmFsdWU6b3ZlcnJpZGVzLnZhbHVlfSl9dHgudmFsdWU9cm9WYWx1ZX1kZWxldGUgb3ZlcnJpZGVzLm5vbmNlO2RlbGV0ZSBvdmVycmlkZXMuZ2FzTGltaXQ7ZGVsZXRlIG92ZXJyaWRlcy5nYXNQcmljZTtkZWxldGUgb3ZlcnJpZGVzLmZyb207ZGVsZXRlIG92ZXJyaWRlcy52YWx1ZTtkZWxldGUgb3ZlcnJpZGVzLnR5cGU7ZGVsZXRlIG92ZXJyaWRlcy5hY2Nlc3NMaXN0O2NvbnN0IGxlZnRvdmVycz1PYmplY3Qua2V5cyhvdmVycmlkZXMpLmZpbHRlcihrZXk9Pm92ZXJyaWRlc1trZXldIT1udWxsKTtpZihsZWZ0b3ZlcnMubGVuZ3RoKXtsb2dnZXIkaS50aHJvd0Vycm9yKGBjYW5ub3Qgb3ZlcnJpZGUgJHtsZWZ0b3ZlcnMubWFwKGw9PkpTT04uc3RyaW5naWZ5KGwpKS5qb2luKFwiLFwiKX1gLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJvdmVycmlkZXNcIixvdmVycmlkZXM6bGVmdG92ZXJzfSl9cmV0dXJuIHR4fSl9ZnVuY3Rpb24gYnVpbGRQb3B1bGF0ZShjb250cmFjdCxmcmFnbWVudCl7cmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3Mpe3JldHVybiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LGZyYWdtZW50LGFyZ3MpfX1mdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LGZyYWdtZW50KXtjb25zdCBzaWduZXJPclByb3ZpZGVyPWNvbnRyYWN0LnNpZ25lcnx8Y29udHJhY3QucHJvdmlkZXI7cmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3Mpe3JldHVybiBfX2F3YWl0ZXIkMyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYoIXNpZ25lck9yUHJvdmlkZXIpe2xvZ2dlciRpLnRocm93RXJyb3IoXCJlc3RpbWF0ZSByZXF1aXJlIGEgcHJvdmlkZXIgb3Igc2lnbmVyXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImVzdGltYXRlR2FzXCJ9KX1jb25zdCB0eD15aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LGZyYWdtZW50LGFyZ3MpO3JldHVybiB5aWVsZCBzaWduZXJPclByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KX0pfX1mdW5jdGlvbiBidWlsZENhbGwoY29udHJhY3QsZnJhZ21lbnQsY29sbGFwc2VTaW1wbGUpe2NvbnN0IHNpZ25lck9yUHJvdmlkZXI9Y29udHJhY3Quc2lnbmVyfHxjb250cmFjdC5wcm92aWRlcjtyZXR1cm4gZnVuY3Rpb24oLi4uYXJncyl7cmV0dXJuIF9fYXdhaXRlciQzKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtsZXQgYmxvY2tUYWc9dW5kZWZpbmVkO2lmKGFyZ3MubGVuZ3RoPT09ZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCsxJiZ0eXBlb2YgYXJnc1thcmdzLmxlbmd0aC0xXT09PVwib2JqZWN0XCIpe2NvbnN0IG92ZXJyaWRlcz1zaGFsbG93Q29weShhcmdzLnBvcCgpKTtpZihvdmVycmlkZXMuYmxvY2tUYWchPW51bGwpe2Jsb2NrVGFnPXlpZWxkIG92ZXJyaWRlcy5ibG9ja1RhZ31kZWxldGUgb3ZlcnJpZGVzLmJsb2NrVGFnO2FyZ3MucHVzaChvdmVycmlkZXMpfWlmKGNvbnRyYWN0LmRlcGxveVRyYW5zYWN0aW9uIT1udWxsKXt5aWVsZCBjb250cmFjdC5fZGVwbG95ZWQoYmxvY2tUYWcpfWNvbnN0IHR4PXlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsZnJhZ21lbnQsYXJncyk7Y29uc3QgcmVzdWx0PXlpZWxkIHNpZ25lck9yUHJvdmlkZXIuY2FsbCh0eCxibG9ja1RhZyk7dHJ5e2xldCB2YWx1ZT1jb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQscmVzdWx0KTtpZihjb2xsYXBzZVNpbXBsZSYmZnJhZ21lbnQub3V0cHV0cy5sZW5ndGg9PT0xKXt2YWx1ZT12YWx1ZVswXX1yZXR1cm4gdmFsdWV9Y2F0Y2goZXJyb3Ipe2lmKGVycm9yLmNvZGU9PT1Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKXtlcnJvci5hZGRyZXNzPWNvbnRyYWN0LmFkZHJlc3M7ZXJyb3IuYXJncz1hcmdzO2Vycm9yLnRyYW5zYWN0aW9uPXR4fXRocm93IGVycm9yfX0pfX1mdW5jdGlvbiBidWlsZFNlbmQoY29udHJhY3QsZnJhZ21lbnQpe3JldHVybiBmdW5jdGlvbiguLi5hcmdzKXtyZXR1cm4gX19hd2FpdGVyJDModGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2lmKCFjb250cmFjdC5zaWduZXIpe2xvZ2dlciRpLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBzaWduZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2VuZFRyYW5zYWN0aW9uXCJ9KX1pZihjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiE9bnVsbCl7eWllbGQgY29udHJhY3QuX2RlcGxveWVkKCl9Y29uc3QgdHhSZXF1ZXN0PXlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsZnJhZ21lbnQsYXJncyk7Y29uc3QgdHg9eWllbGQgY29udHJhY3Quc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eFJlcXVlc3QpO2NvbnN0IHdhaXQ9dHgud2FpdC5iaW5kKHR4KTt0eC53YWl0PShjb25maXJtYXRpb25zPT57cmV0dXJuIHdhaXQoY29uZmlybWF0aW9ucykudGhlbihyZWNlaXB0PT57cmVjZWlwdC5ldmVudHM9cmVjZWlwdC5sb2dzLm1hcChsb2c9PntsZXQgZXZlbnQ9ZGVlcENvcHkobG9nKTtsZXQgcGFyc2VkPW51bGw7dHJ5e3BhcnNlZD1jb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKX1jYXRjaChlKXt9aWYocGFyc2VkKXtldmVudC5hcmdzPXBhcnNlZC5hcmdzO2V2ZW50LmRlY29kZT0oKGRhdGEsdG9waWNzKT0+e3JldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsZGF0YSx0b3BpY3MpfSk7ZXZlbnQuZXZlbnQ9cGFyc2VkLm5hbWU7ZXZlbnQuZXZlbnRTaWduYXR1cmU9cGFyc2VkLnNpZ25hdHVyZX1ldmVudC5yZW1vdmVMaXN0ZW5lcj0oKCk9PntyZXR1cm4gY29udHJhY3QucHJvdmlkZXJ9KTtldmVudC5nZXRCbG9jaz0oKCk9PntyZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0QmxvY2socmVjZWlwdC5ibG9ja0hhc2gpfSk7ZXZlbnQuZ2V0VHJhbnNhY3Rpb249KCgpPT57cmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoKX0pO2V2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdD0oKCk9PntyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlY2VpcHQpfSk7cmV0dXJuIGV2ZW50fSk7cmV0dXJuIHJlY2VpcHR9KX0pO3JldHVybiB0eH0pfX1mdW5jdGlvbiBidWlsZERlZmF1bHQoY29udHJhY3QsZnJhZ21lbnQsY29sbGFwc2VTaW1wbGUpe2lmKGZyYWdtZW50LmNvbnN0YW50KXtyZXR1cm4gYnVpbGRDYWxsKGNvbnRyYWN0LGZyYWdtZW50LGNvbGxhcHNlU2ltcGxlKX1yZXR1cm4gYnVpbGRTZW5kKGNvbnRyYWN0LGZyYWdtZW50KX1mdW5jdGlvbiBnZXRFdmVudFRhZyhmaWx0ZXIpe2lmKGZpbHRlci5hZGRyZXNzJiYoZmlsdGVyLnRvcGljcz09bnVsbHx8ZmlsdGVyLnRvcGljcy5sZW5ndGg9PT0wKSl7cmV0dXJuXCIqXCJ9cmV0dXJuKGZpbHRlci5hZGRyZXNzfHxcIipcIikrXCJAXCIrKGZpbHRlci50b3BpY3M/ZmlsdGVyLnRvcGljcy5tYXAodG9waWM9PntpZihBcnJheS5pc0FycmF5KHRvcGljKSl7cmV0dXJuIHRvcGljLmpvaW4oXCJ8XCIpfXJldHVybiB0b3BpY30pLmpvaW4oXCI6XCIpOlwiXCIpfWNsYXNzIFJ1bm5pbmdFdmVudHtjb25zdHJ1Y3Rvcih0YWcsZmlsdGVyKXtkZWZpbmVSZWFkT25seSh0aGlzLFwidGFnXCIsdGFnKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiZmlsdGVyXCIsZmlsdGVyKTt0aGlzLl9saXN0ZW5lcnM9W119YWRkTGlzdGVuZXIobGlzdGVuZXIsb25jZSl7dGhpcy5fbGlzdGVuZXJzLnB1c2goe2xpc3RlbmVyOmxpc3RlbmVyLG9uY2U6b25jZX0pfXJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKXtsZXQgZG9uZT1mYWxzZTt0aGlzLl9saXN0ZW5lcnM9dGhpcy5fbGlzdGVuZXJzLmZpbHRlcihpdGVtPT57aWYoZG9uZXx8aXRlbS5saXN0ZW5lciE9PWxpc3RlbmVyKXtyZXR1cm4gdHJ1ZX1kb25lPXRydWU7cmV0dXJuIGZhbHNlfSl9cmVtb3ZlQWxsTGlzdGVuZXJzKCl7dGhpcy5fbGlzdGVuZXJzPVtdfWxpc3RlbmVycygpe3JldHVybiB0aGlzLl9saXN0ZW5lcnMubWFwKGk9PmkubGlzdGVuZXIpfWxpc3RlbmVyQ291bnQoKXtyZXR1cm4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aH1ydW4oYXJncyl7Y29uc3QgbGlzdGVuZXJDb3VudD10aGlzLmxpc3RlbmVyQ291bnQoKTt0aGlzLl9saXN0ZW5lcnM9dGhpcy5fbGlzdGVuZXJzLmZpbHRlcihpdGVtPT57Y29uc3QgYXJnc0NvcHk9YXJncy5zbGljZSgpO3NldFRpbWVvdXQoKCk9PntpdGVtLmxpc3RlbmVyLmFwcGx5KHRoaXMsYXJnc0NvcHkpfSwwKTtyZXR1cm4haXRlbS5vbmNlfSk7cmV0dXJuIGxpc3RlbmVyQ291bnR9cHJlcGFyZUV2ZW50KGV2ZW50KXt9Z2V0RW1pdChldmVudCl7cmV0dXJuW2V2ZW50XX19Y2xhc3MgRXJyb3JSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnR7Y29uc3RydWN0b3IoKXtzdXBlcihcImVycm9yXCIsbnVsbCl9fWNsYXNzIEZyYWdtZW50UnVubmluZ0V2ZW50IGV4dGVuZHMgUnVubmluZ0V2ZW50e2NvbnN0cnVjdG9yKGFkZHJlc3MsY29udHJhY3RJbnRlcmZhY2UsZnJhZ21lbnQsdG9waWNzKXtjb25zdCBmaWx0ZXI9e2FkZHJlc3M6YWRkcmVzc307bGV0IHRvcGljPWNvbnRyYWN0SW50ZXJmYWNlLmdldEV2ZW50VG9waWMoZnJhZ21lbnQpO2lmKHRvcGljcyl7aWYodG9waWMhPT10b3BpY3NbMF0pe2xvZ2dlciRpLnRocm93QXJndW1lbnRFcnJvcihcInRvcGljIG1pc21hdGNoXCIsXCJ0b3BpY3NcIix0b3BpY3MpfWZpbHRlci50b3BpY3M9dG9waWNzLnNsaWNlKCl9ZWxzZXtmaWx0ZXIudG9waWNzPVt0b3BpY119c3VwZXIoZ2V0RXZlbnRUYWcoZmlsdGVyKSxmaWx0ZXIpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhZGRyZXNzXCIsYWRkcmVzcyk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImludGVyZmFjZVwiLGNvbnRyYWN0SW50ZXJmYWNlKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiZnJhZ21lbnRcIixmcmFnbWVudCl9cHJlcGFyZUV2ZW50KGV2ZW50KXtzdXBlci5wcmVwYXJlRXZlbnQoZXZlbnQpO2V2ZW50LmV2ZW50PXRoaXMuZnJhZ21lbnQubmFtZTtldmVudC5ldmVudFNpZ25hdHVyZT10aGlzLmZyYWdtZW50LmZvcm1hdCgpO2V2ZW50LmRlY29kZT0oKGRhdGEsdG9waWNzKT0+e3JldHVybiB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LGRhdGEsdG9waWNzKX0pO3RyeXtldmVudC5hcmdzPXRoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHRoaXMuZnJhZ21lbnQsZXZlbnQuZGF0YSxldmVudC50b3BpY3MpfWNhdGNoKGVycm9yKXtldmVudC5hcmdzPW51bGw7ZXZlbnQuZGVjb2RlRXJyb3I9ZXJyb3J9fWdldEVtaXQoZXZlbnQpe2NvbnN0IGVycm9ycz1jaGVja1Jlc3VsdEVycm9ycyhldmVudC5hcmdzKTtpZihlcnJvcnMubGVuZ3RoKXt0aHJvdyBlcnJvcnNbMF0uZXJyb3J9Y29uc3QgYXJncz0oZXZlbnQuYXJnc3x8W10pLnNsaWNlKCk7YXJncy5wdXNoKGV2ZW50KTtyZXR1cm4gYXJnc319Y2xhc3MgV2lsZGNhcmRSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnR7Y29uc3RydWN0b3IoYWRkcmVzcyxjb250cmFjdEludGVyZmFjZSl7c3VwZXIoXCIqXCIse2FkZHJlc3M6YWRkcmVzc30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhZGRyZXNzXCIsYWRkcmVzcyk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImludGVyZmFjZVwiLGNvbnRyYWN0SW50ZXJmYWNlKX1wcmVwYXJlRXZlbnQoZXZlbnQpe3N1cGVyLnByZXBhcmVFdmVudChldmVudCk7dHJ5e2NvbnN0IHBhcnNlZD10aGlzLmludGVyZmFjZS5wYXJzZUxvZyhldmVudCk7ZXZlbnQuZXZlbnQ9cGFyc2VkLm5hbWU7ZXZlbnQuZXZlbnRTaWduYXR1cmU9cGFyc2VkLnNpZ25hdHVyZTtldmVudC5kZWNvZGU9KChkYXRhLHRvcGljcyk9PntyZXR1cm4gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsZGF0YSx0b3BpY3MpfSk7ZXZlbnQuYXJncz1wYXJzZWQuYXJnc31jYXRjaChlcnJvcil7fX19Y2xhc3MgQmFzZUNvbnRyYWN0e2NvbnN0cnVjdG9yKGFkZHJlc3NPck5hbWUsY29udHJhY3RJbnRlcmZhY2Usc2lnbmVyT3JQcm92aWRlcil7bG9nZ2VyJGkuY2hlY2tOZXcobmV3LnRhcmdldCxDb250cmFjdCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImludGVyZmFjZVwiLGdldFN0YXRpYyhuZXcudGFyZ2V0LFwiZ2V0SW50ZXJmYWNlXCIpKGNvbnRyYWN0SW50ZXJmYWNlKSk7aWYoc2lnbmVyT3JQcm92aWRlcj09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb3ZpZGVyXCIsbnVsbCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInNpZ25lclwiLG51bGwpfWVsc2UgaWYoU2lnbmVyLmlzU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIpKXtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJvdmlkZXJcIixzaWduZXJPclByb3ZpZGVyLnByb3ZpZGVyfHxudWxsKTtkZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIsc2lnbmVyT3JQcm92aWRlcil9ZWxzZSBpZihQcm92aWRlci5pc1Byb3ZpZGVyKHNpZ25lck9yUHJvdmlkZXIpKXtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJvdmlkZXJcIixzaWduZXJPclByb3ZpZGVyKTtkZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIsbnVsbCl9ZWxzZXtsb2dnZXIkaS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHNpZ25lciBvciBwcm92aWRlclwiLFwic2lnbmVyT3JQcm92aWRlclwiLHNpZ25lck9yUHJvdmlkZXIpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJjYWxsU3RhdGljXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJlc3RpbWF0ZUdhc1wiLHt9KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiZnVuY3Rpb25zXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJmaWx0ZXJzXCIse30pO3tjb25zdCB1bmlxdWVGaWx0ZXJzPXt9O09iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmV2ZW50cykuZm9yRWFjaChldmVudFNpZ25hdHVyZT0+e2NvbnN0IGV2ZW50PXRoaXMuaW50ZXJmYWNlLmV2ZW50c1tldmVudFNpZ25hdHVyZV07ZGVmaW5lUmVhZE9ubHkodGhpcy5maWx0ZXJzLGV2ZW50U2lnbmF0dXJlLCguLi5hcmdzKT0+e3JldHVybnthZGRyZXNzOnRoaXMuYWRkcmVzcyx0b3BpY3M6dGhpcy5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGV2ZW50LGFyZ3MpfX0pO2lmKCF1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdKXt1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdPVtdfXVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0ucHVzaChldmVudFNpZ25hdHVyZSl9KTtPYmplY3Qua2V5cyh1bmlxdWVGaWx0ZXJzKS5mb3JFYWNoKG5hbWU9Pntjb25zdCBmaWx0ZXJzPXVuaXF1ZUZpbHRlcnNbbmFtZV07aWYoZmlsdGVycy5sZW5ndGg9PT0xKXtkZWZpbmVSZWFkT25seSh0aGlzLmZpbHRlcnMsbmFtZSx0aGlzLmZpbHRlcnNbZmlsdGVyc1swXV0pfWVsc2V7bG9nZ2VyJGkud2FybihgRHVwbGljYXRlIGRlZmluaXRpb24gb2YgJHtuYW1lfSAoJHtmaWx0ZXJzLmpvaW4oXCIsIFwiKX0pYCl9fSl9ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9ydW5uaW5nRXZlbnRzXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfd3JhcHBlZEVtaXRzXCIse30pO2lmKGFkZHJlc3NPck5hbWU9PW51bGwpe2xvZ2dlciRpLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29udHJhY3QgYWRkcmVzcyBvciBFTlMgbmFtZVwiLFwiYWRkcmVzc09yTmFtZVwiLGFkZHJlc3NPck5hbWUpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJhZGRyZXNzXCIsYWRkcmVzc09yTmFtZSk7aWYodGhpcy5wcm92aWRlcil7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInJlc29sdmVkQWRkcmVzc1wiLHJlc29sdmVOYW1lKHRoaXMucHJvdmlkZXIsYWRkcmVzc09yTmFtZSkpfWVsc2V7dHJ5e2RlZmluZVJlYWRPbmx5KHRoaXMsXCJyZXNvbHZlZEFkZHJlc3NcIixQcm9taXNlLnJlc29sdmUoZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSkpfWNhdGNoKGVycm9yKXtsb2dnZXIkaS50aHJvd0Vycm9yKFwicHJvdmlkZXIgaXMgcmVxdWlyZWQgdG8gdXNlIEVOUyBuYW1lIGFzIGNvbnRyYWN0IGFkZHJlc3NcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwibmV3IENvbnRyYWN0XCJ9KX19Y29uc3QgdW5pcXVlTmFtZXM9e307Y29uc3QgdW5pcXVlU2lnbmF0dXJlcz17fTtPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5mdW5jdGlvbnMpLmZvckVhY2goc2lnbmF0dXJlPT57Y29uc3QgZnJhZ21lbnQ9dGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zW3NpZ25hdHVyZV07aWYodW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdKXtsb2dnZXIkaS53YXJuKGBEdXBsaWNhdGUgQUJJIGVudHJ5IGZvciAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWApO3JldHVybn11bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV09dHJ1ZTt7Y29uc3QgbmFtZT1mcmFnbWVudC5uYW1lO2lmKCF1bmlxdWVOYW1lc1tuYW1lXSl7dW5pcXVlTmFtZXNbbmFtZV09W119dW5pcXVlTmFtZXNbbmFtZV0ucHVzaChzaWduYXR1cmUpfWlmKHRoaXNbc2lnbmF0dXJlXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcyxzaWduYXR1cmUsYnVpbGREZWZhdWx0KHRoaXMsZnJhZ21lbnQsdHJ1ZSkpfWlmKHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV09PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMuZnVuY3Rpb25zLHNpZ25hdHVyZSxidWlsZERlZmF1bHQodGhpcyxmcmFnbWVudCxmYWxzZSkpfWlmKHRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdPT1udWxsKXtkZWZpbmVSZWFkT25seSh0aGlzLmNhbGxTdGF0aWMsc2lnbmF0dXJlLGJ1aWxkQ2FsbCh0aGlzLGZyYWdtZW50LHRydWUpKX1pZih0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bc2lnbmF0dXJlXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLHNpZ25hdHVyZSxidWlsZFBvcHVsYXRlKHRoaXMsZnJhZ21lbnQpKX1pZih0aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV09PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMuZXN0aW1hdGVHYXMsc2lnbmF0dXJlLGJ1aWxkRXN0aW1hdGUodGhpcyxmcmFnbWVudCkpfX0pO09iamVjdC5rZXlzKHVuaXF1ZU5hbWVzKS5mb3JFYWNoKG5hbWU9Pntjb25zdCBzaWduYXR1cmVzPXVuaXF1ZU5hbWVzW25hbWVdO2lmKHNpZ25hdHVyZXMubGVuZ3RoPjEpe3JldHVybn1jb25zdCBzaWduYXR1cmU9c2lnbmF0dXJlc1swXTt0cnl7aWYodGhpc1tuYW1lXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcyxuYW1lLHRoaXNbc2lnbmF0dXJlXSl9fWNhdGNoKGUpe31pZih0aGlzLmZ1bmN0aW9uc1tuYW1lXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsbmFtZSx0aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdKX1pZih0aGlzLmNhbGxTdGF0aWNbbmFtZV09PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMuY2FsbFN0YXRpYyxuYW1lLHRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKX1pZih0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bbmFtZV09PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbixuYW1lLHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKX1pZih0aGlzLmVzdGltYXRlR2FzW25hbWVdPT1udWxsKXtkZWZpbmVSZWFkT25seSh0aGlzLmVzdGltYXRlR2FzLG5hbWUsdGhpcy5lc3RpbWF0ZUdhc1tzaWduYXR1cmVdKX19KX1zdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKXtyZXR1cm4gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKX1zdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKXtpZihJbnRlcmZhY2UuaXNJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpKXtyZXR1cm4gY29udHJhY3RJbnRlcmZhY2V9cmV0dXJuIG5ldyBJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpfWRlcGxveWVkKCl7cmV0dXJuIHRoaXMuX2RlcGxveWVkKCl9X2RlcGxveWVkKGJsb2NrVGFnKXtpZighdGhpcy5fZGVwbG95ZWRQcm9taXNlKXtpZih0aGlzLmRlcGxveVRyYW5zYWN0aW9uKXt0aGlzLl9kZXBsb3llZFByb21pc2U9dGhpcy5kZXBsb3lUcmFuc2FjdGlvbi53YWl0KCkudGhlbigoKT0+e3JldHVybiB0aGlzfSl9ZWxzZXt0aGlzLl9kZXBsb3llZFByb21pc2U9dGhpcy5wcm92aWRlci5nZXRDb2RlKHRoaXMuYWRkcmVzcyxibG9ja1RhZykudGhlbihjb2RlPT57aWYoY29kZT09PVwiMHhcIil7bG9nZ2VyJGkudGhyb3dFcnJvcihcImNvbnRyYWN0IG5vdCBkZXBsb3llZFwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtjb250cmFjdEFkZHJlc3M6dGhpcy5hZGRyZXNzLG9wZXJhdGlvbjpcImdldERlcGxveWVkXCJ9KX1yZXR1cm4gdGhpc30pfX1yZXR1cm4gdGhpcy5fZGVwbG95ZWRQcm9taXNlfWZhbGxiYWNrKG92ZXJyaWRlcyl7aWYoIXRoaXMuc2lnbmVyKXtsb2dnZXIkaS50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9ucyByZXF1aXJlIGEgc2lnbmVyXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInNlbmRUcmFuc2FjdGlvbihmYWxsYmFjaylcIn0pfWNvbnN0IHR4PXNoYWxsb3dDb3B5KG92ZXJyaWRlc3x8e30pO1tcImZyb21cIixcInRvXCJdLmZvckVhY2goZnVuY3Rpb24oa2V5KXtpZih0eFtrZXldPT1udWxsKXtyZXR1cm59bG9nZ2VyJGkudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIitrZXksTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjprZXl9KX0pO3R4LnRvPXRoaXMucmVzb2x2ZWRBZGRyZXNzO3JldHVybiB0aGlzLmRlcGxveWVkKCkudGhlbigoKT0+e3JldHVybiB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpfSl9Y29ubmVjdChzaWduZXJPclByb3ZpZGVyKXtpZih0eXBlb2Ygc2lnbmVyT3JQcm92aWRlcj09PVwic3RyaW5nXCIpe3NpZ25lck9yUHJvdmlkZXI9bmV3IFZvaWRTaWduZXIoc2lnbmVyT3JQcm92aWRlcix0aGlzLnByb3ZpZGVyKX1jb25zdCBjb250cmFjdD1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmFkZHJlc3MsdGhpcy5pbnRlcmZhY2Usc2lnbmVyT3JQcm92aWRlcik7aWYodGhpcy5kZXBsb3lUcmFuc2FjdGlvbil7ZGVmaW5lUmVhZE9ubHkoY29udHJhY3QsXCJkZXBsb3lUcmFuc2FjdGlvblwiLHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pfXJldHVybiBjb250cmFjdH1hdHRhY2goYWRkcmVzc09yTmFtZSl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKGFkZHJlc3NPck5hbWUsdGhpcy5pbnRlcmZhY2UsdGhpcy5zaWduZXJ8fHRoaXMucHJvdmlkZXIpfXN0YXRpYyBpc0luZGV4ZWQodmFsdWUpe3JldHVybiBJbmRleGVkLmlzSW5kZXhlZCh2YWx1ZSl9X25vcm1hbGl6ZVJ1bm5pbmdFdmVudChydW5uaW5nRXZlbnQpe2lmKHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ10pe3JldHVybiB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddfXJldHVybiBydW5uaW5nRXZlbnR9X2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpe2lmKHR5cGVvZiBldmVudE5hbWU9PT1cInN0cmluZ1wiKXtpZihldmVudE5hbWU9PT1cImVycm9yXCIpe3JldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEVycm9yUnVubmluZ0V2ZW50KX1pZihldmVudE5hbWU9PT1cImV2ZW50XCIpe3JldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFJ1bm5pbmdFdmVudChcImV2ZW50XCIsbnVsbCkpfWlmKGV2ZW50TmFtZT09PVwiKlwiKXtyZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsdGhpcy5pbnRlcmZhY2UpKX1jb25zdCBmcmFnbWVudD10aGlzLmludGVyZmFjZS5nZXRFdmVudChldmVudE5hbWUpO3JldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcyx0aGlzLmludGVyZmFjZSxmcmFnbWVudCkpfWlmKGV2ZW50TmFtZS50b3BpY3MmJmV2ZW50TmFtZS50b3BpY3MubGVuZ3RoPjApe3RyeXtjb25zdCB0b3BpYz1ldmVudE5hbWUudG9waWNzWzBdO2lmKHR5cGVvZiB0b3BpYyE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgdG9waWNcIil9Y29uc3QgZnJhZ21lbnQ9dGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQodG9waWMpO3JldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcyx0aGlzLmludGVyZmFjZSxmcmFnbWVudCxldmVudE5hbWUudG9waWNzKSl9Y2F0Y2goZXJyb3Ipe31jb25zdCBmaWx0ZXI9e2FkZHJlc3M6dGhpcy5hZGRyZXNzLHRvcGljczpldmVudE5hbWUudG9waWNzfTtyZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoZ2V0RXZlbnRUYWcoZmlsdGVyKSxmaWx0ZXIpKX1yZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsdGhpcy5pbnRlcmZhY2UpKX1fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCl7aWYocnVubmluZ0V2ZW50Lmxpc3RlbmVyQ291bnQoKT09PTApe2RlbGV0ZSB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddO2NvbnN0IGVtaXQ9dGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO2lmKGVtaXQmJnJ1bm5pbmdFdmVudC5maWx0ZXIpe3RoaXMucHJvdmlkZXIub2ZmKHJ1bm5pbmdFdmVudC5maWx0ZXIsZW1pdCk7ZGVsZXRlIHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXX19fV93cmFwRXZlbnQocnVubmluZ0V2ZW50LGxvZyxsaXN0ZW5lcil7Y29uc3QgZXZlbnQ9ZGVlcENvcHkobG9nKTtldmVudC5yZW1vdmVMaXN0ZW5lcj0oKCk9PntpZighbGlzdGVuZXIpe3JldHVybn1ydW5uaW5nRXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO3RoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpfSk7ZXZlbnQuZ2V0QmxvY2s9KCgpPT57cmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobG9nLmJsb2NrSGFzaCl9KTtldmVudC5nZXRUcmFuc2FjdGlvbj0oKCk9PntyZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihsb2cudHJhbnNhY3Rpb25IYXNoKX0pO2V2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdD0oKCk9PntyZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQobG9nLnRyYW5zYWN0aW9uSGFzaCl9KTtydW5uaW5nRXZlbnQucHJlcGFyZUV2ZW50KGV2ZW50KTtyZXR1cm4gZXZlbnR9X2FkZEV2ZW50TGlzdGVuZXIocnVubmluZ0V2ZW50LGxpc3RlbmVyLG9uY2Upe2lmKCF0aGlzLnByb3ZpZGVyKXtsb2dnZXIkaS50aHJvd0Vycm9yKFwiZXZlbnRzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwib25jZVwifSl9cnVubmluZ0V2ZW50LmFkZExpc3RlbmVyKGxpc3RlbmVyLG9uY2UpO3RoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ109cnVubmluZ0V2ZW50O2lmKCF0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10pe2NvbnN0IHdyYXBwZWRFbWl0PWxvZz0+e2xldCBldmVudD10aGlzLl93cmFwRXZlbnQocnVubmluZ0V2ZW50LGxvZyxsaXN0ZW5lcik7aWYoZXZlbnQuZGVjb2RlRXJyb3I9PW51bGwpe3RyeXtjb25zdCBhcmdzPXJ1bm5pbmdFdmVudC5nZXRFbWl0KGV2ZW50KTt0aGlzLmVtaXQocnVubmluZ0V2ZW50LmZpbHRlciwuLi5hcmdzKX1jYXRjaChlcnJvcil7ZXZlbnQuZGVjb2RlRXJyb3I9ZXJyb3IuZXJyb3J9fWlmKHJ1bm5pbmdFdmVudC5maWx0ZXIhPW51bGwpe3RoaXMuZW1pdChcImV2ZW50XCIsZXZlbnQpfWlmKGV2ZW50LmRlY29kZUVycm9yIT1udWxsKXt0aGlzLmVtaXQoXCJlcnJvclwiLGV2ZW50LmRlY29kZUVycm9yLGV2ZW50KX19O3RoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXT13cmFwcGVkRW1pdDtpZihydW5uaW5nRXZlbnQuZmlsdGVyIT1udWxsKXt0aGlzLnByb3ZpZGVyLm9uKHJ1bm5pbmdFdmVudC5maWx0ZXIsd3JhcHBlZEVtaXQpfX19cXVlcnlGaWx0ZXIoZXZlbnQsZnJvbUJsb2NrT3JCbG9ja2hhc2gsdG9CbG9jayl7Y29uc3QgcnVubmluZ0V2ZW50PXRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCk7Y29uc3QgZmlsdGVyPXNoYWxsb3dDb3B5KHJ1bm5pbmdFdmVudC5maWx0ZXIpO2lmKHR5cGVvZiBmcm9tQmxvY2tPckJsb2NraGFzaD09PVwic3RyaW5nXCImJmlzSGV4U3RyaW5nKGZyb21CbG9ja09yQmxvY2toYXNoLDMyKSl7aWYodG9CbG9jayE9bnVsbCl7bG9nZ2VyJGkudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IHNwZWNpZnkgdG9CbG9jayB3aXRoIGJsb2NraGFzaFwiLFwidG9CbG9ja1wiLHRvQmxvY2spfWZpbHRlci5ibG9ja0hhc2g9ZnJvbUJsb2NrT3JCbG9ja2hhc2h9ZWxzZXtmaWx0ZXIuZnJvbUJsb2NrPWZyb21CbG9ja09yQmxvY2toYXNoIT1udWxsP2Zyb21CbG9ja09yQmxvY2toYXNoOjA7ZmlsdGVyLnRvQmxvY2s9dG9CbG9jayE9bnVsbD90b0Jsb2NrOlwibGF0ZXN0XCJ9cmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpLnRoZW4obG9ncz0+e3JldHVybiBsb2dzLm1hcChsb2c9PnRoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsbG9nLG51bGwpKX0pfW9uKGV2ZW50LGxpc3RlbmVyKXt0aGlzLl9hZGRFdmVudExpc3RlbmVyKHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCksbGlzdGVuZXIsZmFsc2UpO3JldHVybiB0aGlzfW9uY2UoZXZlbnQsbGlzdGVuZXIpe3RoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSxsaXN0ZW5lcix0cnVlKTtyZXR1cm4gdGhpc31lbWl0KGV2ZW50TmFtZSwuLi5hcmdzKXtpZighdGhpcy5wcm92aWRlcil7cmV0dXJuIGZhbHNlfWNvbnN0IHJ1bm5pbmdFdmVudD10aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtjb25zdCByZXN1bHQ9cnVubmluZ0V2ZW50LnJ1bihhcmdzKT4wO3RoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO3JldHVybiByZXN1bHR9bGlzdGVuZXJDb3VudChldmVudE5hbWUpe2lmKCF0aGlzLnByb3ZpZGVyKXtyZXR1cm4gMH1pZihldmVudE5hbWU9PW51bGwpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLl9ydW5uaW5nRXZlbnRzKS5yZWR1Y2UoKGFjY3VtLGtleSk9PntyZXR1cm4gYWNjdW0rdGhpcy5fcnVubmluZ0V2ZW50c1trZXldLmxpc3RlbmVyQ291bnQoKX0sMCl9cmV0dXJuIHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpLmxpc3RlbmVyQ291bnQoKX1saXN0ZW5lcnMoZXZlbnROYW1lKXtpZighdGhpcy5wcm92aWRlcil7cmV0dXJuW119aWYoZXZlbnROYW1lPT1udWxsKXtjb25zdCByZXN1bHQ9W107Zm9yKGxldCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cyl7dGhpcy5fcnVubmluZ0V2ZW50c1t0YWddLmxpc3RlbmVycygpLmZvckVhY2gobGlzdGVuZXI9PntyZXN1bHQucHVzaChsaXN0ZW5lcil9KX1yZXR1cm4gcmVzdWx0fXJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lcnMoKX1yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKXtpZighdGhpcy5wcm92aWRlcil7cmV0dXJuIHRoaXN9aWYoZXZlbnROYW1lPT1udWxsKXtmb3IoY29uc3QgdGFnIGluIHRoaXMuX3J1bm5pbmdFdmVudHMpe2NvbnN0IHJ1bm5pbmdFdmVudD10aGlzLl9ydW5uaW5nRXZlbnRzW3RhZ107cnVubmluZ0V2ZW50LnJlbW92ZUFsbExpc3RlbmVycygpO3RoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpfXJldHVybiB0aGlzfWNvbnN0IHJ1bm5pbmdFdmVudD10aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7dGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7cmV0dXJuIHRoaXN9b2ZmKGV2ZW50TmFtZSxsaXN0ZW5lcil7aWYoIXRoaXMucHJvdmlkZXIpe3JldHVybiB0aGlzfWNvbnN0IHJ1bm5pbmdFdmVudD10aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtydW5uaW5nRXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO3RoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO3JldHVybiB0aGlzfXJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSxsaXN0ZW5lcil7cmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSxsaXN0ZW5lcil9fWNsYXNzIENvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0e31jbGFzcyBDb250cmFjdEZhY3Rvcnl7Y29uc3RydWN0b3IoY29udHJhY3RJbnRlcmZhY2UsYnl0ZWNvZGUsc2lnbmVyKXtsZXQgYnl0ZWNvZGVIZXg9bnVsbDtpZih0eXBlb2YgYnl0ZWNvZGU9PT1cInN0cmluZ1wiKXtieXRlY29kZUhleD1ieXRlY29kZX1lbHNlIGlmKGlzQnl0ZXMoYnl0ZWNvZGUpKXtieXRlY29kZUhleD1oZXhsaWZ5KGJ5dGVjb2RlKX1lbHNlIGlmKGJ5dGVjb2RlJiZ0eXBlb2YgYnl0ZWNvZGUub2JqZWN0PT09XCJzdHJpbmdcIil7Ynl0ZWNvZGVIZXg9Ynl0ZWNvZGUub2JqZWN0fWVsc2V7Ynl0ZWNvZGVIZXg9XCIhXCJ9aWYoYnl0ZWNvZGVIZXguc3Vic3RyaW5nKDAsMikhPT1cIjB4XCIpe2J5dGVjb2RlSGV4PVwiMHhcIitieXRlY29kZUhleH1pZighaXNIZXhTdHJpbmcoYnl0ZWNvZGVIZXgpfHxieXRlY29kZUhleC5sZW5ndGglMil7bG9nZ2VyJGkudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlY29kZVwiLFwiYnl0ZWNvZGVcIixieXRlY29kZSl9aWYoc2lnbmVyJiYhU2lnbmVyLmlzU2lnbmVyKHNpZ25lcikpe2xvZ2dlciRpLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyXCIsXCJzaWduZXJcIixzaWduZXIpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJieXRlY29kZVwiLGJ5dGVjb2RlSGV4KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsZ2V0U3RhdGljKG5ldy50YXJnZXQsXCJnZXRJbnRlcmZhY2VcIikoY29udHJhY3RJbnRlcmZhY2UpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIsc2lnbmVyfHxudWxsKX1nZXREZXBsb3lUcmFuc2FjdGlvbiguLi5hcmdzKXtsZXQgdHg9e307aWYoYXJncy5sZW5ndGg9PT10aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCsxJiZ0eXBlb2YgYXJnc1thcmdzLmxlbmd0aC0xXT09PVwib2JqZWN0XCIpe3R4PXNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO2Zvcihjb25zdCBrZXkgaW4gdHgpe2lmKCFhbGxvd2VkVHJhbnNhY3Rpb25LZXlzJDJba2V5XSl7dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0cmFuc2FjdGlvbiBvdmVycmlkZSBcIitrZXkpfX19W1wiZGF0YVwiLFwiZnJvbVwiLFwidG9cIl0uZm9yRWFjaChrZXk9PntpZih0eFtrZXldPT1udWxsKXtyZXR1cm59bG9nZ2VyJGkudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIitrZXksTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjprZXl9KX0pO2xvZ2dlciRpLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCx0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCxcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTt0eC5kYXRhPWhleGxpZnkoY29uY2F0KFt0aGlzLmJ5dGVjb2RlLHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShhcmdzKV0pKTtyZXR1cm4gdHh9ZGVwbG95KC4uLmFyZ3Mpe3JldHVybiBfX2F3YWl0ZXIkMyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7bGV0IG92ZXJyaWRlcz17fTtpZihhcmdzLmxlbmd0aD09PXRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoKzEpe292ZXJyaWRlcz1hcmdzLnBvcCgpfWxvZ2dlciRpLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCx0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCxcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtjb25zdCBwYXJhbXM9eWllbGQgcmVzb2x2ZUFkZHJlc3Nlcyh0aGlzLnNpZ25lcixhcmdzLHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMpO3BhcmFtcy5wdXNoKG92ZXJyaWRlcyk7Y29uc3QgdW5zaWduZWRUeD10aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLnBhcmFtcyk7Y29uc3QgdHg9eWllbGQgdGhpcy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHVuc2lnbmVkVHgpO2NvbnN0IGFkZHJlc3M9Z2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsXCJnZXRDb250cmFjdEFkZHJlc3NcIikodHgpO2NvbnN0IGNvbnRyYWN0PWdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLFwiZ2V0Q29udHJhY3RcIikoYWRkcmVzcyx0aGlzLmludGVyZmFjZSx0aGlzLnNpZ25lcik7ZGVmaW5lUmVhZE9ubHkoY29udHJhY3QsXCJkZXBsb3lUcmFuc2FjdGlvblwiLHR4KTtyZXR1cm4gY29udHJhY3R9KX1hdHRhY2goYWRkcmVzcyl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IuZ2V0Q29udHJhY3QoYWRkcmVzcyx0aGlzLmludGVyZmFjZSx0aGlzLnNpZ25lcil9Y29ubmVjdChzaWduZXIpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmludGVyZmFjZSx0aGlzLmJ5dGVjb2RlLHNpZ25lcil9c3RhdGljIGZyb21Tb2xpZGl0eShjb21waWxlck91dHB1dCxzaWduZXIpe2lmKGNvbXBpbGVyT3V0cHV0PT1udWxsKXtsb2dnZXIkaS50aHJvd0Vycm9yKFwibWlzc2luZyBjb21waWxlciBvdXRwdXRcIixMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQse2FyZ3VtZW50OlwiY29tcGlsZXJPdXRwdXRcIn0pfWlmKHR5cGVvZiBjb21waWxlck91dHB1dD09PVwic3RyaW5nXCIpe2NvbXBpbGVyT3V0cHV0PUpTT04ucGFyc2UoY29tcGlsZXJPdXRwdXQpfWNvbnN0IGFiaT1jb21waWxlck91dHB1dC5hYmk7bGV0IGJ5dGVjb2RlPW51bGw7aWYoY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGUpe2J5dGVjb2RlPWNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlfWVsc2UgaWYoY29tcGlsZXJPdXRwdXQuZXZtJiZjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGUpe2J5dGVjb2RlPWNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZX1yZXR1cm4gbmV3IHRoaXMoYWJpLGJ5dGVjb2RlLHNpZ25lcil9c3RhdGljIGdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSl7cmV0dXJuIENvbnRyYWN0LmdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSl9c3RhdGljIGdldENvbnRyYWN0QWRkcmVzcyh0eCl7cmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh0eCl9c3RhdGljIGdldENvbnRyYWN0KGFkZHJlc3MsY29udHJhY3RJbnRlcmZhY2Usc2lnbmVyKXtyZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsY29udHJhY3RJbnRlcmZhY2Usc2lnbmVyKX19Y2xhc3MgQmFzZVh7Y29uc3RydWN0b3IoYWxwaGFiZXQpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhbHBoYWJldFwiLGFscGhhYmV0KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYmFzZVwiLGFscGhhYmV0Lmxlbmd0aCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9hbHBoYWJldE1hcFwiLHt9KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2xlYWRlclwiLGFscGhhYmV0LmNoYXJBdCgwKSk7Zm9yKGxldCBpPTA7aTxhbHBoYWJldC5sZW5ndGg7aSsrKXt0aGlzLl9hbHBoYWJldE1hcFthbHBoYWJldC5jaGFyQXQoaSldPWl9fWVuY29kZSh2YWx1ZSl7bGV0IHNvdXJjZT1hcnJheWlmeSh2YWx1ZSk7aWYoc291cmNlLmxlbmd0aD09PTApe3JldHVyblwiXCJ9bGV0IGRpZ2l0cz1bMF07Zm9yKGxldCBpPTA7aTxzb3VyY2UubGVuZ3RoOysraSl7bGV0IGNhcnJ5PXNvdXJjZVtpXTtmb3IobGV0IGo9MDtqPGRpZ2l0cy5sZW5ndGg7KytqKXtjYXJyeSs9ZGlnaXRzW2pdPDw4O2RpZ2l0c1tqXT1jYXJyeSV0aGlzLmJhc2U7Y2Fycnk9Y2FycnkvdGhpcy5iYXNlfDB9d2hpbGUoY2Fycnk+MCl7ZGlnaXRzLnB1c2goY2FycnkldGhpcy5iYXNlKTtjYXJyeT1jYXJyeS90aGlzLmJhc2V8MH19bGV0IHN0cmluZz1cIlwiO2ZvcihsZXQgaz0wO3NvdXJjZVtrXT09PTAmJms8c291cmNlLmxlbmd0aC0xOysrayl7c3RyaW5nKz10aGlzLl9sZWFkZXJ9Zm9yKGxldCBxPWRpZ2l0cy5sZW5ndGgtMTtxPj0wOy0tcSl7c3RyaW5nKz10aGlzLmFscGhhYmV0W2RpZ2l0c1txXV19cmV0dXJuIHN0cmluZ31kZWNvZGUodmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIil9bGV0IGJ5dGVzPVtdO2lmKHZhbHVlLmxlbmd0aD09PTApe3JldHVybiBuZXcgVWludDhBcnJheShieXRlcyl9Ynl0ZXMucHVzaCgwKTtmb3IobGV0IGk9MDtpPHZhbHVlLmxlbmd0aDtpKyspe2xldCBieXRlPXRoaXMuX2FscGhhYmV0TWFwW3ZhbHVlW2ldXTtpZihieXRlPT09dW5kZWZpbmVkKXt0aHJvdyBuZXcgRXJyb3IoXCJOb24tYmFzZVwiK3RoaXMuYmFzZStcIiBjaGFyYWN0ZXJcIil9bGV0IGNhcnJ5PWJ5dGU7Zm9yKGxldCBqPTA7ajxieXRlcy5sZW5ndGg7KytqKXtjYXJyeSs9Ynl0ZXNbal0qdGhpcy5iYXNlO2J5dGVzW2pdPWNhcnJ5JjI1NTtjYXJyeT4+PTh9d2hpbGUoY2Fycnk+MCl7Ynl0ZXMucHVzaChjYXJyeSYyNTUpO2NhcnJ5Pj49OH19Zm9yKGxldCBrPTA7dmFsdWVba109PT10aGlzLl9sZWFkZXImJms8dmFsdWUubGVuZ3RoLTE7KytrKXtieXRlcy5wdXNoKDApfXJldHVybiBhcnJheWlmeShuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpKX19Y29uc3QgQmFzZTMyPW5ldyBCYXNlWChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIpO2NvbnN0IEJhc2U1OD1uZXcgQmFzZVgoXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIpO3ZhciBTdXBwb3J0ZWRBbGdvcml0aG07KGZ1bmN0aW9uKFN1cHBvcnRlZEFsZ29yaXRobSl7U3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhMjU2XCJdPVwic2hhMjU2XCI7U3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdPVwic2hhNTEyXCJ9KShTdXBwb3J0ZWRBbGdvcml0aG18fChTdXBwb3J0ZWRBbGdvcml0aG09e30pKTtjb25zdCB2ZXJzaW9uJGU9XCJzaGEyLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJGo9bmV3IExvZ2dlcih2ZXJzaW9uJGUpO2Z1bmN0aW9uIHJpcGVtZDE2MCQxKGRhdGEpe3JldHVyblwiMHhcIitoYXNoXzEucmlwZW1kMTYwKCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIil9ZnVuY3Rpb24gc2hhMjU2JDEoZGF0YSl7cmV0dXJuXCIweFwiK2hhc2hfMS5zaGEyNTYoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKX1mdW5jdGlvbiBzaGE1MTIkMShkYXRhKXtyZXR1cm5cIjB4XCIraGFzaF8xLnNoYTUxMigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpfWZ1bmN0aW9uIGNvbXB1dGVIbWFjKGFsZ29yaXRobSxrZXksZGF0YSl7aWYoIVN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKXtsb2dnZXIkai50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiK2FsZ29yaXRobSxMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiaG1hY1wiLGFsZ29yaXRobTphbGdvcml0aG19KX1yZXR1cm5cIjB4XCIraGFzaF8xLmhtYWMoaGFzaF8xW2FsZ29yaXRobV0sYXJyYXlpZnkoa2V5KSkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIil9XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcGJrZGYyKHBhc3N3b3JkLHNhbHQsaXRlcmF0aW9ucyxrZXlsZW4saGFzaEFsZ29yaXRobSl7cGFzc3dvcmQ9YXJyYXlpZnkocGFzc3dvcmQpO3NhbHQ9YXJyYXlpZnkoc2FsdCk7bGV0IGhMZW47bGV0IGw9MTtjb25zdCBESz1uZXcgVWludDhBcnJheShrZXlsZW4pO2NvbnN0IGJsb2NrMT1uZXcgVWludDhBcnJheShzYWx0Lmxlbmd0aCs0KTtibG9jazEuc2V0KHNhbHQpO2xldCByO2xldCBUO2ZvcihsZXQgaT0xO2k8PWw7aSsrKXtibG9jazFbc2FsdC5sZW5ndGhdPWk+PjI0JjI1NTtibG9jazFbc2FsdC5sZW5ndGgrMV09aT4+MTYmMjU1O2Jsb2NrMVtzYWx0Lmxlbmd0aCsyXT1pPj44JjI1NTtibG9jazFbc2FsdC5sZW5ndGgrM109aSYyNTU7bGV0IFU9YXJyYXlpZnkoY29tcHV0ZUhtYWMoaGFzaEFsZ29yaXRobSxwYXNzd29yZCxibG9jazEpKTtpZighaExlbil7aExlbj1VLmxlbmd0aDtUPW5ldyBVaW50OEFycmF5KGhMZW4pO2w9TWF0aC5jZWlsKGtleWxlbi9oTGVuKTtyPWtleWxlbi0obC0xKSpoTGVufVQuc2V0KFUpO2ZvcihsZXQgaj0xO2o8aXRlcmF0aW9ucztqKyspe1U9YXJyYXlpZnkoY29tcHV0ZUhtYWMoaGFzaEFsZ29yaXRobSxwYXNzd29yZCxVKSk7Zm9yKGxldCBrPTA7azxoTGVuO2srKylUW2tdXj1VW2tdfWNvbnN0IGRlc3RQb3M9KGktMSkqaExlbjtjb25zdCBsZW49aT09PWw/cjpoTGVuO0RLLnNldChhcnJheWlmeShUKS5zbGljZSgwLGxlbiksZGVzdFBvcyl9cmV0dXJuIGhleGxpZnkoREspfWNvbnN0IHZlcnNpb24kZj1cIndvcmRsaXN0cy81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGV4cG9ydFdvcmRsaXN0PWZhbHNlO2NvbnN0IGxvZ2dlciRrPW5ldyBMb2dnZXIodmVyc2lvbiRmKTtjbGFzcyBXb3JkbGlzdHtjb25zdHJ1Y3Rvcihsb2NhbGUpe2xvZ2dlciRrLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCxXb3JkbGlzdCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImxvY2FsZVwiLGxvY2FsZSl9c3BsaXQobW5lbW9uaWMpe3JldHVybiBtbmVtb25pYy50b0xvd2VyQ2FzZSgpLnNwbGl0KC8gKy9nKX1qb2luKHdvcmRzKXtyZXR1cm4gd29yZHMuam9pbihcIiBcIil9c3RhdGljIGNoZWNrKHdvcmRsaXN0KXtjb25zdCB3b3Jkcz1bXTtmb3IobGV0IGk9MDtpPDIwNDg7aSsrKXtjb25zdCB3b3JkPXdvcmRsaXN0LmdldFdvcmQoaSk7aWYoaSE9PXdvcmRsaXN0LmdldFdvcmRJbmRleCh3b3JkKSl7cmV0dXJuXCIweFwifXdvcmRzLnB1c2god29yZCl9cmV0dXJuIGlkKHdvcmRzLmpvaW4oXCJcXG5cIikrXCJcXG5cIil9c3RhdGljIHJlZ2lzdGVyKGxhbmcsbmFtZSl7aWYoIW5hbWUpe25hbWU9bGFuZy5sb2NhbGV9aWYoZXhwb3J0V29yZGxpc3Qpe3RyeXtjb25zdCBhbnlHbG9iYWw9d2luZG93O2lmKGFueUdsb2JhbC5fZXRoZXJzJiZhbnlHbG9iYWwuX2V0aGVycy53b3JkbGlzdHMpe2lmKCFhbnlHbG9iYWwuX2V0aGVycy53b3JkbGlzdHNbbmFtZV0pe2RlZmluZVJlYWRPbmx5KGFueUdsb2JhbC5fZXRoZXJzLndvcmRsaXN0cyxuYW1lLGxhbmcpfX19Y2F0Y2goZXJyb3Ipe319fX1cInVzZSBzdHJpY3RcIjtjb25zdCB3b3Jkcz1cIkFiZGlrYWNlQWJlY2VkYUFkcmVzYUFncmVzZUFrY2VBa3RvdmthQWxlakFsa29ob2xBbXB1dGFjZUFuYW5hc0FuZHVsa2FBbmVrZG90YUFua2V0YUFudGlrYUFudWxvdmF0QXJjaGFBcm9nYW5jZUFzZmFsdEFzaXN0ZW50QXNwaXJhY2VBc3RtYUFzdHJvbm9tQXRsYXNBdGxldGlrYUF0b2xBdXRvYnVzQXp5bEJhYmthQmFjaG9yQmFjaWxCYWN1bGthQmFkYXRlbEJhZ2V0YUJhZ3JCYWhub0Jha3RlcmllQmFsYWRhQmFsZXRrYUJhbGtvbkJhbG9uZWtCYWx2YW5CYWx6YUJhbWJ1c0JhbmtvbWF0QmFyYmFyQmFyZXRCYXJtYW5CYXJva29CYXJ2YUJhdGVya2FCYXRvaEJhdmxuYUJhemFsa2FCYXppbGlrYUJhenVrYUJlZG5hQmVyYW5CZXNlZGFCZXN0aWVCZXRvbkJlemlua2FCZXptb2NCZXp0YWtCaWN5a2xCaWRsb0JpZnRla0Jpa2lueUJpbGFuY2VCaW9ncmFmQmlvbG9nQml0dmFCaXpvbkJsYWhvYnl0QmxhdG91Y2hCbGVjaGFCbGVkdWxlQmxlc2tCbGlrYXRCbGl6bmFCbG9rb3ZhdEJsb3VkaXRCbHVkQm9iZWtCb2JyQm9kbGluYUJvZG5vdXRCb2hhdG9zdEJvamtvdEJvam92YXRCb2tvcnlzQm9sZXN0Qm9yZWNCb3JvdmljZUJvdGFCb3ViZWxCb3VjaGF0Qm91ZGFCb3VsZUJvdXJhdEJveGVyQnJhZGF2a2FCcmFtYm9yYUJyYW5rYUJyYXRyQnJlcHRhQnJpa2V0YUJya29CcmxvaEJyb256QnJvc2tldkJydW5ldGthQnJ1c2lua2FCcnpkYUJyenlCdWJsaW5hQnVibm92YXRCdWNodGFCdWRpdGVsQnVka2FCdWRvdmFCdWZldEJ1amFyb3N0QnVrdmljZUJ1bGRva0J1bHZhQnVuZGFCdW5rckJ1cnphQnV0aWtCdXZvbEJ1em9sYUJ5ZGxldEJ5bGluYUJ5dG92a2FCenVrb3RDYXBhcnRDYXJldm5hQ2VkckNlZHVsZUNlamNoQ2VqbkNlbGFDZWxlckNlbGtlbUNlbG5pY2VDZW5pbmFDZW5ub3N0Q2Vub3ZrYUNlbnRydW1DZW56b3JDZXN0b3Bpc0NldGthQ2hhbHVwYUNoYXBhZGxvQ2hhcml0YUNoYXRhQ2hlY2h0YXRDaGVtaWVDaGljaG90Q2hpcnVyZ0NobGFkQ2hsZWJhQ2hsdWJpdENobWVsQ2htdXJhQ2hvYm90Q2hvY2hvbENob2RiYUNob2xlcmFDaG9tb3V0Q2hvcGl0Q2hvcm9iYUNob3ZDaHJhcG90Q2hybGl0Q2hydENocnVwQ2h0aXZvc3RDaHVkaW5hQ2h1dG5hdENodmF0Q2h2aWxrYUNodm9zdENoeWJhQ2h5c3RhdENoeXRpdENpYnVsZUNpZ2FyZXRhQ2loZWxuYUNpaGxhQ2lua290Q2lya3VzQ2lzdGVybmFDaXRhY2VDaXRydXNDaXppbmVjQ2l6b3N0Q2xvbmFDb2tvbGl2Q291dmF0Q3RpdGVsQ3Rub3N0Q3Vkbm9zdEN1a2V0YUN1a3JDdXBvdEN2YWtub3V0Q3ZhbEN2aWtDdnJrb3RDeWtsaXN0YURhbGVrb0RhcmViYURhdGVsRGF0dW1EY2VyYURlYmF0YURlY2hvdmthRGVjaWJlbERlZmljaXREZWZsYWNlRGVrbERla3JldERlbW9rcmF0RGVwcmVzZURlcmJ5RGVza2FEZXRla3RpdkRpa29icmF6RGlrdG92YXREaW9kYURpcGxvbURpc2tEaXNwbGVqRGl2YWRsb0Rpdm9jaERsYWhhRGxvdWhvRGx1aG9waXNEbmVzRG9icm9Eb2J5dGVrRG9jZW50RG9jaHV0aXREb2RuZXNEb2hsZWREb2hvZGFEb2hyYURvamVtRG9qbmljZURva2xhZERva29sYURva3RvckRva3VtZW50RG9sYXJEb2xldmFEb2xpbmFEb21hRG9taW5hbnREb21sdXZpdERvbW92RG9udXRpdERvcGFkRG9waXNEb3Bsbml0RG9wb3N1ZERvcHJvdm9kRG9wdXN0aXREb3Jheml0RG9yb3N0RG9ydERvc2FoRG9zbG92RG9zdGF0ZWtEb3N1ZERvc3l0YURvdGF6RG90ZWtEb3Rrbm91dERvdWZhdERvdXRuYXREb3ZvemNlRG96YWR1RG96bmF0RG96b3JjZURyYWhvdGFEcmFrRHJhbWF0aWtEcmF2ZWNEcmF6ZURyZG9sRHJvYm5vc3REcm9nZXJpZURyb3pkRHJzbm9zdERydGl0RHJ6b3N0RHViZW5EdWNob3Zub0R1ZGVrRHVoYUR1aG92a2FEdXNpdER1c25vRHV0b3N0RHZvamljZUR2b3JlY0R5bmFtaXRFa29sb2dFa29ub21pZUVsZWt0cm9uRWxpcHNhRW1haWxFbWlzZUVtb2NlRW1wYXRpZUVwaXpvZGFFcG9jaGFFcG9wZWpFcG9zRXNlakVzZW5jZUVza29ydGFFc2t5bW9FdGlrZXRhRXVmb3JpZUV2b2x1Y2VFeGVrdWNlRXhrdXJ6ZUV4cGVkaWNlRXhwbG96ZUV4cG9ydEV4dHJha3RGYWNrYUZhamZrYUZha3VsdGFGYW5hdGlrRmFudGF6aWVGYXJtYWNpZUZhdm9yaXRGYXpvbGVGZWRlcmFjZUZlamV0b25GZW5rYUZpYWxrYUZpZ3VyYW50Rmlsb3pvZkZpbHRyRmluYW5jZUZpbnRhRml4YWNlRmpvcmRGbGFuZWxGbGlydEZsb3RpbGFGb25kRm9zZm9yRm90YmFsRm90a2FGb3RvbkZyYWtjZUZyZXNrYUZyb250YUZ1a2FyRnVua2NlRnl6aWthR2FsZWplR2FyYW50R2VuZXRpa2FHZW9sb2dHaWxvdGluYUdsYXp1cmFHbGVqdEdvbGVtR29sZmlzdGFHb3Rpa2FHcmFmR3JhbW9mb25HcmFudWxlR3JlcEdyaWxHcm9nR3JvdGVza2FHdW1hSGFkaWNlSGFkckhhbGFIYWxlbmthSGFuYmFIYW5vcGlzSGFyZmFIYXJwdW5hSGF2cmFuSGVia29zdEhlamthbEhlam5vSGVqdG1hbkhla3RhckhlbG1hSGVtYXRvbUhlcmVjSGVybmFIZXNsb0hlemt5SGlzdG9yaWtIbGFkb3ZrYUhsYXNpdmt5SGxhdmFIbGVkYXRIbGVuSGxvZGF2ZWNIbG9oSGxvdXBvc3RIbHRhdEhsdWJpbmFIbHVjaG90YUhtYXRIbW90YUhteXpIbmlzSG5vaml2b0hub3V0SG9ibGluYUhvYm9qSG9jaEhvZGlueUhvZGxhdEhvZG5vdGFIb2RvdmF0SG9qbm9zdEhva2VqSG9saW5rYUhvbGthSG9sdWJIb21vbGVIb25pdGJhSG9ub3JhY2VIb3JhbEhvcmRhSG9yaXpvbnRIb3Jrb0hvcmxpdmVjSG9ybW9uSG9ybmluYUhvcm9za29wSG9yc3R2b0hvc3BvZGFIb3N0aW5hSG90b3Zvc3RIb3ViYUhvdWZIb3VwYXRIb3Vza2FIb3ZvckhyYWRiYUhyYW5pY2VIcmF2b3N0SHJhemRhSHJib2xla0hyZGluYUhyZGxvSHJkb3N0SHJuZWtIcm9ia2FIcm9tYWRhSHJvdEhyb3VkYUhyb3plbkhyc3RrYUhydWJvc3RIcnl6YXRIdWJlbm9zdEh1Ym5vdXRIdWRiYUh1a290SHVtckh1c2l0YUh1c3RvdGFIdm96ZEh5Ym5vc3RIeWRyYW50SHlnaWVuYUh5bW5hSHlzdGVyaWtJZHlsa2FJaG5lZElrb25hSWx1emVJbXVuaXRhSW5mZWtjZUluZmxhY2VJbmthc29Jbm92YWNlSW5zcGVrY2VJbnRlcm5ldEludmFsaWRhSW52ZXN0b3JJbnplcmNlSXJvbmllSmFibGtvSmFjaHRhSmFob2RhSmFrbWlsZUpha29zdEphbG92ZWNKYW50YXJKYXJtYXJrSmFyb0phc2FuSmFzbm9KYXRrYUphdm9ySmF6eWtKZWRpbmVjSmVkbGVKZWRuYXRlbEplaGxhbkpla290SmVsZW5KZWxpdG9KZW1ub3N0SmVub21KZXBpY2VKZXNldGVySmV2aXRKZXpkZWNKZXplcm9KaW5ha0ppbmR5Smlub2NoSmlza3JhSmlzdG90YUppdHJuaWNlSml6dmFKbWVub3ZhdEpvZ3VydEp1cnRhS2FiYXJldEthYmVsS2FiaW5ldEthY2huYUthZGV0S2FkaWRsb0thaGFuS2FqYWtLYWp1dGFLYWthb0tha3R1c0thbGFtaXRhS2FsaG90eUthbGlickthbG5vc3RLYW1lcmFLYW1rb2xpdkthbW5hS2FuaWJhbEthbm9lS2FudG9yS2FwYWxpbmFLYXBlbGFLYXBpdG9sYUthcGthS2FwbGVLYXBvdGFLYXByS2FwdXN0YUthcHliYXJhS2FyYW1lbEthcm90a2FLYXJ0b25LYXNhS2F0YWxvZ0thdGVkcmFLYXVjZUthdXphS2F2YWxlY0themFqa2FLYXpldGFLYXppdm9zdEtkZWtvbGl2S2Rlc2lLZWRsdWJlbktlbXBLZXJhbWlrYUtpbm9LbGFjZWtLbGFkaXZvS2xhbUtsYXBvdEtsYXNpa2FLbGF1bktsZWNLbGVuYmFLbGVwYXRLbGVzbm91dEtsaWRLbGltYUtsaXNuYUtsb2JvdWtLbG9rYW5LbG9wYUtsb3ViS2x1Ym92bmFLbHVzYXRLbHV6a29zdEttZW5LbWl0YXRLbW90cktuaWhhS25vdEtvYWxpY2VLb2JlcmVjS29ia2FLb2JsaWhhS29ieWxhS29jb3VyS29ob3V0S29qZW5lY0tva29zS29rdGVqbEtvbGFwc0tvbGVkYUtvbGl6ZUtvbG9Lb21hbmRvS29tZXRhS29taWtLb21uYXRhS29tb3JhS29tcGFzS29tdW5pdGFLb25hdEtvbmNlcHRLb25kaWNlS29uZWNLb25mZXNlS29uZ3Jlc0tvbmluYUtvbmt1cnNLb250YWt0S29uemVydmFLb3BhbmVjS29waWVLb3Bub3V0S29wcm92a2FLb3JiZWxLb3Jla3Rvcktvcm1pZGxvS29yb3B0ZXZLb3JwdXNLb3J1bmFLb3J5dG9Lb3J6ZXRLb3NhdGVjS29zdGthS290ZWxLb3RsZXRhS290b3VsS291a2F0S291cGVsbmFLb3VzZWtLb3V6bG9Lb3Zib2pLb3phS296b3JvaEtyYWJpY2VLcmFjaEtyYWppbmFLcmFsb3ZhdEtyYXNvcGlzS3JhdmF0YUtyZWRpdEtyZWpjYXJLcmVzYmFLcmV2ZXRhS3Jpa2V0S3JpdGlrS3JpemVLcmthdmVjS3JtZWxlY0tybWl2b0tyb2Nhbktyb2tLcm9uaWthS3JvcGl0S3JvdXBhS3JvdmthS3J0ZWtLcnVoYWRsb0tydXBpY2VLcnV0b3N0S3J2aW5rYUtyeWNobGVLcnlwdGFLcnlzdGFsS3J5dEt1ZGxhbmthS3Vmckt1am5vc3RLdWtsYUt1bGFqZGFLdWxpY2hLdWxrYUt1bG9tZXRLdWx0dXJhS3VuYUt1cG9kaXZ1S3VydEt1cnpvckt1dGlsS3ZhbGl0YUt2YXNpbmthS3Zlc3Rvckt5bm9sb2dLeXNlbGluYUt5dGFyYUt5dGljZUt5dGthS3l0b3ZlY0t5dmFkbG9MYWJyYWRvckxhY2h0YW5MYWRub3N0TGFpa0xha29tZWNMYW1lbGFMYW1wYUxhbm92a2FMYXNpY2VMYXNvTGFzdHVyYUxhdGlua2FMYXZpbmFMZWJrYUxlY2tkeUxlZGVuTGVkbmljZUxlZG92a2FMZWR2aW5hTGVnZW5kYUxlZ2llTGVncmFjZUxlaGNlTGVoa29zdExlaG5vdXRMZWt0dmFyTGVub2Nob2RMZW50aWxrYUxlcGVua2FMZXBpZGxvTGV0YWRsb0xldGVjTGV0bW9MZXRva3J1aExldmhhcnRMZXZpdGFjZUxldm9ib2tMaWJyYUxpY2hvdGthTGlkb2plZExpZHNrb3N0TGlob3ZpbmFMaWphdmVjTGlsZWtMaW1ldGthTGluaWVMaW5rYUxpbm9sZXVtTGlzdG9wYWRMaXRpbmFMaXRvdmF0TG9iaXN0YUxvZGl2b2RMb2dpa2FMb2dvcGVkTG9rYWxpdGFMb2tldExvbWNvdmF0TG9wYXRhTG9wdWNoTG9yZExvc29zTG90ckxvdWRhbExvdWhMb3VrYUxvdXNrYXRMb3ZlY0xzdGl2b3N0THVjZXJuYUx1Y2lmZXJMdW1wTHVza0x1c3RyYWNlTHZpY2VMeXJhTHlyaWthTHlzaW5hTWFkYW1NYWRsb01hZ2lzdHJNYWhhZ29uTWFqZXRla01haml0ZWxNYWpvcml0YU1ha2FrTWFrb3ZpY2VNYWtyZWxhTWFsYmFNYWxpbmFNYWxvdmF0TWFsdmljZU1hbWlua2FNYW5kbGVNYW5rb01hcm5vc3RNYXNha3JNYXNrb3RNYXNvcHVzdE1hdGljZU1hdHJpa2FNYXR1cml0YU1hemFuZWNNYXppdm9NYXpsaXRNYXp1cmthTWRsb2JhTWVjaGFuaWtNZWRpdGFjZU1lZG92aW5hTWVsYXNhTWVsb3VuTWVudG9sa2FNZXRsYU1ldG9kYU1ldHJNZXplcmFNaWdyYWNlTWlobm91dE1paHVsZU1pa2luYU1pa3JvZm9uTWlsZW5lY01pbGltZXRyTWlsb3N0TWltaWthTWluY292bmFNaW5pYmFyTWlub21ldE1pbnVsb3N0TWlza2FNaXN0ck1peG92YXRNbGFkb3N0TWxoYU1saG92aW5hTWxva01sc2F0TWx1dml0TW5pY2hNbm9oZW1Nb2JpbE1vY25vc3RNb2RlbGthTW9kbGl0YmFNb2h5bGFNb2tyb01vbGVrdWxhTW9tZW50a2FNb25hcmNoYU1vbm9rbE1vbnN0cnVtTW9udG92YXRNb256dW5Nb3Nhek1vc2t5dE1vc3RNb3RpdmFjZU1vdG9ya2FNb3R5a2FNb3VjaGFNb3Vkcm9zdE1vemFpa2FNb3pla01vem9sTXJhbW9yTXJhdmVuZWNNcmtldk1ydHZvbGFNcnpldE1yenV0b3N0TXN0aXRlbE11ZHJjTXVmbG9uTXVsYXRNdW1pZU11bmljZU11c2V0TXV0YWNlTXV6ZXVtTXV6aWthbnRNeXNsaXZlY016ZGFOYWJvdXJhdE5hY2h5dGF0TmFkYWNlTmFkYnl0ZWtOYWRob3pOYWRvYnJvTmFkcGlzTmFobGFzTmFobmF0TmFob2RpbGVOYWhyYWRpdE5haXZpdGFOYWplZG5vdU5hamlzdG9OYWptb3V0TmFrbG9uaXROYWtvbmVjTmFrcm1pdE5hbGV2b05hbWF6YXROYW1sdXZpdE5hbm9tZXRyTmFva29OYW9wYWtOYW9zdHJvTmFwYWRhdE5hcGV2bm9OYXBsbml0TmFwbm91dE5hcG9zbGVkTmFwcm9zdG9OYXJvZGl0TmFydWJ5TmFyeWNobG9OYXNhZGl0TmFzZWthdE5hc2xlcG9OYXN0YXROYXRvbGlrTmF2ZW5la05hdnJjaE5hdnpkb3J5TmF6dmF0TmViZU5lY2hhdE5lY2t5TmVkYWxla29OZWRiYXROZWR1aE5lZ2FjZU5laGV0TmVob2RhTmVqZW5OZWpwcnZlTmVrbGlkTmVsaWJvc3ROZW1pbG9zdE5lbW9jTmVvY2hvdGFOZW9ua2FOZXBva29qTmVyb3N0TmVydk5lc215c2xOZXNvdWxhZE5ldHZvck5ldXJvbk5ldmluYU5lenZ5a2xlTmljb3RhTmlqYWtOaWthbU5pa2R5TmlrbE5pa3RlcmFrTml0cm9Ob2NsZWhOb2hhdmljZU5vbWluYWNlTm9yYU5vcmVrTm9zaXRlbE5vc25vc3ROb3V6ZU5vdmlueU5vdm90YU5vemRyYU51ZGFOdWRsZU51Z2V0TnV0aXROdXRub3N0TnV0cmllTnltZmFPYmFsT2JhcnZpdE9iYXZhT2JkaXZPYmVjT2JlaG5hdE9iZWptb3V0T2Jleml0YU9iaGFqb2JhT2JpbG5pY2VPYmphc25pdE9iamVrdE9ia2xvcGl0T2JsYXN0T2JsZWtPYmxpYmFPYmxvaGFPYmx1ZGFPYm5vc09ib2hhdGl0T2JvamVrT2JvdXRPYnJhemVjT2JybmFPYnJ1YmFPYnJ5c09ic2FoT2JzbHVoYU9ic3RhcmF0T2J1dk9idmF6T2J2aW5pdE9idm9kT2J2eWtsZU9ieXZhdGVsT2J6b3JPY2FzT2NlbE9jZW5pdE9jaGxhZGl0T2Nob3RhT2NocmFuYU9jaXRub3V0T2Rib2pPZGJ5dE9kY2hvZE9kY2l6aXRPZGVicmF0T2Rlc2xhdE9kZXZ6ZGF0T2RlenZhT2RoYWRjZU9kaG9kaXRPZGpldE9kamludWRPZGthek9ka291cGl0T2RsaXZPZGx1a2FPZG1sa2FPZG9sbm9zdE9kcGFkT2RwaXNPZHBsb3V0T2Rwb3JPZHB1c3RpdE9kcHlrYXRPZHJhemthT2Rzb3VkaXRPZHN0dXBPZHN1bk9kdG9rT2R0dWRPZHZhaGFPZHZldGFPZHZvbGF0T2R2cmFjZXRPZHpuYWtPZmluYU9mc2FqZE9obGFzT2huaXNrb09ocmFkYU9ocm96aXRPaHJ5emVrT2thcE9rZW5pY2VPa2xpa2FPa25vT2tvdXpsaXRPa292eU9rcmFzYU9rcmVzT2tyc2VrT2tydWhPa3VwYW50T2t1cmthT2t1c2l0T2xlam5pbmFPbGl6b3ZhdE9tYWtPbWVsZXRhT21leml0T21sYWRpbmFPbWxvdXZhdE9tbHV2YU9teWxPbmVoZHlPcGFrb3ZhdE9wYXNla09wZXJhY2VPcGljZU9waWxvc3RPcGlzb3ZhdE9wb3JhT3BvemljZU9wcmF2ZHVPcHJvdGlPcmJpdGFsT3JjaGVzdHJPcmdpZU9ybGljZU9ybG9qT3J0ZWxPc2FkYU9zY2hub3V0T3Npa2FPc2l2b09zbGF2YU9zbGVwaXRPc2xuaXRPc2xvdml0T3Nub3ZhT3NvYmFPc29saXRPc3BhbGVjT3N0ZW5Pc3RyYWhhT3N0dWRhT3N0eWNoT3N2b2ppdE90ZXBsaXRPdGlza090b3BPdHJoYXRPdHJsb3N0T3Ryb2tPdHJ1YnlPdHZvck92YW5vdXRPdmFyT3Zlc092bGl2bml0T3ZvY2VPeGlkT3pkb2JhUGFjaGF0ZWxQYWNpZW50UGFkb3VjaFBhaG9yZWtQYWt0UGFsYW5kYVBhbGVjUGFsaXZvUGFsdWJhUGFtZmxldFBhbWxzZWtQYW5lbmthUGFuaWthUGFubmFQYW5vdmF0UGFuc3R2b1BhbnRvZmxlUGFwcmlrYVBhcmtldGFQYXJvZGllUGFydGFQYXJ1a2FQYXJ5YmFQYXNla2FQYXNpdml0YVBhc3RlbGthUGF0ZW50UGF0cm9uYVBhdm91a1Bhem5laHRQYXpvdXJla1BlY2thUGVkYWdvZ1BlanNla1Bla2xvUGVsb3RvblBlbmFsdGFQZW5kcmVrUGVuemVQZXJpc2tvcFBlcm9QZXN0cm9zdFBldGFyZGFQZXRpY2VQZXRyb2xlalBldm5pbmFQZXhlc29QaWFuaXN0YVBpaGFQaWphdmljZVBpa2xlUGlrbmlrUGlsaW5hUGlsbm9zdFBpbHVsa2FQaW56ZXRhUGlwZXRhUGlzYXRlbFBpc3RvbGVQaXRldm5hUGl2bmljZVBpdm92YXJQbGFjZW50YVBsYWthdFBsYW1lblBsYW5ldGFQbGFzdGlrYVBsYXRpdFBsYXZpZGxvUGxhelBsZWNoUGxlbWVub1BsZW50YVBsZXNQbGV0aXZvUGxldmVsUGxpdmF0UGxuaXRQbG5vUGxvY2hhUGxvZGluYVBsb21iYVBsb3V0UGx1a1BseW5Qb2Jhdml0UG9ieXRQb2Nob2RQb2NpdFBvY3RpdmVjUG9kYXRQb2RjZW5pdFBvZGVwc2F0UG9kaGxlZFBvZGl2aXRQb2RrbGFkUG9kbWFuaXRQb2RuaWtQb2RvYmFQb2Rwb3JhUG9kcmF6UG9kc3RhdGFQb2R2b2RQb2R6aW1Qb2V6aWVQb2hhbmthUG9obnV0a2FQb2hvdm9yUG9ocm9tYVBvaHliUG9pbnRhUG9qaXN0a2FQb2ptb3V0UG9rYXppdFBva2xlc1Bva29qUG9rcm9rUG9rdXRhUG9reW5Qb2xlZG5lUG9saWJla1BvbGtub3V0UG9sb2hhUG9seW5vbVBvbWFsdVBvbWlub3V0UG9tbGthUG9tb2NQb21zdGFQb215c2xldFBvbmVjaGF0UG9ub3JrYVBvbnVyb3N0UG9wYWRhdFBvcGVsUG9waXNla1BvcGxhY2hQb3Byb3NpdFBvcHNhdFBvcHVkUG9yYWRjZVBvcmNlUG9yb2RQb3J1Y2hhUG9yeXZQb3NhZGl0UG9zZWRQb3NpbGFQb3Nrb2tQb3NsYW5lY1Bvc291ZGl0UG9zcG9sdVBvc3RhdmFQb3N1ZGVrUG9zeXBQb3RhaFBvdGthblBvdGxlc2tQb3RvbWVrUG90cmF2YVBvdHVwYVBvdHZvcmFQb3VrYXpQb3V0b1BvdXpkcm9Qb3ZhaGFQb3ZpZGxhUG92bGFrUG92b3pQb3ZyY2hQb3ZzdGF0UG92eWtQb3Z6ZGVjaFBvemRyYXZQb3plbWVrUG96bmF0ZWtQb3pvclBvenZhdFByYWNvdmF0UHJhaG9yeVByYWt0aWthUHJhbGVzUHJhb3RlY1ByYXBvcmVrUHJhc2VQcmF2ZGFQcmluY2lwUHJrbm9Qcm9idWRpdFByb2NlbnRvUHJvZGVqUHJvZmVzZVByb2hyYVByb2pla3RQcm9sb21pdFByb21pbGVQcm9uaWthdFByb3BhZFByb3Jva1Byb3NiYVByb3RvblByb3V0ZWtQcm92YXpQcnNrYXZrYVByc3RlblBydWRrb3N0UHJ1dFBydmVrUHJ2b2hvcnlQc2FuZWNQc292b2RQc3RydWhQdGFjdHZvUHViZXJ0YVB1Y2hQdWRsUHVrYXZlY1B1a2xpbmFQdWtybGVQdWx0UHVtcGFQdW5jUHVwZW5QdXNhUHVzaW5rYVB1c3RpbmFQdXRvdmF0UHV0eWthUHlyYW1pZGFQeXNrUHl0ZWxSYWNla1JhY2hvdFJhZGlhY2VSYWRuaWNlUmFkb25SYWZ0UmFnYnlSYWtldGFSYWtvdmluYVJhbWVub1JhbXBvdWNoUmFuZGVSYXJhY2hSYXJpdGFSYXNvdm5hUmFzdHJSYXRvbGVzdFJhemFuY2VSYXppZGxvUmVhZ292YXRSZWFrY2VSZWNlcHRSZWRha3RvclJlZmVyZW50UmVmbGV4UmVqbm9rUmVrbGFtYVJla29yZFJla3J1dFJla3RvclJlcHV0YWNlUmV2aXplUmV2bWFSZXZvbHZlclJlemVydmFSaXNrb3ZhdFJpemlrb1JvYm90aWthUm9kb2ttZW5Sb2hvdmthUm9rbGVSb2tva29Sb21hbmV0b1JvcG92b2RSb3B1Y2hhUm9yZWpzUm9zb2xSb3N0bGluYVJvdG1pc3RyUm90b3BlZFJvdHVuZGFSb3ViZW5rYVJvdWNob1JvdXBSb3VyYVJvdmluYVJvdm5pY2VSb3pib3JSb3pjaG9kUm96ZGF0Um96ZXpuYXRSb3pob2RjZVJvemlua2FSb3pqZXpkUm96a2F6Um96bG9oYVJvem1hclJvenBhZFJvenJ1Y2hSb3pzYWhSb3p0b2tSb3p1bVJvenZvZFJ1YnJpa2FSdWNoYWRsb1J1a2F2aWNlUnVrb3Bpc1J5YmFSeWJvbG92UnljaGxvc3RSeWRsb1J5cGFkbG9SeXRpbmFSeXpvc3RTYWRpc3RhU2FoYXRTYWtvU2FtZWNTYW1pemRhdFNhbW90YVNhbml0a2FTYXJkaW5rYVNhc2Fua2FTYXRlbGl0U2F6YmFTYXplbmljZVNib3JTY2hvdmF0U2VicmFua2FTZWNlc2VTZWRhZGxvU2VkaW1lbnRTZWRsb1NlaG5hdFNlam1vdXRTZWtlcmFTZWt0YVNla3VuZGFTZWt2b2plU2VtZW5vU2Vub1NlcnZpc1Nlc2FkaXRTZXNob3JhU2Vza29rU2VzbGF0U2VzdHJhU2VzdXZTZXN5cGF0U2V0YmFTZXRpbmFTZXRrYXRTZXRub3V0U2V0cnZhdFNldmVyU2V6bmFtU2hvZGFTaHJub3V0U2lmb25TaWxuaWNlU2lya2FTaXJvdGVrU2lydXBTaXR1YWNlU2thZmFuZHJTa2FsaXNrb1NrYW56ZW5Ta2F1dFNrZXB0aWtTa2ljYVNrbGFkYmFTa2xlbmljZVNrbG9Ta2x1elNrb2JhU2tva2FuU2tvcm9Ta3JpcHRhU2tyelNrdXBpbmFTa3Zvc3RTa3ZybmFTbGFiaWthU2xhZGlkbG9TbGFuaW5hU2xhc3RTbGF2bm9zdFNsZWRvdmF0U2xlcGVjU2xldmFTbGV6aW5hU2xpYlNsaW5hU2xpem5pY2VTbG9uU2xvdXBla1Nsb3ZvU2x1Y2hTbHVoYVNsdW5jZVNsdXBrYVNsemFTbWFyYWdkU21ldGFuYVNtaWxzdHZvU21sb3V2YVNtb2dTbXJhZFNtcmtTbXJ0a2FTbXV0ZWtTbXlzbFNuYWRTbmFoYVNub2JTb2JvdGFTb2NoYVNvZG92a2FTb2tvbFNvcGthU290dmFTb3Vib2pTb3VjaXRTb3VkY2VTb3VobGFzU291bGFkU291bXJha1NvdXByYXZhU291c2VkU291dG9rU291dmlzZXRTcGFsb3ZuYVNwYXNpdGVsU3Bpc1NwbGF2U3BvZGVrU3BvamVuZWNTcG9sdVNwb256b3JTcG9ybm9zdFNwb3VzdGFTcHJjaGFTcHVzdGl0U3JhbmRhU3JhelNyZGNlU3JuYVNybmVjU3Jvdm5hdFNycGVuU3JzdFNydWJTdGFuaWNlU3Rhcm9zdGFTdGF0aWthU3RhdmJhU3RlaG5vU3RlemthU3RvZG9sYVN0b2xla1N0b3BhU3Rvcm5vU3RvdXBhdFN0cmFjaFN0cmVzU3RyaG5vdXRTdHJvbVN0cnVuYVN0dWRuYVN0dXBuaWNlU3R2b2xTdHlrU3ViamVrdFN1YnRyb3B5U3VjaGFyU3Vkb3N0U3Vrbm9TdW5kYXRTdW5vdXRTdXJpa2F0YVN1cm92aW5hU3ZhaFN2YWxzdHZvU3ZldHJTdmF0YmFTdmF6ZWtTdmlzbGVTdml0ZWtTdm9ib2RhU3ZvZGlkbG9Tdm9ya2FTdnJhYlN5a2F2a2FTeWtvdFN5bmVrU3lub3ZlY1N5cGF0U3lwa29zdFN5cm92b3N0U3lzZWxTeXRvc3RUYWJsZXRrYVRhYnVsZVRhaG91blRhamVtbm9UYWpmdW5UYWpnYVRhaml0VGFqbm9zdFRha3Rpa2FUYW1obGVUYW1wb25UYW5jb3ZhdFRhbmVjVGFua2VyVGFwZXRhVGF2ZW5pbmFUYXphdGVsVGVjaG5pa2FUZWhkeVRla3V0aW5hVGVsZWZvblRlbW5vdGFUZW5kZW5jZVRlbmlzdGFUZW5vclRlcGxvdGFUZXBuYVRlcHJ2ZVRlcmFwaWVUZXJtb3NrYVRleHRpbFRpY2hvVGlza29waXNUaXR1bGVrVGthZGxlY1RrYW5pbmFUbGFwa2FUbGVza2F0VGx1a290VGx1cGFUbWVsVG9hbGV0YVRvcGlua2FUb3BvbFRvcnpvVG91aGFUb3VsZWNUcmFkaWNlVHJha3RvclRyYW1wVHJhc2FUcmF2ZXJ6YVRyZWZpdFRyZXN0VHJlem9yVHJoYXZpbmFUcmhsaW5hVHJvY2h1VHJvamljZVRyb3NrYVRyb3ViYVRycGNlVHJwaXRlbFRycGtvc3RUcnViZWNUcnVjaGxpdFRydWhsaWNlVHJ1c1RydmF0VHVkeVR1aG5vdXRUdWhvc3RUdW5kcmFUdXJpc3RhVHVybmFqVHV6ZW1za29UdmFyb2hUdm9yYmFUdnJkb3N0VHZyelR5Z3JUeWtldlVib2hvc3RVYm96ZVVicmF0VWJyb3VzZWtVYnJ1c1VieXRvdm5hVWNob1VjdGl2b3N0VWRpdml0VWhyYWRpdFVqZWRuYXRVamlzdGl0VWptb3V0VWthemF0ZWxVa2xpZG5pdFVrbG9uaXRVa290dml0VWtyb2ppdFVsaWNlVWxpdGFVbG92aXRVbXl2YWRsb1VuYXZpdFVuaWZvcm1hVW5pa25vdXRVcGFkbm91dFVwbGF0bml0VXBseW5vdXRVcG91dGF0VXByYXZpdFVyYW5VcmF6aXRVc2Vkbm91dFVzaWxvdmF0VXNtcnRpdFVzbmFkbml0VXNub3V0VXNvdWRpdFVzdGxhdFVzdHJub3V0VXRhaG92YXRVdGthdFV0bHVtaXRVdG9ub3V0VXRvcGVuZWNVdHJvdXNpdFV2YWxpdFV2b2xuaXRVdm96b3ZrYVV6ZHJhdml0VXplbFV6ZW5pbmFVemxpbmFVem5hdFZhZ29uVmFsY2hhVmFsb3VuVmFuYVZhbmRhbFZhbmlsa2FWYXJhblZhcmhhbnlWYXJvdmF0VmNlbGt1VmNob2RWZG92YVZlZHJvVmVnZXRhY2VWZWpjZVZlbGJsb3VkVmVsZXRyaFZlbGl0ZWxWZWxtb2NWZWxyeWJhVmVua292VmVyYW5kYVZlcnplVmVzZWxrYVZlc2tyemVWZXNuaWNlVmVzcG9kdVZlc3RhVmV0ZXJpbmFWZXZlcmthVmlicmFjZVZpY2hyVmlkZW9ocmFWaWRpbmFWaWRsZVZpbGFWaW5pY2VWaXNldFZpdGFsaXRhVml6ZVZpeml0a2FWamV6ZFZrbGFkVmt1c1ZsYWprYVZsYWtWbGFzZWNWbGV2b1ZsaGtvc3RWbGl2Vmxub3ZrYVZsb3VwYXRWbnVjb3ZhdFZudWtWb2RhVm9kaXZvc3RWb2Rvem5ha1ZvZHN0dm9Wb2plbnNreVZvam5hVm9qc2tvVm9sYW50Vm9sYmFWb2xpdFZvbG5vVm9za292a2FWb3ppZGxvVm96b3ZuYVZwcmF2b1ZyYWJlY1ZyYWNldFZyYWhWcmF0YVZyYmFWcmNob2xla1ZyaGF0VnJzdHZhVnJ0dWxlVnNhZGl0VnN0b3VwaXRWc3R1cFZ0aXBWeWJhdml0VnlicmF0VnljaG92YXRWeWRhdFZ5ZHJhVnlmb3RpdFZ5aGxlZGF0Vnlobm91dFZ5aG9kaXRWeWhyYWRpdFZ5aHViaXRWeWphc25pdFZ5amV0VnlqbW91dFZ5a2xvcGl0Vnlrb25hdFZ5bGVrYXRWeW1hemF0VnltZXppdFZ5bWl6ZXRWeW15c2xldFZ5bmVjaGF0VnluaWthdFZ5bnV0aXRWeXBhZGF0VnlwbGF0aXRWeXByYXZpdFZ5cHVzdGl0VnlyYXppdFZ5cm92bmF0VnlydmF0VnlzbG92aXRWeXNva29WeXN0YXZpdFZ5c3Vub3V0VnlzeXBhdFZ5dGFzaXRWeXRlc2F0Vnl0cmF0aXRWeXZpbm91dFZ5dm9sYXRWeXZyaGVsVnl6ZG9iaXRWeXpuYXRWemFkdVZ6YnVkaXRWemNob3BpdFZ6ZG9yVnpkdWNoVnpkeWNoYXRWemVzdHVwVnpobGVkZW1WemthelZ6bHlrYXRWem5pa1Z6b3Jla1Z6cG91cmFWenRhaFZ6dGVrWHlsb2ZvblphYnJhdFphYnlkbGV0WmFjaG92YXRaYWRhcm1vWmFkdXNpdFphZm91a2F0WmFobHRpdFphaG9kaXRaYWhyYWRhWmFoeW5vdXRaYWphdGVjWmFqZXRaYWppc3RpdFpha2xlcGF0WmFrb3VwaXRaYWxlcGl0WmFtZXppdFphbW90YXRaYW15c2xldFphbmVjaGF0WmFuaWthdFphcGxhdGl0WmFwb2ppdFphcHNhdFphcmF6aXRaYXN0YXZpdFphc3Vub3V0WmF0YWppdFphdGVtbml0WmF0a25vdXRaYXVqbW91dFphdmFsaXRaYXZlbGV0WmF2aW5pdFphdm9sYXRaYXZydGF0WmF6dm9uaXRaYmF2aXRaYnJ1c3VaYnVkb3ZhdFpieXRla1pkYWxla2FaZGFybWFaZGF0bm9zdFpkaXZvWmRvYml0WmRyb2paZHZpaFpkeW1hZGxvWmVsZW5pbmFaZW1hblplbWluYVplcHRhdFplemFkdVplemRvbGFaaGF0aXRaaGx0bm91dFpobHVib2thWmhvdG92aXRaaHJ1YmFaaW1hWmltbmljZVpqZW1uaXRaa2xhbWF0WmtvdW1hdFprcmF0a2Faa3VtYXZrYVpsYXRvWmxlaGthWmxvYmFabG9tWmxvc3RabG96dnlrWm1hcG92YXRabWFyWm1hdGVrWm1pamVabWl6ZXRabW9jbml0Wm1vZHJhdFptcnpsaW5hWm11dG92YXRabmFrWm5hbG9zdFpuYW1lbmF0Wm5vdnVab2JyYXppdFpvdGF2aXRab3ViZWtab3VmYWxlWnBsb2RpdFpwb21hbGl0WnByYXZhWnByb3N0aXRacHJ1ZGthWnBydnVacmFkYVpyYW5pdFpyY2FkbG9acm5pdG9zdFpybm9acm92bmFacnljaGxpdFpyemF2b3N0WnRpY2hhWnRyYXRpdFp1Ym92aW5hWnViclp2ZWRub3V0WnZlbmt1WnZlc2VsYVp2b25adnJhdFp2dWtvdm9kWnZ5a1wiO2xldCB3b3JkbGlzdD1udWxsO2Z1bmN0aW9uIGxvYWRXb3JkcyhsYW5nKXtpZih3b3JkbGlzdCE9bnVsbCl7cmV0dXJufXdvcmRsaXN0PXdvcmRzLnJlcGxhY2UoLyhbQS1aXSkvZyxcIiAkMVwiKS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygxKS5zcGxpdChcIiBcIik7aWYoV29yZGxpc3QuY2hlY2sobGFuZykhPT1cIjB4MjVmNDQ1NTVmNGFmMjViNTFhNzExMTM2ZTFjN2Q2ZTUwY2U5Zjg5MTdkMzlkNmIxZjA3NmIyYmI0ZDJmYWMxYVwiKXt3b3JkbGlzdD1udWxsO3Rocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBlbiAoRW5nbGlzaCkgRkFJTEVEXCIpfX1jbGFzcyBMYW5nQ3ogZXh0ZW5kcyBXb3JkbGlzdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiY3pcIil9Z2V0V29yZChpbmRleCl7bG9hZFdvcmRzKHRoaXMpO3JldHVybiB3b3JkbGlzdFtpbmRleF19Z2V0V29yZEluZGV4KHdvcmQpe2xvYWRXb3Jkcyh0aGlzKTtyZXR1cm4gd29yZGxpc3QuaW5kZXhPZih3b3JkKX19Y29uc3QgbGFuZ0N6PW5ldyBMYW5nQ3o7V29yZGxpc3QucmVnaXN0ZXIobGFuZ0N6KTtcInVzZSBzdHJpY3RcIjtjb25zdCB3b3JkcyQxPVwiQWJhbmRvbkFiaWxpdHlBYmxlQWJvdXRBYm92ZUFic2VudEFic29yYkFic3RyYWN0QWJzdXJkQWJ1c2VBY2Nlc3NBY2NpZGVudEFjY291bnRBY2N1c2VBY2hpZXZlQWNpZEFjb3VzdGljQWNxdWlyZUFjcm9zc0FjdEFjdGlvbkFjdG9yQWN0cmVzc0FjdHVhbEFkYXB0QWRkQWRkaWN0QWRkcmVzc0FkanVzdEFkbWl0QWR1bHRBZHZhbmNlQWR2aWNlQWVyb2JpY0FmZmFpckFmZm9yZEFmcmFpZEFnYWluQWdlQWdlbnRBZ3JlZUFoZWFkQWltQWlyQWlycG9ydEFpc2xlQWxhcm1BbGJ1bUFsY29ob2xBbGVydEFsaWVuQWxsQWxsZXlBbGxvd0FsbW9zdEFsb25lQWxwaGFBbHJlYWR5QWxzb0FsdGVyQWx3YXlzQW1hdGV1ckFtYXppbmdBbW9uZ0Ftb3VudEFtdXNlZEFuYWx5c3RBbmNob3JBbmNpZW50QW5nZXJBbmdsZUFuZ3J5QW5pbWFsQW5rbGVBbm5vdW5jZUFubnVhbEFub3RoZXJBbnN3ZXJBbnRlbm5hQW50aXF1ZUFueGlldHlBbnlBcGFydEFwb2xvZ3lBcHBlYXJBcHBsZUFwcHJvdmVBcHJpbEFyY2hBcmN0aWNBcmVhQXJlbmFBcmd1ZUFybUFybWVkQXJtb3JBcm15QXJvdW5kQXJyYW5nZUFycmVzdEFycml2ZUFycm93QXJ0QXJ0ZWZhY3RBcnRpc3RBcnR3b3JrQXNrQXNwZWN0QXNzYXVsdEFzc2V0QXNzaXN0QXNzdW1lQXN0aG1hQXRobGV0ZUF0b21BdHRhY2tBdHRlbmRBdHRpdHVkZUF0dHJhY3RBdWN0aW9uQXVkaXRBdWd1c3RBdW50QXV0aG9yQXV0b0F1dHVtbkF2ZXJhZ2VBdm9jYWRvQXZvaWRBd2FrZUF3YXJlQXdheUF3ZXNvbWVBd2Z1bEF3a3dhcmRBeGlzQmFieUJhY2hlbG9yQmFjb25CYWRnZUJhZ0JhbGFuY2VCYWxjb255QmFsbEJhbWJvb0JhbmFuYUJhbm5lckJhckJhcmVseUJhcmdhaW5CYXJyZWxCYXNlQmFzaWNCYXNrZXRCYXR0bGVCZWFjaEJlYW5CZWF1dHlCZWNhdXNlQmVjb21lQmVlZkJlZm9yZUJlZ2luQmVoYXZlQmVoaW5kQmVsaWV2ZUJlbG93QmVsdEJlbmNoQmVuZWZpdEJlc3RCZXRyYXlCZXR0ZXJCZXR3ZWVuQmV5b25kQmljeWNsZUJpZEJpa2VCaW5kQmlvbG9neUJpcmRCaXJ0aEJpdHRlckJsYWNrQmxhZGVCbGFtZUJsYW5rZXRCbGFzdEJsZWFrQmxlc3NCbGluZEJsb29kQmxvc3NvbUJsb3VzZUJsdWVCbHVyQmx1c2hCb2FyZEJvYXRCb2R5Qm9pbEJvbWJCb25lQm9udXNCb29rQm9vc3RCb3JkZXJCb3JpbmdCb3Jyb3dCb3NzQm90dG9tQm91bmNlQm94Qm95QnJhY2tldEJyYWluQnJhbmRCcmFzc0JyYXZlQnJlYWRCcmVlemVCcmlja0JyaWRnZUJyaWVmQnJpZ2h0QnJpbmdCcmlza0Jyb2Njb2xpQnJva2VuQnJvbnplQnJvb21Ccm90aGVyQnJvd25CcnVzaEJ1YmJsZUJ1ZGR5QnVkZ2V0QnVmZmFsb0J1aWxkQnVsYkJ1bGtCdWxsZXRCdW5kbGVCdW5rZXJCdXJkZW5CdXJnZXJCdXJzdEJ1c0J1c2luZXNzQnVzeUJ1dHRlckJ1eWVyQnV6ekNhYmJhZ2VDYWJpbkNhYmxlQ2FjdHVzQ2FnZUNha2VDYWxsQ2FsbUNhbWVyYUNhbXBDYW5DYW5hbENhbmNlbENhbmR5Q2Fubm9uQ2Fub2VDYW52YXNDYW55b25DYXBhYmxlQ2FwaXRhbENhcHRhaW5DYXJDYXJib25DYXJkQ2FyZ29DYXJwZXRDYXJyeUNhcnRDYXNlQ2FzaENhc2lub0Nhc3RsZUNhc3VhbENhdENhdGFsb2dDYXRjaENhdGVnb3J5Q2F0dGxlQ2F1Z2h0Q2F1c2VDYXV0aW9uQ2F2ZUNlaWxpbmdDZWxlcnlDZW1lbnRDZW5zdXNDZW50dXJ5Q2VyZWFsQ2VydGFpbkNoYWlyQ2hhbGtDaGFtcGlvbkNoYW5nZUNoYW9zQ2hhcHRlckNoYXJnZUNoYXNlQ2hhdENoZWFwQ2hlY2tDaGVlc2VDaGVmQ2hlcnJ5Q2hlc3RDaGlja2VuQ2hpZWZDaGlsZENoaW1uZXlDaG9pY2VDaG9vc2VDaHJvbmljQ2h1Y2tsZUNodW5rQ2h1cm5DaWdhckNpbm5hbW9uQ2lyY2xlQ2l0aXplbkNpdHlDaXZpbENsYWltQ2xhcENsYXJpZnlDbGF3Q2xheUNsZWFuQ2xlcmtDbGV2ZXJDbGlja0NsaWVudENsaWZmQ2xpbWJDbGluaWNDbGlwQ2xvY2tDbG9nQ2xvc2VDbG90aENsb3VkQ2xvd25DbHViQ2x1bXBDbHVzdGVyQ2x1dGNoQ29hY2hDb2FzdENvY29udXRDb2RlQ29mZmVlQ29pbENvaW5Db2xsZWN0Q29sb3JDb2x1bW5Db21iaW5lQ29tZUNvbWZvcnRDb21pY0NvbW1vbkNvbXBhbnlDb25jZXJ0Q29uZHVjdENvbmZpcm1Db25ncmVzc0Nvbm5lY3RDb25zaWRlckNvbnRyb2xDb252aW5jZUNvb2tDb29sQ29wcGVyQ29weUNvcmFsQ29yZUNvcm5Db3JyZWN0Q29zdENvdHRvbkNvdWNoQ291bnRyeUNvdXBsZUNvdXJzZUNvdXNpbkNvdmVyQ295b3RlQ3JhY2tDcmFkbGVDcmFmdENyYW1DcmFuZUNyYXNoQ3JhdGVyQ3Jhd2xDcmF6eUNyZWFtQ3JlZGl0Q3JlZWtDcmV3Q3JpY2tldENyaW1lQ3Jpc3BDcml0aWNDcm9wQ3Jvc3NDcm91Y2hDcm93ZENydWNpYWxDcnVlbENydWlzZUNydW1ibGVDcnVuY2hDcnVzaENyeUNyeXN0YWxDdWJlQ3VsdHVyZUN1cEN1cGJvYXJkQ3VyaW91c0N1cnJlbnRDdXJ0YWluQ3VydmVDdXNoaW9uQ3VzdG9tQ3V0ZUN5Y2xlRGFkRGFtYWdlRGFtcERhbmNlRGFuZ2VyRGFyaW5nRGFzaERhdWdodGVyRGF3bkRheURlYWxEZWJhdGVEZWJyaXNEZWNhZGVEZWNlbWJlckRlY2lkZURlY2xpbmVEZWNvcmF0ZURlY3JlYXNlRGVlckRlZmVuc2VEZWZpbmVEZWZ5RGVncmVlRGVsYXlEZWxpdmVyRGVtYW5kRGVtaXNlRGVuaWFsRGVudGlzdERlbnlEZXBhcnREZXBlbmREZXBvc2l0RGVwdGhEZXB1dHlEZXJpdmVEZXNjcmliZURlc2VydERlc2lnbkRlc2tEZXNwYWlyRGVzdHJveURldGFpbERldGVjdERldmVsb3BEZXZpY2VEZXZvdGVEaWFncmFtRGlhbERpYW1vbmREaWFyeURpY2VEaWVzZWxEaWV0RGlmZmVyRGlnaXRhbERpZ25pdHlEaWxlbW1hRGlubmVyRGlub3NhdXJEaXJlY3REaXJ0RGlzYWdyZWVEaXNjb3ZlckRpc2Vhc2VEaXNoRGlzbWlzc0Rpc29yZGVyRGlzcGxheURpc3RhbmNlRGl2ZXJ0RGl2aWRlRGl2b3JjZURpenp5RG9jdG9yRG9jdW1lbnREb2dEb2xsRG9scGhpbkRvbWFpbkRvbmF0ZURvbmtleURvbm9yRG9vckRvc2VEb3VibGVEb3ZlRHJhZnREcmFnb25EcmFtYURyYXN0aWNEcmF3RHJlYW1EcmVzc0RyaWZ0RHJpbGxEcmlua0RyaXBEcml2ZURyb3BEcnVtRHJ5RHVja0R1bWJEdW5lRHVyaW5nRHVzdER1dGNoRHV0eUR3YXJmRHluYW1pY0VhZ2VyRWFnbGVFYXJseUVhcm5FYXJ0aEVhc2lseUVhc3RFYXN5RWNob0Vjb2xvZ3lFY29ub215RWRnZUVkaXRFZHVjYXRlRWZmb3J0RWdnRWlnaHRFaXRoZXJFbGJvd0VsZGVyRWxlY3RyaWNFbGVnYW50RWxlbWVudEVsZXBoYW50RWxldmF0b3JFbGl0ZUVsc2VFbWJhcmtFbWJvZHlFbWJyYWNlRW1lcmdlRW1vdGlvbkVtcGxveUVtcG93ZXJFbXB0eUVuYWJsZUVuYWN0RW5kRW5kbGVzc0VuZG9yc2VFbmVteUVuZXJneUVuZm9yY2VFbmdhZ2VFbmdpbmVFbmhhbmNlRW5qb3lFbmxpc3RFbm91Z2hFbnJpY2hFbnJvbGxFbnN1cmVFbnRlckVudGlyZUVudHJ5RW52ZWxvcGVFcGlzb2RlRXF1YWxFcXVpcEVyYUVyYXNlRXJvZGVFcm9zaW9uRXJyb3JFcnVwdEVzY2FwZUVzc2F5RXNzZW5jZUVzdGF0ZUV0ZXJuYWxFdGhpY3NFdmlkZW5jZUV2aWxFdm9rZUV2b2x2ZUV4YWN0RXhhbXBsZUV4Y2Vzc0V4Y2hhbmdlRXhjaXRlRXhjbHVkZUV4Y3VzZUV4ZWN1dGVFeGVyY2lzZUV4aGF1c3RFeGhpYml0RXhpbGVFeGlzdEV4aXRFeG90aWNFeHBhbmRFeHBlY3RFeHBpcmVFeHBsYWluRXhwb3NlRXhwcmVzc0V4dGVuZEV4dHJhRXllRXllYnJvd0ZhYnJpY0ZhY2VGYWN1bHR5RmFkZUZhaW50RmFpdGhGYWxsRmFsc2VGYW1lRmFtaWx5RmFtb3VzRmFuRmFuY3lGYW50YXN5RmFybUZhc2hpb25GYXRGYXRhbEZhdGhlckZhdGlndWVGYXVsdEZhdm9yaXRlRmVhdHVyZUZlYnJ1YXJ5RmVkZXJhbEZlZUZlZWRGZWVsRmVtYWxlRmVuY2VGZXN0aXZhbEZldGNoRmV2ZXJGZXdGaWJlckZpY3Rpb25GaWVsZEZpZ3VyZUZpbGVGaWxtRmlsdGVyRmluYWxGaW5kRmluZUZpbmdlckZpbmlzaEZpcmVGaXJtRmlyc3RGaXNjYWxGaXNoRml0Rml0bmVzc0ZpeEZsYWdGbGFtZUZsYXNoRmxhdEZsYXZvckZsZWVGbGlnaHRGbGlwRmxvYXRGbG9ja0Zsb29yRmxvd2VyRmx1aWRGbHVzaEZseUZvYW1Gb2N1c0ZvZ0ZvaWxGb2xkRm9sbG93Rm9vZEZvb3RGb3JjZUZvcmVzdEZvcmdldEZvcmtGb3J0dW5lRm9ydW1Gb3J3YXJkRm9zc2lsRm9zdGVyRm91bmRGb3hGcmFnaWxlRnJhbWVGcmVxdWVudEZyZXNoRnJpZW5kRnJpbmdlRnJvZ0Zyb250RnJvc3RGcm93bkZyb3plbkZydWl0RnVlbEZ1bkZ1bm55RnVybmFjZUZ1cnlGdXR1cmVHYWRnZXRHYWluR2FsYXh5R2FsbGVyeUdhbWVHYXBHYXJhZ2VHYXJiYWdlR2FyZGVuR2FybGljR2FybWVudEdhc0dhc3BHYXRlR2F0aGVyR2F1Z2VHYXplR2VuZXJhbEdlbml1c0dlbnJlR2VudGxlR2VudWluZUdlc3R1cmVHaG9zdEdpYW50R2lmdEdpZ2dsZUdpbmdlckdpcmFmZmVHaXJsR2l2ZUdsYWRHbGFuY2VHbGFyZUdsYXNzR2xpZGVHbGltcHNlR2xvYmVHbG9vbUdsb3J5R2xvdmVHbG93R2x1ZUdvYXRHb2RkZXNzR29sZEdvb2RHb29zZUdvcmlsbGFHb3NwZWxHb3NzaXBHb3Zlcm5Hb3duR3JhYkdyYWNlR3JhaW5HcmFudEdyYXBlR3Jhc3NHcmF2aXR5R3JlYXRHcmVlbkdyaWRHcmllZkdyaXRHcm9jZXJ5R3JvdXBHcm93R3J1bnRHdWFyZEd1ZXNzR3VpZGVHdWlsdEd1aXRhckd1bkd5bUhhYml0SGFpckhhbGZIYW1tZXJIYW1zdGVySGFuZEhhcHB5SGFyYm9ySGFyZEhhcnNoSGFydmVzdEhhdEhhdmVIYXdrSGF6YXJkSGVhZEhlYWx0aEhlYXJ0SGVhdnlIZWRnZWhvZ0hlaWdodEhlbGxvSGVsbWV0SGVscEhlbkhlcm9IaWRkZW5IaWdoSGlsbEhpbnRIaXBIaXJlSGlzdG9yeUhvYmJ5SG9ja2V5SG9sZEhvbGVIb2xpZGF5SG9sbG93SG9tZUhvbmV5SG9vZEhvcGVIb3JuSG9ycm9ySG9yc2VIb3NwaXRhbEhvc3RIb3RlbEhvdXJIb3Zlckh1Ykh1Z2VIdW1hbkh1bWJsZUh1bW9ySHVuZHJlZEh1bmdyeUh1bnRIdXJkbGVIdXJyeUh1cnRIdXNiYW5kSHlicmlkSWNlSWNvbklkZWFJZGVudGlmeUlkbGVJZ25vcmVJbGxJbGxlZ2FsSWxsbmVzc0ltYWdlSW1pdGF0ZUltbWVuc2VJbW11bmVJbXBhY3RJbXBvc2VJbXByb3ZlSW1wdWxzZUluY2hJbmNsdWRlSW5jb21lSW5jcmVhc2VJbmRleEluZGljYXRlSW5kb29ySW5kdXN0cnlJbmZhbnRJbmZsaWN0SW5mb3JtSW5oYWxlSW5oZXJpdEluaXRpYWxJbmplY3RJbmp1cnlJbm1hdGVJbm5lcklubm9jZW50SW5wdXRJbnF1aXJ5SW5zYW5lSW5zZWN0SW5zaWRlSW5zcGlyZUluc3RhbGxJbnRhY3RJbnRlcmVzdEludG9JbnZlc3RJbnZpdGVJbnZvbHZlSXJvbklzbGFuZElzb2xhdGVJc3N1ZUl0ZW1Jdm9yeUphY2tldEphZ3VhckphckphenpKZWFsb3VzSmVhbnNKZWxseUpld2VsSm9iSm9pbkpva2VKb3VybmV5Sm95SnVkZ2VKdWljZUp1bXBKdW5nbGVKdW5pb3JKdW5rSnVzdEthbmdhcm9vS2VlbktlZXBLZXRjaHVwS2V5S2lja0tpZEtpZG5leUtpbmRLaW5nZG9tS2lzc0tpdEtpdGNoZW5LaXRlS2l0dGVuS2l3aUtuZWVLbmlmZUtub2NrS25vd0xhYkxhYmVsTGFib3JMYWRkZXJMYWR5TGFrZUxhbXBMYW5ndWFnZUxhcHRvcExhcmdlTGF0ZXJMYXRpbkxhdWdoTGF1bmRyeUxhdmFMYXdMYXduTGF3c3VpdExheWVyTGF6eUxlYWRlckxlYWZMZWFybkxlYXZlTGVjdHVyZUxlZnRMZWdMZWdhbExlZ2VuZExlaXN1cmVMZW1vbkxlbmRMZW5ndGhMZW5zTGVvcGFyZExlc3NvbkxldHRlckxldmVsTGlhckxpYmVydHlMaWJyYXJ5TGljZW5zZUxpZmVMaWZ0TGlnaHRMaWtlTGltYkxpbWl0TGlua0xpb25MaXF1aWRMaXN0TGl0dGxlTGl2ZUxpemFyZExvYWRMb2FuTG9ic3RlckxvY2FsTG9ja0xvZ2ljTG9uZWx5TG9uZ0xvb3BMb3R0ZXJ5TG91ZExvdW5nZUxvdmVMb3lhbEx1Y2t5THVnZ2FnZUx1bWJlckx1bmFyTHVuY2hMdXh1cnlMeXJpY3NNYWNoaW5lTWFkTWFnaWNNYWduZXRNYWlkTWFpbE1haW5NYWpvck1ha2VNYW1tYWxNYW5NYW5hZ2VNYW5kYXRlTWFuZ29NYW5zaW9uTWFudWFsTWFwbGVNYXJibGVNYXJjaE1hcmdpbk1hcmluZU1hcmtldE1hcnJpYWdlTWFza01hc3NNYXN0ZXJNYXRjaE1hdGVyaWFsTWF0aE1hdHJpeE1hdHRlck1heGltdW1NYXplTWVhZG93TWVhbk1lYXN1cmVNZWF0TWVjaGFuaWNNZWRhbE1lZGlhTWVsb2R5TWVsdE1lbWJlck1lbW9yeU1lbnRpb25NZW51TWVyY3lNZXJnZU1lcml0TWVycnlNZXNoTWVzc2FnZU1ldGFsTWV0aG9kTWlkZGxlTWlkbmlnaHRNaWxrTWlsbGlvbk1pbWljTWluZE1pbmltdW1NaW5vck1pbnV0ZU1pcmFjbGVNaXJyb3JNaXNlcnlNaXNzTWlzdGFrZU1peE1peGVkTWl4dHVyZU1vYmlsZU1vZGVsTW9kaWZ5TW9tTW9tZW50TW9uaXRvck1vbmtleU1vbnN0ZXJNb250aE1vb25Nb3JhbE1vcmVNb3JuaW5nTW9zcXVpdG9Nb3RoZXJNb3Rpb25Nb3Rvck1vdW50YWluTW91c2VNb3ZlTW92aWVNdWNoTXVmZmluTXVsZU11bHRpcGx5TXVzY2xlTXVzZXVtTXVzaHJvb21NdXNpY011c3RNdXR1YWxNeXNlbGZNeXN0ZXJ5TXl0aE5haXZlTmFtZU5hcGtpbk5hcnJvd05hc3R5TmF0aW9uTmF0dXJlTmVhck5lY2tOZWVkTmVnYXRpdmVOZWdsZWN0TmVpdGhlck5lcGhld05lcnZlTmVzdE5ldE5ldHdvcmtOZXV0cmFsTmV2ZXJOZXdzTmV4dE5pY2VOaWdodE5vYmxlTm9pc2VOb21pbmVlTm9vZGxlTm9ybWFsTm9ydGhOb3NlTm90YWJsZU5vdGVOb3RoaW5nTm90aWNlTm92ZWxOb3dOdWNsZWFyTnVtYmVyTnVyc2VOdXRPYWtPYmV5T2JqZWN0T2JsaWdlT2JzY3VyZU9ic2VydmVPYnRhaW5PYnZpb3VzT2NjdXJPY2Vhbk9jdG9iZXJPZG9yT2ZmT2ZmZXJPZmZpY2VPZnRlbk9pbE9rYXlPbGRPbGl2ZU9seW1waWNPbWl0T25jZU9uZU9uaW9uT25saW5lT25seU9wZW5PcGVyYU9waW5pb25PcHBvc2VPcHRpb25PcmFuZ2VPcmJpdE9yY2hhcmRPcmRlck9yZGluYXJ5T3JnYW5PcmllbnRPcmlnaW5hbE9ycGhhbk9zdHJpY2hPdGhlck91dGRvb3JPdXRlck91dHB1dE91dHNpZGVPdmFsT3Zlbk92ZXJPd25Pd25lck94eWdlbk95c3Rlck96b25lUGFjdFBhZGRsZVBhZ2VQYWlyUGFsYWNlUGFsbVBhbmRhUGFuZWxQYW5pY1BhbnRoZXJQYXBlclBhcmFkZVBhcmVudFBhcmtQYXJyb3RQYXJ0eVBhc3NQYXRjaFBhdGhQYXRpZW50UGF0cm9sUGF0dGVyblBhdXNlUGF2ZVBheW1lbnRQZWFjZVBlYW51dFBlYXJQZWFzYW50UGVsaWNhblBlblBlbmFsdHlQZW5jaWxQZW9wbGVQZXBwZXJQZXJmZWN0UGVybWl0UGVyc29uUGV0UGhvbmVQaG90b1BocmFzZVBoeXNpY2FsUGlhbm9QaWNuaWNQaWN0dXJlUGllY2VQaWdQaWdlb25QaWxsUGlsb3RQaW5rUGlvbmVlclBpcGVQaXN0b2xQaXRjaFBpenphUGxhY2VQbGFuZXRQbGFzdGljUGxhdGVQbGF5UGxlYXNlUGxlZGdlUGx1Y2tQbHVnUGx1bmdlUG9lbVBvZXRQb2ludFBvbGFyUG9sZVBvbGljZVBvbmRQb255UG9vbFBvcHVsYXJQb3J0aW9uUG9zaXRpb25Qb3NzaWJsZVBvc3RQb3RhdG9Qb3R0ZXJ5UG92ZXJ0eVBvd2RlclBvd2VyUHJhY3RpY2VQcmFpc2VQcmVkaWN0UHJlZmVyUHJlcGFyZVByZXNlbnRQcmV0dHlQcmV2ZW50UHJpY2VQcmlkZVByaW1hcnlQcmludFByaW9yaXR5UHJpc29uUHJpdmF0ZVByaXplUHJvYmxlbVByb2Nlc3NQcm9kdWNlUHJvZml0UHJvZ3JhbVByb2plY3RQcm9tb3RlUHJvb2ZQcm9wZXJ0eVByb3NwZXJQcm90ZWN0UHJvdWRQcm92aWRlUHVibGljUHVkZGluZ1B1bGxQdWxwUHVsc2VQdW1wa2luUHVuY2hQdXBpbFB1cHB5UHVyY2hhc2VQdXJpdHlQdXJwb3NlUHVyc2VQdXNoUHV0UHV6emxlUHlyYW1pZFF1YWxpdHlRdWFudHVtUXVhcnRlclF1ZXN0aW9uUXVpY2tRdWl0UXVpelF1b3RlUmFiYml0UmFjY29vblJhY2VSYWNrUmFkYXJSYWRpb1JhaWxSYWluUmFpc2VSYWxseVJhbXBSYW5jaFJhbmRvbVJhbmdlUmFwaWRSYXJlUmF0ZVJhdGhlclJhdmVuUmF3UmF6b3JSZWFkeVJlYWxSZWFzb25SZWJlbFJlYnVpbGRSZWNhbGxSZWNlaXZlUmVjaXBlUmVjb3JkUmVjeWNsZVJlZHVjZVJlZmxlY3RSZWZvcm1SZWZ1c2VSZWdpb25SZWdyZXRSZWd1bGFyUmVqZWN0UmVsYXhSZWxlYXNlUmVsaWVmUmVseVJlbWFpblJlbWVtYmVyUmVtaW5kUmVtb3ZlUmVuZGVyUmVuZXdSZW50UmVvcGVuUmVwYWlyUmVwZWF0UmVwbGFjZVJlcG9ydFJlcXVpcmVSZXNjdWVSZXNlbWJsZVJlc2lzdFJlc291cmNlUmVzcG9uc2VSZXN1bHRSZXRpcmVSZXRyZWF0UmV0dXJuUmV1bmlvblJldmVhbFJldmlld1Jld2FyZFJoeXRobVJpYlJpYmJvblJpY2VSaWNoUmlkZVJpZGdlUmlmbGVSaWdodFJpZ2lkUmluZ1Jpb3RSaXBwbGVSaXNrUml0dWFsUml2YWxSaXZlclJvYWRSb2FzdFJvYm90Um9idXN0Um9ja2V0Um9tYW5jZVJvb2ZSb29raWVSb29tUm9zZVJvdGF0ZVJvdWdoUm91bmRSb3V0ZVJveWFsUnViYmVyUnVkZVJ1Z1J1bGVSdW5SdW53YXlSdXJhbFNhZFNhZGRsZVNhZG5lc3NTYWZlU2FpbFNhbGFkU2FsbW9uU2Fsb25TYWx0U2FsdXRlU2FtZVNhbXBsZVNhbmRTYXRpc2Z5U2F0b3NoaVNhdWNlU2F1c2FnZVNhdmVTYXlTY2FsZVNjYW5TY2FyZVNjYXR0ZXJTY2VuZVNjaGVtZVNjaG9vbFNjaWVuY2VTY2lzc29yc1Njb3JwaW9uU2NvdXRTY3JhcFNjcmVlblNjcmlwdFNjcnViU2VhU2VhcmNoU2Vhc29uU2VhdFNlY29uZFNlY3JldFNlY3Rpb25TZWN1cml0eVNlZWRTZWVrU2VnbWVudFNlbGVjdFNlbGxTZW1pbmFyU2VuaW9yU2Vuc2VTZW50ZW5jZVNlcmllc1NlcnZpY2VTZXNzaW9uU2V0dGxlU2V0dXBTZXZlblNoYWRvd1NoYWZ0U2hhbGxvd1NoYXJlU2hlZFNoZWxsU2hlcmlmZlNoaWVsZFNoaWZ0U2hpbmVTaGlwU2hpdmVyU2hvY2tTaG9lU2hvb3RTaG9wU2hvcnRTaG91bGRlclNob3ZlU2hyaW1wU2hydWdTaHVmZmxlU2h5U2libGluZ1NpY2tTaWRlU2llZ2VTaWdodFNpZ25TaWxlbnRTaWxrU2lsbHlTaWx2ZXJTaW1pbGFyU2ltcGxlU2luY2VTaW5nU2lyZW5TaXN0ZXJTaXR1YXRlU2l4U2l6ZVNrYXRlU2tldGNoU2tpU2tpbGxTa2luU2tpcnRTa3VsbFNsYWJTbGFtU2xlZXBTbGVuZGVyU2xpY2VTbGlkZVNsaWdodFNsaW1TbG9nYW5TbG90U2xvd1NsdXNoU21hbGxTbWFydFNtaWxlU21va2VTbW9vdGhTbmFja1NuYWtlU25hcFNuaWZmU25vd1NvYXBTb2NjZXJTb2NpYWxTb2NrU29kYVNvZnRTb2xhclNvbGRpZXJTb2xpZFNvbHV0aW9uU29sdmVTb21lb25lU29uZ1Nvb25Tb3JyeVNvcnRTb3VsU291bmRTb3VwU291cmNlU291dGhTcGFjZVNwYXJlU3BhdGlhbFNwYXduU3BlYWtTcGVjaWFsU3BlZWRTcGVsbFNwZW5kU3BoZXJlU3BpY2VTcGlkZXJTcGlrZVNwaW5TcGlyaXRTcGxpdFNwb2lsU3BvbnNvclNwb29uU3BvcnRTcG90U3ByYXlTcHJlYWRTcHJpbmdTcHlTcXVhcmVTcXVlZXplU3F1aXJyZWxTdGFibGVTdGFkaXVtU3RhZmZTdGFnZVN0YWlyc1N0YW1wU3RhbmRTdGFydFN0YXRlU3RheVN0ZWFrU3RlZWxTdGVtU3RlcFN0ZXJlb1N0aWNrU3RpbGxTdGluZ1N0b2NrU3RvbWFjaFN0b25lU3Rvb2xTdG9yeVN0b3ZlU3RyYXRlZ3lTdHJlZXRTdHJpa2VTdHJvbmdTdHJ1Z2dsZVN0dWRlbnRTdHVmZlN0dW1ibGVTdHlsZVN1YmplY3RTdWJtaXRTdWJ3YXlTdWNjZXNzU3VjaFN1ZGRlblN1ZmZlclN1Z2FyU3VnZ2VzdFN1aXRTdW1tZXJTdW5TdW5ueVN1bnNldFN1cGVyU3VwcGx5U3VwcmVtZVN1cmVTdXJmYWNlU3VyZ2VTdXJwcmlzZVN1cnJvdW5kU3VydmV5U3VzcGVjdFN1c3RhaW5Td2FsbG93U3dhbXBTd2FwU3dhcm1Td2VhclN3ZWV0U3dpZnRTd2ltU3dpbmdTd2l0Y2hTd29yZFN5bWJvbFN5bXB0b21TeXJ1cFN5c3RlbVRhYmxlVGFja2xlVGFnVGFpbFRhbGVudFRhbGtUYW5rVGFwZVRhcmdldFRhc2tUYXN0ZVRhdHRvb1RheGlUZWFjaFRlYW1UZWxsVGVuVGVuYW50VGVubmlzVGVudFRlcm1UZXN0VGV4dFRoYW5rVGhhdFRoZW1lVGhlblRoZW9yeVRoZXJlVGhleVRoaW5nVGhpc1Rob3VnaHRUaHJlZVRocml2ZVRocm93VGh1bWJUaHVuZGVyVGlja2V0VGlkZVRpZ2VyVGlsdFRpbWJlclRpbWVUaW55VGlwVGlyZWRUaXNzdWVUaXRsZVRvYXN0VG9iYWNjb1RvZGF5VG9kZGxlclRvZVRvZ2V0aGVyVG9pbGV0VG9rZW5Ub21hdG9Ub21vcnJvd1RvbmVUb25ndWVUb25pZ2h0VG9vbFRvb3RoVG9wVG9waWNUb3BwbGVUb3JjaFRvcm5hZG9Ub3J0b2lzZVRvc3NUb3RhbFRvdXJpc3RUb3dhcmRUb3dlclRvd25Ub3lUcmFja1RyYWRlVHJhZmZpY1RyYWdpY1RyYWluVHJhbnNmZXJUcmFwVHJhc2hUcmF2ZWxUcmF5VHJlYXRUcmVlVHJlbmRUcmlhbFRyaWJlVHJpY2tUcmlnZ2VyVHJpbVRyaXBUcm9waHlUcm91YmxlVHJ1Y2tUcnVlVHJ1bHlUcnVtcGV0VHJ1c3RUcnV0aFRyeVR1YmVUdWl0aW9uVHVtYmxlVHVuYVR1bm5lbFR1cmtleVR1cm5UdXJ0bGVUd2VsdmVUd2VudHlUd2ljZVR3aW5Ud2lzdFR3b1R5cGVUeXBpY2FsVWdseVVtYnJlbGxhVW5hYmxlVW5hd2FyZVVuY2xlVW5jb3ZlclVuZGVyVW5kb1VuZmFpclVuZm9sZFVuaGFwcHlVbmlmb3JtVW5pcXVlVW5pdFVuaXZlcnNlVW5rbm93blVubG9ja1VudGlsVW51c3VhbFVudmVpbFVwZGF0ZVVwZ3JhZGVVcGhvbGRVcG9uVXBwZXJVcHNldFVyYmFuVXJnZVVzYWdlVXNlVXNlZFVzZWZ1bFVzZWxlc3NVc3VhbFV0aWxpdHlWYWNhbnRWYWN1dW1WYWd1ZVZhbGlkVmFsbGV5VmFsdmVWYW5WYW5pc2hWYXBvclZhcmlvdXNWYXN0VmF1bHRWZWhpY2xlVmVsdmV0VmVuZG9yVmVudHVyZVZlbnVlVmVyYlZlcmlmeVZlcnNpb25WZXJ5VmVzc2VsVmV0ZXJhblZpYWJsZVZpYnJhbnRWaWNpb3VzVmljdG9yeVZpZGVvVmlld1ZpbGxhZ2VWaW50YWdlVmlvbGluVmlydHVhbFZpcnVzVmlzYVZpc2l0VmlzdWFsVml0YWxWaXZpZFZvY2FsVm9pY2VWb2lkVm9sY2Fub1ZvbHVtZVZvdGVWb3lhZ2VXYWdlV2Fnb25XYWl0V2Fsa1dhbGxXYWxudXRXYW50V2FyZmFyZVdhcm1XYXJyaW9yV2FzaFdhc3BXYXN0ZVdhdGVyV2F2ZVdheVdlYWx0aFdlYXBvbldlYXJXZWFzZWxXZWF0aGVyV2ViV2VkZGluZ1dlZWtlbmRXZWlyZFdlbGNvbWVXZXN0V2V0V2hhbGVXaGF0V2hlYXRXaGVlbFdoZW5XaGVyZVdoaXBXaGlzcGVyV2lkZVdpZHRoV2lmZVdpbGRXaWxsV2luV2luZG93V2luZVdpbmdXaW5rV2lubmVyV2ludGVyV2lyZVdpc2RvbVdpc2VXaXNoV2l0bmVzc1dvbGZXb21hbldvbmRlcldvb2RXb29sV29yZFdvcmtXb3JsZFdvcnJ5V29ydGhXcmFwV3JlY2tXcmVzdGxlV3Jpc3RXcml0ZVdyb25nWWFyZFllYXJZZWxsb3dZb3VZb3VuZ1lvdXRoWmVicmFaZXJvWm9uZVpvb1wiO2xldCB3b3JkbGlzdCQxPW51bGw7ZnVuY3Rpb24gbG9hZFdvcmRzJDEobGFuZyl7aWYod29yZGxpc3QkMSE9bnVsbCl7cmV0dXJufXdvcmRsaXN0JDE9d29yZHMkMS5yZXBsYWNlKC8oW0EtWl0pL2csXCIgJDFcIikudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkuc3BsaXQoXCIgXCIpO2lmKFdvcmRsaXN0LmNoZWNrKGxhbmcpIT09XCIweDNjOGFjYzFlN2IwOGQ4ZTc2ZjlmZGEwMTVlZjQ4ZGM4YzcxMGE3M2NiN2UwZjc3YjJjMThhOWI1YTdhZGRlNjBcIil7d29yZGxpc3QkMT1udWxsO3Rocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBlbiAoRW5nbGlzaCkgRkFJTEVEXCIpfX1jbGFzcyBMYW5nRW4gZXh0ZW5kcyBXb3JkbGlzdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiZW5cIil9Z2V0V29yZChpbmRleCl7bG9hZFdvcmRzJDEodGhpcyk7cmV0dXJuIHdvcmRsaXN0JDFbaW5kZXhdfWdldFdvcmRJbmRleCh3b3JkKXtsb2FkV29yZHMkMSh0aGlzKTtyZXR1cm4gd29yZGxpc3QkMS5pbmRleE9mKHdvcmQpfX1jb25zdCBsYW5nRW49bmV3IExhbmdFbjtXb3JkbGlzdC5yZWdpc3RlcihsYW5nRW4pO1widXNlIHN0cmljdFwiO2NvbnN0IHdvcmRzJDI9XCJBL2JhY29BYmRvbWVuQWJlamFBYmllcnRvQWJvZ2Fkb0Fib25vQWJvcnRvQWJyYXpvQWJyaXJBYnVlbG9BYnVzb0FjYWJhckFjYWRlbWlhQWNjZXNvQWNjaW8vbkFjZWl0ZUFjZWxnYUFjZW50b0FjZXB0YXJBL2NpZG9BY2xhcmFyQWNuZS9BY29nZXJBY29zb0FjdGl2b0FjdG9BY3RyaXpBY3R1YXJBY3VkaXJBY3VlcmRvQWN1c2FyQWRpY3RvQWRtaXRpckFkb3B0YXJBZG9ybm9BZHVhbmFBZHVsdG9BZS9yZW9BZmVjdGFyQWZpY2lvL25BZmluYXJBZmlybWFyQS9naWxBZ2l0YXJBZ29uaS9hQWdvc3RvQWdvdGFyQWdyZWdhckFncmlvQWd1YUFndWRvQS9ndWlsYUFndWphQWhvZ29BaG9ycm9BaXJlQWlzbGFyQWplZHJlekFqZW5vQWp1c3RlQWxhY3JhL25BbGFtYnJlQWxhcm1hQWxiYUEvbGJ1bUFsY2FsZGVBbGRlYUFsZWdyZUFsZWphckFsZXJ0YUFsZXRhQWxmaWxlckFsZ2FBbGdvZG8vbkFsaWFkb0FsaWVudG9BbGl2aW9BbG1hQWxtZWphQWxtaS9iYXJBbHRhckFsdGV6YUFsdGl2b0FsdG9BbHR1cmFBbHVtbm9BbHphckFtYWJsZUFtYW50ZUFtYXBvbGFBbWFyZ29BbWFzYXJBL21iYXJBL21iaXRvQW1lbm9BbWlnb0FtaXN0YWRBbW9yQW1wYXJvQW1wbGlvQW5jaG9BbmNpYW5vQW5jbGFBbmRhckFuZGUvbkFuZW1pYUEvbmd1bG9BbmlsbG9BL25pbW9Bbmkvc0Fub3RhckFudGVuYUFudGlndW9BbnRvam9BbnVhbEFudWxhckFudW5jaW9BfmFkaXJBfmVqb0F+b0FwYWdhckFwYXJhdG9BcGV0aXRvQXBpb0FwbGljYXJBcG9kb0Fwb3J0ZUFwb3lvQXByZW5kZXJBcHJvYmFyQXB1ZXN0YUFwdXJvQXJhZG9BcmF+YUFyYXJBL3JiaXRyb0EvcmJvbEFyYnVzdG9BcmNoaXZvQXJjb0FyZGVyQXJkaWxsYUFyZHVvQS9yZWFBL3JpZG9Bcmllc0FybW9uaS9hQXJuZS9zQXJvbWFBcnBhQXJwby9uQXJyZWdsb0Fycm96QXJydWdhQXJ0ZUFydGlzdGFBc2FBc2Fkb0FzYWx0b0FzY2Vuc29Bc2VndXJhckFzZW9Bc2Vzb3JBc2llbnRvQXNpbG9Bc2lzdGlyQXNub0Fzb21icm9BL3NwZXJvQXN0aWxsYUFzdHJvQXN0dXRvQXN1bWlyQXN1bnRvQXRham9BdGFxdWVBdGFyQXRlbnRvQXRlb0EvdGljb0F0bGV0YUEvdG9tb0F0cmFlckF0cm96QXR1L25BdWRhekF1ZGlvQXVnZUF1bGFBdW1lbnRvQXVzZW50ZUF1dG9yQXZhbEF2YW5jZUF2YXJvQXZlQXZlbGxhbmFBdmVuYUF2ZXN0cnV6QXZpby9uQXZpc29BeWVyQXl1ZGFBeXVub0F6YWZyYS9uQXphckF6b3RlQXp1L2NhckF6dWZyZUF6dWxCYWJhQmFib3JCYWNoZUJhaGkvYUJhaWxlQmFqYXJCYWxhbnphQmFsY28vbkJhbGRlQmFtYnUvQmFuY29CYW5kYUJhfm9CYXJiYUJhcmNvQmFybml6QmFycm9CYS9zY3VsYUJhc3RvL25CYXN1cmFCYXRhbGxhQmF0ZXJpL2FCYXRpckJhdHV0YUJhdS9sQmF6YXJCZWJlL0JlYmlkYUJlbGxvQmVzYXJCZXNvQmVzdGlhQmljaG9CaWVuQmluZ29CbGFuY29CbG9xdWVCbHVzYUJvYUJvYmluYUJvYm9Cb2NhQm9jaW5hQm9kYUJvZGVnYUJvaW5hQm9sYUJvbGVyb0JvbHNhQm9tYmFCb25kYWRCb25pdG9Cb25vQm9uc2EvaUJvcmRlQm9ycmFyQm9zcXVlQm90ZUJvdGkvbkJvL3ZlZGFCb3phbEJyYXZvQnJhem9CcmVjaGFCcmV2ZUJyaWxsb0JyaW5jb0JyaXNhQnJvY2FCcm9tYUJyb25jZUJyb3RlQnJ1amFCcnVzY29CcnV0b0J1Y2VvQnVjbGVCdWVub0J1ZXlCdWZhbmRhQnVmby9uQnUvaG9CdWl0cmVCdWx0b0J1cmJ1amFCdXJsYUJ1cnJvQnVzY2FyQnV0YWNhQnV6by9uQ2FiYWxsb0NhYmV6YUNhYmluYUNhYnJhQ2FjYW9DYWRhL3ZlckNhZGVuYUNhZXJDYWZlL0NhaS9kYUNhaW1hL25DYWphQ2Fqby9uQ2FsQ2FsYW1hckNhbGNpb0NhbGRvQ2FsaWRhZENhbGxlQ2FsbWFDYWxvckNhbHZvQ2FtYUNhbWJpb0NhbWVsbG9DYW1pbm9DYW1wb0NhL25jZXJDYW5kaWxDYW5lbGFDYW5ndXJvQ2FuaWNhQ2FudG9DYX5hQ2F+by9uQ2FvYmFDYW9zQ2FwYXpDYXBpdGEvbkNhcG90ZUNhcHRhckNhcHVjaGFDYXJhQ2FyYm8vbkNhL3JjZWxDYXJldGFDYXJnYUNhcml+b0Nhcm5lQ2FycGV0YUNhcnJvQ2FydGFDYXNhQ2FzY29DYXNlcm9DYXNwYUNhc3RvckNhdG9yY2VDYXRyZUNhdWRhbENhdXNhQ2F6b0NlYm9sbGFDZWRlckNlZHJvQ2VsZGFDZS9sZWJyZUNlbG9zb0NlL2x1bGFDZW1lbnRvQ2VuaXphQ2VudHJvQ2VyY2FDZXJkb0NlcmV6YUNlcm9DZXJyYXJDZXJ0ZXphQ2Uvc3BlZENldHJvQ2hhY2FsQ2hhbGVjb0NoYW1wdS9DaGFuY2xhQ2hhcGFDaGFybGFDaGljb0NoaXN0ZUNoaXZvQ2hvcXVlQ2hvemFDaHVsZXRhQ2h1cGFyQ2ljbG8vbkNpZWdvQ2llbG9DaWVuQ2llcnRvQ2lmcmFDaWdhcnJvQ2ltYUNpbmNvQ2luZUNpbnRhQ2lwcmUvc0NpcmNvQ2lydWVsYUNpc25lQ2l0YUNpdWRhZENsYW1vckNsYW5DbGFyb0NsYXNlQ2xhdmVDbGllbnRlQ2xpbWFDbGkvbmljYUNvYnJlQ29jY2lvL25Db2NoaW5vQ29jaW5hQ29jb0NvL2RpZ29Db2RvQ29mcmVDb2dlckNvaGV0ZUNvamkvbkNvam9Db2xhQ29sY2hhQ29sZWdpb0NvbGdhckNvbGluYUNvbGxhckNvbG1vQ29sdW1uYUNvbWJhdGVDb21lckNvbWlkYUNvL21vZG9Db21wcmFDb25kZUNvbmVqb0NvbmdhQ29ub2NlckNvbnNlam9Db250YXJDb3BhQ29waWFDb3Jhem8vbkNvcmJhdGFDb3JjaG9Db3Jkby9uQ29yb25hQ29ycmVyQ29zZXJDb3Ntb3NDb3N0YUNyYS9uZW9DcmEvdGVyQ3JlYXJDcmVjZXJDcmVpL2RvQ3JlbWFDcmkvYUNyaW1lbkNyaXB0YUNyaXNpc0Nyb21vQ3JvL25pY2FDcm9xdWV0YUNydWRvQ3J1ekN1YWRyb0N1YXJ0b0N1YXRyb0N1Ym9DdWJyaXJDdWNoYXJhQ3VlbGxvQ3VlbnRvQ3VlcmRhQ3Vlc3RhQ3VldmFDdWlkYXJDdWxlYnJhQ3VscGFDdWx0b0N1bWJyZUN1bXBsaXJDdW5hQ3VuZXRhQ3VvdGFDdXBvL25DdS9wdWxhQ3VyYXJDdXJpb3NvQ3Vyc29DdXJ2YUN1dGlzRGFtYURhbnphRGFyRGFyZG9EYS90aWxEZWJlckRlL2JpbERlL2NhZGFEZWNpckRlZG9EZWZlbnNhRGVmaW5pckRlamFyRGVsZmkvbkRlbGdhZG9EZWxpdG9EZW1vcmFEZW5zb0RlbnRhbERlcG9ydGVEZXJlY2hvRGVycm90YURlc2F5dW5vRGVzZW9EZXNmaWxlRGVzbnVkb0Rlc3Rpbm9EZXN2aS9vRGV0YWxsZURldGVuZXJEZXVkYURpL2FEaWFibG9EaWFkZW1hRGlhbWFudGVEaWFuYURpYXJpb0RpYnVqb0RpY3RhckRpZW50ZURpZXRhRGllekRpZmkvY2lsRGlnbm9EaWxlbWFEaWx1aXJEaW5lcm9EaXJlY3RvRGlyaWdpckRpc2NvRGlzZX5vRGlzZnJhekRpdmFEaXZpbm9Eb2JsZURvY2VEb2xvckRvbWluZ29Eb25Eb25hckRvcmFkb0Rvcm1pckRvcnNvRG9zRG9zaXNEcmFnby9uRHJvZ2FEdWNoYUR1ZGFEdWVsb0R1ZX5vRHVsY2VEdS9vRHVxdWVEdXJhckR1cmV6YUR1cm9FL2Jhbm9FYnJpb0VjaGFyRWNvRWN1YWRvckVkYWRFZGljaW8vbkVkaWZpY2lvRWRpdG9yRWR1Y2FyRWZlY3RvRWZpY2F6RWplRWplbXBsb0VsZWZhbnRlRWxlZ2lyRWxlbWVudG9FbGV2YXJFbGlwc2VFL2xpdGVFbGl4aXJFbG9naW9FbHVkaXJFbWJ1ZG9FbWl0aXJFbW9jaW8vbkVtcGF0ZUVtcGV+b0VtcGxlb0VtcHJlc2FFbmFub0VuY2FyZ29FbmNodWZlRW5jaS9hRW5lbWlnb0VuZXJvRW5mYWRvRW5mZXJtb0VuZ2F+b0VuaWdtYUVubGFjZUVub3JtZUVucmVkb0Vuc2F5b0Vuc2V+YXJFbnRlcm9FbnRyYXJFbnZhc2VFbnZpL29FL3BvY2FFcXVpcG9Fcml6b0VzY2FsYUVzY2VuYUVzY29sYXJFc2NyaWJpckVzY3Vkb0VzZW5jaWFFc2ZlcmFFc2Z1ZXJ6b0VzcGFkYUVzcGVqb0VzcGkvYUVzcG9zYUVzcHVtYUVzcXVpL0VzdGFyRXN0ZUVzdGlsb0VzdHVmYUV0YXBhRXRlcm5vRS90aWNhRXRuaWFFdmFkaXJFdmFsdWFyRXZlbnRvRXZpdGFyRXhhY3RvRXhhbWVuRXhjZXNvRXhjdXNhRXhlbnRvRXhpZ2lyRXhpbGlvRXhpc3RpckUveGl0b0V4cGVydG9FeHBsaWNhckV4cG9uZXJFeHRyZW1vRmEvYnJpY2FGYS9idWxhRmFjaGFkYUZhL2NpbEZhY3RvckZhZW5hRmFqYUZhbGRhRmFsbG9GYWxzb0ZhbHRhckZhbWFGYW1pbGlhRmFtb3NvRmFyYW8vbkZhcm1hY2lhRmFyb2xGYXJzYUZhc2VGYXRpZ2FGYXVuYUZhdm9yRmF4RmVicmVyb0ZlY2hhRmVsaXpGZW9GZXJpYUZlcm96RmUvcnRpbEZlcnZvckZlc3RpL25GaWFibGVGaWFuemFGaWFyRmlicmFGaWNjaW8vbkZpY2hhRmlkZW9GaWVicmVGaWVsRmllcmFGaWVzdGFGaWd1cmFGaWphckZpam9GaWxhRmlsZXRlRmlsaWFsRmlsdHJvRmluRmluY2FGaW5naXJGaW5pdG9GaXJtYUZsYWNvRmxhdXRhRmxlY2hhRmxvckZsb3RhRmx1aXJGbHVqb0ZsdS9vckZvYmlhRm9jYUZvZ2F0YUZvZ28vbkZvbGlvRm9sbGV0b0ZvbmRvRm9ybWFGb3Jyb0ZvcnR1bmFGb3J6YXJGb3NhRm90b0ZyYWNhc29GcmEvZ2lsRnJhbmphRnJhc2VGcmF1ZGVGcmVpL3JGcmVub0ZyZXNhRnJpL29Gcml0b0ZydXRhRnVlZ29GdWVudGVGdWVyemFGdWdhRnVtYXJGdW5jaW8vbkZ1bmRhRnVyZ28vbkZ1cmlhRnVzaWxGdS90Ym9sRnV0dXJvR2FjZWxhR2FmYXNHYWl0YUdham9HYWxhR2FsZXJpL2FHYWxsb0dhbWJhR2FuYXJHYW5jaG9HYW5nYUdhbnNvR2FyYWplR2FyemFHYXNvbGluYUdhc3RhckdhdG9HYXZpbGEvbkdlbWVsb0dlbWlyR2VuR2UvbmVyb0dlbmlvR2VudGVHZXJhbmlvR2VyZW50ZUdlcm1lbkdlc3RvR2lnYW50ZUdpbW5hc2lvR2lyYXJHaXJvR2xhY2lhckdsb2JvR2xvcmlhR29sR29sZm9Hb2xvc29Hb2xwZUdvbWFHb3Jkb0dvcmlsYUdvcnJhR290YUdvdGVvR296YXJHcmFkYUdyYS9maWNvR3Jhbm9HcmFzYUdyYXRpc0dyYXZlR3JpZXRhR3JpbGxvR3JpcGVHcmlzR3JpdG9Hcm9zb3JHcnUvYUdydWVzb0dydW1vR3J1cG9HdWFudGVHdWFwb0d1YXJkaWFHdWVycmFHdWkvYUd1aX5vR3Vpb25HdWlzb0d1aXRhcnJhR3VzYW5vR3VzdGFySGFiZXJIYS9iaWxIYWJsYXJIYWNlckhhY2hhSGFkYUhhbGxhckhhbWFjYUhhcmluYUhhekhhemF+YUhlYmlsbGFIZWJyYUhlY2hvSGVsYWRvSGVsaW9IZW1icmFIZXJpckhlcm1hbm9IZS9yb2VIZXJ2aXJIaWVsb0hpZXJyb0hpL2dhZG9IaWdpZW5lSGlqb0hpbW5vSGlzdG9yaWFIb2NpY29Ib2dhckhvZ3VlcmFIb2phSG9tYnJlSG9uZ29Ib25vckhvbnJhSG9yYUhvcm1pZ2FIb3Jub0hvc3RpbEhveW9IdWVjb0h1ZWxnYUh1ZXJ0YUh1ZXNvSHVldm9IdWlkYUh1aXJIdW1hbm9IdS9tZWRvSHVtaWxkZUh1bW9IdW5kaXJIdXJhY2Evbkh1cnRvSWNvbm9JZGVhbElkaW9tYUkvZG9sb0lnbGVzaWFJZ2x1L0lndWFsSWxlZ2FsSWx1c2lvL25JbWFnZW5JbWEvbkltaXRhckltcGFySW1wZXJpb0ltcG9uZXJJbXB1bHNvSW5jYXBhekkvbmRpY2VJbmVydGVJbmZpZWxJbmZvcm1lSW5nZW5pb0luaWNpb0lubWVuc29Jbm11bmVJbm5hdG9JbnNlY3RvSW5zdGFudGVJbnRlcmUvc0kvbnRpbW9JbnR1aXJJbnUvdGlsSW52aWVybm9JcmFJcmlzSXJvbmkvYUlzbGFJc2xvdGVKYWJhbGkvSmFiby9uSmFtby9uSmFyYWJlSmFyZGkvbkphcnJhSmF1bGFKYXptaS9uSmVmZUplcmluZ2FKaW5ldGVKb3JuYWRhSm9yb2JhSm92ZW5Kb3lhSnVlcmdhSnVldmVzSnVlekp1Z2Fkb3JKdWdvSnVndWV0ZUp1aWNpb0p1bmNvSnVuZ2xhSnVuaW9KdW50YXJKdS9waXRlckp1cmFySnVzdG9KdXZlbmlsSnV6Z2FyS2lsb0tvYWxhTGFiaW9MYWNpb0xhY3JhTGFkb0xhZHJvL25MYWdhcnRvTGEvZ3JpbWFMYWd1bmFMYWljb0xhbWVyTGEvbWluYUxhL21wYXJhTGFuYUxhbmNoYUxhbmdvc3RhTGFuemFMYS9waXpMYXJnb0xhcnZhTGEvc3RpbWFMYXRhTGEvdGV4TGF0aXJMYXVyZWxMYXZhckxhem9MZWFsTGVjY2lvL25MZWNoZUxlY3RvckxlZXJMZWdpby9uTGVndW1icmVMZWphbm9MZW5ndWFMZW50b0xlfmFMZW8vbkxlb3BhcmRvTGVzaW8vbkxldGFsTGV0cmFMZXZlTGV5ZW5kYUxpYmVydGFkTGlicm9MaWNvckxpL2RlckxpZGlhckxpZW56b0xpZ2FMaWdlcm9MaW1hTGkvbWl0ZUxpbW8vbkxpbXBpb0xpbmNlTGluZG9MaS9uZWFMaW5nb3RlTGlub0xpbnRlcm5hTGkvcXVpZG9MaXNvTGlzdGFMaXRlcmFMaXRpb0xpdHJvTGxhZ2FMbGFtYUxsYW50b0xsYXZlTGxlZ2FyTGxlbmFyTGxldmFyTGxvcmFyTGxvdmVyTGx1dmlhTG9ib0xvY2lvL25Mb2NvTG9jdXJhTG8vZ2ljYUxvZ3JvTG9tYnJpekxvbW9Mb25qYUxvdGVMdWNoYUx1Y2lyTHVnYXJMdWpvTHVuYUx1bmVzTHVwYUx1c3Ryb0x1dG9MdXpNYWNldGFNYWNob01hZGVyYU1hZHJlTWFkdXJvTWFlc3Ryb01hZmlhTWFnaWFNYWdvTWFpL3pNYWxkYWRNYWxldGFNYWxsYU1hbG9NYW1hL01hbWJvTWFtdXRNYW5jb01hbmRvTWFuZWphck1hbmdhTWFuaXF1aS9NYW5qYXJNYW5vTWFuc29NYW50YU1hfmFuYU1hcGFNYS9xdWluYU1hck1hcmNvTWFyZWFNYXJmaWxNYXJnZW5NYXJpZG9NYS9ybW9sTWFycm8vbk1hcnRlc01hcnpvTWFzYU1hL3NjYXJhTWFzaXZvTWF0YXJNYXRlcmlhTWF0aXpNYXRyaXpNYS94aW1vTWF5b3JNYXpvcmNhTWVjaGFNZWRhbGxhTWVkaW9NZS9kdWxhTWVqaWxsYU1lam9yTWVsZW5hTWVsby9uTWVtb3JpYU1lbm9yTWVuc2FqZU1lbnRlTWVudS9NZXJjYWRvTWVyZW5ndWVNZS9yaXRvTWVzTWVzby9uTWV0YU1ldGVyTWUvdG9kb01ldHJvTWV6Y2xhTWllZG9NaWVsTWllbWJyb01pZ2FNaWxNaWxhZ3JvTWlsaXRhck1pbGxvL25NaW1vTWluYU1pbmVyb01pL25pbW9NaW51dG9NaW9wZU1pcmFyTWlzYU1pc2VyaWFNaXNpbE1pc21vTWl0YWRNaXRvTW9jaGlsYU1vY2lvL25Nb2RhTW9kZWxvTW9ob01vamFyTW9sZGVNb2xlck1vbGlub01vbWVudG9Nb21pYU1vbmFyY2FNb25lZGFNb25qYU1vbnRvTW9+b01vcmFkYU1vcmRlck1vcmVub01vcmlyTW9ycm9Nb3JzYU1vcnRhbE1vc2NhTW9zdHJhck1vdGl2b01vdmVyTW8vdmlsTW96b011Y2hvTXVkYXJNdWVibGVNdWVsYU11ZXJ0ZU11ZXN0cmFNdWdyZU11amVyTXVsYU11bGV0YU11bHRhTXVuZG9NdX5lY2FNdXJhbE11cm9NdS9zY3Vsb011c2VvTXVzZ29NdS9zaWNhTXVzbG9OYS9jYXJOYWNpby9uTmFkYXJOYWlwZU5hcmFuamFOYXJpek5hcnJhck5hc2FsTmF0YWxOYXRpdm9OYXR1cmFsTmEvdXNlYU5hdmFsTmF2ZU5hdmlkYWROZWNpb05lL2N0YXJOZWdhck5lZ29jaW9OZWdyb05lby9uTmVydmlvTmV0b05ldXRyb05ldmFyTmV2ZXJhTmljaG9OaWRvTmllYmxhTmlldG9OaX5lek5pfm9OaS90aWRvTml2ZWxOb2JsZXphTm9jaGVOby9taW5hTm9yaWFOb3JtYU5vcnRlTm90YU5vdGljaWFOb3ZhdG9Ob3ZlbGFOb3Zpb051YmVOdWNhTnUvY2xlb051ZGlsbG9OdWRvTnVlcmFOdWV2ZU51ZXpOdWxvTnUvbWVyb051dHJpYU9hc2lzT2Jlc29PYmlzcG9PYmpldG9PYnJhT2JyZXJvT2JzZXJ2YXJPYnRlbmVyT2J2aW9PY2FPY2Fzb09jZS9hbm9PY2hlbnRhT2Nob09jaW9PY3JlT2N0YXZvT2N0dWJyZU9jdWx0b09jdXBhck9jdXJyaXJPZGlhck9kaW9PZGlzZWFPZXN0ZU9mZW5zYU9mZXJ0YU9maWNpb09mcmVjZXJPZ3JvT2kvZG9PaS9yT2pvT2xhT2xlYWRhT2xmYXRvT2xpdm9PbGxhT2xtb09sb3JPbHZpZG9PbWJsaWdvT25kYU9uemFPcGFjb09wY2lvL25PL3BlcmFPcGluYXJPcG9uZXJPcHRhck8vcHRpY2FPcHVlc3RvT3JhY2lvL25PcmFkb3JPcmFsTy9yYml0YU9yY2FPcmRlbk9yZWphTy9yZ2Fub09yZ2kvYU9yZ3VsbG9PcmllbnRlT3JpZ2VuT3JpbGxhT3JvT3JxdWVzdGFPcnVnYU9zYWRpL2FPc2N1cm9Pc2V6bm9Pc29Pc3RyYU90b35vT3Ryb092ZWphTy92dWxvTy94aWRvT3hpL2dlbm9PeWVudGVPem9ub1BhY3RvUGFkcmVQYWVsbGFQYS9naW5hUGFnb1BhaS9zUGEvamFyb1BhbGFicmFQYWxjb1BhbGV0YVBhL2xpZG9QYWxtYVBhbG9tYVBhbHBhclBhblBhbmFsUGEvbmljb1BhbnRlcmFQYX51ZWxvUGFwYS9QYXBlbFBhcGlsbGFQYXF1ZXRlUGFyYXJQYXJjZWxhUGFyZWRQYXJpclBhcm9QYS9ycGFkb1BhcnF1ZVBhL3JyYWZvUGFydGVQYXNhclBhc2VvUGFzaW8vblBhc29QYXN0YVBhdGFQYXRpb1BhdHJpYVBhdXNhUGF1dGFQYXZvUGF5YXNvUGVhdG8vblBlY2Fkb1BlY2VyYVBlY2hvUGVkYWxQZWRpclBlZ2FyUGVpbmVQZWxhclBlbGRhfm9QZWxlYVBlbGlncm9QZWxsZWpvUGVsb1BlbHVjYVBlbmFQZW5zYXJQZX5vL25QZW8vblBlb3JQZXBpbm9QZXF1ZX5vUGVyYVBlcmNoYVBlcmRlclBlcmV6YVBlcmZpbFBlcmljb1BlcmxhUGVybWlzb1BlcnJvUGVyc29uYVBlc2FQZXNjYVBlL3NpbW9QZXN0YX5hUGUvdGFsb1BldHJvL2xlb1BlelBlenV+YVBpY2FyUGljaG8vblBpZVBpZWRyYVBpZXJuYVBpZXphUGlqYW1hUGlsYXJQaWxvdG9QaW1pZW50YVBpbm9QaW50b3JQaW56YVBpfmFQaW9qb1BpcGFQaXJhdGFQaXNhclBpc2NpbmFQaXNvUGlzdGFQaXRvL25QaXpjYVBsYWNhUGxhblBsYXRhUGxheWFQbGF6YVBsZWl0b1BsZW5vUGxvbW9QbHVtYVBsdXJhbFBvYnJlUG9jb1BvZGVyUG9kaW9Qb2VtYVBvZXNpL2FQb2V0YVBvbGVuUG9saWNpL2FQb2xsb1BvbHZvUG9tYWRhUG9tZWxvUG9tb1BvbXBhUG9uZXJQb3JjaW8vblBvcnRhbFBvc2FkYVBvc2VlclBvc2libGVQb3N0ZVBvdGVuY2lhUG90cm9Qb3pvUHJhZG9QcmVjb3pQcmVndW50YVByZW1pb1ByZW5zYVByZXNvUHJldmlvUHJpbW9QcmkvbmNpcGVQcmlzaW8vblByaXZhclByb2FQcm9iYXJQcm9jZXNvUHJvZHVjdG9Qcm9lemFQcm9mZXNvclByb2dyYW1hUHJvbGVQcm9tZXNhUHJvbnRvUHJvcGlvUHJvL3hpbW9QcnVlYmFQdS9ibGljb1B1Y2hlcm9QdWRvclB1ZWJsb1B1ZXJ0YVB1ZXN0b1B1bGdhUHVsaXJQdWxtby9uUHVscG9QdWxzb1B1bWFQdW50b1B1fmFsUHV+b1B1cGFQdXBpbGFQdXJlL1F1ZWRhclF1ZWphUXVlbWFyUXVlcmVyUXVlc29RdWlldG9RdWkvbWljYVF1aW5jZVF1aXRhclJhL2Jhbm9SYWJpYVJhYm9SYWNpby9uUmFkaWNhbFJhaS96UmFtYVJhbXBhUmFuY2hvUmFuZ29SYXBhelJhL3BpZG9SYXB0b1Jhc2dvUmFzcGFSYXRvUmF5b1JhemFSYXpvL25SZWFjY2lvL25SZWFsaWRhZFJlYmF+b1JlYm90ZVJlY2FlclJlY2V0YVJlY2hhem9SZWNvZ2VyUmVjcmVvUmVjdG9SZWN1cnNvUmVkUmVkb25kb1JlZHVjaXJSZWZsZWpvUmVmb3JtYVJlZnJhL25SZWZ1Z2lvUmVnYWxvUmVnaXJSZWdsYVJlZ3Jlc29SZWhlL25SZWlub1JlaS9yUmVqYVJlbGF0b1JlbGV2b1JlbGlldmVSZWxsZW5vUmVsb2pSZW1hclJlbWVkaW9SZW1vUmVuY29yUmVuZGlyUmVudGFSZXBhcnRvUmVwZXRpclJlcG9zb1JlcHRpbFJlc1Jlc2NhdGVSZXNpbmFSZXNwZXRvUmVzdG9SZXN1bWVuUmV0aXJvUmV0b3Jub1JldHJhdG9SZXVuaXJSZXZlL3NSZXZpc3RhUmV5UmV6YXJSaWNvUmllZ29SaWVuZGFSaWVzZ29SaWZhUmkvZ2lkb1JpZ29yUmluY28vblJpfm8vblJpL29SaXF1ZXphUmlzYVJpdG1vUml0b1Jpem9Sb2JsZVJvY2VSb2NpYXJSb2RhclJvZGVvUm9kaWxsYVJvZXJSb2ppem9Sb2pvUm9tZXJvUm9tcGVyUm9uUm9uY29Sb25kYVJvcGFSb3Blcm9Sb3NhUm9zY2FSb3N0cm9Sb3RhclJ1YmkvUnVib3JSdWRvUnVlZGFSdWdpclJ1aWRvUnVpbmFSdWxldGFSdWxvUnVtYm9SdW1vclJ1cHR1cmFSdXRhUnV0aW5hU2EvYmFkb1NhYmVyU2FiaW9TYWJsZVNhY2FyU2FnYXpTYWdyYWRvU2FsYVNhbGRvU2FsZXJvU2FsaXJTYWxtby9uU2Fsby9uU2Fsc2FTYWx0b1NhbHVkU2FsdmFyU2FtYmFTYW5jaW8vblNhbmRpL2FTYW5lYXJTYW5ncmVTYW5pZGFkU2Fub1NhbnRvU2Fwb1NhcXVlU2FyZGluYVNhcnRlL25TYXN0cmVTYXRhL25TYXVuYVNheG9mby9uU2VjY2lvL25TZWNvU2VjcmV0b1NlY3RhU2VkU2VndWlyU2Vpc1NlbGxvU2VsdmFTZW1hbmFTZW1pbGxhU2VuZGFTZW5zb3JTZX5hbFNlfm9yU2VwYXJhclNlcGlhU2VxdWkvYVNlclNlcmllU2VybW8vblNlcnZpclNlc2VudGFTZXNpby9uU2V0YVNldGVudGFTZXZlcm9TZXhvU2V4dG9TaWRyYVNpZXN0YVNpZXRlU2lnbG9TaWdub1NpL2xhYmFTaWxiYXJTaWxlbmNpb1NpbGxhU2kvbWJvbG9TaW1pb1NpcmVuYVNpc3RlbWFTaXRpb1NpdHVhclNvYnJlU29jaW9Tb2Rpb1NvbFNvbGFwYVNvbGRhZG9Tb2xlZGFkU28vbGlkb1NvbHRhclNvbHVjaW8vblNvbWJyYVNvbmRlb1Nvbmlkb1Nvbm9yb1NvbnJpc2FTb3BhU29wbGFyU29wb3J0ZVNvcmRvU29ycHJlc2FTb3J0ZW9Tb3N0ZS9uU28vdGFub1N1YXZlU3ViaXJTdWNlc29TdWRvclN1ZWdyYVN1ZWxvU3Vlfm9TdWVydGVTdWZyaXJTdWpldG9TdWx0YS9uU3VtYXJTdXBlcmFyU3VwbGlyU3Vwb25lclN1cHJlbW9TdXJTdXJjb1N1cmV+b1N1cmdpclN1c3RvU3V0aWxUYWJhY29UYWJpcXVlVGFibGFUYWJ1L1RhY29UYWN0b1Rham9UYWxhclRhbGNvVGFsZW50b1RhbGxhVGFsby9uVGFtYX5vVGFtYm9yVGFuZ29UYW5xdWVUYXBhVGFwZXRlVGFwaWFUYXBvL25UYXF1aWxsYVRhcmRlVGFyZWFUYXJpZmFUYXJqZXRhVGFyb3RUYXJyb1RhcnRhVGF0dWFqZVRhdXJvVGF6YVRhem8vblRlYXRyb1RlY2hvVGVjbGFUZS9jbmljYVRlamFkb1RlamVyVGVqaWRvVGVsYVRlbGUvZm9ub1RlbWFUZW1vclRlbXBsb1RlbmF6VGVuZGVyVGVuZXJUZW5pc1RlbnNvVGVvcmkvYVRlcmFwaWFUZXJjb1RlL3JtaW5vVGVybnVyYVRlcnJvclRlc2lzVGVzb3JvVGVzdGlnb1RldGVyYVRleHRvVGV6VGliaW9UaWJ1cm8vblRpZW1wb1RpZW5kYVRpZXJyYVRpZXNvVGlncmVUaWplcmFUaWxkZVRpbWJyZVRpL21pZG9UaW1vVGludGFUaS9vVGkvcGljb1RpcG9UaXJhVGlyby9uVGl0YS9uVGkvdGVyZVRpL3R1bG9UaXphVG9hbGxhVG9iaWxsb1RvY2FyVG9jaW5vVG9kb1RvZ2FUb2xkb1RvbWFyVG9ub1RvbnRvVG9wYXJUb3BlVG9xdWVUby9yYXhUb3Jlcm9Ub3JtZW50YVRvcm5lb1Rvcm9Ub3JwZWRvVG9ycmVUb3Jzb1RvcnR1Z2FUb3NUb3Njb1Rvc2VyVG8veGljb1RyYWJham9UcmFjdG9yVHJhZXJUcmEvZmljb1RyYWdvVHJhamVUcmFtb1RyYW5jZVRyYXRvVHJhdW1hVHJhemFyVHJlL2JvbFRyZWd1YVRyZWludGFUcmVuVHJlcGFyVHJlc1RyaWJ1VHJpZ29UcmlwYVRyaXN0ZVRyaXVuZm9Ucm9mZW9Ucm9tcGFUcm9uY29Ucm9wYVRyb3RlVHJvem9UcnVjb1RydWVub1RydWZhVHViZXJpL2FUdWJvVHVlcnRvVHVtYmFUdW1vclR1L25lbFR1L25pY2FUdXJiaW5hVHVyaXNtb1R1cm5vVHV0b3JVYmljYXJVL2xjZXJhVW1icmFsVW5pZGFkVW5pclVuaXZlcnNvVW5vVW50YXJVfmFVcmJhbm9VcmJlVXJnZW50ZVVybmFVc2FyVXN1YXJpb1UvdGlsVXRvcGkvYVV2YVZhY2FWYWNpL29WYWN1bmFWYWdhclZhZ29WYWluYVZhamlsbGFWYWxlVmEvbGlkb1ZhbGxlVmFsb3JWYS9sdnVsYVZhbXBpcm9WYXJhVmFyaWFyVmFyby9uVmFzb1ZlY2lub1ZlY3RvclZlaGkvY3Vsb1ZlaW50ZVZlamV6VmVsYVZlbGVyb1ZlbG96VmVuYVZlbmNlclZlbmRhVmVuZW5vVmVuZ2FyVmVuaXJWZW50YVZlbnVzVmVyVmVyYW5vVmVyYm9WZXJkZVZlcmVkYVZlcmphVmVyc29WZXJ0ZXJWaS9hVmlhamVWaWJyYXJWaWNpb1ZpL2N0aW1hVmlkYVZpL2Rlb1ZpZHJpb1ZpZWpvVmllcm5lc1ZpZ29yVmlsVmlsbGFWaW5hZ3JlVmlub1ZpfmVkb1Zpb2xpL25WaXJhbFZpcmdvVmlydHVkVmlzb3JWaS9zcGVyYVZpc3RhVml0YW1pbmFWaXVkb1ZpdmF6Vml2ZXJvVml2aXJWaXZvVm9sY2EvblZvbHVtZW5Wb2x2ZXJWb3JhelZvdGFyVm90b1ZvelZ1ZWxvVnVsZ2FyWWFjZXJZYXRlWWVndWFZZW1hWWVybm9ZZXNvWW9kb1lvZ2FZb2d1clphZmlyb1phbmphWmFwYXRvWmFyemFab25hWm9ycm9adW1vWnVyZG9cIjtjb25zdCBsb29rdXA9e307bGV0IHdvcmRsaXN0JDI9bnVsbDtmdW5jdGlvbiBkcm9wRGlhY3JpdGljKHdvcmQpe2xvZ2dlciRrLmNoZWNrTm9ybWFsaXplKCk7cmV0dXJuIHRvVXRmOFN0cmluZyhBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodG9VdGY4Qnl0ZXMod29yZC5ub3JtYWxpemUoXCJORkRcIikudG9Mb3dlckNhc2UoKSksYz0+e3JldHVybiBjPj02NSYmYzw9OTB8fGM+PTk3JiZjPD0xMjN9KSl9ZnVuY3Rpb24gZXhwYW5kKHdvcmQpe2NvbnN0IG91dHB1dD1bXTtBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRvVXRmOEJ5dGVzKHdvcmQpLGM9PntpZihjPT09NDcpe291dHB1dC5wdXNoKDIwNCk7b3V0cHV0LnB1c2goMTI5KX1lbHNlIGlmKGM9PT0xMjYpe291dHB1dC5wdXNoKDExMCk7b3V0cHV0LnB1c2goMjA0KTtvdXRwdXQucHVzaCgxMzEpfWVsc2V7b3V0cHV0LnB1c2goYyl9fSk7cmV0dXJuIHRvVXRmOFN0cmluZyhvdXRwdXQpfWZ1bmN0aW9uIGxvYWRXb3JkcyQyKGxhbmcpe2lmKHdvcmRsaXN0JDIhPW51bGwpe3JldHVybn13b3JkbGlzdCQyPXdvcmRzJDIucmVwbGFjZSgvKFtBLVpdKS9nLFwiICQxXCIpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDEpLnNwbGl0KFwiIFwiKS5tYXAodz0+ZXhwYW5kKHcpKTt3b3JkbGlzdCQyLmZvckVhY2goKHdvcmQsaW5kZXgpPT57bG9va3VwW2Ryb3BEaWFjcml0aWMod29yZCldPWluZGV4fSk7aWYoV29yZGxpc3QuY2hlY2sobGFuZykhPT1cIjB4Zjc0ZmI3MDkyYWVhY2RmYmY4OTU5NTU3ZGUyMjA5OGRhNTEyMjA3ZmI5ZjEwOWNiNTI2OTk0OTM4Y2Y0MDMwMFwiKXt3b3JkbGlzdCQyPW51bGw7dGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGVzIChTcGFuaXNoKSBGQUlMRURcIil9fWNsYXNzIExhbmdFcyBleHRlbmRzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJlc1wiKX1nZXRXb3JkKGluZGV4KXtsb2FkV29yZHMkMih0aGlzKTtyZXR1cm4gd29yZGxpc3QkMltpbmRleF19Z2V0V29yZEluZGV4KHdvcmQpe2xvYWRXb3JkcyQyKHRoaXMpO3JldHVybiBsb29rdXBbZHJvcERpYWNyaXRpYyh3b3JkKV19fWNvbnN0IGxhbmdFcz1uZXcgTGFuZ0VzO1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdFcyk7XCJ1c2Ugc3RyaWN0XCI7Y29uc3Qgd29yZHMkMz1cIkFiYWlzc2VyQWJhbmRvbkFiZGlxdWVyQWJlaWxsZUFib2xpckFib3JkZXJBYm91dGlyQWJveWVyQWJyYXNpZkFicmV1dmVyQWJyaXRlckFicm9nZXJBYnJ1cHRBYnNlbmNlQWJzb2x1QWJzdXJkZUFidXNpZkFieXNzYWxBY2FkZS9taWVBY2Fqb3VBY2FyaWVuQWNjYWJsZXJBY2NlcHRlckFjY2xhbWVyQWNjb2xhZGVBY2Nyb2NoZUFjY3VzZXJBY2VyYmVBY2hhdEFjaGV0ZXJBY2lkdWxlckFjaWVyQWNvbXB0ZUFjcXVlL3JpckFjcm9ueW1lQWN0ZXVyQWN0aWZBY3R1ZWxBZGVwdGVBZGUvcXVhdEFkaGUvc2lmQWRqZWN0aWZBZGp1Z2VyQWRtZXR0cmVBZG1pcmVyQWRvcHRlckFkb3JlckFkb3VjaXJBZHJlc3NlQWRyb2l0QWR1bHRlQWR2ZXJiZUFlL3JlckFlL3JvbmVmQWZmYWlyZUFmZmVjdGVyQWZmaWNoZUFmZnJldXhBZmZ1YmxlckFnYWNlckFnZW5jZXJBZ2lsZUFnaXRlckFncmFmZXJBZ3JlL2FibGVBZ3J1bWVBaWRlckFpZ3VpbGxlQWlsaWVyQWltYWJsZUFpc2FuY2VBam91dGVyQWp1c3RlckFsYXJtZXJBbGNoaW1pZUFsZXJ0ZUFsZ2UtYnJlQWxndWVBbGllL25lckFsaW1lbnRBbGxlL2dlckFsbGlhZ2VBbGxvdWVyQWxsdW1lckFsb3VyZGlyQWxwYWdhQWx0ZXNzZUFsdmUvb2xlQW1hdGV1ckFtYmlndUFtYnJlQW1lL25hZ2VyQW1lcnR1bWVBbWlkb25BbWlyYWxBbW9yY2VyQW1vdXJBbW92aWJsZUFtcGhpYmllQW1wbGV1ckFtdXNhbnRBbmFseXNlQW5hcGhvcmVBbmFyY2hpZUFuYXRvbWllQW5jaWVuQW5lL2FudGlyQW5nbGVBbmdvaXNzZUFuZ3VsZXV4QW5pbWFsQW5uZXhlckFubm9uY2VBbm51ZWxBbm9kaW5Bbm9tYWxpZUFub255bWVBbm9ybWFsQW50ZW5uZUFudGlkb3RlQW54aWV1eEFwYWlzZXJBcGUvcml0aWZBcGxhbmlyQXBvbG9naWVBcHBhcmVpbEFwcGVsZXJBcHBvcnRlckFwcHV5ZXJBcXVhcml1bUFxdWVkdWNBcmJpdHJlQXJidXN0ZUFyZGV1ckFyZG9pc2VBcmdlbnRBcmxlcXVpbkFybWF0dXJlQXJtZW1lbnRBcm1vaXJlQXJtdXJlQXJwZW50ZXJBcnJhY2hlckFycml2ZXJBcnJvc2VyQXJzZW5pY0FydGUvcmllbEFydGljbGVBc3BlY3RBc3BoYWx0ZUFzcGlyZXJBc3NhdXRBc3NlcnZpckFzc2lldHRlQXNzb2NpZXJBc3N1cmVyQXN0aWNvdEFzdHJlQXN0dWNlQXRlbGllckF0b21lQXRyaXVtQXRyb2NlQXR0YXF1ZUF0dGVudGlmQXR0aXJlckF0dHJhcGVyQXViYWluZUF1YmVyZ2VBdWRhY2VBdWRpYmxlQXVndXJlckF1cm9yZUF1dG9tbmVBdXRydWNoZUF2YWxlckF2YW5jZXJBdmFyaWNlQXZlbmlyQXZlcnNlQXZldWdsZUF2aWF0ZXVyQXZpZGVBdmlvbkF2aXNlckF2b2luZUF2b3VlckF2cmlsQXhpYWxBeGlvbWVCYWRnZUJhZm91ZXJCYWdhZ2VCYWd1ZXR0ZUJhaWduYWRlQmFsYW5jZXJCYWxjb25CYWxlaW5lQmFsaXNhZ2VCYW1iaW5CYW5jYWlyZUJhbmRhZ2VCYW5saWV1ZUJhbm5pZS1yZUJhbnF1aWVyQmFyYmllckJhcmlsQmFyb25CYXJxdWVCYXJyYWdlQmFzc2luQmFzdGlvbkJhdGFpbGxlQmF0ZWF1QmF0dGVyaWVCYXVkcmllckJhdmFyZGVyQmVsZXR0ZUJlL2xpZXJCZWxvdGVCZS9uZS9maWNlQmVyY2VhdUJlcmdlckJlcmxpbmVCZXJtdWRhQmVzYWNlQmVzb2duZUJlL3RhaWxCZXVycmVCaWJlcm9uQmljeWNsZUJpZHVsZUJpam91QmlsYW5CaWxpbmd1ZUJpbGxhcmRCaW5haXJlQmlvbG9naWVCaW9wc2llQmlvdHlwZUJpc2N1aXRCaXNvbkJpc3RvdXJpQml0dW1lQml6YXJyZUJsYWZhcmRCbGFndWVCbGFuY2hpckJsZXNzYW50QmxpbmRlckJsb25kQmxvcXVlckJsb3Vzb25Cb2JhcmRCb2JpbmVCb2lyZUJvaXNlckJvbGlkZUJvbmJvbkJvbmRpckJvbmhldXJCb25pZmllckJvbnVzQm9yZHVyZUJvcm5lQm90dGVCb3VjbGVCb3VldXhCb3VnaWVCb3Vsb25Cb3VxdWluQm91cnNlQm91c3NvbGVCb3V0aXF1ZUJveGV1ckJyYW5jaGVCcmFzaWVyQnJhdmVCcmViaXNCcmUtY2hlQnJldXZhZ2VCcmljb2xlckJyaWdhZGVCcmlsbGFudEJyaW9jaGVCcmlxdWVCcm9jaHVyZUJyb2RlckJyb256ZXJCcm91c3NlQnJveWV1ckJydW1lQnJ1c3F1ZUJydXRhbEJydXlhbnRCdWZmbGVCdWlzc29uQnVsbGV0aW5CdXJlYXVCdXJpbkJ1c3RpZXJCdXRpbmVyQnV0b2lyQnV2YWJsZUJ1dmV0dGVDYWJhbm9uQ2FiaW5lQ2FjaGV0dGVDYWRlYXVDYWRyZUNhZmUvaW5lQ2FpbGxvdUNhaXNzb25DYWxjdWxlckNhbGVwaW5DYWxpYnJlQ2FsbWVyQ2Fsb21uaWVDYWx2YWlyZUNhbWFyYWRlQ2FtZS9yYUNhbWlvbkNhbXBhZ25lQ2FuYWxDYW5ldG9uQ2Fub25DYW50aW5lQ2FudWxhckNhcGFibGVDYXBvcmFsQ2FwcmljZUNhcHN1bGVDYXB0ZXJDYXB1Y2hlQ2FyYWJpbmVDYXJib25lQ2FyZXNzZXJDYXJpYm91Q2FybmFnZUNhcm90dGVDYXJyZWF1Q2FydG9uQ2FzY2FkZUNhc2llckNhc3F1ZUNhc3N1cmVDYXVzZXJDYXV0aW9uQ2F2YWxpZXJDYXZlcm5lQ2F2aWFyQ2UvZGlsbGVDZWludHVyZUNlL2xlc3RlQ2VsbHVsZUNlbmRyaWVyQ2Vuc3VyZXJDZW50cmFsQ2VyY2xlQ2UvcmUvYnJhbENlcmlzZUNlcm5lckNlcnZlYXVDZXNzZXJDaGFncmluQ2hhaXNlQ2hhbGV1ckNoYW1icmVDaGFuY2VDaGFwaXRyZUNoYXJib25DaGFzc2V1ckNoYXRvbkNoYXVzc29uQ2hhdmlyZXJDaGVtaXNlQ2hlbmlsbGVDaGUvcXVpZXJDaGVyY2hlckNoZXZhbENoaWVuQ2hpZmZyZUNoaWdub25DaGltZS1yZUNoaW90Q2hsb3J1cmVDaG9jb2xhdENob2lzaXJDaG9zZUNob3VldHRlQ2hyb21lQ2h1dGVDaWdhcmVDaWdvZ25lQ2ltZW50ZXJDaW5lL21hQ2ludHJlckNpcmN1bGVyQ2lyZXJDaXJxdWVDaXRlcm5lQ2l0b3llbkNpdHJvbkNpdmlsQ2xhaXJvbkNsYW1ldXJDbGFxdWVyQ2xhc3NlQ2xhdmllckNsaWVudENsaWduZXJDbGltYXRDbGl2YWdlQ2xvY2hlQ2xvbmFnZUNsb3BvcnRlQ29iYWx0Q29icmFDb2Nhc3NlQ29jb3RpZXJDb2RlckNvZGlmaWVyQ29mZnJlQ29nbmVyQ29oZS9zaW9uQ29pZmZlckNvaW5jZXJDb2xlLXJlQ29saWJyaUNvbGxpbmVDb2xtYXRlckNvbG9uZWxDb21iYXRDb21lL2RpZUNvbW1hbmRlQ29tcGFjdENvbmNlcnRDb25kdWlyZUNvbmZpZXJDb25nZWxlckNvbm5vdGVyQ29uc29ubmVDb250YWN0Q29udmV4ZUNvcGFpbkNvcGllQ29yYWlsQ29yYmVhdUNvcmRhZ2VDb3JuaWNoZUNvcnB1c0NvcnJlY3RDb3J0ZS1nZUNvc21pcXVlQ29zdHVtZUNvdG9uQ291ZGVDb3VwdXJlQ291cmFnZUNvdXRlYXVDb3V2cmlyQ295b3RlQ3JhYmVDcmFpbnRlQ3JhdmF0ZUNyYXlvbkNyZS9hdHVyZUNyZS9kaXRlckNyZS9tZXV4Q3JldXNlckNyZXZldHRlQ3JpYmxlckNyaWVyQ3Jpc3RhbENyaXRlLXJlQ3JvaXJlQ3JvcXVlckNyb3RhbGVDcnVjaWFsQ3J1ZWxDcnlwdGVyQ3ViaXF1ZUN1ZWlsbGlyQ3VpbGxlLXJlQ3Vpc2luZUN1aXZyZUN1bG1pbmVyQ3VsdGl2ZXJDdW11bGVyQ3VwaWRlQ3VyYXRpZkN1cnNldXJDeWFudXJlQ3ljbGVDeWxpbmRyZUN5bmlxdWVEYWlnbmVyRGFtaWVyRGFuZ2VyRGFuc2V1ckRhdXBoaW5EZS9iYXR0cmVEZS9iaXRlckRlL2JvcmRlckRlL2JyaWRlckRlL2J1dGFudERlL2NhbGVyRGUvY2VtYnJlRGUvY2hpcmVyRGUvY2lkZXJEZS9jbGFyZXJEZS9jb3JlckRlL2NyaXJlRGUvY3VwbGVyRGUvZGFsZURlL2R1Y3RpZkRlL2Vzc2VEZS9mZW5zaWZEZS9maWxlckRlL2ZyYXllckRlL2dhZ2VyRGUvZ2l2cmVyRGUvZ2x1dGlyRGUvZ3JhZmVyRGUvamV1bmVyRGUvbGljZURlL2xvZ2VyRGVtYW5kZXJEZW1ldXJlckRlL21vbGlyRGUvbmljaGVyRGUvbm91ZXJEZW50ZWxsZURlL251ZGVyRGUvcGFydERlL3BlbnNlckRlL3BoYXNlckRlL3BsYWNlckRlL3Bvc2VyRGUvcmFuZ2VyRGUvcm9iZXJEZS9zYXN0cmVEZXNjZW50ZURlL3NlcnREZS9zaWduZXJEZS9zb2JlL2lyRGVzc2luZXJEZXN0cmllckRlL3RhY2hlckRlL3Rlc3RlckRlL3RvdXJlckRlL3RyZXNzZURldmFuY2VyRGV2ZW5pckRldmluZXJEZXZvaXJEaWFibGVEaWFsb2d1ZURpYW1hbnREaWN0ZXJEaWZmZS9yZXJEaWdlL3JlckRpZ2l0YWxEaWduZURpbHVlckRpbWFuY2hlRGltaW51ZXJEaW94eWRlRGlyZWN0aWZEaXJpZ2VyRGlzY3V0ZXJEaXNwb3NlckRpc3NpcGVyRGlzdGFuY2VEaXZlcnRpckRpdmlzZXJEb2NpbGVEb2N0ZXVyRG9nbWVEb2lndERvbWFpbmVEb21pY2lsZURvbXB0ZXJEb25hdGV1ckRvbmpvbkRvbm5lckRvcGFtaW5lRG9ydG9pckRvcnVyZURvc2FnZURvc2V1ckRvc3NpZXJEb3RhdGlvbkRvdWFuaWVyRG91YmxlRG91Y2V1ckRvdXRlckRveWVuRHJhZ29uRHJhcGVyRHJlc3NlckRyaWJibGVyRHJvaXR1cmVEdXBlcmllRHVwbGV4ZUR1cmFibGVEdXJjaXJEeW5hc3RpZUUvYmxvdWlyRS9jYXJ0ZXJFL2NoYXJwZUUvY2hlbGxlRS9jbGFpcmVyRS9jbGlwc2VFL2Nsb3JlRS9jbHVzZUUvY29sZUUvY29ub21pZUUvY29yY2VFL2NvdXRlckUvY3Jhc2VyRS9jcmUvbWVyRS9jcml2YWluRS9jcm91RS9jdW1lRS9jdXJldWlsRS9kaWZpZXJFL2R1cXVlckVmZmFjZXJFZmZlY3RpZkVmZmlnaWVFZmZvcnRFZmZyYXllckVmZnVzaW9uRS9nYWxpc2VyRS9nYXJlckUvamVjdGVyRS9sYWJvcmVyRS9sYXJnaXJFL2xlY3Ryb25FL2xlL2dhbnRFL2xlL3BoYW50RS9sZS12ZUUvbGlnaWJsZUUvbGl0aXNtZUUvbG9nZUUvbHVjaWRlckUvbHVkZXJFbWJhbGxlckVtYmVsbGlyRW1icnlvbkUvbWVyYXVkZUUvbWlzc2lvbkVtbWVuZXJFL21vdGlvbkUvbW91dm9pckVtcGVyZXVyRW1wbG95ZXJFbXBvcnRlckVtcHJpc2VFL211bHNpb25FbmNhZHJlckVuY2hlLXJlRW5jbGF2ZUVuY29jaGVFbmRpZ3VlckVuZG9zc2VyRW5kcm9pdEVuZHVpcmVFL25lcmdpZUVuZmFuY2VFbmZlcm1lckVuZm91aXJFbmdhZ2VyRW5naW5Fbmdsb2JlckUvbmlnbWVFbmphbWJlckVuamV1RW5sZXZlckVubmVtaUVubnV5ZXV4RW5yaWNoaXJFbnJvYmFnZUVuc2VpZ25lRW50YXNzZXJFbnRlbmRyZUVudGllckVudG91cmVyRW50cmF2ZXJFL251bWUvcmVyRW52YWhpckVudmlhYmxlRW52b3llckVuenltZUUvb2xpZW5FL3BhaXNzaXJFL3BhcmduZUUvcGF0YW50RS9wYXVsZUUvcGljZXJpZUUvcGlkZS9taWVFL3BpZXJFL3BpbG9ndWVFL3BpbmVFL3Bpc29kZUUvcGl0YXBoZUUvcG9xdWVFL3ByZXV2ZUUvcHJvdXZlckUvcHVpc2FudEUvcXVlcnJlRS9xdWlwZUUvcmlnZXJFL3Jvc2lvbkVycmV1ckUvcnVwdGlvbkVzY2FsaWVyRXNwYWRvbkVzcGUtY2VFc3BpZS1nbGVFc3BvaXJFc3ByaXRFc3F1aXZlckVzc2F5ZXJFc3NlbmNlRXNzaWV1RXNzb3JlckVzdGltZUVzdG9tYWNFc3RyYWRlRS90YWdlLXJlRS90YWxlckUvdGFuY2hlRS90YXRpcXVlRS90ZWluZHJlRS90ZW5kb2lyRS90ZXJuZWxFL3RoYW5vbEUvdGhpcXVlRXRobmllRS90aXJlckUvdG9mZmVyRS90b2lsZUUvdG9ubmFudEUvdG91cmRpckUvdHJhbmdlRS90cm9pdEUvdHVkZUV1cGhvcmllRS92YWx1ZXJFL3Zhc2lvbkUvdmVudGFpbEUvdmlkZW5jZUUvdml0ZXJFL3ZvbHV0aWZFL3ZvcXVlckV4YWN0RXhhZ2UvcmVyRXhhdWNlckV4Y2VsbGVyRXhjaXRhbnRFeGNsdXNpZkV4Y3VzZUV4ZS9jdXRlckV4ZW1wbGVFeGVyY2VyRXhoYWxlckV4aG9ydGVyRXhpZ2VuY2VFeGlsZXJFeGlzdGVyRXhvdGlxdWVFeHBlL2RpZXJFeHBsb3JlckV4cG9zZXJFeHByaW1lckV4cXVpc0V4dGVuc2lmRXh0cmFpcmVFeHVsdGVyRmFibGVGYWJ1bGV1eEZhY2V0dGVGYWNpbGVGYWN0dXJlRmFpYmxpckZhbGFpc2VGYW1ldXhGYW1pbGxlRmFyY2V1ckZhcmZlbHVGYXJpbmVGYXJvdWNoZUZhc2NpbmVyRmF0YWxGYXRpZ3VlRmF1Y29uRmF1dGlmRmF2ZXVyRmF2b3JpRmUvYnJpbGVGZS9jb25kZXJGZS9kZS9yZXJGZS9saW5GZW1tZUZlL211ckZlbmRvaXJGZS9vZGFsRmVybWVyRmUvcm9jZUZlcnZldXJGZXN0aXZhbEZldWlsbGVGZXV0cmVGZS92cmllckZpYXNjb0ZpY2VsZXJGaWN0aWZGaWRlLWxlRmlndXJlRmlsYXR1cmVGaWxldGFnZUZpbGllLXJlRmlsbGV1bEZpbG1lckZpbG91RmlsdHJlckZpbmFuY2VyRmluaXJGaW9sZUZpcm1lRmlzc3VyZUZpeGVyRmxhaXJlckZsYW1tZUZsYXNxdWVGbGF0dGV1ckZsZS9hdUZsZS1jaGVGbGV1ckZsZXhpb25GbG9jb25GbG9yZUZsdWN0dWVyRmx1aWRlRmx1dmlhbEZvbGllRm9uZGVyaWVGb25naWJsZUZvbnRhaW5lRm9yY2VyRm9yZ2Vyb25Gb3JtdWxlckZvcnR1bmVGb3NzaWxlRm91ZHJlRm91Z2UtcmVGb3VpbGxlckZvdWx1cmVGb3VybWlGcmFnaWxlRnJhaXNlRnJhbmNoaXJGcmFwcGVyRnJheWV1ckZyZS9nYXRlRnJlaW5lckZyZWxvbkZyZS9taXJGcmUvbmUvc2llRnJlLXJlRnJpYWJsZUZyaWN0aW9uRnJpc3NvbkZyaXZvbGVGcm9pZEZyb21hZ2VGcm9udGFsRnJvdHRlckZydWl0RnVnaXRpZkZ1aXRlRnVyZXVyRnVyaWV1eEZ1cnRpZkZ1c2lvbkZ1dHVyR2FnbmVyR2FsYXhpZUdhbGVyaWVHYW1iYWRlckdhcmFudGlyR2FyZGllbkdhcm5pckdhcnJpZ3VlR2F6ZWxsZUdhem9uR2UvYW50R2UvbGF0aW5lR2UvbHVsZUdlbmRhcm1lR2UvbmUvcmFsR2UvbmllR2Vub3VHZW50aWxHZS9vbG9naWVHZS9vbWUtdHJlR2UvcmFuaXVtR2VybWVHZXN0dWVsR2V5c2VyR2liaWVyR2ljbGVyR2lyYWZlR2l2cmVHbGFjZUdsYWl2ZUdsaXNzZXJHbG9iZUdsb2lyZUdsb3JpZXV4R29sZmV1ckdvbW1lR29uZmxlckdvcmdlR29yaWxsZUdvdWRyb25Hb3VmZnJlR291bG90R291cGlsbGVHb3VybWFuZEdvdXR0ZUdyYWR1ZWxHcmFmZml0aUdyYWluZUdyYW5kR3JhcHBpbkdyYXR1aXRHcmF2aXJHcmVuYXRHcmlmZnVyZUdyaWxsZXJHcmltcGVyR3JvZ25lckdyb25kZXJHcm90dGVHcm91cGVHcnVnZXJHcnV0aWVyR3J1eWUtcmVHdWUvcGFyZEd1ZXJyaWVyR3VpZGVHdWltYXV2ZUd1aXRhcmVHdXN0YXRpZkd5bW5hc3RlR3lyb3N0YXRIYWJpdHVkZUhhY2hvaXJIYWx0ZUhhbWVhdUhhbmdhckhhbm5ldG9uSGFyaWNvdEhhcm1vbmllSGFycG9uSGFzYXJkSGUvbGl1bUhlL21hdG9tZUhlcmJlSGUvcmlzc29uSGVybWluZUhlL3JvbkhlL3NpdGVySGV1cmV1eEhpYmVybmVySGlib3VIaWxhcmFudEhpc3RvaXJlSGl2ZXJIb21hcmRIb21tYWdlSG9tb2dlLW5lSG9ubmV1ckhvbm9yZXJIb250ZXV4SG9yZGVIb3Jpem9uSG9ybG9nZUhvcm1vbmVIb3JyaWJsZUhvdWxldXhIb3Vzc2VIdWJsb3RIdWlsZXV4SHVtYWluSHVtYmxlSHVtaWRlSHVtb3VySHVybGVySHlkcm9tZWxIeWdpZS1uZUh5bW5lSHlwbm9zZUlkeWxsZUlnbm9yZXJJZ3VhbmVJbGxpY2l0ZUlsbHVzaW9uSW1hZ2VJbWJpYmVySW1pdGVySW1tZW5zZUltbW9iaWxlSW1tdWFibGVJbXBhY3RJbXBlL3JpYWxJbXBsb3JlckltcG9zZXJJbXByaW1lckltcHV0ZXJJbmNhcm5lckluY2VuZGllSW5jaWRlbnRJbmNsaW5lckluY29sb3JlSW5kZXhlckluZGljZUluZHVjdGlmSW5lL2RpdEluZXB0aWVJbmV4YWN0SW5maW5pSW5mbGlnZXJJbmZvcm1lckluZnVzaW9uSW5nZS9yZXJJbmhhbGVySW5oaWJlckluamVjdGVySW5qdXJlSW5ub2NlbnRJbm9jdWxlcklub25kZXJJbnNjcmlyZUluc2VjdGVJbnNpZ25lSW5zb2xpdGVJbnNwaXJlckluc3RpbmN0SW5zdWx0ZXJJbnRhY3RJbnRlbnNlSW50aW1lSW50cmlndWVJbnR1aXRpZkludXRpbGVJbnZhc2lvbkludmVudGVySW52aXRlckludm9xdWVySXJvbmlxdWVJcnJhZGllcklycmUvZWxJcnJpdGVySXNvbGVySXZvaXJlSXZyZXNzZUphZ3VhckphaWxsaXJKYW1iZUphbnZpZXJKYXJkaW5KYXVnZXJKYXVuZUphdmVsb3RKZXRhYmxlSmV0b25KZXVkaUpldW5lc3NlSm9pbmRyZUpvbmNoZXJKb25nbGVySm91ZXVySm91aXNzaWZKb3VybmFsSm92aWFsSm95YXVKb3lldXhKdWJpbGVySnVnZW1lbnRKdW5pb3JKdXBvbkp1cmlzdGVKdXN0aWNlSnV0ZXV4SnV2ZS9uaWxlS2F5YWtLaW1vbm9LaW9zcXVlTGFiZWxMYWJpYWxMYWJvdXJlckxhY2UvcmVyTGFjdG9zZUxhZ3VuZUxhaW5lTGFpc3NlckxhaXRpZXJMYW1iZWF1TGFtZWxsZUxhbXBlTGFuY2V1ckxhbmdhZ2VMYW50ZXJuZUxhcGluTGFyZ2V1ckxhcm1lTGF1cmllckxhdmFib0xhdm9pckxlY3R1cmVMZS9nYWxMZS9nZXJMZS9ndW1lTGVzc2l2ZUxldHRyZUxldmllckxleGlxdWVMZS96YXJkTGlhc3NlTGliZS9yZXJMaWJyZUxpY2VuY2VMaWNvcm5lTGllLWdlTGllLXZyZUxpZ2F0dXJlTGlnb3RlckxpZ3VlTGltZXJMaW1pdGVMaW1vbmFkZUxpbXBpZGVMaW5lL2FpcmVMaW5nb3RMaW9uY2VhdUxpcXVpZGVMaXNpZS1yZUxpc3RlckxpdGhpdW1MaXRpZ2VMaXR0b3JhbExpdnJldXJMb2dpcXVlTG9pbnRhaW5Mb2lzaXJMb21icmljTG90ZXJpZUxvdWVyTG91cmRMb3V0cmVMb3V2ZUxveWFsTHViaWVMdWNpZGVMdWNyYXRpZkx1ZXVyTHVndWJyZUx1aXNhbnRMdW1pZS1yZUx1bmFpcmVMdW5kaUx1cm9uTHV0dGVyTHV4dWV1eE1hY2hpbmVNYWdhc2luTWFnZW50YU1hZ2lxdWVNYWlncmVNYWlsbG9uTWFpbnRpZW5NYWlyaWVNYWlzb25NYWpvcmVyTWFsYXhlck1hbGUvZmljZU1hbGhldXJNYWxpY2VNYWxsZXR0ZU1hbW1vdXRoTWFuZGF0ZXJNYW5pYWJsZU1hbnF1YW50TWFudGVhdU1hbnVlbE1hcmF0aG9uTWFyYnJlTWFyY2hhbmRNYXJkaU1hcml0aW1lTWFycXVldXJNYXJyb25NYXJ0ZWxlck1hc2NvdHRlTWFzc2lmTWF0ZS9yaWVsTWF0aWUtcmVNYXRyYXF1ZU1hdWRpcmVNYXVzc2FkZU1hdXZlTWF4aW1hbE1lL2NoYW50TWUvY29ubnVNZS9kYWlsbGVNZS9kZWNpbk1lL2RpdGVyTWUvZHVzZU1laWxsZXVyTWUvbGFuZ2VNZS9sb2RpZU1lbWJyZU1lL21vaXJlTWVuYWNlck1lbmVyTWVuaGlyTWVuc29uZ2VNZW50b3JNZXJjcmVkaU1lL3JpdGVNZXJsZU1lc3NhZ2VyTWVzdXJlTWUvdGFsTWUvdGUvb3JlTWUvdGhvZGVNZS90aWVyTWV1YmxlTWlhdWxlck1pY3JvYmVNaWV0dGVNaWdub25NaWdyZXJNaWxpZXVNaWxsaW9uTWltaXF1ZU1pbmNlTWluZS9yYWxNaW5pbWFsTWlub3Jlck1pbnV0ZU1pcmFjbGVNaXJvaXRlck1pc3NpbGVNaXh0ZU1vYmlsZU1vZGVybmVNb2VsbGV1eE1vbmRpYWxNb25pdGV1ck1vbm5haWVNb25vdG9uZU1vbnN0cmVNb250YWduZU1vbnVtZW50TW9xdWV1ck1vcmNlYXVNb3JzdXJlTW9ydGllck1vdGV1ck1vdGlmTW91Y2hlTW91ZmxlTW91bGluTW91c3Nvbk1vdXRvbk1vdXZhbnRNdWx0aXBsZU11bml0aW9uTXVyYWlsbGVNdXJlLW5lTXVybXVyZU11c2NsZU11c2UvdW1NdXNpY2llbk11dGF0aW9uTXV0ZXJNdXR1ZWxNeXJpYWRlTXlydGlsbGVNeXN0ZS1yZU15dGhpcXVlTmFnZXVyTmFwcGVOYXJxdW9pc05hcnJlck5hdGF0aW9uTmF0aW9uTmF0dXJlTmF1ZnJhZ2VOYXV0aXF1ZU5hdmlyZU5lL2J1bGV1eE5lY3Rhck5lL2Zhc3RlTmUvZ2F0aW9uTmUvZ2xpZ2VyTmUvZ29jaWVyTmVpZ2VOZXJ2ZXV4TmV0dG95ZXJOZXVyb25lTmV1dHJvbk5ldmV1TmljaGVOaWNrZWxOaXRyYXRlTml2ZWF1Tm9ibGVOb2NpZk5vY3R1cm5lTm9pcmNldXJOb2lzZXR0ZU5vbWFkZU5vbWJyZXV4Tm9tbWVyTm9ybWF0aWZOb3RhYmxlTm90aWZpZXJOb3RvaXJlTm91cnJpck5vdXZlYXVOb3ZhdGV1ck5vdmVtYnJlTm92aWNlTnVhZ2VOdWFuY2VyTnVpcmVOdWlzaWJsZU51bWUvcm9OdXB0aWFsTnVxdWVOdXRyaXRpZk9iZS9pck9iamVjdGlmT2JsaWdlck9ic2N1ck9ic2VydmVyT2JzdGFjbGVPYnRlbmlyT2J0dXJlck9jY2FzaW9uT2NjdXBlck9jZS9hbk9jdG9icmVPY3Ryb3llck9jdHVwbGVyT2N1bGFpcmVPZGV1ck9kb3JhbnRPZmZlbnNlck9mZmljaWVyT2ZmcmlyT2dpdmVPaXNlYXVPaXNpbGxvbk9sZmFjdGlmT2xpdmllck9tYnJhZ2VPbWV0dHJlT25jdHVldXhPbmR1bGVyT25lL3JldXhPbmlyaXF1ZU9wYWxlT3BhcXVlT3BlL3Jlck9waW5pb25PcHBvcnR1bk9wcHJpbWVyT3B0ZXJPcHRpcXVlT3JhZ2V1eE9yYW5nZU9yYml0ZU9yZG9ubmVyT3JlaWxsZU9yZ2FuZU9yZ3VlaWxPcmlmaWNlT3JuZW1lbnRPcnF1ZU9ydGllT3NjaWxsZXJPc21vc2VPc3NhdHVyZU90YXJpZU91cmFnYW5PdXJzb25PdXRpbE91dHJhZ2VyT3V2cmFnZU92YXRpb25PeHlkZU94eWdlLW5lT3pvbmVQYWlzaWJsZVBhbGFjZVBhbG1hcmUtc1BhbG91cmRlUGFscGVyUGFuYWNoZVBhbmRhUGFuZ29saW5QYW5pcXVlclBhbm5lYXVQYW5vcmFtYVBhbnRhbG9uUGFwYXllUGFwaWVyUGFwb3RlclBhcHlydXNQYXJhZG94ZVBhcmNlbGxlUGFyZXNzZVBhcmZ1bWVyUGFybGVyUGFyb2xlUGFycmFpblBhcnNlbWVyUGFydGFnZXJQYXJ1cmVQYXJ2ZW5pclBhc3Npb25QYXN0ZS1xdWVQYXRlcm5lbFBhdGllbmNlUGF0cm9uUGF2aWxsb25QYXZvaXNlclBheWVyUGF5c2FnZVBlaWduZVBlaW50cmVQZWxhZ2VQZS9saWNhblBlbGxlUGVsb3VzZVBlbHVjaGVQZW5kdWxlUGUvbmUvdHJlclBlL25pYmxlUGVuc2lmUGUvbnVyaWVQZS9waXRlUGUvcGx1bVBlcmRyaXhQZXJmb3JlclBlL3Jpb2RlUGVybXV0ZXJQZXJwbGV4ZVBlcnNpbFBlcnRlUGVzZXJQZS90YWxlUGV0aXRQZS90cmlyUGV1cGxlUGhhcmFvblBob2JpZVBob3F1ZVBob3RvblBocmFzZVBoeXNpcXVlUGlhbm9QaWN0dXJhbFBpZS1jZVBpZXJyZVBpZXV2cmVQaWxvdGVQaW5jZWF1UGlwZXR0ZVBpcXVlclBpcm9ndWVQaXNjaW5lUGlzdG9uUGl2b3RlclBpeGVsUGl6emFQbGFjYXJkUGxhZm9uZFBsYWlzaXJQbGFuZXJQbGFxdWVQbGFzdHJvblBsYXRlYXVQbGV1cmVyUGxleHVzUGxpYWdlUGxvbWJQbG9uZ2VyUGx1aWVQbHVtYWdlUG9jaGV0dGVQb2Uvc2llUG9lLXRlUG9pbnRlUG9pcmllclBvaXNzb25Qb2l2cmVQb2xhaXJlUG9saWNpZXJQb2xsZW5Qb2x5Z29uZVBvbW1hZGVQb21waWVyUG9uY3R1ZWxQb25kZS9yZXJQb25leVBvcnRpcXVlUG9zaXRpb25Qb3NzZS9kZXJQb3N0dXJlUG90YWdlclBvdGVhdVBvdGlvblBvdWNlUG91bGFpblBvdW1vblBvdXJwcmVQb3Vzc2luUG91dm9pclByYWlyaWVQcmF0aXF1ZVByZS9jaWV1eFByZS9kaXJlUHJlL2ZpeGVQcmUvbHVkZVByZS9ub21QcmUvc2VuY2VQcmUvdGV4dGVQcmUvdm9pclByaW1pdGlmUHJpbmNlUHJpc29uUHJpdmVyUHJvYmxlLW1lUHJvY2UvZGVyUHJvZGlnZVByb2ZvbmRQcm9ncmUtc1Byb2llUHJvamV0ZXJQcm9sb2d1ZVByb21lbmVyUHJvcHJlUHJvc3BlLXJlUHJvdGUvZ2VyUHJvdWVzc2VQcm92ZXJiZVBydWRlbmNlUHJ1bmVhdVBzeWNob3NlUHVibGljUHVjZXJvblB1aXNlclB1bHBlUHVsc2FyUHVuYWlzZVB1bml0aWZQdXBpdHJlUHVyaWZpZXJQdXp6bGVQeXJhbWlkZVF1YXNhclF1ZXJlbGxlUXVlc3Rpb25RdWllL3R1ZGVRdWl0dGVyUXVvdGllbnRSYWNpbmVSYWNvbnRlclJhZGlldXhSYWdvbmRpblJhaWRldXJSYWlzaW5SYWxlbnRpclJhbGxvbmdlUmFtYXNzZXJSYXBpZGVSYXNhZ2VSYXRpc3NlclJhdmFnZXJSYXZpblJheW9ubmVyUmUvYWN0aWZSZS9hZ2lyUmUvYWxpc2VyUmUvYW5pbWVyUmVjZXZvaXJSZS9jaXRlclJlL2NsYW1lclJlL2NvbHRlclJlY3J1dGVyUmVjdWxlclJlY3ljbGVyUmUvZGlnZXJSZWRvdXRlclJlZmFpcmVSZS9mbGV4ZVJlL2Zvcm1lclJlZnJhaW5SZWZ1Z2VSZS9nYWxpZW5SZS9naW9uUmUvZ2xhZ2VSZS9ndWxpZXJSZS9pdGUvcmVyUmVqZXRlclJlam91ZXJSZWxhdGlmUmVsZXZlclJlbGllZlJlbWFycXVlUmVtZS1kZVJlbWlzZVJlbW9udGVyUmVtcGxpclJlbXVlclJlbmFyZFJlbmZvcnRSZW5pZmxlclJlbm9uY2VyUmVudHJlclJlbnZvaVJlcGxpZXJSZXBvcnRlclJlcHJpc2VSZXB0aWxlUmVxdWluUmUvc2VydmVSZS9zaW5ldXhSZS9zb3VkcmVSZXNwZWN0UmVzdGVyUmUvc3VsdGF0UmUvdGFibGlyUmV0ZW5pclJlL3RpY3VsZVJldG9tYmVyUmV0cmFjZXJSZS91bmlvblJlL3Vzc2lyUmV2YW5jaGVSZXZpdnJlUmUvdm9sdGVSZS92dWxzaWZSaWNoZXNzZVJpZGVhdVJpZXVyUmlnaWRlUmlnb2xlclJpbmNlclJpcG9zdGVyUmlzaWJsZVJpc3F1ZVJpdHVlbFJpdmFsUml2aWUtcmVSb2NoZXV4Um9tYW5jZVJvbXByZVJvbmNlUm9uZGluUm9zZWF1Um9zaWVyUm90YXRpZlJvdG9yUm90dWxlUm91Z2VSb3VpbGxlUm91bGVhdVJvdXRpbmVSb3lhdW1lUnViYW5SdWJpc1J1Y2hlUnVlbGxlUnVndWV1eFJ1aW5lclJ1aXNzZWF1UnVzZXJSdXN0aXF1ZVJ5dGhtZVNhYmxlclNhYm90ZXJTYWJyZVNhY29jaGVTYWZhcmlTYWdlc3NlU2Fpc2lyU2FsYWRlU2FsaXZlU2Fsb25TYWx1ZXJTYW1lZGlTYW5jdGlvblNhbmdsaWVyU2FyY2FzbWVTYXJkaW5lU2F0dXJlclNhdWdyZW51U2F1bW9uU2F1dGVyU2F1dmFnZVNhdmFudFNhdm9ubmVyU2NhbHBlbFNjYW5kYWxlU2NlL2xlL3JhdFNjZS9uYXJpb1NjZXB0cmVTY2hlL21hU2NpZW5jZVNjaW5kZXJTY29yZVNjcnV0aW5TY3VscHRlclNlL2FuY2VTZS9jYWJsZVNlL2NoZXJTZWNvdWVyU2UvY3JlL3RlclNlL2RhdGlmU2UvZHVpcmVTZWlnbmV1clNlL2pvdXJTZS9sZWN0aWZTZW1haW5lU2VtYmxlclNlbWVuY2VTZS9taW5hbFNlL25hdGV1clNlbnNpYmxlU2VudGVuY2VTZS9wYXJlclNlL3F1ZW5jZVNlcmVpblNlcmdlbnRTZS9yaWV1eFNlcnJ1cmVTZS9ydW1TZXJ2aWNlU2Uvc2FtZVNlL3ZpclNldnJhZ2VTZXh0dXBsZVNpZGUvcmFsU2llLWNsZVNpZS9nZXJTaWZmbGVyU2lnbGVTaWduYWxTaWxlbmNlU2lsaWNpdW1TaW1wbGVTaW5jZS1yZVNpbmlzdHJlU2lwaG9uU2lyb3BTaXNtaXF1ZVNpdHVlclNraWVyU29jaWFsU29jbGVTb2RpdW1Tb2lnbmV1eFNvbGRhdFNvbGVpbFNvbGl0dWRlU29sdWJsZVNvbWJyZVNvbW1laWxTb21ub2xlclNvbmRlU29uZ2V1clNvbm5ldHRlU29ub3JlU29yY2llclNvcnRpclNvc2llU290dGlzZVNvdWNpZXV4U291ZHVyZVNvdWZmbGVTb3VsZXZlclNvdXBhcGVTb3VyY2VTb3V0aXJlclNvdXZlbmlyU3BhY2lldXhTcGF0aWFsU3BlL2NpYWxTcGhlLXJlU3BpcmFsU3RhYmxlU3RhdGlvblN0ZXJudW1TdGltdWx1c1N0aXB1bGVyU3RyaWN0U3R1ZGlldXhTdHVwZXVyU3R5bGlzdGVTdWJsaW1lU3Vic3RyYXRTdWJ0aWxTdWJ2ZW5pclN1Y2NlLXNTdWNyZVN1ZmZpeGVTdWdnZS9yZXJTdWl2ZXVyU3VsZmF0ZVN1cGVyYmVTdXBwbGllclN1cmZhY2VTdXJpY2F0ZVN1cm1lbmVyU3VycHJpc2VTdXJzYXV0U3VydmllU3VzcGVjdFN5bGxhYmVTeW1ib2xlU3ltZS90cmllU3luYXBzZVN5bnRheGVTeXN0ZS1tZVRhYmFjVGFibGllclRhY3RpbGVUYWlsbGVyVGFsZW50VGFsaXNtYW5UYWxvbm5lclRhbWJvdXJUYW1pc2VyVGFuZ2libGVUYXBpc1RhcXVpbmVyVGFyZGVyVGFyaWZUYXJ0aW5lVGFzc2VUYXRhbWlUYXRvdWFnZVRhdXBlVGF1cmVhdVRheGVyVGUvbW9pblRlbXBvcmVsVGVuYWlsbGVUZW5kcmVUZW5ldXJUZW5pclRlbnNpb25UZXJtaW5lclRlcm5lVGVycmlibGVUZS90aW5lVGV4dGVUaGUtbWVUaGUvb3JpZVRoZS9yYXBpZVRob3JheFRpYmlhVGllLWRlVGltaWRlVGlyZWxpcmVUaXJvaXJUaXNzdVRpdGFuZVRpdHJlVGl0dWJlclRvYm9nZ2FuVG9sZS9yYW50VG9tYXRlVG9uaXF1ZVRvbm5lYXVUb3BvbnltZVRvcmNoZVRvcmRyZVRvcm5hZGVUb3JwaWxsZVRvcnJlbnRUb3JzZVRvcnR1ZVRvdGVtVG91Y2hlclRvdXJuYWdlVG91c3NlclRveGluZVRyYWN0aW9uVHJhZmljVHJhZ2lxdWVUcmFoaXJUcmFpblRyYW5jaGVyVHJhdmFpbFRyZS1mbGVUcmVtcGVyVHJlL3NvclRyZXVpbFRyaWFnZVRyaWJ1bmFsVHJpY290ZXJUcmlsb2dpZVRyaW9tcGhlVHJpcGxlclRyaXR1cmVyVHJpdmlhbFRyb21ib25lVHJvbmNUcm9waWNhbFRyb3VwZWF1VHVpbGVUdWxpcGVUdW11bHRlVHVubmVsVHVyYmluZVR1dGV1clR1dG95ZXJUdXlhdVR5bXBhblR5cGhvblR5cGlxdWVUeXJhblVidWVzcXVlVWx0aW1lVWx0cmFzb25VbmFuaW1lVW5pZmllclVuaW9uVW5pcXVlVW5pdGFpcmVVbml2ZXJzVXJhbml1bVVyYmFpblVydGljYW50VXNhZ2VVc2luZVVzdWVsVXN1cmVVdGlsZVV0b3BpZVZhY2FybWVWYWNjaW5WYWdhYm9uZFZhZ3VlVmFpbGxhbnRWYWluY3JlVmFpc3NlYXVWYWxhYmxlVmFsaXNlVmFsbG9uVmFsdmVWYW1waXJlVmFuaWxsZVZhcGV1clZhcmllclZhc2V1eFZhc3NhbFZhc3RlVmVjdGV1clZlZGV0dGVWZS9nZS90YWxWZS9oaWN1bGVWZWluYXJkVmUvbG9jZVZlbmRyZWRpVmUvbmUvcmVyVmVuZ2VyVmVuaW1ldXhWZW50b3VzZVZlcmR1cmVWZS9yaW5WZXJuaXJWZXJyb3VWZXJzZXJWZXJ0dVZlc3RvblZlL3RlL3JhblZlL3R1c3RlVmV4YW50VmV4ZXJWaWFkdWNWaWFuZGVWaWN0b2lyZVZpZGFuZ2VWaWRlL29WaWduZXR0ZVZpZ3VldXJWaWxhaW5WaWxsYWdlVmluYWlncmVWaW9sb25WaXBlLXJlVmlyZW1lbnRWaXJ0dW9zZVZpcnVzVmlzYWdlVmlzZXVyVmlzaW9uVmlzcXVldXhWaXN1ZWxWaXRhbFZpdGVzc2VWaXRpY29sZVZpdHJpbmVWaXZhY2VWaXZpcGFyZVZvY2F0aW9uVm9ndWVyVm9pbGVWb2lzaW5Wb2l0dXJlVm9sYWlsbGVWb2xjYW5Wb2x0aWdlclZvbHVtZVZvcmFjZVZvcnRleFZvdGVyVm91bG9pclZveWFnZVZveWVsbGVXYWdvblhlL25vbllhY2h0WmUtYnJlWmUvbml0aFplc3RlWm9vbG9naWVcIjtsZXQgd29yZGxpc3QkMz1udWxsO2NvbnN0IGxvb2t1cCQxPXt9O2Z1bmN0aW9uIGRyb3BEaWFjcml0aWMkMSh3b3JkKXtsb2dnZXIkay5jaGVja05vcm1hbGl6ZSgpO3JldHVybiB0b1V0ZjhTdHJpbmcoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRvVXRmOEJ5dGVzKHdvcmQubm9ybWFsaXplKFwiTkZEXCIpLnRvTG93ZXJDYXNlKCkpLGM9PntyZXR1cm4gYz49NjUmJmM8PTkwfHxjPj05NyYmYzw9MTIzfSkpfWZ1bmN0aW9uIGV4cGFuZCQxKHdvcmQpe2NvbnN0IG91dHB1dD1bXTtBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRvVXRmOEJ5dGVzKHdvcmQpLGM9PntpZihjPT09NDcpe291dHB1dC5wdXNoKDIwNCk7b3V0cHV0LnB1c2goMTI5KX1lbHNlIGlmKGM9PT00NSl7b3V0cHV0LnB1c2goMjA0KTtvdXRwdXQucHVzaCgxMjgpfWVsc2V7b3V0cHV0LnB1c2goYyl9fSk7cmV0dXJuIHRvVXRmOFN0cmluZyhvdXRwdXQpfWZ1bmN0aW9uIGxvYWRXb3JkcyQzKGxhbmcpe2lmKHdvcmRsaXN0JDMhPW51bGwpe3JldHVybn13b3JkbGlzdCQzPXdvcmRzJDMucmVwbGFjZSgvKFtBLVpdKS9nLFwiICQxXCIpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDEpLnNwbGl0KFwiIFwiKS5tYXAodz0+ZXhwYW5kJDEodykpO3dvcmRsaXN0JDMuZm9yRWFjaCgod29yZCxpbmRleCk9Pntsb29rdXAkMVtkcm9wRGlhY3JpdGljJDEod29yZCldPWluZGV4fSk7aWYoV29yZGxpc3QuY2hlY2sobGFuZykhPT1cIjB4NTFkZWI3YWUwMDkxNDlkYzYxYTZiZDE4YTkxOGViN2FjNzhkMjc3NTcyNmM2OGU1OThiOTJkMDAyNTE5YjA0NVwiKXt3b3JkbGlzdCQzPW51bGw7dGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGZyIChGcmVuY2gpIEZBSUxFRFwiKX19Y2xhc3MgTGFuZ0ZyIGV4dGVuZHMgV29yZGxpc3R7Y29uc3RydWN0b3IoKXtzdXBlcihcImZyXCIpfWdldFdvcmQoaW5kZXgpe2xvYWRXb3JkcyQzKHRoaXMpO3JldHVybiB3b3JkbGlzdCQzW2luZGV4XX1nZXRXb3JkSW5kZXgod29yZCl7bG9hZFdvcmRzJDModGhpcyk7cmV0dXJuIGxvb2t1cCQxW2Ryb3BEaWFjcml0aWMkMSh3b3JkKV19fWNvbnN0IGxhbmdGcj1uZXcgTGFuZ0ZyO1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdGcik7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgZGF0YT1bXCJBUVJBU1JBR0JBR1VBSVJBSEJBZ2hBVVJBZEJBZGNBbm9BTUVBRkJBRkNCS0ZCUVJCU0ZCQ1hCQ0RCQ0hCR0ZCRVFCcEJCcFFCSWtCSE5CZU9CZ0ZCVkNCaEJCaE5CbU9CbVJCaUhCaUZCVUZCWkRCdkZCc1hCa0ZCbGNCallCd0RCTUJCVEJCVFJCV0JCV1hYYVFYYVJYUVdYU1JYQ0ZYWUJYcEhYT1FYSFJYaFJYdVJYbVhYYlJYbFhYd0RYVFJYckNYV1FYV0dhQldhS2NhWWdhc0ZhZFFhbG1hTUJhY0FLYVJLS0JLS1hLS2pLUVJLRFJLQ1lLQ1JLSURLZVZLSGNLbFhLakhLcllOQUhOQldOYVJOS2NOSUJOSU9ObVhOc1hOZFhObkJOTUJOUkJOclhOV0ROV01ORk9RQUJRQUhRQnJRWEJRWEZRYVJRS1hRS0RRS09RS0ZRTkJRTkRRUWdRQ1hRQ0RRR0JRR0RRR2RRWVhRcEJRcFFRcEhRTFhRSHVRZ0JRaEJRaENRdUZRbVhRaURRVUZRWkRRc0ZRZFJRa0hRYlJRbE9RbG1RUERRakRRd1hRTUJRTURRY0ZRVEJRVEhRckREWFFETkZER0JER1FER1JEcEZEaEZEbVhEWlhEYlJETVlEUmREVFJEclhTQWhTQkNTQnJTR1FTRVFTSEJTVlJTaFlTaGtTeVFTdUZTaUJTZGNTb0VTb2NTbG1TTUJTRkJTRktTRk5TRmRTRmNDQnlDYVJDS2NDU0JDU1JDQ3JDR2JDRUhDWVhDcEJDcFFDSUJDSUhDZU5DZ0JDZ0ZDVkVDVmNDbWtDbXdDWlhDWkZDZFJDbE9DbG1DbEZDakRDamRDblhDd0JDd1hDY1JDRlFDRmpHWGhHTmhHREVHRE1HQ0RHQ0hHSUZHZ0JHVlhHVkVHVlJHbVhHc1hHZFlHb1NHYlJHblhHd1hHd0RHV1JHRk5HRkxHRk9HRmRHRmtFQUJFQkRFQkZFWE9FYUJFS1NFTkJFTkRFWVhFSWdFSWtFZ0JFZ1FFZ0hFaEZFdWRFdUZFaUJFaUhFaUZFWkRFdkJFc1hFc0ZFZFhFZFJFa0ZFYkJFYlJFbEZFUENFZmtFRk5ZQUVZQWhZQk5ZUWRZRFhZU1JZQ0VZWW9ZZ1FZZ1JZdVJZbUNZWlRZZEJZYkVZbFhZalFZUmJZV1JwS1hwUW9wUW5wU0ZwQ1hwSUJwSVNwaE5wZEJwZFJwYlJwY1pwRkJwRk5wRkRwRm9wRnJMQURMQnVMWFFMWGNMYUZMQ1hMRWhMcEJMcEZMSFhMZVZMaElMZEhMZFJMb0RMYlJMclhJQUJJQlFJQkNJQnNJQm9JQk1JQlJJWGFJYVJJS1lJS1JJTkJJTnVJQ0RJR0JJSURJSWtJZ1JJeEZJeVFJaUhJZFJJYllJYlJJbEhJd1JJTVlJY1JJUlZJVFJJRkJJRk5JRlFPQUJPQUZPQlFPYUZPTkJPTk1PUUZPU0ZPQ0RPR0JPRVFPcEJPTFhPSUJPSUZPZ1FPZ0ZPeVFPeWNPbVhPc1hPZElPa0hPTUVPTWtPV1dIQk5IWE5IWFdITlhIRHVIRFJIU3VIU1JISG9IaGtIbVJIZFJIa1FIbGNIbFJId0JIV2NnQUVnQWdnQWtnQk5nQlFnQkVnWE9nWWNnTFhnSGpneVFnaUJnc0ZnZGFnTVlnV1NnRlFnRkVWQlRWWEVWS0JWS05WS0RWS1lWS1JWTkJWTllWREJWRHhWU0JWU1JWQ2pWR05WTFhWSUZWaEJWaGNWc1hWZFJWYlJWbFJoQlloS1loRFloR1NoeFdobU5oZGFoZGtoYlJoam9oTVhoVFJ4QVh4WFN4S0J4TkJ4RVF4ZU54ZVF4aFh4c0Z4ZGJ4bEh4amN4RkJ4Rk54RlF4Rk94Rm95Tll5WW95YmN5TVl1QlF1QlJ1QnJ1RE11Q291SEJ1ZFF1a2t1b0J1bFZ1TVh1RkVtQ1ltQ1JtcFJtZURtaU1tamRtVEZtRlFpQURpQk9pYVJpS1JpTkJpTlJpU0ZpR2tpR0ZpRVJpcFJpTEZpSUZpaFlpYkhpakJpakVpTVhpV0JpRkJpRkNVQlFVWEZVYVJVTkRVTmNVTlJVTkZVREJVU0hVQ0RVR0JVR0ZVRXFVTE5VTG9VSVJVZUVVZVlVZ0JVaEZVdVJVaUZVc1hVZEZVa0hVYkJValNVallVd1hVTURVY0hVUmRVVEJVckJVclhVclFaQUZaWFpaYVJaS0ZaTkJaUUZaQ1haR0JaWWRacEJaTERaSUZaSFhaSE5aZVFaVlJaVkZabVhaaUJadkZaZEZaa0ZaYkhaYkZad1haY0NaY1JaUkJ2QlF2Qkd2Qkx2Qld2Q292TVlzQUZzQkRzYVJzS0ZzTkZzRHJzU0hzU0ZzQ1hzQ1JzRUJzRUhzRWZzcEJzTEJzTERzSWdzSVJzZUdzYlJzRkJzRlFzRlNkTkJkU1JkQ1ZkR0hkWURkSGNkVmJkeVNkdURkc1hkbFJkd1hkV1lkV2NkV1JrQk1rWE9rYVJrTklrTkZrU0ZrQ0ZrWUJrcFJrZU5rZ0JraFZrbVhrc0ZrbFZrTUJrV0RrRk5vQk5vYVFvYUZvTkJvTlhvTmFvTkVvU1JvRXJvWVhvWUNvWWJvcFJvcEZvbVhvamtvd1hvckZiQkViRUliZEJiallsYVJsREVsTVhsRkRqS2pqU1JqR0JqWUJqWWtqcFJqTFhqSUJqT0ZqZVZqYlJqd0JuWFFuU0hucEZuTFhuSU5uTUJuVFJ3WEJ3WE53WFl3TkZ3UUZ3U0J3R0Z3TFh3TER3ZU53Z0J3dUh3akR3blhNQlhNcEZNSUJNZU5NVEhjYVFjTkJjREhjU0ZjQ1hjcEJjTFhjTERjZ0ZjdUZjblhjd1hjY0RjVFFjckZUUUVyWE5yQ0hycEZyZ0ZyYkZyVEhyRmNXTllXTmJXRUhXTVhXVFJcIixcIkFCR0hBQklKQUVBVkFZSlFBTFpKQUlhUkFITlhBSGRjQUhiUkFaSk1BWkpSQVpUUkFkVkpBa2xtQWJjTkFqZFJBTW5SQU1XWUFXcFJBV2dSQUZnQkFGaEJBRmRjQk5KQkJOSkRCUUtCQlFoY0JRbG1CREVKQllKa0JZSlRCcE5CQnBKRkJJSkJCSUpEQkljQUJPS1hCT0VKQk9WSkJPaUpCT1pKQmVwQkJlTFhCZUlGQmVnQkJnR0pCVkpYQnVvY0JpSlJCVUpRQmxYVkJsSVRCd05GQk1ZVkJjcVhCVGxtQldORkJXaUpCV25SQkZHSEJGd1hYS0dKWE5KQlhOWkpYRFRUWFNIU1hTVlJYU2xIWENKRFhHUUpYRWhYWFlRSlhZYlJYT2ZYWGVOY1hWSkZYaFFKWGhFSlhkVFJYamRYWE1oQlhjUVRYUkdCWFRFQlhUblFYRkNYWEZPRlhGZ0ZhQmFGYUJOSmFCQ0phQnBCYUJ3WGFOSkthTkpEYVFJQmFEcFJhRVBEYUhNRmFtREphbEVKYU1aSmFGYUZhRk5CYUZRSmFGTERhRlZIS0JDWUtCRUJLQkhES1hhRktYR2RLWEVKS1hwSEtYSUJLWFpES1h3WEtLd0xLTmFjS05ZSktOSm9LTldjS0RHZEtEVFJLQ2hYS0dhUktHaEJLR2JSS0VCVEtFYVJLRVBUS0xNREtMV1JLT0hES1ZKY0tkQmNLbElCS2xPUEtGU0JLRkVQS0ZwRk5CTkpOSkJRTkJHSE5CRVBOQkhYTkJnRk5CVlhOQlpETkJzWE5Cd1hOTmFSTk5KRE5OSkVOTkprTkRDSk5EVkROR0pSTkppRE5aSk5Oc0NKTkpGTk5GU0JORkNYTkZFUE5GTFhORklGUUpCRlFDYVJRSkVRUUxKRFFMSkZRSWFSUU9xWFFIYUZRSEhRUVZKWFFWSkRRaE5KUW1FSVFaSkZRc0pYUUpyRlFXYlJESkFCREJZSkRYTkZEWENYRFhMWERYWkREWHNKRFFxWERTSkZESkNYREVQa0RFcVhEWW1RRHBTSkRPQ2tET0dRREhFSURWSkREdUR1RFdFQkRKRmdTQk5EU0JTRlNCR0hTQklCU0JUUVNLVllTSlFOU0pRaVNKQ1hTRXFYU0pZVlNJaUpTT01ZU0hBSFNIYVFTZUNGU2VwUVNlZ0JTSGRIU0hyRlNoU0pTSnVIU0pVRlNrTlJTclNyU1dFQlNGYUhTSkZRU0ZDWFNGR0RTRllYU0ZPRFNGZ0JTRlZYU0ZoQlNGeEZTRmtGU0ZiQlNGTUZDQURkQ0pYQkNYYUZDWEtGQ1hORkNYQ1hDWEdCQ1hFSkNYWUJDWExEQ1hJQkNYT1BDWEhYQ1hnQkNYaEJDWGlCQ1hsRENYY0hDSk5CQ0pORkNEQ0pDREdCQ0RWWENEaEJDRGlEQ0RKZENDbU5DcEpGQ0lhUkNPcVhDSENIQ0haSkNWaUpDdUN1Q21kZENKaUZDZE5CQ2RIaENsRUpDblVKQ3JlU0NXbGdDV1RSQ0ZCRkNGTkJDRllCQ0ZWRkNGaEZDRmRTQ0ZUQkNGV0RHQk5CR0JRRkdKQkNHQkVxR0JwQkdCZ1FHTkJFR05KWUdOa09HTkpSR0RVRkdKcFFHSGFCR0plTkdKZUVHVkJsR1ZLakdpSkRHdkpIR3NWSkdrRUJHTUlKR1dqTkdGQkZHRkNYR0ZHQkdGWVhHRnBCR0ZNRkVBU0pFQVdwRUpORkVDSlZFSVhTRUlRSkVPcVhFT2NGRWVOY0VIRUpFSGxGRUpnRkVobG1FbURKRW1aSkVpTUJFVXFYRW9TUkVQQkZFUFhGRVBLRkVQU0ZFUEVGRVBwRkVQTFhFUElCRUpQZEVQY0ZFUFRCRUpuWEVxbEhFTXBSRUZDWEVGT0RFRmNGWUFTSllKQUZZQmFCWUJWWFlYcEZZRGhCWUNKQllKR0ZZWWJSWWVOY1lKZVZZaUlKWVpKY1l2SmdZdkpSWUpzWFlzSkZZTVlNWXJlVnBCTkhwQkVKcEJ3WHBReEZwWUVKcGVORHBKZURwZVNGcGVDSHBIVUpwSGJCcEhjSHBtVUpwaWlKcFVKcnBzSnVwbElUcEZhQnBGUXFwRkdCcEZFZnBGWUJwRnBCcEZMSnBGSURwRmdCcEZWWHBGeVFwRnVGcEZsRnBGakRwRm5YcEZ3WHBKRk1wRlRCTFhDSkxYRUZMWGhGTFhVSkxYYkZMYWxtTE5KQkxTSlFMQ0xDTEdKQkxMREpMSGFGTGVORkxlU0hMZUNYTGVwRkxoYVJMWnNKTHNKRExzSnJMb2NhTGxMbExNZGJMRk5CTEZTQkxGRUhMRmtGSUJCRklCWEZJQmFRSUJLWElCU0ZJQnBISUJMWElCZ0JJQmhCSUJ1SElCbVhJQmlGSUJaWElCdkZJQmJGSUJqUUlCd1hJQldGSUtUUklRVUpJREdGSUNqUUlZU1JJSU5YSUplQ0lWYVJJbUVrSVpKRkl2SlJJc0pYSWRDSklKb1JJYkJRSWpZQkljcVhJVEZWSXJlVklGS0ZJRlNGSUZDSklGR0ZJRkxESUZJQklKRk9JRmdCSUZWWElKRmhJRnhGSUZtWElGZEhJRmJCSUpGcklKRldPQkdCT1FmWE9PS2pPVXFYT2ZYQk9xWEVPY3FYT1JWSk9GSUJPRmxESEJJT0hYaUZITlRSSENKWEhJYVJISEpESEhFSkhWYlJIWkpZSGJJQkhSc0pIUmtESFdsbWdCS0ZnQlNCZ0JDRGdCR0hnQnBCZ0JJQmdCVkpnQnVCZ0J2RmdLRFRnUVZYZ0RVSmdHU0pnT3FYZ21VTWdaSUpnVFVKZ1dJRWdGQkZnRk5CZ0ZESmdGU0ZnRkdCZ0ZZWGdKRk9nRmdRZ0ZWWGdGaEJnRmJIZ0pGV1ZKQUJWUUtjVkRnRlZPZlhWZURGVmhhUlZtR2RWaUpZVk1hUlZGTkhoQk5EaEJDWGhCRXFoQnBGaEJMWGhOSkJoU0pSaGVWWGhoS0VoeGxtaFpJSmhkQlFoa0lKaGJNTmhNVUpoTVpKeE5KZ3hRVUp4REVreERkRnhTSlJ4cGxteGVTQnhlQ1h4ZUdGeGVZWHhlcFF4ZWdCeFdWY3hGRVF4RkxYeEZJQnhGZ0J4RnhEeEZadHhGZGN4RmJCeEZ3WHlESlh5RGxjdUFTSnVESnB1RElCdUNwSnVHU0p1SUpGdWVFRnVaSUp1c0pYdWRXRXVvSUJ1V0dKdUZCY3VGS0V1Rk5GdUZRRnVGREp1RkdKdUZWSnVGVXR1RmRIdUZUQm1CWUptTkpZbVFoa21MSkRtTEpvbUlkWG1pSlltdkpSbXNKUm1rbG1tTUJ5bU11Q21jbG1tY25RaUpBQmlKQk5pSkJEaUJTRmlCQ0ppQkVGaUJZQmlCcEZpQkxYaUJUSGlKTmNpREVmaUNaSmlFQ0ppSkVxaU9rSGlIS0ZpZU5EaUhKUWllUWNpZURIaWVTRmllQ1hpZUdGaWVFRmllSUhpZWdGaWhVSml4Tm9pb05YaUZhQmlGS0ZpRk5EaUZFUGlGWVhpdEZPaXRGSGlGZ0JpRlZFaUZtWGlGaXRpRmJCaUZNRmlGckZVQ1hRVUlvUVVJSmNVSFFKVWVDRVVId1hVVUpEVVVxWFVkV2NVY3FYVXJuUVVGTkRVRlNIVUZDRlVGRWZVRkxYVXRGT1pCWE9aWFNCWlhwRlpYVlhaRVFKWkVKa1pwREpaT3FYWmVOSFplQ0RaVXFYWkZCUVpGRUhaRkxYdkJBRnZCS0Z2QkNYdkJFUHZCcEh2QklEdkJnRnZCdUh2UU5KdkZORnZGR0J2RklCdkpGY3NYQ0RzWExYc1hzWHNYbEZzWGNIc1FxWHNKUUZzRXFYc2VJRnNGRUhzRmpEZEJ4T2ROcFJkTkpSZEVKYmRwSlJkaFpKZG5TSmRyak5kRk5KZEZRSGRGaE5rTkpEa1lhUmtITlJrSFNSa1ZiUmt1TVJralNKa2NxRG9TSkZvRWlKb1laSm9PZlhvaEVCb01HUW9jcVhiQkFGYkJYRmJCYUZiQk5EYkJHQmJCTFhiQlRCYkJXRGJHSlliSUpIYkZRcWJGcFFsRGdRbE9yRmxWSlJqR0VCalpKUm5YdkpuWGJCbkVmSG5PUERuZ0pSbnhmWG5VSld3WEVKd05wSndEcEJ3RWZYd3JFQk1EQ0pNREdITURJSk1MSkRjUUdEY1FwSGNxWGNjcU5GY3FDWGNGQ0pSQlNCUkJHQlJCRUpSQnBRVEJORlRCUUpUQnBCVEJWWFRGQUJURlNCVEZDRlRGR0JURk1EclhDSnJYTERyRE5KckVmSHJGUUpyRml0V05qZFdOVFJcIixcIkFLTEpNQU5PUEZBU05KSUFFSldYQVlKTlJBSUliUkFJY2RhQWVFZkRBZ2lkUkFkak5ZQU1ZRUpBTUliUkFGTkpCQUZwSkZCQklKWUJEWkpGQlNpSmhCR2RFQkJFSmZYQkVKcVhCRUpXUkJwYVVKQkxYclhCSVlKTUJPY2ZYQmVFZkZCZXN0WEJqTkpSQmNESk9CRkVxWFhOdkpSWERNQmhYQ0pOWVhPQVdwWE9OSldYSERFQlhlSWFSWGhZSkRYWkpTSlhNREpPWGNBU0pYRlZKWGFCUXFYYUJaSkZhc1hkUWFGU0pRYUZFZlhhRnBKSGFGT3FYS0JOU1JLWHZKQktRSmhYS0VKUUpLRUpHRktJTkpCS0lKak5LZ0pOU0tWRWxtS1ZoRUJLaUpHRktsQmdKS2puVUpLd3NKWUtNRklKS0ZOSkRLRklKRktGT2ZYTkpCU0ZOSkJDWE5CcEpGTkpCdlFOSkJNQk5KTEpYTkpPcVhOSmVDWE5KZUdGTmRzSkNOYlRLRk53WFVKUU5GRVBRRGlKY1FETVNKUVNGcEJRR01RSlFKZU9jUXlDSkVRVUpFQlFKRkJyUUZFSnFEWERKRkRKWHBCREpYSU1ER2lKaERJSkdSREplWWNESHJESkRWWGdGRGtBV3BEa0lnUkRqREVxRE12SlJESkZORkRKRklCU0tjbG1TSlFPRlNKUVZIU0pRakRTSkdKQlNKR0pGU0VDSm9TSEVKcVNKSFRCU0pWSkRTVmlKWVNaSk5CU0pzSkRTRlNKRlNGRWZYU0pGTFhDQlVKVkNKWFNCQ0pYcEJDWFZKWENKWHNYQ0pYZEZDSk5KSENMSUpnQ0hpSkZDVk5KTUNoQ0poQ1VIRUpDc0pUUkNKZFljQ29RSkNDRkVmWENGSUpnQ0ZVSnhDRnN0RkdKQmFRR0pCSURHUUpxWEdZSk5SR0pIS0ZHZVFxREdIRUpGR0plTFhHSElpSkdIZEJsR1VKRUJHa0lKVEdGUVBER0pGRXFFQUdlZ0VKSUpCRUpWSlhFaFFKVEVpSk5jRUpaSkZFSm9FcUVqREVxRVBEc1hFUEdKQkVQT3FYRVBlUUZFZkRpREVKZkVGRWZlcFFFZk1pSkVxWE5CRXFESURFcWVTRkVxVkpYRU12SlJZWE5KRFlYRUpIWUtWSmNZWUpFQllKZUVjWUpVcVhZRnBKRllGc3RYcEFaSk1wQlNKRnBOQk5GcGVRUERwSExKRHBISUpGcEhnSkZwZWl0RnBIWkpGcEpGQURwRlNKRnBKRkNKcEZPcVhwRml0QnBKRlpKTFhJSkZMSUpnUkxWTkpXTFZISk1Md05wSkxGR0pCTEZMSkRMRk9xWExKRlVKSUJESlhJQkdKQklKQllRSUpCSUJJQk9xWElCY3FESUVHSkZJTE5KVElJSkVCSU9pSmhJSmVOQklKZUlCSWhpSklJV29UUklKRkFISUpGcEJJSkZ1SElGVXRGSUpGVEhPU0JZSk9FY3FYT0hFSnFPdkJwRk9rVkpyT2JCVkpPbmNxRE9jTkprSGhOSlJIdUhKdUhkTWhCZ0JVcVhnQnNKWGdPTkpCZ0hOSkRnSEhKUWdKZWl0Z0hzSlhnSnlOYWd5REpCZ1pKRHJnc1ZKUWdrRUpOZ2tqU0pnSkZBSGdGQ0pEZ0ZadE1WSlhORlZYUWZYVkpYREpWWG9RSlZRVkpRVkRFZlhWRHZKSFZFcU5GVmVRZlhWSHBKRlZIeGZYVlZKU1JWVm1hUlZsSUpPaENYVkpoSGpZa2h4Q0pWaFdWVUpoV2lKY3hCTkpJeGVFcUR4ZlhCRnhjRkVQeEZTSkZ4RllKWHlCRFFKeWRhVUp5Rk9QRHVZQ0pZdUx2SlJ1SExKWHVaSkxEdUZPUER1RlpKSHVGY3FYbUtISmRtQ1FKY21Pc1ZKaUpBR0ZpdExDRmllT2ZYaWVzdFhpWkpNRWlrTkpRaXJYekZpRlFxWGlGSUpGaUZaSkZpRnZ0RlVIcEpGVXRlSWNVdGVPY1VWQ0prVWhkSGNVYkVKRVVKcVhRVU1OSmhVUmpZa1VGaXRGWkRHSkhaSkl4RFpKVkpYWkpGREpaSkZwUXZCTkpCdkJTSkZ2SnhCcnNlUXFEc1ZGVkpkRkxKRGtFSk5Ca21OSllrRkxKRG9RSk9Qb0dzSlJvRUFIQm9FSmZGYkJRcURiQlpKSGJGVkpYbEZJSkJqWUlyWGplaXRjampDRUJqV01OQndYUWZYd1hPYUZ3RHNKWHdDSlRSd3JDWkpNRE5KUWNEREpGY3FET1BSWWlKRlRCc0pYVFFJSkJURkVmWFRGTEpEclhFSkZyRUpYTXJGWkpGV0VKZEVXWVRsbVwiLFwiQUJDREVGQUNOSlRSQU1CREpkQWNOSlZYQkxOSkVCWFNJZFdSWEVyTkprWFlESk1CWFpKQ0phWE1OSmFZS0tWSktjS0RFSnFYS0RjTkpoS1ZKck5ZS2JnSlZYS0ZWSlNCTkJZQndETkplUWZYTkplRXFYTmhHSldFTkpGaUpSUWxJSmJFUUpmWHhEUXFYY2ZYUUZOREVKUUZ3WFVKRFljblVKREpJQmdRRElVSlRSREpGRXFEU0pRU0pGU0pRSUpGU09QZVp0U0pGWkpIQ0pYUWZYQ1RERXFGR0pCU0pGR0pCT2ZYR0pCY3FYR0pITkpER0pSTGlKRUpmWEVxRUpGRUpQRUZwQkVKWUpCWkpGWUJ3WFVKWWlKTUVCWUpaSnlUWVRPTkpYcFFNRlhGcGVHSURkcEpGc3RYcEpGY1BETEJWU0pSTEhRSnFYTEpGWkpGSUpCTkpESUpCVXFYSUJrRkRKSUpFSlBUSVlKR1dSSUplUVBESUplRWZISUpGc0pYT3FHRFNGSFhFSnFYZ0pDc0pDZ0dRSnFYZ2RRWUpFZ0ZNRk5CZ0pGY3FEVkp3WFVKVkpGWkpjaElnSkNDeE9FSnFYeE93WFVKeURKQlZSdXNjaXNjaUpCaUpCaWVVdHFYaUpGREpraUZzSlhRVUdFWkpjVUpGc0pYWnRYSXJYWkRaSkRyWkpGTkpEWkpGc3RYdkpGUXFYdkpGQ0pFc0pYUUpxa2hrTkdCYkRKZFRSYllKTUVCbER3WFVKTUVGaUpGY2ZYTkpEUmNOSldNVEJMSlhDXCIsXCJCcmFGVXRIQkZTSkZkYk5CTEpYVkpRb1lKTkVCU0pCRUpmSFNKSHdYVUpDSmRBWkpNR2phRlZKWEVKUE5KQmxFSmZGaUpGcEZiRkVKcUlKQlZKQ3JJQmRIaUpoT1BGQ2h2SlZKWkpOSld4R0ZOSUZMdWVJQlFKcVVIRUpmVUZzdE9aSkRybFhFQVNKUmxYVkpYU0Z3VkpOSldEXCIsXCJRSkVKTk5KRFFKRUpJQlNGUUpFSnhlZ0JRSkVKZkhFUFNKQm1YRUpGU0pDREVKcVhMWE5KRlFxWEljUXNGTkpGSUZFSnFYVUpnRnNKWElKQlVKRUpmSE5Gdkp4RXFYTkpuWFVKRlFxRFwiLFwiSUpCRUpxWFpKXCJdO2NvbnN0IG1hcHBpbmc9XCJ+fkF6Qn5YfmF+S05+UX5EflN+Q35HfkV+WX5wfkx+SX5PfmVIfmd+Vn5oeHl1bWl+flV+flp+fnZ+fnN+fmRrb2JsUGpmbnF3TWNSVHJ+V35+fkZ+fn5+fkp0XCI7bGV0IHdvcmRsaXN0JDQ9bnVsbDtmdW5jdGlvbiBoZXgod29yZCl7cmV0dXJuIGhleGxpZnkodG9VdGY4Qnl0ZXMod29yZCkpfWNvbnN0IEtpWW9LdT1cIjB4ZTM4MThkZTM4Mjg0ZTM4MThmXCI7Y29uc3QgS3lvS3U9XCIweGUzODE4ZGUzODI4M2UzODE4ZlwiO2Z1bmN0aW9uIGxvYWRXb3JkcyQ0KGxhbmcpe2lmKHdvcmRsaXN0JDQhPT1udWxsKXtyZXR1cm59d29yZGxpc3QkND1bXTtjb25zdCB0cmFuc2Zvcm09e307dHJhbnNmb3JtW3RvVXRmOFN0cmluZyhbMjI3LDEzMCwxNTRdKV09ZmFsc2U7dHJhbnNmb3JtW3RvVXRmOFN0cmluZyhbMjI3LDEzMCwxNTNdKV09ZmFsc2U7dHJhbnNmb3JtW3RvVXRmOFN0cmluZyhbMjI3LDEzMCwxMzNdKV09dG9VdGY4U3RyaW5nKFsyMjcsMTMwLDEzNF0pO3RyYW5zZm9ybVt0b1V0ZjhTdHJpbmcoWzIyNywxMjksMTYzXSldPXRvVXRmOFN0cmluZyhbMjI3LDEyOSwxNjRdKTt0cmFuc2Zvcm1bdG9VdGY4U3RyaW5nKFsyMjcsMTMwLDEzMV0pXT10b1V0ZjhTdHJpbmcoWzIyNywxMzAsMTMyXSk7dHJhbnNmb3JtW3RvVXRmOFN0cmluZyhbMjI3LDEzMCwxMzVdKV09dG9VdGY4U3RyaW5nKFsyMjcsMTMwLDEzNl0pO2Z1bmN0aW9uIG5vcm1hbGl6ZSh3b3JkKXtsZXQgcmVzdWx0PVwiXCI7Zm9yKGxldCBpPTA7aTx3b3JkLmxlbmd0aDtpKyspe2xldCBrYW5hPXdvcmRbaV07Y29uc3QgdGFyZ2V0PXRyYW5zZm9ybVtrYW5hXTtpZih0YXJnZXQ9PT1mYWxzZSl7Y29udGludWV9aWYodGFyZ2V0KXtrYW5hPXRhcmdldH1yZXN1bHQrPWthbmF9cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBzb3J0SmFwYW5lc2UoYSxiKXthPW5vcm1hbGl6ZShhKTtiPW5vcm1hbGl6ZShiKTtpZihhPGIpe3JldHVybi0xfWlmKGE+Yil7cmV0dXJuIDF9cmV0dXJuIDB9Zm9yKGxldCBsZW5ndGg9MztsZW5ndGg8PTk7bGVuZ3RoKyspe2NvbnN0IGQ9ZGF0YVtsZW5ndGgtM107Zm9yKGxldCBvZmZzZXQ9MDtvZmZzZXQ8ZC5sZW5ndGg7b2Zmc2V0Kz1sZW5ndGgpe2NvbnN0IHdvcmQ9W107Zm9yKGxldCBpPTA7aTxsZW5ndGg7aSsrKXtjb25zdCBrPW1hcHBpbmcuaW5kZXhPZihkW29mZnNldCtpXSk7d29yZC5wdXNoKDIyNyk7d29yZC5wdXNoKGsmNjQ/MTMwOjEyOSk7d29yZC5wdXNoKChrJjYzKSsxMjgpfXdvcmRsaXN0JDQucHVzaCh0b1V0ZjhTdHJpbmcod29yZCkpfX13b3JkbGlzdCQ0LnNvcnQoc29ydEphcGFuZXNlKTtpZihoZXgod29yZGxpc3QkNFs0NDJdKT09PUtpWW9LdSYmaGV4KHdvcmRsaXN0JDRbNDQzXSk9PT1LeW9LdSl7Y29uc3QgdG1wPXdvcmRsaXN0JDRbNDQyXTt3b3JkbGlzdCQ0WzQ0Ml09d29yZGxpc3QkNFs0NDNdO3dvcmRsaXN0JDRbNDQzXT10bXB9aWYoV29yZGxpc3QuY2hlY2sobGFuZykhPT1cIjB4Y2IzNmIwOWU2YmFhOTM1Nzg3ZmQ3NjJjZTY1ZTgwYjBjNmE4ZGFiZGZiYzNhN2Y4NmFjMGUyYzRmZDExMTYwMFwiKXt3b3JkbGlzdCQ0PW51bGw7dGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGphIChKYXBhbmVzZSkgRkFJTEVEXCIpfX1jbGFzcyBMYW5nSmEgZXh0ZW5kcyBXb3JkbGlzdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiamFcIil9Z2V0V29yZChpbmRleCl7bG9hZFdvcmRzJDQodGhpcyk7cmV0dXJuIHdvcmRsaXN0JDRbaW5kZXhdfWdldFdvcmRJbmRleCh3b3JkKXtsb2FkV29yZHMkNCh0aGlzKTtyZXR1cm4gd29yZGxpc3QkNC5pbmRleE9mKHdvcmQpfXNwbGl0KG1uZW1vbmljKXtsb2dnZXIkay5jaGVja05vcm1hbGl6ZSgpO3JldHVybiBtbmVtb25pYy5zcGxpdCgvKD86XFx1MzAwMHwgKSsvZyl9am9pbih3b3Jkcyl7cmV0dXJuIHdvcmRzLmpvaW4oXCLjgIBcIil9fWNvbnN0IGxhbmdKYT1uZXcgTGFuZ0phO1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdKYSk7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgZGF0YSQxPVtcIk9ZQWFcIixcIkFUQVpvQVRCbDNBVENUckFUQ2w4QVREbG9BVEdnM0FUSFQ4QVRKVDhBVEpsM0FUTGx2QVRMbjRBVE1UOEFUTVg4QVRNYm9BVE1nb0FUb0xiQVRvTVRBVHJIZ0FUdkhuQVQzQW5BVDNKYkFUM01UQVQ4RGJBVDhKVEFUOExtQVQ4TVlBVDhNYkFUI0xuQVVIVDhBVUhadkFVSlhyQVVKWDhBVUxuckFYSm52QVhMVW9BWExndkFYTW42QVhSZzNBWHJNYkFYM0pUQVgzUWJBWUxuM0FaTGd2QVpyU1VBWnZBY0FaOEFhQVo4QWJBWjhBbkFaOEhuQVo4TGdBWjhNWUFaOE1nQVo4T25BYUFib0FhRFRyQWFGVHJBYUpUckFhSmJvQWFMVm9BYU1YdkFhT2w4QWFTZW9BYkFVb0FiQWc4QWJBbDRBYkduckFiTVQ4QWJNWHJBYk1uNEFiUWI4QWJTVjhBYnZSbEFiOEFVQWI4QW5BYjhIZ0FiOEpUQWI4TlRBYjhSYkFjR2JvQWNMbnZBY01UOEFjTVg4QWNTVG9BY3JBYUFjckZuQWM4QWJBYzhNZ0FmR2dyQWZIYm9BZkpudkFmTFY4QWZMa29BZk1UOEFmTW5vQWZRYjhBZlNjckFmU2dyQWdBWjhBZ0ZsM0FnR1g4QWdIWnZBZ0hnckFnSlhvQWdKWDhBZ0pib0FnTFpvQWdMbjRBZ09YOEFnb0FUQWdvQW5BZ29DVUFnb0pnQWdvTFhBZ29NWUFnb1NlQWdyRFVBZ3JKVEFockZuQWhyTGpBaHJRZ0FqQWdvQWpKbnJBa01YOEFrT25vQWxDVHZBbENWOEFsQ2x2QWxGZzRBbEZsNkFsRm4zQWxvU25BbHJBWEFsckFmQWxyRlVBbHJGYkFsckdnQWxyT1hBbHZLbkFsdk1UQWwzQWJBbDNNbkFuQVRyQW5BY3JBbkNaM0FuQ2w4QW5EZzhBbkZib0FuRmwzQW5IWDRBbkhickFuSGdyQW5JbDNBbkpndkFuTFhvQW5MWDRBbkxickFuTGdyQW5MaHJBbk1Yb0FuTWdyQW5PbjNBblNickFuU2VvQW52TG5BbjNPbkNUR2d2Q1RTbHZDVHZBVUNUdktuQ1R2TlRDVDNDWkNUM0dVQ1QzTVRDVDhIbkNVQ1pyQ1VMZjhDVUxudkNVM0huQ1UzSlVDWTZOVUNiRGI4Q2JGWm9DYkxuckNib09UQ2JvU2NDYnJGbkNidkxuQ2I4QWdDYjhIZ0NiJExuQ2tMZm9DbEJuM0Nsb0RVRFRIVDhEVExsM0RUU1U4RFRyQWFEVHJMWERUckxqRFRyT1lEVHJPZ0RUdkZYRFR2Rm5EVDNIVURUM0xmRFVDVDlEVURUNERVRlZvRFVGVjhEVUZrb0RVR2dyRFVKbnJEVUxsOERVTVQ4RFVNWHJEVU1YNERVTWc4RFVPVW9EVU9ndkRVT2c4RFVTVG9EVVNaOERiRFhvRGJEZ29EYkdUOERiSm4zRGJMZzNEYkxuNERiTVhyRGJNZzhEYk9Ub0Rib0pYR1RDbHZHVERUOEdURlpyR1RMVm9HVExsdkdUTGwzR1RNZzhHVE9UdkdUU2xyR1RvQ1VHVHJEZ0dUckpZR1RyU2NHVHRMbkdUdkFuR1R2UWdHVUNackdVRFR2R1VGWm9HVUhYckdVTG52R1VNVDhHVW9NZ0dYb0xuR1hyTVhHWHJNbkdYdkZuR1lMbnZHWk9udkdadk9uR1o4TGFHWjhMbUdiQWwzR2JEWXZHYkRsckdiSFgzR2JKbDRHYkxWOEdiTG4zR2JNbjRHYm9KVEdib1JmR2J2RlVHYjNHVUdiNEpuR2dEWDNHZ0ZsJEdnSmxyR2dMWDZHZ0xab0dnTGY4R2dPWG9HZ3JBZ0dnckpYR2dyTVlHZ3JTY0dndkFUR2d2T1lHbkFnb0duSmd2R25MWm9HbkxnM0duTG5yR25RbjhHblNickduck1nSFRDbHZIVERUb0hURlQzSFRRVDhIVG9KVEhUb0pnSFRyRFVIVHJNbkhUdkZZSFR2UmZIVDhNbkhUOFNVSFVBWjhIVUJiNEhVRFR2SFVvTVlIWEZsNkhYSlg2SFhRbHJIWHJBVUhYck1uSFhyU2JIWHZGWUhYdktYSFgzTGpIWDNNZUhZdlFsSFpyU2NIWnZEYkhiQWNySGJGVDNIYkZsM0hiSlQ4SGJMVHJIYk1UOEhiTVhySGJNYnJIYlFiOEhiU1gzSGJvRGJIYm9KVEhickZVSGJySGdIYnJKVEhiOEpUSGI4TW5IYjhRZ0hnQWxySGdEVDNIZ0dnckhnSGdySGdKVHJIZ0pUOEhnTFhASGdMbnJIZ01UOEhnTVg4SGdNYm9IZ09uckhnUVRvSGdSZzNIZ29IZ0hnckNiSGdyRm5IZ3JMVkhndkFjSGd2QWZIbkFsb0huQ1RySG5DbnZIbkdUckhuR1o4SG5HbnZIbkpUOEhuTGY4SG5Ma3ZIbk1nOEhuUlRySVR2RlVJVHZGbkpUQVhySlRDVjhKVEZUM0pURlQ4SlRGbjRKVEdndkpUSFQ4SlRKVDhKVEpYdkpUSmwzSlRKbnZKVExYNEpUTGY4SlRMaHZKVE1UOEpUTVhySlRNbnJKVE9ickpUUVQ4SlRTbHZKVDhEVUpUOEZrSlQ4TVRKVDhPWEpUOE9nSlQ4UVVKVDhSZkpVSFpvSlhGVDRKWEZsckpYR1o4SlhHbnJKWExWOEpYTGd2SlhNWG9KWE1YM0pYTmJvSlhQbHZKWG9KVEpYb0xrSlhyQVhKWHJIVUpYckpnSlh2SlRKWHZPbkpYNEtuSllBbDNKWUpUOEpZTGh2SllRVG9KWXJRWEpZNk5VSmJBbDNKYkNackpiRGxvSmJHVDhKYkdnckpiSlh2SmJKYm9KYkxmOEpiTGhySmJMbDNKYk1udkpiUmc4SmJTWjhKYm9EYkpickNaSmJyU1VKYjNLbkpiOExuSmZSbjhKZ0FYckpnQ1pySmdEVHJKZ0dackpnR1o4SmdIVG9KZ0pUOEpnSlhvSmdKZ3ZKZ0xYNEpnTFozSmdMWjhKZ0xuNEpnTWdySmdNbjRKZ09ndkpnUFg2SmdSbnZKZ1NUb0pnb0NaSmdvSmJKZ29NWUpnckpYSmdySmdKZ3JMakpnNk1USmxDbjNKbEdndkpsSmw4Smw0QW5KbDhGbkpsOEhnSm5BVG9KbkFUckpuQWJ2Sm5EVW9KbkduckpuSlhySm5KWHZKbkxodkpuTG5ySm5MbnZKbk1Ub0puTVQ4Sm5NWHZKbk1YM0puTWc4Sm5NbHJKbk1uNEpuT1g4Sm5TVDRKblNYM0pub0FnSm5vQW5Kbm9KVEpub09iSm5yQWJKbnJBa0puckhuSm5ySlRKbnJKWUpuck9ZSm5yU2NKbnZDVUpudkZhSm52SmdKbnZKbkpudk9ZSm52UVVKbnZSVUpuM0ZuSm4zSlRLbkZsM0tuTFQ2TFREbHZMVE1ub0xUT24zTFRSbDNMVFNiNExUU2xyTFRvQW5MVG9KZ0xUckFVTFRyQWNMVHJDVUxUckhnTFRyTWdMVDNKbkxVTG5yTFVNWDhMVW9KZ0xWQVRyTFZEVHJMVkxiOExWb0pnTFY4TWdMVjhSVExYRGczTFhGbHJMWHJDbkxYckxYTFgzR1RMWDRHZ0xYNE9ZTFpBWHJMWkFjckxaQWdyTFpBaHJMWkRYeUxaRGxyTFpGYnJMWkZsM0xaSlg2TFpKWDhMWkxjOExaTG5yTFpTVThMWm9KVExab0puTFpyQWdMWnJBbkxackpZTFpyTFVMWnJNZ0xaclNrTFp2QW5MWnZHVUxadkplTFp2T1RMWjNGWkxaNEpYTFo4U1RMWjhTY0xhQVQzTGFBbDNMYUhUOExhSlRyTGFKVDhMYUpYckxhSmd2TGFKbDRMYUxWb0xhTVhyTGFNWHZMYU1YOExiQ2x2TGJGVG9MYkhsckxiSm40TGJMWjNMYkxodkxiTVhyTGJNbm9MYnZTVUxjTG5yTGM4SG5MYzhNVExkck1uTGVBZ29MZU9ndkxlT24zTGZBbDNMZkxudkxmTWwzTGZPWDhMZjhBbkxmOEpYTGY4TFhMZ0pUckxnSlhyTGdKbDhMZ01YOExnUlpyTGhDVG9MaHJBYkxockZVTGhySlhMaHZKWUxqSFRyTGpIWDRMakpYOExqTGhyTGpTWDNMalNaNExrRlg0TGtHWjhMa0dndkxrSlRyTGtNWG9Ma1NUb0xrU1U4TGtTWjhMa29PWUxsM0ZmTGwzTWdMbUFackxtQ2JyTG1HZ3JMbUhib0xtSm5vTG1KbjNMbUxmb0xtTGhyTG1TVG9MbkFYNkxuQWI2TG5DWjNMbkNiM0xuRFR2TG5EYjhMbkZsM0xuR25yTG5IWnZMbkhndkxuSVR2TG5KVDhMbkpYOExuSmx2TG5MZjhMbkxnNkxuTGh2TG5Mbm9Mbk1YckxuTWc4TG5RbHZMblNickxuckFnTG5yQW5MbnJEYkxuckZrTG5ySmRMbnJNVUxuck9ZTG5yU1RMbnZBbkxudkRVTG52SGdMbnZPWUxudk9uTG4zR2dMbjREVUxuNEpUTG40Sm5NVEFab01UQWxvTVREYjhNVEZUOE1USm5vTVRKbnJNVExack1UTGhyTVRMa3ZNVE1YOE1UUlRyTVRvQVRNVHJEbk1Uck9uTVQzSm5NVDRNbk1UOEZVTVQ4RmFNVDhGbE1UOEdUTVQ4R2JNVDhHbk1UOEhuTVQ4SlRNVDhKYk1UOE9UTVVDbDhNVUpUck1VSlU4TVVNWDhNVVJUck1VU1RvTVhBWDZNWEFiNk1YQ1pvTVhGWHJNWEhYck1YTGd2TVhPZ29NWHJBVU1YckFuTVhySGdNWHJKWU1YckpuTVhyTVRNWHJNZ01Yck9ZTVhyU1pNWHJTZ01YdkRVTVh2T1RNWDNKZ01YM09UTVg0Sm5NWDhEYk1YOEZuTVg4SGJNWDhIZ01YOEhuTVg4TGJNWDhNbk1YOE9uTVlBYjhNWUdib01ZSFR2TVlIWDRNWUxUck1ZTG52TVlNVG9NWU9ndk1ZUmczTVlTVHJNYkFUb01iQVhyTWJBbDNNYkFuOE1iR1o4TWJKVDhNYkpYck1iTVh2TWJNWDhNYk1ub01ick1VTWI4QWZNYjhGYk1iOEZrTWNKWG9NZUxuck1nRmwzTWdHVHZNZ0dYb01nR2dyTWdHbnJNZ0hUOE1nSFpyTWdKbm9NZ0xuck1nTG52TWdNVDhNZ1FVb01nckhuTWd2QW5NZzhIZ01nOEpZTWc4TGZNbG9Kbk1sOEFUTWw4QVhNbDhKWU1uQVRvTW5BVDRNbkFaOE1uQWwzTW5BbDRNbkNsOE1uSFQ4TW5IZzhNbkpub01uTFpvTW5MaHJNbk1Yb01uTVgzTW5NbnJNbk9ndk1uckZiTW5yRmZNbnJGbk1uck5UTW52SlhOVE1sOE9UQ1QzT1RGVjhPVEZuM09USFp2T1RKWHJPVE9sM09UM0FUT1QzSlVPVDNMWk9UM0xlT1QzTWJPVDhBVE9UOEFiT1Q4QWdPVDhNYk9VQ1h2T1VNWDNPWEhYdk9YTGwzT1hyTVVPWHZEYk9YNk5VT1g4SmJPWUZab09ZTGJyT1lMa29PWU1nOE9ZU1gzT2JIVHJPYkhUNE9iSmdyT2JMaHJPYk1YM09iT1g4T2I4Rm5PZUFsck9lSlQ4T2VKWHJPZUpuck9lTFRvT2VNYjhPZ0pYb09nTFhvT2dNbnJPZ09Yck9nT2xvT2dvQWdPZ29KYk9nb01ZT2dvU1RPZzhBYk9qTFg0T2pNbm9PalNWOE9uTFZvT25yQWdPbjNEVVBYUWxyUFh2RlhQYnZGVFBkQVQzUGxGbjNQbnZGYlFUTG40UVRvQWdRVG9NVFFVTFY4UVVSZzhRVW9KblFYQ1h2UWJGYnJRYjhBYVFiOEFjUWI4RmJRYjhNWVFiOFNjUWVBbHJRZUxoclFqQW4zUWxGWG9RbG9KZ1Fsb1NuUlRMbnZSVHJHVVJUckpUUlVKWnJSVW9KbFJVclFuUlpyTG1SWnJNblJaclNuUlo4QVRSWjhKYlJaOFNjUmJNVDhSYlNUM1JmR1pyUmZNWDhSZk1nclJmU1pyUm5BYnJSbkdUOFJudkpnUm52TGZSbnZNVFJuOEFhU1RDbHZTVEpnclNUT1hyU1RSZzNTVFJudlNUb0FjU1RvQWZTVG9BblNUb0huU1RvTGpTVG9NVFNUckFhU1RyRVVTVDNCWVNUOEFnU1Q4TG1TVUFadlNVQWdyU1VEVDRTVURUOFNVR2d2U1VKWG9TVUpYdlNVTFRyU1U4SlRTVThMalNWOEFuU1Y4SmdTWEZUb1NYTGY4U1l2QW5TWnJEVVNack1VU1pyTW5TWjhIZ1NaOEpUU1o4SmdTWjhNWVNaOFFVU2FRVW9TYkNUM1NiSFRvU2JRWXZTYlNsNFNib0puU2J2RmJTYjhIYlNiOEpnU2I4T1RTY0daclNjSGdyU2NKVHZTY01UOFNjU1RvU2NvSGJTY3JNVFNjdkFuU2VBWnJTZUFjclNlSGJvU2VKVW9TZUxoclNlTVQ4U2VNWHJTZTZKZ1NnSFRyU2tKbm9Ta0xudlNrOENVU2xGbDNTbHJTblNsOEduU21BYm9TbUdUOFNtSlU4XCIsXCJBVExuRGxBVHJBWm9BVHJKWDRBVHJNVDhBVHJNWDRBVHJSVHJBVHZEbDhBVHZKVW9BVHZNbDhBVDNBVG9BVDNNWDhBVDhDVDNBVDhEVDhBVDhIWnJBVDhIZ29BVUFnRm5BVUNURm5BWG9NWDhBWHJBVDhBWHJHZ3ZBWHJKWHZBWHJPZ29BWHZMbDNBWnZBZ29BWnZGYnJBWnZKWG9BWnZKbDhBWnZKbjNBWnZNWDhBWnZTYnJBWjhGWm9BWjhMWjhBWjhNVThBWjhPVHZBWjhTVjhBWjhTWDNBYkFnRlpBYm9Kbm9BYnZHYm9BYjhBVHJBYjhBWm9BYjhBZ3JBYjhBbDRBYjhEYjhBYjhKbm9BYjhMWDRBYjhMWnJBYjhMaHJBYjhNVDhBYjhPVW9BYjhRYjhBYjhTVDhBY3JBVW9BY3JBYzhBY3JDWjNBY3JGVDNBY3JGWnJBY3JKbDRBY3JKbjNBY3JNWDNBY3JPVHZBYzhBWjhBYzhNVDhBZkFjSlhBZ29GbjRBZ29HZ3ZBZ29HbnJBZ29MYzhBZ29NWG9BZ3JMbnJBa3JTWjhBbEZYQ1RBbG9IYm9BbHJIYnJBbHJMaHJBbHJMa29BbDNDWnJBbDNMVW9BbDNMWnJBbnJBbDRBbnJNVDhBbjNIVDRCVDNJVG9CWDRNbnZCYiFMbiRDVEdYTW5DVG9MWjRDVHJIVDhDVDNKVHJDVDNSWnJDVCNHVHZDVTZHZ3ZDVThEYjhDVThHWnJDVThIVDhDYm9MbDNDYnJHZ3JDYnJNVThDYjhEVDNDYjhHbnJDYjhMWDRDYjhNVDhDYjhPYnJDZ3JHZ3ZDZ3JLWDRDbDhGWm9EVHJBYnZEVHJEYm9EVHJHVDZEVHJKZ3JEVHJNWDNEVHJSWnJEVHJSZzhEVHZBVnZEVHZGWm9EVDNEVDhEVDNMbjNEVDRIWnJEVDRNVDhEVDhBbHJEVDhNVDhEVUFrR2JEVURiSm5EWUxuUWxEYkRVT1lEYk1UQW5EYk1YU25EYm9BVDNEYm9GbjREYm9MbnZEajZKVHJHVENnRlRHVEdnRm5HVEpUTW5HVExuUGxHVG9KVDhHVHJDVDNHVHJMVm9HVHJMbnZHVHJNWDNHVHJNYm9HVHZLbDNHWkNsRm5HWnJEVDNHWjhEVHJHWjhGWjhHWjhNWHZHWjhPbjhHWjhTVDNHYkNuUVhHYk1iRm5HYm9GYm9HYm9KZzNHYm9NWG9HYjNKVHZHYjNKYm9HYjNNbjZHYjNRYjhHZ0RYTGpHZ01uQVVHZ3JEbG9HZ3JIWDRHZ3JTVG9HZ3ZBWHJHZ3ZBWnZHZ3ZGYnJHZ3ZMbDNHZ3ZNbnZHbkRuTFhHbnJBVHJHbnJNYm9HbnVMbDNIVEFUTW5IVEFnQ25IVENUQ1RIVHJHVHZIVHJIVHZIVHJKWDhIVHJMbDhIVHJNVDhIVHJNZ29IVHJPVHJIVHVPbjNIVHZBWnJIVHZEVHZIVHZHYm9IVHZKVThIVHZMbDNIVHZNWHJIVHZRYjRIVDRHVDZIVDRKVDhIVDRKYiNIVDhBbDNIVDhHWnJIVDhHZ3JIVDhIWDRIVDhKYjhIVDhKbm9IVDhMVHJIVDhMZ3ZIVDhTVG9IVDhTVjhIVW9KVW9IVW9KWDhIVW9MbnJIWHJMWm9IWHZBbDNIWDNMbnJIWDRGa3ZIWDRMaHJIWDRNWG9IWDRPbm9IWnJBWjhIWnJEYjhIWnJHWjhIWnJKbnJIWnZHWjhIWnZMbnZIWjhKbnZIWjhMaHJIYkNYSmxIYk1UQW5IYm9KbDRIYnBMbDNIYnJKWDhIYnJMbnJIYnJNbnZIYnZSWXJIZ29TVHJIZ3JGVjhIZ3JHWjhIZ3JKWG9IZ3JSbnZIZ3ZCYiFIZ3ZHVHJIZ3ZIWDRIZ3ZIbiFIZ3ZMVHJIZ3ZTVThIbkRuTGJIbkZiSmJIbnZEbjhIbjZHZ3ZIbiFCVHZKVENUTG5KVFFnRm5KVHJBbnZKVHJMWDRKVHJPVW9KVHZGbjNKVHZMbnJKVHZOVG9KVDNBZ29KVDNKbjRKVDNMaHZKVDNPYnJKVDhBY3JKVDhBbDNKVDhKVDhKVDhKbm9KVDhMWDRKVDhMbnJKVDhNWDNKVDhSZzNKVDhTYzhKVW9CVHZKVThBVG9KVThHWjhKVThHZ3ZKVThKVHJKVThKWHJKVThKbnJKVThMbnZKVThTY3ZKWEhuSmxKWHJHZ3ZKWHJKVThKWHJMaHJKWHJNVDhKWHJNWHJKWHJRVW9KWHZDVHZKWHZHWjhKWHZHZ3JKWHZRVDhKWDhBYjhKWDhEVDhKWDhHWjhKWDhIWnZKWDhMbnJKWDhNVDhKWDhNWG9KWDhNbnZKWDhTVDNKWUduQ1RKYkFrR2JKYkNUQW5KYkxUQWNKYm9EVDNKYm9MYjZKYnJBbnZKYnJDbjNKYnJEbDhKYnJHYm9KYnJJWm9KYnJKbnZKYnJNbnZKYnJRYjRKYjhSWnJKZUFiQW5KZ0puRmJKZ1NjQW5KZ3JBVHJKZ3ZIWjhKZ3ZNbjRKbEpsRmJKbExpUVhKbExqT25KbFJiT2xKbHZOWG9KbHZSbDNKbDRBY3JKbDhBVW9KbDhNbnJKbkZuTWxKbkhnR2JKbm9EVDhKbm9GVjhKbm9HZ3ZKbm9JVDhKbm9RVG9Kbm9SZzNKbnJDWjNKbnJHZ3JKbnJIVHZKbnJMZjhKbnJPWDhKbnZBVDNKbnZGWm9KbnZHVDhKbnZKbDRKbnZNVDhKbnZNWDhKbnZPWHJKbnZQWDZKbnZTWDNKbnZTWnJKbjNNVDhKbjNNWDhKbjNSVHJMVEFUS25MVEpuTFRMVE1YS25MVFJUUWxMVG9HYjhMVHJBWjhMVHJDWjhMVHJEYjhMVHJIVDhMVDNQWDZMVDRGWm9MVCRDVHZMVCRHZ3JMVXZIWDNMVm9BVHJMVm9BZ29MVm9KYm9MVm9NWDNMVm9SZzNMVjhDWjNMVjhGWm9MVjhHVHZMWHJEWG9MWHJGYnJMWHZBZ3ZMWHZGbHJMWHZMbDNMWHZSbjZMWDRNYjhMWDhHVDhMWUNYTW5MWXJNbnJMWm9TVHZMWnJBWnZMWnJBbG9MWnJGVG9MWnJKWHZMWnJKYm9MWnJKbDRMWnJMbnJMWnJNVDhMWnJPZ3ZMWnJSbnZMWnJTVDRMWnZNWDhMWnZTbHZMWjhBZ29MWjhDVDNMWjhKVDhMWjhMVjhMWjhMWm9MWjhMZzhMWjhTVjhMWjhTYnJMWiRIVDhMWiRNbjRMYTZDVHZMYkZiTW5MYlJZRlRMYlNuRlpMYm9KVDhMYnJBVDlMYnJHYjNMYnJRYjhMY3JKWDhMY3JNWHJMZXJIVHZMZXJKYnJMZXJOYm9MZ3JEYjhMZ3JHWjhMZ3JIVHJMZ3JNWHJMZ3JTVThMZ3ZKVHJMZ3ZMbDNMZzZMbDNMaHJMbnJMaHJNVDhMaHZBbDRMaUxuUVhMa29BZ3JMa29KVDhMa29KbjRMbHJTVThMbDNGWm9MbDNIVHJMbDNKWDhMbDNKbm9MbDNMVG9MbUxlRmJMbkRVRmJMbkxWQW5MbnJBVHJMbnJBWm9MbnJBYjhMbnJBbHJMbnJHZ3ZMbnJKVThMbnJMWnJMbnJMaHJMbnJNYjhMbnJPWHJMbnJTWjhMbnZBYjRMbnZEVHJMbnZEbDhMbnZIVHJMbnZIYnJMbnZKVDhMbnZKVThMbnZKYnJMbnZMaHZMbnZNWDhMbnZNYjhMbnZObm9MbnZTVThMbjNBbDNMbjRGWm9MbjRHVDZMbjRKZ3ZMbjRMaHJMbjRNVDhMbjRTVG9NVG9DWnJNVG9KWDhNVG9MWDRNVG9MZjhNVG9SZzNNVHJFbG9NVHZHYjZNVDNCVHJNVDNMYjZNVDhBY3JNVDhBZ3JNVDhHWnJNVDhKbm9NVDhMbnJNVDhNWDNNVU9VQW5NWEFiRm5NWG9BbG9NWG9KWDhNWG9MZjhNWG9MbDhNWHJBYjhNWHJEVHZNWHJHVDhNWHJHZ3JNWHJIVHJNWHJMZjhNWHJNVThNWHJPWHZNWHJRYjhNWHZHVDhNWHZIVHJNWHZMVm9NWDNBWDNNWDNKbjNNWDNMaHJNWDNNWDNNWDRBbHJNWDRPYm9NWDhHVHZNWDhHWnJNWDhHZ3JNWDhKVDhNWDhKWDhNWDhMaHJNWDhNVDhNWURVRmJNWU1nRGJNYkduRmZNYnZMWDRNYnZMbDNNYjhNYjhNYjhTVDRNZ0dYQ25NZzhBVHJNZzhBZ29NZzhDWnJNZzhEVHJNZzhEYm9NZzhIVHJNZzhKZ3JNZzhMVDhNbG9KWG9NbDhBaHJNbDhKVDhNbkxnQVVNbm9KWHJNbm9MWDRNbm9MaHJNbm9NVDhNbnJBbDRNbnJEYjhNbnJPVHZNbnJPZ3ZNbnJRYjhNbnJTVThNbnZHZ3JNbnZIWjhNbjNNVG9NbjREVHJNbjRMVHJNbjRNZzhObkJYQW5PVEZURm5PVG9BVG9PVHJHZ3ZPVHJKWDhPVDNKWG9PVDZNVHJPVDhHZ3JPVDhIVHBPVDhNVG9PVW9IVDhPVW9KVDhPVW9MbjNPWHJBZ29PWHJEZzhPWHJNVDhPWHZTVG9PWDZDVHZPWDhDWnJPWDhPZ3JPYjZIZ3ZPYjhBVG9PYjhNVDhPY3ZMWjhPZ3ZBbHJPZ3ZIVHZPZ3ZKVHJPZ3ZKbnJPZ3ZMWnJPZ3ZMbjRPZ3ZNVDhPZ3ZSVHJPZzhBWm9PZzhEYnZPbnJPWG9PbnZKbjRPbnZMaHZPbnZSVHJPbjNHZ29PbjNKbnZPbjZKYnZPbjhPVHJQVEdZRlRQYkJuRm5QYkduRG5QZ0RZUVRQbHJBbnZQbHJFVHZQbHJMbnZQbHJNWHZQbHZGWDRRVE1UQW5RVHJKVThRWUNuSmxRWUpsUWxRYkdUUWJRYjhKbnJRYjhMWm9RYjhMbnZRYjhNVDhRYjhNbDhRYjhTVDRRbG9BbDRRbG9IWnZRbG9KWDhRbG9NbjhRbkpaT2xSVHJBWnZSVHJEVHJSVHZKbjRSVHZMaHZSVDRKYjhSWnJBWnJSWjhBa3JSWjhKVThSWjhMVjhSWjhMbnZSYkpsUVhSZzNHYm9SZzNNbnZSZzhBWjhSZzhKYm9SZzhKbDRSbkxUQ2JSbnZGbDNSbnZRYjhTVG9BbDRTVG9DWnJTVG9GWm9TVG9IWHJTVG9KVThTVG9KZ3ZTVG9KbDRTVG9MaHJTVG9NWDNTVHJBbHZTVHJDVDlTVHJDZ3JTVHJHZ3JTVHJIWHJTVHJIYm9TVHJKbm9TVHJOYm9TVHZMbnJTVDRBWm9TVDhBYjhTVDhKVDhTVW9KbjNTVTZIWiNTVTZKVHZTVThEYjhTVThIYm9TVThMZ3JTVjhKVDhTWnJBY3JTWnJBbDNTWnJKVDhTWnJKbnZTWnJNVDhTWnZMVW9TWjRGWm9TWjhKbm9TWjhSWnJTY29MbnJTY29NVDhTY29NWDhTY3JBVDRTY3JBWjhTY3JMWjhTY3JMa3ZTY3ZEYjhTY3ZMZjhTY3ZOVG9TZ3JGWnJTaHZLbnJTbG9IVW9TbG9MbnJTbHJNWG9TbDhIZ3JTbXJKVW9TbjNCWDZcIixcIkFURmxPbjNBVExnckRZQVQ0TVRBbkFUOExUTW5BWUpuUlRyQWJHZ0puckFiTFY4TG5BYnZOVEFuQWVGYkxnM0FnT1lNWG9BbFFiRmJvQW5EYm9BZkFuSmdvSlRCVG9EZ0FuQlVKYkFsM0Jib0RVQW5DVERsdkxuQ1RGVHJTbkNZb1FUTG5EVHdBYkFuRFVEVHJTbkRVSGdIZ3JEWDhMWEZuRGJKWEFjckVUdkxUTG5HVEZUUWJyR1RNbkdUb0dUM0RVRmJHVUpsUFgzR2JRZzhMbkdib0piRm5HYjNHZ0FZR2dBZzhTY0dnTWJBWHJHZ3ZBYkFuR25KVExudkdudkFURmdIVERUNkFUSFRyRGxKbkhZTG5NbjhIWnJTYkpUSFo4TFRGbkhiRlRKVW9IZ1NlTVQ4SGdyTGpBbkhndkFiQW5IbEZVckRsSG5EZ3ZBbkhuSFRGVDNIblFUR25ySlRBYU1YdkpUR2JDbjNKVE9nckFuSlh2QVhNbkpiTWc4U25KYk1uUmczSmI4TFRNbkpuQWwzT25KbkdZclFsSm5KbFFZM0xURGxDbjNMVEpqTGczTFRMZ3ZGWExUTWczR1RMVjhIVU9nTFhGWkxnM0xYTlhyTW5MWDhRWEZuTFg5QWxNWUxZTFhQWHJMWkFiSlU4TFpEVUpVOExaTVhyU25MWiRBZ0ZuTGFQWHJEVUxiRllyTW5MYk1uOExYTGJvSmdKZ0xlRmJMZzNMZ0xaclNuTGdPWUFnb0xoclJuSmxMa0NUclNuTGtPbkxockxuRlglQVlMbkZab0pYTG5IVHZKYkxuTGxvQWJNVEFUTGY4TVRIZ0puM01UTVhyQVhNVDNNVEZuTVVJVHZGbk1YRlglQVlNWE1YdkZiTVhyRlREYk1ZQWNNWDNNYkxmOFNuTWI4SmJGbk1nTVhyTVRNZ3ZBWEZuTWd2R2dDbU1uQWxvU25NbkZuSlRyT1h2TVhTbk9YOEhUTW5PYkpUOFNjT2JMWkZsM09iTVhDWm9QVExnclFYUFVGbm9RWFBVM1JYSmxQWDNSa1FYUGJySlhRbFBsckpiRm5RVUFockRiUVhHbkNYdlFZTG5IbHZRYkxmTG52UlRPZ3ZKYlJYSllyUWxSWUxuclFsUmJMbnJRbFJsRlQ4SmxSbEZuclFYU1RDbENuM1NUSFRyQW5TVExaUWxyU1RNbkdUclNUb0hnR2JTVHJHVERuU1R2R1hDblNUM0hnRmJTVTNIWEFYU2JBbkpuM1NiRlQ4TG5TY0xmTG52XCIsXCJBVDNKZ0pYOEFUOEZab1NuQVQ4SmdGVjhBVDhMaHJEYkFaOEpUOERiQWI4R2dMaHJBYjhTa0xudkFlOE1UOFNuQWxNWUpYTFZBbDNHWURUdkFsM0xmTG52QlVEVHZMbDNDVE9uM0hUckNUM0RVR2dyQ1U4TVQ4QWJDYkZUckpVb0NnckRiOE1URFRMVjhKWDhEVExuTFhRbERUOExaclNuRFVRYjhGWjhEVVNUNEpudkRiOFNjT1VvRGo2R2JKbDRHVExmQ1lNbEdUb0FYdkZuR2JvQVh2TG5HZ0FjckpuM0dndkZuU1RvR25MZjhKbnZHbiNIVERUb0hUTG5GWEpsSFR2QVRGVG9IVHZIVERUb0hUdk1UQWdvSFQzU1RDbHZIVDRBbEZsNkhUOEhURFRvSFVvRGdKVHJIVW9TY01YM0hiUlpyTVhvSGJvSmc4TFRIZ0RiOEpUckhnTVRvTGY4SGd2TG5Mbm9IbkhuM0hUNEhuNk1ndkFuSlRKVThTY3ZKVDNBYVFUOEpUOEhUckFuSlhyUmc4QW5KYkFsb01Yb0pickFURlRvSmJ2TW5vU25KZ0RiNkdndkpnRGI4TVhvSmdTWDNKVThKZ3VBVEZUb0psUFlMblFsSmxRa0RuTGJKbFFsRllKbEpsOExmOE9USm5DVEZuTGJKbkxUSFhNbkpuTFhHWENuSm5vRmZSZzNKbnJNWVJnM0puM0hnRmwzS1Q4RGc4TG5MVFJsRm5QVExUdlBiTGJ2TFZvU2JyQ1pMWE1ZNkhUM0xYTlU3RGxyTFhOWERUQVRMWDhEWDhMbkxaRGI4SlU4TFpNbm9MaHJMWlNUb0pVOExackxhTG5yTFp2Sm4zU25MWjhMaHJTbkxhSm5vTVQ4TGJGbHJIVHZMYnJGVExuckxidkFUTGx2TGI2T1RGbjNMY0xuSlpPbExlQVQ2TW40TGVKVDNPYnJMZzZMWEZsckxockpnOExuTGh2RGxQWDRMaHZMZkxudkxqNkpURlQzTG5GYnJNWG9MblFsdUNUdkxuclFYQ1k2TG52TGZMbnZMbnZNZ0xudkxudlNlTGY4TVRNYnJKbjNNVDNKZ1NUM01UOEFuQVRyTVQ4TFVMbnJNVU1Ub0Nack1VU2N2TGY4TVhvRFQ4U25NWDZBVEZUb01YOEFYTVQ4TVg4RmtNVDhNWDhIVHJEVU1YOFNjb1NuTVlKVDZDVHZNZ0Fjck1Yb01nOFNUb0FmTWx2QVhMZzNNbkZsM0Fudk9UM0FuRmwzT1VvQVRIVDhPVTNSbkxYck9Yck9YclNuT2JQYnZGbjZPZzhIZ3JTbk9nOE9YOERiUFR2QWdvSmdQVTNSWUxuclBYckRuSlpyUGI4Q1RHZ3ZQbHJMVERsdlBsdkZVSm5vUVV2RlhyUWxRZU1ub0FsM1FsclFsclNuUlRGVHJKVW9TVERsTGlMWFNURmc2SFQzU1RKZ29NbjRTVHJGVEpUclNUckxaRmwzU1Q0Rm5NWG9TVXJEbEhVb1NjdkhUdlNuU2ZMa3ZNWG9cIixcIkFVb0Fjck1Yb0FaOEhib0FnOEFiT2c2QVRGZ0FnOEFsb01Yb0FsM0FUOEpUckFsOE1YOE1Yb0NUM1NUb0pVOENsOERiOE1Yb0RUOEhnckFUckRib09UOE1Yb0dUT1RyQVRNbkdUOExockFaOEdudkZuR25RWEhUb0dndkFjckhUdkFYdkxsM0hickFab01Yb0hnQmxGWExnM0hnTW5GWHJTbkhnclNiOEpVb0huNkhUOExndklUdkFUckpVb0pVb0xaclJudkpVOEhUOEpiOEpYdkZYOFFUOEpYdkxUb0pUckpZclFuR25RWEpnckpub0FUckpub0pVOFNjdkpudk1udk1Yb0xUQ1RMZ3JKWExUSmxSVHZRbExiUm5KbFFZdkxick1iOExudkxidkZuM1Jub0xkQ1ZTVEdackxlU1R2R1hDbkxnM01ub0xuM01Ub0xsckVUdk1UOFNUb0FsM01ickRVNkdUdk1iOExYNExoclBsckxYR1hDblNUb0xmOFJnM1NUckRiOExUclNUdkxUSFhNblNiM1JZTG5NblNnT2c2QVRGZ1wiLFwiSFVEbEduclFYckpUckhnTG5yQWNKWU1iOERVTGM4TFR2RmdHbkNrM01nOEpiQW5MWDRRWXZGWUhuTVhyUlVvSm5HbnZGblJsdkZUSmxRbm9TVHJCWEhYckxZU1VKZ0xmb01UOFNlOERUckhiRGJcIixcIkFiRGw4U1RvSlU4QW4zUmJBYjhTVDhEVVNUckduckFnb0xiRlU2RGI4TFRyTWc4QWFIVDhKYjhPYkRsOFNUb0pVOFBiM1JsdkZZb0psXCJdO2NvbnN0IGNvZGVzPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkhQCMkJV4mKlwiO2Z1bmN0aW9uIGdldEhhbmd1bChjb2RlKXtpZihjb2RlPj00MCl7Y29kZT1jb2RlKzE2OC00MH1lbHNlIGlmKGNvZGU+PTE5KXtjb2RlPWNvZGUrOTctMTl9cmV0dXJuIHRvVXRmOFN0cmluZyhbMjI1LChjb2RlPj42KSsxMzIsKGNvZGUmNjMpKzEyOF0pfWxldCB3b3JkbGlzdCQ1PW51bGw7ZnVuY3Rpb24gbG9hZFdvcmRzJDUobGFuZyl7aWYod29yZGxpc3QkNSE9bnVsbCl7cmV0dXJufXdvcmRsaXN0JDU9W107ZGF0YSQxLmZvckVhY2goKGRhdGEsbGVuZ3RoKT0+e2xlbmd0aCs9NDtmb3IobGV0IGk9MDtpPGRhdGEubGVuZ3RoO2krPWxlbmd0aCl7bGV0IHdvcmQ9XCJcIjtmb3IobGV0IGo9MDtqPGxlbmd0aDtqKyspe3dvcmQrPWdldEhhbmd1bChjb2Rlcy5pbmRleE9mKGRhdGFbaStqXSkpfXdvcmRsaXN0JDUucHVzaCh3b3JkKX19KTt3b3JkbGlzdCQ1LnNvcnQoKTtpZihXb3JkbGlzdC5jaGVjayhsYW5nKSE9PVwiMHhmOWVkZGVhY2U5YzVkM2RhOWM5M2NmN2QzY2QzOGY2YTEzZWQzYWZmYjkzMzI1OWFlODY1NzE0ZThhM2FlNzFhXCIpe3dvcmRsaXN0JDU9bnVsbDt0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3Iga28gKEtvcmVhbikgRkFJTEVEXCIpfX1jbGFzcyBMYW5nS28gZXh0ZW5kcyBXb3JkbGlzdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwia29cIil9Z2V0V29yZChpbmRleCl7bG9hZFdvcmRzJDUodGhpcyk7cmV0dXJuIHdvcmRsaXN0JDVbaW5kZXhdfWdldFdvcmRJbmRleCh3b3JkKXtsb2FkV29yZHMkNSh0aGlzKTtyZXR1cm4gd29yZGxpc3QkNS5pbmRleE9mKHdvcmQpfX1jb25zdCBsYW5nS289bmV3IExhbmdLbztXb3JkbGlzdC5yZWdpc3RlcihsYW5nS28pO1widXNlIHN0cmljdFwiO2NvbnN0IHdvcmRzJDQ9XCJBYmFjb0FiYmFnbGlvQWJiaW5hdG9BYmV0ZUFiaXNzb0Fib2xpcmVBYnJhc2l2b0Ficm9nYXRvQWNjYWRlcmVBY2Nlbm5vQWNjdXNhdG9BY2V0b25lQWNoaWxsZUFjaWRvQWNxdWFBY3JlQWNyaWxpY29BY3JvYmF0YUFjdXRvQWRhZ2lvQWRkZWJpdG9BZGRvbWVBZGVndWF0b0FkZXJpcmVBZGlwZUFkb3R0YXJlQWR1bGFyZUFmZmFiaWxlQWZmZXR0b0FmZmlzc29BZmZyYW50b0Fmb3Jpc21hQWZvc29BZnJpY2Fub0FnYXZlQWdlbnRlQWdldm9sZUFnZ2FuY2lvQWdpcmVBZ2l0YXJlQWdvbmlzbW9BZ3JpY29sb0FncnVtZXRvQWd1enpvQWxhYmFyZGFBbGF0b0FsYmF0cm9BbGJlcmF0b0FsYm9BbGJ1bWVBbGNlQWxjb2xpY29BbGV0dG9uZUFsZmFBbGdlYnJhQWxpYW50ZUFsaWJpQWxpbWVudG9BbGxhZ2F0b0FsbGVncm9BbGxpZXZvQWxsb2RvbGFBbGx1c2l2b0FsbWVub0Fsb2dlbm9BbHBhY2FBbHBlc3RyZUFsdGFsZW5hQWx0ZXJub0FsdGljY2lvQWx0cm92ZUFsdW5ub0FsdmVvbG9BbHphcmVBbWFsZ2FtYUFtYW5pdGFBbWFyZW5hQW1iaXRvQW1icmF0b0FtZWJhQW1lcmljYUFtZXRpc3RhQW1pY29BbW1hc3NvQW1tZW5kYUFtbWlyYXJlQW1tb25pdG9BbW9yZUFtcGlvQW1wbGlhcmVBbXVsZXRvQW5hY2FyZG9BbmFncmFmZUFuYWxpc3RhQW5hcmNoaWFBbmF0cmFBbmNhQW5jZWxsYUFuY29yYUFuZGFyZUFuZHJlYUFuZWxsb0FuZ2Vsb0FuZ29sYXJlQW5ndXN0b0FuaW1hQW5uZWdhcmVBbm5pZGF0b0Fubm9Bbm51bmNpb0Fub25pbW9BbnRpY2lwb0FuemlBcGF0aWNvQXBlcnR1cmFBcG9kZUFwcGFyaXJlQXBwZXRpdG9BcHBvZ2dpb0FwcHJvZG9BcHB1bnRvQXByaWxlQXJhYmljYUFyYWNoaWRlQXJhZ29zdGFBcmFsZGljYUFyYW5jaW9BcmF0dXJhQXJhenpvQXJiaXRyb0FyY2hpdmlvQXJkaXRvQXJlbmlsZUFyZ2VudG9BcmdpbmVBcmd1dG9BcmlhQXJtb25pYUFybmVzZUFycmVkYXRvQXJyaW5nYUFycm9zdG9BcnNlbmljb0Fyc29BcnRlZmljZUFyemlsbG9Bc2NpdXR0b0FzY29sdG9Bc2Vwc2lBc2V0dGljb0FzZmFsdG9Bc2lub0Fzb2xhQXNwaXJhdG9Bc3Byb0Fzc2FnZ2lvQXNzZUFzc29sdXRvQXNzdXJkb0FzdGFBc3RlbnV0b0FzdGljZUFzdHJhdHRvQXRhdmljb0F0ZWlzbW9BdG9taWNvQXRvbm9BdHRlc2FBdHRpdmFyZUF0dG9ybm9BdHRyaXRvQXR0dWFsZUF1c2lsaW9BdXN0cmlhQXV0aXN0YUF1dG9ub21vQXV0dW5ub0F2YW56YXRvQXZlcmVBdnZlbmlyZUF2dmlzb0F2dm9sZ2VyZUF6aW9uZUF6b3RvQXp6aW1vQXp6dXJyb0JhYmVsZUJhY2Nhbm9CYWNpbm9CYWNvQmFkZXNzYUJhZGlsYXRhQmFnbmF0b0JhaXRhQmFsY29uZUJhbGRvQmFsZW5hQmFsbGF0YUJhbHphbm9CYW1iaW5vQmFuZGlyZUJhcmFvbmRhQmFyYmFyb0JhcmNhQmFyaXRvbm9CYXJsdW1lQmFyb2Njb0Jhc2lsaWNvQmFzc29CYXRvc3RhQmF0dHV0b0JhdWxlQmF2YUJhdm9zYUJlY2NvQmVmZmFCZWxnaW9CZWx2YUJlbmRhQmVuZXZvbGVCZW5pZ25vQmVuemluYUJlcmVCZXJsaW5hQmV0YUJpYml0YUJpY2lCaWRvbmVCaWZpZG9CaWdhQmlsYW5jaWFCaW1ib0Jpbm9jb2xvQmlvbG9nb0JpcGVkZUJpcG9sYXJlQmlyYmFudGVCaXJyYUJpc2NvdHRvQmlzZXN0b0Jpc25vbm5vQmlzb250ZUJpc3R1cmlCaXp6YXJyb0JsYW5kb0JsYXR0YUJvbGxpdG9Cb25pZmljb0JvcmRvQm9zY29Cb3Rhbmljb0JvdHRpbm9Cb3p6b2xvQnJhY2Npb0JyYWRpcG9CcmFtYUJyYW5jYUJyYXZ1cmFCcmV0ZWxsYUJyZXZldHRvQnJlenphQnJpZ2xpYUJyaWxsYW50ZUJyaW5kYXJlQnJvY2NvbG9Ccm9kb0Jyb256aW5hQnJ1bGxvQnJ1bm9CdWJib25lQnVjYUJ1ZGlub0J1ZmZvbmVCdWlvQnVsYm9CdW9ub0J1cmxvbmVCdXJyYXNjYUJ1c3NvbGFCdXN0YUNhZGV0dG9DYWR1Y29DYWxhbWFyb0NhbGNvbG9DYWxlc3NlQ2FsaWJyb0NhbG1vQ2Fsb3JpYUNhbWJ1c2FDYW1lcmF0YUNhbWljaWFDYW1taW5vQ2Ftb2xhQ2FtcGFsZUNhbmFwYUNhbmRlbGFDYW5lQ2FuaW5vQ2Fub3R0b0NhbnRpbmFDYXBhY2VDYXBlbGxvQ2FwaXRvbG9DYXBvZ2lyb0NhcHBlcm9DYXByYUNhcHN1bGFDYXJhcGFjZUNhcmNhc3NhQ2FyZG9DYXJpc21hQ2Fyb3ZhbmFDYXJyZXR0b0NhcnRvbGluYUNhc2FjY2lvQ2FzY2F0YUNhc2VybWFDYXNvQ2Fzc29uZUNhc3RlbGxvQ2FzdWFsZUNhdGFzdGFDYXRlbmFDYXRyYW1lQ2F1dG9DYXZpbGxvQ2VkaWJpbGVDZWRyYXRhQ2VmYWxvQ2VsZWJyZUNlbGx1bGFyZUNlbmFDZW5vbmVDZW50ZXNpbW9DZXJhbWljYUNlcmNhcmVDZXJ0b0NlcnVtZUNlcnZlbGxvQ2Vzb2lhQ2VzcG9DZXRvQ2hlbGFDaGlhcm9DaGljY2FDaGllZGVyZUNoaW1lcmFDaGluYUNoaXJ1cmdvQ2hpdGFycmFDaWFvQ2ljbGlzbW9DaWZyYXJlQ2lnbm9DaWxpbmRyb0Npb3R0b2xvQ2lyY2FDaXJyb3NpQ2l0cmljb0NpdHRhZGlub0NpdWZmb0NpdmV0dGFDaXZpbGVDbGFzc2ljb0NsaW5pY2FDbG9yb0NvY2NvQ29kYXJkb0NvZGljZUNvZXJlbnRlQ29nbm9tZUNvbGxhcmVDb2xtYXRvQ29sb3JlQ29scG9zb0NvbHRpdmF0b0NvbHphQ29tYUNvbWV0YUNvbW1hbmRvQ29tb2RvQ29tcHV0ZXJDb211bmVDb25jaXNvQ29uZHVycmVDb25mZXJtYUNvbmdlbGFyZUNvbml1Z2VDb25uZXNzb0Nvbm9zY2VyZUNvbnN1bW9Db250aW51b0NvbnZlZ25vQ29wZXJ0b0NvcGlvbmVDb3BwaWFDb3ByaWNhcG9Db3JhenphQ29yZGF0YUNvcmljYXRvQ29ybmljZUNvcm9sbGFDb3Jwb0NvcnJlZG9Db3JzaWFDb3J0ZXNlQ29zbWljb0Nvc3RhbnRlQ290dHVyYUNvdmF0b0NyYXRlcmVDcmF2YXR0YUNyZWF0b0NyZWRlcmVDcmVtb3NvQ3Jlc2NpdGFDcmV0YUNyaWNldG9DcmluYWxlQ3Jpc2lDcml0aWNvQ3JvY2VDcm9uYWNhQ3Jvc3RhdGFDcnVjaWFsZUNydXNjYUN1Y2lyZUN1Y3Vsb0N1Z2lub0N1bGxhdG9DdXBvbGFDdXJhdG9yZUN1cnNvcmVDdXJ2b0N1c2Npbm9DdXN0b2RlRGFkb0RhaW5vRGFsbWF0YURhbWVyaW5vRGFuaWVsYURhbm5vc29EYW56YXJlRGF0YXRvRGF2YW50aURhdnZlcm9EZWJ1dHRvRGVjZW5uaW9EZWNpc29EZWNsaW5vRGVjb2xsb0RlY3JldG9EZWRpY2F0b0RlZmluaXRvRGVmb3JtZURlZ25vRGVsZWdhcmVEZWxmaW5vRGVsaXJpb0RlbHRhRGVtZW56YURlbm90YXRvRGVudHJvRGVwb3NpdG9EZXJhcGF0YURlcml2YXJlRGVyb2dhRGVzY3JpdHRvRGVzZXJ0b0Rlc2lkZXJpb0Rlc3VtZXJlRGV0ZXJzaXZvRGV2b3RvRGlhbWV0cm9EaWNlbWJyZURpZWRyb0RpZmVzb0RpZmZ1c29EaWdlcmlyZURpZ2l0YWxlRGlsdXZpb0RpbmFtaWNvRGlubmFuemlEaXBpbnRvRGlwbG9tYURpcG9sb0RpcmFkYXJlRGlyZURpcm90dG9EaXJ1cG9EaXNhZ2lvRGlzY3JldG9EaXNmYXJlRGlzZ2Vsb0Rpc3Bvc3RvRGlzdGFuemFEaXN1bWFub0RpdG9EaXZhbm9EaXZlbHRvRGl2aWRlcmVEaXZvcmF0b0RvYmxvbmVEb2NlbnRlRG9nYW5hbGVEb2dtYURvbGNlRG9tYXRvRG9tZW5pY2FEb21pbmFyZURvbmRvbG9Eb25vRG9ybWlyZURvdGVEb3R0b3JlRG92dXRvRG96emluYURyYWdvRHJ1aWRvRHViYmlvRHViaXRhcmVEdWNhbGVEdW5hRHVvbW9EdXBsaWNlRHVyYXR1cm9FYmFub0VjY2Vzc29FY2NvRWNsaXNzaUVjb25vbWlhRWRlcmFFZGljb2xhRWRpbGVFZGl0b3JpYUVkdWNhcmVFZ2Vtb25pYUVnbGlFZ29pc21vRWdyZWdpb0VsYWJvcmF0b0VsYXJnaXJlRWxlZ2FudGVFbGVuY2F0b0VsZXR0b0VsZXZhcmVFbGZpY29FbGljYUVsbW9FbHNhRWx1c29FbWFuYXRvRW1ibGVtYUVtZXNzb0VtaXJvRW1vdGl2b0Vtb3ppb25lRW1waXJpY29FbXVsb0VuZGVtaWNvRW5kdXJvRW5lcmdpYUVuZmFzaUVub3RlY2FFbnRyYXJlRW56aW1hRXBhdGl0ZUVwaWxvZ29FcGlzb2Rpb0Vwb2NhbGVFcHB1cmVFcXVhdG9yZUVyYXJpb0VyYmFFcmJvc29FcmVkZUVyZW1pdGFFcmlnZXJlRXJtZXRpY29Fcm9lRXJvc2l2b0VycmFudGVFc2Fnb25vRXNhbWVFc2FuaW1lRXNhdWRpcmVFc2NhRXNlbXBpb0VzZXJjaXRvRXNpYml0b0VzaWdlbnRlRXNpc3RlcmVFc2l0b0Vzb2ZhZ29Fc29ydGF0b0Vzb3NvRXNwYW5zb0VzcHJlc3NvRXNzZW56YUVzc29Fc3Rlc29Fc3RpbWFyZUVzdG9uaWFFc3Ryb3NvRXN1bHRhcmVFdGlsaWNvRXRuaWNvRXRydXNjb0V0dG9FdWNsaWRlb0V1cm9wYUV2YXNvRXZpZGVuemFFdml0YXRvRXZvbHV0b0V2dml2YUZhYmJyaWNhRmFjY2VuZGFGYWNoaXJvRmFsY29GYW1pZ2xpYUZhbmFsZUZhbmZhcmFGYW5nb0ZhbnRhc21hRmFyZUZhcmZhbGxhRmFyaW5vc29GYXJtYWNvRmFzY2lhRmFzdG9zb0Zhc3VsbG9GYXRpY2FyZUZhdG9GYXZvbG9zb0ZlYmJyZUZlY29sYUZlZGVGZWdhdG9GZWxwYUZlbHRyb0ZlbW1pbmFGZW5kZXJlRmVub21lbm9GZXJtZW50b0ZlcnJvRmVydGlsZUZlc3N1cmFGZXN0aXZvRmV0dGFGZXVkb0ZpYWJhRmlkdWNpYUZpZmFGaWd1cmF0b0ZpbG9GaW5hbnphRmluZXN0cmFGaW5pcmVGaW9yZUZpc2NhbGVGaXNpY29GaXVtZUZsYWNvbmVGbGFtZW5jb0ZsZWJvRmxlbW1hRmxvcmlkb0ZsdWVudGVGbHVvcm9Gb2JpY29Gb2NhY2NpYUZvY29zb0ZvZGVyYXRvRm9nbGlvRm9sYXRhRm9sY2xvcmVGb2xnb3JlRm9uZGVudGVGb25ldGljb0ZvbmlhRm9udGFuYUZvcmJpdG9Gb3JjaGV0dGFGb3Jlc3RhRm9ybWljYUZvcm5haW9Gb3JvRm9ydGV6emFGb3J6YXJlRm9zZmF0b0Zvc3NvRnJhY2Fzc29GcmFuYUZyYXNzaW5vRnJhdGVsbG9GcmVjY2V0dGFGcmVuYXRhRnJlc2NvRnJpZ29Gcm9sbGlub0Zyb25kZUZydWdhbGVGcnV0dGFGdWNpbGF0YUZ1Y3NpYUZ1Z2dlbnRlRnVsbWluZUZ1bHZvRnVtYW50ZUZ1bWV0dG9GdW1vc29GdW5lRnVuemlvbmVGdW9jb0Z1cmJvRnVyZ29uZUZ1cm9yZUZ1c29GdXRpbGVHYWJiaWFub0dhZmZlR2FsYXRlb0dhbGxpbmFHYWxvcHBvR2FtYmVyb0dhbW1hR2FyYW56aWFHYXJib0dhcm9mYW5vR2Fyem9uZUdhc2RvdHRvR2Fzb2xpb0dhc3RyaWNvR2F0dG9HYXVkaW9HYXplYm9HYXp6ZWxsYUdlY29HZWxhdGluYUdlbHNvR2VtZWxsb0dlbW1hdG9HZW5lR2VuaXRvcmVHZW5uYWlvR2Vub3RpcG9HZXJnb0doZXBhcmRvR2hpYWNjaW9HaGlzYUdpYWxsb0dpbGRhR2luZXByb0dpb2NhcmVHaW9pZWxsb0dpb3Jub0dpb3ZlR2lyYXRvR2lyb25lR2l0dGF0YUdpdWRpemlvR2l1cmF0b0dpdXN0b0dsb2J1bG9HbHV0aW5lR25vbW9Hb2JiYUdvbGZHb21pdG9Hb21tb25lR29uZmlvR29ubmFHb3Zlcm5vR3JhY2lsZUdyYWRvR3JhZmljb0dyYW1tb0dyYW5kZUdyYXR0YXJlR3Jhdm9zb0dyYXppYUdyZWNhR3JlZ2dlR3JpZm9uZUdyaWdpb0dyaW56YUdyb3R0YUdydXBwb0d1YWRhZ25vR3VhaW9HdWFudG9HdWFyZGFyZUd1Zm9HdWlkYXJlSWJlcm5hdG9JY29uYUlkZW50aWNvSWRpbGxpb0lkb2xvSWRyYUlkcmljb0lkcm9nZW5vSWdpZW5lSWduYXJvSWdub3JhdG9JbGFyZUlsbGVzb0lsbG9naWNvSWxsdWRlcmVJbWJhbGxvSW1iZXZ1dG9JbWJvY2NvSW1idXRvSW1tYW5lSW1tZXJzb0ltbW9sYXRvSW1wYWNjb0ltcGV0b0ltcGllZ29JbXBvcnRvSW1wcm9udGFJbmFsYXJlSW5hcmNhcmVJbmF0dGl2b0luY2FudG9JbmNlbmRpb0luY2hpbm9JbmNpc2l2b0luY2x1c29JbmNvbnRyb0luY3JvY2lvSW5jdWJvSW5kYWdpbmVJbmRpYUluZG9sZUluZWRpdG9JbmZhdHRpSW5maWxhcmVJbmZsaXR0b0luZ2FnZ2lvSW5nZWdub0luZ2xlc2VJbmdvcmRvSW5ncm9zc29Jbm5lc2NvSW5vZG9yZUlub2x0cmFyZUlub25kYXRvSW5zYW5vSW5zZXR0b0luc2llbWVJbnNvbm5pYUluc3VsaW5hSW50YXNhdG9JbnRlcm9JbnRvbmFjb0ludHVpdG9JbnVtaWRpcmVJbnZhbGlkb0ludmVjZUludml0b0lwZXJib2xlSXBub3RpY29JcG90ZXNpSXBwaWNhSXJpZGVJcmxhbmRhSXJvbmljb0lycmlnYXRvSXJyb3JhcmVJc29sYXRvSXNvdG9wb0lzdGVyaWNvSXN0aXR1dG9Jc3RyaWNlSXRhbGlhSXRlcmFyZUxhYmJyb0xhYmlyaW50b0xhY2NhTGFjZXJhdG9MYWNyaW1hTGFjdW5hTGFkZG92ZUxhZ29MYW1wb0xhbmNldHRhTGFudGVybmFMYXJkb3NvTGFyZ2FMYXJpbmdlTGFzdHJhTGF0ZW56YUxhdGlub0xhdHR1Z2FMYXZhZ25hTGF2b3JvTGVnYWxlTGVnZ2Vyb0xlbWJvTGVudGV6emFMZW56YUxlb25lTGVwcmVMZXNpdm9MZXNzYXRvTGVzdG9MZXR0ZXJhbGVMZXZhTGV2aWdhdG9MaWJlcm9MaWRvTGlldml0b0xpbGxhTGltYXR1cmFMaW1pdGFyZUxpbXBpZG9MaW5lYXJlTGluZ3VhTGlxdWlkb0xpcmFMaXJpY2FMaXNjYUxpdGVMaXRpZ2lvTGl2cmVhTG9jYW5kYUxvZGVMb2dpY2FMb21iYXJlTG9uZHJhTG9uZ2V2b0xvcXVhY2VMb3JlbnpvTG90b0xvdHRlcmlhTHVjZUx1Y2lkYXRvTHVtYWNhTHVtaW5vc29MdW5nb0x1cG9MdXBwb2xvTHVzaW5nYUx1c3NvTHV0dG9NYWNhYnJvTWFjY2hpbmFNYWNlcm9NYWNpbmF0b01hZGFtYU1hZ2ljb01hZ2xpYU1hZ25ldGVNYWdyb01haW9saWNhTWFsYWZlZGVNYWxncmFkb01hbGludGVzb01hbHNhbm9NYWx0b01hbHVtb3JlTWFuYU1hbmNpYU1hbmRvcmxhTWFuZ2lhcmVNYW5pZmVzdG9NYW5uYXJvTWFub3ZyYU1hbnNhcmRhTWFudGlkZU1hbnVicmlvTWFwcGFNYXJhdG9uYU1hcmNpcmVNYXJldHRhTWFybW9NYXJzdXBpb01hc2NoZXJhTWFzc2FpYU1hc3Rpbm9NYXRlcmFzc29NYXRyaWNvbGFNYXR0b25lTWF0dXJvTWF6dXJjYU1lYW5kcm9NZWNjYW5pY29NZWNlbmF0ZU1lZGVzaW1vTWVkaXRhcmVNZWdhTWVsYXNzYU1lbGlzTWVsb2RpYU1lbmluZ2VNZW5vTWVuc29sYU1lcmN1cmlvTWVyZW5kYU1lcmxvTWVzY2hpbm9NZXNlTWVzc2VyZU1lc3RvbG9NZXRhbGxvTWV0b2RvTWV0dGVyZU1pYWdvbGFyZU1pY2FNaWNlbGlvTWljaGVsZU1pY3JvYm9NaWRvbGxvTWllbGVNaWdsaW9yZU1pbGFub01pbGl0ZU1pbW9zYU1pbmVyYWxlTWluaU1pbm9yZU1pcmlub01pcnRpbGxvTWlzY2VsYU1pc3NpdmFNaXN0b01pc3VyYXJlTWl0ZXp6YU1pdGlnYXJlTWl0cmFNaXR0ZW50ZU1uZW1vbmljb01vZGVsbG9Nb2RpZmljYU1vZHVsb01vZ2Fub01vZ2lvTW9sZU1vbG9zc29Nb25hc3Rlcm9Nb25jb01vbmRpbmFNb25ldGFyaW9Nb25pbGVNb25vdG9ub01vbnNvbmVNb250YXRvTW9udmlzb01vcmFNb3JkZXJlTW9yc2ljYXRvTW9zdHJvTW90aXZhdG9Nb3Rvc2VnYU1vdHRvTW92ZW56YU1vdmltZW50b01venpvTXVjY2FNdWNvc2FNdWZmYU11Z2hldHRvTXVnbmFpb011bGF0dG9NdWxpbmVsbG9NdWx0aXBsb011bW1pYU11bnRvTXVvdmVyZU11cmFsZU11c2FNdXNjb2xvTXVzaWNhTXV0ZXZvbGVNdXRvTmFiYWJib05hZnRhTmFub21ldHJvTmFyY2lzb05hcmljZU5hcnJhdG9OYXNjZXJlTmFzdHJhcmVOYXR1cmFsZU5hdXRpY2FOYXZpZ2xpb05lYnVsb3NhTmVjcm9zaU5lZ2F0aXZvTmVnb3ppb05lbW1lbm9OZW9maXRhTmVyZXR0b05lcnZvTmVzc3Vub05ldHR1bm9OZXV0cmFsZU5ldmVOZXZyb3RpY29OaWNjaGlhTmluZmFOaXRpZG9Ob2JpbGVOb2Npdm9Ob2RvTm9tZU5vbWluYU5vcmRpY29Ob3JtYWxlTm9ydmVnZXNlTm9zdHJhbm9Ob3RhcmVOb3RpemlhTm90dHVybm9Ob3ZlbGxhTnVjbGVvTnVsbGFOdW1lcm9OdW92b051dHJpcmVOdXZvbGFOdXppYWxlT2FzaU9iYmVkaXJlT2JibGlnb09iZWxpc2NvT2JsaW9PYm9sb09ic29sZXRvT2NjYXNpb25lT2NjaGlvT2NjaWRlbnRlT2Njb3JyZXJlT2NjdWx0YXJlT2NyYU9jdWxhdG9PZGllcm5vT2RvcmFyZU9mZmVydGFPZmZyaXJlT2ZmdXNjYXRvT2dnZXR0b09nZ2lPZ251bm9PbGFuZGVzZU9sZmF0dG9PbGlhdG9PbGl2YU9sb2dyYW1tYU9sdHJlT21hZ2dpb09tYmVsaWNvT21icmFPbWVnYU9taXNzaW9uZU9uZG9zb09uZXJlT25pY2VPbm5pdm9yb09ub3Jldm9sZU9udGFPcGVyYXRvT3BpbmlvbmVPcHBvc3RvT3JhY29sb09yYWZvT3JkaW5lT3JlY2NoaW5vT3JlZmljZU9yZmFub09yZ2FuaWNvT3JpZ2luZU9yaXp6b250ZU9ybWFPcm1lZ2dpb09ybmF0aXZvT3JvbG9naW9PcnJlbmRvT3JyaWJpbGVPcnRlbnNpYU9ydGljYU9yemF0YU9yem9Pc2FyZU9zY3VyYXJlT3Ntb3NpT3NwZWRhbGVPc3BpdGVPc3NhT3NzaWRhcmVPc3RhY29sb09zdGVPdGl0ZU90cmVPdHRhZ29ub090dGltb090dG9icmVPdmFsZU92ZXN0T3Zpbm9PdmlwYXJvT3ZvY2l0b092dW5xdWVPdnZpYXJlT3ppb1BhY2NoZXR0b1BhY2VQYWNpZmljb1BhZGVsbGFQYWRyb25lUGFlc2VQYWdhUGFnaW5hUGFsYXp6aW5hUGFsZXNhcmVQYWxsaWRvUGFsb1BhbHVkZVBhbmRvcm9QYW5uZWxsb1Bhb2xvUGFvbmF6em9QYXByaWNhUGFyYWJvbGFQYXJjZWxsYVBhcmVyZVBhcmdvbG9QYXJpUGFybGF0b1Bhcm9sYVBhcnRpcmVQYXJ2ZW56YVBhcnppYWxlUGFzc2l2b1Bhc3RpY2NhUGF0YWNjYVBhdG9sb2dpYVBhdHR1bWVQYXZvbmVQZWNjYXRvUGVkYWxhcmVQZWRvbmFsZVBlZ2dpb1BlbG9zb1BlbmFyZVBlbmRpY2VQZW5pc29sYVBlbm51dG9QZW5vbWJyYVBlbnNhcmVQZW50b2xhUGVwZVBlcGl0YVBlcmJlbmVQZXJjb3Jzb1BlcmRvbmF0b1BlcmZvcmFyZVBlcmdhbWVuYVBlcmlvZG9QZXJtZXNzb1Blcm5vUGVycGxlc3NvUGVyc3Vhc29QZXJ0dWdpb1BlcnZhc29QZXNhdG9yZVBlc2lzdGFQZXNvUGVzdGlmZXJvUGV0YWxvUGV0dGluZVBldHVsYW50ZVBlenpvUGlhY2VyZVBpYW50YVBpYXR0aW5vUGljY2lub1BpY296emFQaWVnYVBpZXRyYVBpZmZlcm9QaWdpYW1hUGlnb2xpb1BpZ3JvUGlsYVBpbGlmZXJvUGlsbG9sYVBpbG90YVBpbXBhbnRlUGluZXRhUGlubmFQaW5vbG9QaW9nZ2lhUGlvbWJvUGlyYW1pZGVQaXJldGljb1Bpcml0ZVBpcm9saXNpUGl0b25lUGl6emljb1BsYWNlYm9QbGFuYXJlUGxhc21hUGxhdGFub1BsZW5hcmlvUG9jaGV6emFQb2Rlcm9zb1BvZGlzbW9Qb2VzaWFQb2dnaWFyZVBvbGVudGFQb2xpZ29ub1BvbGxpY2VQb2xtb25pdGVQb2xwZXR0YVBvbHNvUG9sdHJvbmFQb2x2ZXJlUG9taWNlUG9tb2Rvcm9Qb250ZVBvcG9sb3NvUG9yZmlkb1Bvcm9zb1BvcnBvcmFQb3JyZVBvcnRhdGFQb3NhUG9zaXRpdm9Qb3NzZXNzb1Bvc3R1bGF0b1BvdGFzc2lvUG90ZXJlUHJhbnpvUHJhc3NpUHJhdGljYVByZWNsdXNvUHJlZGljYVByZWZpc3NvUHJlZ2lhdG9QcmVsaWV2b1ByZW1lcmVQcmVub3RhcmVQcmVwYXJhdG9QcmVzZW56YVByZXRlc3RvUHJldmFsc29QcmltYVByaW5jaXBlUHJpdmF0b1Byb2JsZW1hUHJvY3VyYVByb2R1cnJlUHJvZnVtb1Byb2dldHRvUHJvbHVuZ2FQcm9tZXNzYVByb25vbWVQcm9wb3N0YVByb3JvZ2FQcm90ZXNvUHJvdmFQcnVkZW50ZVBydWduYVBydXJpdG9Qc2ljaGVQdWJibGljb1B1ZGljYVB1Z2lsYXRvUHVnbm9QdWxjZVB1bGl0b1B1bHNhbnRlUHVudGFyZVB1cGF6em9QdXBpbGxhUHVyb1F1YWRyb1F1YWxjb3NhUXVhc2lRdWVyZWxhUXVvdGFSYWNjb2x0b1JhZGRvcHBpb1JhZGljYWxlUmFkdW5hdG9SYWZmaWNhUmFnYXp6b1JhZ2lvbmVSYWdub1JhbWFycm9SYW1pbmdvUmFtb1JhbmRhZ2lvUmFudG9sYXJlUmFwYXRvUmFwaW5hUmFwcHJlc29SYXNhdHVyYVJhc2NoaWF0b1Jhc2VudGVSYXNzZWduYVJhc3RyZWxsb1JhdGFSYXZ2ZWR1dG9SZWFsZVJlY2VwaXJlUmVjaW50b1JlY2x1dGFSZWNvbmRpdG9SZWN1cGVyb1JlZGRpdG9SZWRpbWVyZVJlZ2FsYXRvUmVnaXN0cm9SZWdvbGFSZWdyZXNzb1JlbGF6aW9uZVJlbWFyZVJlbW90b1Jlbm5hUmVwbGljYVJlcHJpbWVyZVJlcHV0YXJlUmVzYVJlc2lkZW50ZVJlc3BvbnNvUmVzdGF1cm9SZXRlUmV0aW5hUmV0b3JpY2FSZXR0aWZpY2FSZXZvY2F0b1JpYXNzdW50b1JpYmFkaXJlUmliZWxsZVJpYnJlenpvUmljYXJpY2FSaWNjb1JpY2V2ZXJlUmljaWNsYXRvUmljb3Jkb1JpY3JlZHV0b1JpZGljb2xvUmlkdXJyZVJpZmFzYXJlUmlmbGVzc29SaWZvcm1hUmlmdWdpb1JpZ2FyZVJpZ2V0dGF0b1JpZ2hlbGxvUmlsYXNzYXRvUmlsZXZhdG9SaW1hbmVyZVJpbWJhbHpvUmltZWRpb1JpbW9yY2hpb1JpbmFzY2l0YVJpbmNhcm9SaW5mb3J6b1Jpbm5vdm9SaW5vbWF0b1JpbnNhdml0b1JpbnRvY2NvUmludW5jaWFSaW52ZW5pcmVSaXBhcmF0b1JpcGV0dXRvUmlwaWVub1JpcG9ydGFyZVJpcHJlc2FSaXB1bGlyZVJpc2F0YVJpc2NoaW9SaXNlcnZhUmlzaWJpbGVSaXNvUmlzcGV0dG9SaXN0b3JvUmlzdWx0YXRvUmlzdm9sdG9SaXRhcmRvUml0ZWdub1JpdG1pY29SaXRyb3ZvUml1bmlvbmVSaXZhUml2ZXJzb1JpdmluY2l0YVJpdm9sdG9SaXpvbWFSb2JhUm9ib3RpY29Sb2J1c3RvUm9jY2lhUm9jb1JvZGFnZ2lvUm9kZXJlUm9kaXRvcmVSb2dpdG9Sb2xsaW9Sb21hbnRpY29Sb21wZXJlUm9uemlvUm9zb2xhcmVSb3Nwb1JvdGFudGVSb3RvbmRvUm90dWxhUm92ZXNjaW9SdWJpenpvUnVicmljYVJ1Z2FSdWxsaW5vUnVtaW5lUnVtb3Jvc29SdW9sb1J1cGVSdXNzYXJlUnVzdGljb1NhYmF0b1NhYmJpYXJlU2Fib3RhdG9TYWdvbWFTYWxhc3NvU2FsZGF0dXJhU2FsZ2VtbWFTYWxpdmFyZVNhbG1vbmVTYWxvbmVTYWx0YXJlU2FsdXRvU2Fsdm9TYXBlcmVTYXBpZG9TYXBvcml0b1NhcmFjZW5vU2FyY2FzbW9TYXJ0b1Nhc3Nvc29TYXRlbGxpdGVTYXRpcmFTYXRvbGxvU2F0dXJub1NhdmFuYVNhdmlvU2F6aWF0b1NiYWRpZ2xpb1NiYWx6b1NiYW5jYXRvU2JhcnJhU2JhdHRlcmVTYmF2YXJlU2JlbmRhcmVTYmlyY2lhcmVTYmxvY2NhdG9TYm9jY2lhdG9TYnJpbmFyZVNicnVmZm9uZVNidWZmYXJlU2NhYnJvc29TY2FkZW56YVNjYWxhU2NhbWJpYXJlU2NhbmRhbG9TY2Fwb2xhU2NhcnNvU2NhdGVuYXJlU2NhdmF0b1NjZWx0b1NjZW5pY29TY2V0dHJvU2NoZWRhU2NoaWVuYVNjaWFycGFTY2llbnphU2NpbmRlcmVTY2lwcG9TY2lyb3Bwb1NjaXZvbG9TY2xlcmFyZVNjb2RlbGxhU2NvbHBpdG9TY29tcGFydG9TY29uZm9ydG9TY29wcmlyZVNjb3J0YVNjb3Nzb25lU2Nvenplc2VTY3JpYmFTY3JvbGxhcmVTY3J1dGluaW9TY3VkZXJpYVNjdWx0b3JlU2N1b2xhU2N1cm9TY3VzYXJlU2RlYml0YXJlU2RvZ2FuYXJlU2VjY2F0dXJhU2Vjb25kb1NlZGFub1NlZ2dpb2xhU2VnbmFsYXRvU2VncmVnYXRvU2VndWl0b1NlbGNpYXRvU2VsZXR0aXZvU2VsbGFTZWx2YWdnaW9TZW1hZm9yb1NlbWJyYXJlU2VtZVNlbWluYXRvU2VtcHJlU2Vuc29TZW50aXJlU2Vwb2x0b1NlcXVlbnphU2VyYXRhU2VyYmF0b1NlcmVub1NlcmlvU2VycGVudGVTZXJyYWdsaW9TZXJ2aXJlU2VzdGluYVNldG9sYVNldHRpbWFuYVNmYWNlbG9TZmFsZGFyZVNmYW1hdG9TZmFyem9zb1NmYXRpY2F0b1NmZXJhU2ZpZGFTZmlsYXRvU2ZpbmdlU2ZvY2F0b1Nmb2RlcmFyZVNmb2dvU2ZvbHRpcmVTZm9yemF0b1NmcmF0dG9TZnJ1dHRhdG9TZnVnZ2l0b1NmdW1hcmVTZnVzb1NnYWJlbGxvU2dhcmJhdG9TZ29uZmlhcmVTZ29yYmlvU2dyYXNzYXRvU2d1YXJkb1NpYmlsb1NpY2NvbWVTaWVycmFTaWdsYVNpZ25vcmVTaWxlbnppb1NpbGxhYmFTaW1ib2xvU2ltcGF0aWNvU2ltdWxhdG9TaW5mb25pYVNpbmdvbG9TaW5pc3Ryb1Npbm9TaW50ZXNpU2ludXNvaWRlU2lwYXJpb1Npc21hU2lzdG9sZVNpdHVhdG9TbGl0dGFTbG9nYXR1cmFTbG92ZW5vU21hcnJpdG9TbWVtb3JhdG9TbWVudGl0b1NtZXJhbGRvU21pbHpvU21vbnRhcmVTbW90dGF0b1NtdXNzYXRvU25lbGxpcmVTbmVydmF0b1Nub2RvU29iYmFsem9Tb2JyaW9Tb2Njb3Jzb1NvY2lhbGVTb2RhbGVTb2ZmaXR0b1NvZ25vU29sZGF0b1NvbGVubmVTb2xpZG9Tb2xsYXp6b1NvbG9Tb2x1YmlsZVNvbHZlbnRlU29tYXRpY29Tb21tYVNvbmRhU29uZXR0b1Nvbm5pZmVyb1NvcGlyZVNvcHBlc29Tb3ByYVNvcmdlcmVTb3JwYXNzb1NvcnJpc29Tb3Jzb1NvcnRlZ2dpb1NvcnZvbGF0b1Nvc3Bpcm9Tb3N0YVNvdHRpbGVTcGFkYVNwYWxsYVNwYXJnZXJlU3BhdG9sYVNwYXZlbnRvU3BhenpvbGFTcGVjaWVTcGVkaXJlU3BlZ25lcmVTcGVsYXR1cmFTcGVyYW56YVNwZXNzb3JlU3BldHRyYWxlU3BlenphdG9TcGlhU3BpZ29sb3NvU3BpbGxhdG9TcGlub3NvU3BpcmFsZVNwbGVuZGlkb1Nwb3J0aXZvU3Bvc29TcHJhbmdhU3ByZWNhcmVTcHJvbmF0b1NwcnV6em9TcHVudGlub1NxdWlsbG9TcmFkaWNhcmVTcm90b2xhdG9TdGFiaWxlU3RhY2NvU3RhZmZhU3RhZ25hcmVTdGFtcGF0b1N0YW50aW9TdGFybnV0b1N0YXNlcmFTdGF0dXRvU3RlbG9TdGVwcGFTdGVyem9TdGlsZXR0b1N0aW1hU3RpcnBlU3RpdmFsZVN0aXp6b3NvU3RvbmF0b1N0b3JpY29TdHJhcHBvU3RyZWdhdG9TdHJpZHVsb1N0cm96emFyZVN0cnV0dG9TdHVjY2FyZVN0dWZvU3R1cGVuZG9TdWJlbnRyb1N1Y2Nvc29TdWRvcmVTdWdnZXJpdG9TdWdvU3VsdGFub1N1b25hcmVTdXBlcmJvU3VwcG9ydG9TdXJnZWxhdG9TdXJyb2dhdG9TdXNzdXJyb1N1dHVyYVN2YWdhcmVTdmVkZXNlU3ZlZ2xpb1N2ZWxhcmVTdmVudXRvU3ZlemlhU3ZpbHVwcG9TdmlzdGFTdml6emVyYVN2b2x0YVN2dW90YXJlVGFiYWNjb1RhYnVsYXRvVGFjY2lhcmVUYWNpdHVybm9UYWxlVGFsaXNtYW5vVGFtcG9uZVRhbm5pbm9UYXJhVGFyZGl2b1RhcmdhdG9UYXJpZmZhVGFycGFyZVRhcnRhcnVnYVRhc3RvVGF0dGljb1RhdmVybmFUYXZvbGF0YVRhenphVGVjYVRlY25pY29UZWxlZm9ub1RlbWVyYXJpb1RlbXBvVGVtdXRvVGVuZG9uZVRlbmVyb1RlbnNpb25lVGVudGFjb2xvVGVvcmVtYVRlcm1lVGVycmF6em9UZXJ6ZXR0b1Rlc2lUZXNzZXJhdG9UZXN0YXRvVGV0cm9UZXR0b2lhVGlmYXJlVGlnZWxsYVRpbWJyb1RpbnRvVGlwaWNvVGlwb2dyYWZvVGlyYWdnaW9UaXJvVGl0YW5pb1RpdG9sb1RpdHViYW50ZVRpemlvVGl6em9uZVRvY2NhcmVUb2xsZXJhcmVUb2x0b1RvbWJvbGFUb21vVG9uZm9Ub25zaWxsYVRvcGF6aW9Ub3BvbG9naWFUb3BwYVRvcmJhVG9ybmFyZVRvcnJvbmVUb3J0b3JhVG9zY2Fub1Rvc3NpcmVUb3N0YXR1cmFUb3Rhbm9UcmFib2Njb1RyYWNoZWFUcmFmaWxhVHJhZ2VkaWFUcmFsY2lvVHJhbW9udG9UcmFuc2l0b1RyYXBhbm9UcmFycmVUcmFzbG9jb1RyYXR0YXRvVHJhdmVUcmVjY2lhVHJlbW9saW9UcmVzcG9sb1RyaWJ1dG9UcmljaGVjb1RyaWZvZ2xpb1RyaWxsb1RyaW5jZWFUcmlvVHJpc3RlenphVHJpdHVyYXRvVHJpdmVsbGFUcm9tYmFUcm9ub1Ryb3Bwb1Ryb3R0b2xhVHJvdmFyZVRydWNjYXRvVHViYXR1cmFUdWZmYXRvVHVsaXBhbm9UdW11bHRvVHVuaXNpYVR1cmJhcmVUdXJjaGlub1R1dGFUdXRlbGFVYmljYXRvVWNjZWxsb1VjY2lzb3JlVWRpcmVVZGl0aXZvVWZmYVVmZmljaW9VZ3VhbGVVbGlzc2VVbHRpbWF0b1VtYW5vVW1pbGVVbW9yaXNtb1VuY2luZXR0b1VuZ2VyZVVuZ2hlcmVzZVVuaWNvcm5vVW5pZmljYXRvVW5pc29ub1VuaXRhcmlvVW50ZVVvdm9VcHVwYVVyYWdhbm9VcmdlbnphVXJsb1VzYW56YVVzYXRvVXNjaXRvVXNpZ25vbG9Vc3VyYWlvVXRlbnNpbGVVdGlsaXp6b1V0b3BpYVZhY2FudGVWYWNjaW5hdG9WYWdhYm9uZG9WYWdsaWF0b1ZhbGFuZ2FWYWxnb1ZhbGljb1ZhbGxldHRhVmFsb3Jvc29WYWx1dGFyZVZhbHZvbGFWYW1wYXRhVmFuZ2FyZVZhbml0b3NvVmFub1ZhbnRhZ2dpb1ZhbnZlcmFWYXBvcmVWYXJhbm9WYXJjYXRvVmFyaWFudGVWYXNjYVZlZGV0dGFWZWRvdmFWZWR1dG9WZWdldGFsZVZlaWNvbG9WZWxjcm9WZWxpbmFWZWxsdXRvVmVsb2NlVmVuYXRvVmVuZGVtbWlhVmVudG9WZXJhY2VWZXJiYWxlVmVyZ29nbmFWZXJpZmljYVZlcm9WZXJydWNhVmVydGljYWxlVmVzY2ljYVZlc3NpbGxvVmVzdGFsZVZldGVyYW5vVmV0cmluYVZldHVzdG9WaWFuZGFudGVWaWJyYW50ZVZpY2VuZGFWaWNoaW5nb1ZpY2luYW56YVZpZGltYXJlVmlnaWxpYVZpZ25ldG9WaWdvcmVWaWxlVmlsbGFub1ZpbWluaVZpbmNpdG9yZVZpb2xhVmlwZXJhVmlyZ29sYVZpcm9sb2dvVmlydWxlbnRvVmlzY29zb1Zpc2lvbmVWaXNwb1Zpc3N1dG9WaXN1cmFWaXRhVml0ZWxsb1ZpdHRpbWFWaXZhbmRhVml2aWRvVml6aWFyZVZvY2VWb2dhVm9sYXRpbGVWb2xlcmVWb2xwZVZvcmFnaW5lVnVsY2Fub1phbXBvZ25hWmFubmFaYXBwYXRvWmF0dGVyYVphdm9ycmFaZWZpcm9aZWxhbnRlWmVsb1plbnplcm9aZXJiaW5vWmliZXR0b1ppbmNvWmlyY29uZVppdHRvWm9sbGFab3RpY29adWNjaGVyb1p1Zm9sb1p1bHVadXBwYVwiO2xldCB3b3JkbGlzdCQ2PW51bGw7ZnVuY3Rpb24gbG9hZFdvcmRzJDYobGFuZyl7aWYod29yZGxpc3QkNiE9bnVsbCl7cmV0dXJufXdvcmRsaXN0JDY9d29yZHMkNC5yZXBsYWNlKC8oW0EtWl0pL2csXCIgJDFcIikudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkuc3BsaXQoXCIgXCIpO2lmKFdvcmRsaXN0LmNoZWNrKGxhbmcpIT09XCIweDVjMTM2MmQ4OGZkNGNmNjE0YTk2ZjMyMzQ5NDFkMjlmN2QzN2MwOGM1MjkyZmRlMDNiZjYyYzJkYjZmZjc2MjBcIil7d29yZGxpc3QkNj1udWxsO3Rocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBpdCAoSXRhbGlhbikgRkFJTEVEXCIpfX1jbGFzcyBMYW5nSXQgZXh0ZW5kcyBXb3JkbGlzdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiaXRcIil9Z2V0V29yZChpbmRleCl7bG9hZFdvcmRzJDYodGhpcyk7cmV0dXJuIHdvcmRsaXN0JDZbaW5kZXhdfWdldFdvcmRJbmRleCh3b3JkKXtsb2FkV29yZHMkNih0aGlzKTtyZXR1cm4gd29yZGxpc3QkNi5pbmRleE9mKHdvcmQpfX1jb25zdCBsYW5nSXQ9bmV3IExhbmdJdDtXb3JkbGlzdC5yZWdpc3RlcihsYW5nSXQpO1widXNlIHN0cmljdFwiO2NvbnN0IGRhdGEkMj1cIn1hRSM0QT1ZdiZjbyM0TiM2Rz1jSiZTTSM2NnwvWiM0dCZrbn40NiM0S340cSViOT1JUiM3bCxtQiM3V19YMipkbH1Vb343c31VZiZJdyM5YyZjd342TyZINiZ3eCZJRyV2NT1JUX44YSZQdiM0NyRQUiY1MCVLbyZRTSYzbCM1ZixEOSM0THwvSCZ0UTt2MH42bl1uTjxkaSxBTT1XNSVRTyZrYSZ1YSxoTV50bT16Vj1KQT13UiYrWF03UCZOQiM0SiM1THwvYltkQX10SjxEbyY2bSZ1MltVMSZLYi5ITSZtQz13MCZNVzxyWSxIcSM2TX1RRywxMyZ3UH1KcF1PdyV1ZSZLZzxIUDxEOX40a345VCZJMl9jNiQ5VCM5L1tDNX43T340YT1jcyZPNz1LSz1BbiZsOSQ2VSQ4QSZ1RCZRSXwvWSZiZ31VeCZGMiM2Yn1FMiZKTiZrVyZrcD1VLyZiYj1YbDxDan1rK341SiM2TCY1eiY5aX1iNCZGbyxobyhYMF9nM340TyRGeiZRRTxITj1Xd102LyVHRi1Wdz10aiYvRCZQTiM5Zz1ZT31jTCZPZiZQSX41SSZJcD12VT1JVyM5Rzswby13VX1zcyZRUjxCVCZSOT10ayRQWV9kaCZQcS15aF03VCxuai5YdT1FUCY3Nj1jSSZGcypYZ316NyRHYiYrST1ERixBRj1jQX1yTCM3aj1EeiYzeTxBYSQ1Mj1QUX1iMChpWSRGYX1vTCZ4ViM2VT1lYz1XWix4aCVSWTxkcCM5TiZGbCY0ND1XSCpBNz1zaCZUQiY4UD0wNzt1KyZQS311aH1KNSM3MilWLz14QyxBQiRrMCZmNjsxRXwrNT0xQiwzdl02biZ3UiViKyZ4eF03Zj1PbH1mbDsrRF53R103RTtuQjt1aF5JciZsNT1KTCxuUz1jZj1nNTt1NnwvUSRHYz1NSCVIZyM1ZCVNNl44Nj1VKyRHeixsLyxpcl41eSZCYSYvRi1JWSZGSSZiZSVJWiM3NyZQV19OdSRrRShZZiZOWF03WixKeSZGSihYbyZOeiMvZD15NyZNWDxBZ31aKztuRV1EdChpRyM0RD0xMyZQan40YyV2OCZabyVPTCYvWCM0VzxIUiZpZX42Sl8xTyhZMj15NT1BZCpjdl9lQiM2ayZQWDpCVSM3QTt1ayZGdCZGeF9kRD1VMjt2Qj1VNT00Rn0rTyZHTi5ISDo5cz1iMCVOVihqTyZJSD1KVH1aOT1WWjxBZixLeF40bSZ1SiVjNiw2cjs5bSMrTH1jZiVLaCZGM340SD12UH1idSxIenwrKywxd11udn1rNjt1dSRqdypLbCpXWCZ1TVt4NyZGclttNyROTyZRTl1odT1KTn1uUl44ZyMvaChwc3xLQzt2ZH14ej1WMH1wNiZGRCRHMSM3SzxiR180cH44ZyZjZjt1ND10bH0rayU1L31mejt1dzxjQT11MX1nVX1WTT1MSj1lWCYrTCZQciM0VX1wMjpuQywyS103SDpqRiY5eH11WCM5Tz1NQjxmen44WH41bSY0RCZrTiZ1NSVFLyhoNyhaRiZWRzxkZShxTXwvZS1XdD0zeChhKywvUl1mLyZORCRSbyZuVX0wZz1LQSVrSCZOSyRLZTxkU31jQiZJWH41ZyRUTl02bT1VdixJcyZQeT1FZiVLeiMrLyViaSYrQTxGNCRPRyY0QyZGTCM5Vjxaaz0ySV9lRSY2Y11udyZrcSRIR315KyZBOCRQM31PSD1YUF03MCVJUyhBSl9nSCVHWiZ0WSZBWj12Yn42eSYvcj1WST1XdjxaaT1mbD14ZiZlTH1jOH1PTD1NSj1nOCRGNz1ZVH05dT0wK154Q31KSCZuTF5OMH40VF1LMixDeSVPQyM2czt2RyhBQ154ZV5jRyZNRn1CciM5UDt3RC03aCRPLyZ4QX1Gbl5QQ102aV03RyY4ViRRczt2bChUQn43M340bDxtVyY2Vj0yeSZ1WSYrMylhUH1YRjtMUCZreCR3VT10Nzt1eTxGTiZseik3RT1PbypZKzt3SX05cX1sZTtKNiZSaSY0dCZRciM4Qj1jYiZ2Rz1KNXxRbChoNTxZeX40K31RRCxMeD13biVLLyZSSz1kTyZQdyxROT1jbyU0dTs5dX1nMEA2YV40SSViMD16b3wvYyZ0WD1kUT1PUyMrYj15el9BQiZ3QiZQbT1XOSRIUF9nUj02Mj1BTz10aT1oSSxvQSZqciZkSD10bSZiNiRQMih4OD16aTtuR343RjswNV0wbltJeCYzbX1yZz1YcD1jZCZ1el03dDs5Nz1jTjt2VjxqZiZGRiZGMT02USZJaypLayZQNCwyej1mUV03RCYzdSxIMD1kL31VdzxaTjw3Un1LdjswZiRINyxNRF03biRGMCM4OH45WiVkYT1ieTsrVCMvdT1WRiZmTyZrcl5rZjxBQl1zVSxJNSROZyZQejswaSZRRCZ2TT1ZbDpCTTtuSl94Sl1VNyZLZiYzMCwzZnxaOSpkQylqZV9qQSZRNCZLcCROSChZeiM2UyZJZCVJYj1LWCxBRD1LViVkUH10VyZQa14rRV9OaT1jcSwzUn1WWihTaT1iK31ydjswan1yWl11QSwvdyhTeCZKdiR3OSY0ZCZ3RSxOSiRHeT1KL11McyM3azxaUTxZLyZ1al1PdiRQTTt2MywyRiYrdTp1cD1PbiYzZSxKdjs5MD1KKyZRbV02cX1iSyMrZH44WShoMl1oQTs5OSZBUz1JL31xQiZkUX15Si1WTX1WbCZ1aSxpQiZHM3xEY103ZD1lUSVkWCVKQ18xTH40ZF5OUDt2SiYvMSlaSSM3Tl05WFtiUSZQTD0wTChVWixMbSZrYyZJUn1uNyhpUjxBUTxkZz0zMz12Tn1mdH1hdV03SSxCYT14OT1kUn42UiZUcT1YaSwzZCROciZCY31ESSZrdSZ2Zl1EbiwvRiZpRCxMbCZOdz0weSZJNz1Mcz0vQSZ0VT1RZX1VYSZ1ayYrRj1nND1naD1WaiMrMSZRbn1VeSo0NCM1RixQYyZSeipYbj1vaD01Vzswbl9OZihpRTxZNz12cj1adV1veiM1WiVtST1rTj1Cdl9KcChUMjt2dF9NbDxGUyZ1ST1MLyY2UF02NCRNN304NjxibyVRWChTSSVJWSZWSz1BbCZVeDt2djt1dCpFLyV1aDxaRXxPMyxNMih5Y115dT1XayZ0cDpFeH1ocixDbCZXRSkrWj04VX1JMl80USxoQV9zaT1pdz1PTT10TT15WiVJYT1VNzt3VH1iKzt1bz1aYX15UyE1eH1IRH1mYiM1T19kQTtOdiV1Qih5QjswMShTZn1Gazt2N31QdCM4djxtWiM3TCwvciZQbH40dyZmNT1QaCRGd19MRiY4bSxiTD15SiZCSH1wLypKbn10VX41UTt3QihoNl1EZl04cF4rQjtFNCZXYz1kKztFYSZidyQ4QyZGTixETT1ZZn1tUH41dz1mVCM2Vj1tQz1GaT1BVn1qQiZBTn1sV31hSCMvRClkWjtobDt2RX0vNyxDSjszMSZ3OCxoaiV1OV9Kcz1qSiY0TX44az1UTiZlQ31uTCZ1Yy13aSZsWH1kaj1Ndj1lMiM2dT1jciR1cSQ2R104V31KYjpubT1ZZzxiMyhVQTt2WCY2biZ4Rj1LVCxqQyxEZSZSOCZvWT1adiZvQl03Lz1aMiZPYX1iZixoaCg0aF50WiY3MiZOeDtEMiZ4TH41aH40MClaRyloKz1PSiZSQV1CdiR5Qj1PcT1kZixBUSVKbn1PSjsxMSwzeiZUbCZ0ajt2K15IdixEaChpZD1zK103TiZOMyk5UX44ZixTND11Vz13NCZ1WCxMWCYzZF1DSiZ5cCY4eDxiMl9kbyZsUD15LzxjeV9kRz1PaT03UihWSChsdF8xVCxJcV9BQTsxMl42VCVrNiM4S1tCMXtvTzxBVVtCdDsxYiQ5UyZQczw4VD1TdHtiWSxqQihacCY2MyZVdiQ5VixQTV02diZBZn16V1tiV19vcX1zbX1uQiZLcSZnQyZmZl9lcV8ybSY1RiZUSX1yZn1HZjtacl96OTtFUiZqa31pel9zbjxCTn4rbiZ2bz1WaSU5N3xaUj1XYyxXRSY2dF02eiU4NShseSM4ND1LWSk2bV81Lz1hWCxOM31UbSZoZSY2S110Ul9CMi1JMzt1LyZoVSZsSDxBUD1pQiZJQT1YTDsvNSZOaD13djxCSCM3OT12Uz16bDxBQT0wWF9SR31CdyY5cCROVyxBWCZrUF9McCYvWihUY11NdX1ocyM2SX01QiZjSTxicSZIOSM2bT1LOX12SChZMShZMCM0QiZ3NiwvOSZnRzxiRSwvTz16Yn1JNF9sODxCLzt3TCVRbzxIT1tNcT1YWH0wdiZCUCZGNChtR30waX1ubSxFQz05dXtJMyx4RyYvOT1KWSpESyZoUilCWD1FST1jeD1iL3s2a315WCVBKyZ3YX1YYj1sYTt3aV5sTDswdH1qbyZRYj14Zz1YQn1pTzxxb3tiUj1OViY4Zj1hMCZKeTswdj11SylISzt2TiM2aCZqQihoLyV1ZCZOSSV3WS5YNz1QdH1DdS11TCZHc19obCVtSCx0bV03OD1MYl5RMCM3WT0xdTxCdCYrUT1Db19SSCx3MzsxZX11eDxhVTt1aX1VMyZRNSVidF02MyZVUXwwbCZ1TH1PNyYzbyxBViZkbXxOaihYdCo1KyhVdSZIaChwNyhVRj1WUj1CcF5KbCZIZFtpeCk5Lz1JcV1DODw2N102Nn1tQiU2Zn1iYn1KSV04VCRIQX1kYj1ZTSZwYT0ySn10UyZZMD1QUyZ5ND1jWCQ2RSxoWCxYUCZuUjswNCxGUSZsMCZWbV9EdiM1WX44Wj1CaSVNQV02eD1KTzorcCxBeiY5cSxIan42L31TRD1LMTpFSn1uQTtRbyMvRV05UixJZSY2WCVXM102MSZ2ND14WF9NQz0wcTswNihYcT1mc31JR31Edj0wbH1vNyRpWjs5diZMSCZEUC03YSZPWSxTWixLeixDdiZkaD1meHxOaCxGL343cT1YRiZ3Kzs5biZHdzswaH1aNzw3TyZKSyhTNyZMUzxBRDxhYz13bzxEdCZ6dyU0Qj00diM4UDs5b342cCp2Vj1UbSxPciZJNj0xcX1uWT1QMD1ncSZCbCZVdSxDaCV5Yn1VWT16aH1kaH1ybChUNF94ayhZQSM4Uip4SCxJTn1Kbl03Vn1DNCZUeX1qM103cD1jTD0zaCZ3VyVRdjxaMz1mMCZSSSYrUyhpY196cX1vTiYvWT16MTtUZD1MVz0wZT1PSShWYywrYl5qdShVTDswcjpaYSU4dj1ScD16dyY1OCY3MyZ3S31xWF02eSY4RSlhMn1XUj13UF51ciZuUTxjSH1SZT1BcSZ3a31RMCYrcT1QUCxHY3wvZF5rNSxGd104WX1QZ11wMz1qdT1lZH1yNV95ZiZDc103eiQvRzxDbSZKcCY1NF8xR19nUF9MbH1KWjswdV1rOF83ayhTZ102NXs5aT1MTiZTeCZXSyxpVyZmRCZMa3s5YX1FbS05YyM4TiZpbz1zeV04ZCZuVCZJSyhseCM3LyRsVyhUZDxzOH40OSwzbzw3WT1NVyhUK19KciZXZCxpTH1DdD14aCY1Vjt2NCY4biVLeD1pRiZsMl8wQntCKyxJZihKMCxMdjt1OD1LeC12Qj1IQyZ2Uz1aNiZmVSZ2RV54SzszRD00aD1NUiM0NTpKdzswZH1pdz1MVX1JNT1JMF1nQippbSxLOX1HVSwxa180VSZUdD1WcyhpWCZsVShURiM3eSxaT31vQSZtNSM1UH1QTn1Vej1oTTxCMSZGQjxhRyxlNn43VDx0UChVUV9aVD13dSZGOClhUV1pTiwxcl9MbyYvZzpDRH04NHtKMV9LaSZOYSYzbiRqeiZGRT1kYzt1djt2YX1pbn1sbD1mdihoMSYzaH1mcD1DeX1CTSgrRX44bX1sbyV2Nz1oQyhUNiRjaj1CUT1CdyhEUiwyaj1LcyxOU3xGKzswMD1mVT03MH1NYihZVTsrRyZtNyZocj1TayVDb110KyhYNV9Kd30wcn1nQyhBUy1JUCZRSzxaMiM4USRXQ11XWH1UMiZwR19LYSxIQz1SNCYvTjtaKztjaChDNyxENCQzcF9NayZCMiQ4RD1uOSVLeSM1eihDVCZRSiM3Ql1EQ11nV31uZn41TTtJdyM4MH1UY18xRiM0Wi1hQ31IbD1waD1meiwvMz1hV31KTX1ubjtERzt2bX13biw0UH1UMzt3eCZSRyR1K316Sz0wYjsrSl9Fa3tyZTxhWj1BU315WSM1RF03cSxDcH14Tj1WUCoyQ31HWn1hR34rbV9Dcz1PWSM2cl02ZzxHU31MQyhVQj0zQT1Cb31KeTxjNH1JczsxUDxBR31PcDxaMX1sZH1uUz0xWix5TSY5NSY5OD1DSig0dDoyTCRIaz1ab31WYzsrSX1ucCZOMX05eT1pdn1DTyo3cD1qTClweF10Yl56aCZHUyZWbCV2Lzt2Uj0xND16SiY0OXwvZl1oRn1XRzswMz04UH1vLyZHZyZycDtEQixLdn1KaSZQYjthQV5sbCg0aiV5dH0rSyRIdCM0eSZoWV03WTxGMSxlTn1iRyhVaCU2Wl10NSVHNzsrRl9SRTtpdH10TD1MUyZEYT1YeChTKyg0Zj04Rz15SX1jSn1XUD0zNz1qU31wWH1oZClmcDxBOD1KdH4rbyRISj1NNn1pWD1nOX1DUz1kdj1DaihtUCVLZCx4cXwrOSZMRCg0Lz1YbSZRUD1MY31MWCZmTDsrSz1PcChsdT1Rcy5xQzorZSZMKz1KaiM4dztTTF03UyhiKyM0ST1jMSZuR19MZiZ1SDsrUilaVjxiViVCLyxURSYwSCZKcSZBaCVPRiZTcyhwMixXdiZJMz1XbH1WcTsxTCZsSiM5Yl8xSD04cj1iOD1KSChTWj1oRD1KMiM3VSwvVSMvWH42UCxGVTxlTD1qeCxtRz1oRz1DRSZQVT1TZShxWCZMWT1YNj15NCZ0ayZRUSZ0Zj00ZyZ4SX1XKyZtWj1EYyM3d31MZztEQTt3UV9LYihjSj1oUiV5WCZZYixod3tiWF80WDtFUDsxV18yTX1VYz1iNShZRixDTSZUcF5PSntERF02cz12Rj1Zb344cX1YSH1GdSVQNShTSj1RdDtNT11zODxGMyZCMyY4VChVbC1CUypkdyZkUjw4N30vOF02MiRQWl1MeDxBdX05UV03Yz1qYT1LUixHbyxVcyZ2Nihxa31wRyZHMj1ldl5HTSV3NCZINF03RiZkdl1KNn1Fdzo5dz1zai1aTH1ZbSQraChVdChVbX40bj1YcyhVNyVlRT1RY19KUjxDQSM2dDxGdnwvSSxJUyxFRzxGMihYeSQvbjxGYShoOX0rOV8ybyZONCM3WDxacXwrZl9EcD1kdCZuYSxDYT1OSilqWT04Qz1ZRz1zNiZRKzxET31EMz14QiZSMShsdztRbjxiRihDdXwvQn1IVj1TUyZuNywxMCZ1MF1EbSVBNl40UT1XUihURD1YbzxHSCxSaihsOCliUCZuLz1MTSZDRixGNSZtbD1QSjswaz1MRz10cSxSaCxENkA0aT0xcCYrOT1ZQyVlcl9NaDtuSTswcT1Gd104MD14cT1GTSRHdjt2NiZuYzt3SyVIMiZLajt2cyxBQT1ZUCw2Nn1iSShxUn41VT02cX40YiROaT1LNS5YMyRTbyZJdShwK104Rz1DZj1SWShUU19PMyhpSCY1Nz1mRT1EZ19EbyM5eiM3SDtGS3txZF8yayVKUn1lbiZnaF96ODtSeH05cDxjTl9OZSxETztMTl83b34vcD1ORj01WX1nTjxjZTxDMSxRRV1Xdj0zdTxCQ31HS115cX1EWSZ1L19oaj1JSShweiZyQyxqViYrWn11dD1OUTtDZy1TUl9aUywrbz11LztPeV9SS19RRihGeCZ4UH1XciZUQSxVaCZnMT15cntheFtWRiRQZyhZQjtPeD1WeTsrVyhTcH1YViVkZCYzMyhsL11sNCM0WX1PRT02Yz1idyhBNyY5dCV3ZCZOLyZtbyxKSCZRZSlmbT1Bb31mdT10SFwiO2NvbnN0IGRlbHRhRGF0YT1cIkZBWkRDNkJBTGNMWkNBK0dCQVJDVzh3TkNjRERaOExWRkJPcXFEVWlvdStNNDJURkF5RVJYRmI3RWpoUCt2bUJGcEZyVXBmRFYyRjdlQitlQ2x0Q0hKRldMRkNFRCtwV1RvakVJSEZYYzNhRm40RjY4enFqRXVLaWRTMVFCVlBERWhFN05BNG1oTUY3b1RoRDQ5b3QzRmd0ekhGQ0swYWNXMXg4REgxRW1Mb0lscldGQkxFK3k1K05BM0N4NjV3SkhUYUVaVmFLMW1XQW1QR3hnWUNkeHdPalRESXQvZmFPRWhUbDF2cU5zS3RKQ09oSld1aW8yZzA3S0xaRVFzRkJVcE50d0VCeUJneEZzbEZoZUZiaUVQdmk2MW1zRHZBcHhDekI2ckJDem94N2pvWUE1VWREYytDYjRGU2dJYWJwWEZBajNiamttRkF4Q1pFK21EL1NGZi8wRUxlY1lDdDNuTG94QzZXRVpmMnRLREI0b1p2ckVtcUZrS2s3QndJTEE3Z3RZQnBzVHEvL0Q0akQwRjB3RUI5cHlRMUJENUJhMG9ZSERJK3NiREZodnJIWGRESGZnRkVJSkxpNXI4cWVyY05GQmdGTEM0Ym81RVJKdGFtV0JERnk3M0tDRWI2TThWcG1FdDMzMHlnQ1RLNThFSUlGa1lnRjg0Z3RHQTlVeWgzbTY4aVZyRmJXRmJjYnFpQ1lIWjlKMWplUlBiTDh5c3doTWlEYmhFaGROb1N3RmJackxUNzQwQUJFcWdDa084SjFCTGQxVmhLS1I0c0QxeVVvMHorRkY1OU12ZzcxQ0ZieUVoYkhTRkJLRUlLeW9RTmdRcHBxOVQwS0FxZVB1MFpGR3JYT0hkS0pxa29URmhZdnBETnl1dXpuck44NHRoSmJzQ29PNkN1Nlhsdm50dnkwUVl1QUV4UUVZdFRVQmYzQ29DcXdnR0ZaNHUxSEpGekRWd0V5M2NqY3BWNFF2c1BhQkMzckNHeUNGMjNvNEszcHAyZ2JlckdnRkVKRUhvNG5ISUN0eUtIMlpxeXhoTjA1S0JCSklRbEtoL091anYvREgzMlZybHFGZElGQzdGejlDdDRrYXFGTUUwVUVUTHBybk45a2Z5K2tGbXRRQkIwKzVDRnUwTjlJajhsL1Z2SkRoMm9xM2hUNkV6alRIS0ZON1pqWndvVHNBWjRFeHNrbzZGcGE2V0Mrc2R1ejhqeXJMcGVnVHYyaDFFQmVZcExwbTJjelFXMEtvQ2NTMGJDVlhDbXVXSkRCak4xblFOTGRGNThTRkowaDdpM3BDM29FT0t5L0ZqQmtsTDcwWHZCRUVJV3AyeVowNHhPYnpBV0RESkc3ZitEYnFCRUE3THlpUjk1ajdNRFZkRFZpejJSRTV2V2xCTXY1ZTQrVmZoUDNhWE5QaHZMU3luYjlPMng0dUZCViszanF1NmQ1cENHMjgvc0VUQnl2bXUvK0lKMEwzd2I0cmo5RE5PTEJGNlhQSU9EcjRMMTlVOVJSb2ZBRzZOeHlkaThCa2k4QmhHSmJCQUpLemJKeGtaU2xGOVEyQ3U4b0txZ2dCOWhCQXJ3TExxRUJXRXRGb3d5OFhLOGJFeXc5c25UK0JleUZrMVpDU3JkbWdmRXdGZVBUZ0NqRUxCRW5JYmphRERQSm0zNnJHOXB6dGNFelQ4ZEdrMjNTQmhYQkIxSDR6K09XemUwb29Geno4cERCWUZ2cDlqOXR2RkJ5Zjl5NEVGZFZuejAyNkNHUjVxTXI3ZnhNSE44VVVkbHlKQXpsVEJEUkMyOGsrTDRGQjgwNzhsanlEOTF0VWoxb2NuVHM4dmRFZjd6bmJ6bStHSWpFWm5vWkU1cm5MTDcwMFhjN3lIZnowNW5XeHkwM3ZCQjlZR0hZT1d4Z01RR0JDUjI0Q1ZZTkUxaHBmS3hOMHpLbmZKRG1tTWdNbUJXcU5iamZTeUZDQldTQ0dDZ1I4eUZYaUh5RWorVnREMUZCM0ZwQzF6STBrRmJ6aWZpS1RMbTl5cTV6Rm11citxOEZIcWpvT0JXc0JQaURibkNDMkVydW5WNmNKNlR5Z1hGWUhZcDdNS045UlVsU0lTOC94QkFHWUx6ZXFVbkJGNFFic1R1VWtVcUdzNkNhaURXS1dqUUs5RUpranBrVG1OQ1BZWExcIjtjb25zdCB3b3JkbGlzdCQ3PXt6aF9jbjpudWxsLHpoX3R3Om51bGx9O2NvbnN0IENoZWNrcz17emhfY246XCIweDE3YmNjNGQ4NTQ3ZTVhNzEzNWUzNjVkMWFiNDQzYWFhZTk1ZTc2ZDgyMzBjMjc4MmM2NzMwNWQ0ZjIxNDk3YTFcIix6aF90dzpcIjB4NTFlNzIwZTkwYzdiODdiZWMxZDcwZWI2ZTc0YTIxYTQ0OWJkM2VjOWMwMjBiMDFkM2E0MGVkOTkxYjYwY2U1ZFwifTtjb25zdCBjb2RlcyQxPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2NvbnN0IHN0eWxlPVwifiFAIyQlXiYqXy09W117fXw7OiwuKCk8Pj9cIjtmdW5jdGlvbiBsb2FkV29yZHMkNyhsYW5nKXtpZih3b3JkbGlzdCQ3W2xhbmcubG9jYWxlXSE9PW51bGwpe3JldHVybn13b3JkbGlzdCQ3W2xhbmcubG9jYWxlXT1bXTtsZXQgZGVsdGFPZmZzZXQ9MDtmb3IobGV0IGk9MDtpPDIwNDg7aSsrKXtjb25zdCBzPXN0eWxlLmluZGV4T2YoZGF0YSQyW2kqM10pO2NvbnN0IGJ5dGVzPVsyMjgrKHM+PjIpLDEyOCtjb2RlcyQxLmluZGV4T2YoZGF0YSQyW2kqMysxXSksMTI4K2NvZGVzJDEuaW5kZXhPZihkYXRhJDJbaSozKzJdKV07aWYobGFuZy5sb2NhbGU9PT1cInpoX3R3XCIpe2NvbnN0IGNvbW1vbj1zJTQ7Zm9yKGxldCBpPWNvbW1vbjtpPDM7aSsrKXtieXRlc1tpXT1jb2RlcyQxLmluZGV4T2YoZGVsdGFEYXRhW2RlbHRhT2Zmc2V0KytdKSsoaT09MD8yMjg6MTI4KX19d29yZGxpc3QkN1tsYW5nLmxvY2FsZV0ucHVzaCh0b1V0ZjhTdHJpbmcoYnl0ZXMpKX1pZihXb3JkbGlzdC5jaGVjayhsYW5nKSE9PUNoZWNrc1tsYW5nLmxvY2FsZV0pe3dvcmRsaXN0JDdbbGFuZy5sb2NhbGVdPW51bGw7dGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIFwiK2xhbmcubG9jYWxlK1wiIChDaGluZXNlKSBGQUlMRURcIil9fWNsYXNzIExhbmdaaCBleHRlbmRzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKGNvdW50cnkpe3N1cGVyKFwiemhfXCIrY291bnRyeSl9Z2V0V29yZChpbmRleCl7bG9hZFdvcmRzJDcodGhpcyk7cmV0dXJuIHdvcmRsaXN0JDdbdGhpcy5sb2NhbGVdW2luZGV4XX1nZXRXb3JkSW5kZXgod29yZCl7bG9hZFdvcmRzJDcodGhpcyk7cmV0dXJuIHdvcmRsaXN0JDdbdGhpcy5sb2NhbGVdLmluZGV4T2Yod29yZCl9c3BsaXQobW5lbW9uaWMpe21uZW1vbmljPW1uZW1vbmljLnJlcGxhY2UoLyg/OlxcdTMwMDB8ICkrL2csXCJcIik7cmV0dXJuIG1uZW1vbmljLnNwbGl0KFwiXCIpfX1jb25zdCBsYW5nWmhDbj1uZXcgTGFuZ1poKFwiY25cIik7V29yZGxpc3QucmVnaXN0ZXIobGFuZ1poQ24pO1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdaaENuLFwiemhcIik7Y29uc3QgbGFuZ1poVHc9bmV3IExhbmdaaChcInR3XCIpO1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdaaFR3KTtjb25zdCB3b3JkbGlzdHM9e2N6OmxhbmdDeixlbjpsYW5nRW4sZXM6bGFuZ0VzLGZyOmxhbmdGcixpdDpsYW5nSXQsamE6bGFuZ0phLGtvOmxhbmdLbyx6aDpsYW5nWmhDbix6aF9jbjpsYW5nWmhDbix6aF90dzpsYW5nWmhUd307XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgdmVyc2lvbiRnPVwiaGRub2RlLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJGw9bmV3IExvZ2dlcih2ZXJzaW9uJGcpO2NvbnN0IE49QmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7Y29uc3QgTWFzdGVyU2VjcmV0PXRvVXRmOEJ5dGVzKFwiQml0Y29pbiBzZWVkXCIpO2NvbnN0IEhhcmRlbmVkQml0PTIxNDc0ODM2NDg7ZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpe3JldHVybigxPDxiaXRzKS0xPDw4LWJpdHN9ZnVuY3Rpb24gZ2V0TG93ZXJNYXNrKGJpdHMpe3JldHVybigxPDxiaXRzKS0xfWZ1bmN0aW9uIGJ5dGVzMzIodmFsdWUpe3JldHVybiBoZXhaZXJvUGFkKGhleGxpZnkodmFsdWUpLDMyKX1mdW5jdGlvbiBiYXNlNThjaGVjayhkYXRhKXtyZXR1cm4gQmFzZTU4LmVuY29kZShjb25jYXQoW2RhdGEsaGV4RGF0YVNsaWNlKHNoYTI1NiQxKHNoYTI1NiQxKGRhdGEpKSwwLDQpXSkpfWZ1bmN0aW9uIGdldFdvcmRsaXN0KHdvcmRsaXN0KXtpZih3b3JkbGlzdD09bnVsbCl7cmV0dXJuIHdvcmRsaXN0c1tcImVuXCJdfWlmKHR5cGVvZiB3b3JkbGlzdD09PVwic3RyaW5nXCIpe2NvbnN0IHdvcmRzPXdvcmRsaXN0c1t3b3JkbGlzdF07aWYod29yZHM9PW51bGwpe2xvZ2dlciRsLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gbG9jYWxlXCIsXCJ3b3JkbGlzdFwiLHdvcmRsaXN0KX1yZXR1cm4gd29yZHN9cmV0dXJuIHdvcmRsaXN0fWNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkJDM9e307Y29uc3QgZGVmYXVsdFBhdGg9XCJtLzQ0Jy82MCcvMCcvMC8wXCI7Y2xhc3MgSEROb2Rle2NvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQscHJpdmF0ZUtleSxwdWJsaWNLZXkscGFyZW50RmluZ2VycHJpbnQsY2hhaW5Db2RlLGluZGV4LGRlcHRoLG1uZW1vbmljT3JQYXRoKXtsb2dnZXIkbC5jaGVja05ldyhuZXcudGFyZ2V0LEhETm9kZSk7aWYoY29uc3RydWN0b3JHdWFyZCE9PV9jb25zdHJ1Y3Rvckd1YXJkJDMpe3Rocm93IG5ldyBFcnJvcihcIkhETm9kZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5XCIpfWlmKHByaXZhdGVLZXkpe2NvbnN0IHNpZ25pbmdLZXk9bmV3IFNpZ25pbmdLZXkocHJpdmF0ZUtleSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByaXZhdGVLZXlcIixzaWduaW5nS2V5LnByaXZhdGVLZXkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIixzaWduaW5nS2V5LmNvbXByZXNzZWRQdWJsaWNLZXkpfWVsc2V7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByaXZhdGVLZXlcIixudWxsKTtkZWZpbmVSZWFkT25seSh0aGlzLFwicHVibGljS2V5XCIsaGV4bGlmeShwdWJsaWNLZXkpKX1kZWZpbmVSZWFkT25seSh0aGlzLFwicGFyZW50RmluZ2VycHJpbnRcIixwYXJlbnRGaW5nZXJwcmludCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImZpbmdlcnByaW50XCIsaGV4RGF0YVNsaWNlKHJpcGVtZDE2MCQxKHNoYTI1NiQxKHRoaXMucHVibGljS2V5KSksMCw0KSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIixjb21wdXRlQWRkcmVzcyh0aGlzLnB1YmxpY0tleSkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJjaGFpbkNvZGVcIixjaGFpbkNvZGUpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJpbmRleFwiLGluZGV4KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiZGVwdGhcIixkZXB0aCk7aWYobW5lbW9uaWNPclBhdGg9PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJtbmVtb25pY1wiLG51bGwpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwYXRoXCIsbnVsbCl9ZWxzZSBpZih0eXBlb2YgbW5lbW9uaWNPclBhdGg9PT1cInN0cmluZ1wiKXtkZWZpbmVSZWFkT25seSh0aGlzLFwibW5lbW9uaWNcIixudWxsKTtkZWZpbmVSZWFkT25seSh0aGlzLFwicGF0aFwiLG1uZW1vbmljT3JQYXRoKX1lbHNle2RlZmluZVJlYWRPbmx5KHRoaXMsXCJtbmVtb25pY1wiLG1uZW1vbmljT3JQYXRoKTtkZWZpbmVSZWFkT25seSh0aGlzLFwicGF0aFwiLG1uZW1vbmljT3JQYXRoLnBhdGgpfX1nZXQgZXh0ZW5kZWRLZXkoKXtpZih0aGlzLmRlcHRoPj0yNTYpe3Rocm93IG5ldyBFcnJvcihcIkRlcHRoIHRvbyBsYXJnZSFcIil9cmV0dXJuIGJhc2U1OGNoZWNrKGNvbmNhdChbdGhpcy5wcml2YXRlS2V5IT1udWxsP1wiMHgwNDg4QURFNFwiOlwiMHgwNDg4QjIxRVwiLGhleGxpZnkodGhpcy5kZXB0aCksdGhpcy5wYXJlbnRGaW5nZXJwcmludCxoZXhaZXJvUGFkKGhleGxpZnkodGhpcy5pbmRleCksNCksdGhpcy5jaGFpbkNvZGUsdGhpcy5wcml2YXRlS2V5IT1udWxsP2NvbmNhdChbXCIweDAwXCIsdGhpcy5wcml2YXRlS2V5XSk6dGhpcy5wdWJsaWNLZXldKSl9bmV1dGVyKCl7cmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQkMyxudWxsLHRoaXMucHVibGljS2V5LHRoaXMucGFyZW50RmluZ2VycHJpbnQsdGhpcy5jaGFpbkNvZGUsdGhpcy5pbmRleCx0aGlzLmRlcHRoLHRoaXMucGF0aCl9X2Rlcml2ZShpbmRleCl7aWYoaW5kZXg+NDI5NDk2NzI5NSl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbmRleCAtIFwiK1N0cmluZyhpbmRleCkpfWxldCBwYXRoPXRoaXMucGF0aDtpZihwYXRoKXtwYXRoKz1cIi9cIisoaW5kZXgmfkhhcmRlbmVkQml0KX1jb25zdCBkYXRhPW5ldyBVaW50OEFycmF5KDM3KTtpZihpbmRleCZIYXJkZW5lZEJpdCl7aWYoIXRoaXMucHJpdmF0ZUtleSl7dGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIpfWRhdGEuc2V0KGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSksMSk7aWYocGF0aCl7cGF0aCs9XCInXCJ9fWVsc2V7ZGF0YS5zZXQoYXJyYXlpZnkodGhpcy5wdWJsaWNLZXkpKX1mb3IobGV0IGk9MjQ7aT49MDtpLT04KXtkYXRhWzMzKyhpPj4zKV09aW5kZXg+PjI0LWkmMjU1fWNvbnN0IEk9YXJyYXlpZnkoY29tcHV0ZUhtYWMoU3VwcG9ydGVkQWxnb3JpdGhtLnNoYTUxMix0aGlzLmNoYWluQ29kZSxkYXRhKSk7Y29uc3QgSUw9SS5zbGljZSgwLDMyKTtjb25zdCBJUj1JLnNsaWNlKDMyKTtsZXQga2k9bnVsbDtsZXQgS2k9bnVsbDtpZih0aGlzLnByaXZhdGVLZXkpe2tpPWJ5dGVzMzIoQmlnTnVtYmVyLmZyb20oSUwpLmFkZCh0aGlzLnByaXZhdGVLZXkpLm1vZChOKSl9ZWxzZXtjb25zdCBlaz1uZXcgU2lnbmluZ0tleShoZXhsaWZ5KElMKSk7S2k9ZWsuX2FkZFBvaW50KHRoaXMucHVibGljS2V5KX1sZXQgbW5lbW9uaWNPclBhdGg9cGF0aDtjb25zdCBzcmNNbmVtb25pYz10aGlzLm1uZW1vbmljO2lmKHNyY01uZW1vbmljKXttbmVtb25pY09yUGF0aD1PYmplY3QuZnJlZXplKHtwaHJhc2U6c3JjTW5lbW9uaWMucGhyYXNlLHBhdGg6cGF0aCxsb2NhbGU6c3JjTW5lbW9uaWMubG9jYWxlfHxcImVuXCJ9KX1yZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCQzLGtpLEtpLHRoaXMuZmluZ2VycHJpbnQsYnl0ZXMzMihJUiksaW5kZXgsdGhpcy5kZXB0aCsxLG1uZW1vbmljT3JQYXRoKX1kZXJpdmVQYXRoKHBhdGgpe2NvbnN0IGNvbXBvbmVudHM9cGF0aC5zcGxpdChcIi9cIik7aWYoY29tcG9uZW50cy5sZW5ndGg9PT0wfHxjb21wb25lbnRzWzBdPT09XCJtXCImJnRoaXMuZGVwdGghPT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggLSBcIitwYXRoKX1pZihjb21wb25lbnRzWzBdPT09XCJtXCIpe2NvbXBvbmVudHMuc2hpZnQoKX1sZXQgcmVzdWx0PXRoaXM7Zm9yKGxldCBpPTA7aTxjb21wb25lbnRzLmxlbmd0aDtpKyspe2NvbnN0IGNvbXBvbmVudD1jb21wb25lbnRzW2ldO2lmKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyckLykpe2NvbnN0IGluZGV4PXBhcnNlSW50KGNvbXBvbmVudC5zdWJzdHJpbmcoMCxjb21wb25lbnQubGVuZ3RoLTEpKTtpZihpbmRleD49SGFyZGVuZWRCaXQpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBpbmRleCAtIFwiK2NvbXBvbmVudCl9cmVzdWx0PXJlc3VsdC5fZGVyaXZlKEhhcmRlbmVkQml0K2luZGV4KX1lbHNlIGlmKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyQvKSl7Y29uc3QgaW5kZXg9cGFyc2VJbnQoY29tcG9uZW50KTtpZihpbmRleD49SGFyZGVuZWRCaXQpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBpbmRleCAtIFwiK2NvbXBvbmVudCl9cmVzdWx0PXJlc3VsdC5fZGVyaXZlKGluZGV4KX1lbHNle3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBjb21wb25lbnQgLSBcIitjb21wb25lbnQpfX1yZXR1cm4gcmVzdWx0fXN0YXRpYyBfZnJvbVNlZWQoc2VlZCxtbmVtb25pYyl7Y29uc3Qgc2VlZEFycmF5PWFycmF5aWZ5KHNlZWQpO2lmKHNlZWRBcnJheS5sZW5ndGg8MTZ8fHNlZWRBcnJheS5sZW5ndGg+NjQpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgc2VlZFwiKX1jb25zdCBJPWFycmF5aWZ5KGNvbXB1dGVIbWFjKFN1cHBvcnRlZEFsZ29yaXRobS5zaGE1MTIsTWFzdGVyU2VjcmV0LHNlZWRBcnJheSkpO3JldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkJDMsYnl0ZXMzMihJLnNsaWNlKDAsMzIpKSxudWxsLFwiMHgwMDAwMDAwMFwiLGJ5dGVzMzIoSS5zbGljZSgzMikpLDAsMCxtbmVtb25pYyl9c3RhdGljIGZyb21NbmVtb25pYyhtbmVtb25pYyxwYXNzd29yZCx3b3JkbGlzdCl7d29yZGxpc3Q9Z2V0V29yZGxpc3Qod29yZGxpc3QpO21uZW1vbmljPWVudHJvcHlUb01uZW1vbmljKG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLHdvcmRsaXN0KSx3b3JkbGlzdCk7cmV0dXJuIEhETm9kZS5fZnJvbVNlZWQobW5lbW9uaWNUb1NlZWQobW5lbW9uaWMscGFzc3dvcmQpLHtwaHJhc2U6bW5lbW9uaWMscGF0aDpcIm1cIixsb2NhbGU6d29yZGxpc3QubG9jYWxlfSl9c3RhdGljIGZyb21TZWVkKHNlZWQpe3JldHVybiBIRE5vZGUuX2Zyb21TZWVkKHNlZWQsbnVsbCl9c3RhdGljIGZyb21FeHRlbmRlZEtleShleHRlbmRlZEtleSl7Y29uc3QgYnl0ZXM9QmFzZTU4LmRlY29kZShleHRlbmRlZEtleSk7aWYoYnl0ZXMubGVuZ3RoIT09ODJ8fGJhc2U1OGNoZWNrKGJ5dGVzLnNsaWNlKDAsNzgpKSE9PWV4dGVuZGVkS2V5KXtsb2dnZXIkbC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLFwiZXh0ZW5kZWRLZXlcIixcIltSRURBQ1RFRF1cIil9Y29uc3QgZGVwdGg9Ynl0ZXNbNF07Y29uc3QgcGFyZW50RmluZ2VycHJpbnQ9aGV4bGlmeShieXRlcy5zbGljZSg1LDkpKTtjb25zdCBpbmRleD1wYXJzZUludChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDksMTMpKS5zdWJzdHJpbmcoMiksMTYpO2NvbnN0IGNoYWluQ29kZT1oZXhsaWZ5KGJ5dGVzLnNsaWNlKDEzLDQ1KSk7Y29uc3Qga2V5PWJ5dGVzLnNsaWNlKDQ1LDc4KTtzd2l0Y2goaGV4bGlmeShieXRlcy5zbGljZSgwLDQpKSl7Y2FzZVwiMHgwNDg4YjIxZVwiOmNhc2VcIjB4MDQzNTg3Y2ZcIjpyZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCQzLG51bGwsaGV4bGlmeShrZXkpLHBhcmVudEZpbmdlcnByaW50LGNoYWluQ29kZSxpbmRleCxkZXB0aCxudWxsKTtjYXNlXCIweDA0ODhhZGU0XCI6Y2FzZVwiMHgwNDM1ODM5NCBcIjppZihrZXlbMF0hPT0wKXticmVha31yZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCQzLGhleGxpZnkoa2V5LnNsaWNlKDEpKSxudWxsLHBhcmVudEZpbmdlcnByaW50LGNoYWluQ29kZSxpbmRleCxkZXB0aCxudWxsKX1yZXR1cm4gbG9nZ2VyJGwudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIixcImV4dGVuZGVkS2V5XCIsXCJbUkVEQUNURURdXCIpfX1mdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYyxwYXNzd29yZCl7aWYoIXBhc3N3b3JkKXtwYXNzd29yZD1cIlwifWNvbnN0IHNhbHQ9dG9VdGY4Qnl0ZXMoXCJtbmVtb25pY1wiK3Bhc3N3b3JkLFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktEKTtyZXR1cm4gcGJrZGYyKHRvVXRmOEJ5dGVzKG1uZW1vbmljLFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktEKSxzYWx0LDIwNDgsNjQsXCJzaGE1MTJcIil9ZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsd29yZGxpc3Qpe3dvcmRsaXN0PWdldFdvcmRsaXN0KHdvcmRsaXN0KTtsb2dnZXIkbC5jaGVja05vcm1hbGl6ZSgpO2NvbnN0IHdvcmRzPXdvcmRsaXN0LnNwbGl0KG1uZW1vbmljKTtpZih3b3Jkcy5sZW5ndGglMyE9PTApe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgbW5lbW9uaWNcIil9Y29uc3QgZW50cm9weT1hcnJheWlmeShuZXcgVWludDhBcnJheShNYXRoLmNlaWwoMTEqd29yZHMubGVuZ3RoLzgpKSk7bGV0IG9mZnNldD0wO2ZvcihsZXQgaT0wO2k8d29yZHMubGVuZ3RoO2krKyl7bGV0IGluZGV4PXdvcmRsaXN0LmdldFdvcmRJbmRleCh3b3Jkc1tpXS5ub3JtYWxpemUoXCJORktEXCIpKTtpZihpbmRleD09PS0xKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG1uZW1vbmljXCIpfWZvcihsZXQgYml0PTA7Yml0PDExO2JpdCsrKXtpZihpbmRleCYxPDwxMC1iaXQpe2VudHJvcHlbb2Zmc2V0Pj4zXXw9MTw8Ny1vZmZzZXQlOH1vZmZzZXQrK319Y29uc3QgZW50cm9weUJpdHM9MzIqd29yZHMubGVuZ3RoLzM7Y29uc3QgY2hlY2tzdW1CaXRzPXdvcmRzLmxlbmd0aC8zO2NvbnN0IGNoZWNrc3VtTWFzaz1nZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtjb25zdCBjaGVja3N1bT1hcnJheWlmeShzaGEyNTYkMShlbnRyb3B5LnNsaWNlKDAsZW50cm9weUJpdHMvOCkpKVswXSZjaGVja3N1bU1hc2s7aWYoY2hlY2tzdW0hPT0oZW50cm9weVtlbnRyb3B5Lmxlbmd0aC0xXSZjaGVja3N1bU1hc2spKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNoZWNrc3VtXCIpfXJldHVybiBoZXhsaWZ5KGVudHJvcHkuc2xpY2UoMCxlbnRyb3B5Qml0cy84KSl9ZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSx3b3JkbGlzdCl7d29yZGxpc3Q9Z2V0V29yZGxpc3Qod29yZGxpc3QpO2VudHJvcHk9YXJyYXlpZnkoZW50cm9weSk7aWYoZW50cm9weS5sZW5ndGglNCE9PTB8fGVudHJvcHkubGVuZ3RoPDE2fHxlbnRyb3B5Lmxlbmd0aD4zMil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbnRyb3B5XCIpfWNvbnN0IGluZGljZXM9WzBdO2xldCByZW1haW5pbmdCaXRzPTExO2ZvcihsZXQgaT0wO2k8ZW50cm9weS5sZW5ndGg7aSsrKXtpZihyZW1haW5pbmdCaXRzPjgpe2luZGljZXNbaW5kaWNlcy5sZW5ndGgtMV08PD04O2luZGljZXNbaW5kaWNlcy5sZW5ndGgtMV18PWVudHJvcHlbaV07cmVtYWluaW5nQml0cy09OH1lbHNle2luZGljZXNbaW5kaWNlcy5sZW5ndGgtMV08PD1yZW1haW5pbmdCaXRzO2luZGljZXNbaW5kaWNlcy5sZW5ndGgtMV18PWVudHJvcHlbaV0+PjgtcmVtYWluaW5nQml0cztpbmRpY2VzLnB1c2goZW50cm9weVtpXSZnZXRMb3dlck1hc2soOC1yZW1haW5pbmdCaXRzKSk7cmVtYWluaW5nQml0cys9M319Y29uc3QgY2hlY2tzdW1CaXRzPWVudHJvcHkubGVuZ3RoLzQ7Y29uc3QgY2hlY2tzdW09YXJyYXlpZnkoc2hhMjU2JDEoZW50cm9weSkpWzBdJmdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO2luZGljZXNbaW5kaWNlcy5sZW5ndGgtMV08PD1jaGVja3N1bUJpdHM7aW5kaWNlc1tpbmRpY2VzLmxlbmd0aC0xXXw9Y2hlY2tzdW0+PjgtY2hlY2tzdW1CaXRzO3JldHVybiB3b3JkbGlzdC5qb2luKGluZGljZXMubWFwKGluZGV4PT53b3JkbGlzdC5nZXRXb3JkKGluZGV4KSkpfWZ1bmN0aW9uIGlzVmFsaWRNbmVtb25pYyhtbmVtb25pYyx3b3JkbGlzdCl7dHJ5e21uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLHdvcmRsaXN0KTtyZXR1cm4gdHJ1ZX1jYXRjaChlcnJvcil7fXJldHVybiBmYWxzZX1jb25zdCB2ZXJzaW9uJGg9XCJyYW5kb20vNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkbT1uZXcgTG9nZ2VyKHZlcnNpb24kaCk7bGV0IGFueUdsb2JhbD1udWxsO3RyeXthbnlHbG9iYWw9d2luZG93O2lmKGFueUdsb2JhbD09bnVsbCl7dGhyb3cgbmV3IEVycm9yKFwidHJ5IG5leHRcIil9fWNhdGNoKGVycm9yKXt0cnl7YW55R2xvYmFsPWdsb2JhbDtpZihhbnlHbG9iYWw9PW51bGwpe3Rocm93IG5ldyBFcnJvcihcInRyeSBuZXh0XCIpfX1jYXRjaChlcnJvcil7YW55R2xvYmFsPXt9fX1sZXQgY3J5cHRvPWFueUdsb2JhbC5jcnlwdG98fGFueUdsb2JhbC5tc0NyeXB0bztpZighY3J5cHRvfHwhY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7bG9nZ2VyJG0ud2FybihcIldBUk5JTkc6IE1pc3Npbmcgc3Ryb25nIHJhbmRvbSBudW1iZXIgc291cmNlXCIpO2NyeXB0bz17Z2V0UmFuZG9tVmFsdWVzOmZ1bmN0aW9uKGJ1ZmZlcil7cmV0dXJuIGxvZ2dlciRtLnRocm93RXJyb3IoXCJubyBzZWN1cmUgcmFuZG9tIHNvdXJjZSBhdmFpYWxibGVcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiY3J5cHRvLmdldFJhbmRvbVZhbHVlc1wifSl9fX1mdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpe2lmKGxlbmd0aDw9MHx8bGVuZ3RoPjEwMjR8fGxlbmd0aCUxKXtsb2dnZXIkbS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aFwiLFwibGVuZ3RoXCIsbGVuZ3RoKX1jb25zdCByZXN1bHQ9bmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJlc3VsdCk7cmV0dXJuIGFycmF5aWZ5KHJlc3VsdCl9XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gc2h1ZmZsZWQoYXJyYXkpe2FycmF5PWFycmF5LnNsaWNlKCk7Zm9yKGxldCBpPWFycmF5Lmxlbmd0aC0xO2k+MDtpLS0pe2NvbnN0IGo9TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihpKzEpKTtjb25zdCB0bXA9YXJyYXlbaV07YXJyYXlbaV09YXJyYXlbal07YXJyYXlbal09dG1wfXJldHVybiBhcnJheX1cInVzZSBzdHJpY3RcIjt2YXIgYWVzSnM9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihyb290KXtmdW5jdGlvbiBjaGVja0ludCh2YWx1ZSl7cmV0dXJuIHBhcnNlSW50KHZhbHVlKT09PXZhbHVlfWZ1bmN0aW9uIGNoZWNrSW50cyhhcnJheWlzaCl7aWYoIWNoZWNrSW50KGFycmF5aXNoLmxlbmd0aCkpe3JldHVybiBmYWxzZX1mb3IodmFyIGk9MDtpPGFycmF5aXNoLmxlbmd0aDtpKyspe2lmKCFjaGVja0ludChhcnJheWlzaFtpXSl8fGFycmF5aXNoW2ldPDB8fGFycmF5aXNoW2ldPjI1NSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiBjb2VyY2VBcnJheShhcmcsY29weSl7aWYoYXJnLmJ1ZmZlciYmQXJyYXlCdWZmZXIuaXNWaWV3KGFyZykmJmFyZy5uYW1lPT09XCJVaW50OEFycmF5XCIpe2lmKGNvcHkpe2lmKGFyZy5zbGljZSl7YXJnPWFyZy5zbGljZSgpfWVsc2V7YXJnPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZyl9fXJldHVybiBhcmd9aWYoQXJyYXkuaXNBcnJheShhcmcpKXtpZighY2hlY2tJbnRzKGFyZykpe3Rocm93IG5ldyBFcnJvcihcIkFycmF5IGNvbnRhaW5zIGludmFsaWQgdmFsdWU6IFwiK2FyZyl9cmV0dXJuIG5ldyBVaW50OEFycmF5KGFyZyl9aWYoY2hlY2tJbnQoYXJnLmxlbmd0aCkmJmNoZWNrSW50cyhhcmcpKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKX10aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhcnJheS1saWtlIG9iamVjdFwiKX1mdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpe3JldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpfWZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2VBcnJheSx0YXJnZXRBcnJheSx0YXJnZXRTdGFydCxzb3VyY2VTdGFydCxzb3VyY2VFbmQpe2lmKHNvdXJjZVN0YXJ0IT1udWxsfHxzb3VyY2VFbmQhPW51bGwpe2lmKHNvdXJjZUFycmF5LnNsaWNlKXtzb3VyY2VBcnJheT1zb3VyY2VBcnJheS5zbGljZShzb3VyY2VTdGFydCxzb3VyY2VFbmQpfWVsc2V7c291cmNlQXJyYXk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc291cmNlQXJyYXksc291cmNlU3RhcnQsc291cmNlRW5kKX19dGFyZ2V0QXJyYXkuc2V0KHNvdXJjZUFycmF5LHRhcmdldFN0YXJ0KX12YXIgY29udmVydFV0Zjg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0b0J5dGVzKHRleHQpe3ZhciByZXN1bHQ9W10saT0wO3RleHQ9ZW5jb2RlVVJJKHRleHQpO3doaWxlKGk8dGV4dC5sZW5ndGgpe3ZhciBjPXRleHQuY2hhckNvZGVBdChpKyspO2lmKGM9PT0zNyl7cmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwyKSwxNikpO2krPTJ9ZWxzZXtyZXN1bHQucHVzaChjKX19cmV0dXJuIGNvZXJjZUFycmF5KHJlc3VsdCl9ZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzKXt2YXIgcmVzdWx0PVtdLGk9MDt3aGlsZShpPGJ5dGVzLmxlbmd0aCl7dmFyIGM9Ynl0ZXNbaV07aWYoYzwxMjgpe3Jlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO2krK31lbHNlIGlmKGM+MTkxJiZjPDIyNCl7cmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoYyYzMSk8PDZ8Ynl0ZXNbaSsxXSY2MykpO2krPTJ9ZWxzZXtyZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKChjJjE1KTw8MTJ8KGJ5dGVzW2krMV0mNjMpPDw2fGJ5dGVzW2krMl0mNjMpKTtpKz0zfX1yZXR1cm4gcmVzdWx0LmpvaW4oXCJcIil9cmV0dXJue3RvQnl0ZXM6dG9CeXRlcyxmcm9tQnl0ZXM6ZnJvbUJ5dGVzfX0oKTt2YXIgY29udmVydEhleD1mdW5jdGlvbigpe2Z1bmN0aW9uIHRvQnl0ZXModGV4dCl7dmFyIHJlc3VsdD1bXTtmb3IodmFyIGk9MDtpPHRleHQubGVuZ3RoO2krPTIpe3Jlc3VsdC5wdXNoKHBhcnNlSW50KHRleHQuc3Vic3RyKGksMiksMTYpKX1yZXR1cm4gcmVzdWx0fXZhciBIZXg9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7ZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzKXt2YXIgcmVzdWx0PVtdO2Zvcih2YXIgaT0wO2k8Ynl0ZXMubGVuZ3RoO2krKyl7dmFyIHY9Ynl0ZXNbaV07cmVzdWx0LnB1c2goSGV4Wyh2JjI0MCk+PjRdK0hleFt2JjE1XSl9cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpfXJldHVybnt0b0J5dGVzOnRvQnl0ZXMsZnJvbUJ5dGVzOmZyb21CeXRlc319KCk7dmFyIG51bWJlck9mUm91bmRzPXsxNjoxMCwyNDoxMiwzMjoxNH07dmFyIHJjb249WzEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0LDEwOCwyMTYsMTcxLDc3LDE1NCw0Nyw5NCwxODgsOTksMTk4LDE1MSw1MywxMDYsMjEyLDE3OSwxMjUsMjUwLDIzOSwxOTcsMTQ1XTt2YXIgUz1bOTksMTI0LDExOSwxMjMsMjQyLDEwNywxMTEsMTk3LDQ4LDEsMTAzLDQzLDI1NCwyMTUsMTcxLDExOCwyMDIsMTMwLDIwMSwxMjUsMjUwLDg5LDcxLDI0MCwxNzMsMjEyLDE2MiwxNzUsMTU2LDE2NCwxMTQsMTkyLDE4MywyNTMsMTQ3LDM4LDU0LDYzLDI0NywyMDQsNTIsMTY1LDIyOSwyNDEsMTEzLDIxNiw0OSwyMSw0LDE5OSwzNSwxOTUsMjQsMTUwLDUsMTU0LDcsMTgsMTI4LDIyNiwyMzUsMzksMTc4LDExNyw5LDEzMSw0NCwyNiwyNywxMTAsOTAsMTYwLDgyLDU5LDIxNCwxNzksNDEsMjI3LDQ3LDEzMiw4MywyMDksMCwyMzcsMzIsMjUyLDE3Nyw5MSwxMDYsMjAzLDE5MCw1Nyw3NCw3Niw4OCwyMDcsMjA4LDIzOSwxNzAsMjUxLDY3LDc3LDUxLDEzMyw2OSwyNDksMiwxMjcsODAsNjAsMTU5LDE2OCw4MSwxNjMsNjQsMTQzLDE0NiwxNTcsNTYsMjQ1LDE4OCwxODIsMjE4LDMzLDE2LDI1NSwyNDMsMjEwLDIwNSwxMiwxOSwyMzYsOTUsMTUxLDY4LDIzLDE5NiwxNjcsMTI2LDYxLDEwMCw5MywyNSwxMTUsOTYsMTI5LDc5LDIyMCwzNCw0MiwxNDQsMTM2LDcwLDIzOCwxODQsMjAsMjIyLDk0LDExLDIxOSwyMjQsNTAsNTgsMTAsNzMsNiwzNiw5MiwxOTQsMjExLDE3Miw5OCwxNDUsMTQ5LDIyOCwxMjEsMjMxLDIwMCw1NSwxMDksMTQxLDIxMyw3OCwxNjksMTA4LDg2LDI0NCwyMzQsMTAxLDEyMiwxNzQsOCwxODYsMTIwLDM3LDQ2LDI4LDE2NiwxODAsMTk4LDIzMiwyMjEsMTE2LDMxLDc1LDE4OSwxMzksMTM4LDExMiw2MiwxODEsMTAyLDcyLDMsMjQ2LDE0LDk3LDUzLDg3LDE4NSwxMzQsMTkzLDI5LDE1OCwyMjUsMjQ4LDE1MiwxNywxMDUsMjE3LDE0MiwxNDgsMTU1LDMwLDEzNSwyMzMsMjA2LDg1LDQwLDIyMywxNDAsMTYxLDEzNywxMywxOTEsMjMwLDY2LDEwNCw2NSwxNTMsNDUsMTUsMTc2LDg0LDE4NywyMl07dmFyIFNpPVs4Miw5LDEwNiwyMTMsNDgsNTQsMTY1LDU2LDE5MSw2NCwxNjMsMTU4LDEyOSwyNDMsMjE1LDI1MSwxMjQsMjI3LDU3LDEzMCwxNTUsNDcsMjU1LDEzNSw1MiwxNDIsNjcsNjgsMTk2LDIyMiwyMzMsMjAzLDg0LDEyMywxNDgsNTAsMTY2LDE5NCwzNSw2MSwyMzgsNzYsMTQ5LDExLDY2LDI1MCwxOTUsNzgsOCw0NiwxNjEsMTAyLDQwLDIxNywzNiwxNzgsMTE4LDkxLDE2Miw3MywxMDksMTM5LDIwOSwzNywxMTQsMjQ4LDI0NiwxMDAsMTM0LDEwNCwxNTIsMjIsMjEyLDE2NCw5MiwyMDQsOTMsMTAxLDE4MiwxNDYsMTA4LDExMiw3Miw4MCwyNTMsMjM3LDE4NSwyMTgsOTQsMjEsNzAsODcsMTY3LDE0MSwxNTcsMTMyLDE0NCwyMTYsMTcxLDAsMTQwLDE4OCwyMTEsMTAsMjQ3LDIyOCw4OCw1LDE4NCwxNzksNjksNiwyMDgsNDQsMzAsMTQzLDIwMiw2MywxNSwyLDE5MywxNzUsMTg5LDMsMSwxOSwxMzgsMTA3LDU4LDE0NSwxNyw2NSw3OSwxMDMsMjIwLDIzNCwxNTEsMjQyLDIwNywyMDYsMjQwLDE4MCwyMzAsMTE1LDE1MCwxNzIsMTE2LDM0LDIzMSwxNzMsNTMsMTMzLDIyNiwyNDksNTUsMjMyLDI4LDExNywyMjMsMTEwLDcxLDI0MSwyNiwxMTMsMjksNDEsMTk3LDEzNywxMTEsMTgzLDk4LDE0LDE3MCwyNCwxOTAsMjcsMjUyLDg2LDYyLDc1LDE5OCwyMTAsMTIxLDMyLDE1NCwyMTksMTkyLDI1NCwxMjAsMjA1LDkwLDI0NCwzMSwyMjEsMTY4LDUxLDEzNiw3LDE5OSw0OSwxNzcsMTgsMTYsODksMzksMTI4LDIzNiw5NSw5Niw4MSwxMjcsMTY5LDI1LDE4MSw3NCwxMyw0NSwyMjksMTIyLDE1OSwxNDcsMjAxLDE1NiwyMzksMTYwLDIyNCw1OSw3NywxNzQsNDIsMjQ1LDE3NiwyMDAsMjM1LDE4Nyw2MCwxMzEsODMsMTUzLDk3LDIzLDQzLDQsMTI2LDE4NiwxMTksMjE0LDM4LDIyNSwxMDUsMjAsOTksODUsMzMsMTIsMTI1XTt2YXIgVDE9WzMzMjg0MDIzNDEsNDE2ODkwNzkwOCw0MDAwODA2ODA5LDQxMzUyODc2OTMsNDI5NDExMTc1NywzNTk3MzY0MTU3LDM3MzE4NDUwNDEsMjQ0NTY1NzQyOCwxNjEzNzcwODMyLDMzNjIwMjI3LDM0NjI4ODMyNDEsMTQ0NTY2OTc1NywzODkyMjQ4MDg5LDMwNTA4MjE0NzQsMTMwMzA5NjI5NCwzOTY3MTg2NTg2LDI0MTI0MzE5NDEsNTI4NjQ2ODEzLDIzMTE3MDI4NDgsNDIwMjUyODEzNSw0MDI2MjAyNjQ1LDI5OTIyMDAxNzEsMjM4NzAzNjEwNSw0MjI2ODcxMzA3LDExMDE5MDEyOTIsMzAxNzA2OTY3MSwxNjA0NDk0MDc3LDExNjkxNDE3MzgsNTk3NDY2MzAzLDE0MDMyOTkwNjMsMzgzMjcwNTY4NiwyNjEzMTAwNjM1LDE5NzQ5NzQ0MDIsMzc5MTUxOTAwNCwxMDMzMDgxNzc0LDEyNzc1Njg2MTgsMTgxNTQ5MjE4NiwyMTE4MDc0MTc3LDQxMjY2Njg1NDYsMjIxMTIzNjk0MywxNzQ4MjUxNzQwLDEzNjk4MTA0MjAsMzUyMTUwNDU2NCw0MTkzMzgyNjY0LDM3OTkwODU0NTksMjg4MzExNTEyMywxNjQ3MzkxMDU5LDcwNjAyNDc2NywxMzQ0ODA5MDgsMjUxMjg5Nzg3NCwxMTc2NzA3OTQxLDI2NDY4NTI0NDYsODA2ODg1NDE2LDkzMjYxNTg0MSwxNjgxMDExMzUsNzk4NjYxMzAxLDIzNTM0MTU3Nyw2MDUxNjQwODYsNDYxNDA2MzYzLDM3NTYxODgyMjEsMzQ1NDc5MDQzOCwxMzExMTg4ODQxLDIxNDI0MTc2MTMsMzkzMzU2NjM2NywzMDI1ODIwNDMsNDk1MTU4MTc0LDE0NzkyODk5NzIsODc0MTI1ODcwLDkwNzc0NjA5MywzNjk4MjI0ODE4LDMwMjU4MjAzOTgsMTUzNzI1MzYyNywyNzU2ODU4NjE0LDE5ODM1OTMyOTMsMzA4NDMxMDExMywyMTA4OTI4OTc0LDEzNzg0MjkzMDcsMzcyMjY5OTU4MiwxNTgwMTUwNjQxLDMyNzQ1MTc5OSwyNzkwNDc4ODM3LDMxMTc1MzU1OTIsMCwzMjUzNTk1NDM2LDEwNzU4NDcyNjQsMzgyNTAwNzY0NywyMDQxNjg4NTIwLDMwNTk0NDA2MjEsMzU2Mzc0MzkzNCwyMzc4OTQzMzAyLDE3NDA1NTM5NDUsMTkxNjM1Mjg0MywyNDg3ODk2Nzk4LDI1NTUxMzcyMzYsMjk1ODU3OTk0NCwyMjQ0OTg4NzQ2LDMxNTEwMjQyMzUsMzMyMDgzNTg4MiwxMzM2NTg0OTMzLDM5OTI3MTQwMDYsMjI1MjU1NTIwNSwyNTg4NzU3NDYzLDE3MTQ2MzE1MDksMjkzOTYzMTU2LDIzMTk3OTU2NjMsMzkyNTQ3MzU1Miw2NzI0MDQ1NCw0MjY5NzY4NTc3LDI2ODk2MTgxNjAsMjAxNzIxMzUwOCw2MzEyMTgxMDYsMTI2OTM0NDQ4MywyNzIzMjM4Mzg3LDE1NzEwMDU0MzgsMjE1MTY5NDUyOCw5MzI5NDQ3NCwxMDY2NTcwNDEzLDU2Mzk3NzY2MCwxODgyNzMyNjE2LDQwNTk0MjgxMDAsMTY3MzMxMzUwMywyMDA4NDYzMDQxLDI5NTAzNTU1NzMsMTEwOTQ2NzQ5MSw1Mzc5MjM2MzIsMzg1ODc1OTQ1MCw0MjYwNjIzMTE4LDMyMTgyNjQ2ODUsMjE3Nzc0ODMwMCw0MDM0NDI3MDgsNjM4Nzg0MzA5LDMyODcwODQwNzksMzE5MzkyMTUwNSw4OTkxMjcyMDIsMjI4NjE3NTQzNiw3NzMyNjUyMDksMjQ3OTE0NjA3MSwxNDM3MDUwODY2LDQyMzYxNDgzNTQsMjA1MDgzMzczNSwzMzYyMDIyNTcyLDMxMjY2ODEwNjMsODQwNTA1NjQzLDM4NjYzMjU5MDksMzIyNzU0MTY2NCw0Mjc5MTc3MjAsMjY1NTk5NzkwNSwyNzQ5MTYwNTc1LDExNDMwODc3MTgsMTQxMjA0OTUzNCw5OTkzMjk5NjMsMTkzNDk3MjE5LDIzNTM0MTU4ODIsMzM1NDMyNDUyMSwxODA3MjY4MDUxLDY3MjQwNDU0MCwyODE2NDAxMDE3LDMxNjAzMDEyODIsMzY5ODIyNDkzLDI5MTY4NjY5MzQsMzY4ODk0Nzc3MSwxNjgxMDExMjg2LDE5NDk5NzMwNzAsMzM2MjAyMjcwLDI0NTQyNzY1NzEsMjAxNzIxMzU0LDEyMTAzMjgxNzIsMzA5MzA2MDgzNiwyNjgwMzQxMDg1LDMxODQ3NzYwNDYsMTEzNTM4OTkzNSwzMjk0NzgyMTE4LDk2NTg0MTMyMCw4MzE4ODY3NTYsMzU1NDk5MzIwNyw0MDY4MDQ3MjQzLDM1ODg3NDUwMTAsMjM0NTE5MTQ5MSwxODQ5MTEyNDA5LDM2NjQ2MDQ1OTksMjYwNTQwMjgsMjk4MzU4MTAyOCwyNjIyMzc3NjgyLDEyMzU4NTU4NDAsMzYzMDk4NDM3MiwyODkxMzM5NTE0LDQwOTI5MTY3NDMsMzQ4ODI3OTA3NywzMzk1NjQyNzk5LDQxMDE2Njc0NzAsMTIwMjYzMDM3NywyNjg5NjE4MTYsMTg3NDUwODUwMSw0MDM0NDI3MDE2LDEyNDM5NDgzOTksMTU0NjUzMDQxOCw5NDEzNjYzMDgsMTQ3MDUzOTUwNSwxOTQxMjIyNTk5LDI1NDYzODY1MTMsMzQyMTAzODYyNywyNzE1NjcxOTMyLDM4OTk5NDYxNDAsMTA0MjIyNjk3NywyNTIxNTE3MDIxLDE2Mzk4MjQ4NjAsMjI3MjQ5MDMwLDI2MDczNzY2OSwzNzY1NDY1MjMyLDIwODQ0NTM5NTQsMTkwNzczMzk1NiwzNDI5MjYzMDE4LDI0MjA2NTYzNDQsMTAwODYwNjc3LDQxNjAxNTcxODUsNDcwNjgzMTU0LDMyNjExNjE4OTEsMTc4MTg3MTk2NywyOTI0OTU5NzM3LDE3NzM3Nzk0MDgsMzk0NjkyMjQxLDI1Nzk2MTE5OTIsOTc0OTg2NTM1LDY2NDcwNjc0NSwzNjU1NDU5MTI4LDM5NTg5NjIxOTUsNzMxNDIwODUxLDU3MTU0Mzg1OSwzNTMwMTIzNzA3LDI4NDk2MjY0ODAsMTI2NzgzMTEzLDg2NTM3NTM5OSw3NjUxNzI2NjIsMTAwODYwNjc1NCwzNjEyMDM2MDIsMzM4NzU0OTk4NCwyMjc4NDc3Mzg1LDI4NTc3MTkyOTUsMTM0NDgwOTA4MCwyNzgyOTEyMzc4LDU5NTQyNjcxLDE1MDM3NjQ5ODQsMTYwMDA4NTc2LDQzNzA2MjkzNSwxNzA3MDY1MzA2LDM2MjIyMzM2NDksMjIxODkzNDk4MiwzNDk2NTAzNDgwLDIxODUzMTQ3NTUsNjk3OTMyMjA4LDE1MTI5MTAxOTksNTA0MzAzMzc3LDIwNzUxNzcxNjMsMjgyNDA5OTA2OCwxODQxMDE5ODYyLDczOTY0NDk4Nl07dmFyIFQyPVsyNzgxMjQyMjExLDIyMzA4NzczMDgsMjU4MjU0MjE5OSwyMzgxNzQwOTIzLDIzNDg3NzY4MiwzMTg0OTQ2MDI3LDI5ODQxNDQ3NTEsMTQxODgzOTQ5MywxMzQ4NDgxMDcyLDUwNDYyOTc3LDI4NDg4NzYzOTEsMjEwMjc5OTE0Nyw0MzQ2MzQ0OTQsMTY1NjA4NDQzOSwzODYzODQ5ODk5LDI1OTkxODgwODYsMTE2NzA1MTQ2NiwyNjM2MDg3OTM4LDEwODI3NzE5MTMsMjI4MTM0MDI4NSwzNjgwNDg4OTAsMzk1NDMzNDA0MSwzMzgxNTQ0Nzc1LDIwMTA2MDU5MiwzOTYzNzI3Mjc3LDE3Mzk4Mzg2NzYsNDI1MDkwMzIwMiwzOTMwNDM1NTAzLDMyMDY3ODIxMDgsNDE0OTQ1Mzk4OCwyNTMxNTUzOTA2LDE1MzY5MzQwODAsMzI2MjQ5NDY0Nyw0ODQ1NzI2NjksMjkyMzI3MTA1OSwxNzgzMzc1Mzk4LDE1MTcwNDEyMDYsMTA5ODc5Mjc2Nyw0OTY3NDIzMSwxMzM0MDM3NzA4LDE1NTAzMzI5ODAsNDA5ODk5MTUyNSw4ODYxNzExMDksMTUwNTk4MTI5LDI0ODEwOTA5MjksMTk0MDY0MjAwOCwxMzk4OTQ0MDQ5LDEwNTk3MjI1MTcsMjAxODUxOTA4LDEzODU1NDc3MTksMTY5OTA5NTMzMSwxNTg3Mzk3NTcxLDY3NDI0MDUzNiwyNzA0Nzc0ODA2LDI1MjMxNDg4NSwzMDM5Nzk1ODY2LDE1MTkxNDI0Nyw5MDgzMzM1ODYsMjYwMjI3MDg0OCwxMDM4MDgyNzg2LDY1MTAyOTQ4MywxNzY2NzI5NTExLDM0NDc2OTgwOTgsMjY4Mjk0MjgzNyw0NTQxNjY3OTMsMjY1MjczNDMzOSwxOTUxOTM1NTMyLDc3NTE2NjQ5MCw3NTg1MjA2MDMsMzAwMDc5MDYzOCw0MDA0Nzk3MDE4LDQyMTcwODYxMTIsNDEzNzk2NDExNCwxMjk5NTk0MDQzLDE2Mzk0MzgwMzgsMzQ2NDM0NDQ5OSwyMDY4OTgyMDU3LDEwNTQ3MjkxODcsMTkwMTk5Nzg3MSwyNTM0NjM4NzI0LDQxMjEzMTgyMjcsMTc1NzAwODMzNywwLDc1MDkwNjg2MSwxNjE0ODE1MjY0LDUzNTAzNTEzMiwzMzYzNDE4NTQ1LDM5ODgxNTExMzEsMzIwMTU5MTkxNCwxMTgzNjk3ODY3LDM2NDc0NTQ5MTAsMTI2NTc3Njk1MywzNzM0MjYwMjk4LDM1NjY3NTA3OTYsMzkwMzg3MTA2NCwxMjUwMjgzNDcxLDE4MDc0NzA4MDAsNzE3NjE1MDg3LDM4NDcyMDM0OTgsMzg0Njk1MjkxLDMzMTM5MTA1OTUsMzYxNzIxMzc3MywxNDMyNzYxMTM5LDI0ODQxNzYyNjEsMzQ4MTk0NTQxMywyODM3NjkzMzcsMTAwOTI1OTU0LDIxODA5Mzk2NDcsNDAzNzAzODE2MCwxMTQ4NzMwNDI4LDMxMjMwMjc4NzEsMzgxMzM4NjQwOCw0MDg3NTAxMTM3LDQyNjc1NDk2MDMsMzIyOTYzMDUyOCwyMzE1NjIwMjM5LDI5MDY2MjQ2NTgsMzE1NjMxOTY0NSwxMjE1MzEzOTc2LDgyOTY2MDA1LDM3NDc4NTU1NDgsMzI0NTg0ODI0NiwxOTc0NDU5MDk4LDE2NjUyNzgyNDEsODA3NDA3NjMyLDQ1MTI4MDg5NSwyNTE1MjQwODMsMTg0MTI4Nzg5MCwxMjgzNTc1MjQ1LDMzNzEyMDI2OCw4OTE2ODc2OTksODAxMzY5MzI0LDM3ODczNDk4NTUsMjcyMTQyMTIwNywzNDMxNDgyNDM2LDk1OTMyMTg3OSwxNDY5MzAxOTU2LDQwNjU2OTk3NTEsMjE5NzU4NTUzNCwxMTk5MTkzNDA1LDI4OTg4MTQwNTIsMzg4Nzc1MDQ5Myw3MjQ3MDM1MTMsMjUxNDkwODAxOSwyNjk2OTYyMTQ0LDI1NTE4MDgzODUsMzUxNjgxMzEzNSwyMTQxNDQ1MzQwLDE3MTU3NDEyMTgsMjExOTQ0NTAzNCwyODcyODA3NTY4LDIxOTg1NzExNDQsMzM5ODE5MDY2Miw3MDA5Njg2ODYsMzU0NzA1MjIxNiwxMDA5MjU5NTQwLDIwNDEwNDQ3MDIsMzgwMzk5NTc0Miw0ODc5ODM4ODMsMTk5MTEwNTQ5OSwxMDA0MjY1Njk2LDE0NDk0MDcwMjYsMTMxNjIzOTkzMCw1MDQ2Mjk3NzAsMzY4Mzc5NzMyMSwxNjg1NjAxMzQsMTgxNjY2NzE3MiwzODM3Mjg3NTE2LDE1NzA3NTExNzAsMTg1NzkzNDI5MSw0MDE0MTg5NzQwLDI3OTc4ODgwOTgsMjgyMjM0NTEwNSwyNzU0NzEyOTgxLDkzNjYzMzU3MiwyMzQ3OTIzODMzLDg1Mjg3OTMzNSwxMTMzMjM0Mzc2LDE1MDAzOTUzMTksMzA4NDU0NTM4OSwyMzQ4OTEyMDEzLDE2ODkzNzYyMTMsMzUzMzQ1OTAyMiwzNzYyOTIzOTQ1LDMwMzQwODI0MTIsNDIwNTU5ODI5NCwxMzM0Mjg0NjgsNjM0MzgzMDgyLDI5NDkyNzcwMjksMjM5ODM4NjgxMCwzOTEzNzg5MTAyLDQwMzcwMzgxNiwzNTgwODY5MzA2LDIyOTc0NjA4NTYsMTg2NzEzMDE0OSwxOTE4NjQzNzU4LDYwNzY1Njk4OCw0MDQ5MDUzMzUwLDMzNDYyNDg4ODQsMTM2ODkwMTMxOCw2MDA1NjU5OTIsMjA5MDk4Mjg3NywyNjMyNDc5ODYwLDU1NzcxOTMyNywzNzE3NjE0NDExLDM2OTczOTMwODUsMjI0OTAzNDYzNSwyMjMyMzg4MjM0LDI0MzA2Mjc5NTIsMTExNTQzODY1NCwzMjk1Nzg2NDIxLDI4NjU1MjIyNzgsMzYzMzMzNDM0NCw4NDI4MDA2NywzMzAyNzgzMCwzMDM4Mjg0OTQsMjc0NzQyNTEyMSwxNjAwNzk1OTU3LDQxODg5NTI0MDcsMzQ5NjU4OTc1MywyNDM0MjM4MDg2LDE0ODY0NzE2MTcsNjU4MTE5OTY1LDMxMDYzODE0NzAsOTUzODAzMjMzLDMzNDIzMTgwMCwzMDA1OTc4Nzc2LDg1Nzg3MDYwOSwzMTUxMTI4OTM3LDE4OTAxNzk1NDUsMjI5ODk3MzgzOCwyODA1MTc1NDQ0LDMwNTY0NDIyNjcsNTc0MzY1MjE0LDI0NTA4ODQ0ODcsNTUwMTAzNTI5LDEyMzM2MzcwNzAsNDI4OTM1MzA0NSwyMDE4NTE5MDgwLDIwNTc2OTExMDMsMjM5OTM3NDQ3Niw0MTY2NjIzNjQ5LDIxNDgxMDg2ODEsMzg3NTgzMjQ1LDM2NjQxMDEzMTEsODM2MjMyOTM0LDMzMzA1NTY0ODIsMzEwMDY2NTk2MCwzMjgwMDkzNTA1LDI5NTU1MTYzMTMsMjAwMjM5ODUwOSwyODcxODI2MDcsMzQxMzg4MTAwOCw0MjM4ODkwMDY4LDM1OTc1MTU3MDcsOTc1OTY3NzY2XTt2YXIgVDM9WzE2NzE4MDg2MTEsMjA4OTA4OTE0OCwyMDA2NTc2NzU5LDIwNzI5MDEyNDMsNDA2MTAwMzc2MiwxODA3NjAzMzA3LDE4NzM5Mjc3OTEsMzMxMDY1Mzg5Myw4MTA1NzM4NzIsMTY5NzQzMzcsMTczOTE4MTY3MSw3Mjk2MzQzNDcsNDI2MzExMDY1NCwzNjEzNTcwNTE5LDI4ODM5OTcwOTksMTk4OTg2NDU2NiwzMzkzNTU2NDI2LDIxOTEzMzUyOTgsMzM3NjQ0OTk5MywyMTA2MDYzNDg1LDQxOTU3NDE2OTAsMTUwODYxODg0MSwxMjA0MzkxNDk1LDQwMjczMTcyMzIsMjkxNzk0MTY3NywzNTYzNTY2MDM2LDI3MzQ1MTQwODIsMjk1MTM2NjA2MywyNjI5NzcyMTg4LDI3Njc2NzIyMjgsMTkyMjQ5MTUwNiwzMjI3MjI5MTIwLDMwODI5NzQ2NDcsNDI0NjUyODUwOSwyNDc3NjY5Nzc5LDY0NDUwMDUxOCw5MTE4OTU2MDYsMTA2MTI1Njc2Nyw0MTQ0MTY2MzkxLDM0Mjc3NjMxNDgsODc4NDcxMjIwLDI3ODQyNTIzMjUsMzg0NTQ0NDA2OSw0MDQzODk3MzI5LDE5MDU1MTcxNjksMzYzMTQ1OTI4OCw4Mjc1NDgyMDksMzU2NDYxMDc3LDY3ODk3MzQ4LDMzNDQwNzgyNzksNTkzODM5NjUxLDMyNzc3NTc4OTEsNDA1Mjg2OTM2LDI1MjcxNDc5MjYsODQ4NzE2ODUsMjU5NTU2NTQ2NiwxMTgwMzM5MjcsMzA1NTM4MDY2LDIxNTc2NDg3NjgsMzc5NTcwNTgyNiwzOTQ1MTg4ODQzLDY2MTIxMjcxMSwyOTk5ODEyMDE4LDE5NzM0MTQ1MTcsMTUyNzY5MDMzLDIyMDgxNzc1MzksNzQ1ODIyMjUyLDQzOTIzNTYxMCw0NTU5NDc4MDMsMTg1NzIxNTU5OCwxNTI1NTkzMTc4LDI3MDA4Mjc1NTIsMTM5MTg5NTYzNCw5OTQ5MzIyODMsMzU5NjcyODI3OCwzMDE2NjU0MjU5LDY5NTk0NzgxNywzODEyNTQ4MDY3LDc5NTk1ODgzMSwyMjI0NDkzNDQ0LDE0MDg2MDc4MjcsMzUxMzMwMTQ1NywwLDM5NzkxMzM0MjEsNTQzMTc4Nzg0LDQyMjk5NDg0MTIsMjk4MjcwNTU4NSwxNTQyMzA1MzcxLDE3OTA4OTExMTQsMzQxMDM5ODY2NywzMjAxOTE4OTEwLDk2MTI0NTc1MywxMjU2MTAwOTM4LDEyODkwMDEwMzYsMTQ5MTY0NDUwNCwzNDc3NzY3NjMxLDM0OTY3MjEzNjAsNDAxMjU1NzgwNywyODY3MTU0ODU4LDQyMTI1ODM5MzEsMTEzNzAxODQzNSwxMzA1OTc1MzczLDg2MTIzNDczOSwyMjQxMDczNTQxLDExNzEyMjkyNTMsNDE3ODYzNTI1NywzMzk0ODY3NCwyMTM5MjI1NzI3LDEzNTc5NDY5NjAsMTAxMTEyMDE4OCwyNjc5Nzc2NjcxLDI4MzM0NjgzMjgsMTM3NDkyMTI5NywyNzUxMzU2MzIzLDEwODYzNTc1NjgsMjQwODE4NzI3OSwyNDYwODI3NTM4LDI2NDYzNTIyODUsOTQ0MjcxNDE2LDQxMTA3NDIwMDUsMzE2ODc1NjY2OCwzMDY2MTMyNDA2LDM2NjUxNDU4MTgsNTYwMTUzMTIxLDI3MTU4OTM5Miw0Mjc5OTUyODk1LDQwNzc4NDYwMDMsMzUzMDQwNzg5MCwzNDQ0MzQzMjQ1LDIwMjY0MzQ2OCwzMjIyNTAyNTksMzk2MjU1MzMyNCwxNjA4NjI5ODU1LDI1NDM5OTAxNjcsMTE1NDI1NDkxNiwzODk2MjMzMTksMzI5NDA3Mzc5NiwyODE3Njc2NzExLDIxMjI1MTM1MzQsMTAyODA5NDUyNSwxNjg5MDQ1MDkyLDE1NzU0Njc2MTMsNDIyMjYxMjczLDE5MzkyMDM2OTksMTYyMTE0Nzc0NCwyMTc0MjI4ODY1LDEzMzkxMzc2MTUsMzY5OTM1MjU0MCw1NzcxMjc0NTgsNzEyOTIyMTU0LDI0MjcxNDEwMDgsMjI5MDI4OTU0NCwxMTg3Njc5MzAyLDM5OTU3MTU1NjYsMzEwMDg2MzQxNiwzMzk0ODY3NDAsMzczMjUxNDc4MiwxNTkxOTE3NjYyLDE4NjQ1NTU2MywzNjgxOTg4MDU5LDM3NjIwMTkyOTYsODQ0NTIyNTQ2LDk3ODIyMDA5MCwxNjk3NDMzNzAsMTIzOTEyNjYwMSwxMDEzMjE3MzQsNjExMDc2MTMyLDE1NTg0OTMyNzYsMzI2MDkxNTY1MCwzNTQ3MjUwMTMxLDI5MDEzNjE1ODAsMTY1NTA5NjQxOCwyNDQzNzIxMTA1LDI1MTA1NjU3ODEsMzgyODg2Mzk3MiwyMDM5MjE0NzEzLDM4Nzg4Njg0NTUsMzM1OTg2OTg5Niw5Mjg2MDc3OTksMTg0MDc2NTU0OSwyMzc0NzYyODkzLDM1ODAxNDYxMzMsMTMyMjQyNTQyMiwyODUwMDQ4NDI1LDE4MjM3OTEyMTIsMTQ1OTI2ODY5NCw0MDk0MTYxOTA4LDM5MjgzNDY2MDIsMTcwNjAxOTQyOSwyMDU2MTg5MDUwLDI5MzQ1MjM4MjIsMTM1Nzk0Njk2LDMxMzQ1NDk5NDYsMjAyMjI0MDM3Niw2MjgwNTA0NjksNzc5MjQ2NjM4LDQ3MjEzNTcwOCwyODAwODM0NDcwLDMwMzI5NzAxNjQsMzMyNzIzNjAzOCwzODk0NjYwMDcyLDM3MTU5MzI2MzcsMTk1NjQ0MDE4MCw1MjIyNzIyODcsMTI3MjgxMzEzMSwzMTg1MzM2NzY1LDIzNDA4MTgzMTUsMjMyMzk3NjA3NCwxODg4NTQyODMyLDEwNDQ1NDQ1NzQsMzA0OTU1MDI2MSwxNzIyNDY5NDc4LDEyMjIxNTIyNjQsNTA2NjA4NjcsNDEyNzMyNDE1MCwyMzYwNjc4NTQsMTYzODEyMjA4MSw4OTU0NDU1NTcsMTQ3NTk4MDg4NywzMTE3NDQzNTEzLDIyNTc2NTU2ODYsMzI0MzgwOTIxNyw0ODkxMTAwNDUsMjY2MjkzNDQzMCwzNzc4NTk5MzkzLDQxNjIwNTUxNjAsMjU2MTg3ODkzNiwyODg1NjM3MjksMTc3MzkxNjc3NywzNjQ4MDM5Mzg1LDIzOTEzNDUwMzgsMjQ5Mzk4NTY4NCwyNjEyNDA3NzA3LDUwNTU2MDA5NCwyMjc0NDk3OTI3LDM5MTEyNDAxNjksMzQ2MDkyNTM5MCwxNDQyODE4NjQ1LDY3ODk3MzQ4MCwzNzQ5MzU3MDIzLDIzNTgxODI3OTYsMjcxNzQwNzY0OSwyMzA2ODY5NjQxLDIxOTYxNzgwNSwzMjE4NzYxMTUxLDM4NjIwMjYyMTQsMTEyMDMwNjI0MiwxNzU2OTQyNDQwLDExMDMzMzE5MDUsMjU3ODQ1OTAzMyw3NjI3OTY1ODksMjUyNzgwMDQ3LDI5NjYxMjU0ODgsMTQyNTg0NDMwOCwzMTUxMzkyMTg3LDM3MjkxMTEyNl07dmFyIFQ0PVsxNjY3NDc0ODg2LDIwODg1MzUyODgsMjAwNDMyNjg5NCwyMDcxNjk0ODM4LDQwNzU5NDk1NjcsMTgwMjIyMzA2MiwxODY5NTkxMDA2LDMzMTgwNDM3OTMsODA4NDcyNjcyLDE2ODQzNTIyLDE3MzQ4NDY5MjYsNzI0MjcwNDIyLDQyNzgwNjU2MzksMzYyMTIxNjk0OSwyODgwMTY5NTQ5LDE5ODc0ODQzOTYsMzQwMjI1MzcxMSwyMTg5NTk3OTgzLDMzODU0MDk2NzMsMjEwNTM3ODgxMCw0MjEwNjkzNjE1LDE0OTkwNjUyNjYsMTE5NTg4Njk5MCw0MDQyMjYzNTQ3LDI5MTM4NTY1NzcsMzU3MDY4OTk3MSwyNzI4NTkwNjg3LDI5NDc1NDE1NzMsMjYyNzUxODI0MywyNzYyMjc0NjQzLDE5MjAxMTIzNTYsMzIzMzgzMTgzNSwzMDgyMjczMzk3LDQyNjEyMjM2NDksMjQ3NTkyOTE0OSw2NDAwNTE3ODgsOTA5NTMxNzU2LDEwNjExMTAxNDIsNDE2MDE2MDUwMSwzNDM1OTQxNzYzLDg3NTg0Njc2MCwyNzc5MTE2NjI1LDM4NTcwMDM3MjksNDA1OTEwNTUyOSwxOTAzMjY4ODM0LDM2MzgwNjQwNDMsODI1MzE2MTk0LDM1MzcxMzk2Miw2NzM3NDA4OCwzMzUxNzI4Nzg5LDU4OTUyMjI0NiwzMjg0MzYwODYxLDQwNDIzNjMzNiwyNTI2NDU0MDcxLDg0MjE3NjEwLDI1OTM4MzAxOTEsMTE3OTAxNTgyLDMwMzE4MzM5NiwyMTU1OTExOTYzLDM4MDY0Nzc3OTEsMzk1ODA1NjY1Myw2NTY4OTQyODYsMjk5ODA2MjQ2MywxOTcwNjQyOTIyLDE1MTU5MTY5OCwyMjA2NDQwOTg5LDc0MTExMDg3Miw0Mzc5MjMzODAsNDU0NzY1ODc4LDE4NTI3NDg1MDgsMTUxNTkwODc4OCwyNjk0OTA0NjY3LDEzODExNjg4MDQsOTkzNzQyMTk4LDM2MDQzNzM5NDMsMzAxNDkwNTQ2OSw2OTA1ODQ0MDIsMzgyMzMyMDc5Nyw3OTE2MzgzNjYsMjIyMzI4MTkzOSwxMzk4MDExMzAyLDM1MjAxNjE5NzcsMCwzOTkxNzQzNjgxLDUzODk5MjcwNCw0MjQ0MzgxNjY3LDI5ODEyMTg0MjUsMTUzMjc1MTI4NiwxNzg1MzgwNTY0LDM0MTkwOTY3MTcsMzIwMDE3ODUzNSw5NjAwNTYxNzgsMTI0NjQyMDYyOCwxMjgwMTAzNTc2LDE0ODIyMjE3NDQsMzQ4NjQ2ODc0MSwzNTAzMzE5OTk1LDQwMjU0Mjg2NzcsMjg2MzMyNjU0Myw0MjI3NTM2NjIxLDExMjg1MTQ5NTAsMTI5Njk0NzA5OCw4NTkwMDIyMTQsMjI0MDEyMzkyMSwxMTYyMjAzMDE4LDQxOTM4NDk1NzcsMzM2ODcwNDQsMjEzOTA2Mjc4MiwxMzQ3NDgxNzYwLDEwMTA1ODI2NDgsMjY3ODA0NTIyMSwyODI5NjQwNTIzLDEzNjQzMjUyODIsMjc0NTQzMzY5MywxMDc3OTg1NDA4LDI0MDg1NDg4NjksMjQ1OTA4NjE0MywyNjQ0MzYwMjI1LDk0MzIxMjY1Niw0MTI2NDc1NTA1LDMxNjY0OTQ1NjMsMzA2NTQzMDM5MSwzNjcxNzUwMDYzLDU1NTgzNjIyNiwyNjk0OTYzNTIsNDI5NDkwODY0NSw0MDkyNzkyNTczLDM1MzcwMDYwMTUsMzQ1Mjc4Mzc0NSwyMDIxMTgxNjgsMzIwMDI1ODk0LDM5NzQ5MDE2OTksMTYwMDExOTIzMCwyNTQzMjk3MDc3LDExNDUzNTk0OTYsMzg3Mzk3OTM0LDMzMDEyMDE4MTEsMjgxMjgwMTYyMSwyMTIyMjIwMjg0LDEwMjc0MjYxNzAsMTY4NDMxOTQzMiwxNTY2NDM1MjU4LDQyMTA3OTg1OCwxOTM2OTU0ODU0LDE2MTY5NDUzNDQsMjE3Mjc1Mzk0NSwxMzMwNjMxMDcwLDM3MDU0MzgxMTUsNTcyNjc5NzQ4LDcwNzQyNzkyNCwyNDI1NDAwMTIzLDIyOTA2NDc4MTksMTE3OTA0NDQ5Miw0MDA4NTg1NjcxLDMwOTkxMjA0OTEsMzM2ODcwNDQwLDM3MzkxMjIwODcsMTU4MzI3NjczMiwxODUyNzc3MTgsMzY4ODU5MzA2OSwzNzcyNzkxNzcxLDg0MjE1OTcxNiw5NzY4OTk3MDAsMTY4NDM1MjIwLDEyMjk1NzcxMDYsMTAxMDU5MDg0LDYwNjM2Njc5MiwxNTQ5NTkxNzM2LDMyNjc1MTc4NTUsMzU1Mzg0OTAyMSwyODk3MDE0NTk1LDE2NTA2MzIzODgsMjQ0MjI0MjEwNSwyNTA5NjEyMDgxLDM4NDAxNjE3NDcsMjAzODAwODgxOCwzODkwNjg4NzI1LDMzNjg1Njc2OTEsOTI2Mzc0MjU0LDE4MzU5MDcwMzQsMjM3NDg2Mzg3MywzNTg3NTMxOTUzLDEzMTM3ODg1NzIsMjg0NjQ4MjUwNSwxODE5MDYzNTEyLDE0NDg1NDA4NDQsNDEwOTYzMzUyMywzOTQxMjEzNjQ3LDE3MDExNjI5NTQsMjA1NDg1MjM0MCwyOTMwNjk4NTY3LDEzNDc0ODE3NiwzMTMyODA2NTExLDIwMjExNjUyOTYsNjIzMjEwMzE0LDc3NDc5NTg2OCw0NzE2MDYzMjgsMjc5NTk1ODYxNSwzMDMxNzQ2NDE5LDMzMzQ4ODU3ODMsMzkwNzUyNzYyNywzNzIyMjgwMDk3LDE5NTM3OTk0MDAsNTIyMTMzODIyLDEyNjMyNjMxMjYsMzE4MzMzNjU0NSwyMzQxMTc2ODQ1LDIzMjQzMzM4MzksMTg4NjQyNTMxMiwxMDQ0MjY3NjQ0LDMwNDg1ODg0MDEsMTcxODAwNDQyOCwxMjEyNzMzNTg0LDUwNTI5NTQyLDQxNDMzMTc0OTUsMjM1ODAzMTY0LDE2MzM3ODg4NjYsODkyNjkwMjgyLDE0NjUzODMzNDIsMzExNTk2MjQ3MywyMjU2OTY1OTExLDMyNTA2NzM4MTcsNDg4NDQ5ODUwLDI2NjEyMDIyMTUsMzc4OTYzMzc1Myw0MTc3MDA3NTk1LDI1NjAxNDQxNzEsMjg2MzM5ODc0LDE3Njg1MzcwNDIsMzY1NDkwNjAyNSwyMzkxNzA1ODYzLDI0OTI3NzAwOTksMjYxMDY3MzE5Nyw1MDUyOTEzMjQsMjI3MzgwODkxNywzOTI0MzY5NjA5LDM0Njk2MjU3MzUsMTQzMTY5OTM3MCw2NzM3NDA4ODAsMzc1NTk2NTA5MywyMzU4MDIxODkxLDI3MTE3NDY2NDksMjMwNzQ4OTgwMSwyMTg5NjE2OTAsMzIxNzAyMTU0MSwzODczODQ1NzE5LDExMTE2NzI0NTIsMTc1MTY5MzUyMCwxMDk0ODI4OTMwLDI1NzY5ODYxNTMsNzU3OTU0Mzk0LDI1MjY0NTY2MiwyOTY0Mzc2NDQzLDE0MTQ4NTU4NDgsMzE0OTY0OTUxNywzNzA1NTU0MzZdO3ZhciBUNT1bMTM3NDk4ODExMiwyMTE4MjE0OTk1LDQzNzc1NzEyMyw5NzU2NTg2NDYsMTAwMTA4OTk5NSw1MzA0MDA3NTMsMjkwMjA4Nzg1MSwxMjczMTY4Nzg3LDU0MDA4MDcyNSwyOTEwMjE5NzY2LDIyOTUxMDEwNzMsNDExMDU2ODQ4NSwxMzQwNDYzMTAwLDMzMDc5MTYyNDcsNjQxMDI1MTUyLDMwNDMxNDA0OTUsMzczNjE2NDkzNyw2MzI5NTM3MDMsMTE3Mjk2NzA2NCwxNTc2OTc2NjA5LDMyNzQ2NjcyNjYsMjE2OTMwMzA1OCwyMzcwMjEzNzk1LDE4MDkwNTQxNTAsNTk3Mjc4NDcsMzYxOTI5ODc3LDMyMTE2MjMxNDcsMjUwNTIwMjEzOCwzNTY5MjU1MjEzLDE0ODQwMDU4NDMsMTIzOTQ0Mzc1MywyMzk1NTg4Njc2LDE5NzU2ODM0MzQsNDEwMjk3NzkxMiwyNTcyNjk3MTk1LDY2NjQ2NDczMywzMjAyNDM3MDQ2LDQwMzU0ODkwNDcsMzM3NDM2MTcwMiwyMTEwNjY3NDQ0LDE2NzU1Nzc4ODAsMzg0MzY5OTA3NCwyNTM4NjgxMTg0LDE2NDk2MzkyMzcsMjk3NjE1MTUyMCwzMTQ0Mzk2NDIwLDQyNjk5MDc5OTYsNDE3ODA2MjIyOCwxODgzNzkzNDk2LDI0MDM3Mjg2NjUsMjQ5NzYwNDc0MywxMzgzODU2MzExLDI4NzY0OTQ2MjcsMTkxNzUxODU2MiwzODEwNDk2MzQzLDE3MTY4OTA0MTAsMzAwMTc1NTY1NSw4MDA0NDA4MzUsMjI2MTA4OTE3OCwzNTQzNTk5MjY5LDgwNzk2MjYxMCw1OTk3NjIzNTQsMzM3NzgzNjIsMzk3NzY3NTM1NiwyMzI4ODI4OTcxLDI4MDk3NzExNTQsNDA3NzM4NDQzMiwxMzE1NTYyMTQ1LDE3MDg4NDgzMzMsMTAxMDM5ODI5LDM1MDk4NzExMzUsMzI5OTI3ODQ3NCw4NzU0NTEyOTMsMjczMzg1NjE2MCw5Mjk4NzY5OCwyNzY3NjQ1NTU3LDE5MzE5NTA2NSwxMDgwMDk0NjM0LDE1ODQ1MDQ1ODIsMzE3ODEwNjk2MSwxMDQyMzg1NjU3LDI1MzEwNjc0NTMsMzcxMTgyOTQyMiwxMzA2OTY3MzY2LDI0MzgyMzc2MjEsMTkwODY5NDI3Nyw2NzU1NjQ2MywxNjE1ODYxMjQ3LDQyOTQ1NjE2NCwzNjAyNzcwMzI3LDIzMDI2OTAyNTIsMTc0MjMxNTEyNywyOTY4MDExNDUzLDEyNjQ1NDY2NCwzODc3MTk4NjQ4LDIwNDMyMTE0ODMsMjcwOTI2MDg3MSwyMDg0NzA0MjMzLDQxNjk0MDgyMDEsMCwxNTk0MTc5ODcsODQxNzM5NTkyLDUwNDQ1OTQzNiwxODE3ODY2ODMwLDQyNDU2MTg2ODMsMjYwMzg4OTUwLDEwMzQ4Njc5OTgsOTA4OTMzNDE1LDE2ODgxMDg1MiwxNzUwOTAyMzA1LDI2MDY0NTM5NjksNjA3NTMwNTU0LDIwMjAwODQ5NywyNDcyMDExNTM1LDMwMzU1MzUwNTgsNDYzMTgwMTkwLDIxNjAxMTcwNzEsMTY0MTgxNjIyNiwxNTE3NzY3NTI5LDQ3MDk0ODM3NCwzODAxMzMyMjM0LDMyMzE3MjIyMTMsMTAwODkxODU5NSwzMDM3NjUyNzcsMjM1NDc0MTg3LDQwNjkyNDY4OTMsNzY2OTQ1NDY1LDMzNzU1Mzg2NCwxNDc1NDE4NTAxLDI5NDM2ODIzODAsNDAwMzA2MTE3OSwyNzQzMDM0MTA5LDQxNDQwNDc3NzUsMTU1MTAzNzg4NCwxMTQ3NTUwNjYxLDE1NDMyMDg1MDAsMjMzNjQzNDU1MCwzNDA4MTE5NTE2LDMwNjkwNDk5NjAsMzEwMjAxMTc0NywzNjEwMzY5MjI2LDExMTM4MTgzODQsMzI4NjcxODA4LDIyMjc1NzMwMjQsMjIzNjIyODczMywzNTM1NDg2NDU2LDI5MzU1NjY4NjUsMzM0MTM5NDI4NSw0OTY5MDYwNTksMzcwMjY2NTQ1OSwyMjY5MDY4NjAsMjAwOTE5NTQ3Miw3MzMxNTY5NzIsMjg0MjczNzA0OSwyOTQ5MzA2ODIsMTIwNjQ3Nzg1OCwyODM1MTIzMzk2LDI3MDAwOTkzNTQsMTQ1MTA0NDA1Niw1NzM4MDQ3ODMsMjI2OTcyODQ1NSwzNjQ0Mzc5NTg1LDIzNjIwOTAyMzgsMjU2NDAzMzMzNCwyODAxMTA3NDA3LDI3NzYyOTI5MDQsMzY2OTQ2MjU2NiwxMDY4MzUxMzk2LDc0MjAzOTAxMiwxMzUwMDc4OTg5LDE3ODQ2NjMxOTUsMTQxNzU2MTY5OCw0MTM2NDQwNzcwLDI0MzAxMjIyMTYsNzc1NTUwODE0LDIxOTM4NjI2NDUsMjY3MzcwNTE1MCwxNzc1Mjc2OTI0LDE4NzYyNDE4MzMsMzQ3NTMxMzMzMSwzMzY2NzU0NjE5LDI3MDA0MDQ4NywzOTAyNTYzMTgyLDM2NzgxMjQ5MjMsMzQ0MTg1MDM3NywxODUxMzMyODUyLDM5Njk1NjIzNjksMjIwMzAzMjIzMiwzODY4NTUyODA1LDI4Njg4OTc0MDYsNTY2MDIxODk2LDQwMTExOTA1MDIsMzEzNTc0MDg4OSwxMjQ4ODAyNTEwLDM5MzYyOTEyODQsNjk5NDMyMTUwLDgzMjg3NzIzMSw3MDg3ODA4NDksMzMzMjc0MDE0NCw4OTk4MzU1ODQsMTk1MTMxNzA0Nyw0MjM2NDI5OTkwLDM3Njc1ODY5OTIsODY2NjM3ODQ1LDQwNDM2MTAxODYsMTEwNjA0MTU5MSwyMTQ0MTYxODA2LDM5NTQ0MTcxMSwxOTg0ODEyNjg1LDExMzk3ODE3MDksMzQzMzcxMjk4MCwzODM1MDM2ODk1LDI2NjQ1NDM3MTUsMTI4MjA1MDA3NSwzMjQwODk0MzkyLDExODEwNDUxMTksMjY0MDI0MzIwNCwyNTk2NTkxNyw0MjAzMTgxMTcxLDQyMTE4MTg3OTgsMzAwOTg3OTM4NiwyNDYzODc5NzYyLDM5MTAxNjE5NzEsMTg0Mjc1OTQ0MywyNTk3ODA2NDc2LDkzMzMwMTM3MCwxNTA5NDMwNDE0LDM5NDM5MDY0NDEsMzQ2NzE5MjMwMiwzMDc2NjM5MDI5LDM3NzY3Njc0NjksMjA1MTUxODc4MCwyNjMxMDY1NDMzLDE0NDE5NTI1NzUsNDA0MDE2NzYxLDE5NDI0MzU3NzUsMTQwODc0OTAzNCwxNjEwNDU5NzM5LDM3NDUzNDUzMDAsMjAxNzc3ODU2NiwzNDAwNTI4NzY5LDMxMTA2NTA5NDIsOTQxODk2NzQ4LDMyNjU0Nzg3NTEsMzcxMDQ5MzMwLDMxNjg5MzcyMjgsNjc1MDM5NjI3LDQyNzkwODAyNTcsOTY3MzExNzI5LDEzNTA1MDIwNiwzNjM1NzMzNjYwLDE2ODM0MDcyNDgsMjA3NjkzNTI2NSwzNTc2ODcwNTEyLDEyMTUwNjExMDgsMzUwMTc0MTg5MF07dmFyIFQ2PVsxMzQ3NTQ4MzI3LDE0MDA3ODMyMDUsMzI3MzI2NzEwOCwyNTIwMzkzNTY2LDM0MDk2ODUzNTUsNDA0NTM4MDkzMywyODgwMjQwMjE2LDI0NzEyMjQwNjcsMTQyODE3MzA1MCw0MTM4NTYzMTgxLDI0NDE2NjE1NTgsNjM2ODEzOTAwLDQyMzMwOTQ2MTUsMzYyMDAyMjk4NywyMTQ5OTg3NjUyLDI0MTEwMjkxNTUsMTIzOTMzMTE2MiwxNzMwNTI1NzIzLDI1NTQ3MTg3MzQsMzc4MTAzMzY2NCw0NjM0NjEwMSwzMTA0NjM3MjgsMjc0Mzk0NDg1NSwzMzI4OTU1Mzg1LDM4NzU3NzAyMDcsMjUwMTIxODk3MiwzOTU1MTkxMTYyLDM2NjcyMTkwMzMsNzY4OTE3MTIzLDM1NDU3ODk0NzMsNjkyNzA3NDMzLDExNTAyMDg0NTYsMTc4NjEwMjQwOSwyMDI5MjkzMTc3LDE4MDUyMTE3MTAsMzcxMDM2ODExMywzMDY1OTYyODMxLDQwMTYzOTU5NywxNzI0NDU3MTMyLDMwMjgxNDM2NzQsNDA5MTk4NDEwLDIxOTYwNTI1MjksMTYyMDUyOTQ1OSwxMTY0MDcxODA3LDM3Njk3MjE5NzUsMjIyNjg3NTMxMCw0ODY0NDEzNzYsMjQ5OTM0ODUyMywxNDgzNzUzNTc2LDQyODgxOTk2NSwyMjc0NjgwNDI4LDMwNzU2MzYyMTYsNTk4NDM4ODY3LDM3OTkxNDExMjIsMTQ3NDUwMjU0Myw3MTEzNDk2NzUsMTI5MTY2MTIwLDUzNDU4MzcwLDI1OTI1MjM2NDMsMjc4MjA4MjgyNCw0MDYzMjQyMzc1LDI5ODg2ODcyNjksMzEyMDY5NDEyMiwxNTU5MDQxNjY2LDczMDUxNzI3NiwyNDYwNDQ5MjA0LDQwNDI0NTkxMjIsMjcwNjI3MDY5MCwzNDQ2MDA0NDY4LDM1NzM5NDE2OTQsNTMzODA0MTMwLDIzMjgxNDM2MTQsMjYzNzQ0MjY0MywyNjk1MDMzNjg1LDgzOTIyNDAzMywxOTczNzQ1Mzg3LDk1NzA1NTk4MCwyODU2MzQ1ODM5LDEwNjg1Mjc2NywxMzcxMzY4OTc2LDQxODE1OTg2MDIsMTAzMzI5NzE1OCwyOTMzNzM0OTE3LDExNzk1MTA0NjEsMzA0NjIwMDQ2MSw5MTM0MTkxNywxODYyNTM0ODY4LDQyODQ1MDIwMzcsNjA1NjU3MzM5LDI1NDc0MzI5MzcsMzQzMTU0Njk0NywyMDAzMjk0NjIyLDMxODI0ODc2MTgsMjI4MjE5NTMzOSw5NTQ2Njk0MDMsMzY4MjE5MTU5OCwxMjAxNzY1Mzg2LDM5MTcyMzQ3MDMsMzM4ODUwNzE2NiwwLDIxOTg0MzgwMjIsMTIxMTI0NzU5NywyODg3NjUxNjk2LDEzMTU3MjM4OTAsNDIyNzY2NTY2MywxNDQzODU3NzIwLDUwNzM1ODkzMyw2NTc4NjE5NDUsMTY3ODM4MTAxNyw1NjA0ODc1OTAsMzUxNjYxOTYwNCw5NzU0NTE2OTQsMjk3MDM1NjMyNywyNjEzMTQ1MzUsMzUzNTA3MjkxOCwyNjUyNjA5NDI1LDEzMzM4MzgwMjEsMjcyNDMyMjMzNiwxNzY3NTM2NDU5LDM3MDkzODM5NCwxODI2MjExMTQsMzg1NDYwNjM3OCwxMTI4MDE0NTYwLDQ4NzcyNTg0NywxODU0NjkxOTcsMjkxODM1Mzg2MywzMTA2NzgwODQwLDMzNTY3NjE3NjksMjIzNzEzMzA4MSwxMjg2NTY3MTc1LDMxNTI5NzYzNDksNDI1NTM1MDYyNCwyNjgzNzY1MDMwLDMxNjAxNzUzNDksMzMwOTU5NDE3MSw4Nzg0NDMzOTAsMTk4ODgzODE4NSwzNzA0MzAwNDg2LDE3NTY4MTg5NDAsMTY3MzA2MTYxNywzNDAzMTAwNjM2LDI3Mjc4NjMwOSwxMDc1MDI1Njk4LDU0NTU3MjM2OSwyMTA1ODg3MjY4LDQxNzQ1NjAwNjEsMjk2Njc5NzMwLDE4NDE3Njg4NjUsMTI2MDIzMjIzOSw0MDkxMzI3MDI0LDM5NjAzMDkzMzAsMzQ5NzUwOTM0NywxODE0ODAzMjIyLDI1NzgwMTg0ODksNDE5NTQ1NjA3Miw1NzUxMzgxNDgsMzI5OTQwOTAzNiw0NDY3NTQ4NzksMzYyOTU0Njc5Niw0MDExOTk2MDQ4LDMzNDc1MzIxMTAsMzI1MjIzODU0NSw0MjcwNjM5Nzc4LDkxNTk4NTQxOSwzNDgzODI1NTM3LDY4MTkzMzUzNCw2NTE4NjgwNDYsMjc1NTYzNjY3MSwzODI4MTAzODM3LDIyMzM3NzU1NCwyNjA3NDM5ODIwLDE2NDk3MDQ1MTgsMzI3MDkzNzg3NSwzOTAxODA2Nzc2LDE1ODAwODc3OTksNDExODk4NzY5NSwzMTk4MTE1MjAwLDIwODczMDk0NTksMjg0MjY3ODU3MywzMDE2Njk3MTA2LDEwMDMwMDcxMjksMjgwMjg0OTkxNywxODYwNzM4MTQ3LDIwNzc5NjUyNDMsMTY0NDM5NjcyLDQxMDA4NzI0NzIsMzIyODMzMTksMjgyNzE3Nzg4MiwxNzA5NjEwMzUwLDIxMjUxMzU4NDYsMTM2NDI4NzUxLDM4NzQ0MjgzOTIsMzY1MjkwNDg1OSwzNDYwOTg0NjMwLDM1NzIxNDU5MjksMzU5MzA1NjM4MCwyOTM5MjY2MjI2LDgyNDg1MjI1OSw4MTgzMjQ4ODQsMzIyNDc0MDQ1NCw5MzAzNjkyMTIsMjgwMTU2NjQxMCwyOTY3NTA3MTUyLDM1NTcwNjg0MCwxMjU3MzA5MzM2LDQxNDgyOTI4MjYsMjQzMjU2NjU2LDc5MDA3Mzg0NiwyMzczMzQwNjMwLDEyOTYyOTc5MDQsMTQyMjY5OTA4NSwzNzU2Mjk5NzgwLDM4MTg4MzY0MDUsNDU3OTkyODQwLDMwOTk2Njc0ODcsMjEzNTMxOTg4OSw3NzQyMjMxNCwxNTYwMzgyNTE3LDE5NDU3OTg1MTYsNzg4MjA0MzUzLDE1MjE3MDY3ODEsMTM4NTM1NjI0Miw4NzA5MTIwODYsMzI1OTY1MzgzLDIzNTg5NTc5MjEsMjA1MDQ2NjA2MCwyMzg4MjYwODg0LDIzMTM4ODQ0NzYsNDAwNjUyMTEyNyw5MDEyMTA1NjksMzk5MDk1MzE4OSwxMDE0NjQ2NzA1LDE1MDM0NDk4MjMsMTA2MjU5NzIzNSwyMDMxNjIxMzI2LDMyMTIwMzU4OTUsMzkzMTM3MTQ2OSwxNTMzMDE3NTE0LDM1MDE3NDU3NSwyMjU2MDI4ODkxLDIxNzc1NDQxNzksMTA1MjMzODM3Miw3NDE4NzY3ODgsMTYwNjU5MTI5NiwxOTE0MDUyMDM1LDIxMzcwNTI1MywyMzM0NjY5ODk3LDExMDcyMzQxOTcsMTg5OTYwMzk2OSwzNzI1MDY5NDkxLDI2MzE0NDc3ODAsMjQyMjQ5NDkxMywxNjM1NTAyOTgwLDE4OTMwMjAzNDIsMTk1MDkwMzM4OCwxMTIwOTc0OTM1XTt2YXIgVDc9WzI4MDcwNTg5MzIsMTY5OTk3MDYyNSwyNzY0MjQ5NjIzLDE1ODY5MDM1OTEsMTgwODQ4MTE5NSwxMTczNDMwMTczLDE0ODc2NDU5NDYsNTk5ODQ4NjcsNDE5OTg4MjgwMCwxODQ0ODgyODA2LDE5ODkyNDkyMjgsMTI3NzU1NTk3MCwzNjIzNjM2OTY1LDM0MTk5MTU1NjIsMTE0OTI0OTA3NywyNzQ0MTA0MjkwLDE1MTQ3OTA1NzcsNDU5NzQ0Njk4LDI0NDg2MDM5NCwzMjM1OTk1MTM0LDE5NjMxMTUzMTEsNDAyNzc0NDU4OCwyNTQ0MDc4MTUwLDQxOTA1MzA1MTUsMTYwODk3NTI0NywyNjI3MDE2MDgyLDIwNjIyNzAzMTcsMTUwNzQ5NzI5OCwyMjAwODE4ODc4LDU2NzQ5ODg2OCwxNzY0MzEzNTY4LDMzNTk5MzYyMDEsMjMwNTQ1NTU1NCwyMDM3OTcwMDYyLDEwNDcyMzllMywxOTEwMzE5MDMzLDEzMzczNzY0ODEsMjkwNDAyNzI3MiwyODkyNDE3MzEyLDk4NDkwNzIxNCwxMjQzMTEyNDE1LDgzMDY2MTkxNCw4NjE5NjgyMDksMjEzNTI1MzU4NywyMDExMjE0MTgwLDI5Mjc5MzQzMTUsMjY4NjI1NDcyMSw3MzExODMzNjgsMTc1MDYyNjM3Niw0MjQ2MzEwNzI1LDE4MjA4MjQ3OTgsNDE3Mjc2Mzc3MSwzNTQyMzMwMjI3LDQ4Mzk0ODI3LDI0MDQ5MDE2NjMsMjg3MTY4MjY0NSw2NzE1OTMxOTUsMzI1NDk4ODcyNSwyMDczNzI0NjEzLDE0NTA4NTIzOSwyMjgwNzk2MjAwLDI3Nzk5MTUxOTksMTc5MDU3NTEwNywyMTg3MTI4MDg2LDQ3MjYxNTYzMSwzMDI5NTEwMDA5LDQwNzU4NzcxMjcsMzgwMjIyMjE4NSw0MTA3MTAxNjU4LDMyMDE2MzE3NDksMTY0NjI1MjM0MCw0MjcwNTA3MTc0LDE0MDI4MTE0MzgsMTQzNjU5MDgzNSwzNzc4MTUxODE4LDM5NTAzNTU3MDIsMzk2MzE2MTQ3NSw0MDIwOTEyMjI0LDI2Njc5OTQ3MzcsMjczNzkyMzY2LDIzMzE1OTAxNzcsMTA0Njk5NjEzLDk1MzQ1OTgyLDMxNzU1MDEyODYsMjM3NzQ4NjY3NiwxNTYwNjM3ODkyLDM1NjQwNDUzMTgsMzY5MDU3ODcyLDQyMTM0NDcwNjQsMzkxOTA0MjIzNywxMTM3NDc3OTUyLDI2NTg2MjU0OTcsMTExOTcyNzg0OCwyMzQwOTQ3ODQ5LDE1MzA0NTU4MzMsNDAwNzM2MDk2OCwxNzI0NjY1NTYsMjY2OTU5OTM4LDUxNjU1MjgzNiwwLDIyNTY3MzQ1OTIsMzk4MDkzMTYyNywxODkwMzI4MDgxLDE5MTc3NDIxNzAsNDI5NDcwNDM5OCw5NDUxNjQxNjUsMzU3NTUyODg3OCw5NTg4NzEwODUsMzY0NzIxMjA0NywyNzg3MjA3MjYwLDE0MjMwMjI5MzksNzc1NTYyMjk0LDE3Mzk2NTYyMDIsMzg3NjU1NzY1NSwyNTMwMzkxMjc4LDI0NDMwNTgwNzUsMzMxMDMyMTg1Niw1NDc1MTI3OTYsMTI2NTE5NTYzOSw0Mzc2NTY1OTQsMzEyMTI3NTUzOSw3MTk3MDAxMjgsMzc2MjUwMjY5MCwzODc3ODExNDcsMjE4ODI4Mjk3LDMzNTAwNjU4MDMsMjgzMDcwODE1MCwyODQ4NDYxODU0LDQyODE2OTIwMSwxMjI0NjYxNjUsMzcyMDA4MTA0OSwxNjI3MjM1MTk5LDY0ODAxNzY2NSw0MTIyNzYyMzU0LDEwMDI3ODM4NDYsMjExNzM2MDYzNSw2OTU2MzQ3NTUsMzMzNjM1ODY5MSw0MjM0NzIxMDA1LDQwNDk4NDQ0NTIsMzcwNDI4MDg4MSwyMjMyNDM1Mjk5LDU3NDYyNDY2MywyODczNDM4MTQsNjEyMjA1ODk4LDEwMzk3MTcwNTEsODQwMDE5NzA1LDI3MDgzMjYxODUsNzkzNDUxOTM0LDgyMTI4ODExNCwxMzkxMjAxNjcwLDM4MjIwOTAxNzcsMzc2MTg3ODI3LDMxMTM4NTUzNDQsMTIyNDM0ODA1MiwxNjc5OTY4MjMzLDIzNjE2OTg1NTYsMTA1ODcwOTc0NCw3NTIzNzU0MjEsMjQzMTU5MDk2MywxMzIxNjk5MTQ1LDM1MTkxNDIyMDAsMjczNDU5MTE3OCwxODgxMjc0NDQsMjE3Nzg2OTU1NywzNzI3MjA1NzU0LDIzODQ5MTEwMzEsMzIxNTIxMjQ2MSwyNjQ4OTc2NDQyLDI0NTAzNDYxMDQsMzQzMjczNzM3NSwxMTgwODQ5Mjc4LDMzMTU0NDIwNSwzMTAyMjQ5MTc2LDQxNTAxNDQ1NjksMjk1MjEwMjU5NSwyMTU5OTc2Mjg1LDI0NzQ0MDQzMDQsNzY2MDc4OTMzLDMxMzc3Mzg2MSwyNTcwODMyMDQ0LDIxMDgxMDA2MzIsMTY2ODIxMjg5MiwzMTQ1NDU2NDQzLDIwMTM5MDgyNjIsNDE4NjcyMjE3LDMwNzAzNTY2MzQsMjU5NDczNDkyNywxODUyMTcxOTI1LDM4NjcwNjA5OTEsMzQ3MzQxNjYzNiwzOTA3NDQ4NTk3LDI2MTQ3Mzc2MzksOTE5NDg5MTM1LDE2NDk0ODYzOSwyMDk0NDEwMTYwLDI5OTc4MjU5NTYsNTkwNDI0NjM5LDI0ODYyMjQ1NDksMTcyMzg3MjY3NCwzMTU3NzUwODYyLDMzOTk5NDEyNTAsMzUwMTI1Mjc1MiwzNjI1MjY4MTM1LDI1NTUwNDgxOTYsMzY3MzYzNzM1NiwxMzQzMTI3NTAxLDQxMzAyODEzNjEsMzU5OTU5NTA4NSwyOTU3ODUzNjc5LDEyOTc0MDMwNTAsODE3ODE5MTAsMzA1MTU5MzQyNSwyMjgzNDkwNDEwLDUzMjIwMTc3MiwxMzY3Mjk1NTg5LDM5MjYxNzA5NzQsODk1Mjg3NjkyLDE5NTM3NTc4MzEsMTA5MzU5Nzk2Myw0OTI0ODM0MzEsMzUyODYyNjkwNywxNDQ2MjQyNTc2LDExOTI0NTU2MzgsMTYzNjYwNDYzMSwyMDkzMzYyMjUsMzQ0ODczNDY0LDEwMTU2NzE1NzEsNjY5OTYxODk3LDMzNzU3NDA3NjksMzg1NzU3MjEyNCwyOTczNTMwNjk1LDM3NDcxOTIwMTgsMTkzMzUzMDYxMCwzNDY0MDQyNTE2LDkzNTI5Mzg5NSwzNDU0Njg2MTk5LDI4NTgxMTUwNjksMTg2MzYzODg0NSwzNjgzMDIyOTE2LDQwODUzNjk1MTksMzI5MjQ0NTAzMiw4NzUzMTMxODgsMTA4MDAxNzU3MSwzMjc5MDMzODg1LDYyMTU5MTc3OCwxMjMzODU2NTcyLDI1MDQxMzAzMTcsMjQxOTc1NDQsMzAxNzY3MjcxNiwzODM1NDg0MzQwLDMyNDc0NjU1NTgsMjIyMDk4MTE5NSwzMDYwODQ3OTIyLDE1NTExMjQ1ODgsMTQ2Mzk5NjYwMF07dmFyIFQ4PVs0MTA0NjA1Nzc3LDEwOTcxNTk1NTAsMzk2NjczODE4LDY2MDUxMDI2NiwyODc1OTY4MzE1LDI2Mzg2MDY2MjMsNDIwMDExNTExNiwzODA4NjYyMzQ3LDgyMTcxMjE2MCwxOTg2OTE4MDYxLDM0MzAzMjI1NjgsMzg1NDQ4ODUsMzg1NjEzNzI5NSw3MTgwMDIxMTcsODkzNjgxNzAyLDE2NTQ4ODYzMjUsMjk3NTQ4NDM4MiwzMTIyMzU4MDUzLDM5MjY4MjUwMjksNDI3NDA1MzQ2OSw3OTYxOTc1NzEsMTI5MDgwMTc5MywxMTg0MzQyOTI1LDM1NTYzNjE4MzUsMjQwNTQyNjk0NywyNDU5NzM1MzE3LDE4MzY3NzIyODcsMTM4MTYyMDM3MywzMTk2MjY3OTg4LDE5NDgzNzM4NDgsMzc2NDk4ODIzMywzMzg1MzQ1MTY2LDMyNjM3ODU1ODksMjM5MDMyNTQ5MiwxNDgwNDg1Nzg1LDMxMTEyNDcxNDMsMzc4MDA5NzcyNiwyMjkzMDQ1MjMyLDU0ODE2OTQxNywzNDU5OTUzNzg5LDM3NDYxNzUwNzUsNDM5NDUyMzg5LDEzNjIzMjE1NTksMTQwMDg0OTc2MiwxNjg1NTc3OTA1LDE4MDY1OTkzNTUsMjE3NDc1NDA0NiwxMzcwNzM5MTMsMTIxNDc5NzkzNiwxMTc0MjE1MDU1LDM3MzE2NTQ1NDgsMjA3OTg5NzQyNiwxOTQzMjE3MDY3LDEyNTg0ODAyNDIsNTI5NDg3ODQzLDE0MzcyODA4NzAsMzk0NTI2OTE3MCwzMDQ5MzkwODk1LDMzMTMyMTIwMzgsOTIzMzEzNjE5LDY3OTk5OGUzLDMyMTUzMDcyOTksNTczMjYwODIsMzc3NjQyMjIxLDM0NzQ3Mjk4NjYsMjA0MTg3NzE1OSwxMzMzNjE5MDcsMTc3NjQ2MDExMCwzNjczNDc2NDUzLDk2MzkyNDU0LDg3ODg0NTkwNSwyODAxNjk5NTI0LDc3NzIzMTY2OCw0MDgyNDc1MTcwLDIzMzAwMTQyMTMsNDE0MjYyNjIxMiwyMjEzMjk2Mzk1LDE2MjYzMTk0MjQsMTkwNjI0NzI2MiwxODQ2NTYzMjYxLDU2Mjc1NTkwMiwzNzA4MTczNzE4LDEwNDA1NTk4MzcsMzg3MTE2Mzk4MSwxNDE4NTczMjAxLDMyOTQ0MzA1NzcsMTE0NTg1MzQ4LDEzNDM2MTg5MTIsMjU2NjU5NTYwOSwzMTg2MjAyNTgyLDEwNzgxODUwOTcsMzY1MTA0MTEyNywzODk2Njg4MDQ4LDIzMDc2MjI5MTksNDI1NDA4NzQzLDMzNzEwOTY5NTMsMjA4MTA0ODQ4MSwxMTA4MzM5MDY4LDIyMTY2MTAyOTYsMCwyMTU2Mjk5MDE3LDczNjk3MDgwMiwyOTI1OTY3NjYsMTUxNzQ0MDYyMCwyNTE2NTcyMTMsMjIzNTA2MTc3NSwyOTMzMjAyNDkzLDc1ODcyMDMxMCwyNjU5MDUxNjIsMTU1NDM5MTQwMCwxNTMyMjg1MzM5LDkwODk5OTIwNCwxNzQ1Njc2OTIsMTQ3NDc2MDU5NSw0MDAyODYxNzQ4LDI2MTAwMTE2NzUsMzIzNDE1NjQxNiwzNjkzMTI2MjQxLDIwMDE0MzA4NzQsMzAzNjk5NDg0LDI0Nzg0NDMyMzQsMjY4NzE2NTg4OCw1ODUxMjI2MjAsNDU0NDk5NjAyLDE1MTg0OTc0MiwyMzQ1MTE5MjE4LDMwNjQ1MTA3NjUsNTE0NDQzMjg0LDQwNDQ5ODE1OTEsMTk2MzQxMjY1NSwyNTgxNDQ1NjE0LDIxMzcwNjI4MTksMTkzMDg1MzUsMTkyODcwNzE2NCwxNzE1MTkzMTU2LDQyMTkzNTIxNTUsMTEyNjc5MDc5NSw2MDAyMzUyMTEsMzk5Mjc0MjA3MCwzODQxMDI0OTUyLDgzNjU1MzQzMSwxNjY5NjY0ODM0LDI1MzU2MDQyNDMsMzMyMzAxMTIwNCwxMjQzOTA1NDEzLDMxNDE0MDA3ODYsNDE4MDgwODExMCw2OTg0NDUyNTUsMjY1Mzg5OTU0OSwyOTg5NTUyNjA0LDIyNTM1ODEzMjUsMzI1MjkzMjcyNywzMDA0NTkxMTQ3LDE4OTEyMTE2ODksMjQ4NzgxMDU3NywzOTE1NjUzNzAzLDQyMzcwODM4MTYsNDAzMDY2NzQyNCwyMTAwMDkwOTY2LDg2NTEzNjQxOCwxMjI5ODk5NjU1LDk1MzI3MDc0NSwzMzk5Njc5NjI4LDM1NTc1MDQ2NjQsNDExODkyNTIyMiwyMDYxMzc5NzQ5LDMwNzk1NDY1ODYsMjkxNTAxNzc5MSw5ODM0MjYwOTIsMjAyMjgzNzU4NCwxNjA3MjQ0NjUwLDIxMTg1NDE5MDgsMjM2Njg4MjU1MCwzNjM1OTk2ODE2LDk3MjUxMjgxNCwzMjgzMDg4NzcwLDE1Njg3MTg0OTUsMzQ5OTMyNjU2OSwzNTc2NTM5NTAzLDYyMTk4MjY3MSwyODk1NzIzNDY0LDQxMDg4Nzk1MiwyNjIzNzYyMTUyLDEwMDIxNDI2ODMsNjQ1NDAxMDM3LDE0OTQ4MDc2NjIsMjU5NTY4NDg0NCwxMzM1NTM1NzQ3LDI1MDcwNDAyMzAsNDI5MzI5NTc4NiwzMTY3Njg0NjQxLDM2NzU4NTAwNywzODg1NzUwNzE0LDE4NjU4NjI3MzAsMjY2ODIyMTY3NCwyOTYwOTcxMzA1LDI3NjMxNzM2ODEsMTA1OTI3MDk1NCwyNzc3OTUyNDU0LDI3MjQ2NDI4NjksMTMyMDk1NzgxMiwyMTk0MzE5MTAwLDI0Mjk1OTU4NzIsMjgxNTk1NjI3NSw3NzA4OTUyMSwzOTczNzczMTIxLDM0NDQ1NzU4NzEsMjQ0ODgzMDIzMSwxMzA1OTA2NTUwLDQwMjEzMDg3MzksMjg1NzE5NDcwMCwyNTE2OTAxODYwLDM1MTgzNTg0MzAsMTc4NzMwNDc4MCw3NDAyNzY0MTcsMTY5OTgzOTgxNCwxNTkyMzk0OTA5LDIzNTIzMDc0NTcsMjI3MjU1NjAyNiwxODg4MjEyNDMsMTcyOTk3NzAxMSwzNjg3OTk0MDAyLDI3NDA4NDg0MSwzNTk0OTgyMjUzLDM2MTM0OTQ0MjYsMjcwMTk0OTQ5NSw0MTYyMDk2NzI5LDMyMjczNDU3MSwyODM3OTY2NTQyLDE2NDA1NzY0MzksNDg0ODMwNjg5LDEyMDI3OTc2OTAsMzUzNzg1MjgyOCw0MDY3NjM5MTI1LDM0OTA3NTczNiwzMzQyMzE5NDc1LDQxNTc0NjcyMTksNDI1NTgwMDE1OSwxMDMwNjkwMDE1LDExNTUyMzc0OTYsMjk1MTk3MTI3NCwxNzU3NjkxNTc3LDYwNzM5ODk2OCwyNzM4OTA1MDI2LDQ5OTM0Nzk5MCwzNzk0MDc4OTA4LDEwMTE0NTI3MTIsMjI3ODg1NTY3LDI4MTg2NjY4MDksMjEzMTE0Mzc2LDMwMzQ4ODEyNDAsMTQ1NTUyNTk4OCwzNDE0NDUwNTU1LDg1MDgxNzIzNywxODE3OTk4NDA4LDMwOTI3MjY0ODBdO3ZhciBVMT1bMCwyMzU0NzQxODcsNDcwOTQ4Mzc0LDMwMzc2NTI3Nyw5NDE4OTY3NDgsOTA4OTMzNDE1LDYwNzUzMDU1NCw3MDg3ODA4NDksMTg4Mzc5MzQ5NiwyMTE4MjE0OTk1LDE4MTc4NjY4MzAsMTY0OTYzOTIzNywxMjE1MDYxMTA4LDExODEwNDUxMTksMTQxNzU2MTY5OCwxNTE3NzY3NTI5LDM3Njc1ODY5OTIsNDAwMzA2MTE3OSw0MjM2NDI5OTkwLDQwNjkyNDY4OTMsMzYzNTczMzY2MCwzNjAyNzcwMzI3LDMyOTkyNzg0NzQsMzQwMDUyODc2OSwyNDMwMTIyMjE2LDI2NjQ1NDM3MTUsMjM2MjA5MDIzOCwyMTkzODYyNjQ1LDI4MzUxMjMzOTYsMjgwMTEwNzQwNywzMDM1NTM1MDU4LDMxMzU3NDA4ODksMzY3ODEyNDkyMywzNTc2ODcwNTEyLDMzNDEzOTQyODUsMzM3NDM2MTcwMiwzODEwNDk2MzQzLDM5Nzc2NzUzNTYsNDI3OTA4MDI1Nyw0MDQzNjEwMTg2LDI4NzY0OTQ2MjcsMjc3NjI5MjkwNCwzMDc2NjM5MDI5LDMxMTA2NTA5NDIsMjQ3MjAxMTUzNSwyNjQwMjQzMjA0LDI0MDM3Mjg2NjUsMjE2OTMwMzA1OCwxMDAxMDg5OTk1LDg5OTgzNTU4NCw2NjY0NjQ3MzMsNjk5NDMyMTUwLDU5NzI3ODQ3LDIyNjkwNjg2MCw1MzA0MDA3NTMsMjk0OTMwNjgyLDEyNzMxNjg3ODcsMTE3Mjk2NzA2NCwxNDc1NDE4NTAxLDE1MDk0MzA0MTQsMTk0MjQzNTc3NSwyMTEwNjY3NDQ0LDE4NzYyNDE4MzMsMTY0MTgxNjIyNiwyOTEwMjE5NzY2LDI3NDMwMzQxMDksMjk3NjE1MTUyMCwzMjExNjIzMTQ3LDI1MDUyMDIxMzgsMjYwNjQ1Mzk2OSwyMzAyNjkwMjUyLDIyNjk3Mjg0NTUsMzcxMTgyOTQyMiwzNTQzNTk5MjY5LDMyNDA4OTQzOTIsMzQ3NTMxMzMzMSwzODQzNjk5MDc0LDM5NDM5MDY0NDEsNDE3ODA2MjIyOCw0MTQ0MDQ3Nzc1LDEzMDY5NjczNjYsMTEzOTc4MTcwOSwxMzc0OTg4MTEyLDE2MTA0NTk3MzksMTk3NTY4MzQzNCwyMDc2OTM1MjY1LDE3NzUyNzY5MjQsMTc0MjMxNTEyNywxMDM0ODY3OTk4LDg2NjYzNzg0NSw1NjYwMjE4OTYsODAwNDQwODM1LDkyOTg3Njk4LDE5MzE5NTA2NSw0Mjk0NTYxNjQsMzk1NDQxNzExLDE5ODQ4MTI2ODUsMjAxNzc3ODU2NiwxNzg0NjYzMTk1LDE2ODM0MDcyNDgsMTMxNTU2MjE0NSwxMDgwMDk0NjM0LDEzODM4NTYzMTEsMTU1MTAzNzg4NCwxMDEwMzk4MjksMTM1MDUwMjA2LDQzNzc1NzEyMywzMzc1NTM4NjQsMTA0MjM4NTY1Nyw4MDc5NjI2MTAsNTczODA0NzgzLDc0MjAzOTAxMiwyNTMxMDY3NDUzLDI1NjQwMzMzMzQsMjMyODgyODk3MSwyMjI3NTczMDI0LDI5MzU1NjY4NjUsMjcwMDA5OTM1NCwzMDAxNzU1NjU1LDMxNjg5MzcyMjgsMzg2ODU1MjgwNSwzOTAyNTYzMTgyLDQyMDMxODExNzEsNDEwMjk3NzkxMiwzNzM2MTY0OTM3LDM1MDE3NDE4OTAsMzI2NTQ3ODc1MSwzNDMzNzEyOTgwLDExMDYwNDE1OTEsMTM0MDQ2MzEwMCwxNTc2OTc2NjA5LDE0MDg3NDkwMzQsMjA0MzIxMTQ4MywyMDA5MTk1NDcyLDE3MDg4NDgzMzMsMTgwOTA1NDE1MCw4MzI4NzcyMzEsMTA2ODM1MTM5Niw3NjY5NDU0NjUsNTk5NzYyMzU0LDE1OTQxNzk4NywxMjY0NTQ2NjQsMzYxOTI5ODc3LDQ2MzE4MDE5MCwyNzA5MjYwODcxLDI5NDM2ODIzODAsMzE3ODEwNjk2MSwzMDA5ODc5Mzg2LDI1NzI2OTcxOTUsMjUzODY4MTE4NCwyMjM2MjI4NzMzLDIzMzY0MzQ1NTAsMzUwOTg3MTEzNSwzNzQ1MzQ1MzAwLDM0NDE4NTAzNzcsMzI3NDY2NzI2NiwzOTEwMTYxOTcxLDM4NzcxOTg2NDgsNDExMDU2ODQ4NSw0MjExODE4Nzk4LDI1OTc4MDY0NzYsMjQ5NzYwNDc0MywyMjYxMDg5MTc4LDIyOTUxMDEwNzMsMjczMzg1NjE2MCwyOTAyMDg3ODUxLDMyMDI0MzcwNDYsMjk2ODAxMTQ1MywzOTM2MjkxMjg0LDM4MzUwMzY4OTUsNDEzNjQ0MDc3MCw0MTY5NDA4MjAxLDM1MzU0ODY0NTYsMzcwMjY2NTQ1OSwzNDY3MTkyMzAyLDMyMzE3MjIyMTMsMjA1MTUxODc4MCwxOTUxMzE3MDQ3LDE3MTY4OTA0MTAsMTc1MDkwMjMwNSwxMTEzODE4Mzg0LDEyODIwNTAwNzUsMTU4NDUwNDU4MiwxMzUwMDc4OTg5LDE2ODgxMDg1Miw2NzU1NjQ2MywzNzEwNDkzMzAsNDA0MDE2NzYxLDg0MTczOTU5MiwxMDA4OTE4NTk1LDc3NTU1MDgxNCw1NDAwODA3MjUsMzk2OTU2MjM2OSwzODAxMzMyMjM0LDQwMzU0ODkwNDcsNDI2OTkwNzk5NiwzNTY5MjU1MjEzLDM2Njk0NjI1NjYsMzM2Njc1NDYxOSwzMzMyNzQwMTQ0LDI2MzEwNjU0MzMsMjQ2Mzg3OTc2MiwyMTYwMTE3MDcxLDIzOTU1ODg2NzYsMjc2NzY0NTU1NywyODY4ODk3NDA2LDMxMDIwMTE3NDcsMzA2OTA0OTk2MCwyMDIwMDg0OTcsMzM3NzgzNjIsMjcwMDQwNDg3LDUwNDQ1OTQzNiw4NzU0NTEyOTMsOTc1NjU4NjQ2LDY3NTAzOTYyNyw2NDEwMjUxNTIsMjA4NDcwNDIzMywxOTE3NTE4NTYyLDE2MTU4NjEyNDcsMTg1MTMzMjg1MiwxMTQ3NTUwNjYxLDEyNDg4MDI1MTAsMTQ4NDAwNTg0MywxNDUxMDQ0MDU2LDkzMzMwMTM3MCw5NjczMTE3MjksNzMzMTU2OTcyLDYzMjk1MzcwMywyNjAzODg5NTAsMjU5NjU5MTcsMzI4NjcxODA4LDQ5NjkwNjA1OSwxMjA2NDc3ODU4LDEyMzk0NDM3NTMsMTU0MzIwODUwMCwxNDQxOTUyNTc1LDIxNDQxNjE4MDYsMTkwODY5NDI3NywxNjc1NTc3ODgwLDE4NDI3NTk0NDMsMzYxMDM2OTIyNiwzNjQ0Mzc5NTg1LDM0MDgxMTk1MTYsMzMwNzkxNjI0Nyw0MDExMTkwNTAyLDM3NzY3Njc0NjksNDA3NzM4NDQzMiw0MjQ1NjE4NjgzLDI4MDk3NzExNTQsMjg0MjczNzA0OSwzMTQ0Mzk2NDIwLDMwNDMxNDA0OTUsMjY3MzcwNTE1MCwyNDM4MjM3NjIxLDIyMDMwMzIyMzIsMjM3MDIxMzc5NV07dmFyIFUyPVswLDE4NTQ2OTE5NywzNzA5MzgzOTQsNDg3NzI1ODQ3LDc0MTg3Njc4OCw2NTc4NjE5NDUsOTc1NDUxNjk0LDgyNDg1MjI1OSwxNDgzNzUzNTc2LDE0MDA3ODMyMDUsMTMxNTcyMzg5MCwxMTY0MDcxODA3LDE5NTA5MDMzODgsMjEzNTMxOTg4OSwxNjQ5NzA0NTE4LDE3Njc1MzY0NTksMjk2NzUwNzE1MiwzMTUyOTc2MzQ5LDI4MDE1NjY0MTAsMjkxODM1Mzg2MywyNjMxNDQ3NzgwLDI1NDc0MzI5MzcsMjMyODE0MzYxNCwyMTc3NTQ0MTc5LDM5MDE4MDY3NzYsMzgxODgzNjQwNSw0MjcwNjM5Nzc4LDQxMTg5ODc2OTUsMzI5OTQwOTAzNiwzNDgzODI1NTM3LDM1MzUwNzI5MTgsMzY1MjkwNDg1OSwyMDc3OTY1MjQzLDE4OTMwMjAzNDIsMTg0MTc2ODg2NSwxNzI0NDU3MTMyLDE0NzQ1MDI1NDMsMTU1OTA0MTY2NiwxMTA3MjM0MTk3LDEyNTczMDkzMzYsNTk4NDM4ODY3LDY4MTkzMzUzNCw5MDEyMTA1NjksMTA1MjMzODM3MiwyNjEzMTQ1MzUsNzc0MjIzMTQsNDI4ODE5OTY1LDMxMDQ2MzcyOCwzNDA5Njg1MzU1LDMyMjQ3NDA0NTQsMzcxMDM2ODExMywzNTkzMDU2MzgwLDM4NzU3NzAyMDcsMzk2MDMwOTMzMCw0MDQ1MzgwOTMzLDQxOTU0NTYwNzIsMjQ3MTIyNDA2NywyNTU0NzE4NzM0LDIyMzcxMzMwODEsMjM4ODI2MDg4NCwzMjEyMDM1ODk1LDMwMjgxNDM2NzQsMjg0MjY3ODU3MywyNzI0MzIyMzM2LDQxMzg1NjMxODEsNDI1NTM1MDYyNCwzNzY5NzIxOTc1LDM5NTUxOTExNjIsMzY2NzIxOTAzMywzNTE2NjE5NjA0LDM0MzE1NDY5NDcsMzM0NzUzMjExMCwyOTMzNzM0OTE3LDI3ODIwODI4MjQsMzA5OTY2NzQ4NywzMDE2Njk3MTA2LDIxOTYwNTI1MjksMjMxMzg4NDQ3NiwyNDk5MzQ4NTIzLDI2ODM3NjUwMzAsMTE3OTUxMDQ2MSwxMjk2Mjk3OTA0LDEzNDc1NDgzMjcsMTUzMzAxNzUxNCwxNzg2MTAyNDA5LDE2MzU1MDI5ODAsMjA4NzMwOTQ1OSwyMDAzMjk0NjIyLDUwNzM1ODkzMywzNTU3MDY4NDAsMTM2NDI4NzUxLDUzNDU4MzcwLDgzOTIyNDAzMyw5NTcwNTU5ODAsNjA1NjU3MzM5LDc5MDA3Mzg0NiwyMzczMzQwNjMwLDIyNTYwMjg4OTEsMjYwNzQzOTgyMCwyNDIyNDk0OTEzLDI3MDYyNzA2OTAsMjg1NjM0NTgzOSwzMDc1NjM2MjE2LDMxNjAxNzUzNDksMzU3Mzk0MTY5NCwzNzI1MDY5NDkxLDMyNzMyNjcxMDgsMzM1Njc2MTc2OSw0MTgxNTk4NjAyLDQwNjMyNDIzNzUsNDAxMTk5NjA0OCwzODI4MTAzODM3LDEwMzMyOTcxNTgsOTE1OTg1NDE5LDczMDUxNzI3Niw1NDU1NzIzNjksMjk2Njc5NzMwLDQ0Njc1NDg3OSwxMjkxNjYxMjAsMjEzNzA1MjUzLDE3MDk2MTAzNTAsMTg2MDczODE0NywxOTQ1Nzk4NTE2LDIwMjkyOTMxNzcsMTIzOTMzMTE2MiwxMTIwOTc0OTM1LDE2MDY1OTEyOTYsMTQyMjY5OTA4NSw0MTQ4MjkyODI2LDQyMzMwOTQ2MTUsMzc4MTAzMzY2NCwzOTMxMzcxNDY5LDM2ODIxOTE1OTgsMzQ5NzUwOTM0NywzNDQ2MDA0NDY4LDMzMjg5NTUzODUsMjkzOTI2NjIyNiwyNzU1NjM2NjcxLDMxMDY3ODA4NDAsMjk4ODY4NzI2OSwyMTk4NDM4MDIyLDIyODIxOTUzMzksMjUwMTIxODk3MiwyNjUyNjA5NDI1LDEyMDE3NjUzODYsMTI4NjU2NzE3NSwxMzcxMzY4OTc2LDE1MjE3MDY3ODEsMTgwNTIxMTcxMCwxNjIwNTI5NDU5LDIxMDU4ODcyNjgsMTk4ODgzODE4NSw1MzM4MDQxMzAsMzUwMTc0NTc1LDE2NDQzOTY3Miw0NjM0NjEwMSw4NzA5MTIwODYsOTU0NjY5NDAzLDYzNjgxMzkwMCw3ODgyMDQzNTMsMjM1ODk1NzkyMSwyMjc0NjgwNDI4LDI1OTI1MjM2NDMsMjQ0MTY2MTU1OCwyNjk1MDMzNjg1LDI4ODAyNDAyMTYsMzA2NTk2MjgzMSwzMTgyNDg3NjE4LDM1NzIxNDU5MjksMzc1NjI5OTc4MCwzMjcwOTM3ODc1LDMzODg1MDcxNjYsNDE3NDU2MDA2MSw0MDkxMzI3MDI0LDQwMDY1MjExMjcsMzg1NDYwNjM3OCwxMDE0NjQ2NzA1LDkzMDM2OTIxMiw3MTEzNDk2NzUsNTYwNDg3NTkwLDI3Mjc4NjMwOSw0NTc5OTI4NDAsMTA2ODUyNzY3LDIyMzM3NzU1NCwxNjc4MzgxMDE3LDE4NjI1MzQ4NjgsMTkxNDA1MjAzNSwyMDMxNjIxMzI2LDEyMTEyNDc1OTcsMTEyODAxNDU2MCwxNTgwMDg3Nzk5LDE0MjgxNzMwNTAsMzIyODMzMTksMTgyNjIxMTE0LDQwMTYzOTU5Nyw0ODY0NDEzNzYsNzY4OTE3MTIzLDY1MTg2ODA0NiwxMDAzMDA3MTI5LDgxODMyNDg4NCwxNTAzNDQ5ODIzLDEzODUzNTYyNDIsMTMzMzgzODAyMSwxMTUwMjA4NDU2LDE5NzM3NDUzODcsMjEyNTEzNTg0NiwxNjczMDYxNjE3LDE3NTY4MTg5NDAsMjk3MDM1NjMyNywzMTIwNjk0MTIyLDI4MDI4NDk5MTcsMjg4NzY1MTY5NiwyNjM3NDQyNjQzLDI1MjAzOTM1NjYsMjMzNDY2OTg5NywyMTQ5OTg3NjUyLDM5MTcyMzQ3MDMsMzc5OTE0MTEyMiw0Mjg0NTAyMDM3LDQxMDA4NzI0NzIsMzMwOTU5NDE3MSwzNDYwOTg0NjMwLDM1NDU3ODk0NzMsMzYyOTU0Njc5NiwyMDUwNDY2MDYwLDE4OTk2MDM5NjksMTgxNDgwMzIyMiwxNzMwNTI1NzIzLDE0NDM4NTc3MjAsMTU2MDM4MjUxNywxMDc1MDI1Njk4LDEyNjAyMzIyMzksNTc1MTM4MTQ4LDY5MjcwNzQzMyw4Nzg0NDMzOTAsMTA2MjU5NzIzNSwyNDMyNTY2NTYsOTEzNDE5MTcsNDA5MTk4NDEwLDMyNTk2NTM4MywzNDAzMTAwNjM2LDMyNTIyMzg1NDUsMzcwNDMwMDQ4NiwzNjIwMDIyOTg3LDM4NzQ0MjgzOTIsMzk5MDk1MzE4OSw0MDQyNDU5MTIyLDQyMjc2NjU2NjMsMjQ2MDQ0OTIwNCwyNTc4MDE4NDg5LDIyMjY4NzUzMTAsMjQxMTAyOTE1NSwzMTk4MTE1MjAwLDMwNDYyMDA0NjEsMjgyNzE3Nzg4MiwyNzQzOTQ0ODU1XTt2YXIgVTM9WzAsMjE4ODI4Mjk3LDQzNzY1NjU5NCwzODc3ODExNDcsODc1MzEzMTg4LDk1ODg3MTA4NSw3NzU1NjIyOTQsNTkwNDI0NjM5LDE3NTA2MjYzNzYsMTY5OTk3MDYyNSwxOTE3NzQyMTcwLDIxMzUyNTM1ODcsMTU1MTEyNDU4OCwxMzY3Mjk1NTg5LDExODA4NDkyNzgsMTI2NTE5NTYzOSwzNTAxMjUyNzUyLDM3MjAwODEwNDksMzM5OTk0MTI1MCwzMzUwMDY1ODAzLDM4MzU0ODQzNDAsMzkxOTA0MjIzNyw0MjcwNTA3MTc0LDQwODUzNjk1MTksMzEwMjI0OTE3NiwzMDUxNTkzNDI1LDI3MzQ1OTExNzgsMjk1MjEwMjU5NSwyMzYxNjk4NTU2LDIxNzc4Njk1NTcsMjUzMDM5MTI3OCwyNjE0NzM3NjM5LDMxNDU0NTY0NDMsMzA2MDg0NzkyMiwyNzA4MzI2MTg1LDI4OTI0MTczMTIsMjQwNDkwMTY2MywyMTg3MTI4MDg2LDI1MDQxMzAzMTcsMjU1NTA0ODE5NiwzNTQyMzMwMjI3LDM3MjcyMDU3NTQsMzM3NTc0MDc2OSwzMjkyNDQ1MDMyLDM4NzY1NTc2NTUsMzkyNjE3MDk3NCw0MjQ2MzEwNzI1LDQwMjc3NDQ1ODgsMTgwODQ4MTE5NSwxNzIzODcyNjc0LDE5MTAzMTkwMzMsMjA5NDQxMDE2MCwxNjA4OTc1MjQ3LDEzOTEyMDE2NzAsMTE3MzQzMDE3MywxMjI0MzQ4MDUyLDU5OTg0ODY3LDI0NDg2MDM5NCw0MjgxNjkyMDEsMzQ0ODczNDY0LDkzNTI5Mzg5NSw5ODQ5MDcyMTQsNzY2MDc4OTMzLDU0NzUxMjc5NiwxODQ0ODgyODA2LDE2MjcyMzUxOTksMjAxMTIxNDE4MCwyMDYyMjcwMzE3LDE1MDc0OTcyOTgsMTQyMzAyMjkzOSwxMTM3NDc3OTUyLDEzMjE2OTkxNDUsOTUzNDU5ODIsMTQ1MDg1MjM5LDUzMjIwMTc3MiwzMTM3NzM4NjEsODMwNjYxOTE0LDEwMTU2NzE1NzEsNzMxMTgzMzY4LDY0ODAxNzY2NSwzMTc1NTAxMjg2LDI5NTc4NTM2NzksMjgwNzA1ODkzMiwyODU4MTE1MDY5LDIzMDU0NTU1NTQsMjIyMDk4MTE5NSwyNDc0NDA0MzA0LDI2NTg2MjU0OTcsMzU3NTUyODg3OCwzNjI1MjY4MTM1LDM0NzM0MTY2MzYsMzI1NDk4ODcyNSwzNzc4MTUxODE4LDM5NjMxNjE0NzUsNDIxMzQ0NzA2NCw0MTMwMjgxMzYxLDM1OTk1OTUwODUsMzY4MzAyMjkxNiwzNDMyNzM3Mzc1LDMyNDc0NjU1NTgsMzgwMjIyMjE4NSw0MDIwOTEyMjI0LDQxNzI3NjM3NzEsNDEyMjc2MjM1NCwzMjAxNjMxNzQ5LDMwMTc2NzI3MTYsMjc2NDI0OTYyMywyODQ4NDYxODU0LDIzMzE1OTAxNzcsMjI4MDc5NjIwMCwyNDMxNTkwOTYzLDI2NDg5NzY0NDIsMTA0Njk5NjEzLDE4ODEyNzQ0NCw0NzI2MTU2MzEsMjg3MzQzODE0LDg0MDAxOTcwNSwxMDU4NzA5NzQ0LDY3MTU5MzE5NSw2MjE1OTE3NzgsMTg1MjE3MTkyNSwxNjY4MjEyODkyLDE5NTM3NTc4MzEsMjAzNzk3MDA2MiwxNTE0NzkwNTc3LDE0NjM5OTY2MDAsMTA4MDAxNzU3MSwxMjk3NDAzMDUwLDM2NzM2MzczNTYsMzYyMzYzNjk2NSwzMjM1OTk1MTM0LDM0NTQ2ODYxOTksNDAwNzM2MDk2OCwzODIyMDkwMTc3LDQxMDcxMDE2NTgsNDE5MDUzMDUxNSwyOTk3ODI1OTU2LDMyMTUyMTI0NjEsMjgzMDcwODE1MCwyNzc5OTE1MTk5LDIyNTY3MzQ1OTIsMjM0MDk0Nzg0OSwyNjI3MDE2MDgyLDI0NDMwNTgwNzUsMTcyNDY2NTU2LDEyMjQ2NjE2NSwyNzM3OTIzNjYsNDkyNDgzNDMxLDEwNDcyMzllMyw4NjE5NjgyMDksNjEyMjA1ODk4LDY5NTYzNDc1NSwxNjQ2MjUyMzQwLDE4NjM2Mzg4NDUsMjAxMzkwODI2MiwxOTYzMTE1MzExLDE0NDYyNDI1NzYsMTUzMDQ1NTgzMywxMjc3NTU1OTcwLDEwOTM1OTc5NjMsMTYzNjYwNDYzMSwxODIwODI0Nzk4LDIwNzM3MjQ2MTMsMTk4OTI0OTIyOCwxNDM2NTkwODM1LDE0ODc2NDU5NDYsMTMzNzM3NjQ4MSwxMTE5NzI3ODQ4LDE2NDk0ODYzOSw4MTc4MTkxMCwzMzE1NDQyMDUsNTE2NTUyODM2LDEwMzk3MTcwNTEsODIxMjg4MTE0LDY2OTk2MTg5Nyw3MTk3MDAxMjgsMjk3MzUzMDY5NSwzMTU3NzUwODYyLDI4NzE2ODI2NDUsMjc4NzIwNzI2MCwyMjMyNDM1Mjk5LDIyODM0OTA0MTAsMjY2Nzk5NDczNywyNDUwMzQ2MTA0LDM2NDcyMTIwNDcsMzU2NDA0NTMxOCwzMjc5MDMzODg1LDM0NjQwNDI1MTYsMzk4MDkzMTYyNywzNzYyNTAyNjkwLDQxNTAxNDQ1NjksNDE5OTg4MjgwMCwzMDcwMzU2NjM0LDMxMjEyNzU1MzksMjkwNDAyNzI3MiwyNjg2MjU0NzIxLDIyMDA4MTg4NzgsMjM4NDkxMTAzMSwyNTcwODMyMDQ0LDI0ODYyMjQ1NDksMzc0NzE5MjAxOCwzNTI4NjI2OTA3LDMzMTAzMjE4NTYsMzM1OTkzNjIwMSwzOTUwMzU1NzAyLDM4NjcwNjA5OTEsNDA0OTg0NDQ1Miw0MjM0NzIxMDA1LDE3Mzk2NTYyMDIsMTc5MDU3NTEwNywyMTA4MTAwNjMyLDE4OTAzMjgwODEsMTQwMjgxMTQzOCwxNTg2OTAzNTkxLDEyMzM4NTY1NzIsMTE0OTI0OTA3NywyNjY5NTk5MzgsNDgzOTQ4MjcsMzY5MDU3ODcyLDQxODY3MjIxNywxMDAyNzgzODQ2LDkxOTQ4OTEzNSw1Njc0OTg4NjgsNzUyMzc1NDIxLDIwOTMzNjIyNSwyNDE5NzU0NCwzNzYxODc4MjcsNDU5NzQ0Njk4LDk0NTE2NDE2NSw4OTUyODc2OTIsNTc0NjI0NjYzLDc5MzQ1MTkzNCwxNjc5OTY4MjMzLDE3NjQzMTM1NjgsMjExNzM2MDYzNSwxOTMzNTMwNjEwLDEzNDMxMjc1MDEsMTU2MDYzNzg5MiwxMjQzMTEyNDE1LDExOTI0NTU2MzgsMzcwNDI4MDg4MSwzNTE5MTQyMjAwLDMzMzYzNTg2OTEsMzQxOTkxNTU2MiwzOTA3NDQ4NTk3LDM4NTc1NzIxMjQsNDA3NTg3NzEyNyw0Mjk0NzA0Mzk4LDMwMjk1MTAwMDksMzExMzg1NTM0NCwyOTI3OTM0MzE1LDI3NDQxMDQyOTAsMjE1OTk3NjI4NSwyMzc3NDg2Njc2LDI1OTQ3MzQ5MjcsMjU0NDA3ODE1MF07dmFyIFU0PVswLDE1MTg0OTc0MiwzMDM2OTk0ODQsNDU0NDk5NjAyLDYwNzM5ODk2OCw3NTg3MjAzMTAsOTA4OTk5MjA0LDEwNTkyNzA5NTQsMTIxNDc5NzkzNiwxMDk3MTU5NTUwLDE1MTc0NDA2MjAsMTQwMDg0OTc2MiwxODE3OTk4NDA4LDE2OTk4Mzk4MTQsMjExODU0MTkwOCwyMDAxNDMwODc0LDI0Mjk1OTU4NzIsMjU4MTQ0NTYxNCwyMTk0MzE5MTAwLDIzNDUxMTkyMTgsMzAzNDg4MTI0MCwzMTg2MjAyNTgyLDI4MDE2OTk1MjQsMjk1MTk3MTI3NCwzNjM1OTk2ODE2LDM1MTgzNTg0MzAsMzM5OTY3OTYyOCwzMjgzMDg4NzcwLDQyMzcwODM4MTYsNDExODkyNTIyMiw0MDAyODYxNzQ4LDM4ODU3NTA3MTQsMTAwMjE0MjY4Myw4NTA4MTcyMzcsNjk4NDQ1MjU1LDU0ODE2OTQxNyw1Mjk0ODc4NDMsMzc3NjQyMjIxLDIyNzg4NTU2Nyw3NzA4OTUyMSwxOTQzMjE3MDY3LDIwNjEzNzk3NDksMTY0MDU3NjQzOSwxNzU3NjkxNTc3LDE0NzQ3NjA1OTUsMTU5MjM5NDkwOSwxMTc0MjE1MDU1LDEyOTA4MDE3OTMsMjg3NTk2ODMxNSwyNzI0NjQyODY5LDMxMTEyNDcxNDMsMjk2MDk3MTMwNSwyNDA1NDI2OTQ3LDIyNTM1ODEzMjUsMjYzODYwNjYyMywyNDg3ODEwNTc3LDM4MDg2NjIzNDcsMzkyNjgyNTAyOSw0MDQ0OTgxNTkxLDQxNjIwOTY3MjksMzM0MjMxOTQ3NSwzNDU5OTUzNzg5LDM1NzY1Mzk1MDMsMzY5MzEyNjI0MSwxOTg2OTE4MDYxLDIxMzcwNjI4MTksMTY4NTU3NzkwNSwxODM2NzcyMjg3LDEzODE2MjAzNzMsMTUzMjI4NTMzOSwxMDc4MTg1MDk3LDEyMjk4OTk2NTUsMTA0MDU1OTgzNyw5MjMzMTM2MTksNzQwMjc2NDE3LDYyMTk4MjY3MSw0Mzk0NTIzODksMzIyNzM0NTcxLDEzNzA3MzkxMywxOTMwODUzNSwzODcxMTYzOTgxLDQwMjEzMDg3MzksNDEwNDYwNTc3Nyw0MjU1ODAwMTU5LDMyNjM3ODU1ODksMzQxNDQ1MDU1NSwzNDk5MzI2NTY5LDM2NTEwNDExMjcsMjkzMzIwMjQ5MywyODE1OTU2Mjc1LDMxNjc2ODQ2NDEsMzA0OTM5MDg5NSwyMzMwMDE0MjEzLDIyMTMyOTYzOTUsMjU2NjU5NTYwOSwyNDQ4ODMwMjMxLDEzMDU5MDY1NTAsMTE1NTIzNzQ5NiwxNjA3MjQ0NjUwLDE0NTU1MjU5ODgsMTc3NjQ2MDExMCwxNjI2MzE5NDI0LDIwNzk4OTc0MjYsMTkyODcwNzE2NCw5NjM5MjQ1NCwyMTMxMTQzNzYsMzk2NjczODE4LDUxNDQ0MzI4NCw1NjI3NTU5MDIsNjc5OTk4ZTMsODY1MTM2NDE4LDk4MzQyNjA5MiwzNzA4MTczNzE4LDM1NTc1MDQ2NjQsMzQ3NDcyOTg2NiwzMzIzMDExMjA0LDQxODA4MDgxMTAsNDAzMDY2NzQyNCwzOTQ1MjY5MTcwLDM3OTQwNzg5MDgsMjUwNzA0MDIzMCwyNjIzNzYyMTUyLDIyNzI1NTYwMjYsMjM5MDMyNTQ5MiwyOTc1NDg0MzgyLDMwOTI3MjY0ODAsMjczODkwNTAyNiwyODU3MTk0NzAwLDM5NzM3NzMxMjEsMzg1NjEzNzI5NSw0Mjc0MDUzNDY5LDQxNTc0NjcyMTksMzM3MTA5Njk1MywzMjUyOTMyNzI3LDM2NzM0NzY0NTMsMzU1NjM2MTgzNSwyNzYzMTczNjgxLDI5MTUwMTc3OTEsMzA2NDUxMDc2NSwzMjE1MzA3Mjk5LDIxNTYyOTkwMTcsMjMwNzYyMjkxOSwyNDU5NzM1MzE3LDI2MTAwMTE2NzUsMjA4MTA0ODQ4MSwxOTYzNDEyNjU1LDE4NDY1NjMyNjEsMTcyOTk3NzAxMSwxNDgwNDg1Nzg1LDEzNjIzMjE1NTksMTI0MzkwNTQxMywxMTI2NzkwNzk1LDg3ODg0NTkwNSwxMDMwNjkwMDE1LDY0NTQwMTAzNyw3OTYxOTc1NzEsMjc0MDg0ODQxLDQyNTQwODc0MywzODU0NDg4NSwxODg4MjEyNDMsMzYxMzQ5NDQyNiwzNzMxNjU0NTQ4LDMzMTMyMTIwMzgsMzQzMDMyMjU2OCw0MDgyNDc1MTcwLDQyMDAxMTUxMTYsMzc4MDA5NzcyNiwzODk2Njg4MDQ4LDI2NjgyMjE2NzQsMjUxNjkwMTg2MCwyMzY2ODgyNTUwLDIyMTY2MTAyOTYsMzE0MTQwMDc4NiwyOTg5NTUyNjA0LDI4Mzc5NjY1NDIsMjY4NzE2NTg4OCwxMjAyNzk3NjkwLDEzMjA5NTc4MTIsMTQzNzI4MDg3MCwxNTU0MzkxNDAwLDE2Njk2NjQ4MzQsMTc4NzMwNDc4MCwxOTA2MjQ3MjYyLDIwMjI4Mzc1ODQsMjY1OTA1MTYyLDExNDU4NTM0OCw0OTkzNDc5OTAsMzQ5MDc1NzM2LDczNjk3MDgwMiw1ODUxMjI2MjAsOTcyNTEyODE0LDgyMTcxMjE2MCwyNTk1Njg0ODQ0LDI0Nzg0NDMyMzQsMjI5MzA0NTIzMiwyMTc0NzU0MDQ2LDMxOTYyNjc5ODgsMzA3OTU0NjU4NiwyODk1NzIzNDY0LDI3Nzc5NTI0NTQsMzUzNzg1MjgyOCwzNjg3OTk0MDAyLDMyMzQxNTY0MTYsMzM4NTM0NTE2Niw0MTQyNjI2MjEyLDQyOTMyOTU3ODYsMzg0MTAyNDk1MiwzOTkyNzQyMDcwLDE3NDU2NzY5Miw1NzMyNjA4Miw0MTA4ODc5NTIsMjkyNTk2NzY2LDc3NzIzMTY2OCw2NjA1MTAyNjYsMTAxMTQ1MjcxMiw4OTM2ODE3MDIsMTEwODMzOTA2OCwxMjU4NDgwMjQyLDEzNDM2MTg5MTIsMTQ5NDgwNzY2MiwxNzE1MTkzMTU2LDE4NjU4NjI3MzAsMTk0ODM3Mzg0OCwyMTAwMDkwOTY2LDI3MDE5NDk0OTUsMjgxODY2NjgwOSwzMDA0NTkxMTQ3LDMxMjIzNTgwNTMsMjIzNTA2MTc3NSwyMzUyMzA3NDU3LDI1MzU2MDQyNDMsMjY1Mzg5OTU0OSwzOTE1NjUzNzAzLDM3NjQ5ODgyMzMsNDIxOTM1MjE1NSw0MDY3NjM5MTI1LDM0NDQ1NzU4NzEsMzI5NDQzMDU3NywzNzQ2MTc1MDc1LDM1OTQ5ODIyNTMsODM2NTUzNDMxLDk1MzI3MDc0NSw2MDAyMzUyMTEsNzE4MDAyMTE3LDM2NzU4NTAwNyw0ODQ4MzA2ODksMTMzMzYxOTA3LDI1MTY1NzIxMywyMDQxODc3MTU5LDE4OTEyMTE2ODksMTgwNjU5OTM1NSwxNjU0ODg2MzI1LDE1Njg3MTg0OTUsMTQxODU3MzIwMSwxMzM1NTM1NzQ3LDExODQzNDI5MjVdO2Z1bmN0aW9uIGNvbnZlcnRUb0ludDMyKGJ5dGVzKXt2YXIgcmVzdWx0PVtdO2Zvcih2YXIgaT0wO2k8Ynl0ZXMubGVuZ3RoO2krPTQpe3Jlc3VsdC5wdXNoKGJ5dGVzW2ldPDwyNHxieXRlc1tpKzFdPDwxNnxieXRlc1tpKzJdPDw4fGJ5dGVzW2krM10pfXJldHVybiByZXN1bHR9dmFyIEFFUz1mdW5jdGlvbihrZXkpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEFFUykpe3Rocm93IEVycm9yKFwiQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJrZXlcIix7dmFsdWU6Y29lcmNlQXJyYXkoa2V5LHRydWUpfSk7dGhpcy5fcHJlcGFyZSgpfTtBRVMucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7dmFyIHJvdW5kcz1udW1iZXJPZlJvdW5kc1t0aGlzLmtleS5sZW5ndGhdO2lmKHJvdW5kcz09bnVsbCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpXCIpfXRoaXMuX0tlPVtdO3RoaXMuX0tkPVtdO2Zvcih2YXIgaT0wO2k8PXJvdW5kcztpKyspe3RoaXMuX0tlLnB1c2goWzAsMCwwLDBdKTt0aGlzLl9LZC5wdXNoKFswLDAsMCwwXSl9dmFyIHJvdW5kS2V5Q291bnQ9KHJvdW5kcysxKSo0O3ZhciBLQz10aGlzLmtleS5sZW5ndGgvNDt2YXIgdGs9Y29udmVydFRvSW50MzIodGhpcy5rZXkpO3ZhciBpbmRleDtmb3IodmFyIGk9MDtpPEtDO2krKyl7aW5kZXg9aT4+Mjt0aGlzLl9LZVtpbmRleF1baSU0XT10a1tpXTt0aGlzLl9LZFtyb3VuZHMtaW5kZXhdW2klNF09dGtbaV19dmFyIHJjb25wb2ludGVyPTA7dmFyIHQ9S0MsdHQ7d2hpbGUodDxyb3VuZEtleUNvdW50KXt0dD10a1tLQy0xXTt0a1swXV49U1t0dD4+MTYmMjU1XTw8MjReU1t0dD4+OCYyNTVdPDwxNl5TW3R0JjI1NV08PDheU1t0dD4+MjQmMjU1XV5yY29uW3Jjb25wb2ludGVyXTw8MjQ7cmNvbnBvaW50ZXIrPTE7aWYoS0MhPTgpe2Zvcih2YXIgaT0xO2k8S0M7aSsrKXt0a1tpXV49dGtbaS0xXX19ZWxzZXtmb3IodmFyIGk9MTtpPEtDLzI7aSsrKXt0a1tpXV49dGtbaS0xXX10dD10a1tLQy8yLTFdO3RrW0tDLzJdXj1TW3R0JjI1NV1eU1t0dD4+OCYyNTVdPDw4XlNbdHQ+PjE2JjI1NV08PDE2XlNbdHQ+PjI0JjI1NV08PDI0O2Zvcih2YXIgaT1LQy8yKzE7aTxLQztpKyspe3RrW2ldXj10a1tpLTFdfX12YXIgaT0wLHIsYzt3aGlsZShpPEtDJiZ0PHJvdW5kS2V5Q291bnQpe3I9dD4+MjtjPXQlNDt0aGlzLl9LZVtyXVtjXT10a1tpXTt0aGlzLl9LZFtyb3VuZHMtcl1bY109dGtbaSsrXTt0Kyt9fWZvcih2YXIgcj0xO3I8cm91bmRzO3IrKyl7Zm9yKHZhciBjPTA7Yzw0O2MrKyl7dHQ9dGhpcy5fS2Rbcl1bY107dGhpcy5fS2Rbcl1bY109VTFbdHQ+PjI0JjI1NV1eVTJbdHQ+PjE2JjI1NV1eVTNbdHQ+PjgmMjU1XV5VNFt0dCYyNTVdfX19O0FFUy5wcm90b3R5cGUuZW5jcnlwdD1mdW5jdGlvbihwbGFpbnRleHQpe2lmKHBsYWludGV4dC5sZW5ndGghPTE2KXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKX12YXIgcm91bmRzPXRoaXMuX0tlLmxlbmd0aC0xO3ZhciBhPVswLDAsMCwwXTt2YXIgdD1jb252ZXJ0VG9JbnQzMihwbGFpbnRleHQpO2Zvcih2YXIgaT0wO2k8NDtpKyspe3RbaV1ePXRoaXMuX0tlWzBdW2ldfWZvcih2YXIgcj0xO3I8cm91bmRzO3IrKyl7Zm9yKHZhciBpPTA7aTw0O2krKyl7YVtpXT1UMVt0W2ldPj4yNCYyNTVdXlQyW3RbKGkrMSklNF0+PjE2JjI1NV1eVDNbdFsoaSsyKSU0XT4+OCYyNTVdXlQ0W3RbKGkrMyklNF0mMjU1XV50aGlzLl9LZVtyXVtpXX10PWEuc2xpY2UoKX12YXIgcmVzdWx0PWNyZWF0ZUFycmF5KDE2KSx0dDtmb3IodmFyIGk9MDtpPDQ7aSsrKXt0dD10aGlzLl9LZVtyb3VuZHNdW2ldO3Jlc3VsdFs0KmldPShTW3RbaV0+PjI0JjI1NV1edHQ+PjI0KSYyNTU7cmVzdWx0WzQqaSsxXT0oU1t0WyhpKzEpJTRdPj4xNiYyNTVdXnR0Pj4xNikmMjU1O3Jlc3VsdFs0KmkrMl09KFNbdFsoaSsyKSU0XT4+OCYyNTVdXnR0Pj44KSYyNTU7cmVzdWx0WzQqaSszXT0oU1t0WyhpKzMpJTRdJjI1NV1edHQpJjI1NX1yZXR1cm4gcmVzdWx0fTtBRVMucHJvdG90eXBlLmRlY3J5cHQ9ZnVuY3Rpb24oY2lwaGVydGV4dCl7aWYoY2lwaGVydGV4dC5sZW5ndGghPTE2KXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIil9dmFyIHJvdW5kcz10aGlzLl9LZC5sZW5ndGgtMTt2YXIgYT1bMCwwLDAsMF07dmFyIHQ9Y29udmVydFRvSW50MzIoY2lwaGVydGV4dCk7Zm9yKHZhciBpPTA7aTw0O2krKyl7dFtpXV49dGhpcy5fS2RbMF1baV19Zm9yKHZhciByPTE7cjxyb3VuZHM7cisrKXtmb3IodmFyIGk9MDtpPDQ7aSsrKXthW2ldPVQ1W3RbaV0+PjI0JjI1NV1eVDZbdFsoaSszKSU0XT4+MTYmMjU1XV5UN1t0WyhpKzIpJTRdPj44JjI1NV1eVDhbdFsoaSsxKSU0XSYyNTVdXnRoaXMuX0tkW3JdW2ldfXQ9YS5zbGljZSgpfXZhciByZXN1bHQ9Y3JlYXRlQXJyYXkoMTYpLHR0O2Zvcih2YXIgaT0wO2k8NDtpKyspe3R0PXRoaXMuX0tkW3JvdW5kc11baV07cmVzdWx0WzQqaV09KFNpW3RbaV0+PjI0JjI1NV1edHQ+PjI0KSYyNTU7cmVzdWx0WzQqaSsxXT0oU2lbdFsoaSszKSU0XT4+MTYmMjU1XV50dD4+MTYpJjI1NTtyZXN1bHRbNCppKzJdPShTaVt0WyhpKzIpJTRdPj44JjI1NV1edHQ+PjgpJjI1NTtyZXN1bHRbNCppKzNdPShTaVt0WyhpKzEpJTRdJjI1NV1edHQpJjI1NX1yZXR1cm4gcmVzdWx0fTt2YXIgTW9kZU9mT3BlcmF0aW9uRUNCPWZ1bmN0aW9uKGtleSl7aWYoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uRUNCKSl7dGhyb3cgRXJyb3IoXCJBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKX10aGlzLmRlc2NyaXB0aW9uPVwiRWxlY3Ryb25pYyBDb2RlIEJsb2NrXCI7dGhpcy5uYW1lPVwiZWNiXCI7dGhpcy5fYWVzPW5ldyBBRVMoa2V5KX07TW9kZU9mT3BlcmF0aW9uRUNCLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKHBsYWludGV4dCl7cGxhaW50ZXh0PWNvZXJjZUFycmF5KHBsYWludGV4dCk7aWYocGxhaW50ZXh0Lmxlbmd0aCUxNiE9PTApe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpfXZhciBjaXBoZXJ0ZXh0PWNyZWF0ZUFycmF5KHBsYWludGV4dC5sZW5ndGgpO3ZhciBibG9jaz1jcmVhdGVBcnJheSgxNik7Zm9yKHZhciBpPTA7aTxwbGFpbnRleHQubGVuZ3RoO2krPTE2KXtjb3B5QXJyYXkocGxhaW50ZXh0LGJsb2NrLDAsaSxpKzE2KTtibG9jaz10aGlzLl9hZXMuZW5jcnlwdChibG9jayk7Y29weUFycmF5KGJsb2NrLGNpcGhlcnRleHQsaSl9cmV0dXJuIGNpcGhlcnRleHR9O01vZGVPZk9wZXJhdGlvbkVDQi5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihjaXBoZXJ0ZXh0KXtjaXBoZXJ0ZXh0PWNvZXJjZUFycmF5KGNpcGhlcnRleHQpO2lmKGNpcGhlcnRleHQubGVuZ3RoJTE2IT09MCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpfXZhciBwbGFpbnRleHQ9Y3JlYXRlQXJyYXkoY2lwaGVydGV4dC5sZW5ndGgpO3ZhciBibG9jaz1jcmVhdGVBcnJheSgxNik7Zm9yKHZhciBpPTA7aTxjaXBoZXJ0ZXh0Lmxlbmd0aDtpKz0xNil7Y29weUFycmF5KGNpcGhlcnRleHQsYmxvY2ssMCxpLGkrMTYpO2Jsb2NrPXRoaXMuX2Flcy5kZWNyeXB0KGJsb2NrKTtjb3B5QXJyYXkoYmxvY2sscGxhaW50ZXh0LGkpfXJldHVybiBwbGFpbnRleHR9O3ZhciBNb2RlT2ZPcGVyYXRpb25DQkM9ZnVuY3Rpb24oa2V5LGl2KXtpZighKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25DQkMpKXt0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpfXRoaXMuZGVzY3JpcHRpb249XCJDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcIjt0aGlzLm5hbWU9XCJjYmNcIjtpZighaXYpe2l2PWNyZWF0ZUFycmF5KDE2KX1lbHNlIGlmKGl2Lmxlbmd0aCE9MTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKX10aGlzLl9sYXN0Q2lwaGVyYmxvY2s9Y29lcmNlQXJyYXkoaXYsdHJ1ZSk7dGhpcy5fYWVzPW5ldyBBRVMoa2V5KX07TW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKHBsYWludGV4dCl7cGxhaW50ZXh0PWNvZXJjZUFycmF5KHBsYWludGV4dCk7aWYocGxhaW50ZXh0Lmxlbmd0aCUxNiE9PTApe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpfXZhciBjaXBoZXJ0ZXh0PWNyZWF0ZUFycmF5KHBsYWludGV4dC5sZW5ndGgpO3ZhciBibG9jaz1jcmVhdGVBcnJheSgxNik7Zm9yKHZhciBpPTA7aTxwbGFpbnRleHQubGVuZ3RoO2krPTE2KXtjb3B5QXJyYXkocGxhaW50ZXh0LGJsb2NrLDAsaSxpKzE2KTtmb3IodmFyIGo9MDtqPDE2O2orKyl7YmxvY2tbal1ePXRoaXMuX2xhc3RDaXBoZXJibG9ja1tqXX10aGlzLl9sYXN0Q2lwaGVyYmxvY2s9dGhpcy5fYWVzLmVuY3J5cHQoYmxvY2spO2NvcHlBcnJheSh0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssY2lwaGVydGV4dCxpKX1yZXR1cm4gY2lwaGVydGV4dH07TW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5kZWNyeXB0PWZ1bmN0aW9uKGNpcGhlcnRleHQpe2NpcGhlcnRleHQ9Y29lcmNlQXJyYXkoY2lwaGVydGV4dCk7aWYoY2lwaGVydGV4dC5sZW5ndGglMTYhPT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIil9dmFyIHBsYWludGV4dD1jcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7dmFyIGJsb2NrPWNyZWF0ZUFycmF5KDE2KTtmb3IodmFyIGk9MDtpPGNpcGhlcnRleHQubGVuZ3RoO2krPTE2KXtjb3B5QXJyYXkoY2lwaGVydGV4dCxibG9jaywwLGksaSsxNik7YmxvY2s9dGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO2Zvcih2YXIgaj0wO2o8MTY7aisrKXtwbGFpbnRleHRbaStqXT1ibG9ja1tqXV50aGlzLl9sYXN0Q2lwaGVyYmxvY2tbal19Y29weUFycmF5KGNpcGhlcnRleHQsdGhpcy5fbGFzdENpcGhlcmJsb2NrLDAsaSxpKzE2KX1yZXR1cm4gcGxhaW50ZXh0fTt2YXIgTW9kZU9mT3BlcmF0aW9uQ0ZCPWZ1bmN0aW9uKGtleSxpdixzZWdtZW50U2l6ZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ0ZCKSl7dGhyb3cgRXJyb3IoXCJBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKX10aGlzLmRlc2NyaXB0aW9uPVwiQ2lwaGVyIEZlZWRiYWNrXCI7dGhpcy5uYW1lPVwiY2ZiXCI7aWYoIWl2KXtpdj1jcmVhdGVBcnJheSgxNil9ZWxzZSBpZihpdi5sZW5ndGghPTE2KXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBzaXplKVwiKX1pZighc2VnbWVudFNpemUpe3NlZ21lbnRTaXplPTF9dGhpcy5zZWdtZW50U2l6ZT1zZWdtZW50U2l6ZTt0aGlzLl9zaGlmdFJlZ2lzdGVyPWNvZXJjZUFycmF5KGl2LHRydWUpO3RoaXMuX2Flcz1uZXcgQUVTKGtleSl9O01vZGVPZk9wZXJhdGlvbkNGQi5wcm90b3R5cGUuZW5jcnlwdD1mdW5jdGlvbihwbGFpbnRleHQpe2lmKHBsYWludGV4dC5sZW5ndGgldGhpcy5zZWdtZW50U2l6ZSE9MCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcylcIil9dmFyIGVuY3J5cHRlZD1jb2VyY2VBcnJheShwbGFpbnRleHQsdHJ1ZSk7dmFyIHhvclNlZ21lbnQ7Zm9yKHZhciBpPTA7aTxlbmNyeXB0ZWQubGVuZ3RoO2krPXRoaXMuc2VnbWVudFNpemUpe3hvclNlZ21lbnQ9dGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fc2hpZnRSZWdpc3Rlcik7Zm9yKHZhciBqPTA7ajx0aGlzLnNlZ21lbnRTaXplO2orKyl7ZW5jcnlwdGVkW2kral1ePXhvclNlZ21lbnRbal19Y29weUFycmF5KHRoaXMuX3NoaWZ0UmVnaXN0ZXIsdGhpcy5fc2hpZnRSZWdpc3RlciwwLHRoaXMuc2VnbWVudFNpemUpO2NvcHlBcnJheShlbmNyeXB0ZWQsdGhpcy5fc2hpZnRSZWdpc3RlciwxNi10aGlzLnNlZ21lbnRTaXplLGksaSt0aGlzLnNlZ21lbnRTaXplKX1yZXR1cm4gZW5jcnlwdGVkfTtNb2RlT2ZPcGVyYXRpb25DRkIucHJvdG90eXBlLmRlY3J5cHQ9ZnVuY3Rpb24oY2lwaGVydGV4dCl7aWYoY2lwaGVydGV4dC5sZW5ndGgldGhpcy5zZWdtZW50U2l6ZSE9MCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgc2VnbWVudFNpemUgYnl0ZXMpXCIpfXZhciBwbGFpbnRleHQ9Y29lcmNlQXJyYXkoY2lwaGVydGV4dCx0cnVlKTt2YXIgeG9yU2VnbWVudDtmb3IodmFyIGk9MDtpPHBsYWludGV4dC5sZW5ndGg7aSs9dGhpcy5zZWdtZW50U2l6ZSl7eG9yU2VnbWVudD10aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9zaGlmdFJlZ2lzdGVyKTtmb3IodmFyIGo9MDtqPHRoaXMuc2VnbWVudFNpemU7aisrKXtwbGFpbnRleHRbaStqXV49eG9yU2VnbWVudFtqXX1jb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3Rlcix0aGlzLl9zaGlmdFJlZ2lzdGVyLDAsdGhpcy5zZWdtZW50U2l6ZSk7Y29weUFycmF5KGNpcGhlcnRleHQsdGhpcy5fc2hpZnRSZWdpc3RlciwxNi10aGlzLnNlZ21lbnRTaXplLGksaSt0aGlzLnNlZ21lbnRTaXplKX1yZXR1cm4gcGxhaW50ZXh0fTt2YXIgTW9kZU9mT3BlcmF0aW9uT0ZCPWZ1bmN0aW9uKGtleSxpdil7aWYoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uT0ZCKSl7dGhyb3cgRXJyb3IoXCJBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKX10aGlzLmRlc2NyaXB0aW9uPVwiT3V0cHV0IEZlZWRiYWNrXCI7dGhpcy5uYW1lPVwib2ZiXCI7aWYoIWl2KXtpdj1jcmVhdGVBcnJheSgxNil9ZWxzZSBpZihpdi5sZW5ndGghPTE2KXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIil9dGhpcy5fbGFzdFByZWNpcGhlcj1jb2VyY2VBcnJheShpdix0cnVlKTt0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXg9MTY7dGhpcy5fYWVzPW5ldyBBRVMoa2V5KX07TW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKHBsYWludGV4dCl7dmFyIGVuY3J5cHRlZD1jb2VyY2VBcnJheShwbGFpbnRleHQsdHJ1ZSk7Zm9yKHZhciBpPTA7aTxlbmNyeXB0ZWQubGVuZ3RoO2krKyl7aWYodGhpcy5fbGFzdFByZWNpcGhlckluZGV4PT09MTYpe3RoaXMuX2xhc3RQcmVjaXBoZXI9dGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fbGFzdFByZWNpcGhlcik7dGhpcy5fbGFzdFByZWNpcGhlckluZGV4PTB9ZW5jcnlwdGVkW2ldXj10aGlzLl9sYXN0UHJlY2lwaGVyW3RoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCsrXX1yZXR1cm4gZW5jcnlwdGVkfTtNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmRlY3J5cHQ9TW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5lbmNyeXB0O3ZhciBDb3VudGVyPWZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgQ291bnRlcikpe3Rocm93IEVycm9yKFwiQ291bnRlciBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpfWlmKGluaXRpYWxWYWx1ZSE9PTAmJiFpbml0aWFsVmFsdWUpe2luaXRpYWxWYWx1ZT0xfWlmKHR5cGVvZiBpbml0aWFsVmFsdWU9PT1cIm51bWJlclwiKXt0aGlzLl9jb3VudGVyPWNyZWF0ZUFycmF5KDE2KTt0aGlzLnNldFZhbHVlKGluaXRpYWxWYWx1ZSl9ZWxzZXt0aGlzLnNldEJ5dGVzKGluaXRpYWxWYWx1ZSl9fTtDb3VudGVyLnByb3RvdHlwZS5zZXRWYWx1ZT1mdW5jdGlvbih2YWx1ZSl7aWYodHlwZW9mIHZhbHVlIT09XCJudW1iZXJcInx8cGFyc2VJbnQodmFsdWUpIT12YWx1ZSl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb3VudGVyIHZhbHVlIChtdXN0IGJlIGFuIGludGVnZXIpXCIpfWZvcih2YXIgaW5kZXg9MTU7aW5kZXg+PTA7LS1pbmRleCl7dGhpcy5fY291bnRlcltpbmRleF09dmFsdWUlMjU2O3ZhbHVlPXZhbHVlPj44fX07Q291bnRlci5wcm90b3R5cGUuc2V0Qnl0ZXM9ZnVuY3Rpb24oYnl0ZXMpe2J5dGVzPWNvZXJjZUFycmF5KGJ5dGVzLHRydWUpO2lmKGJ5dGVzLmxlbmd0aCE9MTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgY291bnRlciBieXRlcyBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKX10aGlzLl9jb3VudGVyPWJ5dGVzfTtDb3VudGVyLnByb3RvdHlwZS5pbmNyZW1lbnQ9ZnVuY3Rpb24oKXtmb3IodmFyIGk9MTU7aT49MDtpLS0pe2lmKHRoaXMuX2NvdW50ZXJbaV09PT0yNTUpe3RoaXMuX2NvdW50ZXJbaV09MH1lbHNle3RoaXMuX2NvdW50ZXJbaV0rKzticmVha319fTt2YXIgTW9kZU9mT3BlcmF0aW9uQ1RSPWZ1bmN0aW9uKGtleSxjb3VudGVyKXtpZighKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25DVFIpKXt0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpfXRoaXMuZGVzY3JpcHRpb249XCJDb3VudGVyXCI7dGhpcy5uYW1lPVwiY3RyXCI7aWYoIShjb3VudGVyIGluc3RhbmNlb2YgQ291bnRlcikpe2NvdW50ZXI9bmV3IENvdW50ZXIoY291bnRlcil9dGhpcy5fY291bnRlcj1jb3VudGVyO3RoaXMuX3JlbWFpbmluZ0NvdW50ZXI9bnVsbDt0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXg9MTY7dGhpcy5fYWVzPW5ldyBBRVMoa2V5KX07TW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKHBsYWludGV4dCl7dmFyIGVuY3J5cHRlZD1jb2VyY2VBcnJheShwbGFpbnRleHQsdHJ1ZSk7Zm9yKHZhciBpPTA7aTxlbmNyeXB0ZWQubGVuZ3RoO2krKyl7aWYodGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4PT09MTYpe3RoaXMuX3JlbWFpbmluZ0NvdW50ZXI9dGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fY291bnRlci5fY291bnRlcik7dGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4PTA7dGhpcy5fY291bnRlci5pbmNyZW1lbnQoKX1lbmNyeXB0ZWRbaV1ePXRoaXMuX3JlbWFpbmluZ0NvdW50ZXJbdGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4KytdfXJldHVybiBlbmNyeXB0ZWR9O01vZGVPZk9wZXJhdGlvbkNUUi5wcm90b3R5cGUuZGVjcnlwdD1Nb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmVuY3J5cHQ7ZnVuY3Rpb24gcGtjczdwYWQoZGF0YSl7ZGF0YT1jb2VyY2VBcnJheShkYXRhLHRydWUpO3ZhciBwYWRkZXI9MTYtZGF0YS5sZW5ndGglMTY7dmFyIHJlc3VsdD1jcmVhdGVBcnJheShkYXRhLmxlbmd0aCtwYWRkZXIpO2NvcHlBcnJheShkYXRhLHJlc3VsdCk7Zm9yKHZhciBpPWRhdGEubGVuZ3RoO2k8cmVzdWx0Lmxlbmd0aDtpKyspe3Jlc3VsdFtpXT1wYWRkZXJ9cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBwa2NzN3N0cmlwKGRhdGEpe2RhdGE9Y29lcmNlQXJyYXkoZGF0YSx0cnVlKTtpZihkYXRhLmxlbmd0aDwxNil7dGhyb3cgbmV3IEVycm9yKFwiUEtDUyM3IGludmFsaWQgbGVuZ3RoXCIpfXZhciBwYWRkZXI9ZGF0YVtkYXRhLmxlbmd0aC0xXTtpZihwYWRkZXI+MTYpe3Rocm93IG5ldyBFcnJvcihcIlBLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlXCIpfXZhciBsZW5ndGg9ZGF0YS5sZW5ndGgtcGFkZGVyO2Zvcih2YXIgaT0wO2k8cGFkZGVyO2krKyl7aWYoZGF0YVtsZW5ndGgraV0hPT1wYWRkZXIpe3Rocm93IG5ldyBFcnJvcihcIlBLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZVwiKX19dmFyIHJlc3VsdD1jcmVhdGVBcnJheShsZW5ndGgpO2NvcHlBcnJheShkYXRhLHJlc3VsdCwwLDAsbGVuZ3RoKTtyZXR1cm4gcmVzdWx0fXZhciBhZXNqcz17QUVTOkFFUyxDb3VudGVyOkNvdW50ZXIsTW9kZU9mT3BlcmF0aW9uOntlY2I6TW9kZU9mT3BlcmF0aW9uRUNCLGNiYzpNb2RlT2ZPcGVyYXRpb25DQkMsY2ZiOk1vZGVPZk9wZXJhdGlvbkNGQixvZmI6TW9kZU9mT3BlcmF0aW9uT0ZCLGN0cjpNb2RlT2ZPcGVyYXRpb25DVFJ9LHV0aWxzOntoZXg6Y29udmVydEhleCx1dGY4OmNvbnZlcnRVdGY4fSxwYWRkaW5nOntwa2NzNzp7cGFkOnBrY3M3cGFkLHN0cmlwOnBrY3M3c3RyaXB9fSxfYXJyYXlUZXN0Ontjb2VyY2VBcnJheTpjb2VyY2VBcnJheSxjcmVhdGVBcnJheTpjcmVhdGVBcnJheSxjb3B5QXJyYXk6Y29weUFycmF5fX07aWYoXCJvYmplY3RcIiE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWFlc2pzfWVsc2UgaWYodHlwZW9mIHVuZGVmaW5lZD09PVwiZnVuY3Rpb25cIiYmdW5kZWZpbmVkLmFtZCl7dW5kZWZpbmVkKGFlc2pzKX1lbHNle2lmKHJvb3QuYWVzanMpe2Flc2pzLl9hZXNqcz1yb290LmFlc2pzfXJvb3QuYWVzanM9YWVzanN9fSkoY29tbW9uanNHbG9iYWwpfSk7Y29uc3QgdmVyc2lvbiRpPVwianNvbi13YWxsZXRzLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpe2lmKHR5cGVvZiBoZXhTdHJpbmc9PT1cInN0cmluZ1wiJiZoZXhTdHJpbmcuc3Vic3RyaW5nKDAsMikhPT1cIjB4XCIpe2hleFN0cmluZz1cIjB4XCIraGV4U3RyaW5nfXJldHVybiBhcnJheWlmeShoZXhTdHJpbmcpfWZ1bmN0aW9uIHpwYWQodmFsdWUsbGVuZ3RoKXt2YWx1ZT1TdHJpbmcodmFsdWUpO3doaWxlKHZhbHVlLmxlbmd0aDxsZW5ndGgpe3ZhbHVlPVwiMFwiK3ZhbHVlfXJldHVybiB2YWx1ZX1mdW5jdGlvbiBnZXRQYXNzd29yZChwYXNzd29yZCl7aWYodHlwZW9mIHBhc3N3b3JkPT09XCJzdHJpbmdcIil7cmV0dXJuIHRvVXRmOEJ5dGVzKHBhc3N3b3JkLFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktDKX1yZXR1cm4gYXJyYXlpZnkocGFzc3dvcmQpfWZ1bmN0aW9uIHNlYXJjaFBhdGgob2JqZWN0LHBhdGgpe2xldCBjdXJyZW50Q2hpbGQ9b2JqZWN0O2NvbnN0IGNvbXBzPXBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdChcIi9cIik7Zm9yKGxldCBpPTA7aTxjb21wcy5sZW5ndGg7aSsrKXtsZXQgbWF0Y2hpbmdDaGlsZD1udWxsO2Zvcihjb25zdCBrZXkgaW4gY3VycmVudENoaWxkKXtpZihrZXkudG9Mb3dlckNhc2UoKT09PWNvbXBzW2ldKXttYXRjaGluZ0NoaWxkPWN1cnJlbnRDaGlsZFtrZXldO2JyZWFrfX1pZihtYXRjaGluZ0NoaWxkPT09bnVsbCl7cmV0dXJuIG51bGx9Y3VycmVudENoaWxkPW1hdGNoaW5nQ2hpbGR9cmV0dXJuIGN1cnJlbnRDaGlsZH1mdW5jdGlvbiB1dWlkVjQocmFuZG9tQnl0ZXMpe2NvbnN0IGJ5dGVzPWFycmF5aWZ5KHJhbmRvbUJ5dGVzKTtieXRlc1s2XT1ieXRlc1s2XSYxNXw2NDtieXRlc1s4XT1ieXRlc1s4XSY2M3wxMjg7Y29uc3QgdmFsdWU9aGV4bGlmeShieXRlcyk7cmV0dXJuW3ZhbHVlLnN1YnN0cmluZygyLDEwKSx2YWx1ZS5zdWJzdHJpbmcoMTAsMTQpLHZhbHVlLnN1YnN0cmluZygxNCwxOCksdmFsdWUuc3Vic3RyaW5nKDE4LDIyKSx2YWx1ZS5zdWJzdHJpbmcoMjIsMzQpXS5qb2luKFwiLVwiKX1cInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkbj1uZXcgTG9nZ2VyKHZlcnNpb24kaSk7Y2xhc3MgQ3Jvd2RzYWxlQWNjb3VudCBleHRlbmRzIERlc2NyaXB0aW9ue2lzQ3Jvd2RzYWxlQWNjb3VudCh2YWx1ZSl7cmV0dXJuISEodmFsdWUmJnZhbHVlLl9pc0Nyb3dkc2FsZUFjY291bnQpfX1mdW5jdGlvbiBkZWNyeXB0KGpzb24scGFzc3dvcmQpe2NvbnN0IGRhdGE9SlNPTi5wYXJzZShqc29uKTtwYXNzd29yZD1nZXRQYXNzd29yZChwYXNzd29yZCk7Y29uc3QgZXRoYWRkcj1nZXRBZGRyZXNzKHNlYXJjaFBhdGgoZGF0YSxcImV0aGFkZHJcIikpO2NvbnN0IGVuY3NlZWQ9bG9vc2VBcnJheWlmeShzZWFyY2hQYXRoKGRhdGEsXCJlbmNzZWVkXCIpKTtpZighZW5jc2VlZHx8ZW5jc2VlZC5sZW5ndGglMTYhPT0wKXtsb2dnZXIkbi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGVuY3NlZWRcIixcImpzb25cIixqc29uKX1jb25zdCBrZXk9YXJyYXlpZnkocGJrZGYyKHBhc3N3b3JkLHBhc3N3b3JkLDJlMywzMixcInNoYTI1NlwiKSkuc2xpY2UoMCwxNik7Y29uc3QgaXY9ZW5jc2VlZC5zbGljZSgwLDE2KTtjb25zdCBlbmNyeXB0ZWRTZWVkPWVuY3NlZWQuc2xpY2UoMTYpO2NvbnN0IGFlc0NiYz1uZXcgYWVzSnMuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksaXYpO2NvbnN0IHNlZWQ9YWVzSnMucGFkZGluZy5wa2NzNy5zdHJpcChhcnJheWlmeShhZXNDYmMuZGVjcnlwdChlbmNyeXB0ZWRTZWVkKSkpO2xldCBzZWVkSGV4PVwiXCI7Zm9yKGxldCBpPTA7aTxzZWVkLmxlbmd0aDtpKyspe3NlZWRIZXgrPVN0cmluZy5mcm9tQ2hhckNvZGUoc2VlZFtpXSl9Y29uc3Qgc2VlZEhleEJ5dGVzPXRvVXRmOEJ5dGVzKHNlZWRIZXgpO2NvbnN0IHByaXZhdGVLZXk9a2VjY2FrMjU2KHNlZWRIZXhCeXRlcyk7cmV0dXJuIG5ldyBDcm93ZHNhbGVBY2NvdW50KHtfaXNDcm93ZHNhbGVBY2NvdW50OnRydWUsYWRkcmVzczpldGhhZGRyLHByaXZhdGVLZXk6cHJpdmF0ZUtleX0pfVwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pe2xldCBkYXRhPW51bGw7dHJ5e2RhdGE9SlNPTi5wYXJzZShqc29uKX1jYXRjaChlcnJvcil7cmV0dXJuIGZhbHNlfXJldHVybiBkYXRhLmVuY3NlZWQmJmRhdGEuZXRoYWRkcn1mdW5jdGlvbiBpc0tleXN0b3JlV2FsbGV0KGpzb24pe2xldCBkYXRhPW51bGw7dHJ5e2RhdGE9SlNPTi5wYXJzZShqc29uKX1jYXRjaChlcnJvcil7cmV0dXJuIGZhbHNlfWlmKCFkYXRhLnZlcnNpb258fHBhcnNlSW50KGRhdGEudmVyc2lvbikhPT1kYXRhLnZlcnNpb258fHBhcnNlSW50KGRhdGEudmVyc2lvbikhPT0zKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZnVuY3Rpb24gZ2V0SnNvbldhbGxldEFkZHJlc3MoanNvbil7aWYoaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpe3RyeXtyZXR1cm4gZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmV0aGFkZHIpfWNhdGNoKGVycm9yKXtyZXR1cm4gbnVsbH19aWYoaXNLZXlzdG9yZVdhbGxldChqc29uKSl7dHJ5e3JldHVybiBnZXRBZGRyZXNzKEpTT04ucGFyc2UoanNvbikuYWRkcmVzcyl9Y2F0Y2goZXJyb3Ipe3JldHVybiBudWxsfX1yZXR1cm4gbnVsbH12YXIgc2NyeXB0PWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24ocm9vdCl7Y29uc3QgTUFYX1ZBTFVFPTIxNDc0ODM2NDc7ZnVuY3Rpb24gU0hBMjU2KG0pe2NvbnN0IEs9bmV3IFVpbnQzMkFycmF5KFsxMTE2MzUyNDA4LDE4OTk0NDc0NDEsMzA0OTMyMzQ3MSwzOTIxMDA5NTczLDk2MTk4NzE2MywxNTA4OTcwOTkzLDI0NTM2MzU3NDgsMjg3MDc2MzIyMSwzNjI0MzgxMDgwLDMxMDU5ODQwMSw2MDcyMjUyNzgsMTQyNjg4MTk4NywxOTI1MDc4Mzg4LDIxNjIwNzgyMDYsMjYxNDg4ODEwMywzMjQ4MjIyNTgwLDM4MzUzOTA0MDEsNDAyMjIyNDc3NCwyNjQzNDcwNzgsNjA0ODA3NjI4LDc3MDI1NTk4MywxMjQ5MTUwMTIyLDE1NTUwODE2OTIsMTk5NjA2NDk4NiwyNTU0MjIwODgyLDI4MjE4MzQzNDksMjk1Mjk5NjgwOCwzMjEwMzEzNjcxLDMzMzY1NzE4OTEsMzU4NDUyODcxMSwxMTM5MjY5OTMsMzM4MjQxODk1LDY2NjMwNzIwNSw3NzM1Mjk5MTIsMTI5NDc1NzM3MiwxMzk2MTgyMjkxLDE2OTUxODM3MDAsMTk4NjY2MTA1MSwyMTc3MDI2MzUwLDI0NTY5NTYwMzcsMjczMDQ4NTkyMSwyODIwMzAyNDExLDMyNTk3MzA4MDAsMzM0NTc2NDc3MSwzNTE2MDY1ODE3LDM2MDAzNTI4MDQsNDA5NDU3MTkwOSwyNzU0MjMzNDQsNDMwMjI3NzM0LDUwNjk0ODYxNiw2NTkwNjA1NTYsODgzOTk3ODc3LDk1ODEzOTU3MSwxMzIyODIyMjE4LDE1MzcwMDIwNjMsMTc0Nzg3Mzc3OSwxOTU1NTYyMjIyLDIwMjQxMDQ4MTUsMjIyNzczMDQ1MiwyMzYxODUyNDI0LDI0Mjg0MzY0NzQsMjc1NjczNDE4NywzMjA0MDMxNDc5LDMzMjkzMjUyOThdKTtsZXQgaDA9MTc3OTAzMzcwMyxoMT0zMTQ0MTM0Mjc3LGgyPTEwMTM5MDQyNDIsaDM9Mjc3MzQ4MDc2MjtsZXQgaDQ9MTM1OTg5MzExOSxoNT0yNjAwODIyOTI0LGg2PTUyODczNDYzNSxoNz0xNTQxNDU5MjI1O2NvbnN0IHc9bmV3IFVpbnQzMkFycmF5KDY0KTtmdW5jdGlvbiBibG9ja3MocCl7bGV0IG9mZj0wLGxlbj1wLmxlbmd0aDt3aGlsZShsZW4+PTY0KXtsZXQgYT1oMCxiPWgxLGM9aDIsZD1oMyxlPWg0LGY9aDUsZz1oNixoPWg3LHUsaSxqLHQxLHQyO2ZvcihpPTA7aTwxNjtpKyspe2o9b2ZmK2kqNDt3W2ldPShwW2pdJjI1NSk8PDI0fChwW2orMV0mMjU1KTw8MTZ8KHBbaisyXSYyNTUpPDw4fHBbaiszXSYyNTV9Zm9yKGk9MTY7aTw2NDtpKyspe3U9d1tpLTJdO3QxPSh1Pj4+MTd8dTw8MzItMTcpXih1Pj4+MTl8dTw8MzItMTkpXnU+Pj4xMDt1PXdbaS0xNV07dDI9KHU+Pj43fHU8PDMyLTcpXih1Pj4+MTh8dTw8MzItMTgpXnU+Pj4zO3dbaV09KHQxK3dbaS03XXwwKSsodDIrd1tpLTE2XXwwKXwwfWZvcihpPTA7aTw2NDtpKyspe3QxPSgoKGU+Pj42fGU8PDMyLTYpXihlPj4+MTF8ZTw8MzItMTEpXihlPj4+MjV8ZTw8MzItMjUpKSsoZSZmXn5lJmcpfDApKyhoKyhLW2ldK3dbaV18MCl8MCl8MDt0Mj0oKGE+Pj4yfGE8PDMyLTIpXihhPj4+MTN8YTw8MzItMTMpXihhPj4+MjJ8YTw8MzItMjIpKSsoYSZiXmEmY15iJmMpfDA7aD1nO2c9ZjtmPWU7ZT1kK3QxfDA7ZD1jO2M9YjtiPWE7YT10MSt0MnwwfWgwPWgwK2F8MDtoMT1oMStifDA7aDI9aDIrY3wwO2gzPWgzK2R8MDtoND1oNCtlfDA7aDU9aDUrZnwwO2g2PWg2K2d8MDtoNz1oNytofDA7b2ZmKz02NDtsZW4tPTY0fX1ibG9ja3MobSk7bGV0IGksYnl0ZXNMZWZ0PW0ubGVuZ3RoJTY0LGJpdExlbkhpPW0ubGVuZ3RoLzUzNjg3MDkxMnwwLGJpdExlbkxvPW0ubGVuZ3RoPDwzLG51bVplcm9zPWJ5dGVzTGVmdDw1Nj81NjoxMjAscD1tLnNsaWNlKG0ubGVuZ3RoLWJ5dGVzTGVmdCxtLmxlbmd0aCk7cC5wdXNoKDEyOCk7Zm9yKGk9Ynl0ZXNMZWZ0KzE7aTxudW1aZXJvcztpKyspe3AucHVzaCgwKX1wLnB1c2goYml0TGVuSGk+Pj4yNCYyNTUpO3AucHVzaChiaXRMZW5IaT4+PjE2JjI1NSk7cC5wdXNoKGJpdExlbkhpPj4+OCYyNTUpO3AucHVzaChiaXRMZW5IaT4+PjAmMjU1KTtwLnB1c2goYml0TGVuTG8+Pj4yNCYyNTUpO3AucHVzaChiaXRMZW5Mbz4+PjE2JjI1NSk7cC5wdXNoKGJpdExlbkxvPj4+OCYyNTUpO3AucHVzaChiaXRMZW5Mbz4+PjAmMjU1KTtibG9ja3MocCk7cmV0dXJuW2gwPj4+MjQmMjU1LGgwPj4+MTYmMjU1LGgwPj4+OCYyNTUsaDA+Pj4wJjI1NSxoMT4+PjI0JjI1NSxoMT4+PjE2JjI1NSxoMT4+PjgmMjU1LGgxPj4+MCYyNTUsaDI+Pj4yNCYyNTUsaDI+Pj4xNiYyNTUsaDI+Pj44JjI1NSxoMj4+PjAmMjU1LGgzPj4+MjQmMjU1LGgzPj4+MTYmMjU1LGgzPj4+OCYyNTUsaDM+Pj4wJjI1NSxoND4+PjI0JjI1NSxoND4+PjE2JjI1NSxoND4+PjgmMjU1LGg0Pj4+MCYyNTUsaDU+Pj4yNCYyNTUsaDU+Pj4xNiYyNTUsaDU+Pj44JjI1NSxoNT4+PjAmMjU1LGg2Pj4+MjQmMjU1LGg2Pj4+MTYmMjU1LGg2Pj4+OCYyNTUsaDY+Pj4wJjI1NSxoNz4+PjI0JjI1NSxoNz4+PjE2JjI1NSxoNz4+PjgmMjU1LGg3Pj4+MCYyNTVdfWZ1bmN0aW9uIFBCS0RGMl9ITUFDX1NIQTI1Nl9PbmVJdGVyKHBhc3N3b3JkLHNhbHQsZGtMZW4pe3Bhc3N3b3JkPXBhc3N3b3JkLmxlbmd0aDw9NjQ/cGFzc3dvcmQ6U0hBMjU2KHBhc3N3b3JkKTtjb25zdCBpbm5lckxlbj02NCtzYWx0Lmxlbmd0aCs0O2NvbnN0IGlubmVyPW5ldyBBcnJheShpbm5lckxlbik7Y29uc3Qgb3V0ZXJLZXk9bmV3IEFycmF5KDY0KTtsZXQgaTtsZXQgZGs9W107Zm9yKGk9MDtpPDY0O2krKyl7aW5uZXJbaV09NTR9Zm9yKGk9MDtpPHBhc3N3b3JkLmxlbmd0aDtpKyspe2lubmVyW2ldXj1wYXNzd29yZFtpXX1mb3IoaT0wO2k8c2FsdC5sZW5ndGg7aSsrKXtpbm5lcls2NCtpXT1zYWx0W2ldfWZvcihpPWlubmVyTGVuLTQ7aTxpbm5lckxlbjtpKyspe2lubmVyW2ldPTB9Zm9yKGk9MDtpPDY0O2krKylvdXRlcktleVtpXT05Mjtmb3IoaT0wO2k8cGFzc3dvcmQubGVuZ3RoO2krKylvdXRlcktleVtpXV49cGFzc3dvcmRbaV07ZnVuY3Rpb24gaW5jcmVtZW50Q291bnRlcigpe2ZvcihsZXQgaT1pbm5lckxlbi0xO2k+PWlubmVyTGVuLTQ7aS0tKXtpbm5lcltpXSsrO2lmKGlubmVyW2ldPD0yNTUpcmV0dXJuO2lubmVyW2ldPTB9fXdoaWxlKGRrTGVuPj0zMil7aW5jcmVtZW50Q291bnRlcigpO2RrPWRrLmNvbmNhdChTSEEyNTYob3V0ZXJLZXkuY29uY2F0KFNIQTI1Nihpbm5lcikpKSk7ZGtMZW4tPTMyfWlmKGRrTGVuPjApe2luY3JlbWVudENvdW50ZXIoKTtkaz1kay5jb25jYXQoU0hBMjU2KG91dGVyS2V5LmNvbmNhdChTSEEyNTYoaW5uZXIpKSkuc2xpY2UoMCxka0xlbikpfXJldHVybiBka31mdW5jdGlvbiBibG9ja21peF9zYWxzYTgoQlksWWkscix4LF9YKXtsZXQgaTthcnJheWNvcHkoQlksKDIqci0xKSoxNixfWCwwLDE2KTtmb3IoaT0wO2k8MipyO2krKyl7YmxvY2t4b3IoQlksaSoxNixfWCwxNik7c2Fsc2EyMF84KF9YLHgpO2FycmF5Y29weShfWCwwLEJZLFlpK2kqMTYsMTYpfWZvcihpPTA7aTxyO2krKyl7YXJyYXljb3B5KEJZLFlpK2kqMioxNixCWSxpKjE2LDE2KX1mb3IoaT0wO2k8cjtpKyspe2FycmF5Y29weShCWSxZaSsoaSoyKzEpKjE2LEJZLChpK3IpKjE2LDE2KX19ZnVuY3Rpb24gUihhLGIpe3JldHVybiBhPDxifGE+Pj4zMi1ifWZ1bmN0aW9uIHNhbHNhMjBfOChCLHgpe2FycmF5Y29weShCLDAseCwwLDE2KTtmb3IobGV0IGk9ODtpPjA7aS09Mil7eFs0XV49Uih4WzBdK3hbMTJdLDcpO3hbOF1ePVIoeFs0XSt4WzBdLDkpO3hbMTJdXj1SKHhbOF0reFs0XSwxMyk7eFswXV49Uih4WzEyXSt4WzhdLDE4KTt4WzldXj1SKHhbNV0reFsxXSw3KTt4WzEzXV49Uih4WzldK3hbNV0sOSk7eFsxXV49Uih4WzEzXSt4WzldLDEzKTt4WzVdXj1SKHhbMV0reFsxM10sMTgpO3hbMTRdXj1SKHhbMTBdK3hbNl0sNyk7eFsyXV49Uih4WzE0XSt4WzEwXSw5KTt4WzZdXj1SKHhbMl0reFsxNF0sMTMpO3hbMTBdXj1SKHhbNl0reFsyXSwxOCk7eFszXV49Uih4WzE1XSt4WzExXSw3KTt4WzddXj1SKHhbM10reFsxNV0sOSk7eFsxMV1ePVIoeFs3XSt4WzNdLDEzKTt4WzE1XV49Uih4WzExXSt4WzddLDE4KTt4WzFdXj1SKHhbMF0reFszXSw3KTt4WzJdXj1SKHhbMV0reFswXSw5KTt4WzNdXj1SKHhbMl0reFsxXSwxMyk7eFswXV49Uih4WzNdK3hbMl0sMTgpO3hbNl1ePVIoeFs1XSt4WzRdLDcpO3hbN11ePVIoeFs2XSt4WzVdLDkpO3hbNF1ePVIoeFs3XSt4WzZdLDEzKTt4WzVdXj1SKHhbNF0reFs3XSwxOCk7eFsxMV1ePVIoeFsxMF0reFs5XSw3KTt4WzhdXj1SKHhbMTFdK3hbMTBdLDkpO3hbOV1ePVIoeFs4XSt4WzExXSwxMyk7eFsxMF1ePVIoeFs5XSt4WzhdLDE4KTt4WzEyXV49Uih4WzE1XSt4WzE0XSw3KTt4WzEzXV49Uih4WzEyXSt4WzE1XSw5KTt4WzE0XV49Uih4WzEzXSt4WzEyXSwxMyk7eFsxNV1ePVIoeFsxNF0reFsxM10sMTgpfWZvcihsZXQgaT0wO2k8MTY7KytpKXtCW2ldKz14W2ldfX1mdW5jdGlvbiBibG9ja3hvcihTLFNpLEQsbGVuKXtmb3IobGV0IGk9MDtpPGxlbjtpKyspe0RbaV1ePVNbU2kraV19fWZ1bmN0aW9uIGFycmF5Y29weShzcmMsc3JjUG9zLGRlc3QsZGVzdFBvcyxsZW5ndGgpe3doaWxlKGxlbmd0aC0tKXtkZXN0W2Rlc3RQb3MrK109c3JjW3NyY1BvcysrXX19ZnVuY3Rpb24gY2hlY2tCdWZmZXJpc2gobyl7aWYoIW98fHR5cGVvZiBvLmxlbmd0aCE9PVwibnVtYmVyXCIpe3JldHVybiBmYWxzZX1mb3IobGV0IGk9MDtpPG8ubGVuZ3RoO2krKyl7Y29uc3Qgdj1vW2ldO2lmKHR5cGVvZiB2IT09XCJudW1iZXJcInx8diUxfHx2PDB8fHY+PTI1Nil7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiBlbnN1cmVJbnRlZ2VyKHZhbHVlLG5hbWUpe2lmKHR5cGVvZiB2YWx1ZSE9PVwibnVtYmVyXCJ8fHZhbHVlJTEpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgXCIrbmFtZSl9cmV0dXJuIHZhbHVlfWZ1bmN0aW9uIF9zY3J5cHQocGFzc3dvcmQsc2FsdCxOLHIscCxka0xlbixjYWxsYmFjayl7Tj1lbnN1cmVJbnRlZ2VyKE4sXCJOXCIpO3I9ZW5zdXJlSW50ZWdlcihyLFwiclwiKTtwPWVuc3VyZUludGVnZXIocCxcInBcIik7ZGtMZW49ZW5zdXJlSW50ZWdlcihka0xlbixcImRrTGVuXCIpO2lmKE49PT0wfHwoTiZOLTEpIT09MCl7dGhyb3cgbmV3IEVycm9yKFwiTiBtdXN0IGJlIHBvd2VyIG9mIDJcIil9aWYoTj5NQVhfVkFMVUUvMTI4L3Ipe3Rocm93IG5ldyBFcnJvcihcIk4gdG9vIGxhcmdlXCIpfWlmKHI+TUFYX1ZBTFVFLzEyOC9wKXt0aHJvdyBuZXcgRXJyb3IoXCJyIHRvbyBsYXJnZVwiKX1pZighY2hlY2tCdWZmZXJpc2gocGFzc3dvcmQpKXt0aHJvdyBuZXcgRXJyb3IoXCJwYXNzd29yZCBtdXN0IGJlIGFuIGFycmF5IG9yIGJ1ZmZlclwiKX1wYXNzd29yZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXNzd29yZCk7aWYoIWNoZWNrQnVmZmVyaXNoKHNhbHQpKXt0aHJvdyBuZXcgRXJyb3IoXCJzYWx0IG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyXCIpfXNhbHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2FsdCk7bGV0IGI9UEJLREYyX0hNQUNfU0hBMjU2X09uZUl0ZXIocGFzc3dvcmQsc2FsdCxwKjEyOCpyKTtjb25zdCBCPW5ldyBVaW50MzJBcnJheShwKjMyKnIpO2ZvcihsZXQgaT0wO2k8Qi5sZW5ndGg7aSsrKXtjb25zdCBqPWkqNDtCW2ldPShiW2orM10mMjU1KTw8MjR8KGJbaisyXSYyNTUpPDwxNnwoYltqKzFdJjI1NSk8PDh8KGJbaiswXSYyNTUpPDwwfWNvbnN0IFhZPW5ldyBVaW50MzJBcnJheSg2NCpyKTtjb25zdCBWPW5ldyBVaW50MzJBcnJheSgzMipyKk4pO2NvbnN0IFlpPTMyKnI7Y29uc3QgeD1uZXcgVWludDMyQXJyYXkoMTYpO2NvbnN0IF9YPW5ldyBVaW50MzJBcnJheSgxNik7Y29uc3QgdG90YWxPcHM9cCpOKjI7bGV0IGN1cnJlbnRPcD0wO2xldCBsYXN0UGVyY2VudDEwPW51bGw7bGV0IHN0b3A9ZmFsc2U7bGV0IHN0YXRlPTA7bGV0IGkwPTAsaTE7bGV0IEJpO2NvbnN0IGxpbWl0PWNhbGxiYWNrP3BhcnNlSW50KDFlMy9yKTo0Mjk0OTY3Mjk1O2NvbnN0IG5leHRUaWNrPXR5cGVvZiBzZXRJbW1lZGlhdGUhPT1cInVuZGVmaW5lZFwiP3NldEltbWVkaWF0ZTpzZXRUaW1lb3V0O2NvbnN0IGluY3JlbWVudGFsU01peD1mdW5jdGlvbigpe2lmKHN0b3Ape3JldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJjYW5jZWxsZWRcIiksY3VycmVudE9wL3RvdGFsT3BzKX1sZXQgc3RlcHM7c3dpdGNoKHN0YXRlKXtjYXNlIDA6Qmk9aTAqMzIqcjthcnJheWNvcHkoQixCaSxYWSwwLFlpKTtzdGF0ZT0xO2kxPTA7Y2FzZSAxOnN0ZXBzPU4taTE7aWYoc3RlcHM+bGltaXQpe3N0ZXBzPWxpbWl0fWZvcihsZXQgaT0wO2k8c3RlcHM7aSsrKXthcnJheWNvcHkoWFksMCxWLChpMStpKSpZaSxZaSk7YmxvY2ttaXhfc2Fsc2E4KFhZLFlpLHIseCxfWCl9aTErPXN0ZXBzO2N1cnJlbnRPcCs9c3RlcHM7aWYoY2FsbGJhY2spe2NvbnN0IHBlcmNlbnQxMD1wYXJzZUludCgxZTMqY3VycmVudE9wL3RvdGFsT3BzKTtpZihwZXJjZW50MTAhPT1sYXN0UGVyY2VudDEwKXtzdG9wPWNhbGxiYWNrKG51bGwsY3VycmVudE9wL3RvdGFsT3BzKTtpZihzdG9wKXticmVha31sYXN0UGVyY2VudDEwPXBlcmNlbnQxMH19aWYoaTE8Til7YnJlYWt9aTE9MDtzdGF0ZT0yO2Nhc2UgMjpzdGVwcz1OLWkxO2lmKHN0ZXBzPmxpbWl0KXtzdGVwcz1saW1pdH1mb3IobGV0IGk9MDtpPHN0ZXBzO2krKyl7Y29uc3Qgb2Zmc2V0PSgyKnItMSkqMTY7Y29uc3Qgaj1YWVtvZmZzZXRdJk4tMTtibG9ja3hvcihWLGoqWWksWFksWWkpO2Jsb2NrbWl4X3NhbHNhOChYWSxZaSxyLHgsX1gpfWkxKz1zdGVwcztjdXJyZW50T3ArPXN0ZXBzO2lmKGNhbGxiYWNrKXtjb25zdCBwZXJjZW50MTA9cGFyc2VJbnQoMWUzKmN1cnJlbnRPcC90b3RhbE9wcyk7aWYocGVyY2VudDEwIT09bGFzdFBlcmNlbnQxMCl7c3RvcD1jYWxsYmFjayhudWxsLGN1cnJlbnRPcC90b3RhbE9wcyk7aWYoc3RvcCl7YnJlYWt9bGFzdFBlcmNlbnQxMD1wZXJjZW50MTB9fWlmKGkxPE4pe2JyZWFrfWFycmF5Y29weShYWSwwLEIsQmksWWkpO2kwKys7aWYoaTA8cCl7c3RhdGU9MDticmVha31iPVtdO2ZvcihsZXQgaT0wO2k8Qi5sZW5ndGg7aSsrKXtiLnB1c2goQltpXT4+MCYyNTUpO2IucHVzaChCW2ldPj44JjI1NSk7Yi5wdXNoKEJbaV0+PjE2JjI1NSk7Yi5wdXNoKEJbaV0+PjI0JjI1NSl9Y29uc3QgZGVyaXZlZEtleT1QQktERjJfSE1BQ19TSEEyNTZfT25lSXRlcihwYXNzd29yZCxiLGRrTGVuKTtpZihjYWxsYmFjayl7Y2FsbGJhY2sobnVsbCwxLGRlcml2ZWRLZXkpfXJldHVybiBkZXJpdmVkS2V5fWlmKGNhbGxiYWNrKXtuZXh0VGljayhpbmNyZW1lbnRhbFNNaXgpfX07aWYoIWNhbGxiYWNrKXt3aGlsZSh0cnVlKXtjb25zdCBkZXJpdmVkS2V5PWluY3JlbWVudGFsU01peCgpO2lmKGRlcml2ZWRLZXkhPXVuZGVmaW5lZCl7cmV0dXJuIGRlcml2ZWRLZXl9fX1pbmNyZW1lbnRhbFNNaXgoKX1jb25zdCBsaWI9e3NjcnlwdDpmdW5jdGlvbihwYXNzd29yZCxzYWx0LE4scixwLGRrTGVuLHByb2dyZXNzQ2FsbGJhY2spe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7bGV0IGxhc3RQcm9ncmVzcz0wO2lmKHByb2dyZXNzQ2FsbGJhY2spe3Byb2dyZXNzQ2FsbGJhY2soMCl9X3NjcnlwdChwYXNzd29yZCxzYWx0LE4scixwLGRrTGVuLGZ1bmN0aW9uKGVycm9yLHByb2dyZXNzLGtleSl7aWYoZXJyb3Ipe3JlamVjdChlcnJvcil9ZWxzZSBpZihrZXkpe2lmKHByb2dyZXNzQ2FsbGJhY2smJmxhc3RQcm9ncmVzcyE9PTEpe3Byb2dyZXNzQ2FsbGJhY2soMSl9cmVzb2x2ZShuZXcgVWludDhBcnJheShrZXkpKX1lbHNlIGlmKHByb2dyZXNzQ2FsbGJhY2smJnByb2dyZXNzIT09bGFzdFByb2dyZXNzKXtsYXN0UHJvZ3Jlc3M9cHJvZ3Jlc3M7cmV0dXJuIHByb2dyZXNzQ2FsbGJhY2socHJvZ3Jlc3MpfX0pfSl9LHN5bmNTY3J5cHQ6ZnVuY3Rpb24ocGFzc3dvcmQsc2FsdCxOLHIscCxka0xlbil7cmV0dXJuIG5ldyBVaW50OEFycmF5KF9zY3J5cHQocGFzc3dvcmQsc2FsdCxOLHIscCxka0xlbikpfX07aWYoXCJvYmplY3RcIiE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWxpYn1lbHNlIGlmKHR5cGVvZiB1bmRlZmluZWQ9PT1cImZ1bmN0aW9uXCImJnVuZGVmaW5lZC5hbWQpe3VuZGVmaW5lZChsaWIpfWVsc2UgaWYocm9vdCl7aWYocm9vdC5zY3J5cHQpe3Jvb3QuX3NjcnlwdD1yb290LnNjcnlwdH1yb290LnNjcnlwdD1saWJ9fSkoY29tbW9uanNHbG9iYWwpfSk7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciQ0PXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkbz1uZXcgTG9nZ2VyKHZlcnNpb24kaSk7ZnVuY3Rpb24gaGFzTW5lbW9uaWModmFsdWUpe3JldHVybiB2YWx1ZSE9bnVsbCYmdmFsdWUubW5lbW9uaWMmJnZhbHVlLm1uZW1vbmljLnBocmFzZX1jbGFzcyBLZXlzdG9yZUFjY291bnQgZXh0ZW5kcyBEZXNjcmlwdGlvbntpc0tleXN0b3JlQWNjb3VudCh2YWx1ZSl7cmV0dXJuISEodmFsdWUmJnZhbHVlLl9pc0tleXN0b3JlQWNjb3VudCl9fWZ1bmN0aW9uIF9kZWNyeXB0KGRhdGEsa2V5LGNpcGhlcnRleHQpe2NvbnN0IGNpcGhlcj1zZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8vY2lwaGVyXCIpO2lmKGNpcGhlcj09PVwiYWVzLTEyOC1jdHJcIil7Y29uc3QgaXY9bG9vc2VBcnJheWlmeShzZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8vY2lwaGVycGFyYW1zL2l2XCIpKTtjb25zdCBjb3VudGVyPW5ldyBhZXNKcy5Db3VudGVyKGl2KTtjb25zdCBhZXNDdHI9bmV3IGFlc0pzLk1vZGVPZk9wZXJhdGlvbi5jdHIoa2V5LGNvdW50ZXIpO3JldHVybiBhcnJheWlmeShhZXNDdHIuZGVjcnlwdChjaXBoZXJ0ZXh0KSl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gX2dldEFjY291bnQoZGF0YSxrZXkpe2NvbnN0IGNpcGhlcnRleHQ9bG9vc2VBcnJheWlmeShzZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8vY2lwaGVydGV4dFwiKSk7Y29uc3QgY29tcHV0ZWRNQUM9aGV4bGlmeShrZWNjYWsyNTYoY29uY2F0KFtrZXkuc2xpY2UoMTYsMzIpLGNpcGhlcnRleHRdKSkpLnN1YnN0cmluZygyKTtpZihjb21wdXRlZE1BQyE9PXNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9tYWNcIikudG9Mb3dlckNhc2UoKSl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXNzd29yZFwiKX1jb25zdCBwcml2YXRlS2V5PV9kZWNyeXB0KGRhdGEsa2V5LnNsaWNlKDAsMTYpLGNpcGhlcnRleHQpO2lmKCFwcml2YXRlS2V5KXtsb2dnZXIkby50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgY2lwaGVyXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImRlY3J5cHRcIn0pfWNvbnN0IG1uZW1vbmljS2V5PWtleS5zbGljZSgzMiw2NCk7Y29uc3QgYWRkcmVzcz1jb21wdXRlQWRkcmVzcyhwcml2YXRlS2V5KTtpZihkYXRhLmFkZHJlc3Mpe2xldCBjaGVjaz1kYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtpZihjaGVjay5zdWJzdHJpbmcoMCwyKSE9PVwiMHhcIil7Y2hlY2s9XCIweFwiK2NoZWNrfWlmKGdldEFkZHJlc3MoY2hlY2spIT09YWRkcmVzcyl7dGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcyBtaXNtYXRjaFwiKX19Y29uc3QgYWNjb3VudD17X2lzS2V5c3RvcmVBY2NvdW50OnRydWUsYWRkcmVzczphZGRyZXNzLHByaXZhdGVLZXk6aGV4bGlmeShwcml2YXRlS2V5KX07aWYoc2VhcmNoUGF0aChkYXRhLFwieC1ldGhlcnMvdmVyc2lvblwiKT09PVwiMC4xXCIpe2NvbnN0IG1uZW1vbmljQ2lwaGVydGV4dD1sb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSxcIngtZXRoZXJzL21uZW1vbmljQ2lwaGVydGV4dFwiKSk7Y29uc3QgbW5lbW9uaWNJdj1sb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSxcIngtZXRoZXJzL21uZW1vbmljQ291bnRlclwiKSk7Y29uc3QgbW5lbW9uaWNDb3VudGVyPW5ldyBhZXNKcy5Db3VudGVyKG1uZW1vbmljSXYpO2NvbnN0IG1uZW1vbmljQWVzQ3RyPW5ldyBhZXNKcy5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LG1uZW1vbmljQ291bnRlcik7Y29uc3QgcGF0aD1zZWFyY2hQYXRoKGRhdGEsXCJ4LWV0aGVycy9wYXRoXCIpfHxkZWZhdWx0UGF0aDtjb25zdCBsb2NhbGU9c2VhcmNoUGF0aChkYXRhLFwieC1ldGhlcnMvbG9jYWxlXCIpfHxcImVuXCI7Y29uc3QgZW50cm9weT1hcnJheWlmeShtbmVtb25pY0Flc0N0ci5kZWNyeXB0KG1uZW1vbmljQ2lwaGVydGV4dCkpO3RyeXtjb25zdCBtbmVtb25pYz1lbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LGxvY2FsZSk7Y29uc3Qgbm9kZT1IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLG51bGwsbG9jYWxlKS5kZXJpdmVQYXRoKHBhdGgpO2lmKG5vZGUucHJpdmF0ZUtleSE9YWNjb3VudC5wcml2YXRlS2V5KXt0aHJvdyBuZXcgRXJyb3IoXCJtbmVtb25pYyBtaXNtYXRjaFwiKX1hY2NvdW50Lm1uZW1vbmljPW5vZGUubW5lbW9uaWN9Y2F0Y2goZXJyb3Ipe2lmKGVycm9yLmNvZGUhPT1Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlR8fGVycm9yLmFyZ3VtZW50IT09XCJ3b3JkbGlzdFwiKXt0aHJvdyBlcnJvcn19fXJldHVybiBuZXcgS2V5c3RvcmVBY2NvdW50KGFjY291bnQpfWZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcyxzYWx0LGNvdW50LGRrTGVuLHByZkZ1bmMpe3JldHVybiBhcnJheWlmeShwYmtkZjIocGFzc3dvcmRCeXRlcyxzYWx0LGNvdW50LGRrTGVuLHByZkZ1bmMpKX1mdW5jdGlvbiBwYmtkZjIkMShwYXNzd29yZEJ5dGVzLHNhbHQsY291bnQsZGtMZW4scHJmRnVuYyl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShwYmtkZjJTeW5jKHBhc3N3b3JkQnl0ZXMsc2FsdCxjb3VudCxka0xlbixwcmZGdW5jKSl9ZnVuY3Rpb24gX2NvbXB1dGVLZGZLZXkoZGF0YSxwYXNzd29yZCxwYmtkZjJGdW5jLHNjcnlwdEZ1bmMscHJvZ3Jlc3NDYWxsYmFjayl7Y29uc3QgcGFzc3dvcmRCeXRlcz1nZXRQYXNzd29yZChwYXNzd29yZCk7Y29uc3Qga2RmPXNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9rZGZcIik7aWYoa2RmJiZ0eXBlb2Yga2RmPT09XCJzdHJpbmdcIil7Y29uc3QgdGhyb3dFcnJvcj1mdW5jdGlvbihuYW1lLHZhbHVlKXtyZXR1cm4gbG9nZ2VyJG8udGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXCIsbmFtZSx2YWx1ZSl9O2lmKGtkZi50b0xvd2VyQ2FzZSgpPT09XCJzY3J5cHRcIil7Y29uc3Qgc2FsdD1sb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSk7Y29uc3QgTj1wYXJzZUludChzZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8va2RmcGFyYW1zL25cIikpO2NvbnN0IHI9cGFyc2VJbnQoc2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9yXCIpKTtjb25zdCBwPXBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9rZGZwYXJhbXMvcFwiKSk7aWYoIU58fCFyfHwhcCl7dGhyb3dFcnJvcihcImtkZlwiLGtkZil9aWYoKE4mTi0xKSE9PTApe3Rocm93RXJyb3IoXCJOXCIsTil9Y29uc3QgZGtMZW49cGFyc2VJbnQoc2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9ka2xlblwiKSk7aWYoZGtMZW4hPT0zMil7dGhyb3dFcnJvcihcImRrbGVuXCIsZGtMZW4pfXJldHVybiBzY3J5cHRGdW5jKHBhc3N3b3JkQnl0ZXMsc2FsdCxOLHIscCw2NCxwcm9ncmVzc0NhbGxiYWNrKX1lbHNlIGlmKGtkZi50b0xvd2VyQ2FzZSgpPT09XCJwYmtkZjJcIil7Y29uc3Qgc2FsdD1sb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSk7bGV0IHByZkZ1bmM9bnVsbDtjb25zdCBwcmY9c2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9wcmZcIik7aWYocHJmPT09XCJobWFjLXNoYTI1NlwiKXtwcmZGdW5jPVwic2hhMjU2XCJ9ZWxzZSBpZihwcmY9PT1cImhtYWMtc2hhNTEyXCIpe3ByZkZ1bmM9XCJzaGE1MTJcIn1lbHNle3Rocm93RXJyb3IoXCJwcmZcIixwcmYpfWNvbnN0IGNvdW50PXBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9rZGZwYXJhbXMvY1wiKSk7Y29uc3QgZGtMZW49cGFyc2VJbnQoc2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9ka2xlblwiKSk7aWYoZGtMZW4hPT0zMil7dGhyb3dFcnJvcihcImRrbGVuXCIsZGtMZW4pfXJldHVybiBwYmtkZjJGdW5jKHBhc3N3b3JkQnl0ZXMsc2FsdCxjb3VudCxka0xlbixwcmZGdW5jKX19cmV0dXJuIGxvZ2dlciRvLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsXCJrZGZcIixrZGYpfWZ1bmN0aW9uIGRlY3J5cHRTeW5jKGpzb24scGFzc3dvcmQpe2NvbnN0IGRhdGE9SlNPTi5wYXJzZShqc29uKTtjb25zdCBrZXk9X2NvbXB1dGVLZGZLZXkoZGF0YSxwYXNzd29yZCxwYmtkZjJTeW5jLHNjcnlwdC5zeW5jU2NyeXB0KTtyZXR1cm4gX2dldEFjY291bnQoZGF0YSxrZXkpfWZ1bmN0aW9uIGRlY3J5cHQkMShqc29uLHBhc3N3b3JkLHByb2dyZXNzQ2FsbGJhY2spe3JldHVybiBfX2F3YWl0ZXIkNCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgZGF0YT1KU09OLnBhcnNlKGpzb24pO2NvbnN0IGtleT15aWVsZCBfY29tcHV0ZUtkZktleShkYXRhLHBhc3N3b3JkLHBia2RmMiQxLHNjcnlwdC5zY3J5cHQscHJvZ3Jlc3NDYWxsYmFjayk7cmV0dXJuIF9nZXRBY2NvdW50KGRhdGEsa2V5KX0pfWZ1bmN0aW9uIGVuY3J5cHQoYWNjb3VudCxwYXNzd29yZCxvcHRpb25zLHByb2dyZXNzQ2FsbGJhY2spe3RyeXtpZihnZXRBZGRyZXNzKGFjY291bnQuYWRkcmVzcykhPT1jb21wdXRlQWRkcmVzcyhhY2NvdW50LnByaXZhdGVLZXkpKXt0aHJvdyBuZXcgRXJyb3IoXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIil9aWYoaGFzTW5lbW9uaWMoYWNjb3VudCkpe2NvbnN0IG1uZW1vbmljPWFjY291bnQubW5lbW9uaWM7Y29uc3Qgbm9kZT1IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLnBocmFzZSxudWxsLG1uZW1vbmljLmxvY2FsZSkuZGVyaXZlUGF0aChtbmVtb25pYy5wYXRofHxkZWZhdWx0UGF0aCk7aWYobm9kZS5wcml2YXRlS2V5IT1hY2NvdW50LnByaXZhdGVLZXkpe3Rocm93IG5ldyBFcnJvcihcIm1uZW1vbmljIG1pc21hdGNoXCIpfX19Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfWlmKHR5cGVvZiBvcHRpb25zPT09XCJmdW5jdGlvblwiJiYhcHJvZ3Jlc3NDYWxsYmFjayl7cHJvZ3Jlc3NDYWxsYmFjaz1vcHRpb25zO29wdGlvbnM9e319aWYoIW9wdGlvbnMpe29wdGlvbnM9e319Y29uc3QgcHJpdmF0ZUtleT1hcnJheWlmeShhY2NvdW50LnByaXZhdGVLZXkpO2NvbnN0IHBhc3N3b3JkQnl0ZXM9Z2V0UGFzc3dvcmQocGFzc3dvcmQpO2xldCBlbnRyb3B5PW51bGw7bGV0IHBhdGg9bnVsbDtsZXQgbG9jYWxlPW51bGw7aWYoaGFzTW5lbW9uaWMoYWNjb3VudCkpe2NvbnN0IHNyY01uZW1vbmljPWFjY291bnQubW5lbW9uaWM7ZW50cm9weT1hcnJheWlmeShtbmVtb25pY1RvRW50cm9weShzcmNNbmVtb25pYy5waHJhc2Usc3JjTW5lbW9uaWMubG9jYWxlfHxcImVuXCIpKTtwYXRoPXNyY01uZW1vbmljLnBhdGh8fGRlZmF1bHRQYXRoO2xvY2FsZT1zcmNNbmVtb25pYy5sb2NhbGV8fFwiZW5cIn1sZXQgY2xpZW50PW9wdGlvbnMuY2xpZW50O2lmKCFjbGllbnQpe2NsaWVudD1cImV0aGVycy5qc1wifWxldCBzYWx0PW51bGw7aWYob3B0aW9ucy5zYWx0KXtzYWx0PWFycmF5aWZ5KG9wdGlvbnMuc2FsdCl9ZWxzZXtzYWx0PXJhbmRvbUJ5dGVzKDMyKX1sZXQgaXY9bnVsbDtpZihvcHRpb25zLml2KXtpdj1hcnJheWlmeShvcHRpb25zLml2KTtpZihpdi5sZW5ndGghPT0xNil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdlwiKX19ZWxzZXtpdj1yYW5kb21CeXRlcygxNil9bGV0IHV1aWRSYW5kb209bnVsbDtpZihvcHRpb25zLnV1aWQpe3V1aWRSYW5kb209YXJyYXlpZnkob3B0aW9ucy51dWlkKTtpZih1dWlkUmFuZG9tLmxlbmd0aCE9PTE2KXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV1aWRcIil9fWVsc2V7dXVpZFJhbmRvbT1yYW5kb21CeXRlcygxNil9bGV0IE49MTw8MTcscj04LHA9MTtpZihvcHRpb25zLnNjcnlwdCl7aWYob3B0aW9ucy5zY3J5cHQuTil7Tj1vcHRpb25zLnNjcnlwdC5OfWlmKG9wdGlvbnMuc2NyeXB0LnIpe3I9b3B0aW9ucy5zY3J5cHQucn1pZihvcHRpb25zLnNjcnlwdC5wKXtwPW9wdGlvbnMuc2NyeXB0LnB9fXJldHVybiBzY3J5cHQuc2NyeXB0KHBhc3N3b3JkQnl0ZXMsc2FsdCxOLHIscCw2NCxwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGtleT0+e2tleT1hcnJheWlmeShrZXkpO2NvbnN0IGRlcml2ZWRLZXk9a2V5LnNsaWNlKDAsMTYpO2NvbnN0IG1hY1ByZWZpeD1rZXkuc2xpY2UoMTYsMzIpO2NvbnN0IG1uZW1vbmljS2V5PWtleS5zbGljZSgzMiw2NCk7Y29uc3QgY291bnRlcj1uZXcgYWVzSnMuQ291bnRlcihpdik7Y29uc3QgYWVzQ3RyPW5ldyBhZXNKcy5Nb2RlT2ZPcGVyYXRpb24uY3RyKGRlcml2ZWRLZXksY291bnRlcik7Y29uc3QgY2lwaGVydGV4dD1hcnJheWlmeShhZXNDdHIuZW5jcnlwdChwcml2YXRlS2V5KSk7Y29uc3QgbWFjPWtlY2NhazI1Nihjb25jYXQoW21hY1ByZWZpeCxjaXBoZXJ0ZXh0XSkpO2NvbnN0IGRhdGE9e2FkZHJlc3M6YWNjb3VudC5hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLGlkOnV1aWRWNCh1dWlkUmFuZG9tKSx2ZXJzaW9uOjMsQ3J5cHRvOntjaXBoZXI6XCJhZXMtMTI4LWN0clwiLGNpcGhlcnBhcmFtczp7aXY6aGV4bGlmeShpdikuc3Vic3RyaW5nKDIpfSxjaXBoZXJ0ZXh0OmhleGxpZnkoY2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLGtkZjpcInNjcnlwdFwiLGtkZnBhcmFtczp7c2FsdDpoZXhsaWZ5KHNhbHQpLnN1YnN0cmluZygyKSxuOk4sZGtsZW46MzIscDpwLHI6cn0sbWFjOm1hYy5zdWJzdHJpbmcoMil9fTtpZihlbnRyb3B5KXtjb25zdCBtbmVtb25pY0l2PXJhbmRvbUJ5dGVzKDE2KTtjb25zdCBtbmVtb25pY0NvdW50ZXI9bmV3IGFlc0pzLkNvdW50ZXIobW5lbW9uaWNJdik7Y29uc3QgbW5lbW9uaWNBZXNDdHI9bmV3IGFlc0pzLk1vZGVPZk9wZXJhdGlvbi5jdHIobW5lbW9uaWNLZXksbW5lbW9uaWNDb3VudGVyKTtjb25zdCBtbmVtb25pY0NpcGhlcnRleHQ9YXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7Y29uc3Qgbm93PW5ldyBEYXRlO2NvbnN0IHRpbWVzdGFtcD1ub3cuZ2V0VVRDRnVsbFllYXIoKStcIi1cIit6cGFkKG5vdy5nZXRVVENNb250aCgpKzEsMikrXCItXCIrenBhZChub3cuZ2V0VVRDRGF0ZSgpLDIpK1wiVFwiK3pwYWQobm93LmdldFVUQ0hvdXJzKCksMikrXCItXCIrenBhZChub3cuZ2V0VVRDTWludXRlcygpLDIpK1wiLVwiK3pwYWQobm93LmdldFVUQ1NlY29uZHMoKSwyKStcIi4wWlwiO2RhdGFbXCJ4LWV0aGVyc1wiXT17Y2xpZW50OmNsaWVudCxnZXRoRmlsZW5hbWU6XCJVVEMtLVwiK3RpbWVzdGFtcCtcIi0tXCIrZGF0YS5hZGRyZXNzLG1uZW1vbmljQ291bnRlcjpoZXhsaWZ5KG1uZW1vbmljSXYpLnN1YnN0cmluZygyKSxtbmVtb25pY0NpcGhlcnRleHQ6aGV4bGlmeShtbmVtb25pY0NpcGhlcnRleHQpLnN1YnN0cmluZygyKSxwYXRoOnBhdGgsbG9jYWxlOmxvY2FsZSx2ZXJzaW9uOlwiMC4xXCJ9fXJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKX0pfVwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGRlY3J5cHRKc29uV2FsbGV0KGpzb24scGFzc3dvcmQscHJvZ3Jlc3NDYWxsYmFjayl7aWYoaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpe2lmKHByb2dyZXNzQ2FsbGJhY2spe3Byb2dyZXNzQ2FsbGJhY2soMCl9Y29uc3QgYWNjb3VudD1kZWNyeXB0KGpzb24scGFzc3dvcmQpO2lmKHByb2dyZXNzQ2FsbGJhY2spe3Byb2dyZXNzQ2FsbGJhY2soMSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZShhY2NvdW50KX1pZihpc0tleXN0b3JlV2FsbGV0KGpzb24pKXtyZXR1cm4gZGVjcnlwdCQxKGpzb24scGFzc3dvcmQscHJvZ3Jlc3NDYWxsYmFjayl9cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgSlNPTiB3YWxsZXRcIikpfWZ1bmN0aW9uIGRlY3J5cHRKc29uV2FsbGV0U3luYyhqc29uLHBhc3N3b3JkKXtpZihpc0Nyb3dkc2FsZVdhbGxldChqc29uKSl7cmV0dXJuIGRlY3J5cHQoanNvbixwYXNzd29yZCl9aWYoaXNLZXlzdG9yZVdhbGxldChqc29uKSl7cmV0dXJuIGRlY3J5cHRTeW5jKGpzb24scGFzc3dvcmQpfXRocm93IG5ldyBFcnJvcihcImludmFsaWQgSlNPTiB3YWxsZXRcIil9Y29uc3QgdmVyc2lvbiRqPVwid2FsbGV0LzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciQ1PXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkcD1uZXcgTG9nZ2VyKHZlcnNpb24kaik7ZnVuY3Rpb24gaXNBY2NvdW50KHZhbHVlKXtyZXR1cm4gdmFsdWUhPW51bGwmJmlzSGV4U3RyaW5nKHZhbHVlLnByaXZhdGVLZXksMzIpJiZ2YWx1ZS5hZGRyZXNzIT1udWxsfWZ1bmN0aW9uIGhhc01uZW1vbmljJDEodmFsdWUpe2NvbnN0IG1uZW1vbmljPXZhbHVlLm1uZW1vbmljO3JldHVybiBtbmVtb25pYyYmbW5lbW9uaWMucGhyYXNlfWNsYXNzIFdhbGxldCBleHRlbmRzIFNpZ25lcntjb25zdHJ1Y3Rvcihwcml2YXRlS2V5LHByb3ZpZGVyKXtsb2dnZXIkcC5jaGVja05ldyhuZXcudGFyZ2V0LFdhbGxldCk7c3VwZXIoKTtpZihpc0FjY291bnQocHJpdmF0ZUtleSkpe2NvbnN0IHNpZ25pbmdLZXk9bmV3IFNpZ25pbmdLZXkocHJpdmF0ZUtleS5wcml2YXRlS2V5KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX3NpZ25pbmdLZXlcIiwoKT0+c2lnbmluZ0tleSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIixjb21wdXRlQWRkcmVzcyh0aGlzLnB1YmxpY0tleSkpO2lmKHRoaXMuYWRkcmVzcyE9PWdldEFkZHJlc3MocHJpdmF0ZUtleS5hZGRyZXNzKSl7bG9nZ2VyJHAudGhyb3dBcmd1bWVudEVycm9yKFwicHJpdmF0ZUtleS9hZGRyZXNzIG1pc21hdGNoXCIsXCJwcml2YXRlS2V5XCIsXCJbUkVEQUNURURdXCIpfWlmKGhhc01uZW1vbmljJDEocHJpdmF0ZUtleSkpe2NvbnN0IHNyY01uZW1vbmljPXByaXZhdGVLZXkubW5lbW9uaWM7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9tbmVtb25pY1wiLCgpPT4oe3BocmFzZTpzcmNNbmVtb25pYy5waHJhc2UscGF0aDpzcmNNbmVtb25pYy5wYXRofHxkZWZhdWx0UGF0aCxsb2NhbGU6c3JjTW5lbW9uaWMubG9jYWxlfHxcImVuXCJ9KSk7Y29uc3QgbW5lbW9uaWM9dGhpcy5tbmVtb25pYztjb25zdCBub2RlPUhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLG51bGwsbW5lbW9uaWMubG9jYWxlKS5kZXJpdmVQYXRoKG1uZW1vbmljLnBhdGgpO2lmKGNvbXB1dGVBZGRyZXNzKG5vZGUucHJpdmF0ZUtleSkhPT10aGlzLmFkZHJlc3Mpe2xvZ2dlciRwLnRocm93QXJndW1lbnRFcnJvcihcIm1uZW1vbmljL2FkZHJlc3MgbWlzbWF0Y2hcIixcInByaXZhdGVLZXlcIixcIltSRURBQ1RFRF1cIil9fWVsc2V7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9tbmVtb25pY1wiLCgpPT5udWxsKX19ZWxzZXtpZihTaWduaW5nS2V5LmlzU2lnbmluZ0tleShwcml2YXRlS2V5KSl7aWYocHJpdmF0ZUtleS5jdXJ2ZSE9PVwic2VjcDI1NmsxXCIpe2xvZ2dlciRwLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGN1cnZlOyBtdXN0IGJlIHNlY3AyNTZrMVwiLFwicHJpdmF0ZUtleVwiLFwiW1JFREFDVEVEXVwiKX1kZWZpbmVSZWFkT25seSh0aGlzLFwiX3NpZ25pbmdLZXlcIiwoKT0+cHJpdmF0ZUtleSl9ZWxzZXtpZih0eXBlb2YgcHJpdmF0ZUtleT09PVwic3RyaW5nXCIpe2lmKHByaXZhdGVLZXkubWF0Y2goL15bMC05YS1mXSokL2kpJiZwcml2YXRlS2V5Lmxlbmd0aD09PTY0KXtwcml2YXRlS2V5PVwiMHhcIitwcml2YXRlS2V5fX1jb25zdCBzaWduaW5nS2V5PW5ldyBTaWduaW5nS2V5KHByaXZhdGVLZXkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfc2lnbmluZ0tleVwiLCgpPT5zaWduaW5nS2V5KX1kZWZpbmVSZWFkT25seSh0aGlzLFwiX21uZW1vbmljXCIsKCk9Pm51bGwpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhZGRyZXNzXCIsY29tcHV0ZUFkZHJlc3ModGhpcy5wdWJsaWNLZXkpKX1pZihwcm92aWRlciYmIVByb3ZpZGVyLmlzUHJvdmlkZXIocHJvdmlkZXIpKXtsb2dnZXIkcC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHByb3ZpZGVyXCIsXCJwcm92aWRlclwiLHByb3ZpZGVyKX1kZWZpbmVSZWFkT25seSh0aGlzLFwicHJvdmlkZXJcIixwcm92aWRlcnx8bnVsbCl9Z2V0IG1uZW1vbmljKCl7cmV0dXJuIHRoaXMuX21uZW1vbmljKCl9Z2V0IHByaXZhdGVLZXkoKXtyZXR1cm4gdGhpcy5fc2lnbmluZ0tleSgpLnByaXZhdGVLZXl9Z2V0IHB1YmxpY0tleSgpe3JldHVybiB0aGlzLl9zaWduaW5nS2V5KCkucHVibGljS2V5fWdldEFkZHJlc3MoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyl9Y29ubmVjdChwcm92aWRlcil7cmV0dXJuIG5ldyBXYWxsZXQodGhpcyxwcm92aWRlcil9c2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKXtyZXR1cm4gcmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pLnRoZW4odHg9PntpZih0eC5mcm9tIT1udWxsKXtpZihnZXRBZGRyZXNzKHR4LmZyb20pIT09dGhpcy5hZGRyZXNzKXtsb2dnZXIkcC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbiBmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIixcInRyYW5zYWN0aW9uLmZyb21cIix0cmFuc2FjdGlvbi5mcm9tKX1kZWxldGUgdHguZnJvbX1jb25zdCBzaWduYXR1cmU9dGhpcy5fc2lnbmluZ0tleSgpLnNpZ25EaWdlc3Qoa2VjY2FrMjU2KHNlcmlhbGl6ZSh0eCkpKTtyZXR1cm4gc2VyaWFsaXplKHR4LHNpZ25hdHVyZSl9KX1zaWduTWVzc2FnZShtZXNzYWdlKXtyZXR1cm4gX19hd2FpdGVyJDUodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3JldHVybiBqb2luU2lnbmF0dXJlKHRoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KGhhc2hNZXNzYWdlKG1lc3NhZ2UpKSl9KX1fc2lnblR5cGVkRGF0YShkb21haW4sdHlwZXMsdmFsdWUpe3JldHVybiBfX2F3YWl0ZXIkNSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgcG9wdWxhdGVkPXlpZWxkIFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbix0eXBlcyx2YWx1ZSxuYW1lPT57aWYodGhpcy5wcm92aWRlcj09bnVsbCl7bG9nZ2VyJHAudGhyb3dFcnJvcihcImNhbm5vdCByZXNvbHZlIEVOUyBuYW1lcyB3aXRob3V0IGEgcHJvdmlkZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwicmVzb2x2ZU5hbWVcIix2YWx1ZTpuYW1lfSl9cmV0dXJuIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSl9KTtyZXR1cm4gam9pblNpZ25hdHVyZSh0aGlzLl9zaWduaW5nS2V5KCkuc2lnbkRpZ2VzdChUeXBlZERhdGFFbmNvZGVyLmhhc2gocG9wdWxhdGVkLmRvbWFpbix0eXBlcyxwb3B1bGF0ZWQudmFsdWUpKSl9KX1lbmNyeXB0KHBhc3N3b3JkLG9wdGlvbnMscHJvZ3Jlc3NDYWxsYmFjayl7aWYodHlwZW9mIG9wdGlvbnM9PT1cImZ1bmN0aW9uXCImJiFwcm9ncmVzc0NhbGxiYWNrKXtwcm9ncmVzc0NhbGxiYWNrPW9wdGlvbnM7b3B0aW9ucz17fX1pZihwcm9ncmVzc0NhbGxiYWNrJiZ0eXBlb2YgcHJvZ3Jlc3NDYWxsYmFjayE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKX1pZighb3B0aW9ucyl7b3B0aW9ucz17fX1yZXR1cm4gZW5jcnlwdCh0aGlzLHBhc3N3b3JkLG9wdGlvbnMscHJvZ3Jlc3NDYWxsYmFjayl9c3RhdGljIGNyZWF0ZVJhbmRvbShvcHRpb25zKXtsZXQgZW50cm9weT1yYW5kb21CeXRlcygxNik7aWYoIW9wdGlvbnMpe29wdGlvbnM9e319aWYob3B0aW9ucy5leHRyYUVudHJvcHkpe2VudHJvcHk9YXJyYXlpZnkoaGV4RGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW2VudHJvcHksb3B0aW9ucy5leHRyYUVudHJvcHldKSksMCwxNikpfWNvbnN0IG1uZW1vbmljPWVudHJvcHlUb01uZW1vbmljKGVudHJvcHksb3B0aW9ucy5sb2NhbGUpO3JldHVybiBXYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljLG9wdGlvbnMucGF0aCxvcHRpb25zLmxvY2FsZSl9c3RhdGljIGZyb21FbmNyeXB0ZWRKc29uKGpzb24scGFzc3dvcmQscHJvZ3Jlc3NDYWxsYmFjayl7cmV0dXJuIGRlY3J5cHRKc29uV2FsbGV0KGpzb24scGFzc3dvcmQscHJvZ3Jlc3NDYWxsYmFjaykudGhlbihhY2NvdW50PT57cmV0dXJuIG5ldyBXYWxsZXQoYWNjb3VudCl9KX1zdGF0aWMgZnJvbUVuY3J5cHRlZEpzb25TeW5jKGpzb24scGFzc3dvcmQpe3JldHVybiBuZXcgV2FsbGV0KGRlY3J5cHRKc29uV2FsbGV0U3luYyhqc29uLHBhc3N3b3JkKSl9c3RhdGljIGZyb21NbmVtb25pYyhtbmVtb25pYyxwYXRoLHdvcmRsaXN0KXtpZighcGF0aCl7cGF0aD1kZWZhdWx0UGF0aH1yZXR1cm4gbmV3IFdhbGxldChIRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLG51bGwsd29yZGxpc3QpLmRlcml2ZVBhdGgocGF0aCkpfX1mdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKG1lc3NhZ2Usc2lnbmF0dXJlKXtyZXR1cm4gcmVjb3ZlckFkZHJlc3MoaGFzaE1lc3NhZ2UobWVzc2FnZSksc2lnbmF0dXJlKX1mdW5jdGlvbiB2ZXJpZnlUeXBlZERhdGEoZG9tYWluLHR5cGVzLHZhbHVlLHNpZ25hdHVyZSl7cmV0dXJuIHJlY292ZXJBZGRyZXNzKFR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sdHlwZXMsdmFsdWUpLHNpZ25hdHVyZSl9Y29uc3QgdmVyc2lvbiRrPVwibmV0d29ya3MvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkcT1uZXcgTG9nZ2VyKHZlcnNpb24kayk7ZnVuY3Rpb24gaXNSZW5ldHdvcmthYmxlKHZhbHVlKXtyZXR1cm4gdmFsdWUmJnR5cGVvZiB2YWx1ZS5yZW5ldHdvcms9PT1cImZ1bmN0aW9uXCJ9ZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspe2NvbnN0IGZ1bmM9ZnVuY3Rpb24ocHJvdmlkZXJzLG9wdGlvbnMpe2lmKG9wdGlvbnM9PW51bGwpe29wdGlvbnM9e319Y29uc3QgcHJvdmlkZXJMaXN0PVtdO2lmKHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcil7dHJ5e3Byb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIobmV0d29yayxvcHRpb25zLmluZnVyYSkpfWNhdGNoKGVycm9yKXt9fWlmKHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcil7dHJ5e3Byb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yayxvcHRpb25zLmV0aGVyc2NhbikpfWNhdGNoKGVycm9yKXt9fWlmKHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIpe2NvbnN0IHNraXA9W1wiZ29lcmxpXCIsXCJyb3BzdGVuXCIsXCJyaW5rZWJ5XCJdO3RyeXtjb25zdCBwcm92aWRlcj1uZXcgcHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcihuZXR3b3JrLG9wdGlvbnMuYWxjaGVteSk7aWYocHJvdmlkZXIubmV0d29yayYmc2tpcC5pbmRleE9mKHByb3ZpZGVyLm5ldHdvcmsubmFtZSk9PT0tMSl7cHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpfX1jYXRjaChlcnJvcil7fX1pZihwcm92aWRlcnMuUG9ja2V0UHJvdmlkZXIpe2NvbnN0IHNraXA9W1wiZ29lcmxpXCIsXCJyb3BzdGVuXCIsXCJyaW5rZWJ5XCJdO3RyeXtjb25zdCBwcm92aWRlcj1uZXcgcHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKG5ldHdvcmspO2lmKHByb3ZpZGVyLm5ldHdvcmsmJnNraXAuaW5kZXhPZihwcm92aWRlci5uZXR3b3JrLm5hbWUpPT09LTEpe3Byb3ZpZGVyTGlzdC5wdXNoKHByb3ZpZGVyKX19Y2F0Y2goZXJyb3Ipe319aWYocHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcil7dHJ5e3Byb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyKG5ldHdvcmspKX1jYXRjaChlcnJvcil7fX1pZihwcm92aWRlckxpc3QubGVuZ3RoPT09MCl7cmV0dXJuIG51bGx9aWYocHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIpe2xldCBxdW9ydW09MTtpZihvcHRpb25zLnF1b3J1bSE9bnVsbCl7cXVvcnVtPW9wdGlvbnMucXVvcnVtfWVsc2UgaWYobmV0d29yaz09PVwiaG9tZXN0ZWFkXCIpe3F1b3J1bT0yfXJldHVybiBuZXcgcHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJMaXN0LHF1b3J1bSl9cmV0dXJuIHByb3ZpZGVyTGlzdFswXX07ZnVuYy5yZW5ldHdvcms9ZnVuY3Rpb24obmV0d29yayl7cmV0dXJuIGV0aERlZmF1bHRQcm92aWRlcihuZXR3b3JrKX07cmV0dXJuIGZ1bmN9ZnVuY3Rpb24gZXRjRGVmYXVsdFByb3ZpZGVyKHVybCxuZXR3b3JrKXtjb25zdCBmdW5jPWZ1bmN0aW9uKHByb3ZpZGVycyxvcHRpb25zKXtpZihwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKXtyZXR1cm4gbmV3IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIodXJsLG5ldHdvcmspfXJldHVybiBudWxsfTtmdW5jLnJlbmV0d29yaz1mdW5jdGlvbihuZXR3b3JrKXtyZXR1cm4gZXRjRGVmYXVsdFByb3ZpZGVyKHVybCxuZXR3b3JrKX07cmV0dXJuIGZ1bmN9Y29uc3QgaG9tZXN0ZWFkPXtjaGFpbklkOjEsZW5zQWRkcmVzczpcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLG5hbWU6XCJob21lc3RlYWRcIixfZGVmYXVsdFByb3ZpZGVyOmV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKX07Y29uc3Qgcm9wc3Rlbj17Y2hhaW5JZDozLGVuc0FkZHJlc3M6XCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixuYW1lOlwicm9wc3RlblwiLF9kZWZhdWx0UHJvdmlkZXI6ZXRoRGVmYXVsdFByb3ZpZGVyKFwicm9wc3RlblwiKX07Y29uc3QgY2xhc3NpY01vcmRvcj17Y2hhaW5JZDo2MyxuYW1lOlwiY2xhc3NpY01vcmRvclwiLF9kZWZhdWx0UHJvdmlkZXI6ZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6Ly93d3cuZXRoZXJjbHVzdGVyLmNvbS9tb3Jkb3JcIixcImNsYXNzaWNNb3Jkb3JcIil9O2NvbnN0IG5ldHdvcmtzPXt1bnNwZWNpZmllZDp7Y2hhaW5JZDowLG5hbWU6XCJ1bnNwZWNpZmllZFwifSxob21lc3RlYWQ6aG9tZXN0ZWFkLG1haW5uZXQ6aG9tZXN0ZWFkLG1vcmRlbjp7Y2hhaW5JZDoyLG5hbWU6XCJtb3JkZW5cIn0scm9wc3Rlbjpyb3BzdGVuLHRlc3RuZXQ6cm9wc3RlbixyaW5rZWJ5OntjaGFpbklkOjQsZW5zQWRkcmVzczpcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLG5hbWU6XCJyaW5rZWJ5XCIsX2RlZmF1bHRQcm92aWRlcjpldGhEZWZhdWx0UHJvdmlkZXIoXCJyaW5rZWJ5XCIpfSxrb3Zhbjp7Y2hhaW5JZDo0MixuYW1lOlwia292YW5cIixfZGVmYXVsdFByb3ZpZGVyOmV0aERlZmF1bHRQcm92aWRlcihcImtvdmFuXCIpfSxnb2VybGk6e2NoYWluSWQ6NSxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcImdvZXJsaVwiLF9kZWZhdWx0UHJvdmlkZXI6ZXRoRGVmYXVsdFByb3ZpZGVyKFwiZ29lcmxpXCIpfSxjbGFzc2ljOntjaGFpbklkOjYxLG5hbWU6XCJjbGFzc2ljXCIsX2RlZmF1bHRQcm92aWRlcjpldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2V0Y1wiLFwiY2xhc3NpY1wiKX0sY2xhc3NpY01vcmRlbjp7Y2hhaW5JZDo2MixuYW1lOlwiY2xhc3NpY01vcmRlblwifSxjbGFzc2ljTW9yZG9yOmNsYXNzaWNNb3Jkb3IsY2xhc3NpY1Rlc3RuZXQ6Y2xhc3NpY01vcmRvcixjbGFzc2ljS290dGk6e2NoYWluSWQ6NixuYW1lOlwiY2xhc3NpY0tvdHRpXCIsX2RlZmF1bHRQcm92aWRlcjpldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2tvdHRpXCIsXCJjbGFzc2ljS290dGlcIil9fTtmdW5jdGlvbiBnZXROZXR3b3JrKG5ldHdvcmspe2lmKG5ldHdvcms9PW51bGwpe3JldHVybiBudWxsfWlmKHR5cGVvZiBuZXR3b3JrPT09XCJudW1iZXJcIil7Zm9yKGNvbnN0IG5hbWUgaW4gbmV0d29ya3Mpe2NvbnN0IHN0YW5kYXJkPW5ldHdvcmtzW25hbWVdO2lmKHN0YW5kYXJkLmNoYWluSWQ9PT1uZXR3b3JrKXtyZXR1cm57bmFtZTpzdGFuZGFyZC5uYW1lLGNoYWluSWQ6c3RhbmRhcmQuY2hhaW5JZCxlbnNBZGRyZXNzOnN0YW5kYXJkLmVuc0FkZHJlc3N8fG51bGwsX2RlZmF1bHRQcm92aWRlcjpzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyfHxudWxsfX19cmV0dXJue2NoYWluSWQ6bmV0d29yayxuYW1lOlwidW5rbm93blwifX1pZih0eXBlb2YgbmV0d29yaz09PVwic3RyaW5nXCIpe2NvbnN0IHN0YW5kYXJkPW5ldHdvcmtzW25ldHdvcmtdO2lmKHN0YW5kYXJkPT1udWxsKXtyZXR1cm4gbnVsbH1yZXR1cm57bmFtZTpzdGFuZGFyZC5uYW1lLGNoYWluSWQ6c3RhbmRhcmQuY2hhaW5JZCxlbnNBZGRyZXNzOnN0YW5kYXJkLmVuc0FkZHJlc3MsX2RlZmF1bHRQcm92aWRlcjpzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyfHxudWxsfX1jb25zdCBzdGFuZGFyZD1uZXR3b3Jrc1tuZXR3b3JrLm5hbWVdO2lmKCFzdGFuZGFyZCl7aWYodHlwZW9mIG5ldHdvcmsuY2hhaW5JZCE9PVwibnVtYmVyXCIpe2xvZ2dlciRxLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsXCJuZXR3b3JrXCIsbmV0d29yayl9cmV0dXJuIG5ldHdvcmt9aWYobmV0d29yay5jaGFpbklkIT09MCYmbmV0d29yay5jaGFpbklkIT09c3RhbmRhcmQuY2hhaW5JZCl7bG9nZ2VyJHEudGhyb3dBcmd1bWVudEVycm9yKFwibmV0d29yayBjaGFpbklkIG1pc21hdGNoXCIsXCJuZXR3b3JrXCIsbmV0d29yayl9bGV0IGRlZmF1bHRQcm92aWRlcj1uZXR3b3JrLl9kZWZhdWx0UHJvdmlkZXJ8fG51bGw7aWYoZGVmYXVsdFByb3ZpZGVyPT1udWxsJiZzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKXtpZihpc1JlbmV0d29ya2FibGUoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcikpe2RlZmF1bHRQcm92aWRlcj1zdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyLnJlbmV0d29yayhuZXR3b3JrKX1lbHNle2RlZmF1bHRQcm92aWRlcj1zdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyfX1yZXR1cm57bmFtZTpuZXR3b3JrLm5hbWUsY2hhaW5JZDpzdGFuZGFyZC5jaGFpbklkLGVuc0FkZHJlc3M6bmV0d29yay5lbnNBZGRyZXNzfHxzdGFuZGFyZC5lbnNBZGRyZXNzfHxudWxsLF9kZWZhdWx0UHJvdmlkZXI6ZGVmYXVsdFByb3ZpZGVyfX1cInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBkZWNvZGUkMSh0ZXh0RGF0YSl7dGV4dERhdGE9YXRvYih0ZXh0RGF0YSk7Y29uc3QgZGF0YT1bXTtmb3IobGV0IGk9MDtpPHRleHREYXRhLmxlbmd0aDtpKyspe2RhdGEucHVzaCh0ZXh0RGF0YS5jaGFyQ29kZUF0KGkpKX1yZXR1cm4gYXJyYXlpZnkoZGF0YSl9ZnVuY3Rpb24gZW5jb2RlJDEoZGF0YSl7ZGF0YT1hcnJheWlmeShkYXRhKTtsZXQgdGV4dERhdGE9XCJcIjtmb3IobGV0IGk9MDtpPGRhdGEubGVuZ3RoO2krKyl7dGV4dERhdGErPVN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSl9cmV0dXJuIGJ0b2EodGV4dERhdGEpfVwidXNlIHN0cmljdFwiO3ZhciBpbmRleCQyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlY29kZTpkZWNvZGUkMSxlbmNvZGU6ZW5jb2RlJDF9KTtjb25zdCB2ZXJzaW9uJGw9XCJ3ZWIvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyJDY9d2luZG93JiZ3aW5kb3cuX19hd2FpdGVyfHxmdW5jdGlvbih0aGlzQXJnLF9hcmd1bWVudHMsUCxnZW5lcmF0b3Ipe2Z1bmN0aW9uIGFkb3B0KHZhbHVlKXtyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQP3ZhbHVlOm5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpe3Jlc29sdmUodmFsdWUpfSl9cmV0dXJuIG5ldyhQfHwoUD1Qcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2Z1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gc3RlcChyZXN1bHQpe3Jlc3VsdC5kb25lP3Jlc29sdmUocmVzdWx0LnZhbHVlKTphZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChnZW5lcmF0b3I9Z2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsX2FyZ3VtZW50c3x8W10pKS5uZXh0KCkpfSl9O2Z1bmN0aW9uIGdldFVybChocmVmLG9wdGlvbnMpe3JldHVybiBfX2F3YWl0ZXIkNih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYob3B0aW9ucz09bnVsbCl7b3B0aW9ucz17fX1jb25zdCByZXF1ZXN0PXttZXRob2Q6b3B0aW9ucy5tZXRob2R8fFwiR0VUXCIsaGVhZGVyczpvcHRpb25zLmhlYWRlcnN8fHt9LGJvZHk6b3B0aW9ucy5ib2R5fHx1bmRlZmluZWQsbW9kZTpcImNvcnNcIixjYWNoZTpcIm5vLWNhY2hlXCIsY3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwiLHJlZGlyZWN0OlwiZm9sbG93XCIscmVmZXJyZXI6XCJjbGllbnRcIn07Y29uc3QgcmVzcG9uc2U9eWllbGQgZmV0Y2goaHJlZixyZXF1ZXN0KTtjb25zdCBib2R5PXlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7Y29uc3QgaGVhZGVycz17fTtpZihyZXNwb25zZS5oZWFkZXJzLmZvckVhY2gpe3Jlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsa2V5KT0+e2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldPXZhbHVlfSl9ZWxzZXtyZXNwb25zZS5oZWFkZXJzLmtleXMoKS5mb3JFYWNoKGtleT0+e2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldPXJlc3BvbnNlLmhlYWRlcnMuZ2V0KGtleSl9KX1yZXR1cm57aGVhZGVyczpoZWFkZXJzLHN0YXR1c0NvZGU6cmVzcG9uc2Uuc3RhdHVzLHN0YXR1c01lc3NhZ2U6cmVzcG9uc2Uuc3RhdHVzVGV4dCxib2R5OmFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJvZHkpKX19KX1cInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyJDc9d2luZG93JiZ3aW5kb3cuX19hd2FpdGVyfHxmdW5jdGlvbih0aGlzQXJnLF9hcmd1bWVudHMsUCxnZW5lcmF0b3Ipe2Z1bmN0aW9uIGFkb3B0KHZhbHVlKXtyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQP3ZhbHVlOm5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpe3Jlc29sdmUodmFsdWUpfSl9cmV0dXJuIG5ldyhQfHwoUD1Qcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2Z1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gc3RlcChyZXN1bHQpe3Jlc3VsdC5kb25lP3Jlc29sdmUocmVzdWx0LnZhbHVlKTphZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChnZW5lcmF0b3I9Z2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsX2FyZ3VtZW50c3x8W10pKS5uZXh0KCkpfSl9O2NvbnN0IGxvZ2dlciRyPW5ldyBMb2dnZXIodmVyc2lvbiRsKTtmdW5jdGlvbiBzdGFsbGVyKGR1cmF0aW9uKXtyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZT0+e3NldFRpbWVvdXQocmVzb2x2ZSxkdXJhdGlvbil9KX1mdW5jdGlvbiBib2R5aWZ5KHZhbHVlLHR5cGUpe2lmKHZhbHVlPT1udWxsKXtyZXR1cm4gbnVsbH1pZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtyZXR1cm4gdmFsdWV9aWYoaXNCeXRlc0xpa2UodmFsdWUpKXtpZih0eXBlJiYodHlwZS5zcGxpdChcIi9cIilbMF09PT1cInRleHRcInx8dHlwZS5zcGxpdChcIjtcIilbMF0udHJpbSgpPT09XCJhcHBsaWNhdGlvbi9qc29uXCIpKXt0cnl7cmV0dXJuIHRvVXRmOFN0cmluZyh2YWx1ZSl9Y2F0Y2goZXJyb3Ipe319cmV0dXJuIGhleGxpZnkodmFsdWUpfXJldHVybiB2YWx1ZX1mdW5jdGlvbiBfZmV0Y2hEYXRhKGNvbm5lY3Rpb24sYm9keSxwcm9jZXNzRnVuYyl7Y29uc3QgYXR0ZW1wdExpbWl0PXR5cGVvZiBjb25uZWN0aW9uPT09XCJvYmplY3RcIiYmY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0IT1udWxsP2Nvbm5lY3Rpb24udGhyb3R0bGVMaW1pdDoxMjtsb2dnZXIkci5hc3NlcnRBcmd1bWVudChhdHRlbXB0TGltaXQ+MCYmYXR0ZW1wdExpbWl0JTE9PT0wLFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIGxpbWl0XCIsXCJjb25uZWN0aW9uLnRocm90dGxlTGltaXRcIixhdHRlbXB0TGltaXQpO2NvbnN0IHRocm90dGxlQ2FsbGJhY2s9dHlwZW9mIGNvbm5lY3Rpb249PT1cIm9iamVjdFwiP2Nvbm5lY3Rpb24udGhyb3R0bGVDYWxsYmFjazpudWxsO2NvbnN0IHRocm90dGxlU2xvdEludGVydmFsPXR5cGVvZiBjb25uZWN0aW9uPT09XCJvYmplY3RcIiYmdHlwZW9mIGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWw9PT1cIm51bWJlclwiP2Nvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWw6MTAwO2xvZ2dlciRyLmFzc2VydEFyZ3VtZW50KHRocm90dGxlU2xvdEludGVydmFsPjAmJnRocm90dGxlU2xvdEludGVydmFsJTE9PT0wLFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIHNsb3QgaW50ZXJ2YWxcIixcImNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWxcIix0aHJvdHRsZVNsb3RJbnRlcnZhbCk7Y29uc3QgaGVhZGVycz17fTtsZXQgdXJsPW51bGw7Y29uc3Qgb3B0aW9ucz17bWV0aG9kOlwiR0VUXCJ9O2xldCBhbGxvdzMwND1mYWxzZTtsZXQgdGltZW91dD0yKjYwKjFlMztpZih0eXBlb2YgY29ubmVjdGlvbj09PVwic3RyaW5nXCIpe3VybD1jb25uZWN0aW9ufWVsc2UgaWYodHlwZW9mIGNvbm5lY3Rpb249PT1cIm9iamVjdFwiKXtpZihjb25uZWN0aW9uPT1udWxsfHxjb25uZWN0aW9uLnVybD09bnVsbCl7bG9nZ2VyJHIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBVUkxcIixcImNvbm5lY3Rpb24udXJsXCIsY29ubmVjdGlvbil9dXJsPWNvbm5lY3Rpb24udXJsO2lmKHR5cGVvZiBjb25uZWN0aW9uLnRpbWVvdXQ9PT1cIm51bWJlclwiJiZjb25uZWN0aW9uLnRpbWVvdXQ+MCl7dGltZW91dD1jb25uZWN0aW9uLnRpbWVvdXR9aWYoY29ubmVjdGlvbi5oZWFkZXJzKXtmb3IoY29uc3Qga2V5IGluIGNvbm5lY3Rpb24uaGVhZGVycyl7aGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV09e2tleTprZXksdmFsdWU6U3RyaW5nKGNvbm5lY3Rpb24uaGVhZGVyc1trZXldKX07aWYoW1wiaWYtbm9uZS1tYXRjaFwiLFwiaWYtbW9kaWZpZWQtc2luY2VcIl0uaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSk+PTApe2FsbG93MzA0PXRydWV9fX1vcHRpb25zLmFsbG93R3ppcD0hIWNvbm5lY3Rpb24uYWxsb3dHemlwO2lmKGNvbm5lY3Rpb24udXNlciE9bnVsbCYmY29ubmVjdGlvbi5wYXNzd29yZCE9bnVsbCl7aWYodXJsLnN1YnN0cmluZygwLDYpIT09XCJodHRwczpcIiYmY29ubmVjdGlvbi5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24hPT10cnVlKXtsb2dnZXIkci50aHJvd0Vycm9yKFwiYmFzaWMgYXV0aGVudGljYXRpb24gcmVxdWlyZXMgYSBzZWN1cmUgaHR0cHMgdXJsXCIsTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInVybFwiLHVybDp1cmwsdXNlcjpjb25uZWN0aW9uLnVzZXIscGFzc3dvcmQ6XCJbUkVEQUNURURdXCJ9KX1jb25zdCBhdXRob3JpemF0aW9uPWNvbm5lY3Rpb24udXNlcitcIjpcIitjb25uZWN0aW9uLnBhc3N3b3JkO2hlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdPXtrZXk6XCJBdXRob3JpemF0aW9uXCIsdmFsdWU6XCJCYXNpYyBcIitlbmNvZGUkMSh0b1V0ZjhCeXRlcyhhdXRob3JpemF0aW9uKSl9fX1pZihib2R5KXtvcHRpb25zLm1ldGhvZD1cIlBPU1RcIjtvcHRpb25zLmJvZHk9Ym9keTtpZihoZWFkZXJzW1wiY29udGVudC10eXBlXCJdPT1udWxsKXtoZWFkZXJzW1wiY29udGVudC10eXBlXCJdPXtrZXk6XCJDb250ZW50LVR5cGVcIix2YWx1ZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifX1pZihoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl09PW51bGwpe2hlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXT17a2V5OlwiQ29udGVudC1MZW5ndGhcIix2YWx1ZTpTdHJpbmcoYm9keS5sZW5ndGgpfX19Y29uc3QgZmxhdEhlYWRlcnM9e307T2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChrZXk9Pntjb25zdCBoZWFkZXI9aGVhZGVyc1trZXldO2ZsYXRIZWFkZXJzW2hlYWRlci5rZXldPWhlYWRlci52YWx1ZX0pO29wdGlvbnMuaGVhZGVycz1mbGF0SGVhZGVycztjb25zdCBydW5uaW5nVGltZW91dD1mdW5jdGlvbigpe2xldCB0aW1lcj1udWxsO2NvbnN0IHByb21pc2U9bmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2lmKHRpbWVvdXQpe3RpbWVyPXNldFRpbWVvdXQoKCk9PntpZih0aW1lcj09bnVsbCl7cmV0dXJufXRpbWVyPW51bGw7cmVqZWN0KGxvZ2dlciRyLm1ha2VFcnJvcihcInRpbWVvdXRcIixMb2dnZXIuZXJyb3JzLlRJTUVPVVQse3JlcXVlc3RCb2R5OmJvZHlpZnkob3B0aW9ucy5ib2R5LGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxyZXF1ZXN0TWV0aG9kOm9wdGlvbnMubWV0aG9kLHRpbWVvdXQ6dGltZW91dCx1cmw6dXJsfSkpfSx0aW1lb3V0KX19KTtjb25zdCBjYW5jZWw9ZnVuY3Rpb24oKXtpZih0aW1lcj09bnVsbCl7cmV0dXJufWNsZWFyVGltZW91dCh0aW1lcik7dGltZXI9bnVsbH07cmV0dXJue3Byb21pc2U6cHJvbWlzZSxjYW5jZWw6Y2FuY2VsfX0oKTtjb25zdCBydW5uaW5nRmV0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyJDcodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2ZvcihsZXQgYXR0ZW1wdD0wO2F0dGVtcHQ8YXR0ZW1wdExpbWl0O2F0dGVtcHQrKyl7bGV0IHJlc3BvbnNlPW51bGw7dHJ5e3Jlc3BvbnNlPXlpZWxkIGdldFVybCh1cmwsb3B0aW9ucyk7aWYocmVzcG9uc2Uuc3RhdHVzQ29kZT09PTQyOSYmYXR0ZW1wdDxhdHRlbXB0TGltaXQpe2xldCB0cnlBZ2Fpbj10cnVlO2lmKHRocm90dGxlQ2FsbGJhY2spe3RyeUFnYWluPXlpZWxkIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCx1cmwpfWlmKHRyeUFnYWluKXtsZXQgc3RhbGw9MDtjb25zdCByZXRyeUFmdGVyPXJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtpZih0eXBlb2YgcmV0cnlBZnRlcj09PVwic3RyaW5nXCImJnJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSl7c3RhbGw9cGFyc2VJbnQocmV0cnlBZnRlcikqMWUzfWVsc2V7c3RhbGw9dGhyb3R0bGVTbG90SW50ZXJ2YWwqcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMixhdHRlbXB0KSkpfXlpZWxkIHN0YWxsZXIoc3RhbGwpO2NvbnRpbnVlfX19Y2F0Y2goZXJyb3Ipe3Jlc3BvbnNlPWVycm9yLnJlc3BvbnNlO2lmKHJlc3BvbnNlPT1udWxsKXtydW5uaW5nVGltZW91dC5jYW5jZWwoKTtsb2dnZXIkci50aHJvd0Vycm9yKFwibWlzc2luZyByZXNwb25zZVwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHtyZXF1ZXN0Qm9keTpib2R5aWZ5KG9wdGlvbnMuYm9keSxmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSkscmVxdWVzdE1ldGhvZDpvcHRpb25zLm1ldGhvZCxzZXJ2ZXJFcnJvcjplcnJvcix1cmw6dXJsfSl9fWxldCBib2R5PXJlc3BvbnNlLmJvZHk7aWYoYWxsb3czMDQmJnJlc3BvbnNlLnN0YXR1c0NvZGU9PT0zMDQpe2JvZHk9bnVsbH1lbHNlIGlmKHJlc3BvbnNlLnN0YXR1c0NvZGU8MjAwfHxyZXNwb25zZS5zdGF0dXNDb2RlPj0zMDApe3J1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO2xvZ2dlciRyLnRocm93RXJyb3IoXCJiYWQgcmVzcG9uc2VcIixMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUix7c3RhdHVzOnJlc3BvbnNlLnN0YXR1c0NvZGUsaGVhZGVyczpyZXNwb25zZS5oZWFkZXJzLGJvZHk6Ym9keWlmeShib2R5LHJlc3BvbnNlLmhlYWRlcnM/cmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTpudWxsKSxyZXF1ZXN0Qm9keTpib2R5aWZ5KG9wdGlvbnMuYm9keSxmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSkscmVxdWVzdE1ldGhvZDpvcHRpb25zLm1ldGhvZCx1cmw6dXJsfSl9aWYocHJvY2Vzc0Z1bmMpe3RyeXtjb25zdCByZXN1bHQ9eWllbGQgcHJvY2Vzc0Z1bmMoYm9keSxyZXNwb25zZSk7cnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7cmV0dXJuIHJlc3VsdH1jYXRjaChlcnJvcil7aWYoZXJyb3IudGhyb3R0bGVSZXRyeSYmYXR0ZW1wdDxhdHRlbXB0TGltaXQpe2xldCB0cnlBZ2Fpbj10cnVlO2lmKHRocm90dGxlQ2FsbGJhY2spe3RyeUFnYWluPXlpZWxkIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCx1cmwpfWlmKHRyeUFnYWluKXtjb25zdCB0aW1lb3V0PXRocm90dGxlU2xvdEludGVydmFsKnBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpKk1hdGgucG93KDIsYXR0ZW1wdCkpKTt5aWVsZCBzdGFsbGVyKHRpbWVvdXQpO2NvbnRpbnVlfX1ydW5uaW5nVGltZW91dC5jYW5jZWwoKTtsb2dnZXIkci50aHJvd0Vycm9yKFwicHJvY2Vzc2luZyByZXNwb25zZSBlcnJvclwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHtib2R5OmJvZHlpZnkoYm9keSxyZXNwb25zZS5oZWFkZXJzP3Jlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl06bnVsbCksZXJyb3I6ZXJyb3IscmVxdWVzdEJvZHk6Ym9keWlmeShvcHRpb25zLmJvZHksZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLHJlcXVlc3RNZXRob2Q6b3B0aW9ucy5tZXRob2QsdXJsOnVybH0pfX1ydW5uaW5nVGltZW91dC5jYW5jZWwoKTtyZXR1cm4gYm9keX1yZXR1cm4gbG9nZ2VyJHIudGhyb3dFcnJvcihcImZhaWxlZCByZXNwb25zZVwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHtyZXF1ZXN0Qm9keTpib2R5aWZ5KG9wdGlvbnMuYm9keSxmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSkscmVxdWVzdE1ldGhvZDpvcHRpb25zLm1ldGhvZCx1cmw6dXJsfSl9KX0oKTtyZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5uaW5nVGltZW91dC5wcm9taXNlLHJ1bm5pbmdGZXRjaF0pfWZ1bmN0aW9uIGZldGNoSnNvbihjb25uZWN0aW9uLGpzb24scHJvY2Vzc0Z1bmMpe2xldCBwcm9jZXNzSnNvbkZ1bmM9KHZhbHVlLHJlc3BvbnNlKT0+e2xldCByZXN1bHQ9bnVsbDtpZih2YWx1ZSE9bnVsbCl7dHJ5e3Jlc3VsdD1KU09OLnBhcnNlKHRvVXRmOFN0cmluZyh2YWx1ZSkpfWNhdGNoKGVycm9yKXtsb2dnZXIkci50aHJvd0Vycm9yKFwiaW52YWxpZCBKU09OXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise2JvZHk6dmFsdWUsZXJyb3I6ZXJyb3J9KX19aWYocHJvY2Vzc0Z1bmMpe3Jlc3VsdD1wcm9jZXNzRnVuYyhyZXN1bHQscmVzcG9uc2UpfXJldHVybiByZXN1bHR9O2xldCBib2R5PW51bGw7aWYoanNvbiE9bnVsbCl7Ym9keT10b1V0ZjhCeXRlcyhqc29uKTtjb25zdCB1cGRhdGVkPXR5cGVvZiBjb25uZWN0aW9uPT09XCJzdHJpbmdcIj97dXJsOmNvbm5lY3Rpb259OnNoYWxsb3dDb3B5KGNvbm5lY3Rpb24pO2lmKHVwZGF0ZWQuaGVhZGVycyl7Y29uc3QgaGFzQ29udGVudFR5cGU9T2JqZWN0LmtleXModXBkYXRlZC5oZWFkZXJzKS5maWx0ZXIoaz0+ay50b0xvd2VyQ2FzZSgpPT09XCJjb250ZW50LXR5cGVcIikubGVuZ3RoIT09MDtpZighaGFzQ29udGVudFR5cGUpe3VwZGF0ZWQuaGVhZGVycz1zaGFsbG93Q29weSh1cGRhdGVkLmhlYWRlcnMpO3VwZGF0ZWQuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXT1cImFwcGxpY2F0aW9uL2pzb25cIn19ZWxzZXt1cGRhdGVkLmhlYWRlcnM9e1wiY29udGVudC10eXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fWNvbm5lY3Rpb249dXBkYXRlZH1yZXR1cm4gX2ZldGNoRGF0YShjb25uZWN0aW9uLGJvZHkscHJvY2Vzc0pzb25GdW5jKX1mdW5jdGlvbiBwb2xsKGZ1bmMsb3B0aW9ucyl7aWYoIW9wdGlvbnMpe29wdGlvbnM9e319b3B0aW9ucz1zaGFsbG93Q29weShvcHRpb25zKTtpZihvcHRpb25zLmZsb29yPT1udWxsKXtvcHRpb25zLmZsb29yPTB9aWYob3B0aW9ucy5jZWlsaW5nPT1udWxsKXtvcHRpb25zLmNlaWxpbmc9MWU0fWlmKG9wdGlvbnMuaW50ZXJ2YWw9PW51bGwpe29wdGlvbnMuaW50ZXJ2YWw9MjUwfXJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7bGV0IHRpbWVyPW51bGw7bGV0IGRvbmU9ZmFsc2U7Y29uc3QgY2FuY2VsPSgpPT57aWYoZG9uZSl7cmV0dXJuIGZhbHNlfWRvbmU9dHJ1ZTtpZih0aW1lcil7Y2xlYXJUaW1lb3V0KHRpbWVyKX1yZXR1cm4gdHJ1ZX07aWYob3B0aW9ucy50aW1lb3V0KXt0aW1lcj1zZXRUaW1lb3V0KCgpPT57aWYoY2FuY2VsKCkpe3JlamVjdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKX19LG9wdGlvbnMudGltZW91dCl9Y29uc3QgcmV0cnlMaW1pdD1vcHRpb25zLnJldHJ5TGltaXQ7bGV0IGF0dGVtcHQ9MDtmdW5jdGlvbiBjaGVjaygpe3JldHVybiBmdW5jKCkudGhlbihmdW5jdGlvbihyZXN1bHQpe2lmKHJlc3VsdCE9PXVuZGVmaW5lZCl7aWYoY2FuY2VsKCkpe3Jlc29sdmUocmVzdWx0KX19ZWxzZSBpZihvcHRpb25zLm9uY2VQb2xsKXtvcHRpb25zLm9uY2VQb2xsLm9uY2UoXCJwb2xsXCIsY2hlY2spfWVsc2UgaWYob3B0aW9ucy5vbmNlQmxvY2spe29wdGlvbnMub25jZUJsb2NrLm9uY2UoXCJibG9ja1wiLGNoZWNrKX1lbHNlIGlmKCFkb25lKXthdHRlbXB0Kys7aWYoYXR0ZW1wdD5yZXRyeUxpbWl0KXtpZihjYW5jZWwoKSl7cmVqZWN0KG5ldyBFcnJvcihcInJldHJ5IGxpbWl0IHJlYWNoZWRcIikpfXJldHVybn1sZXQgdGltZW91dD1vcHRpb25zLmludGVydmFsKnBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpKk1hdGgucG93KDIsYXR0ZW1wdCkpKTtpZih0aW1lb3V0PG9wdGlvbnMuZmxvb3Ipe3RpbWVvdXQ9b3B0aW9ucy5mbG9vcn1pZih0aW1lb3V0Pm9wdGlvbnMuY2VpbGluZyl7dGltZW91dD1vcHRpb25zLmNlaWxpbmd9c2V0VGltZW91dChjaGVjayx0aW1lb3V0KX1yZXR1cm4gbnVsbH0sZnVuY3Rpb24oZXJyb3Ipe2lmKGNhbmNlbCgpKXtyZWplY3QoZXJyb3IpfX0pfWNoZWNrKCl9KX1cInVzZSBzdHJpY3RcIjt2YXIgQUxQSEFCRVQ9XCJxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bFwiO3ZhciBBTFBIQUJFVF9NQVA9e307Zm9yKHZhciB6PTA7ejxBTFBIQUJFVC5sZW5ndGg7eisrKXt2YXIgeD1BTFBIQUJFVC5jaGFyQXQoeik7aWYoQUxQSEFCRVRfTUFQW3hdIT09dW5kZWZpbmVkKXRocm93IG5ldyBUeXBlRXJyb3IoeCtcIiBpcyBhbWJpZ3VvdXNcIik7QUxQSEFCRVRfTUFQW3hdPXp9ZnVuY3Rpb24gcG9seW1vZFN0ZXAocHJlKXt2YXIgYj1wcmU+PjI1O3JldHVybihwcmUmMzM1NTQ0MzEpPDw1Xi0oYj4+MCYxKSY5OTY4MjUwMTBeLShiPj4xJjEpJjY0MjgxMzU0OV4tKGI+PjImMSkmNTEzODc0NDI2Xi0oYj4+MyYxKSYxMDI3NzQ4ODI5Xi0oYj4+NCYxKSY3MDU5NzkwNTl9ZnVuY3Rpb24gcHJlZml4Q2hrKHByZWZpeCl7dmFyIGNoaz0xO2Zvcih2YXIgaT0wO2k8cHJlZml4Lmxlbmd0aDsrK2kpe3ZhciBjPXByZWZpeC5jaGFyQ29kZUF0KGkpO2lmKGM8MzN8fGM+MTI2KXJldHVyblwiSW52YWxpZCBwcmVmaXggKFwiK3ByZWZpeCtcIilcIjtjaGs9cG9seW1vZFN0ZXAoY2hrKV5jPj41fWNoaz1wb2x5bW9kU3RlcChjaGspO2ZvcihpPTA7aTxwcmVmaXgubGVuZ3RoOysraSl7dmFyIHY9cHJlZml4LmNoYXJDb2RlQXQoaSk7Y2hrPXBvbHltb2RTdGVwKGNoaylediYzMX1yZXR1cm4gY2hrfWZ1bmN0aW9uIGVuY29kZSQyKHByZWZpeCx3b3JkcyxMSU1JVCl7TElNSVQ9TElNSVR8fDkwO2lmKHByZWZpeC5sZW5ndGgrNyt3b3Jkcy5sZW5ndGg+TElNSVQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4Y2VlZHMgbGVuZ3RoIGxpbWl0XCIpO3ByZWZpeD1wcmVmaXgudG9Mb3dlckNhc2UoKTt2YXIgY2hrPXByZWZpeENoayhwcmVmaXgpO2lmKHR5cGVvZiBjaGs9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihjaGspO3ZhciByZXN1bHQ9cHJlZml4K1wiMVwiO2Zvcih2YXIgaT0wO2k8d29yZHMubGVuZ3RoOysraSl7dmFyIHg9d29yZHNbaV07aWYoeD4+NSE9PTApdGhyb3cgbmV3IEVycm9yKFwiTm9uIDUtYml0IHdvcmRcIik7Y2hrPXBvbHltb2RTdGVwKGNoayleeDtyZXN1bHQrPUFMUEhBQkVULmNoYXJBdCh4KX1mb3IoaT0wO2k8NjsrK2kpe2Noaz1wb2x5bW9kU3RlcChjaGspfWNoa149MTtmb3IoaT0wO2k8NjsrK2kpe3ZhciB2PWNoaz4+KDUtaSkqNSYzMTtyZXN1bHQrPUFMUEhBQkVULmNoYXJBdCh2KX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIF9fZGVjb2RlKHN0cixMSU1JVCl7TElNSVQ9TElNSVR8fDkwO2lmKHN0ci5sZW5ndGg8OClyZXR1cm4gc3RyK1wiIHRvbyBzaG9ydFwiO2lmKHN0ci5sZW5ndGg+TElNSVQpcmV0dXJuXCJFeGNlZWRzIGxlbmd0aCBsaW1pdFwiO3ZhciBsb3dlcmVkPXN0ci50b0xvd2VyQ2FzZSgpO3ZhciB1cHBlcmVkPXN0ci50b1VwcGVyQ2FzZSgpO2lmKHN0ciE9PWxvd2VyZWQmJnN0ciE9PXVwcGVyZWQpcmV0dXJuXCJNaXhlZC1jYXNlIHN0cmluZyBcIitzdHI7c3RyPWxvd2VyZWQ7dmFyIHNwbGl0PXN0ci5sYXN0SW5kZXhPZihcIjFcIik7aWYoc3BsaXQ9PT0tMSlyZXR1cm5cIk5vIHNlcGFyYXRvciBjaGFyYWN0ZXIgZm9yIFwiK3N0cjtpZihzcGxpdD09PTApcmV0dXJuXCJNaXNzaW5nIHByZWZpeCBmb3IgXCIrc3RyO3ZhciBwcmVmaXg9c3RyLnNsaWNlKDAsc3BsaXQpO3ZhciB3b3JkQ2hhcnM9c3RyLnNsaWNlKHNwbGl0KzEpO2lmKHdvcmRDaGFycy5sZW5ndGg8NilyZXR1cm5cIkRhdGEgdG9vIHNob3J0XCI7dmFyIGNoaz1wcmVmaXhDaGsocHJlZml4KTtpZih0eXBlb2YgY2hrPT09XCJzdHJpbmdcIilyZXR1cm4gY2hrO3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MDtpPHdvcmRDaGFycy5sZW5ndGg7KytpKXt2YXIgYz13b3JkQ2hhcnMuY2hhckF0KGkpO3ZhciB2PUFMUEhBQkVUX01BUFtjXTtpZih2PT09dW5kZWZpbmVkKXJldHVyblwiVW5rbm93biBjaGFyYWN0ZXIgXCIrYztjaGs9cG9seW1vZFN0ZXAoY2hrKV52O2lmKGkrNj49d29yZENoYXJzLmxlbmd0aCljb250aW51ZTt3b3Jkcy5wdXNoKHYpfWlmKGNoayE9PTEpcmV0dXJuXCJJbnZhbGlkIGNoZWNrc3VtIGZvciBcIitzdHI7cmV0dXJue3ByZWZpeDpwcmVmaXgsd29yZHM6d29yZHN9fWZ1bmN0aW9uIGRlY29kZVVuc2FmZSgpe3ZhciByZXM9X19kZWNvZGUuYXBwbHkobnVsbCxhcmd1bWVudHMpO2lmKHR5cGVvZiByZXM9PT1cIm9iamVjdFwiKXJldHVybiByZXN9ZnVuY3Rpb24gZGVjb2RlJDIoc3RyKXt2YXIgcmVzPV9fZGVjb2RlLmFwcGx5KG51bGwsYXJndW1lbnRzKTtpZih0eXBlb2YgcmVzPT09XCJvYmplY3RcIilyZXR1cm4gcmVzO3Rocm93IG5ldyBFcnJvcihyZXMpfWZ1bmN0aW9uIGNvbnZlcnQoZGF0YSxpbkJpdHMsb3V0Qml0cyxwYWQpe3ZhciB2YWx1ZT0wO3ZhciBiaXRzPTA7dmFyIG1heFY9KDE8PG91dEJpdHMpLTE7dmFyIHJlc3VsdD1bXTtmb3IodmFyIGk9MDtpPGRhdGEubGVuZ3RoOysraSl7dmFsdWU9dmFsdWU8PGluQml0c3xkYXRhW2ldO2JpdHMrPWluQml0czt3aGlsZShiaXRzPj1vdXRCaXRzKXtiaXRzLT1vdXRCaXRzO3Jlc3VsdC5wdXNoKHZhbHVlPj5iaXRzJm1heFYpfX1pZihwYWQpe2lmKGJpdHM+MCl7cmVzdWx0LnB1c2godmFsdWU8PG91dEJpdHMtYml0cyZtYXhWKX19ZWxzZXtpZihiaXRzPj1pbkJpdHMpcmV0dXJuXCJFeGNlc3MgcGFkZGluZ1wiO2lmKHZhbHVlPDxvdXRCaXRzLWJpdHMmbWF4VilyZXR1cm5cIk5vbi16ZXJvIHBhZGRpbmdcIn1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIHRvV29yZHNVbnNhZmUoYnl0ZXMpe3ZhciByZXM9Y29udmVydChieXRlcyw4LDUsdHJ1ZSk7aWYoQXJyYXkuaXNBcnJheShyZXMpKXJldHVybiByZXN9ZnVuY3Rpb24gdG9Xb3JkcyhieXRlcyl7dmFyIHJlcz1jb252ZXJ0KGJ5dGVzLDgsNSx0cnVlKTtpZihBcnJheS5pc0FycmF5KHJlcykpcmV0dXJuIHJlczt0aHJvdyBuZXcgRXJyb3IocmVzKX1mdW5jdGlvbiBmcm9tV29yZHNVbnNhZmUod29yZHMpe3ZhciByZXM9Y29udmVydCh3b3Jkcyw1LDgsZmFsc2UpO2lmKEFycmF5LmlzQXJyYXkocmVzKSlyZXR1cm4gcmVzfWZ1bmN0aW9uIGZyb21Xb3Jkcyh3b3Jkcyl7dmFyIHJlcz1jb252ZXJ0KHdvcmRzLDUsOCxmYWxzZSk7aWYoQXJyYXkuaXNBcnJheShyZXMpKXJldHVybiByZXM7dGhyb3cgbmV3IEVycm9yKHJlcyl9dmFyIGJlY2gzMj17ZGVjb2RlVW5zYWZlOmRlY29kZVVuc2FmZSxkZWNvZGU6ZGVjb2RlJDIsZW5jb2RlOmVuY29kZSQyLHRvV29yZHNVbnNhZmU6dG9Xb3Jkc1Vuc2FmZSx0b1dvcmRzOnRvV29yZHMsZnJvbVdvcmRzVW5zYWZlOmZyb21Xb3Jkc1Vuc2FmZSxmcm9tV29yZHM6ZnJvbVdvcmRzfTtjb25zdCB2ZXJzaW9uJG09XCJwcm92aWRlcnMvNS4xLjJcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkcz1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7Y2xhc3MgRm9ybWF0dGVye2NvbnN0cnVjdG9yKCl7bG9nZ2VyJHMuY2hlY2tOZXcobmV3LnRhcmdldCxGb3JtYXR0ZXIpO3RoaXMuZm9ybWF0cz10aGlzLmdldERlZmF1bHRGb3JtYXRzKCl9Z2V0RGVmYXVsdEZvcm1hdHMoKXtjb25zdCBmb3JtYXRzPXt9O2NvbnN0IGFkZHJlc3M9dGhpcy5hZGRyZXNzLmJpbmQodGhpcyk7Y29uc3QgYmlnTnVtYmVyPXRoaXMuYmlnTnVtYmVyLmJpbmQodGhpcyk7Y29uc3QgYmxvY2tUYWc9dGhpcy5ibG9ja1RhZy5iaW5kKHRoaXMpO2NvbnN0IGRhdGE9dGhpcy5kYXRhLmJpbmQodGhpcyk7Y29uc3QgaGFzaD10aGlzLmhhc2guYmluZCh0aGlzKTtjb25zdCBoZXg9dGhpcy5oZXguYmluZCh0aGlzKTtjb25zdCBudW1iZXI9dGhpcy5udW1iZXIuYmluZCh0aGlzKTtjb25zdCBzdHJpY3REYXRhPXY9PntyZXR1cm4gdGhpcy5kYXRhKHYsdHJ1ZSl9O2Zvcm1hdHMudHJhbnNhY3Rpb249e2hhc2g6aGFzaCx0eXBlOkZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLG51bGwpLGFjY2Vzc0xpc3Q6Rm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSxudWxsKSxibG9ja0hhc2g6Rm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLG51bGwpLGJsb2NrTnVtYmVyOkZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLG51bGwpLHRyYW5zYWN0aW9uSW5kZXg6Rm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsbnVsbCksY29uZmlybWF0aW9uczpGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlcixudWxsKSxmcm9tOmFkZHJlc3MsZ2FzUHJpY2U6YmlnTnVtYmVyLGdhc0xpbWl0OmJpZ051bWJlcix0bzpGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsbnVsbCksdmFsdWU6YmlnTnVtYmVyLG5vbmNlOm51bWJlcixkYXRhOmRhdGEscjpGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksczpGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksdjpGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksY3JlYXRlczpGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsbnVsbCkscmF3OkZvcm1hdHRlci5hbGxvd051bGwoZGF0YSl9O2Zvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0PXtmcm9tOkZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksbm9uY2U6Rm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLGdhc0xpbWl0OkZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxnYXNQcmljZTpGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksdG86Rm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSx2YWx1ZTpGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksZGF0YTpGb3JtYXR0ZXIuYWxsb3dOdWxsKHN0cmljdERhdGEpLHR5cGU6Rm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLGFjY2Vzc0xpc3Q6Rm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSxudWxsKX07Zm9ybWF0cy5yZWNlaXB0TG9nPXt0cmFuc2FjdGlvbkluZGV4Om51bWJlcixibG9ja051bWJlcjpudW1iZXIsdHJhbnNhY3Rpb25IYXNoOmhhc2gsYWRkcmVzczphZGRyZXNzLHRvcGljczpGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSxkYXRhOmRhdGEsbG9nSW5kZXg6bnVtYmVyLGJsb2NrSGFzaDpoYXNofTtmb3JtYXRzLnJlY2VpcHQ9e3RvOkZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hZGRyZXNzLG51bGwpLGZyb206Rm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsbnVsbCksY29udHJhY3RBZGRyZXNzOkZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyxudWxsKSx0cmFuc2FjdGlvbkluZGV4Om51bWJlcixyb290OkZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxnYXNVc2VkOmJpZ051bWJlcixsb2dzQmxvb206Rm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxibG9ja0hhc2g6aGFzaCx0cmFuc2FjdGlvbkhhc2g6aGFzaCxsb2dzOkZvcm1hdHRlci5hcnJheU9mKHRoaXMucmVjZWlwdExvZy5iaW5kKHRoaXMpKSxibG9ja051bWJlcjpudW1iZXIsY29uZmlybWF0aW9uczpGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlcixudWxsKSxjdW11bGF0aXZlR2FzVXNlZDpiaWdOdW1iZXIsc3RhdHVzOkZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKX07Zm9ybWF0cy5ibG9jaz17aGFzaDpoYXNoLHBhcmVudEhhc2g6aGFzaCxudW1iZXI6bnVtYmVyLHRpbWVzdGFtcDpudW1iZXIsbm9uY2U6Rm9ybWF0dGVyLmFsbG93TnVsbChoZXgpLGRpZmZpY3VsdHk6dGhpcy5kaWZmaWN1bHR5LmJpbmQodGhpcyksZ2FzTGltaXQ6YmlnTnVtYmVyLGdhc1VzZWQ6YmlnTnVtYmVyLG1pbmVyOmFkZHJlc3MsZXh0cmFEYXRhOmRhdGEsdHJhbnNhY3Rpb25zOkZvcm1hdHRlci5hbGxvd051bGwoRm9ybWF0dGVyLmFycmF5T2YoaGFzaCkpfTtmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucz1zaGFsbG93Q29weShmb3JtYXRzLmJsb2NrKTtmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucy50cmFuc2FjdGlvbnM9Rm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO2Zvcm1hdHMuZmlsdGVyPXtmcm9tQmxvY2s6Rm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZyx1bmRlZmluZWQpLHRvQmxvY2s6Rm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZyx1bmRlZmluZWQpLGJsb2NrSGFzaDpGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsdW5kZWZpbmVkKSxhZGRyZXNzOkZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyx1bmRlZmluZWQpLHRvcGljczpGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudG9waWNzLmJpbmQodGhpcyksdW5kZWZpbmVkKX07Zm9ybWF0cy5maWx0ZXJMb2c9e2Jsb2NrTnVtYmVyOkZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxibG9ja0hhc2g6Rm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSx0cmFuc2FjdGlvbkluZGV4Om51bWJlcixyZW1vdmVkOkZvcm1hdHRlci5hbGxvd051bGwodGhpcy5ib29sZWFuLmJpbmQodGhpcykpLGFkZHJlc3M6YWRkcmVzcyxkYXRhOkZvcm1hdHRlci5hbGxvd0ZhbHNpc2goZGF0YSxcIjB4XCIpLHRvcGljczpGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSx0cmFuc2FjdGlvbkhhc2g6aGFzaCxsb2dJbmRleDpudW1iZXJ9O3JldHVybiBmb3JtYXRzfWFjY2Vzc0xpc3QoYWNjZXNzTGlzdCl7cmV0dXJuIGFjY2Vzc0xpc3RpZnkoYWNjZXNzTGlzdHx8W10pfW51bWJlcihudW1iZXIpe2lmKG51bWJlcj09PVwiMHhcIil7cmV0dXJuIDB9cmV0dXJuIEJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKX1iaWdOdW1iZXIodmFsdWUpe3JldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSl9Ym9vbGVhbih2YWx1ZSl7aWYodHlwZW9mIHZhbHVlPT09XCJib29sZWFuXCIpe3JldHVybiB2YWx1ZX1pZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXt2YWx1ZT12YWx1ZS50b0xvd2VyQ2FzZSgpO2lmKHZhbHVlPT09XCJ0cnVlXCIpe3JldHVybiB0cnVlfWlmKHZhbHVlPT09XCJmYWxzZVwiKXtyZXR1cm4gZmFsc2V9fXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9vbGVhbiAtIFwiK3ZhbHVlKX1oZXgodmFsdWUsc3RyaWN0KXtpZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtpZighc3RyaWN0JiZ2YWx1ZS5zdWJzdHJpbmcoMCwyKSE9PVwiMHhcIil7dmFsdWU9XCIweFwiK3ZhbHVlfWlmKGlzSGV4U3RyaW5nKHZhbHVlKSl7cmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCl9fXJldHVybiBsb2dnZXIkcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIixcInZhbHVlXCIsdmFsdWUpfWRhdGEodmFsdWUsc3RyaWN0KXtjb25zdCByZXN1bHQ9dGhpcy5oZXgodmFsdWUsc3RyaWN0KTtpZihyZXN1bHQubGVuZ3RoJTIhPT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGE7IG9kZC1sZW5ndGggLSBcIit2YWx1ZSl9cmV0dXJuIHJlc3VsdH1hZGRyZXNzKHZhbHVlKXtyZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSl9Y2FsbEFkZHJlc3ModmFsdWUpe2lmKCFpc0hleFN0cmluZyh2YWx1ZSwzMikpe3JldHVybiBudWxsfWNvbnN0IGFkZHJlc3M9Z2V0QWRkcmVzcyhoZXhEYXRhU2xpY2UodmFsdWUsMTIpKTtyZXR1cm4gYWRkcmVzcz09PUFkZHJlc3NaZXJvP251bGw6YWRkcmVzc31jb250cmFjdEFkZHJlc3ModmFsdWUpe3JldHVybiBnZXRDb250cmFjdEFkZHJlc3ModmFsdWUpfWJsb2NrVGFnKGJsb2NrVGFnKXtpZihibG9ja1RhZz09bnVsbCl7cmV0dXJuXCJsYXRlc3RcIn1pZihibG9ja1RhZz09PVwiZWFybGllc3RcIil7cmV0dXJuXCIweDBcIn1pZihibG9ja1RhZz09PVwibGF0ZXN0XCJ8fGJsb2NrVGFnPT09XCJwZW5kaW5nXCIpe3JldHVybiBibG9ja1RhZ31pZih0eXBlb2YgYmxvY2tUYWc9PT1cIm51bWJlclwifHxpc0hleFN0cmluZyhibG9ja1RhZykpe3JldHVybiBoZXhWYWx1ZShibG9ja1RhZyl9dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBibG9ja1RhZ1wiKX1oYXNoKHZhbHVlLHN0cmljdCl7Y29uc3QgcmVzdWx0PXRoaXMuaGV4KHZhbHVlLHN0cmljdCk7aWYoaGV4RGF0YUxlbmd0aChyZXN1bHQpIT09MzIpe3JldHVybiBsb2dnZXIkcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIixcInZhbHVlXCIsdmFsdWUpfXJldHVybiByZXN1bHR9ZGlmZmljdWx0eSh2YWx1ZSl7aWYodmFsdWU9PW51bGwpe3JldHVybiBudWxsfWNvbnN0IHY9QmlnTnVtYmVyLmZyb20odmFsdWUpO3RyeXtyZXR1cm4gdi50b051bWJlcigpfWNhdGNoKGVycm9yKXt9cmV0dXJuIG51bGx9dWludDI1Nih2YWx1ZSl7aWYoIWlzSGV4U3RyaW5nKHZhbHVlKSl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpfXJldHVybiBoZXhaZXJvUGFkKHZhbHVlLDMyKX1fYmxvY2sodmFsdWUsZm9ybWF0KXtpZih2YWx1ZS5hdXRob3IhPW51bGwmJnZhbHVlLm1pbmVyPT1udWxsKXt2YWx1ZS5taW5lcj12YWx1ZS5hdXRob3J9cmV0dXJuIEZvcm1hdHRlci5jaGVjayhmb3JtYXQsdmFsdWUpfWJsb2NrKHZhbHVlKXtyZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsdGhpcy5mb3JtYXRzLmJsb2NrKX1ibG9ja1dpdGhUcmFuc2FjdGlvbnModmFsdWUpe3JldHVybiB0aGlzLl9ibG9jayh2YWx1ZSx0aGlzLmZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKX10cmFuc2FjdGlvblJlcXVlc3QodmFsdWUpe3JldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCx2YWx1ZSl9dHJhbnNhY3Rpb25SZXNwb25zZSh0cmFuc2FjdGlvbil7aWYodHJhbnNhY3Rpb24uZ2FzIT1udWxsJiZ0cmFuc2FjdGlvbi5nYXNMaW1pdD09bnVsbCl7dHJhbnNhY3Rpb24uZ2FzTGltaXQ9dHJhbnNhY3Rpb24uZ2FzfWlmKHRyYW5zYWN0aW9uLnRvJiZCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi50bykuaXNaZXJvKCkpe3RyYW5zYWN0aW9uLnRvPVwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJ9aWYodHJhbnNhY3Rpb24uaW5wdXQhPW51bGwmJnRyYW5zYWN0aW9uLmRhdGE9PW51bGwpe3RyYW5zYWN0aW9uLmRhdGE9dHJhbnNhY3Rpb24uaW5wdXR9aWYodHJhbnNhY3Rpb24udG89PW51bGwmJnRyYW5zYWN0aW9uLmNyZWF0ZXM9PW51bGwpe3RyYW5zYWN0aW9uLmNyZWF0ZXM9dGhpcy5jb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pfWlmKHRyYW5zYWN0aW9uLnR5cGU9PT0xJiZ0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0PT1udWxsKXt0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0PVtdfWNvbnN0IHJlc3VsdD1Gb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uLHRyYW5zYWN0aW9uKTtpZih0cmFuc2FjdGlvbi5jaGFpbklkIT1udWxsKXtsZXQgY2hhaW5JZD10cmFuc2FjdGlvbi5jaGFpbklkO2lmKGlzSGV4U3RyaW5nKGNoYWluSWQpKXtjaGFpbklkPUJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCl9cmVzdWx0LmNoYWluSWQ9Y2hhaW5JZH1lbHNle2xldCBjaGFpbklkPXRyYW5zYWN0aW9uLm5ldHdvcmtJZDtpZihjaGFpbklkPT1udWxsJiZyZXN1bHQudj09bnVsbCl7Y2hhaW5JZD10cmFuc2FjdGlvbi5jaGFpbklkfWlmKGlzSGV4U3RyaW5nKGNoYWluSWQpKXtjaGFpbklkPUJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCl9aWYodHlwZW9mIGNoYWluSWQhPT1cIm51bWJlclwiJiZyZXN1bHQudiE9bnVsbCl7Y2hhaW5JZD0ocmVzdWx0LnYtMzUpLzI7aWYoY2hhaW5JZDwwKXtjaGFpbklkPTB9Y2hhaW5JZD1wYXJzZUludChjaGFpbklkKX1pZih0eXBlb2YgY2hhaW5JZCE9PVwibnVtYmVyXCIpe2NoYWluSWQ9MH1yZXN1bHQuY2hhaW5JZD1jaGFpbklkfWlmKHJlc3VsdC5ibG9ja0hhc2gmJnJlc3VsdC5ibG9ja0hhc2gucmVwbGFjZSgvMC9nLFwiXCIpPT09XCJ4XCIpe3Jlc3VsdC5ibG9ja0hhc2g9bnVsbH1yZXR1cm4gcmVzdWx0fXRyYW5zYWN0aW9uKHZhbHVlKXtyZXR1cm4gcGFyc2UodmFsdWUpfXJlY2VpcHRMb2codmFsdWUpe3JldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnJlY2VpcHRMb2csdmFsdWUpfXJlY2VpcHQodmFsdWUpe2NvbnN0IHJlc3VsdD1Gb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnJlY2VpcHQsdmFsdWUpO2lmKHJlc3VsdC5yb290IT1udWxsKXtpZihyZXN1bHQucm9vdC5sZW5ndGg8PTQpe2NvbnN0IHZhbHVlPUJpZ051bWJlci5mcm9tKHJlc3VsdC5yb290KS50b051bWJlcigpO2lmKHZhbHVlPT09MHx8dmFsdWU9PT0xKXtpZihyZXN1bHQuc3RhdHVzIT1udWxsJiZyZXN1bHQuc3RhdHVzIT09dmFsdWUpe2xvZ2dlciRzLnRocm93QXJndW1lbnRFcnJvcihcImFsdC1yb290LXN0YXR1cy9zdGF0dXMgbWlzbWF0Y2hcIixcInZhbHVlXCIse3Jvb3Q6cmVzdWx0LnJvb3Qsc3RhdHVzOnJlc3VsdC5zdGF0dXN9KX1yZXN1bHQuc3RhdHVzPXZhbHVlO2RlbGV0ZSByZXN1bHQucm9vdH1lbHNle2xvZ2dlciRzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWx0LXJvb3Qtc3RhdHVzXCIsXCJ2YWx1ZS5yb290XCIscmVzdWx0LnJvb3QpfX1lbHNlIGlmKHJlc3VsdC5yb290Lmxlbmd0aCE9PTY2KXtsb2dnZXIkcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJvb3QgaGFzaFwiLFwidmFsdWUucm9vdFwiLHJlc3VsdC5yb290KX19aWYocmVzdWx0LnN0YXR1cyE9bnVsbCl7cmVzdWx0LmJ5emFudGl1bT10cnVlfXJldHVybiByZXN1bHR9dG9waWNzKHZhbHVlKXtpZihBcnJheS5pc0FycmF5KHZhbHVlKSl7cmV0dXJuIHZhbHVlLm1hcCh2PT50aGlzLnRvcGljcyh2KSl9ZWxzZSBpZih2YWx1ZSE9bnVsbCl7cmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSx0cnVlKX1yZXR1cm4gbnVsbH1maWx0ZXIodmFsdWUpe3JldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlcix2YWx1ZSl9ZmlsdGVyTG9nKHZhbHVlKXtyZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csdmFsdWUpfXN0YXRpYyBjaGVjayhmb3JtYXQsb2JqZWN0KXtjb25zdCByZXN1bHQ9e307Zm9yKGNvbnN0IGtleSBpbiBmb3JtYXQpe3RyeXtjb25zdCB2YWx1ZT1mb3JtYXRba2V5XShvYmplY3Rba2V5XSk7aWYodmFsdWUhPT11bmRlZmluZWQpe3Jlc3VsdFtrZXldPXZhbHVlfX1jYXRjaChlcnJvcil7ZXJyb3IuY2hlY2tLZXk9a2V5O2Vycm9yLmNoZWNrVmFsdWU9b2JqZWN0W2tleV07dGhyb3cgZXJyb3J9fXJldHVybiByZXN1bHR9c3RhdGljIGFsbG93TnVsbChmb3JtYXQsbnVsbFZhbHVlKXtyZXR1cm4gZnVuY3Rpb24odmFsdWUpe2lmKHZhbHVlPT1udWxsKXtyZXR1cm4gbnVsbFZhbHVlfXJldHVybiBmb3JtYXQodmFsdWUpfX1zdGF0aWMgYWxsb3dGYWxzaXNoKGZvcm1hdCxyZXBsYWNlVmFsdWUpe3JldHVybiBmdW5jdGlvbih2YWx1ZSl7aWYoIXZhbHVlKXtyZXR1cm4gcmVwbGFjZVZhbHVlfXJldHVybiBmb3JtYXQodmFsdWUpfX1zdGF0aWMgYXJyYXlPZihmb3JtYXQpe3JldHVybiBmdW5jdGlvbihhcnJheSl7aWYoIUFycmF5LmlzQXJyYXkoYXJyYXkpKXt0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXlcIil9Y29uc3QgcmVzdWx0PVtdO2FycmF5LmZvckVhY2goZnVuY3Rpb24odmFsdWUpe3Jlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpfSk7cmV0dXJuIHJlc3VsdH19fWZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpe3JldHVybiB2YWx1ZSYmdHlwZW9mIHZhbHVlLmlzQ29tbXVuaXR5UmVzb3VyY2U9PT1cImZ1bmN0aW9uXCJ9ZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjZSh2YWx1ZSl7cmV0dXJuIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpJiZ2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKCl9bGV0IHRocm90dGxlTWVzc2FnZT1mYWxzZTtmdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKCl7aWYodGhyb3R0bGVNZXNzYWdlKXtyZXR1cm59dGhyb3R0bGVNZXNzYWdlPXRydWU7Y29uc29sZS5sb2coXCI9PT09PT09PT0gTk9USUNFID09PT09PT09PVwiKTtjb25zb2xlLmxvZyhcIlJlcXVlc3QtUmF0ZSBFeGNlZWRlZCAgKHRoaXMgbWVzc2FnZSB3aWxsIG5vdCBiZSByZXBlYXRlZClcIik7Y29uc29sZS5sb2coXCJcIik7Y29uc29sZS5sb2coXCJUaGUgZGVmYXVsdCBBUEkga2V5cyBmb3IgZWFjaCBzZXJ2aWNlIGFyZSBwcm92aWRlZCBhcyBhIGhpZ2hseS10aHJvdHRsZWQsXCIpO2NvbnNvbGUubG9nKFwiY29tbXVuaXR5IHJlc291cmNlIGZvciBsb3ctdHJhZmZpYyBwcm9qZWN0cyBhbmQgZWFybHkgcHJvdG90eXBpbmcuXCIpO2NvbnNvbGUubG9nKFwiXCIpO2NvbnNvbGUubG9nKFwiV2hpbGUgeW91ciBhcHBsaWNhdGlvbiB3aWxsIGNvbnRpbnVlIHRvIGZ1bmN0aW9uLCB3ZSBoaWdobHkgcmVjb21tZW5kZWRcIik7Y29uc29sZS5sb2coXCJzaWduaW5nIHVwIGZvciB5b3VyIG93biBBUEkga2V5cyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBpbmNyZWFzZSB5b3VyXCIpO2NvbnNvbGUubG9nKFwicmVxdWVzdCByYXRlL2xpbWl0IGFuZCBlbmFibGUgb3RoZXIgcGVya3MsIHN1Y2ggYXMgbWV0cmljcyBhbmQgYWR2YW5jZWQgQVBJcy5cIik7Y29uc29sZS5sb2coXCJcIik7Y29uc29sZS5sb2coXCJGb3IgbW9yZSBkZXRhaWxzOiBodHRwczovL2RvY3MuZXRoZXJzLmlvL2FwaS1rZXlzL1wiKTtjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09XCIpfVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkOD13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJHQ9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2Z1bmN0aW9uIGNoZWNrVG9waWModG9waWMpe2lmKHRvcGljPT1udWxsKXtyZXR1cm5cIm51bGxcIn1pZihoZXhEYXRhTGVuZ3RoKHRvcGljKSE9PTMyKXtsb2dnZXIkdC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsXCJ0b3BpY1wiLHRvcGljKX1yZXR1cm4gdG9waWMudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiBzZXJpYWxpemVUb3BpY3ModG9waWNzKXt0b3BpY3M9dG9waWNzLnNsaWNlKCk7d2hpbGUodG9waWNzLmxlbmd0aD4wJiZ0b3BpY3NbdG9waWNzLmxlbmd0aC0xXT09bnVsbCl7dG9waWNzLnBvcCgpfXJldHVybiB0b3BpY3MubWFwKHRvcGljPT57aWYoQXJyYXkuaXNBcnJheSh0b3BpYykpe2NvbnN0IHVuaXF1ZT17fTt0b3BpYy5mb3JFYWNoKHRvcGljPT57dW5pcXVlW2NoZWNrVG9waWModG9waWMpXT10cnVlfSk7Y29uc3Qgc29ydGVkPU9iamVjdC5rZXlzKHVuaXF1ZSk7c29ydGVkLnNvcnQoKTtyZXR1cm4gc29ydGVkLmpvaW4oXCJ8XCIpfWVsc2V7cmV0dXJuIGNoZWNrVG9waWModG9waWMpfX0pLmpvaW4oXCImXCIpfWZ1bmN0aW9uIGRlc2VyaWFsaXplVG9waWNzKGRhdGEpe2lmKGRhdGE9PT1cIlwiKXtyZXR1cm5bXX1yZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAodG9waWM9PntpZih0b3BpYz09PVwiXCIpe3JldHVybltdfWNvbnN0IGNvbXBzPXRvcGljLnNwbGl0KFwifFwiKS5tYXAodG9waWM9PntyZXR1cm4gdG9waWM9PT1cIm51bGxcIj9udWxsOnRvcGljfSk7cmV0dXJuIGNvbXBzLmxlbmd0aD09PTE/Y29tcHNbMF06Y29tcHN9KX1mdW5jdGlvbiBnZXRFdmVudFRhZyQxKGV2ZW50TmFtZSl7aWYodHlwZW9mIGV2ZW50TmFtZT09PVwic3RyaW5nXCIpe2V2ZW50TmFtZT1ldmVudE5hbWUudG9Mb3dlckNhc2UoKTtpZihoZXhEYXRhTGVuZ3RoKGV2ZW50TmFtZSk9PT0zMil7cmV0dXJuXCJ0eDpcIitldmVudE5hbWV9aWYoZXZlbnROYW1lLmluZGV4T2YoXCI6XCIpPT09LTEpe3JldHVybiBldmVudE5hbWV9fWVsc2UgaWYoQXJyYXkuaXNBcnJheShldmVudE5hbWUpKXtyZXR1cm5cImZpbHRlcjoqOlwiK3NlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUpfWVsc2UgaWYoRm9ya0V2ZW50LmlzRm9ya0V2ZW50KGV2ZW50TmFtZSkpe2xvZ2dlciR0Lndhcm4oXCJub3QgaW1wbGVtZW50ZWRcIik7dGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpfWVsc2UgaWYoZXZlbnROYW1lJiZ0eXBlb2YgZXZlbnROYW1lPT09XCJvYmplY3RcIil7cmV0dXJuXCJmaWx0ZXI6XCIrKGV2ZW50TmFtZS5hZGRyZXNzfHxcIipcIikrXCI6XCIrc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZS50b3BpY3N8fFtdKX10aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50IC0gXCIrZXZlbnROYW1lKX1mdW5jdGlvbiBnZXRUaW1lKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9ZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pe3JldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlPT57c2V0VGltZW91dChyZXNvbHZlLGR1cmF0aW9uKX0pfWNvbnN0IFBvbGxhYmxlRXZlbnRzPVtcImJsb2NrXCIsXCJuZXR3b3JrXCIsXCJwZW5kaW5nXCIsXCJwb2xsXCJdO2NsYXNzIEV2ZW50e2NvbnN0cnVjdG9yKHRhZyxsaXN0ZW5lcixvbmNlKXtkZWZpbmVSZWFkT25seSh0aGlzLFwidGFnXCIsdGFnKTtkZWZpbmVSZWFkT25seSh0aGlzLFwibGlzdGVuZXJcIixsaXN0ZW5lcik7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIm9uY2VcIixvbmNlKX1nZXQgZXZlbnQoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJ0eFwiOnJldHVybiB0aGlzLmhhc2g7Y2FzZVwiZmlsdGVyXCI6cmV0dXJuIHRoaXMuZmlsdGVyfXJldHVybiB0aGlzLnRhZ31nZXQgdHlwZSgpe3JldHVybiB0aGlzLnRhZy5zcGxpdChcIjpcIilbMF19Z2V0IGhhc2goKXtjb25zdCBjb21wcz10aGlzLnRhZy5zcGxpdChcIjpcIik7aWYoY29tcHNbMF0hPT1cInR4XCIpe3JldHVybiBudWxsfXJldHVybiBjb21wc1sxXX1nZXQgZmlsdGVyKCl7Y29uc3QgY29tcHM9dGhpcy50YWcuc3BsaXQoXCI6XCIpO2lmKGNvbXBzWzBdIT09XCJmaWx0ZXJcIil7cmV0dXJuIG51bGx9Y29uc3QgYWRkcmVzcz1jb21wc1sxXTtjb25zdCB0b3BpY3M9ZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO2NvbnN0IGZpbHRlcj17fTtpZih0b3BpY3MubGVuZ3RoPjApe2ZpbHRlci50b3BpY3M9dG9waWNzfWlmKGFkZHJlc3MmJmFkZHJlc3MhPT1cIipcIil7ZmlsdGVyLmFkZHJlc3M9YWRkcmVzc31yZXR1cm4gZmlsdGVyfXBvbGxhYmxlKCl7cmV0dXJuIHRoaXMudGFnLmluZGV4T2YoXCI6XCIpPj0wfHxQb2xsYWJsZUV2ZW50cy5pbmRleE9mKHRoaXMudGFnKT49MH19Y29uc3QgY29pbkluZm9zPXswOntzeW1ib2w6XCJidGNcIixwMnBraDowLHAyc2g6NSxwcmVmaXg6XCJiY1wifSwyOntzeW1ib2w6XCJsdGNcIixwMnBraDo0OCxwMnNoOjUwLHByZWZpeDpcImx0Y1wifSwzOntzeW1ib2w6XCJkb2dlXCIscDJwa2g6MzAscDJzaDoyMn0sNjA6e3N5bWJvbDpcImV0aFwiLGlsazpcImV0aFwifSw2MTp7c3ltYm9sOlwiZXRjXCIsaWxrOlwiZXRoXCJ9LDcwMDp7c3ltYm9sOlwieGRhaVwiLGlsazpcImV0aFwifX07ZnVuY3Rpb24gYnl0ZXMzMmlmeSh2YWx1ZSl7cmV0dXJuIGhleFplcm9QYWQoQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCksMzIpfWZ1bmN0aW9uIGJhc2U1OEVuY29kZShkYXRhKXtyZXR1cm4gQmFzZTU4LmVuY29kZShjb25jYXQoW2RhdGEsaGV4RGF0YVNsaWNlKHNoYTI1NiQxKHNoYTI1NiQxKGRhdGEpKSwwLDQpXSkpfWNsYXNzIFJlc29sdmVye2NvbnN0cnVjdG9yKHByb3ZpZGVyLGFkZHJlc3MsbmFtZSl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb3ZpZGVyXCIscHJvdmlkZXIpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJuYW1lXCIsbmFtZSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIixwcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKSl9X2ZldGNoQnl0ZXMoc2VsZWN0b3IscGFyYW1ldGVycyl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCB0cmFuc2FjdGlvbj17dG86dGhpcy5hZGRyZXNzLGRhdGE6aGV4Q29uY2F0KFtzZWxlY3RvcixuYW1laGFzaCh0aGlzLm5hbWUpLHBhcmFtZXRlcnN8fFwiMHhcIl0pfTtjb25zdCByZXN1bHQ9eWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHRyYW5zYWN0aW9uKTtpZihyZXN1bHQ9PT1cIjB4XCIpe3JldHVybiBudWxsfWNvbnN0IG9mZnNldD1CaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LDAsMzIpKS50b051bWJlcigpO2NvbnN0IGxlbmd0aD1CaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LG9mZnNldCxvZmZzZXQrMzIpKS50b051bWJlcigpO3JldHVybiBoZXhEYXRhU2xpY2UocmVzdWx0LG9mZnNldCszMixvZmZzZXQrMzIrbGVuZ3RoKX0pfV9nZXRBZGRyZXNzKGNvaW5UeXBlLGhleEJ5dGVzKXtjb25zdCBjb2luSW5mbz1jb2luSW5mb3NbU3RyaW5nKGNvaW5UeXBlKV07aWYoY29pbkluZm89PW51bGwpe2xvZ2dlciR0LnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIGNvaW4gdHlwZTogJHtjb2luVHlwZX1gLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246YGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYH0pfWlmKGNvaW5JbmZvLmlsaz09PVwiZXRoXCIpe3JldHVybiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGhleEJ5dGVzKX1jb25zdCBieXRlcz1hcnJheWlmeShoZXhCeXRlcyk7aWYoY29pbkluZm8ucDJwa2ghPW51bGwpe2NvbnN0IHAycGtoPWhleEJ5dGVzLm1hdGNoKC9eMHg3NmE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4OGFjJC8pO2lmKHAycGtoKXtjb25zdCBsZW5ndGg9cGFyc2VJbnQocDJwa2hbMV0sMTYpO2lmKHAycGtoWzJdLmxlbmd0aD09PWxlbmd0aCoyJiZsZW5ndGg+PTEmJmxlbmd0aDw9NzUpe3JldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJwa2hdLFwiMHhcIitwMnBraFsyXV0pKX19fWlmKGNvaW5JbmZvLnAyc2ghPW51bGwpe2NvbnN0IHAyc2g9aGV4Qnl0ZXMubWF0Y2goL14weGE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4NyQvKTtpZihwMnNoKXtjb25zdCBsZW5ndGg9cGFyc2VJbnQocDJzaFsxXSwxNik7aWYocDJzaFsyXS5sZW5ndGg9PT1sZW5ndGgqMiYmbGVuZ3RoPj0xJiZsZW5ndGg8PTc1KXtyZXR1cm4gYmFzZTU4RW5jb2RlKGNvbmNhdChbW2NvaW5JbmZvLnAyc2hdLFwiMHhcIitwMnNoWzJdXSkpfX19aWYoY29pbkluZm8ucHJlZml4IT1udWxsKXtjb25zdCBsZW5ndGg9Ynl0ZXNbMV07bGV0IHZlcnNpb249Ynl0ZXNbMF07aWYodmVyc2lvbj09PTApe2lmKGxlbmd0aCE9PTIwJiZsZW5ndGghPT0zMil7dmVyc2lvbj0tMX19ZWxzZXt2ZXJzaW9uPS0xfWlmKHZlcnNpb24+PTAmJmJ5dGVzLmxlbmd0aD09PTIrbGVuZ3RoJiZsZW5ndGg+PTEmJmxlbmd0aDw9NzUpe2NvbnN0IHdvcmRzPWJlY2gzMi50b1dvcmRzKGJ5dGVzLnNsaWNlKDIpKTt3b3Jkcy51bnNoaWZ0KHZlcnNpb24pO3JldHVybiBiZWNoMzIuZW5jb2RlKGNvaW5JbmZvLnByZWZpeCx3b3Jkcyl9fXJldHVybiBudWxsfWdldEFkZHJlc3MoY29pblR5cGUpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYoY29pblR5cGU9PW51bGwpe2NvaW5UeXBlPTYwfWlmKGNvaW5UeXBlPT09NjApe2NvbnN0IHRyYW5zYWN0aW9uPXt0bzp0aGlzLmFkZHJlc3MsZGF0YTpcIjB4M2IzYjU3ZGVcIituYW1laGFzaCh0aGlzLm5hbWUpLnN1YnN0cmluZygyKX07Y29uc3QgaGV4Qnl0ZXM9eWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHRyYW5zYWN0aW9uKTtpZihoZXhCeXRlcz09PVwiMHhcInx8aGV4Qnl0ZXM9PT1IYXNoWmVybyl7cmV0dXJuIG51bGx9cmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKGhleEJ5dGVzKX1jb25zdCBoZXhCeXRlcz15aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhmMWNiN2UwNlwiLGJ5dGVzMzJpZnkoY29pblR5cGUpKTtpZihoZXhCeXRlcz09bnVsbHx8aGV4Qnl0ZXM9PT1cIjB4XCIpe3JldHVybiBudWxsfWNvbnN0IGFkZHJlc3M9dGhpcy5fZ2V0QWRkcmVzcyhjb2luVHlwZSxoZXhCeXRlcyk7aWYoYWRkcmVzcz09bnVsbCl7bG9nZ2VyJHQudGhyb3dFcnJvcihgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb2luIGRhdGFgLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246YGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxjb2luVHlwZTpjb2luVHlwZSxkYXRhOmhleEJ5dGVzfSl9cmV0dXJuIGFkZHJlc3N9KX1nZXRDb250ZW50SGFzaCgpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgaGV4Qnl0ZXM9eWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4YmMxYzU4ZDFcIik7aWYoaGV4Qnl0ZXM9PW51bGx8fGhleEJ5dGVzPT09XCIweFwiKXtyZXR1cm4gbnVsbH1jb25zdCBpcGZzPWhleEJ5dGVzLm1hdGNoKC9eMHhlMzAxMDE3MCgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7aWYoaXBmcyl7Y29uc3QgbGVuZ3RoPXBhcnNlSW50KGlwZnNbM10sMTYpO2lmKGlwZnNbNF0ubGVuZ3RoPT09bGVuZ3RoKjIpe3JldHVyblwiaXBmczovL1wiK0Jhc2U1OC5lbmNvZGUoXCIweFwiK2lwZnNbMV0pfX1jb25zdCBzd2FybT1oZXhCeXRlcy5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtpZihzd2FybSl7aWYoc3dhcm1bMV0ubGVuZ3RoPT09MzIqMil7cmV0dXJuXCJieno6Ly9cIitzd2FybVsxXX19cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXRDb250ZW50SGFzaCgpXCIsZGF0YTpoZXhCeXRlc30pfSl9Z2V0VGV4dChrZXkpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7bGV0IGtleUJ5dGVzPXRvVXRmOEJ5dGVzKGtleSk7a2V5Qnl0ZXM9Y29uY2F0KFtieXRlczMyaWZ5KDY0KSxieXRlczMyaWZ5KGtleUJ5dGVzLmxlbmd0aCksa2V5Qnl0ZXNdKTtpZihrZXlCeXRlcy5sZW5ndGglMzIhPT0wKXtrZXlCeXRlcz1jb25jYXQoW2tleUJ5dGVzLGhleFplcm9QYWQoXCIweFwiLDMyLWtleS5sZW5ndGglMzIpXSl9Y29uc3QgaGV4Qnl0ZXM9eWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4NTlkMWQ0M2NcIixoZXhsaWZ5KGtleUJ5dGVzKSk7aWYoaGV4Qnl0ZXM9PW51bGx8fGhleEJ5dGVzPT09XCIweFwiKXtyZXR1cm4gbnVsbH1yZXR1cm4gdG9VdGY4U3RyaW5nKGhleEJ5dGVzKX0pfX1sZXQgZGVmYXVsdEZvcm1hdHRlcj1udWxsO2xldCBuZXh0UG9sbElkPTE7Y2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJ7Y29uc3RydWN0b3IobmV0d29yayl7bG9nZ2VyJHQuY2hlY2tOZXcobmV3LnRhcmdldCxQcm92aWRlcik7c3VwZXIoKTt0aGlzLl9ldmVudHM9W107dGhpcy5fZW1pdHRlZD17YmxvY2s6LTJ9O3RoaXMuZm9ybWF0dGVyPW5ldy50YXJnZXQuZ2V0Rm9ybWF0dGVyKCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFueU5ldHdvcmtcIixuZXR3b3JrPT09XCJhbnlcIik7aWYodGhpcy5hbnlOZXR3b3JrKXtuZXR3b3JrPXRoaXMuZGV0ZWN0TmV0d29yaygpfWlmKG5ldHdvcmsgaW5zdGFuY2VvZiBQcm9taXNlKXt0aGlzLl9uZXR3b3JrUHJvbWlzZT1uZXR3b3JrO25ldHdvcmsuY2F0Y2goZXJyb3I9Pnt9KTt0aGlzLl9yZWFkeSgpLmNhdGNoKGVycm9yPT57fSl9ZWxzZXtjb25zdCBrbm93bk5ldHdvcms9Z2V0U3RhdGljKG5ldy50YXJnZXQsXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO2lmKGtub3duTmV0d29yayl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9uZXR3b3JrXCIsa25vd25OZXR3b3JrKTt0aGlzLmVtaXQoXCJuZXR3b3JrXCIsa25vd25OZXR3b3JrLG51bGwpfWVsc2V7bG9nZ2VyJHQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrXCIsXCJuZXR3b3JrXCIsbmV0d29yayl9fXRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXI9LTEwMjQ7dGhpcy5fbGFzdEJsb2NrTnVtYmVyPS0yO3RoaXMuX3BvbGxpbmdJbnRlcnZhbD00ZTM7dGhpcy5fZmFzdFF1ZXJ5RGF0ZT0wfV9yZWFkeSgpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYodGhpcy5fbmV0d29yaz09bnVsbCl7bGV0IG5ldHdvcms9bnVsbDtpZih0aGlzLl9uZXR3b3JrUHJvbWlzZSl7dHJ5e25ldHdvcms9eWllbGQgdGhpcy5fbmV0d29ya1Byb21pc2V9Y2F0Y2goZXJyb3Ipe319aWYobmV0d29yaz09bnVsbCl7bmV0d29yaz15aWVsZCB0aGlzLmRldGVjdE5ldHdvcmsoKX1pZighbmV0d29yayl7bG9nZ2VyJHQudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIixMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1Ise30pfWlmKHRoaXMuX25ldHdvcms9PW51bGwpe2lmKHRoaXMuYW55TmV0d29yayl7dGhpcy5fbmV0d29yaz1uZXR3b3JrfWVsc2V7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9uZXR3b3JrXCIsbmV0d29yayl9dGhpcy5lbWl0KFwibmV0d29ya1wiLG5ldHdvcmssbnVsbCl9fXJldHVybiB0aGlzLl9uZXR3b3JrfSl9Z2V0IHJlYWR5KCl7cmV0dXJuIHBvbGwoKCk9PntyZXR1cm4gdGhpcy5fcmVhZHkoKS50aGVuKG5ldHdvcms9PntyZXR1cm4gbmV0d29ya30sZXJyb3I9PntpZihlcnJvci5jb2RlPT09TG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SJiZlcnJvci5ldmVudD09PVwibm9OZXR3b3JrXCIpe3JldHVybiB1bmRlZmluZWR9dGhyb3cgZXJyb3J9KX0pfXN0YXRpYyBnZXRGb3JtYXR0ZXIoKXtpZihkZWZhdWx0Rm9ybWF0dGVyPT1udWxsKXtkZWZhdWx0Rm9ybWF0dGVyPW5ldyBGb3JtYXR0ZXJ9cmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXJ9c3RhdGljIGdldE5ldHdvcmsobmV0d29yayl7cmV0dXJuIGdldE5ldHdvcmsobmV0d29yaz09bnVsbD9cImhvbWVzdGVhZFwiOm5ldHdvcmspfV9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKG1heEFnZSl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLl9yZWFkeSgpO2lmKG1heEFnZT4wKXt3aGlsZSh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyKXtjb25zdCBpbnRlcm5hbEJsb2NrTnVtYmVyPXRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI7dHJ5e2NvbnN0IHJlc3VsdD15aWVsZCBpbnRlcm5hbEJsb2NrTnVtYmVyO2lmKGdldFRpbWUoKS1yZXN1bHQucmVzcFRpbWU8PW1heEFnZSl7cmV0dXJuIHJlc3VsdC5ibG9ja051bWJlcn1icmVha31jYXRjaChlcnJvcil7aWYodGhpcy5faW50ZXJuYWxCbG9ja051bWJlcj09PWludGVybmFsQmxvY2tOdW1iZXIpe2JyZWFrfX19fWNvbnN0IHJlcVRpbWU9Z2V0VGltZSgpO2NvbnN0IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcj1yZXNvbHZlUHJvcGVydGllcyh7YmxvY2tOdW1iZXI6dGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tOdW1iZXJcIix7fSksbmV0d29ya0Vycm9yOnRoaXMuZ2V0TmV0d29yaygpLnRoZW4obmV0d29yaz0+bnVsbCxlcnJvcj0+ZXJyb3IpfSkudGhlbigoe2Jsb2NrTnVtYmVyOmJsb2NrTnVtYmVyLG5ldHdvcmtFcnJvcjpuZXR3b3JrRXJyb3J9KT0+e2lmKG5ldHdvcmtFcnJvcil7aWYodGhpcy5faW50ZXJuYWxCbG9ja051bWJlcj09PWNoZWNrSW50ZXJuYWxCbG9ja051bWJlcil7dGhpcy5faW50ZXJuYWxCbG9ja051bWJlcj1udWxsfXRocm93IG5ldHdvcmtFcnJvcn1jb25zdCByZXNwVGltZT1nZXRUaW1lKCk7YmxvY2tOdW1iZXI9QmlnTnVtYmVyLmZyb20oYmxvY2tOdW1iZXIpLnRvTnVtYmVyKCk7aWYoYmxvY2tOdW1iZXI8dGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcil7YmxvY2tOdW1iZXI9dGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcn10aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyPWJsb2NrTnVtYmVyO3RoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7cmV0dXJue2Jsb2NrTnVtYmVyOmJsb2NrTnVtYmVyLHJlcVRpbWU6cmVxVGltZSxyZXNwVGltZTpyZXNwVGltZX19KTt0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyPWNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtjaGVja0ludGVybmFsQmxvY2tOdW1iZXIuY2F0Y2goZXJyb3I9PntpZih0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyPT09Y2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKXt0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyPW51bGx9fSk7cmV0dXJuKHlpZWxkIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikuYmxvY2tOdW1iZXJ9KX1wb2xsKCl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBwb2xsSWQ9bmV4dFBvbGxJZCsrO2NvbnN0IHJ1bm5lcnM9W107bGV0IGJsb2NrTnVtYmVyPW51bGw7dHJ5e2Jsb2NrTnVtYmVyPXlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwK3RoaXMucG9sbGluZ0ludGVydmFsLzIpfWNhdGNoKGVycm9yKXt0aGlzLmVtaXQoXCJlcnJvclwiLGVycm9yKTtyZXR1cm59dGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTt0aGlzLmVtaXQoXCJwb2xsXCIscG9sbElkLGJsb2NrTnVtYmVyKTtpZihibG9ja051bWJlcj09PXRoaXMuX2xhc3RCbG9ja051bWJlcil7dGhpcy5lbWl0KFwiZGlkUG9sbFwiLHBvbGxJZCk7cmV0dXJufWlmKHRoaXMuX2VtaXR0ZWQuYmxvY2s9PT0tMil7dGhpcy5fZW1pdHRlZC5ibG9jaz1ibG9ja051bWJlci0xfWlmKE1hdGguYWJzKHRoaXMuX2VtaXR0ZWQuYmxvY2stYmxvY2tOdW1iZXIpPjFlMyl7bG9nZ2VyJHQud2FybihcIm5ldHdvcmsgYmxvY2sgc2tldyBkZXRlY3RlZDsgc2tpcHBpbmcgYmxvY2sgZXZlbnRzXCIpO3RoaXMuZW1pdChcImVycm9yXCIsbG9nZ2VyJHQubWFrZUVycm9yKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkXCIsTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLHtibG9ja051bWJlcjpibG9ja051bWJlcixldmVudDpcImJsb2NrU2tld1wiLHByZXZpb3VzQmxvY2tOdW1iZXI6dGhpcy5fZW1pdHRlZC5ibG9ja30pKTt0aGlzLmVtaXQoXCJibG9ja1wiLGJsb2NrTnVtYmVyKX1lbHNle2ZvcihsZXQgaT10aGlzLl9lbWl0dGVkLmJsb2NrKzE7aTw9YmxvY2tOdW1iZXI7aSsrKXt0aGlzLmVtaXQoXCJibG9ja1wiLGkpfX1pZih0aGlzLl9lbWl0dGVkLmJsb2NrIT09YmxvY2tOdW1iZXIpe3RoaXMuX2VtaXR0ZWQuYmxvY2s9YmxvY2tOdW1iZXI7T2JqZWN0LmtleXModGhpcy5fZW1pdHRlZCkuZm9yRWFjaChrZXk9PntpZihrZXk9PT1cImJsb2NrXCIpe3JldHVybn1jb25zdCBldmVudEJsb2NrTnVtYmVyPXRoaXMuX2VtaXR0ZWRba2V5XTtpZihldmVudEJsb2NrTnVtYmVyPT09XCJwZW5kaW5nXCIpe3JldHVybn1pZihibG9ja051bWJlci1ldmVudEJsb2NrTnVtYmVyPjEyKXtkZWxldGUgdGhpcy5fZW1pdHRlZFtrZXldfX0pfWlmKHRoaXMuX2xhc3RCbG9ja051bWJlcj09PS0yKXt0aGlzLl9sYXN0QmxvY2tOdW1iZXI9YmxvY2tOdW1iZXItMX10aGlzLl9ldmVudHMuZm9yRWFjaChldmVudD0+e3N3aXRjaChldmVudC50eXBlKXtjYXNlXCJ0eFwiOntjb25zdCBoYXNoPWV2ZW50Lmhhc2g7bGV0IHJ1bm5lcj10aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKS50aGVuKHJlY2VpcHQ9PntpZighcmVjZWlwdHx8cmVjZWlwdC5ibG9ja051bWJlcj09bnVsbCl7cmV0dXJuIG51bGx9dGhpcy5fZW1pdHRlZFtcInQ6XCIraGFzaF09cmVjZWlwdC5ibG9ja051bWJlcjt0aGlzLmVtaXQoaGFzaCxyZWNlaXB0KTtyZXR1cm4gbnVsbH0pLmNhdGNoKGVycm9yPT57dGhpcy5lbWl0KFwiZXJyb3JcIixlcnJvcil9KTtydW5uZXJzLnB1c2gocnVubmVyKTticmVha31jYXNlXCJmaWx0ZXJcIjp7Y29uc3QgZmlsdGVyPWV2ZW50LmZpbHRlcjtmaWx0ZXIuZnJvbUJsb2NrPXRoaXMuX2xhc3RCbG9ja051bWJlcisxO2ZpbHRlci50b0Jsb2NrPWJsb2NrTnVtYmVyO2NvbnN0IHJ1bm5lcj10aGlzLmdldExvZ3MoZmlsdGVyKS50aGVuKGxvZ3M9PntpZihsb2dzLmxlbmd0aD09PTApe3JldHVybn1sb2dzLmZvckVhY2gobG9nPT57dGhpcy5fZW1pdHRlZFtcImI6XCIrbG9nLmJsb2NrSGFzaF09bG9nLmJsb2NrTnVtYmVyO3RoaXMuX2VtaXR0ZWRbXCJ0OlwiK2xvZy50cmFuc2FjdGlvbkhhc2hdPWxvZy5ibG9ja051bWJlcjt0aGlzLmVtaXQoZmlsdGVyLGxvZyl9KX0pLmNhdGNoKGVycm9yPT57dGhpcy5lbWl0KFwiZXJyb3JcIixlcnJvcil9KTtydW5uZXJzLnB1c2gocnVubmVyKTticmVha319fSk7dGhpcy5fbGFzdEJsb2NrTnVtYmVyPWJsb2NrTnVtYmVyO1Byb21pc2UuYWxsKHJ1bm5lcnMpLnRoZW4oKCk9Pnt0aGlzLmVtaXQoXCJkaWRQb2xsXCIscG9sbElkKX0pLmNhdGNoKGVycm9yPT57dGhpcy5lbWl0KFwiZXJyb3JcIixlcnJvcil9KTtyZXR1cm59KX1yZXNldEV2ZW50c0Jsb2NrKGJsb2NrTnVtYmVyKXt0aGlzLl9sYXN0QmxvY2tOdW1iZXI9YmxvY2tOdW1iZXItMTtpZih0aGlzLnBvbGxpbmcpe3RoaXMucG9sbCgpfX1nZXQgbmV0d29yaygpe3JldHVybiB0aGlzLl9uZXR3b3JrfWRldGVjdE5ldHdvcmsoKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3JldHVybiBsb2dnZXIkdC50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJwcm92aWRlci5kZXRlY3ROZXR3b3JrXCJ9KX0pfWdldE5ldHdvcmsoKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IG5ldHdvcms9eWllbGQgdGhpcy5fcmVhZHkoKTtjb25zdCBjdXJyZW50TmV0d29yaz15aWVsZCB0aGlzLmRldGVjdE5ldHdvcmsoKTtpZihuZXR3b3JrLmNoYWluSWQhPT1jdXJyZW50TmV0d29yay5jaGFpbklkKXtpZih0aGlzLmFueU5ldHdvcmspe3RoaXMuX25ldHdvcms9Y3VycmVudE5ldHdvcms7dGhpcy5fbGFzdEJsb2NrTnVtYmVyPS0yO3RoaXMuX2Zhc3RCbG9ja051bWJlcj1udWxsO3RoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2U9bnVsbDt0aGlzLl9mYXN0UXVlcnlEYXRlPTA7dGhpcy5fZW1pdHRlZC5ibG9jaz0tMjt0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyPS0xMDI0O3RoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI9bnVsbDt0aGlzLmVtaXQoXCJuZXR3b3JrXCIsY3VycmVudE5ldHdvcmssbmV0d29yayk7eWllbGQgc3RhbGwoMCk7cmV0dXJuIHRoaXMuX25ldHdvcmt9Y29uc3QgZXJyb3I9bG9nZ2VyJHQubWFrZUVycm9yKFwidW5kZXJseWluZyBuZXR3b3JrIGNoYW5nZWRcIixMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1Ise2V2ZW50OlwiY2hhbmdlZFwiLG5ldHdvcms6bmV0d29yayxkZXRlY3RlZE5ldHdvcms6Y3VycmVudE5ldHdvcmt9KTt0aGlzLmVtaXQoXCJlcnJvclwiLGVycm9yKTt0aHJvdyBlcnJvcn1yZXR1cm4gbmV0d29ya30pfWdldCBibG9ja051bWJlcigpe3RoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwK3RoaXMucG9sbGluZ0ludGVydmFsLzIpLnRoZW4oYmxvY2tOdW1iZXI9Pnt0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpfSxlcnJvcj0+e30pO3JldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIhPW51bGw/dGhpcy5fZmFzdEJsb2NrTnVtYmVyOi0xfWdldCBwb2xsaW5nKCl7cmV0dXJuIHRoaXMuX3BvbGxlciE9bnVsbH1zZXQgcG9sbGluZyh2YWx1ZSl7aWYodmFsdWUmJiF0aGlzLl9wb2xsZXIpe3RoaXMuX3BvbGxlcj1zZXRJbnRlcnZhbCgoKT0+e3RoaXMucG9sbCgpfSx0aGlzLnBvbGxpbmdJbnRlcnZhbCk7aWYoIXRoaXMuX2Jvb3RzdHJhcFBvbGwpe3RoaXMuX2Jvb3RzdHJhcFBvbGw9c2V0VGltZW91dCgoKT0+e3RoaXMucG9sbCgpO3RoaXMuX2Jvb3RzdHJhcFBvbGw9c2V0VGltZW91dCgoKT0+e2lmKCF0aGlzLl9wb2xsZXIpe3RoaXMucG9sbCgpfXRoaXMuX2Jvb3RzdHJhcFBvbGw9bnVsbH0sdGhpcy5wb2xsaW5nSW50ZXJ2YWwpfSwwKX19ZWxzZSBpZighdmFsdWUmJnRoaXMuX3BvbGxlcil7Y2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO3RoaXMuX3BvbGxlcj1udWxsfX1nZXQgcG9sbGluZ0ludGVydmFsKCl7cmV0dXJuIHRoaXMuX3BvbGxpbmdJbnRlcnZhbH1zZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKXtpZih0eXBlb2YgdmFsdWUhPT1cIm51bWJlclwifHx2YWx1ZTw9MHx8cGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkhPXZhbHVlKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvbGxpbmcgaW50ZXJ2YWxcIil9dGhpcy5fcG9sbGluZ0ludGVydmFsPXZhbHVlO2lmKHRoaXMuX3BvbGxlcil7Y2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO3RoaXMuX3BvbGxlcj1zZXRJbnRlcnZhbCgoKT0+e3RoaXMucG9sbCgpfSx0aGlzLl9wb2xsaW5nSW50ZXJ2YWwpfX1fZ2V0RmFzdEJsb2NrTnVtYmVyKCl7Y29uc3Qgbm93PWdldFRpbWUoKTtpZihub3ctdGhpcy5fZmFzdFF1ZXJ5RGF0ZT4yKnRoaXMuX3BvbGxpbmdJbnRlcnZhbCl7dGhpcy5fZmFzdFF1ZXJ5RGF0ZT1ub3c7dGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZT10aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbihibG9ja051bWJlcj0+e2lmKHRoaXMuX2Zhc3RCbG9ja051bWJlcj09bnVsbHx8YmxvY2tOdW1iZXI+dGhpcy5fZmFzdEJsb2NrTnVtYmVyKXt0aGlzLl9mYXN0QmxvY2tOdW1iZXI9YmxvY2tOdW1iZXJ9cmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlcn0pfXJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlfV9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpe2lmKHRoaXMuX2Zhc3RCbG9ja051bWJlciE9bnVsbCYmYmxvY2tOdW1iZXI8dGhpcy5fZmFzdEJsb2NrTnVtYmVyKXtyZXR1cm59dGhpcy5fZmFzdFF1ZXJ5RGF0ZT1nZXRUaW1lKCk7aWYodGhpcy5fZmFzdEJsb2NrTnVtYmVyPT1udWxsfHxibG9ja051bWJlcj50aGlzLl9mYXN0QmxvY2tOdW1iZXIpe3RoaXMuX2Zhc3RCbG9ja051bWJlcj1ibG9ja051bWJlcjt0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlPVByb21pc2UucmVzb2x2ZShibG9ja051bWJlcil9fXdhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsY29uZmlybWF0aW9ucyx0aW1lb3V0KXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2lmKGNvbmZpcm1hdGlvbnM9PW51bGwpe2NvbmZpcm1hdGlvbnM9MX1jb25zdCByZWNlaXB0PXlpZWxkIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCk7aWYoKHJlY2VpcHQ/cmVjZWlwdC5jb25maXJtYXRpb25zOjApPj1jb25maXJtYXRpb25zKXtyZXR1cm4gcmVjZWlwdH1yZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e2xldCB0aW1lcj1udWxsO2xldCBkb25lPWZhbHNlO2NvbnN0IGhhbmRsZXI9cmVjZWlwdD0+e2lmKHJlY2VpcHQuY29uZmlybWF0aW9uczxjb25maXJtYXRpb25zKXtyZXR1cm59aWYodGltZXIpe2NsZWFyVGltZW91dCh0aW1lcil9aWYoZG9uZSl7cmV0dXJufWRvbmU9dHJ1ZTt0aGlzLnJlbW92ZUxpc3RlbmVyKHRyYW5zYWN0aW9uSGFzaCxoYW5kbGVyKTtyZXNvbHZlKHJlY2VpcHQpfTt0aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCxoYW5kbGVyKTtpZih0eXBlb2YgdGltZW91dD09PVwibnVtYmVyXCImJnRpbWVvdXQ+MCl7dGltZXI9c2V0VGltZW91dCgoKT0+e2lmKGRvbmUpe3JldHVybn10aW1lcj1udWxsO2RvbmU9dHJ1ZTt0aGlzLnJlbW92ZUxpc3RlbmVyKHRyYW5zYWN0aW9uSGFzaCxoYW5kbGVyKTtyZWplY3QobG9nZ2VyJHQubWFrZUVycm9yKFwidGltZW91dCBleGNlZWRlZFwiLExvZ2dlci5lcnJvcnMuVElNRU9VVCx7dGltZW91dDp0aW1lb3V0fSkpfSx0aW1lb3V0KTtpZih0aW1lci51bnJlZil7dGltZXIudW5yZWYoKX19fSl9KX1nZXRCbG9ja051bWJlcigpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7cmV0dXJuIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMCl9KX1nZXRHYXNQcmljZSgpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgcmVzdWx0PXlpZWxkIHRoaXMucGVyZm9ybShcImdldEdhc1ByaWNlXCIse30pO3RyeXtyZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KX1jYXRjaChlcnJvcil7cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHttZXRob2Q6XCJnZXRHYXNQcmljZVwiLHJlc3VsdDpyZXN1bHQsZXJyb3I6ZXJyb3J9KX19KX1nZXRCYWxhbmNlKGFkZHJlc3NPck5hbWUsYmxvY2tUYWcpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgcGFyYW1zPXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzOnRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksYmxvY2tUYWc6dGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpfSk7Y29uc3QgcmVzdWx0PXlpZWxkIHRoaXMucGVyZm9ybShcImdldEJhbGFuY2VcIixwYXJhbXMpO3RyeXtyZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KX1jYXRjaChlcnJvcil7cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHttZXRob2Q6XCJnZXRCYWxhbmNlXCIscGFyYW1zOnBhcmFtcyxyZXN1bHQ6cmVzdWx0LGVycm9yOmVycm9yfSl9fSl9Z2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzT3JOYW1lLGJsb2NrVGFnKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO2NvbnN0IHBhcmFtcz15aWVsZCByZXNvbHZlUHJvcGVydGllcyh7YWRkcmVzczp0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLGJsb2NrVGFnOnRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKX0pO2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIscGFyYW1zKTt0cnl7cmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkudG9OdW1iZXIoKX1jYXRjaChlcnJvcil7cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHttZXRob2Q6XCJnZXRUcmFuc2FjdGlvbkNvdW50XCIscGFyYW1zOnBhcmFtcyxyZXN1bHQ6cmVzdWx0LGVycm9yOmVycm9yfSl9fSl9Z2V0Q29kZShhZGRyZXNzT3JOYW1lLGJsb2NrVGFnKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO2NvbnN0IHBhcmFtcz15aWVsZCByZXNvbHZlUHJvcGVydGllcyh7YWRkcmVzczp0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLGJsb2NrVGFnOnRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKX0pO2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRDb2RlXCIscGFyYW1zKTt0cnl7cmV0dXJuIGhleGxpZnkocmVzdWx0KX1jYXRjaChlcnJvcil7cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHttZXRob2Q6XCJnZXRDb2RlXCIscGFyYW1zOnBhcmFtcyxyZXN1bHQ6cmVzdWx0LGVycm9yOmVycm9yfSl9fSl9Z2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUscG9zaXRpb24sYmxvY2tUYWcpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgcGFyYW1zPXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzOnRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksYmxvY2tUYWc6dGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLHBvc2l0aW9uOlByb21pc2UucmVzb2x2ZShwb3NpdGlvbikudGhlbihwPT5oZXhWYWx1ZShwKSl9KTtjb25zdCByZXN1bHQ9eWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0U3RvcmFnZUF0XCIscGFyYW1zKTt0cnl7cmV0dXJuIGhleGxpZnkocmVzdWx0KX1jYXRjaChlcnJvcil7cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHttZXRob2Q6XCJnZXRTdG9yYWdlQXRcIixwYXJhbXM6cGFyYW1zLHJlc3VsdDpyZXN1bHQsZXJyb3I6ZXJyb3J9KX19KX1fd3JhcFRyYW5zYWN0aW9uKHR4LGhhc2gpe2lmKGhhc2ghPW51bGwmJmhleERhdGFMZW5ndGgoaGFzaCkhPT0zMil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZSAtIHNlbmRUcmFuc2FjdGlvblwiKX1jb25zdCByZXN1bHQ9dHg7aWYoaGFzaCE9bnVsbCYmdHguaGFzaCE9PWhhc2gpe2xvZ2dlciR0LnRocm93RXJyb3IoXCJUcmFuc2FjdGlvbiBoYXNoIG1pc21hdGNoIGZyb20gUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uLlwiLExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUix7ZXhwZWN0ZWRIYXNoOnR4Lmhhc2gscmV0dXJuZWRIYXNoOmhhc2h9KX1yZXN1bHQud2FpdD0oY29uZmlybWF0aW9ucz0+X19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2lmKGNvbmZpcm1hdGlvbnMhPT0wKXt0aGlzLl9lbWl0dGVkW1widDpcIit0eC5oYXNoXT1cInBlbmRpbmdcIn1jb25zdCByZWNlaXB0PXlpZWxkIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsY29uZmlybWF0aW9ucyk7aWYocmVjZWlwdD09bnVsbCYmY29uZmlybWF0aW9ucz09PTApe3JldHVybiBudWxsfXRoaXMuX2VtaXR0ZWRbXCJ0OlwiK3R4Lmhhc2hdPXJlY2VpcHQuYmxvY2tOdW1iZXI7aWYocmVjZWlwdC5zdGF0dXM9PT0wKXtsb2dnZXIkdC50aHJvd0Vycm9yKFwidHJhbnNhY3Rpb24gZmFpbGVkXCIsTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTix7dHJhbnNhY3Rpb25IYXNoOnR4Lmhhc2gsdHJhbnNhY3Rpb246dHgscmVjZWlwdDpyZWNlaXB0fSl9cmV0dXJuIHJlY2VpcHR9KSk7cmV0dXJuIHJlc3VsdH1zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgaGV4VHg9eWllbGQgUHJvbWlzZS5yZXNvbHZlKHNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKHQ9PmhleGxpZnkodCkpO2NvbnN0IHR4PXRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTt0cnl7Y29uc3QgaGFzaD15aWVsZCB0aGlzLnBlcmZvcm0oXCJzZW5kVHJhbnNhY3Rpb25cIix7c2lnbmVkVHJhbnNhY3Rpb246aGV4VHh9KTtyZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LGhhc2gpfWNhdGNoKGVycm9yKXtlcnJvci50cmFuc2FjdGlvbj10eDtlcnJvci50cmFuc2FjdGlvbkhhc2g9dHguaGFzaDt0aHJvdyBlcnJvcn19KX1fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHZhbHVlcz15aWVsZCB0cmFuc2FjdGlvbjtjb25zdCB0eD17fTtbXCJmcm9tXCIsXCJ0b1wiXS5mb3JFYWNoKGtleT0+e2lmKHZhbHVlc1trZXldPT1udWxsKXtyZXR1cm59dHhba2V5XT1Qcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4odj0+dj90aGlzLl9nZXRBZGRyZXNzKHYpOm51bGwpfSk7W1wiZ2FzTGltaXRcIixcImdhc1ByaWNlXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGtleT0+e2lmKHZhbHVlc1trZXldPT1udWxsKXtyZXR1cm59dHhba2V5XT1Qcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4odj0+dj9CaWdOdW1iZXIuZnJvbSh2KTpudWxsKX0pO1tcInR5cGVcIl0uZm9yRWFjaChrZXk9PntpZih2YWx1ZXNba2V5XT09bnVsbCl7cmV0dXJufXR4W2tleV09UHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKHY9PnYhPW51bGw/djpudWxsKX0pO2lmKHZhbHVlcy5hY2Nlc3NMaXN0KXt0eC5hY2Nlc3NMaXN0PXRoaXMuZm9ybWF0dGVyLmFjY2Vzc0xpc3QodmFsdWVzLmFjY2Vzc0xpc3QpfVtcImRhdGFcIl0uZm9yRWFjaChrZXk9PntpZih2YWx1ZXNba2V5XT09bnVsbCl7cmV0dXJufXR4W2tleV09UHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKHY9PnY/aGV4bGlmeSh2KTpudWxsKX0pO3JldHVybiB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlcXVlc3QoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpKX0pfV9nZXRGaWx0ZXIoZmlsdGVyKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2ZpbHRlcj15aWVsZCBmaWx0ZXI7Y29uc3QgcmVzdWx0PXt9O2lmKGZpbHRlci5hZGRyZXNzIT1udWxsKXtyZXN1bHQuYWRkcmVzcz10aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKX1bXCJibG9ja0hhc2hcIixcInRvcGljc1wiXS5mb3JFYWNoKGtleT0+e2lmKGZpbHRlcltrZXldPT1udWxsKXtyZXR1cm59cmVzdWx0W2tleV09ZmlsdGVyW2tleV19KTtbXCJmcm9tQmxvY2tcIixcInRvQmxvY2tcIl0uZm9yRWFjaChrZXk9PntpZihmaWx0ZXJba2V5XT09bnVsbCl7cmV0dXJufXJlc3VsdFtrZXldPXRoaXMuX2dldEJsb2NrVGFnKGZpbHRlcltrZXldKX0pO3JldHVybiB0aGlzLmZvcm1hdHRlci5maWx0ZXIoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXMocmVzdWx0KSl9KX1jYWxsKHRyYW5zYWN0aW9uLGJsb2NrVGFnKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO2NvbnN0IHBhcmFtcz15aWVsZCByZXNvbHZlUHJvcGVydGllcyh7dHJhbnNhY3Rpb246dGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSxibG9ja1RhZzp0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyl9KTtjb25zdCByZXN1bHQ9eWllbGQgdGhpcy5wZXJmb3JtKFwiY2FsbFwiLHBhcmFtcyk7dHJ5e3JldHVybiBoZXhsaWZ5KHJlc3VsdCl9Y2F0Y2goZXJyb3Ipe3JldHVybiBsb2dnZXIkdC50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIixMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUix7bWV0aG9kOlwiY2FsbFwiLHBhcmFtczpwYXJhbXMscmVzdWx0OnJlc3VsdCxlcnJvcjplcnJvcn0pfX0pfWVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO2NvbnN0IHBhcmFtcz15aWVsZCByZXNvbHZlUHJvcGVydGllcyh7dHJhbnNhY3Rpb246dGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKX0pO2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnBlcmZvcm0oXCJlc3RpbWF0ZUdhc1wiLHBhcmFtcyk7dHJ5e3JldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpfWNhdGNoKGVycm9yKXtyZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise21ldGhvZDpcImVzdGltYXRlR2FzXCIscGFyYW1zOnBhcmFtcyxyZXN1bHQ6cmVzdWx0LGVycm9yOmVycm9yfSl9fSl9X2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBhZGRyZXNzPXlpZWxkIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSk7aWYoYWRkcmVzcz09bnVsbCl7bG9nZ2VyJHQudGhyb3dFcnJvcihcIkVOUyBuYW1lIG5vdCBjb25maWd1cmVkXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpgcmVzb2x2ZU5hbWUoJHtKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKX0pYH0pfXJldHVybiBhZGRyZXNzfSl9X2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsaW5jbHVkZVRyYW5zYWN0aW9ucyl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtibG9ja0hhc2hPckJsb2NrVGFnPXlpZWxkIGJsb2NrSGFzaE9yQmxvY2tUYWc7bGV0IGJsb2NrTnVtYmVyPS0xMjg7Y29uc3QgcGFyYW1zPXtpbmNsdWRlVHJhbnNhY3Rpb25zOiEhaW5jbHVkZVRyYW5zYWN0aW9uc307aWYoaXNIZXhTdHJpbmcoYmxvY2tIYXNoT3JCbG9ja1RhZywzMikpe3BhcmFtcy5ibG9ja0hhc2g9YmxvY2tIYXNoT3JCbG9ja1RhZ31lbHNle3RyeXtwYXJhbXMuYmxvY2tUYWc9dGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoeWllbGQgdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tIYXNoT3JCbG9ja1RhZykpO2lmKGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpe2Jsb2NrTnVtYmVyPXBhcnNlSW50KHBhcmFtcy5ibG9ja1RhZy5zdWJzdHJpbmcoMiksMTYpfX1jYXRjaChlcnJvcil7bG9nZ2VyJHQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9jayBoYXNoIG9yIGJsb2NrIHRhZ1wiLFwiYmxvY2tIYXNoT3JCbG9ja1RhZ1wiLGJsb2NrSGFzaE9yQmxvY2tUYWcpfX1yZXR1cm4gcG9sbCgoKT0+X19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IGJsb2NrPXlpZWxkIHRoaXMucGVyZm9ybShcImdldEJsb2NrXCIscGFyYW1zKTtpZihibG9jaz09bnVsbCl7aWYocGFyYW1zLmJsb2NrSGFzaCE9bnVsbCl7aWYodGhpcy5fZW1pdHRlZFtcImI6XCIrcGFyYW1zLmJsb2NrSGFzaF09PW51bGwpe3JldHVybiBudWxsfX1pZihwYXJhbXMuYmxvY2tUYWchPW51bGwpe2lmKGJsb2NrTnVtYmVyPnRoaXMuX2VtaXR0ZWQuYmxvY2spe3JldHVybiBudWxsfX1yZXR1cm4gdW5kZWZpbmVkfWlmKGluY2x1ZGVUcmFuc2FjdGlvbnMpe2xldCBibG9ja051bWJlcj1udWxsO2ZvcihsZXQgaT0wO2k8YmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aDtpKyspe2NvbnN0IHR4PWJsb2NrLnRyYW5zYWN0aW9uc1tpXTtpZih0eC5ibG9ja051bWJlcj09bnVsbCl7dHguY29uZmlybWF0aW9ucz0wfWVsc2UgaWYodHguY29uZmlybWF0aW9ucz09bnVsbCl7aWYoYmxvY2tOdW1iZXI9PW51bGwpe2Jsb2NrTnVtYmVyPXlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwKzIqdGhpcy5wb2xsaW5nSW50ZXJ2YWwpfWxldCBjb25maXJtYXRpb25zPWJsb2NrTnVtYmVyLXR4LmJsb2NrTnVtYmVyKzE7aWYoY29uZmlybWF0aW9uczw9MCl7Y29uZmlybWF0aW9ucz0xfXR4LmNvbmZpcm1hdGlvbnM9Y29uZmlybWF0aW9uc319cmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9jayl9cmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrKGJsb2NrKX0pLHtvbmNlUG9sbDp0aGlzfSl9KX1nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnKXtyZXR1cm4gdGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZyxmYWxzZSl9Z2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrSGFzaE9yQmxvY2tUYWcpe3JldHVybiB0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLHRydWUpfWdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTt0cmFuc2FjdGlvbkhhc2g9eWllbGQgdHJhbnNhY3Rpb25IYXNoO2NvbnN0IHBhcmFtcz17dHJhbnNhY3Rpb25IYXNoOnRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLHRydWUpfTtyZXR1cm4gcG9sbCgoKT0+X19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLHBhcmFtcyk7aWYocmVzdWx0PT1udWxsKXtpZih0aGlzLl9lbWl0dGVkW1widDpcIit0cmFuc2FjdGlvbkhhc2hdPT1udWxsKXtyZXR1cm4gbnVsbH1yZXR1cm4gdW5kZWZpbmVkfWNvbnN0IHR4PXRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UocmVzdWx0KTtpZih0eC5ibG9ja051bWJlcj09bnVsbCl7dHguY29uZmlybWF0aW9ucz0wfWVsc2UgaWYodHguY29uZmlybWF0aW9ucz09bnVsbCl7Y29uc3QgYmxvY2tOdW1iZXI9eWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDArMip0aGlzLnBvbGxpbmdJbnRlcnZhbCk7bGV0IGNvbmZpcm1hdGlvbnM9YmxvY2tOdW1iZXItdHguYmxvY2tOdW1iZXIrMTtpZihjb25maXJtYXRpb25zPD0wKXtjb25maXJtYXRpb25zPTF9dHguY29uZmlybWF0aW9ucz1jb25maXJtYXRpb25zfXJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpfSkse29uY2VQb2xsOnRoaXN9KX0pfWdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7dHJhbnNhY3Rpb25IYXNoPXlpZWxkIHRyYW5zYWN0aW9uSGFzaDtjb25zdCBwYXJhbXM9e3RyYW5zYWN0aW9uSGFzaDp0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCx0cnVlKX07cmV0dXJuIHBvbGwoKCk9Pl9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCByZXN1bHQ9eWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIscGFyYW1zKTtpZihyZXN1bHQ9PW51bGwpe2lmKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiK3RyYW5zYWN0aW9uSGFzaF09PW51bGwpe3JldHVybiBudWxsfXJldHVybiB1bmRlZmluZWR9aWYocmVzdWx0LmJsb2NrSGFzaD09bnVsbCl7cmV0dXJuIHVuZGVmaW5lZH1jb25zdCByZWNlaXB0PXRoaXMuZm9ybWF0dGVyLnJlY2VpcHQocmVzdWx0KTtpZihyZWNlaXB0LmJsb2NrTnVtYmVyPT1udWxsKXtyZWNlaXB0LmNvbmZpcm1hdGlvbnM9MH1lbHNlIGlmKHJlY2VpcHQuY29uZmlybWF0aW9ucz09bnVsbCl7Y29uc3QgYmxvY2tOdW1iZXI9eWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDArMip0aGlzLnBvbGxpbmdJbnRlcnZhbCk7bGV0IGNvbmZpcm1hdGlvbnM9YmxvY2tOdW1iZXItcmVjZWlwdC5ibG9ja051bWJlcisxO2lmKGNvbmZpcm1hdGlvbnM8PTApe2NvbmZpcm1hdGlvbnM9MX1yZWNlaXB0LmNvbmZpcm1hdGlvbnM9Y29uZmlybWF0aW9uc31yZXR1cm4gcmVjZWlwdH0pLHtvbmNlUG9sbDp0aGlzfSl9KX1nZXRMb2dzKGZpbHRlcil7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtjb25zdCBwYXJhbXM9eWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe2ZpbHRlcjp0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKX0pO2NvbnN0IGxvZ3M9eWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0TG9nc1wiLHBhcmFtcyk7bG9ncy5mb3JFYWNoKGxvZz0+e2lmKGxvZy5yZW1vdmVkPT1udWxsKXtsb2cucmVtb3ZlZD1mYWxzZX19KTtyZXR1cm4gRm9ybWF0dGVyLmFycmF5T2YodGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nLmJpbmQodGhpcy5mb3JtYXR0ZXIpKShsb2dzKX0pfWdldEV0aGVyUHJpY2UoKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO3JldHVybiB0aGlzLnBlcmZvcm0oXCJnZXRFdGhlclByaWNlXCIse30pfSl9X2dldEJsb2NrVGFnKGJsb2NrVGFnKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2Jsb2NrVGFnPXlpZWxkIGJsb2NrVGFnO2lmKHR5cGVvZiBibG9ja1RhZz09PVwibnVtYmVyXCImJmJsb2NrVGFnPDApe2lmKGJsb2NrVGFnJTEpe2xvZ2dlciR0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmxvY2tUYWdcIixcImJsb2NrVGFnXCIsYmxvY2tUYWcpfWxldCBibG9ja051bWJlcj15aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCsyKnRoaXMucG9sbGluZ0ludGVydmFsKTtibG9ja051bWJlcis9YmxvY2tUYWc7aWYoYmxvY2tOdW1iZXI8MCl7YmxvY2tOdW1iZXI9MH1yZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tOdW1iZXIpfXJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyl9KX1nZXRSZXNvbHZlcihuYW1lKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IGFkZHJlc3M9eWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIobmFtZSk7aWYoYWRkcmVzcz09bnVsbCl7cmV0dXJuIG51bGx9cmV0dXJuIG5ldyBSZXNvbHZlcih0aGlzLGFkZHJlc3MsbmFtZSl9KX1fZ2V0UmVzb2x2ZXIobmFtZSl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBuZXR3b3JrPXlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO2lmKCFuZXR3b3JrLmVuc0FkZHJlc3Mpe2xvZ2dlciR0LnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIkVOU1wiLG5ldHdvcms6bmV0d29yay5uYW1lfSl9Y29uc3QgdHJhbnNhY3Rpb249e3RvOm5ldHdvcmsuZW5zQWRkcmVzcyxkYXRhOlwiMHgwMTc4YjhiZlwiK25hbWVoYXNoKG5hbWUpLnN1YnN0cmluZygyKX07cmV0dXJuIHRoaXMuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKHlpZWxkIHRoaXMuY2FsbCh0cmFuc2FjdGlvbikpfSl9cmVzb2x2ZU5hbWUobmFtZSl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtuYW1lPXlpZWxkIG5hbWU7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSl9Y2F0Y2goZXJyb3Ipe2lmKGlzSGV4U3RyaW5nKG5hbWUpKXt0aHJvdyBlcnJvcn19aWYodHlwZW9mIG5hbWUhPT1cInN0cmluZ1wiKXtsb2dnZXIkdC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lXCIsXCJuYW1lXCIsbmFtZSl9Y29uc3QgcmVzb2x2ZXI9eWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtpZighcmVzb2x2ZXIpe3JldHVybiBudWxsfXJldHVybiB5aWVsZCByZXNvbHZlci5nZXRBZGRyZXNzKCl9KX1sb29rdXBBZGRyZXNzKGFkZHJlc3Mpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7YWRkcmVzcz15aWVsZCBhZGRyZXNzO2FkZHJlc3M9dGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKTtjb25zdCByZXZlcnNlTmFtZT1hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpK1wiLmFkZHIucmV2ZXJzZVwiO2NvbnN0IHJlc29sdmVyQWRkcmVzcz15aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihyZXZlcnNlTmFtZSk7aWYoIXJlc29sdmVyQWRkcmVzcyl7cmV0dXJuIG51bGx9bGV0IGJ5dGVzPWFycmF5aWZ5KHlpZWxkIHRoaXMuY2FsbCh7dG86cmVzb2x2ZXJBZGRyZXNzLGRhdGE6XCIweDY5MWYzNDMxXCIrbmFtZWhhc2gocmV2ZXJzZU5hbWUpLnN1YnN0cmluZygyKX0pKTtpZihieXRlcy5sZW5ndGg8MzJ8fCFCaWdOdW1iZXIuZnJvbShieXRlcy5zbGljZSgwLDMyKSkuZXEoMzIpKXtyZXR1cm4gbnVsbH1ieXRlcz1ieXRlcy5zbGljZSgzMik7aWYoYnl0ZXMubGVuZ3RoPDMyKXtyZXR1cm4gbnVsbH1jb25zdCBsZW5ndGg9QmlnTnVtYmVyLmZyb20oYnl0ZXMuc2xpY2UoMCwzMikpLnRvTnVtYmVyKCk7Ynl0ZXM9Ynl0ZXMuc2xpY2UoMzIpO2lmKGxlbmd0aD5ieXRlcy5sZW5ndGgpe3JldHVybiBudWxsfWNvbnN0IG5hbWU9dG9VdGY4U3RyaW5nKGJ5dGVzLnNsaWNlKDAsbGVuZ3RoKSk7Y29uc3QgYWRkcj15aWVsZCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO2lmKGFkZHIhPWFkZHJlc3Mpe3JldHVybiBudWxsfXJldHVybiBuYW1lfSl9cGVyZm9ybShtZXRob2QscGFyYW1zKXtyZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihtZXRob2QrXCIgbm90IGltcGxlbWVudGVkXCIsTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQse29wZXJhdGlvbjptZXRob2R9KX1fc3RhcnRFdmVudChldmVudCl7dGhpcy5wb2xsaW5nPXRoaXMuX2V2ZW50cy5maWx0ZXIoZT0+ZS5wb2xsYWJsZSgpKS5sZW5ndGg+MH1fc3RvcEV2ZW50KGV2ZW50KXt0aGlzLnBvbGxpbmc9dGhpcy5fZXZlbnRzLmZpbHRlcihlPT5lLnBvbGxhYmxlKCkpLmxlbmd0aD4wfV9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSxsaXN0ZW5lcixvbmNlKXtjb25zdCBldmVudD1uZXcgRXZlbnQoZ2V0RXZlbnRUYWckMShldmVudE5hbWUpLGxpc3RlbmVyLG9uY2UpO3RoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTt0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtyZXR1cm4gdGhpc31vbihldmVudE5hbWUsbGlzdGVuZXIpe3JldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSxsaXN0ZW5lcixmYWxzZSl9b25jZShldmVudE5hbWUsbGlzdGVuZXIpe3JldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSxsaXN0ZW5lcix0cnVlKX1lbWl0KGV2ZW50TmFtZSwuLi5hcmdzKXtsZXQgcmVzdWx0PWZhbHNlO2xldCBzdG9wcGVkPVtdO2xldCBldmVudFRhZz1nZXRFdmVudFRhZyQxKGV2ZW50TmFtZSk7dGhpcy5fZXZlbnRzPXRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQ9PntpZihldmVudC50YWchPT1ldmVudFRhZyl7cmV0dXJuIHRydWV9c2V0VGltZW91dCgoKT0+e2V2ZW50Lmxpc3RlbmVyLmFwcGx5KHRoaXMsYXJncyl9LDApO3Jlc3VsdD10cnVlO2lmKGV2ZW50Lm9uY2Upe3N0b3BwZWQucHVzaChldmVudCk7cmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfSk7c3RvcHBlZC5mb3JFYWNoKGV2ZW50PT57dGhpcy5fc3RvcEV2ZW50KGV2ZW50KX0pO3JldHVybiByZXN1bHR9bGlzdGVuZXJDb3VudChldmVudE5hbWUpe2lmKCFldmVudE5hbWUpe3JldHVybiB0aGlzLl9ldmVudHMubGVuZ3RofWxldCBldmVudFRhZz1nZXRFdmVudFRhZyQxKGV2ZW50TmFtZSk7cmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQ9PntyZXR1cm4gZXZlbnQudGFnPT09ZXZlbnRUYWd9KS5sZW5ndGh9bGlzdGVuZXJzKGV2ZW50TmFtZSl7aWYoZXZlbnROYW1lPT1udWxsKXtyZXR1cm4gdGhpcy5fZXZlbnRzLm1hcChldmVudD0+ZXZlbnQubGlzdGVuZXIpfWxldCBldmVudFRhZz1nZXRFdmVudFRhZyQxKGV2ZW50TmFtZSk7cmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQ9PmV2ZW50LnRhZz09PWV2ZW50VGFnKS5tYXAoZXZlbnQ9PmV2ZW50Lmxpc3RlbmVyKX1vZmYoZXZlbnROYW1lLGxpc3RlbmVyKXtpZihsaXN0ZW5lcj09bnVsbCl7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSl9Y29uc3Qgc3RvcHBlZD1bXTtsZXQgZm91bmQ9ZmFsc2U7bGV0IGV2ZW50VGFnPWdldEV2ZW50VGFnJDEoZXZlbnROYW1lKTt0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzLmZpbHRlcihldmVudD0+e2lmKGV2ZW50LnRhZyE9PWV2ZW50VGFnfHxldmVudC5saXN0ZW5lciE9bGlzdGVuZXIpe3JldHVybiB0cnVlfWlmKGZvdW5kKXtyZXR1cm4gdHJ1ZX1mb3VuZD10cnVlO3N0b3BwZWQucHVzaChldmVudCk7cmV0dXJuIGZhbHNlfSk7c3RvcHBlZC5mb3JFYWNoKGV2ZW50PT57dGhpcy5fc3RvcEV2ZW50KGV2ZW50KX0pO3JldHVybiB0aGlzfXJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpe2xldCBzdG9wcGVkPVtdO2lmKGV2ZW50TmFtZT09bnVsbCl7c3RvcHBlZD10aGlzLl9ldmVudHM7dGhpcy5fZXZlbnRzPVtdfWVsc2V7Y29uc3QgZXZlbnRUYWc9Z2V0RXZlbnRUYWckMShldmVudE5hbWUpO3RoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50PT57aWYoZXZlbnQudGFnIT09ZXZlbnRUYWcpe3JldHVybiB0cnVlfXN0b3BwZWQucHVzaChldmVudCk7cmV0dXJuIGZhbHNlfSl9c3RvcHBlZC5mb3JFYWNoKGV2ZW50PT57dGhpcy5fc3RvcEV2ZW50KGV2ZW50KX0pO3JldHVybiB0aGlzfX1cInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyJDk9d2luZG93JiZ3aW5kb3cuX19hd2FpdGVyfHxmdW5jdGlvbih0aGlzQXJnLF9hcmd1bWVudHMsUCxnZW5lcmF0b3Ipe2Z1bmN0aW9uIGFkb3B0KHZhbHVlKXtyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQP3ZhbHVlOm5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpe3Jlc29sdmUodmFsdWUpfSl9cmV0dXJuIG5ldyhQfHwoUD1Qcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2Z1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gc3RlcChyZXN1bHQpe3Jlc3VsdC5kb25lP3Jlc29sdmUocmVzdWx0LnZhbHVlKTphZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChnZW5lcmF0b3I9Z2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsX2FyZ3VtZW50c3x8W10pKS5uZXh0KCkpfSl9O2NvbnN0IGxvZ2dlciR1PW5ldyBMb2dnZXIodmVyc2lvbiRtKTtjb25zdCBlcnJvckdhcz1bXCJjYWxsXCIsXCJlc3RpbWF0ZUdhc1wiXTtmdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCxlcnJvcixwYXJhbXMpe2lmKG1ldGhvZD09PVwiY2FsbFwiJiZlcnJvci5jb2RlPT09TG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ipe2NvbnN0IGU9ZXJyb3IuZXJyb3I7aWYoZSYmZS5tZXNzYWdlLm1hdGNoKFwicmV2ZXJ0ZWRcIikmJmlzSGV4U3RyaW5nKGUuZGF0YSkpe3JldHVybiBlLmRhdGF9fWxldCBtZXNzYWdlPWVycm9yLm1lc3NhZ2U7aWYoZXJyb3IuY29kZT09PUxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SJiZlcnJvci5lcnJvciYmdHlwZW9mIGVycm9yLmVycm9yLm1lc3NhZ2U9PT1cInN0cmluZ1wiKXttZXNzYWdlPWVycm9yLmVycm9yLm1lc3NhZ2V9ZWxzZSBpZih0eXBlb2YgZXJyb3IuYm9keT09PVwic3RyaW5nXCIpe21lc3NhZ2U9ZXJyb3IuYm9keX1lbHNlIGlmKHR5cGVvZiBlcnJvci5yZXNwb25zZVRleHQ9PT1cInN0cmluZ1wiKXttZXNzYWdlPWVycm9yLnJlc3BvbnNlVGV4dH1tZXNzYWdlPShtZXNzYWdlfHxcIlwiKS50b0xvd2VyQ2FzZSgpO2NvbnN0IHRyYW5zYWN0aW9uPXBhcmFtcy50cmFuc2FjdGlvbnx8cGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uO2lmKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy8pKXtsb2dnZXIkdS50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLExvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLHtlcnJvcjplcnJvcixtZXRob2Q6bWV0aG9kLHRyYW5zYWN0aW9uOnRyYW5zYWN0aW9ufSl9aWYobWVzc2FnZS5tYXRjaCgvbm9uY2UgdG9vIGxvdy8pKXtsb2dnZXIkdS50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELHtlcnJvcjplcnJvcixtZXRob2Q6bWV0aG9kLHRyYW5zYWN0aW9uOnRyYW5zYWN0aW9ufSl9aWYobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWQvKSl7bG9nZ2VyJHUudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCx7ZXJyb3I6ZXJyb3IsbWV0aG9kOm1ldGhvZCx0cmFuc2FjdGlvbjp0cmFuc2FjdGlvbn0pfWlmKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC8pKXtsb2dnZXIkdS50aHJvd0Vycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se2Vycm9yOmVycm9yLG1ldGhvZDptZXRob2QsdHJhbnNhY3Rpb246dHJhbnNhY3Rpb259KX1pZihlcnJvckdhcy5pbmRleE9mKG1ldGhvZCk+PTAmJm1lc3NhZ2UubWF0Y2goL2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZXxhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWQvKSl7bG9nZ2VyJHUudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIixMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULHtlcnJvcjplcnJvcixtZXRob2Q6bWV0aG9kLHRyYW5zYWN0aW9uOnRyYW5zYWN0aW9ufSl9dGhyb3cgZXJyb3J9ZnVuY3Rpb24gdGltZXIodGltZW91dCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpe3NldFRpbWVvdXQocmVzb2x2ZSx0aW1lb3V0KX0pfWZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKXtpZihwYXlsb2FkLmVycm9yKXtjb25zdCBlcnJvcj1uZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtlcnJvci5jb2RlPXBheWxvYWQuZXJyb3IuY29kZTtlcnJvci5kYXRhPXBheWxvYWQuZXJyb3IuZGF0YTt0aHJvdyBlcnJvcn1yZXR1cm4gcGF5bG9hZC5yZXN1bHR9ZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKXtpZih2YWx1ZSl7cmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCl9cmV0dXJuIHZhbHVlfWNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkJDQ9e307Y2xhc3MgSnNvblJwY1NpZ25lciBleHRlbmRzIFNpZ25lcntjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLHByb3ZpZGVyLGFkZHJlc3NPckluZGV4KXtsb2dnZXIkdS5jaGVja05ldyhuZXcudGFyZ2V0LEpzb25ScGNTaWduZXIpO3N1cGVyKCk7aWYoY29uc3RydWN0b3JHdWFyZCE9PV9jb25zdHJ1Y3Rvckd1YXJkJDQpe3Rocm93IG5ldyBFcnJvcihcImRvIG5vdCBjYWxsIHRoZSBKc29uUnBjU2lnbmVyIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgcHJvdmlkZXIuZ2V0U2lnbmVyXCIpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHByb3ZpZGVyKTtpZihhZGRyZXNzT3JJbmRleD09bnVsbCl7YWRkcmVzc09ySW5kZXg9MH1pZih0eXBlb2YgYWRkcmVzc09ySW5kZXg9PT1cInN0cmluZ1wiKXtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2FkZHJlc3NcIix0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3NPckluZGV4KSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9pbmRleFwiLG51bGwpfWVsc2UgaWYodHlwZW9mIGFkZHJlc3NPckluZGV4PT09XCJudW1iZXJcIil7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9pbmRleFwiLGFkZHJlc3NPckluZGV4KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2FkZHJlc3NcIixudWxsKX1lbHNle2xvZ2dlciR1LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBpbmRleFwiLFwiYWRkcmVzc09ySW5kZXhcIixhZGRyZXNzT3JJbmRleCl9fWNvbm5lY3QocHJvdmlkZXIpe3JldHVybiBsb2dnZXIkdS50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImNvbm5lY3RcIn0pfWNvbm5lY3RVbmNoZWNrZWQoKXtyZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQkNCx0aGlzLnByb3ZpZGVyLHRoaXMuX2FkZHJlc3N8fHRoaXMuX2luZGV4KX1nZXRBZGRyZXNzKCl7aWYodGhpcy5fYWRkcmVzcyl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKX1yZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsW10pLnRoZW4oYWNjb3VudHM9PntpZihhY2NvdW50cy5sZW5ndGg8PXRoaXMuX2luZGV4KXtsb2dnZXIkdS50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIit0aGlzLl9pbmRleCxMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiZ2V0QWRkcmVzc1wifSl9cmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWNjb3VudHNbdGhpcy5faW5kZXhdKX0pfXNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbil7dHJhbnNhY3Rpb249c2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO2NvbnN0IGZyb21BZGRyZXNzPXRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oYWRkcmVzcz0+e2lmKGFkZHJlc3Mpe2FkZHJlc3M9YWRkcmVzcy50b0xvd2VyQ2FzZSgpfXJldHVybiBhZGRyZXNzfSk7aWYodHJhbnNhY3Rpb24uZ2FzTGltaXQ9PW51bGwpe2NvbnN0IGVzdGltYXRlPXNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtlc3RpbWF0ZS5mcm9tPWZyb21BZGRyZXNzO3RyYW5zYWN0aW9uLmdhc0xpbWl0PXRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoZXN0aW1hdGUpfXJldHVybiByZXNvbHZlUHJvcGVydGllcyh7dHg6cmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pLHNlbmRlcjpmcm9tQWRkcmVzc30pLnRoZW4oKHt0eDp0eCxzZW5kZXI6c2VuZGVyfSk9PntpZih0eC5mcm9tIT1udWxsKXtpZih0eC5mcm9tLnRvTG93ZXJDYXNlKCkhPT1zZW5kZXIpe2xvZ2dlciR1LnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLFwidHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvbil9fWVsc2V7dHguZnJvbT1zZW5kZXJ9Y29uc3QgaGV4VHg9dGhpcy5wcm92aWRlci5jb25zdHJ1Y3Rvci5oZXhsaWZ5VHJhbnNhY3Rpb24odHgse2Zyb206dHJ1ZX0pO3JldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsW2hleFR4XSkudGhlbihoYXNoPT57cmV0dXJuIGhhc2h9LGVycm9yPT57cmV0dXJuIGNoZWNrRXJyb3IoXCJzZW5kVHJhbnNhY3Rpb25cIixlcnJvcixoZXhUeCl9KX0pfXNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbil7cmV0dXJuIGxvZ2dlciR1LnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzaWduVHJhbnNhY3Rpb25cIn0pfXNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbil7cmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKGhhc2g9PntyZXR1cm4gcG9sbCgoKT0+e3JldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpLnRoZW4odHg9PntpZih0eD09PW51bGwpe3JldHVybiB1bmRlZmluZWR9cmV0dXJuIHRoaXMucHJvdmlkZXIuX3dyYXBUcmFuc2FjdGlvbih0eCxoYXNoKX0pfSx7b25jZUJsb2NrOnRoaXMucHJvdmlkZXJ9KS5jYXRjaChlcnJvcj0+e2Vycm9yLnRyYW5zYWN0aW9uSGFzaD1oYXNoO3Rocm93IGVycm9yfSl9KX1zaWduTWVzc2FnZShtZXNzYWdlKXtyZXR1cm4gX19hd2FpdGVyJDkodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IGRhdGE9dHlwZW9mIG1lc3NhZ2U9PT1cInN0cmluZ1wiP3RvVXRmOEJ5dGVzKG1lc3NhZ2UpOm1lc3NhZ2U7Y29uc3QgYWRkcmVzcz15aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIixbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLGhleGxpZnkoZGF0YSldKX0pfV9zaWduVHlwZWREYXRhKGRvbWFpbix0eXBlcyx2YWx1ZSl7cmV0dXJuIF9fYXdhaXRlciQ5KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBwb3B1bGF0ZWQ9eWllbGQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLHR5cGVzLHZhbHVlLG5hbWU9PntyZXR1cm4gdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKX0pO2NvbnN0IGFkZHJlc3M9eWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7cmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsW2FkZHJlc3MudG9Mb3dlckNhc2UoKSxKU09OLnN0cmluZ2lmeShUeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbix0eXBlcyxwb3B1bGF0ZWQudmFsdWUpKV0pfSl9dW5sb2NrKHBhc3N3b3JkKXtyZXR1cm4gX19hd2FpdGVyJDkodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHByb3ZpZGVyPXRoaXMucHJvdmlkZXI7Y29uc3QgYWRkcmVzcz15aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtyZXR1cm4gcHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIixbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLHBhc3N3b3JkLG51bGxdKX0pfX1jbGFzcyBVbmNoZWNrZWRKc29uUnBjU2lnbmVyIGV4dGVuZHMgSnNvblJwY1NpZ25lcntzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pe3JldHVybiB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikudGhlbihoYXNoPT57cmV0dXJue2hhc2g6aGFzaCxub25jZTpudWxsLGdhc0xpbWl0Om51bGwsZ2FzUHJpY2U6bnVsbCxkYXRhOm51bGwsdmFsdWU6bnVsbCxjaGFpbklkOm51bGwsY29uZmlybWF0aW9uczowLGZyb206bnVsbCx3YWl0OmNvbmZpcm1hdGlvbnM9PntyZXR1cm4gdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCxjb25maXJtYXRpb25zKX19fSl9fWNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMkMz17Y2hhaW5JZDp0cnVlLGRhdGE6dHJ1ZSxnYXNMaW1pdDp0cnVlLGdhc1ByaWNlOnRydWUsbm9uY2U6dHJ1ZSx0bzp0cnVlLHZhbHVlOnRydWUsdHlwZTp0cnVlLGFjY2Vzc0xpc3Q6dHJ1ZX07Y2xhc3MgSnNvblJwY1Byb3ZpZGVyIGV4dGVuZHMgQmFzZVByb3ZpZGVye2NvbnN0cnVjdG9yKHVybCxuZXR3b3JrKXtsb2dnZXIkdS5jaGVja05ldyhuZXcudGFyZ2V0LEpzb25ScGNQcm92aWRlcik7bGV0IG5ldHdvcmtPclJlYWR5PW5ldHdvcms7aWYobmV0d29ya09yUmVhZHk9PW51bGwpe25ldHdvcmtPclJlYWR5PW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntzZXRUaW1lb3V0KCgpPT57dGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihuZXR3b3JrPT57cmVzb2x2ZShuZXR3b3JrKX0sZXJyb3I9PntyZWplY3QoZXJyb3IpfSl9LDApfSl9c3VwZXIobmV0d29ya09yUmVhZHkpO2lmKCF1cmwpe3VybD1nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvcixcImRlZmF1bHRVcmxcIikoKX1pZih0eXBlb2YgdXJsPT09XCJzdHJpbmdcIil7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImNvbm5lY3Rpb25cIixPYmplY3QuZnJlZXplKHt1cmw6dXJsfSkpfWVsc2V7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImNvbm5lY3Rpb25cIixPYmplY3QuZnJlZXplKHNoYWxsb3dDb3B5KHVybCkpKX10aGlzLl9uZXh0SWQ9NDJ9Z2V0IF9jYWNoZSgpe2lmKHRoaXMuX2V2ZW50TG9vcENhY2hlPT1udWxsKXt0aGlzLl9ldmVudExvb3BDYWNoZT17fX1yZXR1cm4gdGhpcy5fZXZlbnRMb29wQ2FjaGV9c3RhdGljIGRlZmF1bHRVcmwoKXtyZXR1cm5cImh0dHA6Ly9sb2NhbGhvc3Q6ODU0NVwifWRldGVjdE5ldHdvcmsoKXtpZighdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdKXt0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl09dGhpcy5fdW5jYWNoZWREZXRlY3ROZXR3b3JrKCk7c2V0VGltZW91dCgoKT0+e3RoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXT1udWxsfSwwKX1yZXR1cm4gdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdfV91bmNhY2hlZERldGVjdE5ldHdvcmsoKXtyZXR1cm4gX19hd2FpdGVyJDkodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRpbWVyKDApO2xldCBjaGFpbklkPW51bGw7dHJ5e2NoYWluSWQ9eWllbGQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIixbXSl9Y2F0Y2goZXJyb3Ipe3RyeXtjaGFpbklkPXlpZWxkIHRoaXMuc2VuZChcIm5ldF92ZXJzaW9uXCIsW10pfWNhdGNoKGVycm9yKXt9fWlmKGNoYWluSWQhPW51bGwpe2NvbnN0IGdldE5ldHdvcms9Z2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsXCJnZXROZXR3b3JrXCIpO3RyeXtyZXR1cm4gZ2V0TmV0d29yayhCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpKX1jYXRjaChlcnJvcil7cmV0dXJuIGxvZ2dlciR1LnRocm93RXJyb3IoXCJjb3VsZCBub3QgZGV0ZWN0IG5ldHdvcmtcIixMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1Ise2NoYWluSWQ6Y2hhaW5JZCxldmVudDpcImludmFsaWROZXR3b3JrXCIsc2VydmVyRXJyb3I6ZXJyb3J9KX19cmV0dXJuIGxvZ2dlciR1LnRocm93RXJyb3IoXCJjb3VsZCBub3QgZGV0ZWN0IG5ldHdvcmtcIixMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1Ise2V2ZW50Olwibm9OZXR3b3JrXCJ9KX0pfWdldFNpZ25lcihhZGRyZXNzT3JJbmRleCl7cmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkJDQsdGhpcyxhZGRyZXNzT3JJbmRleCl9Z2V0VW5jaGVja2VkU2lnbmVyKGFkZHJlc3NPckluZGV4KXtyZXR1cm4gdGhpcy5nZXRTaWduZXIoYWRkcmVzc09ySW5kZXgpLmNvbm5lY3RVbmNoZWNrZWQoKX1saXN0QWNjb3VudHMoKXtyZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsW10pLnRoZW4oYWNjb3VudHM9PntyZXR1cm4gYWNjb3VudHMubWFwKGE9PnRoaXMuZm9ybWF0dGVyLmFkZHJlc3MoYSkpfSl9c2VuZChtZXRob2QscGFyYW1zKXtjb25zdCByZXF1ZXN0PXttZXRob2Q6bWV0aG9kLHBhcmFtczpwYXJhbXMsaWQ6dGhpcy5fbmV4dElkKyssanNvbnJwYzpcIjIuMFwifTt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXF1ZXN0XCIscmVxdWVzdDpkZWVwQ29weShyZXF1ZXN0KSxwcm92aWRlcjp0aGlzfSk7Y29uc3QgY2FjaGU9W1wiZXRoX2NoYWluSWRcIixcImV0aF9ibG9ja051bWJlclwiXS5pbmRleE9mKG1ldGhvZCk+PTA7aWYoY2FjaGUmJnRoaXMuX2NhY2hlW21ldGhvZF0pe3JldHVybiB0aGlzLl9jYWNoZVttZXRob2RdfWNvbnN0IHJlc3VsdD1mZXRjaEpzb24odGhpcy5jb25uZWN0aW9uLEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLGdldFJlc3VsdCkudGhlbihyZXN1bHQ9Pnt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXNwb25zZVwiLHJlcXVlc3Q6cmVxdWVzdCxyZXNwb25zZTpyZXN1bHQscHJvdmlkZXI6dGhpc30pO3JldHVybiByZXN1bHR9LGVycm9yPT57dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVzcG9uc2VcIixlcnJvcjplcnJvcixyZXF1ZXN0OnJlcXVlc3QscHJvdmlkZXI6dGhpc30pO3Rocm93IGVycm9yfSk7aWYoY2FjaGUpe3RoaXMuX2NhY2hlW21ldGhvZF09cmVzdWx0O3NldFRpbWVvdXQoKCk9Pnt0aGlzLl9jYWNoZVttZXRob2RdPW51bGx9LDApfXJldHVybiByZXN1bHR9cHJlcGFyZVJlcXVlc3QobWV0aG9kLHBhcmFtcyl7c3dpdGNoKG1ldGhvZCl7Y2FzZVwiZ2V0QmxvY2tOdW1iZXJcIjpyZXR1cm5bXCJldGhfYmxvY2tOdW1iZXJcIixbXV07Y2FzZVwiZ2V0R2FzUHJpY2VcIjpyZXR1cm5bXCJldGhfZ2FzUHJpY2VcIixbXV07Y2FzZVwiZ2V0QmFsYW5jZVwiOnJldHVybltcImV0aF9nZXRCYWxhbmNlXCIsW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcykscGFyYW1zLmJsb2NrVGFnXV07Y2FzZVwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOnJldHVybltcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcykscGFyYW1zLmJsb2NrVGFnXV07Y2FzZVwiZ2V0Q29kZVwiOnJldHVybltcImV0aF9nZXRDb2RlXCIsW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcykscGFyYW1zLmJsb2NrVGFnXV07Y2FzZVwiZ2V0U3RvcmFnZUF0XCI6cmV0dXJuW1wiZXRoX2dldFN0b3JhZ2VBdFwiLFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLHBhcmFtcy5wb3NpdGlvbixwYXJhbXMuYmxvY2tUYWddXTtjYXNlXCJzZW5kVHJhbnNhY3Rpb25cIjpyZXR1cm5bXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO2Nhc2VcImdldEJsb2NrXCI6aWYocGFyYW1zLmJsb2NrVGFnKXtyZXR1cm5bXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFtwYXJhbXMuYmxvY2tUYWcsISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dfWVsc2UgaWYocGFyYW1zLmJsb2NrSGFzaCl7cmV0dXJuW1wiZXRoX2dldEJsb2NrQnlIYXNoXCIsW3BhcmFtcy5ibG9ja0hhc2gsISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dfXJldHVybiBudWxsO2Nhc2VcImdldFRyYW5zYWN0aW9uXCI6cmV0dXJuW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtjYXNlXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpyZXR1cm5bXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtjYXNlXCJjYWxsXCI6e2NvbnN0IGhleGxpZnlUcmFuc2FjdGlvbj1nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvcixcImhleGxpZnlUcmFuc2FjdGlvblwiKTtyZXR1cm5bXCJldGhfY2FsbFwiLFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLHtmcm9tOnRydWV9KSxwYXJhbXMuYmxvY2tUYWddXX1jYXNlXCJlc3RpbWF0ZUdhc1wiOntjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb249Z2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7cmV0dXJuW1wiZXRoX2VzdGltYXRlR2FzXCIsW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24se2Zyb206dHJ1ZX0pXV19Y2FzZVwiZ2V0TG9nc1wiOmlmKHBhcmFtcy5maWx0ZXImJnBhcmFtcy5maWx0ZXIuYWRkcmVzcyE9bnVsbCl7cGFyYW1zLmZpbHRlci5hZGRyZXNzPWdldExvd2VyQ2FzZShwYXJhbXMuZmlsdGVyLmFkZHJlc3MpfXJldHVybltcImV0aF9nZXRMb2dzXCIsW3BhcmFtcy5maWx0ZXJdXTtkZWZhdWx0OmJyZWFrfXJldHVybiBudWxsfXBlcmZvcm0obWV0aG9kLHBhcmFtcyl7cmV0dXJuIF9fYXdhaXRlciQ5KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBhcmdzPXRoaXMucHJlcGFyZVJlcXVlc3QobWV0aG9kLHBhcmFtcyk7aWYoYXJncz09bnVsbCl7bG9nZ2VyJHUudGhyb3dFcnJvcihtZXRob2QrXCIgbm90IGltcGxlbWVudGVkXCIsTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQse29wZXJhdGlvbjptZXRob2R9KX10cnl7cmV0dXJuIHlpZWxkIHRoaXMuc2VuZChhcmdzWzBdLGFyZ3NbMV0pfWNhdGNoKGVycm9yKXtyZXR1cm4gY2hlY2tFcnJvcihtZXRob2QsZXJyb3IscGFyYW1zKX19KX1fc3RhcnRFdmVudChldmVudCl7aWYoZXZlbnQudGFnPT09XCJwZW5kaW5nXCIpe3RoaXMuX3N0YXJ0UGVuZGluZygpfXN1cGVyLl9zdGFydEV2ZW50KGV2ZW50KX1fc3RhcnRQZW5kaW5nKCl7aWYodGhpcy5fcGVuZGluZ0ZpbHRlciE9bnVsbCl7cmV0dXJufWNvbnN0IHNlbGY9dGhpcztjb25zdCBwZW5kaW5nRmlsdGVyPXRoaXMuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIixbXSk7dGhpcy5fcGVuZGluZ0ZpbHRlcj1wZW5kaW5nRmlsdGVyO3BlbmRpbmdGaWx0ZXIudGhlbihmdW5jdGlvbihmaWx0ZXJJZCl7ZnVuY3Rpb24gcG9sbCgpe3NlbGYuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsW2ZpbHRlcklkXSkudGhlbihmdW5jdGlvbihoYXNoZXMpe2lmKHNlbGYuX3BlbmRpbmdGaWx0ZXIhPXBlbmRpbmdGaWx0ZXIpe3JldHVybiBudWxsfWxldCBzZXE9UHJvbWlzZS5yZXNvbHZlKCk7aGFzaGVzLmZvckVhY2goZnVuY3Rpb24oaGFzaCl7c2VsZi5fZW1pdHRlZFtcInQ6XCIraGFzaC50b0xvd2VyQ2FzZSgpXT1cInBlbmRpbmdcIjtzZXE9c2VxLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gc2VsZi5nZXRUcmFuc2FjdGlvbihoYXNoKS50aGVuKGZ1bmN0aW9uKHR4KXtzZWxmLmVtaXQoXCJwZW5kaW5nXCIsdHgpO3JldHVybiBudWxsfSl9KX0pO3JldHVybiBzZXEudGhlbihmdW5jdGlvbigpe3JldHVybiB0aW1lcigxZTMpfSl9KS50aGVuKGZ1bmN0aW9uKCl7aWYoc2VsZi5fcGVuZGluZ0ZpbHRlciE9cGVuZGluZ0ZpbHRlcil7c2VsZi5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLFtmaWx0ZXJJZF0pO3JldHVybn1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cG9sbCgpfSwwKTtyZXR1cm4gbnVsbH0pLmNhdGNoKGVycm9yPT57fSl9cG9sbCgpO3JldHVybiBmaWx0ZXJJZH0pLmNhdGNoKGVycm9yPT57fSl9X3N0b3BFdmVudChldmVudCl7aWYoZXZlbnQudGFnPT09XCJwZW5kaW5nXCImJnRoaXMubGlzdGVuZXJDb3VudChcInBlbmRpbmdcIik9PT0wKXt0aGlzLl9wZW5kaW5nRmlsdGVyPW51bGx9c3VwZXIuX3N0b3BFdmVudChldmVudCl9c3RhdGljIGhleGxpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbixhbGxvd0V4dHJhKXtjb25zdCBhbGxvd2VkPXNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMkMyk7aWYoYWxsb3dFeHRyYSl7Zm9yKGNvbnN0IGtleSBpbiBhbGxvd0V4dHJhKXtpZihhbGxvd0V4dHJhW2tleV0pe2FsbG93ZWRba2V5XT10cnVlfX19Y2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLGFsbG93ZWQpO2NvbnN0IHJlc3VsdD17fTtbXCJnYXNMaW1pdFwiLFwiZ2FzUHJpY2VcIixcInR5cGVcIixcIm5vbmNlXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7aWYodHJhbnNhY3Rpb25ba2V5XT09bnVsbCl7cmV0dXJufWNvbnN0IHZhbHVlPWhleFZhbHVlKHRyYW5zYWN0aW9uW2tleV0pO2lmKGtleT09PVwiZ2FzTGltaXRcIil7a2V5PVwiZ2FzXCJ9cmVzdWx0W2tleV09dmFsdWV9KTtbXCJmcm9tXCIsXCJ0b1wiLFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7aWYodHJhbnNhY3Rpb25ba2V5XT09bnVsbCl7cmV0dXJufXJlc3VsdFtrZXldPWhleGxpZnkodHJhbnNhY3Rpb25ba2V5XSl9KTtpZih0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KXtyZXN1bHRbXCJhY2Nlc3NMaXN0XCJdPWFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCl9cmV0dXJuIHJlc3VsdH19XCJ1c2Ugc3RyaWN0XCI7bGV0IFdTPW51bGw7dHJ5e1dTPVdlYlNvY2tldDtpZihXUz09bnVsbCl7dGhyb3cgbmV3IEVycm9yKFwiaW5qZWN0IHBsZWFzZVwiKX19Y2F0Y2goZXJyb3Ipe2NvbnN0IGxvZ2dlcj1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7V1M9ZnVuY3Rpb24oKXtsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldHMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm5ldyBXZWJTb2NrZXQoKVwifSl9fVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkYT13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJHY9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2xldCBOZXh0SWQ9MTtjbGFzcyBXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlcntjb25zdHJ1Y3Rvcih1cmwsbmV0d29yayl7aWYobmV0d29yaz09PVwiYW55XCIpe2xvZ2dlciR2LnRocm93RXJyb3IoXCJXZWJTb2NrZXRQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0ICdhbnknIG5ldHdvcmsgeWV0XCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm5ldHdvcms6YW55XCJ9KX1zdXBlcih1cmwsbmV0d29yayk7dGhpcy5fcG9sbGluZ0ludGVydmFsPS0xO3RoaXMuX3dzUmVhZHk9ZmFsc2U7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl93ZWJzb2NrZXRcIixuZXcgV1ModGhpcy5jb25uZWN0aW9uLnVybCkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfcmVxdWVzdHNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9zdWJzXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfc3ViSWRzXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfZGV0ZWN0TmV0d29ya1wiLHN1cGVyLmRldGVjdE5ldHdvcmsoKSk7dGhpcy5fd2Vic29ja2V0Lm9ub3Blbj0oKCk9Pnt0aGlzLl93c1JlYWR5PXRydWU7T2JqZWN0LmtleXModGhpcy5fcmVxdWVzdHMpLmZvckVhY2goaWQ9Pnt0aGlzLl93ZWJzb2NrZXQuc2VuZCh0aGlzLl9yZXF1ZXN0c1tpZF0ucGF5bG9hZCl9KX0pO3RoaXMuX3dlYnNvY2tldC5vbm1lc3NhZ2U9KG1lc3NhZ2VFdmVudD0+e2NvbnN0IGRhdGE9bWVzc2FnZUV2ZW50LmRhdGE7Y29uc3QgcmVzdWx0PUpTT04ucGFyc2UoZGF0YSk7aWYocmVzdWx0LmlkIT1udWxsKXtjb25zdCBpZD1TdHJpbmcocmVzdWx0LmlkKTtjb25zdCByZXF1ZXN0PXRoaXMuX3JlcXVlc3RzW2lkXTtkZWxldGUgdGhpcy5fcmVxdWVzdHNbaWRdO2lmKHJlc3VsdC5yZXN1bHQhPT11bmRlZmluZWQpe3JlcXVlc3QuY2FsbGJhY2sobnVsbCxyZXN1bHQucmVzdWx0KTt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXNwb25zZVwiLHJlcXVlc3Q6SlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLHJlc3BvbnNlOnJlc3VsdC5yZXN1bHQscHJvdmlkZXI6dGhpc30pfWVsc2V7bGV0IGVycm9yPW51bGw7aWYocmVzdWx0LmVycm9yKXtlcnJvcj1uZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2V8fFwidW5rbm93biBlcnJvclwiKTtkZWZpbmVSZWFkT25seShlcnJvcixcImNvZGVcIixyZXN1bHQuZXJyb3IuY29kZXx8bnVsbCk7ZGVmaW5lUmVhZE9ubHkoZXJyb3IsXCJyZXNwb25zZVwiLGRhdGEpfWVsc2V7ZXJyb3I9bmV3IEVycm9yKFwidW5rbm93biBlcnJvclwiKX1yZXF1ZXN0LmNhbGxiYWNrKGVycm9yLHVuZGVmaW5lZCk7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVzcG9uc2VcIixlcnJvcjplcnJvcixyZXF1ZXN0OkpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxwcm92aWRlcjp0aGlzfSl9fWVsc2UgaWYocmVzdWx0Lm1ldGhvZD09PVwiZXRoX3N1YnNjcmlwdGlvblwiKXtjb25zdCBzdWI9dGhpcy5fc3Vic1tyZXN1bHQucGFyYW1zLnN1YnNjcmlwdGlvbl07aWYoc3ViKXtzdWIucHJvY2Vzc0Z1bmMocmVzdWx0LnBhcmFtcy5yZXN1bHQpfX1lbHNle2NvbnNvbGUud2FybihcInRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIil9fSk7Y29uc3QgZmF1eFBvbGw9c2V0SW50ZXJ2YWwoKCk9Pnt0aGlzLmVtaXQoXCJwb2xsXCIpfSwxZTMpO2lmKGZhdXhQb2xsLnVucmVmKXtmYXV4UG9sbC51bnJlZigpfX1kZXRlY3ROZXR3b3JrKCl7cmV0dXJuIHRoaXMuX2RldGVjdE5ldHdvcmt9Z2V0IHBvbGxpbmdJbnRlcnZhbCgpe3JldHVybiAwfXJlc2V0RXZlbnRzQmxvY2soYmxvY2tOdW1iZXIpe2xvZ2dlciR2LnRocm93RXJyb3IoXCJjYW5ub3QgcmVzZXQgZXZlbnRzIGJsb2NrIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInJlc2V0RXZlbnRCbG9ja1wifSl9c2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSl7bG9nZ2VyJHYudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBpbnRlcnZhbCBvbiBXZWJTb2NrZXRQcm92aWRlclwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzZXRQb2xsaW5nSW50ZXJ2YWxcIn0pfXBvbGwoKXtyZXR1cm4gX19hd2FpdGVyJGEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3JldHVybiBudWxsfSl9c2V0IHBvbGxpbmcodmFsdWUpe2lmKCF2YWx1ZSl7cmV0dXJufWxvZ2dlciR2LnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgb24gV2ViU29ja2V0UHJvdmlkZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2V0UG9sbGluZ1wifSl9c2VuZChtZXRob2QscGFyYW1zKXtjb25zdCByaWQ9TmV4dElkKys7cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntmdW5jdGlvbiBjYWxsYmFjayhlcnJvcixyZXN1bHQpe2lmKGVycm9yKXtyZXR1cm4gcmVqZWN0KGVycm9yKX1yZXR1cm4gcmVzb2x2ZShyZXN1bHQpfWNvbnN0IHBheWxvYWQ9SlNPTi5zdHJpbmdpZnkoe21ldGhvZDptZXRob2QscGFyYW1zOnBhcmFtcyxpZDpyaWQsanNvbnJwYzpcIjIuMFwifSk7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVxdWVzdFwiLHJlcXVlc3Q6SlNPTi5wYXJzZShwYXlsb2FkKSxwcm92aWRlcjp0aGlzfSk7dGhpcy5fcmVxdWVzdHNbU3RyaW5nKHJpZCldPXtjYWxsYmFjazpjYWxsYmFjayxwYXlsb2FkOnBheWxvYWR9O2lmKHRoaXMuX3dzUmVhZHkpe3RoaXMuX3dlYnNvY2tldC5zZW5kKHBheWxvYWQpfX0pfXN0YXRpYyBkZWZhdWx0VXJsKCl7cmV0dXJuXCJ3czovL2xvY2FsaG9zdDo4NTQ2XCJ9X3N1YnNjcmliZSh0YWcscGFyYW0scHJvY2Vzc0Z1bmMpe3JldHVybiBfX2F3YWl0ZXIkYSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7bGV0IHN1YklkUHJvbWlzZT10aGlzLl9zdWJJZHNbdGFnXTtpZihzdWJJZFByb21pc2U9PW51bGwpe3N1YklkUHJvbWlzZT1Qcm9taXNlLmFsbChwYXJhbSkudGhlbihwYXJhbT0+e3JldHVybiB0aGlzLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIscGFyYW0pfSk7dGhpcy5fc3ViSWRzW3RhZ109c3ViSWRQcm9taXNlfWNvbnN0IHN1YklkPXlpZWxkIHN1YklkUHJvbWlzZTt0aGlzLl9zdWJzW3N1YklkXT17dGFnOnRhZyxwcm9jZXNzRnVuYzpwcm9jZXNzRnVuY319KX1fc3RhcnRFdmVudChldmVudCl7c3dpdGNoKGV2ZW50LnR5cGUpe2Nhc2VcImJsb2NrXCI6dGhpcy5fc3Vic2NyaWJlKFwiYmxvY2tcIixbXCJuZXdIZWFkc1wiXSxyZXN1bHQ9Pntjb25zdCBibG9ja051bWJlcj1CaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO3RoaXMuX2VtaXR0ZWQuYmxvY2s9YmxvY2tOdW1iZXI7dGhpcy5lbWl0KFwiYmxvY2tcIixibG9ja051bWJlcil9KTticmVhaztjYXNlXCJwZW5kaW5nXCI6dGhpcy5fc3Vic2NyaWJlKFwicGVuZGluZ1wiLFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0scmVzdWx0PT57dGhpcy5lbWl0KFwicGVuZGluZ1wiLHJlc3VsdCl9KTticmVhaztjYXNlXCJmaWx0ZXJcIjp0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLFtcImxvZ3NcIix0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0scmVzdWx0PT57aWYocmVzdWx0LnJlbW92ZWQ9PW51bGwpe3Jlc3VsdC5yZW1vdmVkPWZhbHNlfXRoaXMuZW1pdChldmVudC5maWx0ZXIsdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpfSk7YnJlYWs7Y2FzZVwidHhcIjp7Y29uc3QgZW1pdFJlY2VpcHQ9ZXZlbnQ9Pntjb25zdCBoYXNoPWV2ZW50Lmhhc2g7dGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbihyZWNlaXB0PT57aWYoIXJlY2VpcHQpe3JldHVybn10aGlzLmVtaXQoaGFzaCxyZWNlaXB0KX0pfTtlbWl0UmVjZWlwdChldmVudCk7dGhpcy5fc3Vic2NyaWJlKFwidHhcIixbXCJuZXdIZWFkc1wiXSxyZXN1bHQ9Pnt0aGlzLl9ldmVudHMuZmlsdGVyKGU9PmUudHlwZT09PVwidHhcIikuZm9yRWFjaChlbWl0UmVjZWlwdCl9KTticmVha31jYXNlXCJkZWJ1Z1wiOmNhc2VcInBvbGxcIjpjYXNlXCJ3aWxsUG9sbFwiOmNhc2VcImRpZFBvbGxcIjpjYXNlXCJlcnJvclwiOmJyZWFrO2RlZmF1bHQ6Y29uc29sZS5sb2coXCJ1bmhhbmRsZWQ6XCIsZXZlbnQpO2JyZWFrfX1fc3RvcEV2ZW50KGV2ZW50KXtsZXQgdGFnPWV2ZW50LnRhZztpZihldmVudC50eXBlPT09XCJ0eFwiKXtpZih0aGlzLl9ldmVudHMuZmlsdGVyKGU9PmUudHlwZT09PVwidHhcIikubGVuZ3RoKXtyZXR1cm59dGFnPVwidHhcIn1lbHNlIGlmKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpe3JldHVybn1jb25zdCBzdWJJZD10aGlzLl9zdWJJZHNbdGFnXTtpZighc3ViSWQpe3JldHVybn1kZWxldGUgdGhpcy5fc3ViSWRzW3RhZ107c3ViSWQudGhlbihzdWJJZD0+e2lmKCF0aGlzLl9zdWJzW3N1YklkXSl7cmV0dXJufWRlbGV0ZSB0aGlzLl9zdWJzW3N1YklkXTt0aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIixbc3ViSWRdKX0pfWRlc3Ryb3koKXtyZXR1cm4gX19hd2FpdGVyJGEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2lmKHRoaXMuX3dlYnNvY2tldC5yZWFkeVN0YXRlPT09V1MuQ09OTkVDVElORyl7eWllbGQgbmV3IFByb21pc2UocmVzb2x2ZT0+e3RoaXMuX3dlYnNvY2tldC5vbm9wZW49ZnVuY3Rpb24oKXtyZXNvbHZlKHRydWUpfTt0aGlzLl93ZWJzb2NrZXQub25lcnJvcj1mdW5jdGlvbigpe3Jlc29sdmUoZmFsc2UpfX0pfXRoaXMuX3dlYnNvY2tldC5jbG9zZSgxZTMpfSl9fVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkYj13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJHc9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2NsYXNzIFN0YXRpY0pzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlcntkZXRlY3ROZXR3b3JrKCl7Y29uc3QgX3N1cGVyPU9iamVjdC5jcmVhdGUobnVsbCx7ZGV0ZWN0TmV0d29yazp7Z2V0OigpPT5zdXBlci5kZXRlY3ROZXR3b3JrfX0pO3JldHVybiBfX2F3YWl0ZXIkYih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7bGV0IG5ldHdvcms9dGhpcy5uZXR3b3JrO2lmKG5ldHdvcms9PW51bGwpe25ldHdvcms9eWllbGQgX3N1cGVyLmRldGVjdE5ldHdvcmsuY2FsbCh0aGlzKTtpZighbmV0d29yayl7bG9nZ2VyJHcudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIixMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1Ise30pfWlmKHRoaXMuX25ldHdvcms9PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfbmV0d29ya1wiLG5ldHdvcmspO3RoaXMuZW1pdChcIm5ldHdvcmtcIixuZXR3b3JrLG51bGwpfX1yZXR1cm4gbmV0d29ya30pfX1jbGFzcyBVcmxKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBTdGF0aWNKc29uUnBjUHJvdmlkZXJ7Y29uc3RydWN0b3IobmV0d29yayxhcGlLZXkpe2xvZ2dlciR3LmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCxVcmxKc29uUnBjUHJvdmlkZXIpO25ldHdvcms9Z2V0U3RhdGljKG5ldy50YXJnZXQsXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO2FwaUtleT1nZXRTdGF0aWMobmV3LnRhcmdldCxcImdldEFwaUtleVwiKShhcGlLZXkpO2NvbnN0IGNvbm5lY3Rpb249Z2V0U3RhdGljKG5ldy50YXJnZXQsXCJnZXRVcmxcIikobmV0d29yayxhcGlLZXkpO3N1cGVyKGNvbm5lY3Rpb24sbmV0d29yayk7aWYodHlwZW9mIGFwaUtleT09PVwic3RyaW5nXCIpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhcGlLZXlcIixhcGlLZXkpfWVsc2UgaWYoYXBpS2V5IT1udWxsKXtPYmplY3Qua2V5cyhhcGlLZXkpLmZvckVhY2goa2V5PT57ZGVmaW5lUmVhZE9ubHkodGhpcyxrZXksYXBpS2V5W2tleV0pfSl9fV9zdGFydFBlbmRpbmcoKXtsb2dnZXIkdy53YXJuKFwiV0FSTklORzogQVBJIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgcGVuZGluZyBmaWx0ZXJzXCIpfWlzQ29tbXVuaXR5UmVzb3VyY2UoKXtyZXR1cm4gZmFsc2V9Z2V0U2lnbmVyKGFkZHJlc3Mpe3JldHVybiBsb2dnZXIkdy50aHJvd0Vycm9yKFwiQVBJIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZ1wiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXRTaWduZXJcIn0pfWxpc3RBY2NvdW50cygpe3JldHVybiBQcm9taXNlLnJlc29sdmUoW10pfXN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KXtyZXR1cm4gYXBpS2V5fXN0YXRpYyBnZXRVcmwobmV0d29yayxhcGlLZXkpe3JldHVybiBsb2dnZXIkdy50aHJvd0Vycm9yKFwibm90IGltcGxlbWVudGVkOyBzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldFVybFwiLExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELHtvcGVyYXRpb246XCJnZXRVcmxcIn0pfX1cInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkeD1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7Y29uc3QgZGVmYXVsdEFwaUtleT1cIl9nZzd3U1NpMEtNQnNkS25HVmZIRHVlcTZ4TUI5RWtDXCI7Y2xhc3MgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgV2ViU29ja2V0UHJvdmlkZXJ7Y29uc3RydWN0b3IobmV0d29yayxhcGlLZXkpe2NvbnN0IHByb3ZpZGVyPW5ldyBBbGNoZW15UHJvdmlkZXIobmV0d29yayxhcGlLZXkpO2NvbnN0IHVybD1wcm92aWRlci5jb25uZWN0aW9uLnVybC5yZXBsYWNlKC9eaHR0cC9pLFwid3NcIikucmVwbGFjZShcIi5hbGNoZW15YXBpLlwiLFwiLndzLmFsY2hlbXlhcGkuXCIpO3N1cGVyKHVybCxwcm92aWRlci5uZXR3b3JrKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYXBpS2V5XCIscHJvdmlkZXIuYXBpS2V5KX1pc0NvbW11bml0eVJlc291cmNlKCl7cmV0dXJuIHRoaXMuYXBpS2V5PT09ZGVmYXVsdEFwaUtleX19Y2xhc3MgQWxjaGVteVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVye3N0YXRpYyBnZXRXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLGFwaUtleSl7cmV0dXJuIG5ldyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIobmV0d29yayxhcGlLZXkpfXN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KXtpZihhcGlLZXk9PW51bGwpe3JldHVybiBkZWZhdWx0QXBpS2V5fWlmKGFwaUtleSYmdHlwZW9mIGFwaUtleSE9PVwic3RyaW5nXCIpe2xvZ2dlciR4LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsXCJhcGlLZXlcIixhcGlLZXkpfXJldHVybiBhcGlLZXl9c3RhdGljIGdldFVybChuZXR3b3JrLGFwaUtleSl7bGV0IGhvc3Q9bnVsbDtzd2l0Y2gobmV0d29yay5uYW1lKXtjYXNlXCJob21lc3RlYWRcIjpob3N0PVwiZXRoLW1haW5uZXQuYWxjaGVteWFwaS5pby92Mi9cIjticmVhaztjYXNlXCJyb3BzdGVuXCI6aG9zdD1cImV0aC1yb3BzdGVuLmFsY2hlbXlhcGkuaW8vdjIvXCI7YnJlYWs7Y2FzZVwicmlua2VieVwiOmhvc3Q9XCJldGgtcmlua2VieS5hbGNoZW15YXBpLmlvL3YyL1wiO2JyZWFrO2Nhc2VcImdvZXJsaVwiOmhvc3Q9XCJldGgtZ29lcmxpLmFsY2hlbXlhcGkuaW8vdjIvXCI7YnJlYWs7Y2FzZVwia292YW5cIjpob3N0PVwiZXRoLWtvdmFuLmFsY2hlbXlhcGkuaW8vdjIvXCI7YnJlYWs7ZGVmYXVsdDpsb2dnZXIkeC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsXCJuZXR3b3JrXCIsYXJndW1lbnRzWzBdKX1yZXR1cm57YWxsb3dHemlwOnRydWUsdXJsOlwiaHR0cHM6L1wiK1wiL1wiK2hvc3QrYXBpS2V5LHRocm90dGxlQ2FsbGJhY2s6KGF0dGVtcHQsdXJsKT0+e2lmKGFwaUtleT09PWRlZmF1bHRBcGlLZXkpe3Nob3dUaHJvdHRsZU1lc3NhZ2UoKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpfX19aXNDb21tdW5pdHlSZXNvdXJjZSgpe3JldHVybiB0aGlzLmFwaUtleT09PWRlZmF1bHRBcGlLZXl9fVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkYz13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJHk9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2NsYXNzIENsb3VkZmxhcmVQcm92aWRlciBleHRlbmRzIFVybEpzb25ScGNQcm92aWRlcntzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSl7aWYoYXBpS2V5IT1udWxsKXtsb2dnZXIkeS50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcGlLZXkgbm90IHN1cHBvcnRlZCBmb3IgY2xvdWRmbGFyZVwiLFwiYXBpS2V5XCIsYXBpS2V5KX1yZXR1cm4gbnVsbH1zdGF0aWMgZ2V0VXJsKG5ldHdvcmssYXBpS2V5KXtsZXQgaG9zdD1udWxsO3N3aXRjaChuZXR3b3JrLm5hbWUpe2Nhc2VcImhvbWVzdGVhZFwiOmhvc3Q9XCJodHRwczovL2Nsb3VkZmxhcmUtZXRoLmNvbS9cIjticmVhaztkZWZhdWx0OmxvZ2dlciR5LnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIixcIm5ldHdvcmtcIixhcmd1bWVudHNbMF0pfXJldHVybiBob3N0fXBlcmZvcm0obWV0aG9kLHBhcmFtcyl7Y29uc3QgX3N1cGVyPU9iamVjdC5jcmVhdGUobnVsbCx7cGVyZm9ybTp7Z2V0OigpPT5zdXBlci5wZXJmb3JtfX0pO3JldHVybiBfX2F3YWl0ZXIkYyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYobWV0aG9kPT09XCJnZXRCbG9ja051bWJlclwiKXtjb25zdCBibG9jaz15aWVsZCBfc3VwZXIucGVyZm9ybS5jYWxsKHRoaXMsXCJnZXRCbG9ja1wiLHtibG9ja1RhZzpcImxhdGVzdFwifSk7cmV0dXJuIGJsb2NrLm51bWJlcn1yZXR1cm4gX3N1cGVyLnBlcmZvcm0uY2FsbCh0aGlzLG1ldGhvZCxwYXJhbXMpfSl9fVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkZD13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJHo9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2Z1bmN0aW9uIGdldFRyYW5zYWN0aW9uUG9zdERhdGEodHJhbnNhY3Rpb24pe2NvbnN0IHJlc3VsdD17fTtmb3IobGV0IGtleSBpbiB0cmFuc2FjdGlvbil7aWYodHJhbnNhY3Rpb25ba2V5XT09bnVsbCl7Y29udGludWV9bGV0IHZhbHVlPXRyYW5zYWN0aW9uW2tleV07aWYoe3R5cGU6dHJ1ZSxnYXNMaW1pdDp0cnVlLGdhc1ByaWNlOnRydWUsbm9uY2U6dHJ1ZSx2YWx1ZTp0cnVlfVtrZXldKXt2YWx1ZT1oZXhWYWx1ZShoZXhsaWZ5KHZhbHVlKSl9ZWxzZSBpZihrZXk9PT1cImFjY2Vzc0xpc3RcIil7Y29uc3Qgc2V0cz1hY2Nlc3NMaXN0aWZ5KHZhbHVlKTt2YWx1ZT1cIltcIitzZXRzLm1hcChzZXQ9PntyZXR1cm5ge2FkZHJlc3M6XCIke3NldC5hZGRyZXNzfVwiLHN0b3JhZ2VLZXlzOltcIiR7c2V0LnN0b3JhZ2VLZXlzLmpvaW4oJ1wiLFwiJyl9XCJdfWB9KS5qb2luKFwiLFwiKStcIl1cIn1lbHNle3ZhbHVlPWhleGxpZnkodmFsdWUpfXJlc3VsdFtrZXldPXZhbHVlfXJldHVybiByZXN1bHR9ZnVuY3Rpb24gZ2V0UmVzdWx0JDEocmVzdWx0KXtpZihyZXN1bHQuc3RhdHVzPT0wJiYocmVzdWx0Lm1lc3NhZ2U9PT1cIk5vIHJlY29yZHMgZm91bmRcInx8cmVzdWx0Lm1lc3NhZ2U9PT1cIk5vIHRyYW5zYWN0aW9ucyBmb3VuZFwiKSl7cmV0dXJuIHJlc3VsdC5yZXN1bHR9aWYocmVzdWx0LnN0YXR1cyE9MXx8cmVzdWx0Lm1lc3NhZ2UhPVwiT0tcIil7Y29uc3QgZXJyb3I9bmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtlcnJvci5yZXN1bHQ9SlNPTi5zdHJpbmdpZnkocmVzdWx0KTtpZigocmVzdWx0LnJlc3VsdHx8XCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKT49MCl7ZXJyb3IudGhyb3R0bGVSZXRyeT10cnVlfXRocm93IGVycm9yfXJldHVybiByZXN1bHQucmVzdWx0fWZ1bmN0aW9uIGdldEpzb25SZXN1bHQocmVzdWx0KXtpZihyZXN1bHQmJnJlc3VsdC5zdGF0dXM9PTAmJnJlc3VsdC5tZXNzYWdlPT1cIk5PVE9LXCImJihyZXN1bHQucmVzdWx0fHxcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpPj0wKXtjb25zdCBlcnJvcj1uZXcgRXJyb3IoXCJ0aHJvdHRsZWQgcmVzcG9uc2VcIik7ZXJyb3IucmVzdWx0PUpTT04uc3RyaW5naWZ5KHJlc3VsdCk7ZXJyb3IudGhyb3R0bGVSZXRyeT10cnVlO3Rocm93IGVycm9yfWlmKHJlc3VsdC5qc29ucnBjIT1cIjIuMFwiKXtjb25zdCBlcnJvcj1uZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO2Vycm9yLnJlc3VsdD1KU09OLnN0cmluZ2lmeShyZXN1bHQpO3Rocm93IGVycm9yfWlmKHJlc3VsdC5lcnJvcil7Y29uc3QgZXJyb3I9bmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlfHxcInVua25vd24gZXJyb3JcIik7aWYocmVzdWx0LmVycm9yLmNvZGUpe2Vycm9yLmNvZGU9cmVzdWx0LmVycm9yLmNvZGV9aWYocmVzdWx0LmVycm9yLmRhdGEpe2Vycm9yLmRhdGE9cmVzdWx0LmVycm9yLmRhdGF9dGhyb3cgZXJyb3J9cmV0dXJuIHJlc3VsdC5yZXN1bHR9ZnVuY3Rpb24gY2hlY2tMb2dUYWcoYmxvY2tUYWcpe2lmKGJsb2NrVGFnPT09XCJwZW5kaW5nXCIpe3Rocm93IG5ldyBFcnJvcihcInBlbmRpbmcgbm90IHN1cHBvcnRlZFwiKX1pZihibG9ja1RhZz09PVwibGF0ZXN0XCIpe3JldHVybiBibG9ja1RhZ31yZXR1cm4gcGFyc2VJbnQoYmxvY2tUYWcuc3Vic3RyaW5nKDIpLDE2KX1jb25zdCBkZWZhdWx0QXBpS2V5JDE9XCI5RDEzWkU3WFNCVEo5NE45Qk5KMk1BMzNWTUFZMllQSVJCXCI7ZnVuY3Rpb24gY2hlY2tFcnJvciQxKG1ldGhvZCxlcnJvcix0cmFuc2FjdGlvbil7aWYobWV0aG9kPT09XCJjYWxsXCImJmVycm9yLmNvZGU9PT1Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUil7Y29uc3QgZT1lcnJvci5lcnJvcjtpZihlJiZlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSYmaXNIZXhTdHJpbmcoZS5kYXRhKSl7cmV0dXJuIGUuZGF0YX19bGV0IG1lc3NhZ2U9ZXJyb3IubWVzc2FnZTtpZihlcnJvci5jb2RlPT09TG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ipe2lmKGVycm9yLmVycm9yJiZ0eXBlb2YgZXJyb3IuZXJyb3IubWVzc2FnZT09PVwic3RyaW5nXCIpe21lc3NhZ2U9ZXJyb3IuZXJyb3IubWVzc2FnZX1lbHNlIGlmKHR5cGVvZiBlcnJvci5ib2R5PT09XCJzdHJpbmdcIil7bWVzc2FnZT1lcnJvci5ib2R5fWVsc2UgaWYodHlwZW9mIGVycm9yLnJlc3BvbnNlVGV4dD09PVwic3RyaW5nXCIpe21lc3NhZ2U9ZXJyb3IucmVzcG9uc2VUZXh0fX1tZXNzYWdlPShtZXNzYWdlfHxcIlwiKS50b0xvd2VyQ2FzZSgpO2lmKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy8pKXtsb2dnZXIkei50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLExvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLHtlcnJvcjplcnJvcixtZXRob2Q6bWV0aG9kLHRyYW5zYWN0aW9uOnRyYW5zYWN0aW9ufSl9aWYobWVzc2FnZS5tYXRjaCgvc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkfHRyYW5zYWN0aW9uIG5vbmNlIGlzIHRvbyBsb3cvKSl7bG9nZ2VyJHoudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCx7ZXJyb3I6ZXJyb3IsbWV0aG9kOm1ldGhvZCx0cmFuc2FjdGlvbjp0cmFuc2FjdGlvbn0pfWlmKG1lc3NhZ2UubWF0Y2goL2Fub3RoZXIgdHJhbnNhY3Rpb24gd2l0aCBzYW1lIG5vbmNlLykpe2xvZ2dlciR6LnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQse2Vycm9yOmVycm9yLG1ldGhvZDptZXRob2QsdHJhbnNhY3Rpb246dHJhbnNhY3Rpb259KX1pZihtZXNzYWdlLm1hdGNoKC9leGVjdXRpb24gZmFpbGVkIGR1ZSB0byBhbiBleGNlcHRpb24vKSl7bG9nZ2VyJHoudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIixMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULHtlcnJvcjplcnJvcixtZXRob2Q6bWV0aG9kLHRyYW5zYWN0aW9uOnRyYW5zYWN0aW9ufSl9dGhyb3cgZXJyb3J9Y2xhc3MgRXRoZXJzY2FuUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXJ7Y29uc3RydWN0b3IobmV0d29yayxhcGlLZXkpe2xvZ2dlciR6LmNoZWNrTmV3KG5ldy50YXJnZXQsRXRoZXJzY2FuUHJvdmlkZXIpO3N1cGVyKG5ldHdvcmspO2xldCBuYW1lPVwiaW52YWxpZFwiO2lmKHRoaXMubmV0d29yayl7bmFtZT10aGlzLm5ldHdvcmsubmFtZX1sZXQgYmFzZVVybD1udWxsO3N3aXRjaChuYW1lKXtjYXNlXCJob21lc3RlYWRcIjpiYXNlVXJsPVwiaHR0cHM6Ly9hcGkuZXRoZXJzY2FuLmlvXCI7YnJlYWs7Y2FzZVwicm9wc3RlblwiOmJhc2VVcmw9XCJodHRwczovL2FwaS1yb3BzdGVuLmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2Nhc2VcInJpbmtlYnlcIjpiYXNlVXJsPVwiaHR0cHM6Ly9hcGktcmlua2VieS5ldGhlcnNjYW4uaW9cIjticmVhaztjYXNlXCJrb3ZhblwiOmJhc2VVcmw9XCJodHRwczovL2FwaS1rb3Zhbi5ldGhlcnNjYW4uaW9cIjticmVhaztjYXNlXCJnb2VybGlcIjpiYXNlVXJsPVwiaHR0cHM6Ly9hcGktZ29lcmxpLmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiKX1kZWZpbmVSZWFkT25seSh0aGlzLFwiYmFzZVVybFwiLGJhc2VVcmwpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhcGlLZXlcIixhcGlLZXl8fGRlZmF1bHRBcGlLZXkkMSl9ZGV0ZWN0TmV0d29yaygpe3JldHVybiBfX2F3YWl0ZXIkZCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7cmV0dXJuIHRoaXMubmV0d29ya30pfXBlcmZvcm0obWV0aG9kLHBhcmFtcyl7Y29uc3QgX3N1cGVyPU9iamVjdC5jcmVhdGUobnVsbCx7cGVyZm9ybTp7Z2V0OigpPT5zdXBlci5wZXJmb3JtfX0pO3JldHVybiBfX2F3YWl0ZXIkZCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7bGV0IHVybD10aGlzLmJhc2VVcmwrXCIvYXBpXCI7bGV0IGFwaUtleT1cIlwiO2lmKHRoaXMuYXBpS2V5KXthcGlLZXkrPVwiJmFwaWtleT1cIit0aGlzLmFwaUtleX1jb25zdCBnZXQ9KHVybCxwYXlsb2FkLHByb2NGdW5jKT0+X19hd2FpdGVyJGQodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlcXVlc3RcIixyZXF1ZXN0OnVybCxwcm92aWRlcjp0aGlzfSk7Y29uc3QgY29ubmVjdGlvbj17dXJsOnVybCx0aHJvdHRsZVNsb3RJbnRlcnZhbDoxZTMsdGhyb3R0bGVDYWxsYmFjazooYXR0ZW1wdCx1cmwpPT57aWYodGhpcy5pc0NvbW11bml0eVJlc291cmNlKCkpe3Nob3dUaHJvdHRsZU1lc3NhZ2UoKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpfX07bGV0IHBheWxvYWRTdHI9bnVsbDtpZihwYXlsb2FkKXtjb25uZWN0aW9uLmhlYWRlcnM9e1wiY29udGVudC10eXBlXCI6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIn07cGF5bG9hZFN0cj1PYmplY3Qua2V5cyhwYXlsb2FkKS5tYXAoa2V5PT57cmV0dXJuYCR7a2V5fT0ke3BheWxvYWRba2V5XX1gfSkuam9pbihcIiZcIil9Y29uc3QgcmVzdWx0PXlpZWxkIGZldGNoSnNvbihjb25uZWN0aW9uLHBheWxvYWRTdHIscHJvY0Z1bmN8fGdldEpzb25SZXN1bHQpO3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlc3BvbnNlXCIscmVxdWVzdDp1cmwscmVzcG9uc2U6ZGVlcENvcHkocmVzdWx0KSxwcm92aWRlcjp0aGlzfSk7cmV0dXJuIHJlc3VsdH0pO3N3aXRjaChtZXRob2Qpe2Nhc2VcImdldEJsb2NrTnVtYmVyXCI6dXJsKz1cIj9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9ibG9ja051bWJlclwiK2FwaUtleTtyZXR1cm4gZ2V0KHVybCxudWxsKTtjYXNlXCJnZXRHYXNQcmljZVwiOnVybCs9XCI/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2FzUHJpY2VcIithcGlLZXk7cmV0dXJuIGdldCh1cmwsbnVsbCk7Y2FzZVwiZ2V0QmFsYW5jZVwiOnVybCs9XCI/bW9kdWxlPWFjY291bnQmYWN0aW9uPWJhbGFuY2UmYWRkcmVzcz1cIitwYXJhbXMuYWRkcmVzczt1cmwrPVwiJnRhZz1cIitwYXJhbXMuYmxvY2tUYWcrYXBpS2V5O3JldHVybiBnZXQodXJsLG51bGwsZ2V0UmVzdWx0JDEpO2Nhc2VcImdldFRyYW5zYWN0aW9uQ291bnRcIjp1cmwrPVwiP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFRyYW5zYWN0aW9uQ291bnQmYWRkcmVzcz1cIitwYXJhbXMuYWRkcmVzczt1cmwrPVwiJnRhZz1cIitwYXJhbXMuYmxvY2tUYWcrYXBpS2V5O3JldHVybiBnZXQodXJsLG51bGwpO2Nhc2VcImdldENvZGVcIjp1cmwrPVwiP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldENvZGUmYWRkcmVzcz1cIitwYXJhbXMuYWRkcmVzczt1cmwrPVwiJnRhZz1cIitwYXJhbXMuYmxvY2tUYWcrYXBpS2V5O3JldHVybiBnZXQodXJsLG51bGwpO2Nhc2VcImdldFN0b3JhZ2VBdFwiOnVybCs9XCI/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0U3RvcmFnZUF0JmFkZHJlc3M9XCIrcGFyYW1zLmFkZHJlc3M7dXJsKz1cIiZwb3NpdGlvbj1cIitwYXJhbXMucG9zaXRpb247dXJsKz1cIiZ0YWc9XCIrcGFyYW1zLmJsb2NrVGFnK2FwaUtleTtyZXR1cm4gZ2V0KHVybCxudWxsKTtjYXNlXCJzZW5kVHJhbnNhY3Rpb25cIjpyZXR1cm4gZ2V0KHVybCx7bW9kdWxlOlwicHJveHlcIixhY3Rpb246XCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsaGV4OnBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbixhcGlrZXk6dGhpcy5hcGlLZXl9KS5jYXRjaChlcnJvcj0+e3JldHVybiBjaGVja0Vycm9yJDEoXCJzZW5kVHJhbnNhY3Rpb25cIixlcnJvcixwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pfSk7Y2FzZVwiZ2V0QmxvY2tcIjppZihwYXJhbXMuYmxvY2tUYWcpe3VybCs9XCI/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0QmxvY2tCeU51bWJlciZ0YWc9XCIrcGFyYW1zLmJsb2NrVGFnO2lmKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zKXt1cmwrPVwiJmJvb2xlYW49dHJ1ZVwifWVsc2V7dXJsKz1cIiZib29sZWFuPWZhbHNlXCJ9dXJsKz1hcGlLZXk7cmV0dXJuIGdldCh1cmwsbnVsbCl9dGhyb3cgbmV3IEVycm9yKFwiZ2V0QmxvY2sgYnkgYmxvY2tIYXNoIG5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJnZXRUcmFuc2FjdGlvblwiOnVybCs9XCI/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gmdHhoYXNoPVwiK3BhcmFtcy50cmFuc2FjdGlvbkhhc2g7dXJsKz1hcGlLZXk7cmV0dXJuIGdldCh1cmwsbnVsbCk7Y2FzZVwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6dXJsKz1cIj9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQmdHhoYXNoPVwiK3BhcmFtcy50cmFuc2FjdGlvbkhhc2g7dXJsKz1hcGlLZXk7cmV0dXJuIGdldCh1cmwsbnVsbCk7Y2FzZVwiY2FsbFwiOntpZihwYXJhbXMuYmxvY2tUYWchPT1cImxhdGVzdFwiKXt0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcnNjYW5Qcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IGJsb2NrVGFnIGZvciBjYWxsXCIpfWNvbnN0IHBvc3REYXRhPWdldFRyYW5zYWN0aW9uUG9zdERhdGEocGFyYW1zLnRyYW5zYWN0aW9uKTtwb3N0RGF0YS5tb2R1bGU9XCJwcm94eVwiO3Bvc3REYXRhLmFjdGlvbj1cImV0aF9jYWxsXCI7cG9zdERhdGEuYXBpa2V5PXRoaXMuYXBpS2V5O3RyeXtyZXR1cm4geWllbGQgZ2V0KHVybCxwb3N0RGF0YSl9Y2F0Y2goZXJyb3Ipe3JldHVybiBjaGVja0Vycm9yJDEoXCJjYWxsXCIsZXJyb3IscGFyYW1zLnRyYW5zYWN0aW9uKX19Y2FzZVwiZXN0aW1hdGVHYXNcIjp7Y29uc3QgcG9zdERhdGE9Z2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShwYXJhbXMudHJhbnNhY3Rpb24pO3Bvc3REYXRhLm1vZHVsZT1cInByb3h5XCI7cG9zdERhdGEuYWN0aW9uPVwiZXRoX2VzdGltYXRlR2FzXCI7cG9zdERhdGEuYXBpa2V5PXRoaXMuYXBpS2V5O3RyeXtyZXR1cm4geWllbGQgZ2V0KHVybCxwb3N0RGF0YSl9Y2F0Y2goZXJyb3Ipe3JldHVybiBjaGVja0Vycm9yJDEoXCJlc3RpbWF0ZUdhc1wiLGVycm9yLHBhcmFtcy50cmFuc2FjdGlvbil9fWNhc2VcImdldExvZ3NcIjp7dXJsKz1cIj9tb2R1bGU9bG9ncyZhY3Rpb249Z2V0TG9nc1wiO2lmKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKXt1cmwrPVwiJmZyb21CbG9jaz1cIitjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLmZyb21CbG9jayl9aWYocGFyYW1zLmZpbHRlci50b0Jsb2NrKXt1cmwrPVwiJnRvQmxvY2s9XCIrY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci50b0Jsb2NrKX1pZihwYXJhbXMuZmlsdGVyLmFkZHJlc3Mpe3VybCs9XCImYWRkcmVzcz1cIitwYXJhbXMuZmlsdGVyLmFkZHJlc3N9aWYocGFyYW1zLmZpbHRlci50b3BpY3MmJnBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aD4wKXtpZihwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGg+MSl7bG9nZ2VyJHoudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGNvdW50XCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se3RvcGljczpwYXJhbXMuZmlsdGVyLnRvcGljc30pfWlmKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aD09PTEpe2NvbnN0IHRvcGljMD1wYXJhbXMuZmlsdGVyLnRvcGljc1swXTtpZih0eXBlb2YgdG9waWMwIT09XCJzdHJpbmdcInx8dG9waWMwLmxlbmd0aCE9PTY2KXtsb2dnZXIkei50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgZm9ybWF0XCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se3RvcGljMDp0b3BpYzB9KX11cmwrPVwiJnRvcGljMD1cIit0b3BpYzB9fXVybCs9YXBpS2V5O2NvbnN0IGxvZ3M9eWllbGQgZ2V0KHVybCxudWxsLGdldFJlc3VsdCQxKTtsZXQgYmxvY2tzPXt9O2ZvcihsZXQgaT0wO2k8bG9ncy5sZW5ndGg7aSsrKXtjb25zdCBsb2c9bG9nc1tpXTtpZihsb2cuYmxvY2tIYXNoIT1udWxsKXtjb250aW51ZX1pZihibG9ja3NbbG9nLmJsb2NrTnVtYmVyXT09bnVsbCl7Y29uc3QgYmxvY2s9eWllbGQgdGhpcy5nZXRCbG9jayhsb2cuYmxvY2tOdW1iZXIpO2lmKGJsb2NrKXtibG9ja3NbbG9nLmJsb2NrTnVtYmVyXT1ibG9jay5oYXNofX1sb2cuYmxvY2tIYXNoPWJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdfXJldHVybiBsb2dzfWNhc2VcImdldEV0aGVyUHJpY2VcIjppZih0aGlzLm5ldHdvcmsubmFtZSE9PVwiaG9tZXN0ZWFkXCIpe3JldHVybiAwfXVybCs9XCI/bW9kdWxlPXN0YXRzJmFjdGlvbj1ldGhwcmljZVwiO3VybCs9YXBpS2V5O3JldHVybiBwYXJzZUZsb2F0KCh5aWVsZCBnZXQodXJsLG51bGwsZ2V0UmVzdWx0JDEpKS5ldGh1c2QpO2RlZmF1bHQ6YnJlYWt9cmV0dXJuIF9zdXBlci5wZXJmb3JtLmNhbGwodGhpcyxtZXRob2QscGFyYW1zKX0pfWdldEhpc3RvcnkoYWRkcmVzc09yTmFtZSxzdGFydEJsb2NrLGVuZEJsb2NrKXtsZXQgdXJsPXRoaXMuYmFzZVVybDtsZXQgYXBpS2V5PVwiXCI7aWYodGhpcy5hcGlLZXkpe2FwaUtleSs9XCImYXBpa2V5PVwiK3RoaXMuYXBpS2V5fWlmKHN0YXJ0QmxvY2s9PW51bGwpe3N0YXJ0QmxvY2s9MH1pZihlbmRCbG9jaz09bnVsbCl7ZW5kQmxvY2s9OTk5OTk5OTl9cmV0dXJuIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSkudGhlbihhZGRyZXNzPT57dXJsKz1cIi9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPXR4bGlzdCZhZGRyZXNzPVwiK2FkZHJlc3M7dXJsKz1cIiZzdGFydGJsb2NrPVwiK3N0YXJ0QmxvY2s7dXJsKz1cIiZlbmRibG9jaz1cIitlbmRCbG9jazt1cmwrPVwiJnNvcnQ9YXNjXCIrYXBpS2V5O3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlcXVlc3RcIixyZXF1ZXN0OnVybCxwcm92aWRlcjp0aGlzfSk7Y29uc3QgY29ubmVjdGlvbj17dXJsOnVybCx0aHJvdHRsZVNsb3RJbnRlcnZhbDoxZTMsdGhyb3R0bGVDYWxsYmFjazooYXR0ZW1wdCx1cmwpPT57aWYodGhpcy5hcGlLZXk9PT1kZWZhdWx0QXBpS2V5JDEpe3Nob3dUaHJvdHRsZU1lc3NhZ2UoKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpfX07cmV0dXJuIGZldGNoSnNvbihjb25uZWN0aW9uLG51bGwsZ2V0UmVzdWx0JDEpLnRoZW4ocmVzdWx0PT57dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVzcG9uc2VcIixyZXF1ZXN0OnVybCxyZXNwb25zZTpkZWVwQ29weShyZXN1bHQpLHByb3ZpZGVyOnRoaXN9KTtsZXQgb3V0cHV0PVtdO3Jlc3VsdC5mb3JFYWNoKHR4PT57W1wiY29udHJhY3RBZGRyZXNzXCIsXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7aWYodHhba2V5XT09XCJcIil7ZGVsZXRlIHR4W2tleV19fSk7aWYodHguY3JlYXRlcz09bnVsbCYmdHguY29udHJhY3RBZGRyZXNzIT1udWxsKXt0eC5jcmVhdGVzPXR4LmNvbnRyYWN0QWRkcmVzc31sZXQgaXRlbT10aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHR4KTtpZih0eC50aW1lU3RhbXApe2l0ZW0udGltZXN0YW1wPXBhcnNlSW50KHR4LnRpbWVTdGFtcCl9b3V0cHV0LnB1c2goaXRlbSl9KTtyZXR1cm4gb3V0cHV0fSl9KX1pc0NvbW11bml0eVJlc291cmNlKCl7cmV0dXJuIHRoaXMuYXBpS2V5PT09ZGVmYXVsdEFwaUtleSQxfX1cInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyJGU9d2luZG93JiZ3aW5kb3cuX19hd2FpdGVyfHxmdW5jdGlvbih0aGlzQXJnLF9hcmd1bWVudHMsUCxnZW5lcmF0b3Ipe2Z1bmN0aW9uIGFkb3B0KHZhbHVlKXtyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQP3ZhbHVlOm5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpe3Jlc29sdmUodmFsdWUpfSl9cmV0dXJuIG5ldyhQfHwoUD1Qcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2Z1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gc3RlcChyZXN1bHQpe3Jlc3VsdC5kb25lP3Jlc29sdmUocmVzdWx0LnZhbHVlKTphZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChnZW5lcmF0b3I9Z2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsX2FyZ3VtZW50c3x8W10pKS5uZXh0KCkpfSl9O2NvbnN0IGxvZ2dlciRBPW5ldyBMb2dnZXIodmVyc2lvbiRtKTtmdW5jdGlvbiBub3coKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX1mdW5jdGlvbiBjaGVja05ldHdvcmtzKG5ldHdvcmtzKXtsZXQgcmVzdWx0PW51bGw7Zm9yKGxldCBpPTA7aTxuZXR3b3Jrcy5sZW5ndGg7aSsrKXtjb25zdCBuZXR3b3JrPW5ldHdvcmtzW2ldO2lmKG5ldHdvcms9PW51bGwpe3JldHVybiBudWxsfWlmKHJlc3VsdCl7aWYoIShyZXN1bHQubmFtZT09PW5ldHdvcmsubmFtZSYmcmVzdWx0LmNoYWluSWQ9PT1uZXR3b3JrLmNoYWluSWQmJihyZXN1bHQuZW5zQWRkcmVzcz09PW5ldHdvcmsuZW5zQWRkcmVzc3x8cmVzdWx0LmVuc0FkZHJlc3M9PW51bGwmJm5ldHdvcmsuZW5zQWRkcmVzcz09bnVsbCkpKXtsb2dnZXIkQS50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlciBtaXNtYXRjaFwiLFwibmV0d29ya3NcIixuZXR3b3Jrcyl9fWVsc2V7cmVzdWx0PW5ldHdvcmt9fXJldHVybiByZXN1bHR9ZnVuY3Rpb24gbWVkaWFuKHZhbHVlcyxtYXhEZWx0YSl7dmFsdWVzPXZhbHVlcy5zbGljZSgpLnNvcnQoKTtjb25zdCBtaWRkbGU9TWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoLzIpO2lmKHZhbHVlcy5sZW5ndGglMil7cmV0dXJuIHZhbHVlc1ttaWRkbGVdfWNvbnN0IGE9dmFsdWVzW21pZGRsZS0xXSxiPXZhbHVlc1ttaWRkbGVdO2lmKG1heERlbHRhIT1udWxsJiZNYXRoLmFicyhhLWIpPm1heERlbHRhKXtyZXR1cm4gbnVsbH1yZXR1cm4oYStiKS8yfWZ1bmN0aW9uIHNlcmlhbGl6ZSQxKHZhbHVlKXtpZih2YWx1ZT09PW51bGwpe3JldHVyblwibnVsbFwifWVsc2UgaWYodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcInx8dHlwZW9mIHZhbHVlPT09XCJib29sZWFuXCIpe3JldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSl9ZWxzZSBpZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtyZXR1cm4gdmFsdWV9ZWxzZSBpZihCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpKXtyZXR1cm4gdmFsdWUudG9TdHJpbmcoKX1lbHNlIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUubWFwKGk9PnNlcmlhbGl6ZSQxKGkpKSl9ZWxzZSBpZih0eXBlb2YgdmFsdWU9PT1cIm9iamVjdFwiKXtjb25zdCBrZXlzPU9iamVjdC5rZXlzKHZhbHVlKTtrZXlzLnNvcnQoKTtyZXR1cm5cIntcIitrZXlzLm1hcChrZXk9PntsZXQgdj12YWx1ZVtrZXldO2lmKHR5cGVvZiB2PT09XCJmdW5jdGlvblwiKXt2PVwiW2Z1bmN0aW9uXVwifWVsc2V7dj1zZXJpYWxpemUkMSh2KX1yZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KStcIjpcIit2fSkuam9pbihcIixcIikrXCJ9XCJ9dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZSB0eXBlOiBcIit0eXBlb2YgdmFsdWUpfWxldCBuZXh0UmlkPTE7ZnVuY3Rpb24gc3RhbGwkMShkdXJhdGlvbil7bGV0IGNhbmNlbD1udWxsO2xldCB0aW1lcj1udWxsO2xldCBwcm9taXNlPW5ldyBQcm9taXNlKHJlc29sdmU9PntjYW5jZWw9ZnVuY3Rpb24oKXtpZih0aW1lcil7Y2xlYXJUaW1lb3V0KHRpbWVyKTt0aW1lcj1udWxsfXJlc29sdmUoKX07dGltZXI9c2V0VGltZW91dChjYW5jZWwsZHVyYXRpb24pfSk7Y29uc3Qgd2FpdD1mdW5jPT57cHJvbWlzZT1wcm9taXNlLnRoZW4oZnVuYyk7cmV0dXJuIHByb21pc2V9O2Z1bmN0aW9uIGdldFByb21pc2UoKXtyZXR1cm4gcHJvbWlzZX1yZXR1cm57Y2FuY2VsOmNhbmNlbCxnZXRQcm9taXNlOmdldFByb21pc2Usd2FpdDp3YWl0fX1jb25zdCBGb3J3YXJkRXJyb3JzPVtMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLExvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCxMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVRdO2NvbnN0IEZvcndhcmRQcm9wZXJ0aWVzPVtcImFkZHJlc3NcIixcImFyZ3NcIixcImVycm9yQXJnc1wiLFwiZXJyb3JTaWduYXR1cmVcIixcIm1ldGhvZFwiLFwidHJhbnNhY3Rpb25cIl07ZnVuY3Rpb24gZXhwb3NlRGVidWdDb25maWcoY29uZmlnLG5vdyl7Y29uc3QgcmVzdWx0PXt3ZWlnaHQ6Y29uZmlnLndlaWdodH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCxcInByb3ZpZGVyXCIse2dldDooKT0+Y29uZmlnLnByb3ZpZGVyfSk7aWYoY29uZmlnLnN0YXJ0KXtyZXN1bHQuc3RhcnQ9Y29uZmlnLnN0YXJ0fWlmKG5vdyl7cmVzdWx0LmR1cmF0aW9uPW5vdy1jb25maWcuc3RhcnR9aWYoY29uZmlnLmRvbmUpe2lmKGNvbmZpZy5lcnJvcil7cmVzdWx0LmVycm9yPWNvbmZpZy5lcnJvcn1lbHNle3Jlc3VsdC5yZXN1bHQ9Y29uZmlnLnJlc3VsdHx8bnVsbH19cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLHF1b3J1bSl7cmV0dXJuIGZ1bmN0aW9uKGNvbmZpZ3Mpe2NvbnN0IHRhbGx5PXt9O2NvbmZpZ3MuZm9yRWFjaChjPT57Y29uc3QgdmFsdWU9bm9ybWFsaXplKGMucmVzdWx0KTtpZighdGFsbHlbdmFsdWVdKXt0YWxseVt2YWx1ZV09e2NvdW50OjAscmVzdWx0OmMucmVzdWx0fX10YWxseVt2YWx1ZV0uY291bnQrK30pO2NvbnN0IGtleXM9T2JqZWN0LmtleXModGFsbHkpO2ZvcihsZXQgaT0wO2k8a2V5cy5sZW5ndGg7aSsrKXtjb25zdCBjaGVjaz10YWxseVtrZXlzW2ldXTtpZihjaGVjay5jb3VudD49cXVvcnVtKXtyZXR1cm4gY2hlY2sucmVzdWx0fX1yZXR1cm4gdW5kZWZpbmVkfX1mdW5jdGlvbiBnZXRQcm9jZXNzRnVuYyhwcm92aWRlcixtZXRob2QscGFyYW1zKXtsZXQgbm9ybWFsaXplPXNlcmlhbGl6ZSQxO3N3aXRjaChtZXRob2Qpe2Nhc2VcImdldEJsb2NrTnVtYmVyXCI6cmV0dXJuIGZ1bmN0aW9uKGNvbmZpZ3Mpe2NvbnN0IHZhbHVlcz1jb25maWdzLm1hcChjPT5jLnJlc3VsdCk7bGV0IGJsb2NrTnVtYmVyPW1lZGlhbihjb25maWdzLm1hcChjPT5jLnJlc3VsdCksMik7aWYoYmxvY2tOdW1iZXI9PW51bGwpe3JldHVybiB1bmRlZmluZWR9YmxvY2tOdW1iZXI9TWF0aC5jZWlsKGJsb2NrTnVtYmVyKTtpZih2YWx1ZXMuaW5kZXhPZihibG9ja051bWJlcisxKT49MCl7YmxvY2tOdW1iZXIrK31pZihibG9ja051bWJlcj49cHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcil7cHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcj1ibG9ja051bWJlcn1yZXR1cm4gcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcn07Y2FzZVwiZ2V0R2FzUHJpY2VcIjpyZXR1cm4gZnVuY3Rpb24oY29uZmlncyl7Y29uc3QgdmFsdWVzPWNvbmZpZ3MubWFwKGM9PmMucmVzdWx0KTt2YWx1ZXMuc29ydCgpO3JldHVybiB2YWx1ZXNbTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoLzIpXX07Y2FzZVwiZ2V0RXRoZXJQcmljZVwiOnJldHVybiBmdW5jdGlvbihjb25maWdzKXtyZXR1cm4gbWVkaWFuKGNvbmZpZ3MubWFwKGM9PmMucmVzdWx0KSl9O2Nhc2VcImdldEJhbGFuY2VcIjpjYXNlXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6Y2FzZVwiZ2V0Q29kZVwiOmNhc2VcImdldFN0b3JhZ2VBdFwiOmNhc2VcImNhbGxcIjpjYXNlXCJlc3RpbWF0ZUdhc1wiOmNhc2VcImdldExvZ3NcIjpicmVhaztjYXNlXCJnZXRUcmFuc2FjdGlvblwiOmNhc2VcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOm5vcm1hbGl6ZT1mdW5jdGlvbih0eCl7aWYodHg9PW51bGwpe3JldHVybiBudWxsfXR4PXNoYWxsb3dDb3B5KHR4KTt0eC5jb25maXJtYXRpb25zPS0xO3JldHVybiBzZXJpYWxpemUkMSh0eCl9O2JyZWFrO2Nhc2VcImdldEJsb2NrXCI6aWYocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMpe25vcm1hbGl6ZT1mdW5jdGlvbihibG9jayl7aWYoYmxvY2s9PW51bGwpe3JldHVybiBudWxsfWJsb2NrPXNoYWxsb3dDb3B5KGJsb2NrKTtibG9jay50cmFuc2FjdGlvbnM9YmxvY2sudHJhbnNhY3Rpb25zLm1hcCh0eD0+e3R4PXNoYWxsb3dDb3B5KHR4KTt0eC5jb25maXJtYXRpb25zPS0xO3JldHVybiB0eH0pO3JldHVybiBzZXJpYWxpemUkMShibG9jayl9fWVsc2V7bm9ybWFsaXplPWZ1bmN0aW9uKGJsb2NrKXtpZihibG9jaz09bnVsbCl7cmV0dXJuIG51bGx9cmV0dXJuIHNlcmlhbGl6ZSQxKGJsb2NrKX19YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG1ldGhvZDogXCIrbWV0aG9kKX1yZXR1cm4gbm9ybWFsaXplZFRhbGx5KG5vcm1hbGl6ZSxwcm92aWRlci5xdW9ydW0pfWZ1bmN0aW9uIHdhaXRGb3JTeW5jKGNvbmZpZyxibG9ja051bWJlcil7cmV0dXJuIF9fYXdhaXRlciRlKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBwcm92aWRlcj1jb25maWcucHJvdmlkZXI7aWYocHJvdmlkZXIuYmxvY2tOdW1iZXIhPW51bGwmJnByb3ZpZGVyLmJsb2NrTnVtYmVyPj1ibG9ja051bWJlcnx8YmxvY2tOdW1iZXI9PT0tMSl7cmV0dXJuIHByb3ZpZGVyfXJldHVybiBwb2xsKCgpPT57cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYocHJvdmlkZXIuYmxvY2tOdW1iZXI+PWJsb2NrTnVtYmVyKXtyZXR1cm4gcmVzb2x2ZShwcm92aWRlcil9aWYoY29uZmlnLmNhbmNlbGxlZCl7cmV0dXJuIHJlc29sdmUobnVsbCl9cmV0dXJuIHJlc29sdmUodW5kZWZpbmVkKX0sMCl9KX0se29uY2VQb2xsOnByb3ZpZGVyfSl9KX1mdW5jdGlvbiBnZXRSdW5uZXIoY29uZmlnLGN1cnJlbnRCbG9ja051bWJlcixtZXRob2QscGFyYW1zKXtyZXR1cm4gX19hd2FpdGVyJGUodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2xldCBwcm92aWRlcj1jb25maWcucHJvdmlkZXI7c3dpdGNoKG1ldGhvZCl7Y2FzZVwiZ2V0QmxvY2tOdW1iZXJcIjpjYXNlXCJnZXRHYXNQcmljZVwiOnJldHVybiBwcm92aWRlclttZXRob2RdKCk7Y2FzZVwiZ2V0RXRoZXJQcmljZVwiOmlmKHByb3ZpZGVyLmdldEV0aGVyUHJpY2Upe3JldHVybiBwcm92aWRlci5nZXRFdGhlclByaWNlKCl9YnJlYWs7Y2FzZVwiZ2V0QmFsYW5jZVwiOmNhc2VcImdldFRyYW5zYWN0aW9uQ291bnRcIjpjYXNlXCJnZXRDb2RlXCI6aWYocGFyYW1zLmJsb2NrVGFnJiZpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKXtwcm92aWRlcj15aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsY3VycmVudEJsb2NrTnVtYmVyKX1yZXR1cm4gcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMuYWRkcmVzcyxwYXJhbXMuYmxvY2tUYWd8fFwibGF0ZXN0XCIpO2Nhc2VcImdldFN0b3JhZ2VBdFwiOmlmKHBhcmFtcy5ibG9ja1RhZyYmaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSl7cHJvdmlkZXI9eWllbGQgd2FpdEZvclN5bmMoY29uZmlnLGN1cnJlbnRCbG9ja051bWJlcil9cmV0dXJuIHByb3ZpZGVyLmdldFN0b3JhZ2VBdChwYXJhbXMuYWRkcmVzcyxwYXJhbXMucG9zaXRpb24scGFyYW1zLmJsb2NrVGFnfHxcImxhdGVzdFwiKTtjYXNlXCJnZXRCbG9ja1wiOmlmKHBhcmFtcy5ibG9ja1RhZyYmaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSl7cHJvdmlkZXI9eWllbGQgd2FpdEZvclN5bmMoY29uZmlnLGN1cnJlbnRCbG9ja051bWJlcil9cmV0dXJuIHByb3ZpZGVyW3BhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zP1wiZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zXCI6XCJnZXRCbG9ja1wiXShwYXJhbXMuYmxvY2tUYWd8fHBhcmFtcy5ibG9ja0hhc2gpO2Nhc2VcImNhbGxcIjpjYXNlXCJlc3RpbWF0ZUdhc1wiOmlmKHBhcmFtcy5ibG9ja1RhZyYmaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSl7cHJvdmlkZXI9eWllbGQgd2FpdEZvclN5bmMoY29uZmlnLGN1cnJlbnRCbG9ja051bWJlcil9cmV0dXJuIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLnRyYW5zYWN0aW9uKTtjYXNlXCJnZXRUcmFuc2FjdGlvblwiOmNhc2VcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOnJldHVybiBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbkhhc2gpO2Nhc2VcImdldExvZ3NcIjp7bGV0IGZpbHRlcj1wYXJhbXMuZmlsdGVyO2lmKGZpbHRlci5mcm9tQmxvY2smJmlzSGV4U3RyaW5nKGZpbHRlci5mcm9tQmxvY2spfHxmaWx0ZXIudG9CbG9jayYmaXNIZXhTdHJpbmcoZmlsdGVyLnRvQmxvY2spKXtwcm92aWRlcj15aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsY3VycmVudEJsb2NrTnVtYmVyKX1yZXR1cm4gcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpfX1yZXR1cm4gbG9nZ2VyJEEudGhyb3dFcnJvcihcInVua25vd24gbWV0aG9kIGVycm9yXCIsTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLHttZXRob2Q6bWV0aG9kLHBhcmFtczpwYXJhbXN9KX0pfWNsYXNzIEZhbGxiYWNrUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXJ7Y29uc3RydWN0b3IocHJvdmlkZXJzLHF1b3J1bSl7bG9nZ2VyJEEuY2hlY2tOZXcobmV3LnRhcmdldCxGYWxsYmFja1Byb3ZpZGVyKTtpZihwcm92aWRlcnMubGVuZ3RoPT09MCl7bG9nZ2VyJEEudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcm92aWRlcnNcIixcInByb3ZpZGVyc1wiLHByb3ZpZGVycyl9Y29uc3QgcHJvdmlkZXJDb25maWdzPXByb3ZpZGVycy5tYXAoKGNvbmZpZ09yUHJvdmlkZXIsaW5kZXgpPT57aWYoUHJvdmlkZXIuaXNQcm92aWRlcihjb25maWdPclByb3ZpZGVyKSl7Y29uc3Qgc3RhbGxUaW1lb3V0PWlzQ29tbXVuaXR5UmVzb3VyY2UoY29uZmlnT3JQcm92aWRlcik/MmUzOjc1MDtjb25zdCBwcmlvcml0eT0xO3JldHVybiBPYmplY3QuZnJlZXplKHtwcm92aWRlcjpjb25maWdPclByb3ZpZGVyLHdlaWdodDoxLHN0YWxsVGltZW91dDpzdGFsbFRpbWVvdXQscHJpb3JpdHk6cHJpb3JpdHl9KX1jb25zdCBjb25maWc9c2hhbGxvd0NvcHkoY29uZmlnT3JQcm92aWRlcik7aWYoY29uZmlnLnByaW9yaXR5PT1udWxsKXtjb25maWcucHJpb3JpdHk9MX1pZihjb25maWcuc3RhbGxUaW1lb3V0PT1udWxsKXtjb25maWcuc3RhbGxUaW1lb3V0PWlzQ29tbXVuaXR5UmVzb3VyY2UoY29uZmlnT3JQcm92aWRlcik/MmUzOjc1MH1pZihjb25maWcud2VpZ2h0PT1udWxsKXtjb25maWcud2VpZ2h0PTF9Y29uc3Qgd2VpZ2h0PWNvbmZpZy53ZWlnaHQ7aWYod2VpZ2h0JTF8fHdlaWdodD41MTJ8fHdlaWdodDwxKXtsb2dnZXIkQS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHdlaWdodDsgbXVzdCBiZSBpbnRlZ2VyIGluIFsxLCA1MTJdXCIsYHByb3ZpZGVyc1ske2luZGV4fV0ud2VpZ2h0YCx3ZWlnaHQpfXJldHVybiBPYmplY3QuZnJlZXplKGNvbmZpZyl9KTtjb25zdCB0b3RhbD1wcm92aWRlckNvbmZpZ3MucmVkdWNlKChhY2N1bSxjKT0+YWNjdW0rYy53ZWlnaHQsMCk7aWYocXVvcnVtPT1udWxsKXtxdW9ydW09dG90YWwvMn1lbHNlIGlmKHF1b3J1bT50b3RhbCl7bG9nZ2VyJEEudGhyb3dBcmd1bWVudEVycm9yKFwicXVvcnVtIHdpbGwgYWx3YXlzIGZhaWw7IGxhcmdlciB0aGFuIHRvdGFsIHdlaWdodFwiLFwicXVvcnVtXCIscXVvcnVtKX1sZXQgbmV0d29ya09yUmVhZHk9Y2hlY2tOZXR3b3Jrcyhwcm92aWRlckNvbmZpZ3MubWFwKGM9PmMucHJvdmlkZXIubmV0d29yaykpO2lmKG5ldHdvcmtPclJlYWR5PT1udWxsKXtuZXR3b3JrT3JSZWFkeT1uZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpPT57c2V0VGltZW91dCgoKT0+e3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4ocmVzb2x2ZSxyZWplY3QpfSwwKX0pfXN1cGVyKG5ldHdvcmtPclJlYWR5KTtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJvdmlkZXJDb25maWdzXCIsT2JqZWN0LmZyZWV6ZShwcm92aWRlckNvbmZpZ3MpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwicXVvcnVtXCIscXVvcnVtKTt0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXI9LTF9ZGV0ZWN0TmV0d29yaygpe3JldHVybiBfX2F3YWl0ZXIkZSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgbmV0d29ya3M9eWllbGQgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKGM9PmMucHJvdmlkZXIuZ2V0TmV0d29yaygpKSk7cmV0dXJuIGNoZWNrTmV0d29ya3MobmV0d29ya3MpfSl9cGVyZm9ybShtZXRob2QscGFyYW1zKXtyZXR1cm4gX19hd2FpdGVyJGUodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2lmKG1ldGhvZD09PVwic2VuZFRyYW5zYWN0aW9uXCIpe2NvbnN0IHJlc3VsdHM9eWllbGQgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKGM9PntyZXR1cm4gYy5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24ocGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKHJlc3VsdD0+e3JldHVybiByZXN1bHQuaGFzaH0sZXJyb3I9PntyZXR1cm4gZXJyb3J9KX0pKTtmb3IobGV0IGk9MDtpPHJlc3VsdHMubGVuZ3RoO2krKyl7Y29uc3QgcmVzdWx0PXJlc3VsdHNbaV07aWYodHlwZW9mIHJlc3VsdD09PVwic3RyaW5nXCIpe3JldHVybiByZXN1bHR9fXRocm93IHJlc3VsdHNbMF19aWYodGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyPT09LTEmJm1ldGhvZCE9PVwiZ2V0QmxvY2tOdW1iZXJcIil7eWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpfWNvbnN0IHByb2Nlc3NGdW5jPWdldFByb2Nlc3NGdW5jKHRoaXMsbWV0aG9kLHBhcmFtcyk7Y29uc3QgY29uZmlncz1zaHVmZmxlZCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoc2hhbGxvd0NvcHkpKTtjb25maWdzLnNvcnQoKGEsYik9PmEucHJpb3JpdHktYi5wcmlvcml0eSk7Y29uc3QgY3VycmVudEJsb2NrTnVtYmVyPXRoaXMuX2hpZ2hlc3RCbG9ja051bWJlcjtsZXQgaT0wO2xldCBmaXJzdD10cnVlO3doaWxlKHRydWUpe2NvbnN0IHQwPW5vdygpO2xldCBpbmZsaWdodFdlaWdodD1jb25maWdzLmZpbHRlcihjPT5jLnJ1bm5lciYmdDAtYy5zdGFydDxjLnN0YWxsVGltZW91dCkucmVkdWNlKChhY2N1bSxjKT0+YWNjdW0rYy53ZWlnaHQsMCk7d2hpbGUoaW5mbGlnaHRXZWlnaHQ8dGhpcy5xdW9ydW0mJmk8Y29uZmlncy5sZW5ndGgpe2NvbnN0IGNvbmZpZz1jb25maWdzW2krK107Y29uc3QgcmlkPW5leHRSaWQrKztjb25maWcuc3RhcnQ9bm93KCk7Y29uZmlnLnN0YWxsZXI9c3RhbGwkMShjb25maWcuc3RhbGxUaW1lb3V0KTtjb25maWcuc3RhbGxlci53YWl0KCgpPT57Y29uZmlnLnN0YWxsZXI9bnVsbH0pO2NvbmZpZy5ydW5uZXI9Z2V0UnVubmVyKGNvbmZpZyxjdXJyZW50QmxvY2tOdW1iZXIsbWV0aG9kLHBhcmFtcykudGhlbihyZXN1bHQ9Pntjb25maWcuZG9uZT10cnVlO2NvbmZpZy5yZXN1bHQ9cmVzdWx0O2lmKHRoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKXt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXF1ZXN0XCIscmlkOnJpZCxiYWNrZW5kOmV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZyxub3coKSkscmVxdWVzdDp7bWV0aG9kOm1ldGhvZCxwYXJhbXM6ZGVlcENvcHkocGFyYW1zKX0scHJvdmlkZXI6dGhpc30pfX0sZXJyb3I9Pntjb25maWcuZG9uZT10cnVlO2NvbmZpZy5lcnJvcj1lcnJvcjtpZih0aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSl7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVxdWVzdFwiLHJpZDpyaWQsYmFja2VuZDpleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsbm93KCkpLHJlcXVlc3Q6e21ldGhvZDptZXRob2QscGFyYW1zOmRlZXBDb3B5KHBhcmFtcyl9LHByb3ZpZGVyOnRoaXN9KX19KTtpZih0aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSl7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVxdWVzdFwiLHJpZDpyaWQsYmFja2VuZDpleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsbnVsbCkscmVxdWVzdDp7bWV0aG9kOm1ldGhvZCxwYXJhbXM6ZGVlcENvcHkocGFyYW1zKX0scHJvdmlkZXI6dGhpc30pfWluZmxpZ2h0V2VpZ2h0Kz1jb25maWcud2VpZ2h0fWNvbnN0IHdhaXRpbmc9W107Y29uZmlncy5mb3JFYWNoKGM9PntpZihjLmRvbmV8fCFjLnJ1bm5lcil7cmV0dXJufXdhaXRpbmcucHVzaChjLnJ1bm5lcik7aWYoYy5zdGFsbGVyKXt3YWl0aW5nLnB1c2goYy5zdGFsbGVyLmdldFByb21pc2UoKSl9fSk7aWYod2FpdGluZy5sZW5ndGgpe3lpZWxkIFByb21pc2UucmFjZSh3YWl0aW5nKX1jb25zdCByZXN1bHRzPWNvbmZpZ3MuZmlsdGVyKGM9PmMuZG9uZSYmYy5lcnJvcj09bnVsbCk7aWYocmVzdWx0cy5sZW5ndGg+PXRoaXMucXVvcnVtKXtjb25zdCByZXN1bHQ9cHJvY2Vzc0Z1bmMocmVzdWx0cyk7aWYocmVzdWx0IT09dW5kZWZpbmVkKXtjb25maWdzLmZvckVhY2goYz0+e2lmKGMuc3RhbGxlcil7Yy5zdGFsbGVyLmNhbmNlbCgpfWMuY2FuY2VsbGVkPXRydWV9KTtyZXR1cm4gcmVzdWx0fWlmKCFmaXJzdCl7eWllbGQgc3RhbGwkMSgxMDApLmdldFByb21pc2UoKX1maXJzdD1mYWxzZX1jb25zdCBlcnJvcnM9Y29uZmlncy5yZWR1Y2UoKGFjY3VtLGMpPT57aWYoIWMuZG9uZXx8Yy5lcnJvcj09bnVsbCl7cmV0dXJuIGFjY3VtfWNvbnN0IGNvZGU9Yy5lcnJvci5jb2RlO2lmKEZvcndhcmRFcnJvcnMuaW5kZXhPZihjb2RlKT49MCl7aWYoIWFjY3VtW2NvZGVdKXthY2N1bVtjb2RlXT17ZXJyb3I6Yy5lcnJvcix3ZWlnaHQ6MH19YWNjdW1bY29kZV0ud2VpZ2h0Kz1jLndlaWdodH1yZXR1cm4gYWNjdW19LHt9KTtPYmplY3Qua2V5cyhlcnJvcnMpLmZvckVhY2goZXJyb3JDb2RlPT57Y29uc3QgdGFsbHk9ZXJyb3JzW2Vycm9yQ29kZV07aWYodGFsbHkud2VpZ2h0PHRoaXMucXVvcnVtKXtyZXR1cm59Y29uZmlncy5mb3JFYWNoKGM9PntpZihjLnN0YWxsZXIpe2Muc3RhbGxlci5jYW5jZWwoKX1jLmNhbmNlbGxlZD10cnVlfSk7Y29uc3QgZT10YWxseS5lcnJvcjtjb25zdCBwcm9wcz17fTtGb3J3YXJkUHJvcGVydGllcy5mb3JFYWNoKG5hbWU9PntpZihlW25hbWVdPT1udWxsKXtyZXR1cm59cHJvcHNbbmFtZV09ZVtuYW1lXX0pO2xvZ2dlciRBLnRocm93RXJyb3IoZS5yZWFzb258fGUubWVzc2FnZSxlcnJvckNvZGUscHJvcHMpfSk7aWYoY29uZmlncy5maWx0ZXIoYz0+IWMuZG9uZSkubGVuZ3RoPT09MCl7YnJlYWt9fWNvbmZpZ3MuZm9yRWFjaChjPT57aWYoYy5zdGFsbGVyKXtjLnN0YWxsZXIuY2FuY2VsKCl9Yy5jYW5jZWxsZWQ9dHJ1ZX0pO3JldHVybiBsb2dnZXIkQS50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIG1lZXQgcXVvcnVtXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise21ldGhvZDptZXRob2QscGFyYW1zOnBhcmFtcyxyZXN1bHRzOmNvbmZpZ3MubWFwKGM9PmV4cG9zZURlYnVnQ29uZmlnKGMpKSxwcm92aWRlcjp0aGlzfSl9KX19XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgSXBjUHJvdmlkZXI9bnVsbDtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkQj1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7Y29uc3QgZGVmYXVsdFByb2plY3RJZD1cIjg0ODQyMDc4YjA5OTQ2NjM4YzAzMTU3ZjgzNDA1MjEzXCI7Y2xhc3MgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBXZWJTb2NrZXRQcm92aWRlcntjb25zdHJ1Y3RvcihuZXR3b3JrLGFwaUtleSl7Y29uc3QgcHJvdmlkZXI9bmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssYXBpS2V5KTtjb25zdCBjb25uZWN0aW9uPXByb3ZpZGVyLmNvbm5lY3Rpb247aWYoY29ubmVjdGlvbi5wYXNzd29yZCl7bG9nZ2VyJEIudGhyb3dFcnJvcihcIklORlVSQSBXZWJTb2NrZXQgcHJvamVjdCBzZWNyZXRzIHVuc3VwcG9ydGVkXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIkluZnVyYVByb3ZpZGVyLmdldFdlYlNvY2tldFByb3ZpZGVyKClcIn0pfWNvbnN0IHVybD1jb25uZWN0aW9uLnVybC5yZXBsYWNlKC9eaHR0cC9pLFwid3NcIikucmVwbGFjZShcIi92My9cIixcIi93cy92My9cIik7c3VwZXIodXJsLG5ldHdvcmspO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhcGlLZXlcIixwcm92aWRlci5wcm9qZWN0SWQpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm9qZWN0SWRcIixwcm92aWRlci5wcm9qZWN0SWQpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm9qZWN0U2VjcmV0XCIscHJvdmlkZXIucHJvamVjdFNlY3JldCl9aXNDb21tdW5pdHlSZXNvdXJjZSgpe3JldHVybiB0aGlzLnByb2plY3RJZD09PWRlZmF1bHRQcm9qZWN0SWR9fWNsYXNzIEluZnVyYVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVye3N0YXRpYyBnZXRXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLGFwaUtleSl7cmV0dXJuIG5ldyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLGFwaUtleSl9c3RhdGljIGdldEFwaUtleShhcGlLZXkpe2NvbnN0IGFwaUtleU9iaj17YXBpS2V5OmRlZmF1bHRQcm9qZWN0SWQscHJvamVjdElkOmRlZmF1bHRQcm9qZWN0SWQscHJvamVjdFNlY3JldDpudWxsfTtpZihhcGlLZXk9PW51bGwpe3JldHVybiBhcGlLZXlPYmp9aWYodHlwZW9mIGFwaUtleT09PVwic3RyaW5nXCIpe2FwaUtleU9iai5wcm9qZWN0SWQ9YXBpS2V5fWVsc2UgaWYoYXBpS2V5LnByb2plY3RTZWNyZXQhPW51bGwpe2xvZ2dlciRCLmFzc2VydEFyZ3VtZW50KHR5cGVvZiBhcGlLZXkucHJvamVjdElkPT09XCJzdHJpbmdcIixcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIixcInByb2plY3RJZFwiLGFwaUtleS5wcm9qZWN0SWQpO2xvZ2dlciRCLmFzc2VydEFyZ3VtZW50KHR5cGVvZiBhcGlLZXkucHJvamVjdFNlY3JldD09PVwic3RyaW5nXCIsXCJpbnZhbGlkIHByb2plY3RTZWNyZXRcIixcInByb2plY3RTZWNyZXRcIixcIltSRURBQ1RFRF1cIik7YXBpS2V5T2JqLnByb2plY3RJZD1hcGlLZXkucHJvamVjdElkO2FwaUtleU9iai5wcm9qZWN0U2VjcmV0PWFwaUtleS5wcm9qZWN0U2VjcmV0fWVsc2UgaWYoYXBpS2V5LnByb2plY3RJZCl7YXBpS2V5T2JqLnByb2plY3RJZD1hcGlLZXkucHJvamVjdElkfWFwaUtleU9iai5hcGlLZXk9YXBpS2V5T2JqLnByb2plY3RJZDtyZXR1cm4gYXBpS2V5T2JqfXN0YXRpYyBnZXRVcmwobmV0d29yayxhcGlLZXkpe2xldCBob3N0PW51bGw7c3dpdGNoKG5ldHdvcms/bmV0d29yay5uYW1lOlwidW5rbm93blwiKXtjYXNlXCJob21lc3RlYWRcIjpob3N0PVwibWFpbm5ldC5pbmZ1cmEuaW9cIjticmVhaztjYXNlXCJyb3BzdGVuXCI6aG9zdD1cInJvcHN0ZW4uaW5mdXJhLmlvXCI7YnJlYWs7Y2FzZVwicmlua2VieVwiOmhvc3Q9XCJyaW5rZWJ5LmluZnVyYS5pb1wiO2JyZWFrO2Nhc2VcImtvdmFuXCI6aG9zdD1cImtvdmFuLmluZnVyYS5pb1wiO2JyZWFrO2Nhc2VcImdvZXJsaVwiOmhvc3Q9XCJnb2VybGkuaW5mdXJhLmlvXCI7YnJlYWs7ZGVmYXVsdDpsb2dnZXIkQi50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJuZXR3b3JrXCIsdmFsdWU6bmV0d29ya30pfWNvbnN0IGNvbm5lY3Rpb249e2FsbG93R3ppcDp0cnVlLHVybDpcImh0dHBzOi9cIitcIi9cIitob3N0K1wiL3YzL1wiK2FwaUtleS5wcm9qZWN0SWQsdGhyb3R0bGVDYWxsYmFjazooYXR0ZW1wdCx1cmwpPT57aWYoYXBpS2V5LnByb2plY3RJZD09PWRlZmF1bHRQcm9qZWN0SWQpe3Nob3dUaHJvdHRsZU1lc3NhZ2UoKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpfX07aWYoYXBpS2V5LnByb2plY3RTZWNyZXQhPW51bGwpe2Nvbm5lY3Rpb24udXNlcj1cIlwiO2Nvbm5lY3Rpb24ucGFzc3dvcmQ9YXBpS2V5LnByb2plY3RTZWNyZXR9cmV0dXJuIGNvbm5lY3Rpb259aXNDb21tdW5pdHlSZXNvdXJjZSgpe3JldHVybiB0aGlzLnByb2plY3RJZD09PWRlZmF1bHRQcm9qZWN0SWR9fWNsYXNzIEpzb25ScGNCYXRjaFByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVye3NlbmQobWV0aG9kLHBhcmFtcyl7Y29uc3QgcmVxdWVzdD17bWV0aG9kOm1ldGhvZCxwYXJhbXM6cGFyYW1zLGlkOnRoaXMuX25leHRJZCsrLGpzb25ycGM6XCIyLjBcIn07aWYodGhpcy5fcGVuZGluZ0JhdGNoPT1udWxsKXt0aGlzLl9wZW5kaW5nQmF0Y2g9W119Y29uc3QgaW5mbGlnaHRSZXF1ZXN0PXtyZXF1ZXN0OnJlcXVlc3QscmVzb2x2ZTpudWxsLHJlamVjdDpudWxsfTtjb25zdCBwcm9taXNlPW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntpbmZsaWdodFJlcXVlc3QucmVzb2x2ZT1yZXNvbHZlO2luZmxpZ2h0UmVxdWVzdC5yZWplY3Q9cmVqZWN0fSk7dGhpcy5fcGVuZGluZ0JhdGNoLnB1c2goaW5mbGlnaHRSZXF1ZXN0KTtpZighdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcil7dGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcj1zZXRUaW1lb3V0KCgpPT57Y29uc3QgYmF0Y2g9dGhpcy5fcGVuZGluZ0JhdGNoO3RoaXMuX3BlbmRpbmdCYXRjaD1udWxsO3RoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3I9bnVsbDtjb25zdCByZXF1ZXN0PWJhdGNoLm1hcChpbmZsaWdodD0+aW5mbGlnaHQucmVxdWVzdCk7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVxdWVzdEJhdGNoXCIscmVxdWVzdDpkZWVwQ29weShyZXF1ZXN0KSxwcm92aWRlcjp0aGlzfSk7cmV0dXJuIGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkpLnRoZW4ocmVzdWx0PT57dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVzcG9uc2VcIixyZXF1ZXN0OnJlcXVlc3QscmVzcG9uc2U6cmVzdWx0LHByb3ZpZGVyOnRoaXN9KTtiYXRjaC5mb3JFYWNoKChpbmZsaWdodFJlcXVlc3QsaW5kZXgpPT57Y29uc3QgcGF5bG9hZD1yZXN1bHRbaW5kZXhdO2lmKHBheWxvYWQuZXJyb3Ipe2NvbnN0IGVycm9yPW5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO2Vycm9yLmNvZGU9cGF5bG9hZC5lcnJvci5jb2RlO2Vycm9yLmRhdGE9cGF5bG9hZC5lcnJvci5kYXRhO2luZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpfWVsc2V7aW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUocGF5bG9hZC5yZXN1bHQpfX0pfSxlcnJvcj0+e3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlc3BvbnNlXCIsZXJyb3I6ZXJyb3IscmVxdWVzdDpyZXF1ZXN0LHByb3ZpZGVyOnRoaXN9KTtiYXRjaC5mb3JFYWNoKGluZmxpZ2h0UmVxdWVzdD0+e2luZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpfSl9KX0sMTApfXJldHVybiBwcm9taXNlfX1cInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkQz1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7Y29uc3QgZGVmYXVsdEFwaUtleSQyPVwiRVRIRVJTX0pTX1NIQVJFRFwiO2NsYXNzIE5vZGVzbWl0aFByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVye3N0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KXtpZihhcGlLZXkmJnR5cGVvZiBhcGlLZXkhPT1cInN0cmluZ1wiKXtsb2dnZXIkQy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFwaUtleVwiLFwiYXBpS2V5XCIsYXBpS2V5KX1yZXR1cm4gYXBpS2V5fHxkZWZhdWx0QXBpS2V5JDJ9c3RhdGljIGdldFVybChuZXR3b3JrLGFwaUtleSl7bG9nZ2VyJEMud2FybihcIk5vZGVTbWl0aCB3aWxsIGJlIGRpc2NvbnRpbnVlZCBvbiAyMDE5LTEyLTIwOyBwbGVhc2UgbWlncmF0ZSB0byBhbm90aGVyIHBsYXRmb3JtLlwiKTtsZXQgaG9zdD1udWxsO3N3aXRjaChuZXR3b3JrLm5hbWUpe2Nhc2VcImhvbWVzdGVhZFwiOmhvc3Q9XCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvbWFpbm5ldC9qc29ucnBjXCI7YnJlYWs7Y2FzZVwicm9wc3RlblwiOmhvc3Q9XCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvcm9wc3Rlbi9qc29ucnBjXCI7YnJlYWs7Y2FzZVwicmlua2VieVwiOmhvc3Q9XCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvcmlua2VieS9qc29ucnBjXCI7YnJlYWs7Y2FzZVwiZ29lcmxpXCI6aG9zdD1cImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9nb2VybGkvanNvbnJwY1wiO2JyZWFrO2Nhc2VcImtvdmFuXCI6aG9zdD1cImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9rb3Zhbi9qc29ucnBjXCI7YnJlYWs7ZGVmYXVsdDpsb2dnZXIkQy50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsXCJuZXR3b3JrXCIsYXJndW1lbnRzWzBdKX1yZXR1cm4gaG9zdCtcIj9hcGlLZXk9XCIrYXBpS2V5fX1cInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkRD1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7Y29uc3QgZGVmYXVsdEFwcGxpY2F0aW9uSWRzPXtob21lc3RlYWQ6XCI2MDA0YmNkMTAwNDAyNjE2MzNhZGU5OTBcIixyb3BzdGVuOlwiNjAwNGJkNGQwMDQwMjYxNjMzYWRlOTkxXCIscmlua2VieTpcIjYwMDRiZGEyMDA0MDI2MTYzM2FkZTk5NFwiLGdvZXJsaTpcIjYwMDRiZDg2MDA0MDI2MTYzM2FkZTk5MlwifTtjbGFzcyBQb2NrZXRQcm92aWRlciBleHRlbmRzIFVybEpzb25ScGNQcm92aWRlcntjb25zdHJ1Y3RvcihuZXR3b3JrLGFwaUtleSl7aWYoYXBpS2V5PT1udWxsKXtjb25zdCBuPWdldFN0YXRpYyhuZXcudGFyZ2V0LFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtpZihuKXtjb25zdCBhcHBsaWNhdGlvbklkPWRlZmF1bHRBcHBsaWNhdGlvbklkc1tuLm5hbWVdO2lmKGFwcGxpY2F0aW9uSWQpe2FwaUtleT17YXBwbGljYXRpb25JZDphcHBsaWNhdGlvbklkLGxvYWRCYWxhbmNlcjp0cnVlfX19aWYoYXBpS2V5PT1udWxsKXtsb2dnZXIkRC50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJuZXR3b3JrXCIsdmFsdWU6bmV0d29ya30pfX1zdXBlcihuZXR3b3JrLGFwaUtleSl9c3RhdGljIGdldEFwaUtleShhcGlLZXkpe2lmKGFwaUtleT09bnVsbCl7bG9nZ2VyJEQudGhyb3dBcmd1bWVudEVycm9yKFwiUG9ja2V0UHJvdmlkZXIuZ2V0QXBpS2V5IGRvZXMgbm90IHN1cHBvcnQgbnVsbCBhcGlLZXlcIixcImFwaUtleVwiLGFwaUtleSl9Y29uc3QgYXBpS2V5T2JqPXthcHBsaWNhdGlvbklkOm51bGwsbG9hZEJhbGFuY2VyOmZhbHNlLGFwcGxpY2F0aW9uU2VjcmV0S2V5Om51bGx9O2lmKHR5cGVvZiBhcGlLZXk9PT1cInN0cmluZ1wiKXthcGlLZXlPYmouYXBwbGljYXRpb25JZD1hcGlLZXl9ZWxzZSBpZihhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkhPW51bGwpe2xvZ2dlciRELmFzc2VydEFyZ3VtZW50KHR5cGVvZiBhcGlLZXkuYXBwbGljYXRpb25JZD09PVwic3RyaW5nXCIsXCJhcHBsaWNhdGlvblNlY3JldEtleSByZXF1aXJlcyBhbiBhcHBsaWNhdGlvbklkXCIsXCJhcHBsaWNhdGlvbklkXCIsYXBpS2V5LmFwcGxpY2F0aW9uSWQpO2xvZ2dlciRELmFzc2VydEFyZ3VtZW50KHR5cGVvZiBhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXk9PT1cInN0cmluZ1wiLFwiaW52YWxpZCBhcHBsaWNhdGlvblNlY3JldEtleVwiLFwiYXBwbGljYXRpb25TZWNyZXRLZXlcIixcIltSRURBQ1RFRF1cIik7YXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQ9YXBpS2V5LmFwcGxpY2F0aW9uSWQ7YXBpS2V5T2JqLmFwcGxpY2F0aW9uU2VjcmV0S2V5PWFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleTthcGlLZXlPYmoubG9hZEJhbGFuY2VyPSEhYXBpS2V5LmxvYWRCYWxhbmNlcn1lbHNlIGlmKGFwaUtleS5hcHBsaWNhdGlvbklkKXtsb2dnZXIkRC5hc3NlcnRBcmd1bWVudCh0eXBlb2YgYXBpS2V5LmFwcGxpY2F0aW9uSWQ9PT1cInN0cmluZ1wiLFwiYXBpS2V5LmFwcGxpY2F0aW9uSWQgbXVzdCBiZSBhIHN0cmluZ1wiLFwiYXBpS2V5LmFwcGxpY2F0aW9uSWRcIixhcGlLZXkuYXBwbGljYXRpb25JZCk7YXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQ9YXBpS2V5LmFwcGxpY2F0aW9uSWQ7YXBpS2V5T2JqLmxvYWRCYWxhbmNlcj0hIWFwaUtleS5sb2FkQmFsYW5jZXJ9ZWxzZXtsb2dnZXIkRC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBQb2NrZXRQcm92aWRlciBhcGlLZXlcIixcImFwaUtleVwiLGFwaUtleSl9cmV0dXJuIGFwaUtleU9ian1zdGF0aWMgZ2V0VXJsKG5ldHdvcmssYXBpS2V5KXtsZXQgaG9zdD1udWxsO3N3aXRjaChuZXR3b3JrP25ldHdvcmsubmFtZTpcInVua25vd25cIil7Y2FzZVwiaG9tZXN0ZWFkXCI6aG9zdD1cImV0aC1tYWlubmV0LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7YnJlYWs7Y2FzZVwicm9wc3RlblwiOmhvc3Q9XCJldGgtcm9wc3Rlbi5nYXRld2F5LnBva3QubmV0d29ya1wiO2JyZWFrO2Nhc2VcInJpbmtlYnlcIjpob3N0PVwiZXRoLXJpbmtlYnkuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjticmVhaztjYXNlXCJnb2VybGlcIjpob3N0PVwiZXRoLWdvZXJsaS5nYXRld2F5LnBva3QubmV0d29ya1wiO2JyZWFrO2RlZmF1bHQ6bG9nZ2VyJEQudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIixMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwibmV0d29ya1wiLHZhbHVlOm5ldHdvcmt9KX1sZXQgdXJsPW51bGw7aWYoYXBpS2V5LmxvYWRCYWxhbmNlcil7dXJsPWBodHRwczovLyR7aG9zdH0vdjEvbGIvJHthcGlLZXkuYXBwbGljYXRpb25JZH1gfWVsc2V7dXJsPWBodHRwczovLyR7aG9zdH0vdjEvJHthcGlLZXkuYXBwbGljYXRpb25JZH1gfWNvbnN0IGNvbm5lY3Rpb249e3VybDp1cmx9O2Nvbm5lY3Rpb24uaGVhZGVycz17fTtpZihhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkhPW51bGwpe2Nvbm5lY3Rpb24udXNlcj1cIlwiO2Nvbm5lY3Rpb24ucGFzc3dvcmQ9YXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5fXJldHVybiBjb25uZWN0aW9ufWlzQ29tbXVuaXR5UmVzb3VyY2UoKXtyZXR1cm4gdGhpcy5hcHBsaWNhdGlvbklkPT09ZGVmYXVsdEFwcGxpY2F0aW9uSWRzW3RoaXMubmV0d29yay5uYW1lXX19XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJEU9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2xldCBfbmV4dElkPTE7ZnVuY3Rpb24gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlcixzZW5kRnVuYyl7cmV0dXJuIGZ1bmN0aW9uKG1ldGhvZCxwYXJhbXMpe2lmKG1ldGhvZD09XCJldGhfc2lnblwiJiYocHJvdmlkZXIuaXNNZXRhTWFza3x8cHJvdmlkZXIuaXNTdGF0dXMpKXttZXRob2Q9XCJwZXJzb25hbF9zaWduXCI7cGFyYW1zPVtwYXJhbXNbMV0scGFyYW1zWzBdXX1jb25zdCByZXF1ZXN0PXttZXRob2Q6bWV0aG9kLHBhcmFtczpwYXJhbXMsaWQ6X25leHRJZCsrLGpzb25ycGM6XCIyLjBcIn07cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntzZW5kRnVuYyhyZXF1ZXN0LGZ1bmN0aW9uKGVycm9yLHJlc3VsdCl7aWYoZXJyb3Ipe3JldHVybiByZWplY3QoZXJyb3IpfWlmKHJlc3VsdC5lcnJvcil7Y29uc3QgZXJyb3I9bmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKTtlcnJvci5jb2RlPXJlc3VsdC5lcnJvci5jb2RlO2Vycm9yLmRhdGE9cmVzdWx0LmVycm9yLmRhdGE7cmV0dXJuIHJlamVjdChlcnJvcil9cmVzb2x2ZShyZXN1bHQucmVzdWx0KX0pfSl9fWZ1bmN0aW9uIGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpe3JldHVybiBmdW5jdGlvbihtZXRob2QscGFyYW1zKXtpZihwYXJhbXM9PW51bGwpe3BhcmFtcz1bXX1pZihtZXRob2Q9PVwiZXRoX3NpZ25cIiYmKHByb3ZpZGVyLmlzTWV0YU1hc2t8fHByb3ZpZGVyLmlzU3RhdHVzKSl7bWV0aG9kPVwicGVyc29uYWxfc2lnblwiO3BhcmFtcz1bcGFyYW1zWzFdLHBhcmFtc1swXV19cmV0dXJuIHByb3ZpZGVyLnJlcXVlc3Qoe21ldGhvZDptZXRob2QscGFyYW1zOnBhcmFtc30pfX1jbGFzcyBXZWIzUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXJ7Y29uc3RydWN0b3IocHJvdmlkZXIsbmV0d29yayl7bG9nZ2VyJEUuY2hlY2tOZXcobmV3LnRhcmdldCxXZWIzUHJvdmlkZXIpO2lmKHByb3ZpZGVyPT1udWxsKXtsb2dnZXIkRS50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsXCJwcm92aWRlclwiLHByb3ZpZGVyKX1sZXQgcGF0aD1udWxsO2xldCBqc29uUnBjRmV0Y2hGdW5jPW51bGw7bGV0IHN1YnByb3ZpZGVyPW51bGw7aWYodHlwZW9mIHByb3ZpZGVyPT09XCJmdW5jdGlvblwiKXtwYXRoPVwidW5rbm93bjpcIjtqc29uUnBjRmV0Y2hGdW5jPXByb3ZpZGVyfWVsc2V7cGF0aD1wcm92aWRlci5ob3N0fHxwcm92aWRlci5wYXRofHxcIlwiO2lmKCFwYXRoJiZwcm92aWRlci5pc01ldGFNYXNrKXtwYXRoPVwibWV0YW1hc2tcIn1zdWJwcm92aWRlcj1wcm92aWRlcjtpZihwcm92aWRlci5yZXF1ZXN0KXtpZihwYXRoPT09XCJcIil7cGF0aD1cImVpcC0xMTkzOlwifWpzb25ScGNGZXRjaEZ1bmM9YnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcil9ZWxzZSBpZihwcm92aWRlci5zZW5kQXN5bmMpe2pzb25ScGNGZXRjaEZ1bmM9YnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlcixwcm92aWRlci5zZW5kQXN5bmMuYmluZChwcm92aWRlcikpfWVsc2UgaWYocHJvdmlkZXIuc2VuZCl7anNvblJwY0ZldGNoRnVuYz1idWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLHByb3ZpZGVyLnNlbmQuYmluZChwcm92aWRlcikpfWVsc2V7bG9nZ2VyJEUudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgcHJvdmlkZXJcIixcInByb3ZpZGVyXCIscHJvdmlkZXIpfWlmKCFwYXRoKXtwYXRoPVwidW5rbm93bjpcIn19c3VwZXIocGF0aCxuZXR3b3JrKTtkZWZpbmVSZWFkT25seSh0aGlzLFwianNvblJwY0ZldGNoRnVuY1wiLGpzb25ScGNGZXRjaEZ1bmMpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHN1YnByb3ZpZGVyKX1zZW5kKG1ldGhvZCxwYXJhbXMpe3JldHVybiB0aGlzLmpzb25ScGNGZXRjaEZ1bmMobWV0aG9kLHBhcmFtcyl9fVwidXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRGPW5ldyBMb2dnZXIodmVyc2lvbiRtKTtmdW5jdGlvbiBnZXREZWZhdWx0UHJvdmlkZXIobmV0d29yayxvcHRpb25zKXtpZihuZXR3b3JrPT1udWxsKXtuZXR3b3JrPVwiaG9tZXN0ZWFkXCJ9aWYodHlwZW9mIG5ldHdvcms9PT1cInN0cmluZ1wiKXtjb25zdCBtYXRjaD1uZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO2lmKG1hdGNoKXtzd2l0Y2gobWF0Y2hbMV0pe2Nhc2VcImh0dHBcIjpyZXR1cm4gbmV3IEpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtjYXNlXCJ3c1wiOnJldHVybiBuZXcgV2ViU29ja2V0UHJvdmlkZXIobmV0d29yayk7ZGVmYXVsdDpsb2dnZXIkRi50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBVUkwgc2NoZW1lXCIsXCJuZXR3b3JrXCIsbmV0d29yayl9fX1jb25zdCBuPWdldE5ldHdvcmsobmV0d29yayk7aWYoIW58fCFuLl9kZWZhdWx0UHJvdmlkZXIpe2xvZ2dlciRGLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUix7b3BlcmF0aW9uOlwiZ2V0RGVmYXVsdFByb3ZpZGVyXCIsbmV0d29yazpuZXR3b3JrfSl9cmV0dXJuIG4uX2RlZmF1bHRQcm92aWRlcih7RmFsbGJhY2tQcm92aWRlcjpGYWxsYmFja1Byb3ZpZGVyLEFsY2hlbXlQcm92aWRlcjpBbGNoZW15UHJvdmlkZXIsQ2xvdWRmbGFyZVByb3ZpZGVyOkNsb3VkZmxhcmVQcm92aWRlcixFdGhlcnNjYW5Qcm92aWRlcjpFdGhlcnNjYW5Qcm92aWRlcixJbmZ1cmFQcm92aWRlcjpJbmZ1cmFQcm92aWRlcixKc29uUnBjUHJvdmlkZXI6SnNvblJwY1Byb3ZpZGVyLE5vZGVzbWl0aFByb3ZpZGVyOk5vZGVzbWl0aFByb3ZpZGVyLFBvY2tldFByb3ZpZGVyOlBvY2tldFByb3ZpZGVyLFdlYjNQcm92aWRlcjpXZWIzUHJvdmlkZXIsSXBjUHJvdmlkZXI6SXBjUHJvdmlkZXJ9LG9wdGlvbnMpfXZhciBpbmRleCQzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFByb3ZpZGVyOlByb3ZpZGVyLEJhc2VQcm92aWRlcjpCYXNlUHJvdmlkZXIsUmVzb2x2ZXI6UmVzb2x2ZXIsVXJsSnNvblJwY1Byb3ZpZGVyOlVybEpzb25ScGNQcm92aWRlcixGYWxsYmFja1Byb3ZpZGVyOkZhbGxiYWNrUHJvdmlkZXIsQWxjaGVteVByb3ZpZGVyOkFsY2hlbXlQcm92aWRlcixBbGNoZW15V2ViU29ja2V0UHJvdmlkZXI6QWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLENsb3VkZmxhcmVQcm92aWRlcjpDbG91ZGZsYXJlUHJvdmlkZXIsRXRoZXJzY2FuUHJvdmlkZXI6RXRoZXJzY2FuUHJvdmlkZXIsSW5mdXJhUHJvdmlkZXI6SW5mdXJhUHJvdmlkZXIsSW5mdXJhV2ViU29ja2V0UHJvdmlkZXI6SW5mdXJhV2ViU29ja2V0UHJvdmlkZXIsSnNvblJwY1Byb3ZpZGVyOkpzb25ScGNQcm92aWRlcixKc29uUnBjQmF0Y2hQcm92aWRlcjpKc29uUnBjQmF0Y2hQcm92aWRlcixOb2Rlc21pdGhQcm92aWRlcjpOb2Rlc21pdGhQcm92aWRlcixQb2NrZXRQcm92aWRlcjpQb2NrZXRQcm92aWRlcixTdGF0aWNKc29uUnBjUHJvdmlkZXI6U3RhdGljSnNvblJwY1Byb3ZpZGVyLFdlYjNQcm92aWRlcjpXZWIzUHJvdmlkZXIsV2ViU29ja2V0UHJvdmlkZXI6V2ViU29ja2V0UHJvdmlkZXIsSXBjUHJvdmlkZXI6SXBjUHJvdmlkZXIsSnNvblJwY1NpZ25lcjpKc29uUnBjU2lnbmVyLGdldERlZmF1bHRQcm92aWRlcjpnZXREZWZhdWx0UHJvdmlkZXIsZ2V0TmV0d29yazpnZXROZXR3b3JrLGlzQ29tbXVuaXR5UmVzb3VyY2U6aXNDb21tdW5pdHlSZXNvdXJjZSxpc0NvbW11bml0eVJlc291cmNhYmxlOmlzQ29tbXVuaXR5UmVzb3VyY2FibGUsc2hvd1Rocm90dGxlTWVzc2FnZTpzaG93VGhyb3R0bGVNZXNzYWdlLEZvcm1hdHRlcjpGb3JtYXR0ZXJ9KTtcInVzZSBzdHJpY3RcIjtjb25zdCByZWdleEJ5dGVzPW5ldyBSZWdFeHAoXCJeYnl0ZXMoWzAtOV0rKSRcIik7Y29uc3QgcmVnZXhOdW1iZXI9bmV3IFJlZ0V4cChcIl4odT9pbnQpKFswLTldKikkXCIpO2NvbnN0IHJlZ2V4QXJyYXk9bmV3IFJlZ0V4cChcIl4oLiopXFxcXFsoWzAtOV0qKVxcXFxdJFwiKTtjb25zdCBaZXJvcyQxPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO2Z1bmN0aW9uIF9wYWNrKHR5cGUsdmFsdWUsaXNBcnJheSl7c3dpdGNoKHR5cGUpe2Nhc2VcImFkZHJlc3NcIjppZihpc0FycmF5KXtyZXR1cm4gemVyb1BhZCh2YWx1ZSwzMil9cmV0dXJuIGFycmF5aWZ5KHZhbHVlKTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUpO2Nhc2VcImJ5dGVzXCI6cmV0dXJuIGFycmF5aWZ5KHZhbHVlKTtjYXNlXCJib29sXCI6dmFsdWU9dmFsdWU/XCIweDAxXCI6XCIweDAwXCI7aWYoaXNBcnJheSl7cmV0dXJuIHplcm9QYWQodmFsdWUsMzIpfXJldHVybiBhcnJheWlmeSh2YWx1ZSl9bGV0IG1hdGNoPXR5cGUubWF0Y2gocmVnZXhOdW1iZXIpO2lmKG1hdGNoKXtsZXQgc2l6ZT1wYXJzZUludChtYXRjaFsyXXx8XCIyNTZcIik7aWYobWF0Y2hbMl0mJlN0cmluZyhzaXplKSE9PW1hdGNoWzJdfHxzaXplJTghPT0wfHxzaXplPT09MHx8c2l6ZT4yNTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgbnVtYmVyIHR5cGUgLSBcIit0eXBlKX1pZihpc0FycmF5KXtzaXplPTI1Nn12YWx1ZT1CaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9Ud29zKHNpemUpO3JldHVybiB6ZXJvUGFkKHZhbHVlLHNpemUvOCl9bWF0Y2g9dHlwZS5tYXRjaChyZWdleEJ5dGVzKTtpZihtYXRjaCl7Y29uc3Qgc2l6ZT1wYXJzZUludChtYXRjaFsxXSk7aWYoU3RyaW5nKHNpemUpIT09bWF0Y2hbMV18fHNpemU9PT0wfHxzaXplPjMyKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzIHR5cGUgLSBcIit0eXBlKX1pZihhcnJheWlmeSh2YWx1ZSkuYnl0ZUxlbmd0aCE9PXNpemUpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFsdWUgZm9yIFwiK3R5cGUpfWlmKGlzQXJyYXkpe3JldHVybiBhcnJheWlmeSgodmFsdWUrWmVyb3MkMSkuc3Vic3RyaW5nKDAsNjYpKX1yZXR1cm4gdmFsdWV9bWF0Y2g9dHlwZS5tYXRjaChyZWdleEFycmF5KTtpZihtYXRjaCYmQXJyYXkuaXNBcnJheSh2YWx1ZSkpe2NvbnN0IGJhc2VUeXBlPW1hdGNoWzFdO2NvbnN0IGNvdW50PXBhcnNlSW50KG1hdGNoWzJdfHxTdHJpbmcodmFsdWUubGVuZ3RoKSk7aWYoY291bnQhPXZhbHVlLmxlbmd0aCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgXCIrdHlwZSl9Y29uc3QgcmVzdWx0PVtdO3ZhbHVlLmZvckVhY2goZnVuY3Rpb24odmFsdWUpe3Jlc3VsdC5wdXNoKF9wYWNrKGJhc2VUeXBlLHZhbHVlLHRydWUpKX0pO3JldHVybiBjb25jYXQocmVzdWx0KX10aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGUgLSBcIit0eXBlKX1mdW5jdGlvbiBwYWNrJDEodHlwZXMsdmFsdWVzKXtpZih0eXBlcy5sZW5ndGghPXZhbHVlcy5sZW5ndGgpe3Rocm93IG5ldyBFcnJvcihcInR5cGUvdmFsdWUgY291bnQgbWlzbWF0Y2hcIil9Y29uc3QgdGlnaHQ9W107dHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlLGluZGV4KXt0aWdodC5wdXNoKF9wYWNrKHR5cGUsdmFsdWVzW2luZGV4XSkpfSk7cmV0dXJuIGhleGxpZnkoY29uY2F0KHRpZ2h0KSl9ZnVuY3Rpb24ga2VjY2FrMjU2JDEodHlwZXMsdmFsdWVzKXtyZXR1cm4ga2VjY2FrMjU2KHBhY2skMSh0eXBlcyx2YWx1ZXMpKX1mdW5jdGlvbiBzaGEyNTYkMih0eXBlcyx2YWx1ZXMpe3JldHVybiBzaGEyNTYkMShwYWNrJDEodHlwZXMsdmFsdWVzKSl9Y29uc3QgdmVyc2lvbiRuPVwidW5pdHMvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkRz1uZXcgTG9nZ2VyKHZlcnNpb24kbik7Y29uc3QgbmFtZXM9W1wid2VpXCIsXCJrd2VpXCIsXCJtd2VpXCIsXCJnd2VpXCIsXCJzemFib1wiLFwiZmlubmV5XCIsXCJldGhlclwiXTtmdW5jdGlvbiBjb21taWZ5KHZhbHVlKXtjb25zdCBjb21wcz1TdHJpbmcodmFsdWUpLnNwbGl0KFwiLlwiKTtpZihjb21wcy5sZW5ndGg+Mnx8IWNvbXBzWzBdLm1hdGNoKC9eLT9bMC05XSokLyl8fGNvbXBzWzFdJiYhY29tcHNbMV0ubWF0Y2goL15bMC05XSokLyl8fHZhbHVlPT09XCIuXCJ8fHZhbHVlPT09XCItLlwiKXtsb2dnZXIkRy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIsXCJ2YWx1ZVwiLHZhbHVlKX1sZXQgd2hvbGU9Y29tcHNbMF07bGV0IG5lZ2F0aXZlPVwiXCI7aWYod2hvbGUuc3Vic3RyaW5nKDAsMSk9PT1cIi1cIil7bmVnYXRpdmU9XCItXCI7d2hvbGU9d2hvbGUuc3Vic3RyaW5nKDEpfXdoaWxlKHdob2xlLnN1YnN0cmluZygwLDEpPT09XCIwXCIpe3dob2xlPXdob2xlLnN1YnN0cmluZygxKX1pZih3aG9sZT09PVwiXCIpe3dob2xlPVwiMFwifWxldCBzdWZmaXg9XCJcIjtpZihjb21wcy5sZW5ndGg9PT0yKXtzdWZmaXg9XCIuXCIrKGNvbXBzWzFdfHxcIjBcIil9d2hpbGUoc3VmZml4Lmxlbmd0aD4yJiZzdWZmaXhbc3VmZml4Lmxlbmd0aC0xXT09PVwiMFwiKXtzdWZmaXg9c3VmZml4LnN1YnN0cmluZygwLHN1ZmZpeC5sZW5ndGgtMSl9Y29uc3QgZm9ybWF0dGVkPVtdO3doaWxlKHdob2xlLmxlbmd0aCl7aWYod2hvbGUubGVuZ3RoPD0zKXtmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZSk7YnJlYWt9ZWxzZXtjb25zdCBpbmRleD13aG9sZS5sZW5ndGgtMztmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZS5zdWJzdHJpbmcoaW5kZXgpKTt3aG9sZT13aG9sZS5zdWJzdHJpbmcoMCxpbmRleCl9fXJldHVybiBuZWdhdGl2ZStmb3JtYXR0ZWQuam9pbihcIixcIikrc3VmZml4fWZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLHVuaXROYW1lKXtpZih0eXBlb2YgdW5pdE5hbWU9PT1cInN0cmluZ1wiKXtjb25zdCBpbmRleD1uYW1lcy5pbmRleE9mKHVuaXROYW1lKTtpZihpbmRleCE9PS0xKXt1bml0TmFtZT0zKmluZGV4fX1yZXR1cm4gZm9ybWF0Rml4ZWQodmFsdWUsdW5pdE5hbWUhPW51bGw/dW5pdE5hbWU6MTgpfWZ1bmN0aW9uIHBhcnNlVW5pdHModmFsdWUsdW5pdE5hbWUpe2lmKHR5cGVvZiB2YWx1ZSE9PVwic3RyaW5nXCIpe2xvZ2dlciRHLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG11c3QgYmUgYSBzdHJpbmdcIixcInZhbHVlXCIsdmFsdWUpfWlmKHR5cGVvZiB1bml0TmFtZT09PVwic3RyaW5nXCIpe2NvbnN0IGluZGV4PW5hbWVzLmluZGV4T2YodW5pdE5hbWUpO2lmKGluZGV4IT09LTEpe3VuaXROYW1lPTMqaW5kZXh9fXJldHVybiBwYXJzZUZpeGVkKHZhbHVlLHVuaXROYW1lIT1udWxsP3VuaXROYW1lOjE4KX1mdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWkpe3JldHVybiBmb3JtYXRVbml0cyh3ZWksMTgpfWZ1bmN0aW9uIHBhcnNlRXRoZXIoZXRoZXIpe3JldHVybiBwYXJzZVVuaXRzKGV0aGVyLDE4KX1cInVzZSBzdHJpY3RcIjt2YXIgdXRpbHMkMT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBYmlDb2RlcjpBYmlDb2RlcixkZWZhdWx0QWJpQ29kZXI6ZGVmYXVsdEFiaUNvZGVyLEZyYWdtZW50OkZyYWdtZW50LEV2ZW50RnJhZ21lbnQ6RXZlbnRGcmFnbWVudCxGdW5jdGlvbkZyYWdtZW50OkZ1bmN0aW9uRnJhZ21lbnQsUGFyYW1UeXBlOlBhcmFtVHlwZSxGb3JtYXRUeXBlczpGb3JtYXRUeXBlcyxjaGVja1Jlc3VsdEVycm9yczpjaGVja1Jlc3VsdEVycm9ycyxMb2dnZXI6TG9nZ2VyLFJMUDppbmRleCxfZmV0Y2hEYXRhOl9mZXRjaERhdGEsZmV0Y2hKc29uOmZldGNoSnNvbixwb2xsOnBvbGwsY2hlY2tQcm9wZXJ0aWVzOmNoZWNrUHJvcGVydGllcyxkZWVwQ29weTpkZWVwQ29weSxkZWZpbmVSZWFkT25seTpkZWZpbmVSZWFkT25seSxnZXRTdGF0aWM6Z2V0U3RhdGljLHJlc29sdmVQcm9wZXJ0aWVzOnJlc29sdmVQcm9wZXJ0aWVzLHNoYWxsb3dDb3B5OnNoYWxsb3dDb3B5LGFycmF5aWZ5OmFycmF5aWZ5LGNvbmNhdDpjb25jYXQsc3RyaXBaZXJvczpzdHJpcFplcm9zLHplcm9QYWQ6emVyb1BhZCxpc0J5dGVzOmlzQnl0ZXMsaXNCeXRlc0xpa2U6aXNCeXRlc0xpa2UsZGVmYXVsdFBhdGg6ZGVmYXVsdFBhdGgsSEROb2RlOkhETm9kZSxTaWduaW5nS2V5OlNpZ25pbmdLZXksSW50ZXJmYWNlOkludGVyZmFjZSxMb2dEZXNjcmlwdGlvbjpMb2dEZXNjcmlwdGlvbixUcmFuc2FjdGlvbkRlc2NyaXB0aW9uOlRyYW5zYWN0aW9uRGVzY3JpcHRpb24sYmFzZTU4OkJhc2U1OCxiYXNlNjQ6aW5kZXgkMixoZXhsaWZ5OmhleGxpZnksaXNIZXhTdHJpbmc6aXNIZXhTdHJpbmcsaGV4Q29uY2F0OmhleENvbmNhdCxoZXhTdHJpcFplcm9zOmhleFN0cmlwWmVyb3MsaGV4VmFsdWU6aGV4VmFsdWUsaGV4WmVyb1BhZDpoZXhaZXJvUGFkLGhleERhdGFMZW5ndGg6aGV4RGF0YUxlbmd0aCxoZXhEYXRhU2xpY2U6aGV4RGF0YVNsaWNlLG5hbWVwcmVwOm5hbWVwcmVwLF90b0VzY2FwZWRVdGY4U3RyaW5nOl90b0VzY2FwZWRVdGY4U3RyaW5nLHRvVXRmOEJ5dGVzOnRvVXRmOEJ5dGVzLHRvVXRmOENvZGVQb2ludHM6dG9VdGY4Q29kZVBvaW50cyx0b1V0ZjhTdHJpbmc6dG9VdGY4U3RyaW5nLFV0ZjhFcnJvckZ1bmNzOlV0ZjhFcnJvckZ1bmNzLGZvcm1hdEJ5dGVzMzJTdHJpbmc6Zm9ybWF0Qnl0ZXMzMlN0cmluZyxwYXJzZUJ5dGVzMzJTdHJpbmc6cGFyc2VCeXRlczMyU3RyaW5nLGhhc2hNZXNzYWdlOmhhc2hNZXNzYWdlLG5hbWVoYXNoOm5hbWVoYXNoLGlzVmFsaWROYW1lOmlzVmFsaWROYW1lLGlkOmlkLF9UeXBlZERhdGFFbmNvZGVyOlR5cGVkRGF0YUVuY29kZXIsZ2V0QWRkcmVzczpnZXRBZGRyZXNzLGdldEljYXBBZGRyZXNzOmdldEljYXBBZGRyZXNzLGdldENvbnRyYWN0QWRkcmVzczpnZXRDb250cmFjdEFkZHJlc3MsZ2V0Q3JlYXRlMkFkZHJlc3M6Z2V0Q3JlYXRlMkFkZHJlc3MsaXNBZGRyZXNzOmlzQWRkcmVzcyxmb3JtYXRFdGhlcjpmb3JtYXRFdGhlcixwYXJzZUV0aGVyOnBhcnNlRXRoZXIsZm9ybWF0VW5pdHM6Zm9ybWF0VW5pdHMscGFyc2VVbml0czpwYXJzZVVuaXRzLGNvbW1pZnk6Y29tbWlmeSxjb21wdXRlSG1hYzpjb21wdXRlSG1hYyxrZWNjYWsyNTY6a2VjY2FrMjU2LHJpcGVtZDE2MDpyaXBlbWQxNjAkMSxzaGEyNTY6c2hhMjU2JDEsc2hhNTEyOnNoYTUxMiQxLHJhbmRvbUJ5dGVzOnJhbmRvbUJ5dGVzLHNodWZmbGVkOnNodWZmbGVkLHNvbGlkaXR5UGFjazpwYWNrJDEsc29saWRpdHlLZWNjYWsyNTY6a2VjY2FrMjU2JDEsc29saWRpdHlTaGEyNTY6c2hhMjU2JDIsc3BsaXRTaWduYXR1cmU6c3BsaXRTaWduYXR1cmUsam9pblNpZ25hdHVyZTpqb2luU2lnbmF0dXJlLGFjY2Vzc0xpc3RpZnk6YWNjZXNzTGlzdGlmeSxwYXJzZVRyYW5zYWN0aW9uOnBhcnNlLHNlcmlhbGl6ZVRyYW5zYWN0aW9uOnNlcmlhbGl6ZSxnZXRKc29uV2FsbGV0QWRkcmVzczpnZXRKc29uV2FsbGV0QWRkcmVzcyxjb21wdXRlQWRkcmVzczpjb21wdXRlQWRkcmVzcyxyZWNvdmVyQWRkcmVzczpyZWNvdmVyQWRkcmVzcyxjb21wdXRlUHVibGljS2V5OmNvbXB1dGVQdWJsaWNLZXkscmVjb3ZlclB1YmxpY0tleTpyZWNvdmVyUHVibGljS2V5LHZlcmlmeU1lc3NhZ2U6dmVyaWZ5TWVzc2FnZSx2ZXJpZnlUeXBlZERhdGE6dmVyaWZ5VHlwZWREYXRhLG1uZW1vbmljVG9FbnRyb3B5Om1uZW1vbmljVG9FbnRyb3B5LGVudHJvcHlUb01uZW1vbmljOmVudHJvcHlUb01uZW1vbmljLGlzVmFsaWRNbmVtb25pYzppc1ZhbGlkTW5lbW9uaWMsbW5lbW9uaWNUb1NlZWQ6bW5lbW9uaWNUb1NlZWQsZ2V0IFN1cHBvcnRlZEFsZ29yaXRobSgpe3JldHVybiBTdXBwb3J0ZWRBbGdvcml0aG19LGdldCBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0oKXtyZXR1cm4gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtfSxnZXQgVXRmOEVycm9yUmVhc29uKCl7cmV0dXJuIFV0ZjhFcnJvclJlYXNvbn0sSW5kZXhlZDpJbmRleGVkfSk7Y29uc3QgdmVyc2lvbiRvPVwiZXRoZXJzLzUuMS40XCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJEg9bmV3IExvZ2dlcih2ZXJzaW9uJG8pO3ZhciBldGhlcnM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsU2lnbmVyOlNpZ25lcixXYWxsZXQ6V2FsbGV0LFZvaWRTaWduZXI6Vm9pZFNpZ25lcixnZXREZWZhdWx0UHJvdmlkZXI6Z2V0RGVmYXVsdFByb3ZpZGVyLHByb3ZpZGVyczppbmRleCQzLEJhc2VDb250cmFjdDpCYXNlQ29udHJhY3QsQ29udHJhY3Q6Q29udHJhY3QsQ29udHJhY3RGYWN0b3J5OkNvbnRyYWN0RmFjdG9yeSxCaWdOdW1iZXI6QmlnTnVtYmVyLEZpeGVkTnVtYmVyOkZpeGVkTnVtYmVyLGNvbnN0YW50czppbmRleCQxLGdldCBlcnJvcnMoKXtyZXR1cm4gRXJyb3JDb2RlfSxsb2dnZXI6bG9nZ2VyJEgsdXRpbHM6dXRpbHMkMSx3b3JkbGlzdHM6d29yZGxpc3RzLHZlcnNpb246dmVyc2lvbiRvLFdvcmRsaXN0OldvcmRsaXN0fSk7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2NvbnN0IGFueUdsb2JhbD13aW5kb3c7aWYoYW55R2xvYmFsLl9ldGhlcnM9PW51bGwpe2FueUdsb2JhbC5fZXRoZXJzPWV0aGVyc319Y2F0Y2goZXJyb3Ipe31leHBvcnR7QmFzZUNvbnRyYWN0LEJpZ051bWJlcixDb250cmFjdCxDb250cmFjdEZhY3RvcnksRml4ZWROdW1iZXIsU2lnbmVyLFZvaWRTaWduZXIsV2FsbGV0LFdvcmRsaXN0LGluZGV4JDEgYXMgY29uc3RhbnRzLEVycm9yQ29kZSBhcyBlcnJvcnMsZXRoZXJzLGdldERlZmF1bHRQcm92aWRlcixsb2dnZXIkSCBhcyBsb2dnZXIsaW5kZXgkMyBhcyBwcm92aWRlcnMsdXRpbHMkMSBhcyB1dGlscyx2ZXJzaW9uJG8gYXMgdmVyc2lvbix3b3JkbGlzdHN9OyIsImltcG9ydCB7IGV0aGVycyB9IGZyb20gXCIuL2V0aGVycy01LjEuZXNtLm1pbi5qc1wiO1xyXG5pbXBvcnQgeyBnZW5SYW5kb21Mb2dpbk1zZyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9naW4od2FsbGV0X2FkZHJlc3MsIHdlYjMpXHJcbntcclxuICAgIGNvbnN0IG1zZyA9IGdlblJhbmRvbUxvZ2luTXNnKCk7XHJcblxyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIod2ViMyk7XHJcbiAgICBjb25zdCBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduTWVzc2FnZShtc2cpO1xyXG5cclxuICAgIGF3YWl0IGhhbmRsZV9hdXRoKHdhbGxldF9hZGRyZXNzLCBtc2csIHNpZ25hdHVyZSk7XHJcblxyXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIi9pbmRleFwiO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlX2F1dGgod2FsbGV0X2FkZHJlc3MsIG1zZywgc2lnbmF0dXJlKVxyXG57XHJcbiAgICBjb25zb2xlLmxvZyh3YWxsZXRfYWRkcmVzcyk7XHJcbiAgICBjb25zb2xlLmxvZyhzaWduYXR1cmUpO1xyXG5cclxuICAgIGNvbnN0IGRhdGEgPSB7YWRkcmVzczogd2FsbGV0X2FkZHJlc3MsIG1lc3NhZ2U6IG1zZywgc2lnbmF0dXJlOiBzaWduYXR1cmV9XHJcblxyXG4gICAgYXdhaXQgZmV0Y2goJ2xvZ2luJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcclxuICAgICAgICAgICAgaGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbid9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxyXG4gICAgICAgIH0pO1xyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvcyhudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgPyAnLScgOiAnJztcbiAgdmFyIG91dHB1dCA9IE1hdGguYWJzKG51bWJlcikudG9TdHJpbmcoKTtcblxuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBzaWduICsgb3V0cHV0O1xufSIsImltcG9ydCBnZXRVVENEYXlPZlllYXIgZnJvbSBcIi4uLy4uLy4uL19saWIvZ2V0VVRDRGF5T2ZZZWFyL2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VVRDSVNPV2VlayBmcm9tIFwiLi4vLi4vLi4vX2xpYi9nZXRVVENJU09XZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VVRDSVNPV2Vla1llYXIgZnJvbSBcIi4uLy4uLy4uL19saWIvZ2V0VVRDSVNPV2Vla1llYXIvaW5kZXguanNcIjtcbmltcG9ydCBnZXRVVENXZWVrIGZyb20gXCIuLi8uLi8uLi9fbGliL2dldFVUQ1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCBnZXRVVENXZWVrWWVhciBmcm9tIFwiLi4vLi4vLi4vX2xpYi9nZXRVVENXZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IGFkZExlYWRpbmdaZXJvcyBmcm9tIFwiLi4vLi4vYWRkTGVhZGluZ1plcm9zL2luZGV4LmpzXCI7XG5pbXBvcnQgbGlnaHRGb3JtYXR0ZXJzIGZyb20gXCIuLi9saWdodEZvcm1hdHRlcnMvaW5kZXguanNcIjtcbnZhciBkYXlQZXJpb2RFbnVtID0ge1xuICBhbTogJ2FtJyxcbiAgcG06ICdwbScsXG4gIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICBub29uOiAnbm9vbicsXG4gIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICBuaWdodDogJ25pZ2h0J1xufTtcbi8qXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8IE1pbGxpc2Vjb25kcyBpbiBkYXkgICAgICAgICAgICB8XG4gKiB8ICBiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICB8ICBCICB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICB8XG4gKiB8ICBjICB8IFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrICB8ICBDKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8XG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBlICB8IExvY2FsIGRheSBvZiB3ZWVrICAgICAgICAgICAgICB8ICBFICB8IERheSBvZiB3ZWVrICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBmICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBGKiB8IERheSBvZiB3ZWVrIGluIG1vbnRoICAgICAgICAgICB8XG4gKiB8ICBnKiB8IE1vZGlmaWVkIEp1bGlhbiBkYXkgICAgICAgICAgICB8ICBHICB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBpISB8IElTTyBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgICB8ICBJISB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICB8XG4gKiB8ICBqKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8ICBKKiB8IExvY2FsaXplZCBob3VyIHcvbyBkYXkgcGVyaW9kICB8XG4gKiB8ICBrICB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICB8ICBLICB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBsKiB8IChkZXByZWNhdGVkKSAgICAgICAgICAgICAgICAgICB8ICBMICB8IFN0YW5kLWFsb25lIG1vbnRoICAgICAgICAgICAgICB8XG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBuICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBOICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBvISB8IE9yZGluYWwgbnVtYmVyIG1vZGlmaWVyICAgICAgICB8ICBPICB8IFRpbWV6b25lIChHTVQpICAgICAgICAgICAgICAgICB8XG4gKiB8ICBwISB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICB8ICBQISB8IExvbmcgbG9jYWxpemVkIGRhdGUgICAgICAgICAgICB8XG4gKiB8ICBxICB8IFN0YW5kLWFsb25lIHF1YXJ0ZXIgICAgICAgICAgICB8ICBRICB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICByKiB8IFJlbGF0ZWQgR3JlZ29yaWFuIHllYXIgICAgICAgICB8ICBSISB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICB8XG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gKiB8ICB0ISB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICB8ICBUISB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICB8XG4gKiB8ICB1ICB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICB8ICBVKiB8IEN5Y2xpYyB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICB2KiB8IFRpbWV6b25lIChnZW5lcmljIG5vbi1sb2NhdC4pICB8ICBWKiB8IFRpbWV6b25lIChsb2NhdGlvbikgICAgICAgICAgICB8XG4gKiB8ICB3ICB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICB8ICBXKiB8IFdlZWsgb2YgbW9udGggICAgICAgICAgICAgICAgICB8XG4gKiB8ICB4ICB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICB8ICBYICB8IFRpbWV6b25lIChJU08tODYwMSkgICAgICAgICAgICB8XG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICB8XG4gKiB8ICB6ICB8IFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXQuKSB8ICBaKiB8IFRpbWV6b25lIChhbGlhc2VzKSAgICAgICAgICAgICB8XG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICEgYXJlIG5vbi1zdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IGRhdGUtZm5zOlxuICogLSBgb2AgbW9kaWZpZXMgdGhlIHByZXZpb3VzIHRva2VuIHRvIHR1cm4gaXQgaW50byBhbiBvcmRpbmFsIChzZWUgYGZvcm1hdGAgZG9jcylcbiAqIC0gYGlgIGlzIElTTyBkYXkgb2Ygd2Vlay4gRm9yIGBpYCBhbmQgYGlpYCBpcyByZXR1cm5zIG51bWVyaWMgSVNPIHdlZWsgZGF5cyxcbiAqICAgaS5lLiA3IGZvciBTdW5kYXksIDEgZm9yIE1vbmRheSwgZXRjLlxuICogLSBgSWAgaXMgSVNPIHdlZWsgb2YgeWVhciwgYXMgb3Bwb3NlZCB0byBgd2Agd2hpY2ggaXMgbG9jYWwgd2VlayBvZiB5ZWFyLlxuICogLSBgUmAgaXMgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsIGFzIG9wcG9zZWQgdG8gYFlgIHdoaWNoIGlzIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIuXG4gKiAgIGBSYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYElgIGFuZCBgaWBcbiAqICAgZm9yIHVuaXZlcnNhbCBJU08gd2Vlay1udW1iZXJpbmcgZGF0ZSwgd2hlcmVhc1xuICogICBgWWAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB3YCBhbmQgYGVgXG4gKiAgIGZvciB3ZWVrLW51bWJlcmluZyBkYXRlIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUuXG4gKiAtIGBQYCBpcyBsb25nIGxvY2FsaXplZCBkYXRlIGZvcm1hdFxuICogLSBgcGAgaXMgbG9uZyBsb2NhbGl6ZWQgdGltZSBmb3JtYXRcbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHtcbiAgLy8gRXJhXG4gIEc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZXJhID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpID4gMCA/IDEgOiAwO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gQUQsIEJDXG4gICAgICBjYXNlICdHJzpcbiAgICAgIGNhc2UgJ0dHJzpcbiAgICAgIGNhc2UgJ0dHRyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCdcbiAgICAgICAgfSk7XG4gICAgICAvLyBBLCBCXG5cbiAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdydcbiAgICAgICAgfSk7XG4gICAgICAvLyBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdFxuXG4gICAgICBjYXNlICdHR0dHJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFllYXJcbiAgeTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIC8vIE9yZGluYWwgbnVtYmVyXG4gICAgaWYgKHRva2VuID09PSAneW8nKSB7XG4gICAgICB2YXIgc2lnbmVkWWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTsgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcblxuICAgICAgdmFyIHllYXIgPSBzaWduZWRZZWFyID4gMCA/IHNpZ25lZFllYXIgOiAxIC0gc2lnbmVkWWVhcjtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHllYXIsIHtcbiAgICAgICAgdW5pdDogJ3llYXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLnkoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2lnbmVkV2Vla1llYXIgPSBnZXRVVENXZWVrWWVhcihkYXRlLCBvcHRpb25zKTsgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcblxuICAgIHZhciB3ZWVrWWVhciA9IHNpZ25lZFdlZWtZZWFyID4gMCA/IHNpZ25lZFdlZWtZZWFyIDogMSAtIHNpZ25lZFdlZWtZZWFyOyAvLyBUd28gZGlnaXQgeWVhclxuXG4gICAgaWYgKHRva2VuID09PSAnWVknKSB7XG4gICAgICB2YXIgdHdvRGlnaXRZZWFyID0gd2Vla1llYXIgJSAxMDA7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHR3b0RpZ2l0WWVhciwgMik7XG4gICAgfSAvLyBPcmRpbmFsIG51bWJlclxuXG5cbiAgICBpZiAodG9rZW4gPT09ICdZbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHdlZWtZZWFyLCB7XG4gICAgICAgIHVuaXQ6ICd5ZWFyJ1xuICAgICAgfSk7XG4gICAgfSAvLyBQYWRkaW5nXG5cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3Mod2Vla1llYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBpc29XZWVrWWVhciA9IGdldFVUQ0lTT1dlZWtZZWFyKGRhdGUpOyAvLyBQYWRkaW5nXG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb1dlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBFeHRlbmRlZCB5ZWFyLiBUaGlzIGlzIGEgc2luZ2xlIG51bWJlciBkZXNpZ25hdGluZyB0aGUgeWVhciBvZiB0aGlzIGNhbGVuZGFyIHN5c3RlbS5cbiAgLy8gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIGxvY2FsaXplcnMgYXJlIEIuQy4geWVhcnM6XG4gIC8vIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gIC8vIHwtLS0tLS18LS0tLS18LS0tLS18XG4gIC8vIHwgQUMgMSB8ICAgMSB8ICAgMSB8XG4gIC8vIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gIC8vIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gIC8vIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcbiAgLy8gd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkLlxuICB1OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHllYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIFF1YXJ0ZXJcbiAgUTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSAvIDMpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuXG4gICAgICBjYXNlICdRUSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MocXVhcnRlciwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcblxuICAgICAgY2FzZSAnUW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7XG4gICAgICAgICAgdW5pdDogJ3F1YXJ0ZXInXG4gICAgICAgIH0pO1xuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcblxuICAgICAgY2FzZSAnUVFRJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuXG4gICAgICBjYXNlICdRUVFRUSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cblxuICAgICAgY2FzZSAnUVFRUSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBxdWFydGVyXG4gIHE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgcXVhcnRlciA9IE1hdGguY2VpbCgoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgLyAzKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHF1YXJ0ZXIpO1xuICAgICAgLy8gMDEsIDAyLCAwMywgMDRcblxuICAgICAgY2FzZSAncXEnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHF1YXJ0ZXIsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG5cbiAgICAgIGNhc2UgJ3FvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIocXVhcnRlciwge1xuICAgICAgICAgIHVuaXQ6ICdxdWFydGVyJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG5cbiAgICAgIGNhc2UgJ3FxcSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcblxuICAgICAgY2FzZSAncXFxcXEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG5cbiAgICAgIGNhc2UgJ3FxcXEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gTW9udGhcbiAgTTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgY2FzZSAnTU0nOlxuICAgICAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLk0oZGF0ZSwgdG9rZW4pO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxuXG4gICAgICBjYXNlICdNbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoICsgMSwge1xuICAgICAgICAgIHVuaXQ6ICdtb250aCdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcblxuICAgICAgY2FzZSAnTU1NJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG5cbiAgICAgIGNhc2UgJ01NTU1NJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG5cbiAgICAgIGNhc2UgJ01NTU0nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBTdGFuZC1hbG9uZSBtb250aFxuICBMOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgLi4uLCAxMlxuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIHJldHVybiBTdHJpbmcobW9udGggKyAxKTtcbiAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuXG4gICAgICBjYXNlICdMTCc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobW9udGggKyAxLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcblxuICAgICAgY2FzZSAnTG8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHtcbiAgICAgICAgICB1bml0OiAnbW9udGgnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG5cbiAgICAgIGNhc2UgJ0xMTCc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEosIEYsIC4uLiwgRFxuXG4gICAgICBjYXNlICdMTExMTCc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuXG4gICAgICBjYXNlICdMTExMJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gTG9jYWwgd2VlayBvZiB5ZWFyXG4gIHc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2VlayA9IGdldFVUQ1dlZWsoZGF0ZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodG9rZW4gPT09ICd3bycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHdlZWssIHtcbiAgICAgICAgdW5pdDogJ3dlZWsnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWssIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIElTTyB3ZWVrIG9mIHllYXJcbiAgSTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBpc29XZWVrID0gZ2V0VVRDSVNPV2VlayhkYXRlKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJ0lvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaXNvV2Vlaywge1xuICAgICAgICB1bml0OiAnd2VlaydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHRoZSBtb250aFxuICBkOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnZG8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ0RhdGUoKSwge1xuICAgICAgICB1bml0OiAnZGF0ZSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMuZChkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIERheSBvZiB5ZWFyXG4gIEQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gZ2V0VVRDRGF5T2ZZZWFyKGRhdGUpO1xuXG4gICAgaWYgKHRva2VuID09PSAnRG8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXlPZlllYXIsIHtcbiAgICAgICAgdW5pdDogJ2RheU9mWWVhcidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF5T2ZZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBEYXkgb2Ygd2Vla1xuICBFOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBUdWVcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgY2FzZSAnRUUnOlxuICAgICAgY2FzZSAnRUVFJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ0VFRUVFJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnRUVFRUVFJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ0VFRUUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXG4gIGU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgICB2YXIgbG9jYWxEYXlPZldlZWsgPSAoZGF5T2ZXZWVrIC0gb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA4KSAlIDcgfHwgNztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIE51bWVyaWNhbCB2YWx1ZSAoTnRoIGRheSBvZiB3ZWVrIHdpdGggY3VycmVudCBsb2NhbGUgb3Igd2Vla1N0YXJ0c09uKVxuICAgICAgY2FzZSAnZSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcobG9jYWxEYXlPZldlZWspO1xuICAgICAgLy8gUGFkZGVkIG51bWVyaWNhbCB2YWx1ZVxuXG4gICAgICBjYXNlICdlZSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobG9jYWxEYXlPZldlZWssIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgN3RoXG5cbiAgICAgIGNhc2UgJ2VvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobG9jYWxEYXlPZldlZWssIHtcbiAgICAgICAgICB1bml0OiAnZGF5J1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnZWVlJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ2VlZWVlJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnZWVlZWVlJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ2VlZWUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrXG4gIGM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgICB2YXIgbG9jYWxEYXlPZldlZWsgPSAoZGF5T2ZXZWVrIC0gb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA4KSAlIDcgfHwgNztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIE51bWVyaWNhbCB2YWx1ZSAoc2FtZSBhcyBpbiBgZWApXG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsb2NhbERheU9mV2Vlayk7XG4gICAgICAvLyBQYWRkZWQgbnVtZXJpY2FsIHZhbHVlXG5cbiAgICAgIGNhc2UgJ2NjJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhsb2NhbERheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuXG4gICAgICBjYXNlICdjbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7XG4gICAgICAgICAgdW5pdDogJ2RheSdcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2NjYyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdjY2NjYyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ2NjY2NjYyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdjY2NjJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBJU08gZGF5IG9mIHdlZWtcbiAgaTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuICAgIHZhciBpc29EYXlPZldlZWsgPSBkYXlPZldlZWsgPT09IDAgPyA3IDogZGF5T2ZXZWVrO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMlxuICAgICAgY2FzZSAnaSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcoaXNvRGF5T2ZXZWVrKTtcbiAgICAgIC8vIDAyXG5cbiAgICAgIGNhc2UgJ2lpJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29EYXlPZldlZWssIHRva2VuLmxlbmd0aCk7XG4gICAgICAvLyAybmRcblxuICAgICAgY2FzZSAnaW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihpc29EYXlPZldlZWssIHtcbiAgICAgICAgICB1bml0OiAnZGF5J1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZVxuXG4gICAgICBjYXNlICdpaWknOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnaWlpaWknOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdpaWlpaWknOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnaWlpaSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gQU0gb3IgUE1cbiAgYTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlID0gaG91cnMgLyAxMiA+PSAxID8gJ3BtJyA6ICdhbSc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdhJzpcbiAgICAgIGNhc2UgJ2FhJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2FhYSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGNhc2UgJ2FhYWFhJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdhYWFhJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBBTSwgUE0sIG1pZG5pZ2h0LCBub29uXG4gIGI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZTtcblxuICAgIGlmIChob3VycyA9PT0gMTIpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubm9vbjtcbiAgICB9IGVsc2UgaWYgKGhvdXJzID09PSAwKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm1pZG5pZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBob3VycyAvIDEyID49IDEgPyAncG0nIDogJ2FtJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdiJzpcbiAgICAgIGNhc2UgJ2JiJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2JiYic6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGNhc2UgJ2JiYmJiJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdiYmJiJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBpbiB0aGUgbW9ybmluZywgaW4gdGhlIGFmdGVybm9vbiwgaW4gdGhlIGV2ZW5pbmcsIGF0IG5pZ2h0XG4gIEI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgdmFyIGRheVBlcmlvZEVudW1WYWx1ZTtcblxuICAgIGlmIChob3VycyA+PSAxNykge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5ldmVuaW5nO1xuICAgIH0gZWxzZSBpZiAoaG91cnMgPj0gMTIpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uYWZ0ZXJub29uO1xuICAgIH0gZWxzZSBpZiAoaG91cnMgPj0gNCkge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5tb3JuaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5pZ2h0O1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ0InOlxuICAgICAgY2FzZSAnQkInOlxuICAgICAgY2FzZSAnQkJCJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ0JCQkJCJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdCQkJCJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnaG8nKSB7XG4gICAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMjtcbiAgICAgIGlmIChob3VycyA9PT0gMCkgaG91cnMgPSAxMjtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5oKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gSG91ciBbMC0yM11cbiAgSDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ0hvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENIb3VycygpLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5IKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gSG91ciBbMC0xMV1cbiAgSzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyO1xuXG4gICAgaWYgKHRva2VuID09PSAnS28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3Vycywge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEhvdXIgWzEtMjRdXG4gIGs6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgaWYgKGhvdXJzID09PSAwKSBob3VycyA9IDI0O1xuXG4gICAgaWYgKHRva2VuID09PSAna28nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3Vycywge1xuICAgICAgICB1bml0OiAnaG91cidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1pbnV0ZVxuICBtOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnbW8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ01pbnV0ZXMoKSwge1xuICAgICAgICB1bml0OiAnbWludXRlJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5tKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gU2Vjb25kXG4gIHM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdzbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDU2Vjb25kcygpLCB7XG4gICAgICAgIHVuaXQ6ICdzZWNvbmQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLnMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcbiAgUzogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5TKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gVGltZXpvbmUgKElTTy04NjAxLiBJZiBvZmZzZXQgaXMgMCwgb3V0cHV0IGlzIGFsd2F5cyBgJ1onYClcbiAgWDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBpZiAodGltZXpvbmVPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiAnWic7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmVXaXRoT3B0aW9uYWxNaW51dGVzKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYYFxuXG4gICAgICBjYXNlICdYWFhYJzpcbiAgICAgIGNhc2UgJ1hYJzpcbiAgICAgICAgLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRoIGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGBYWFhgXG5cbiAgICAgIGNhc2UgJ1hYWFhYJzpcbiAgICAgIGNhc2UgJ1hYWCc6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBUaW1lem9uZSAoSVNPLTg2MDEuIElmIG9mZnNldCBpcyAwLCBvdXRwdXQgaXMgYCcrMDA6MDAnYCBvciBlcXVpdmFsZW50KVxuICB4OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIEhvdXJzIGFuZCBvcHRpb25hbCBtaW51dGVzXG4gICAgICBjYXNlICd4JzpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGB4eGBcblxuICAgICAgY2FzZSAneHh4eCc6XG4gICAgICBjYXNlICd4eCc6XG4gICAgICAgIC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHh4YFxuXG4gICAgICBjYXNlICd4eHh4eCc6XG4gICAgICBjYXNlICd4eHgnOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRoIGA6YCBkZWxpbWl0ZXJcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGltZXpvbmUgKEdNVClcbiAgTzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSAnTyc6XG4gICAgICBjYXNlICdPTyc6XG4gICAgICBjYXNlICdPT08nOlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZVNob3J0KHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgICAgLy8gTG9uZ1xuXG4gICAgICBjYXNlICdPT09PJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdGlvbilcbiAgejogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICd6eic6XG4gICAgICBjYXNlICd6enonOlxuICAgICAgICByZXR1cm4gJ0dNVCcgKyBmb3JtYXRUaW1lem9uZVNob3J0KHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgICAgLy8gTG9uZ1xuXG4gICAgICBjYXNlICd6enp6JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpO1xuICAgIH1cbiAgfSxcbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXBcbiAgdDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3Iob3JpZ2luYWxEYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNaWxsaXNlY29uZHMgdGltZXN0YW1wXG4gIFQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lc3RhbXAgPSBvcmlnaW5hbERhdGUuZ2V0VGltZSgpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZVNob3J0KG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpIHtcbiAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xuICB2YXIgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihhYnNPZmZzZXQgLyA2MCk7XG4gIHZhciBtaW51dGVzID0gYWJzT2Zmc2V0ICUgNjA7XG5cbiAgaWYgKG1pbnV0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gc2lnbiArIFN0cmluZyhob3Vycyk7XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZGlydHlEZWxpbWl0ZXIgfHwgJyc7XG4gIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKSArIGRlbGltaXRlciArIGFkZExlYWRpbmdaZXJvcyhtaW51dGVzLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmVXaXRoT3B0aW9uYWxNaW51dGVzKG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpIHtcbiAgaWYgKG9mZnNldCAlIDYwID09PSAwKSB7XG4gICAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xuICAgIHJldHVybiBzaWduICsgYWRkTGVhZGluZ1plcm9zKE1hdGguYWJzKG9mZnNldCkgLyA2MCwgMik7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VGltZXpvbmUob2Zmc2V0LCBkaXJ0eURlbGltaXRlcik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lKG9mZnNldCwgZGlydHlEZWxpbWl0ZXIpIHtcbiAgdmFyIGRlbGltaXRlciA9IGRpcnR5RGVsaW1pdGVyIHx8ICcnO1xuICB2YXIgc2lnbiA9IG9mZnNldCA+IDAgPyAnLScgOiAnKyc7XG4gIHZhciBhYnNPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuICB2YXIgaG91cnMgPSBhZGRMZWFkaW5nWmVyb3MoTWF0aC5mbG9vcihhYnNPZmZzZXQgLyA2MCksIDIpO1xuICB2YXIgbWludXRlcyA9IGFkZExlYWRpbmdaZXJvcyhhYnNPZmZzZXQgJSA2MCwgMik7XG4gIHJldHVybiBzaWduICsgaG91cnMgKyBkZWxpbWl0ZXIgKyBtaW51dGVzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXR0ZXJzOyIsImltcG9ydCBhZGRMZWFkaW5nWmVyb3MgZnJvbSBcIi4uLy4uL2FkZExlYWRpbmdaZXJvcy9pbmRleC5qc1wiO1xuLypcbiAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gKi9cblxudmFyIGZvcm1hdHRlcnMgPSB7XG4gIC8vIFllYXJcbiAgeTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgLy8gRnJvbSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTMxL3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF90b2tlbnNcbiAgICAvLyB8IFllYXIgICAgIHwgICAgIHkgfCB5eSB8ICAgeXl5IHwgIHl5eXkgfCB5eXl5eSB8XG4gICAgLy8gfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxuICAgIC8vIHwgQUQgMSAgICAgfCAgICAgMSB8IDAxIHwgICAwMDEgfCAgMDAwMSB8IDAwMDAxIHxcbiAgICAvLyB8IEFEIDEyICAgIHwgICAgMTIgfCAxMiB8ICAgMDEyIHwgIDAwMTIgfCAwMDAxMiB8XG4gICAgLy8gfCBBRCAxMjMgICB8ICAgMTIzIHwgMjMgfCAgIDEyMyB8ICAwMTIzIHwgMDAxMjMgfFxuICAgIC8vIHwgQUQgMTIzNCAgfCAgMTIzNCB8IDM0IHwgIDEyMzQgfCAgMTIzNCB8IDAxMjM0IHxcbiAgICAvLyB8IEFEIDEyMzQ1IHwgMTIzNDUgfCA0NSB8IDEyMzQ1IHwgMTIzNDUgfCAxMjM0NSB8XG4gICAgdmFyIHNpZ25lZFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7IC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG5cbiAgICB2YXIgeWVhciA9IHNpZ25lZFllYXIgPiAwID8gc2lnbmVkWWVhciA6IDEgLSBzaWduZWRZZWFyO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModG9rZW4gPT09ICd5eScgPyB5ZWFyICUgMTAwIDogeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTW9udGhcbiAgTTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgIHJldHVybiB0b2tlbiA9PT0gJ00nID8gU3RyaW5nKG1vbnRoICsgMSkgOiBhZGRMZWFkaW5nWmVyb3MobW9udGggKyAxLCAyKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHRoZSBtb250aFxuICBkOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDRGF0ZSgpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBBTSBvciBQTVxuICBhOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF0ZS5nZXRVVENIb3VycygpIC8gMTIgPj0gMSA/ICdwbScgOiAnYW0nO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnYSc6XG4gICAgICBjYXNlICdhYSc6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgY2FzZSAnYWFhJzpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZTtcblxuICAgICAgY2FzZSAnYWFhYWEnOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlWzBdO1xuXG4gICAgICBjYXNlICdhYWFhJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWUgPT09ICdhbScgPyAnYS5tLicgOiAncC5tLic7XG4gICAgfVxuICB9LFxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDSG91cnMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTWludXRlXG4gIG06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENNaW51dGVzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIFNlY29uZFxuICBzOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDU2Vjb25kcygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcbiAgUzogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIG51bWJlck9mRGlnaXRzID0gdG9rZW4ubGVuZ3RoO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIHZhciBmcmFjdGlvbmFsU2Vjb25kcyA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzICogTWF0aC5wb3coMTAsIG51bWJlck9mRGlnaXRzIC0gMykpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZnJhY3Rpb25hbFNlY29uZHMsIHRva2VuLmxlbmd0aCk7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBmb3JtYXR0ZXJzOyIsImZ1bmN0aW9uIGRhdGVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpIHtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSAnUCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdzaG9ydCdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnUFAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnbWVkaXVtJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdQUFAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnbG9uZydcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnUFBQUCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ2Z1bGwnXG4gICAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aW1lTG9uZ0Zvcm1hdHRlcihwYXR0ZXJuLCBmb3JtYXRMb25nKSB7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgJ3AnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnc2hvcnQnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ3BwJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ21lZGl1bSdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAncHBwJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ2xvbmcnXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ3BwcHAnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdmdWxsJ1xuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZVRpbWVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpIHtcbiAgdmFyIG1hdGNoUmVzdWx0ID0gcGF0dGVybi5tYXRjaCgvKFArKShwKyk/LykgfHwgW107XG4gIHZhciBkYXRlUGF0dGVybiA9IG1hdGNoUmVzdWx0WzFdO1xuICB2YXIgdGltZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsyXTtcblxuICBpZiAoIXRpbWVQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGRhdGVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpO1xuICB9XG5cbiAgdmFyIGRhdGVUaW1lRm9ybWF0O1xuXG4gIHN3aXRjaCAoZGF0ZVBhdHRlcm4pIHtcbiAgICBjYXNlICdQJzpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnc2hvcnQnXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUFAnOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdtZWRpdW0nXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUFBQJzpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7XG4gICAgICAgIHdpZHRoOiAnbG9uZydcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQUFBQJzpcbiAgICBkZWZhdWx0OlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdmdWxsJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBkYXRlVGltZUZvcm1hdC5yZXBsYWNlKCd7e2RhdGV9fScsIGRhdGVMb25nRm9ybWF0dGVyKGRhdGVQYXR0ZXJuLCBmb3JtYXRMb25nKSkucmVwbGFjZSgne3t0aW1lfX0nLCB0aW1lTG9uZ0Zvcm1hdHRlcih0aW1lUGF0dGVybiwgZm9ybWF0TG9uZykpO1xufVxuXG52YXIgbG9uZ0Zvcm1hdHRlcnMgPSB7XG4gIHA6IHRpbWVMb25nRm9ybWF0dGVyLFxuICBQOiBkYXRlVGltZUxvbmdGb3JtYXR0ZXJcbn07XG5leHBvcnQgZGVmYXVsdCBsb25nRm9ybWF0dGVyczsiLCIvKipcbiAqIEdvb2dsZSBDaHJvbWUgYXMgb2YgNjcuMC4zMzk2Ljg3IGludHJvZHVjZWQgdGltZXpvbmVzIHdpdGggb2Zmc2V0IHRoYXQgaW5jbHVkZXMgc2Vjb25kcy5cbiAqIFRoZXkgdXN1YWxseSBhcHBlYXIgZm9yIGRhdGVzIHRoYXQgZGVub3RlIHRpbWUgYmVmb3JlIHRoZSB0aW1lem9uZXMgd2VyZSBpbnRyb2R1Y2VkXG4gKiAoZS5nLiBmb3IgJ0V1cm9wZS9QcmFndWUnIHRpbWV6b25lIHRoZSBvZmZzZXQgaXMgR01UKzAwOjU3OjQ0IGJlZm9yZSAxIE9jdG9iZXIgMTg5MVxuICogYW5kIEdNVCswMTowMDowMCBhZnRlciB0aGF0IGRhdGUpXG4gKlxuICogRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgaW4gbWludXRlcyBhbmQgd291bGQgcmV0dXJuIDU3IGZvciB0aGUgZXhhbXBsZSBhYm92ZSxcbiAqIHdoaWNoIHdvdWxkIGxlYWQgdG8gaW5jb3JyZWN0IGNhbGN1bGF0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0YWtlcyBzZWNvbmRzIGluIGFjY291bnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZGF0ZSkge1xuICB2YXIgdXRjRGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCksIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpKTtcbiAgdXRjRGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLSB1dGNEYXRlLmdldFRpbWUoKTtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xudmFyIE1JTExJU0VDT05EU19JTl9EQVkgPSA4NjQwMDAwMDsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVUQ0RheU9mWWVhcihkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZZZWFyVGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gIHZhciBkaWZmZXJlbmNlID0gdGltZXN0YW1wIC0gc3RhcnRPZlllYXJUaW1lc3RhbXA7XG4gIHJldHVybiBNYXRoLmZsb29yKGRpZmZlcmVuY2UgLyBNSUxMSVNFQ09ORFNfSU5fREFZKSArIDE7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDSVNPV2VlayBmcm9tIFwiLi4vc3RhcnRPZlVUQ0lTT1dlZWsvaW5kZXguanNcIjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZk5leHRZZWFyID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhcik7XG4gIHZhciBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mVVRDSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyKTtcblxuICBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyICsgMTtcbiAgfSBlbHNlIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mVGhpc1llYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHllYXIgLSAxO1xuICB9XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ0lTT1dlZWsgZnJvbSBcIi4uL3N0YXJ0T2ZVVENJU09XZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ0lTT1dlZWtZZWFyIGZyb20gXCIuLi9zdGFydE9mVVRDSVNPV2Vla1llYXIvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xudmFyIE1JTExJU0VDT05EU19JTl9XRUVLID0gNjA0ODAwMDAwOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VVRDSVNPV2VlayhkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkaWZmID0gc3RhcnRPZlVUQ0lTT1dlZWsoZGF0ZSkuZ2V0VGltZSgpIC0gc3RhcnRPZlVUQ0lTT1dlZWtZZWFyKGRhdGUpLmdldFRpbWUoKTsgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50XG4gIC8vIChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdClcblxuICByZXR1cm4gTWF0aC5yb3VuZChkaWZmIC8gTUlMTElTRUNPTkRTX0lOX1dFRUspICsgMTtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENXZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vdG9JbnRlZ2VyL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIHZhciBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlcihsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA+PSAxICYmIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA8PSA3KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBmaXJzdFdlZWtPZk5leHRZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWtPZk5leHRZZWFyLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZmlyc3RXZWVrT2ZUaGlzWWVhciA9IG5ldyBEYXRlKDApO1xuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mVGhpc1llYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWtPZlRoaXNZZWFyLCBkaXJ0eU9wdGlvbnMpO1xuXG4gIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXIgKyAxO1xuICB9IGVsc2UgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDE7XG4gIH1cbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDV2VlayBmcm9tIFwiLi4vc3RhcnRPZlVUQ1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDV2Vla1llYXIgZnJvbSBcIi4uL3N0YXJ0T2ZVVENXZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG52YXIgTUlMTElTRUNPTkRTX0lOX1dFRUsgPSA2MDQ4MDAwMDA7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVVENXZWVrKGRpcnR5RGF0ZSwgb3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRpZmYgPSBzdGFydE9mVVRDV2VlayhkYXRlLCBvcHRpb25zKS5nZXRUaW1lKCkgLSBzdGFydE9mVVRDV2Vla1llYXIoZGF0ZSwgb3B0aW9ucykuZ2V0VGltZSgpOyAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIGRheXMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuICAvLyBiZWNhdXNlIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnRcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBNSUxMSVNFQ09ORFNfSU5fV0VFSykgKyAxO1xufSIsImltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENXZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDV2Vlay9pbmRleC5qc1wiOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTYW1lVVRDV2VlayhkaXJ0eURhdGVMZWZ0LCBkaXJ0eURhdGVSaWdodCwgb3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGVMZWZ0U3RhcnRPZldlZWsgPSBzdGFydE9mVVRDV2VlayhkaXJ0eURhdGVMZWZ0LCBvcHRpb25zKTtcbiAgdmFyIGRhdGVSaWdodFN0YXJ0T2ZXZWVrID0gc3RhcnRPZlVUQ1dlZWsoZGlydHlEYXRlUmlnaHQsIG9wdGlvbnMpO1xuICByZXR1cm4gZGF0ZUxlZnRTdGFydE9mV2Vlay5nZXRUaW1lKCkgPT09IGRhdGVSaWdodFN0YXJ0T2ZXZWVrLmdldFRpbWUoKTtcbn0iLCJ2YXIgcHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW5zID0gWydEJywgJ0REJ107XG52YXIgcHJvdGVjdGVkV2Vla1llYXJUb2tlbnMgPSBbJ1lZJywgJ1lZWVknXTtcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiBwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMuaW5kZXhPZih0b2tlbikgIT09IC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbih0b2tlbikge1xuICByZXR1cm4gcHJvdGVjdGVkV2Vla1llYXJUb2tlbnMuaW5kZXhPZih0b2tlbikgIT09IC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRocm93UHJvdGVjdGVkRXJyb3IodG9rZW4sIGZvcm1hdCwgaW5wdXQpIHtcbiAgaWYgKHRva2VuID09PSAnWVlZWScpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgKGluIGBcIi5jb25jYXQoZm9ybWF0LCBcImApIGZvciBmb3JtYXR0aW5nIHllYXJzIHRvIHRoZSBpbnB1dCBgXCIpLmNvbmNhdChpbnB1dCwgXCJgOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXCIpKTtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ1lZJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIChpbiBgXCIuY29uY2F0KGZvcm1hdCwgXCJgKSBmb3IgZm9ybWF0dGluZyB5ZWFycyB0byB0aGUgaW5wdXQgYFwiKS5jb25jYXQoaW5wdXQsIFwiYDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clwiKSk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdEJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCAoaW4gYFwiLmNvbmNhdChmb3JtYXQsIFwiYCkgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdG8gdGhlIGlucHV0IGBcIikuY29uY2F0KGlucHV0LCBcImA7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcIikpO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnREQnKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVc2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgKGluIGBcIi5jb25jYXQoZm9ybWF0LCBcImApIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHRvIHRoZSBpbnB1dCBgXCIpLmNvbmNhdChpbnB1dCwgXCJgOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXCIpKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVpcmVkQXJncyhyZXF1aXJlZCwgYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPCByZXF1aXJlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocmVxdWlyZWQgKyAnIGFyZ3VtZW50JyArIChyZXF1aXJlZCA+IDEgPyAncycgOiAnJykgKyAnIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJncy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxufSIsImltcG9ydCBnZXRVVENJU09XZWVrWWVhciBmcm9tIFwiLi4vZ2V0VVRDSVNPV2Vla1llYXIvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDSVNPV2VlayBmcm9tIFwiLi4vc3RhcnRPZlVUQ0lTT1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RhcnRPZlVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIHllYXIgPSBnZXRVVENJU09XZWVrWWVhcihkaXJ0eURhdGUpO1xuICB2YXIgZm91cnRoT2ZKYW51YXJ5ID0gbmV3IERhdGUoMCk7XG4gIGZvdXJ0aE9mSmFudWFyeS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgZGF0ZSA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeSk7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGFydE9mVVRDSVNPV2VlayhkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSAxO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiaW1wb3J0IGdldFVUQ1dlZWtZZWFyIGZyb20gXCIuLi9nZXRVVENXZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ1dlZWsgZnJvbSBcIi4uL3N0YXJ0T2ZVVENXZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9JbnRlZ2VyIGZyb20gXCIuLi90b0ludGVnZXIvaW5kZXguanNcIjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXJ0T2ZVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU7XG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyAxIDogdG9JbnRlZ2VyKGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciBmaXJzdFdlZWtDb250YWluc0RhdGUgPSBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA6IHRvSW50ZWdlcihvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciB5ZWFyID0gZ2V0VVRDV2Vla1llYXIoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICB2YXIgZmlyc3RXZWVrID0gbmV3IERhdGUoMCk7XG4gIGZpcnN0V2Vlay5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBmaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICBmaXJzdFdlZWsuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBkYXRlID0gc3RhcnRPZlVUQ1dlZWsoZmlyc3RXZWVrLCBkaXJ0eU9wdGlvbnMpO1xuICByZXR1cm4gZGF0ZTtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vdG9JbnRlZ2VyL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGFydE9mVVRDV2VlayhkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIGxvY2FsZVdlZWtTdGFydHNPbiA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XG4gIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlcihvcHRpb25zLndlZWtTdGFydHNPbik7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIHZhciBkaWZmID0gKGRheSA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIHdlZWtTdGFydHNPbjtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZik7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkYXRlO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvSW50ZWdlcihkaXJ0eU51bWJlcikge1xuICBpZiAoZGlydHlOdW1iZXIgPT09IG51bGwgfHwgZGlydHlOdW1iZXIgPT09IHRydWUgfHwgZGlydHlOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcik7XG59IiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgYWRkTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkLiBQb3NpdGl2ZSBkZWNpbWFscyB3aWxsIGJlIHJvdW5kZWQgdXNpbmcgYE1hdGguZmxvb3JgLCBkZWNpbWFscyBsZXNzIHRoYW4gemVybyB3aWxsIGJlIHJvdW5kZWQgdXNpbmcgYE1hdGguY2VpbGAuXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbGxpc2Vjb25kcyBhZGRlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgNzUwIG1pbGxpc2Vjb25kcyB0byAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxuICogY29uc3QgcmVzdWx0ID0gYWRkTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MzAuNzUwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciB0aW1lc3RhbXAgPSB0b0RhdGUoZGlydHlEYXRlKS5nZXRUaW1lKCk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgYW1vdW50KTtcbn0iLCJpbXBvcnQgaXNWYWxpZCBmcm9tIFwiLi4vaXNWYWxpZC9pbmRleC5qc1wiO1xuaW1wb3J0IGRlZmF1bHRMb2NhbGUgZnJvbSBcIi4uL2xvY2FsZS9lbi1VUy9pbmRleC5qc1wiO1xuaW1wb3J0IHN1Yk1pbGxpc2Vjb25kcyBmcm9tIFwiLi4vc3ViTWlsbGlzZWNvbmRzL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXR0ZXJzIGZyb20gXCIuLi9fbGliL2Zvcm1hdC9mb3JtYXR0ZXJzL2luZGV4LmpzXCI7XG5pbXBvcnQgbG9uZ0Zvcm1hdHRlcnMgZnJvbSBcIi4uL19saWIvZm9ybWF0L2xvbmdGb3JtYXR0ZXJzL2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyBmcm9tIFwiLi4vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuLCBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4sIHRocm93UHJvdGVjdGVkRXJyb3IgfSBmcm9tIFwiLi4vX2xpYi9wcm90ZWN0ZWRUb2tlbnMvaW5kZXguanNcIjtcbmltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiOyAvLyBUaGlzIFJlZ0V4cCBjb25zaXN0cyBvZiB0aHJlZSBwYXJ0cyBzZXBhcmF0ZWQgYnkgYHxgOlxuLy8gLSBbeVlRcU1Md0lkRGVjaWhIS2ttc11vIG1hdGNoZXMgYW55IGF2YWlsYWJsZSBvcmRpbmFsIG51bWJlciB0b2tlblxuLy8gICAob25lIG9mIHRoZSBjZXJ0YWluIGxldHRlcnMgZm9sbG93ZWQgYnkgYG9gKVxuLy8gLSAoXFx3KVxcMSogbWF0Y2hlcyBhbnkgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIGxldHRlclxuLy8gLSAnJyBtYXRjaGVzIHR3byBxdW90ZSBjaGFyYWN0ZXJzIGluIGEgcm93XG4vLyAtICcoJyd8W14nXSkrKCd8JCkgbWF0Y2hlcyBhbnl0aGluZyBzdXJyb3VuZGVkIGJ5IHR3byBxdW90ZSBjaGFyYWN0ZXJzICgnKSxcbi8vICAgZXhjZXB0IGEgc2luZ2xlIHF1b3RlIHN5bWJvbCwgd2hpY2ggZW5kcyB0aGUgc2VxdWVuY2UuXG4vLyAgIFR3byBxdW90ZSBjaGFyYWN0ZXJzIGRvIG5vdCBlbmQgdGhlIHNlcXVlbmNlLlxuLy8gICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBzaW5nbGUgcXVvdGVcbi8vICAgdGhlbiB0aGUgc2VxdWVuY2Ugd2lsbCBjb250aW51ZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4vLyAtIC4gbWF0Y2hlcyBhbnkgc2luZ2xlIGNoYXJhY3RlciB1bm1hdGNoZWQgYnkgcHJldmlvdXMgcGFydHMgb2YgdGhlIFJlZ0V4cHNcblxudmFyIGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvW3lZUXFNTHdJZERlY2loSEtrbXNdb3woXFx3KVxcMSp8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7IC8vIFRoaXMgUmVnRXhwIGNhdGNoZXMgc3ltYm9scyBlc2NhcGVkIGJ5IHF1b3RlcywgYW5kIGFsc29cbi8vIHNlcXVlbmNlcyBvZiBzeW1ib2xzIFAsIHAsIGFuZCB0aGUgY29tYmluYXRpb25zIGxpa2UgYFBQUFBQUFBwcHBwcGBcblxudmFyIGxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gL1ArcCt8UCt8cCt8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7XG52YXIgZXNjYXBlZFN0cmluZ1JlZ0V4cCA9IC9eJyhbXl0qPyknPyQvO1xudmFyIGRvdWJsZVF1b3RlUmVnRXhwID0gLycnL2c7XG52YXIgdW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAgPSAvW2EtekEtWl0vO1xuLyoqXG4gKiBAbmFtZSBmb3JtYXRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgRm9ybWF0IHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdC4gVGhlIHJlc3VsdCBtYXkgdmFyeSBieSBsb2NhbGUuXG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgYGZvcm1hdGAgdG9rZW5zIGRpZmZlciBmcm9tIE1vbWVudC5qcyBhbmQgb3RoZXIgbGlicmFyaWVzLlxuICogPiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogVGhlIGNoYXJhY3RlcnMgd3JhcHBlZCBiZXR3ZWVuIHR3byBzaW5nbGUgcXVvdGVzIGNoYXJhY3RlcnMgKCcpIGFyZSBlc2NhcGVkLlxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXG4gKiAoc2VlIHRoZSBsYXN0IGV4YW1wbGUpXG4gKlxuICogRm9ybWF0IG9mIHRoZSBzdHJpbmcgaXMgYmFzZWQgb24gVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0ZpZWxkX1N5bWJvbF9UYWJsZVxuICogd2l0aCBhIGZldyBhZGRpdGlvbnMgKHNlZSBub3RlIDcgYmVsb3cgdGhlIHRhYmxlKS5cbiAqXG4gKiBBY2NlcHRlZCBwYXR0ZXJuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBhdHRlcm4gfCBSZXN1bHQgZXhhbXBsZXMgICAgICAgICAgICAgICAgICAgfCBOb3RlcyB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tfFxuICogfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRy4uR0dHICB8IEFELCBCQyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0cgICAgfCBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHRyAgIHwgQSwgQiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBDYWxlbmRhciB5ZWFyICAgICAgICAgICAgICAgICAgIHwgeSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHlvICAgICAgfCA0NHRoLCAxc3QsIDB0aCwgMTd0aCAgICAgICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5ICAgICB8IDA0NCwgMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXl5eSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgIHwgWSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlvICAgICAgfCA0NHRoLCAxc3QsIDE5MDB0aCwgMjAxN3RoICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZICAgICB8IDA0NCwgMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZWSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgIHwgUiAgICAgICB8IC00MywgMCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSICAgICAgfCAtNDMsIDAwLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlIgICAgIHwgLTA0MywgMDAwLCAwMDEsIDE5MDAsIDIwMTcgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUiAgICB8IC0wMDQzLCAwMDAwLCAwMDAxLCAxOTAwLCAyMDE3ICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUlJSICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUsNyB8XG4gKiB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICAgfCB1ICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXUgICAgICB8IC00MywgMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dSAgICAgfCAtMDQzLCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1ICAgIHwgLTAwNDMsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1dXUgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSAgIHxcbiAqIHwgUXVhcnRlciAoZm9ybWF0dGluZykgICAgICAgICAgICB8IFEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRUVEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgUXVhcnRlciAoc3RhbmQtYWxvbmUpICAgICAgICAgICB8IHEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxcXEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgTW9udGggKGZvcm1hdHRpbmcpICAgICAgICAgICAgICB8IE0gICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU0gICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTSAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NTU0gICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTW9udGggKHN0YW5kLWFsb25lKSAgICAgICAgICAgICB8IEwgICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTEwgICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTCAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMTEwgICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgICB8IHcgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3byAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgd3cgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgICB8IEkgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSUkgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgICB8IGQgICAgICAgfCAxLCAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzFzdCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZGQgICAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgICB8IEQgICAgICAgfCAxLCAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgICAgfCA5ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzY1dGgsIDM2NnRoICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREQgICAgICB8IDAxLCAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERERCAgICAgfCAwMDEsIDAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBEYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgICAgIHwgRS4uRUVFICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRUVFICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICB8IGkgICAgICAgfCAxLCAyLCAzLCAuLi4sIDcgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgN3RoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWkgICAgICB8IDAxLCAwMiwgLi4uLCAwNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWkgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWlpaSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCA3ICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgfCBlICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZW8gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWUgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlZWUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoc3RhbmQtYWxvbmUpIHwgYyAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjYyAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2MgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjYyAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjY2NjICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICB8IGEuLmFhICAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWEgICAgIHwgYW0sIHBtICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYWFhICAgfCBhLCBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgfCBiLi5iYiAgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiICAgICB8IGFtLCBwbSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmIgICAgfCBhLm0uLCBwLm0uLCBub29uLCBtaWRuaWdodCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmJiYiAgIHwgYSwgcCwgbiwgbWkgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgIHwgQi4uQkJCICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkIgICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBCQkJCQiAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgIHwgaCAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAxMnRoICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBoaCAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgIHwgSCAgICAgICB8IDAsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhvICAgICAgfCAwdGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBISCAgICAgIHwgMDAsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgIHwgSyAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAwdGggICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBLSyAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAwMCAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgIHwgayAgICAgICB8IDI0LCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtvICAgICAgfCAyNHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBrayAgICAgIHwgMjQsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbSAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1vICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbSAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcyAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNvICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzcyAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgIHwgUyAgICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTICAgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1MgICAgIHwgMDAwLCAwMDEsIC4uLiwgOTk5ICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1NTUyAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvIFopICAgICAgICB8IFggICAgICAgfCAtMDgsICswNTMwLCBaICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWCAgICAgIHwgLTA4MDAsICswNTMwLCBaICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYICAgICB8IC0wODowMCwgKzA1OjMwLCBaICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFggICAgfCAtMDgwMCwgKzA1MzAsIFosICsxMjM0NTYgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFhYWCAgIHwgLTA4OjAwLCArMDU6MzAsIFosICsxMjozNDo1NiAgICAgIHwgICAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgIHwgeCAgICAgICB8IC0wOCwgKzA1MzAsICswMCAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4ICAgICAgfCAtMDgwMCwgKzA1MzAsICswMDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHggICAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eCAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAsICsxMjM0NTYgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eHh4ICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwLCArMTI6MzQ6NTYgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChHTVQpICAgICAgICAgICAgICAgICAgfCBPLi4uT09PIHwgR01ULTgsIEdNVCs1OjMwLCBHTVQrMCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgT09PTyAgICB8IEdNVC0wODowMCwgR01UKzA1OjMwLCBHTVQrMDA6MDAgICB8IDIgICAgIHxcbiAqIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pICB8IHouLi56enogfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCA2ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB6enp6ICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiw2ICAgfFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgIHwgdCAgICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHR0ICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDcgICB8XG4gKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgfCBUICAgICAgIHwgNTEyOTY5NTIwOTAwICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgVFQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgICB8IFAgICAgICAgfCAwNC8yOS8xNDUzICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUCAgICAgIHwgQXByIDI5LCAxNDUzICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQICAgICB8IEFwcmlsIDI5dGgsIDE0NTMgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUFAgICAgfCBGcmlkYXksIEFwcmlsIDI5dGgsIDE0NTMgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICAgfCBwICAgICAgIHwgMTI6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHAgICAgICB8IDEyOjAwOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcCAgICAgfCAxMjowMDowMCBBTSBHTVQrMiAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcHBwICAgIHwgMTI6MDA6MDAgQU0gR01UKzAyOjAwICAgICAgICAgICAgIHwgMiw3ICAgfFxuICogfCBDb21iaW5hdGlvbiBvZiBkYXRlIGFuZCB0aW1lICAgIHwgUHAgICAgICB8IDA0LzI5LzE0NTMsIDEyOjAwIEFNICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQcHAgICAgfCBBcHIgMjksIDE0NTMsIDEyOjAwOjAwIEFNICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBwcHAgIHwgQXByaWwgMjl0aCwgMTQ1MyBhdCAuLi4gICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUHBwcHB8IEZyaWRheSwgQXByaWwgMjl0aCwgMTQ1MyBhdCAuLi4gICB8IDIsNyAgIHxcbiAqIE5vdGVzOlxuICogMS4gXCJGb3JtYXR0aW5nXCIgdW5pdHMgKGUuZy4gZm9ybWF0dGluZyBxdWFydGVyKSBpbiB0aGUgZGVmYXVsdCBlbi1VUyBsb2NhbGVcbiAqICAgIGFyZSB0aGUgc2FtZSBhcyBcInN0YW5kLWFsb25lXCIgdW5pdHMsIGJ1dCBhcmUgZGlmZmVyZW50IGluIHNvbWUgbGFuZ3VhZ2VzLlxuICogICAgXCJGb3JtYXR0aW5nXCIgdW5pdHMgYXJlIGRlY2xpbmVkIGFjY29yZGluZyB0byB0aGUgcnVsZXMgb2YgdGhlIGxhbmd1YWdlXG4gKiAgICBpbiB0aGUgY29udGV4dCBvZiBhIGRhdGUuIFwiU3RhbmQtYWxvbmVcIiB1bml0cyBhcmUgYWx3YXlzIG5vbWluYXRpdmUgc2luZ3VsYXI6XG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBMTExMJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZCdgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBNTU1NJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZHUnYFxuICpcbiAqIDIuIEFueSBzZXF1ZW5jZSBvZiB0aGUgaWRlbnRpY2FsIGxldHRlcnMgaXMgYSBwYXR0ZXJuLCB1bmxlc3MgaXQgaXMgZXNjYXBlZCBieVxuICogICAgdGhlIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIChzZWUgYmVsb3cpLlxuICogICAgSWYgdGhlIHNlcXVlbmNlIGlzIGxvbmdlciB0aGFuIGxpc3RlZCBpbiB0YWJsZSAoZS5nLiBgRUVFRUVFRUVFRUVgKVxuICogICAgdGhlIG91dHB1dCB3aWxsIGJlIHRoZSBzYW1lIGFzIGRlZmF1bHQgcGF0dGVybiBmb3IgdGhpcyB1bml0LCB1c3VhbGx5XG4gKiAgICB0aGUgbG9uZ2VzdCBvbmUgKGluIGNhc2Ugb2YgSVNPIHdlZWtkYXlzLCBgRUVFRWApLiBEZWZhdWx0IHBhdHRlcm5zIGZvciB1bml0c1xuICogICAgYXJlIG1hcmtlZCB3aXRoIFwiMlwiIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU0nKSAvLz0+ICdOb3YnYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NJykgLy89PiAnTidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqIDMuIFNvbWUgcGF0dGVybnMgY291bGQgYmUgdW5saW1pdGVkIGxlbmd0aCAoc3VjaCBhcyBgeXl5eXl5eXlgKS5cbiAqICAgIFRoZSBvdXRwdXQgd2lsbCBiZSBwYWRkZWQgd2l0aCB6ZXJvcyB0byBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBwYXR0ZXJuLlxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAneXl5eXl5eXknKSAvLz0+ICcwMDAwMjAxNydgXG4gKlxuICogNC4gYFFRUVFRYCBhbmQgYHFxcXFxYCBjb3VsZCBiZSBub3Qgc3RyaWN0bHkgbnVtZXJpY2FsIGluIHNvbWUgbG9jYWxlcy5cbiAqICAgIFRoZXNlIHRva2VucyByZXByZXNlbnQgdGhlIHNob3J0ZXN0IGZvcm0gb2YgdGhlIHF1YXJ0ZXIuXG4gKlxuICogNS4gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIHBhdHRlcm5zIGFyZSBCLkMuIHllYXJzOlxuICpcbiAqICAgIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tfC0tLS0tfFxuICogICAgfCBBQyAxIHwgICAxIHwgICAxIHxcbiAqICAgIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gKiAgICB8IEJDIDIgfCAgIDIgfCAgLTEgfFxuICpcbiAqICAgIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcbiAqICAgIHdoaWxlIGB1dWAgcGFkcyBzaW5nbGUgZGlnaXQgeWVhcnMgdG8gMiBjaGFyYWN0ZXJzIGFuZCByZXR1cm5zIG90aGVyIHllYXJzIHVuY2hhbmdlZDpcbiAqXG4gKiAgICB8IFllYXIgfCBgeXlgIHwgYHV1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tLXwtLS0tLS18XG4gKiAgICB8IDEgICAgfCAgIDAxIHwgICAwMSB8XG4gKiAgICB8IDE0ICAgfCAgIDE0IHwgICAxNCB8XG4gKiAgICB8IDM3NiAgfCAgIDc2IHwgIDM3NiB8XG4gKiAgICB8IDE0NTMgfCAgIDUzIHwgMTQ1MyB8XG4gKlxuICogICAgVGhlIHNhbWUgZGlmZmVyZW5jZSBpcyB0cnVlIGZvciBsb2NhbCBhbmQgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIChgWWAgYW5kIGBSYCksXG4gKiAgICBleGNlcHQgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhcnMgYXJlIGRlcGVuZGVudCBvbiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gXG4gKiAgICBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAoY29tcGFyZSBbZ2V0SVNPV2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0SVNPV2Vla1llYXJ9XG4gKiAgICBhbmQgW2dldFdlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL2dldFdlZWtZZWFyfSkuXG4gKlxuICogNi4gU3BlY2lmaWMgbm9uLWxvY2F0aW9uIHRpbWV6b25lcyBhcmUgY3VycmVudGx5IHVuYXZhaWxhYmxlIGluIGBkYXRlLWZuc2AsXG4gKiAgICBzbyByaWdodCBub3cgdGhlc2UgdG9rZW5zIGZhbGwgYmFjayB0byBHTVQgdGltZXpvbmVzLlxuICpcbiAqIDcuIFRoZXNlIHBhdHRlcm5zIGFyZSBub3QgaW4gdGhlIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqICAgIC0gYGlgOiBJU08gZGF5IG9mIHdlZWtcbiAqICAgIC0gYElgOiBJU08gd2VlayBvZiB5ZWFyXG4gKiAgICAtIGBSYDogSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqICAgIC0gYHRgOiBzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgVGA6IG1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAqICAgIC0gYG9gOiBvcmRpbmFsIG51bWJlciBtb2RpZmllclxuICogICAgLSBgUGA6IGxvbmcgbG9jYWxpemVkIGRhdGVcbiAqICAgIC0gYHBgOiBsb25nIGxvY2FsaXplZCB0aW1lXG4gKlxuICogOC4gYFlZYCBhbmQgYFlZWVlgIHRva2VucyByZXByZXNlbnQgd2Vlay1udW1iZXJpbmcgeWVhcnMgYnV0IHRoZXkgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggeWVhcnMuXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogOS4gYERgIGFuZCBgRERgIHRva2VucyByZXByZXNlbnQgZGF5cyBvZiB0aGUgeWVhciBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCBkYXlzIG9mIHRoZSBtb250aC5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgbm93IHJlcXVpcmVkIGZvciB0aGUgc2FrZSBvZiBleHBsaWNpdG5lc3MuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIEJlZm9yZSB2Mi4wLjBcbiAqICAgZm9ybWF0KG5ldyBEYXRlKDIwMTYsIDAsIDEpKVxuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICogICBmb3JtYXQobmV3IERhdGUoMjAxNiwgMCwgMSksIFwieXl5eS1NTS1kZCdUJ0hIOm1tOnNzLlNTU3h4eFwiKVxuICogICBgYGBcbiAqXG4gKiAtIE5ldyBmb3JtYXQgc3RyaW5nIEFQSSBmb3IgYGZvcm1hdGAgZnVuY3Rpb25cbiAqICAgd2hpY2ggaXMgYmFzZWQgb24gW1VuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNV0oaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0ZpZWxkX1N5bWJvbF9UYWJsZSkuXG4gKiAgIFNlZSBbdGhpcyBwb3N0XShodHRwczovL2Jsb2cuZGF0ZS1mbnMub3JnL3Bvc3QvdW5pY29kZS10b2tlbnMtaW4tZGF0ZS1mbnMtdjItc3JlYXR5a2k5MWpnKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIC0gQ2hhcmFjdGVycyBhcmUgbm93IGVzY2FwZWQgdXNpbmcgc2luZ2xlIHF1b3RlIHN5bWJvbHMgKGAnYCkgaW5zdGVhZCBvZiBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XG4gKiBAcGFyYW0gezB8MXwyfDN8NHw1fDZ9IFtvcHRpb25zLndlZWtTdGFydHNPbj0wXSAtIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwIC0gU3VuZGF5KVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZT0xXSAtIHRoZSBkYXkgb2YgSmFudWFyeSwgd2hpY2ggaXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zPWZhbHNlXSAtIGlmIHRydWUsIGFsbG93cyB1c2FnZSBvZiB0aGUgd2Vlay1udW1iZXJpbmcgeWVhciB0b2tlbnMgYFlZYCBhbmQgYFlZWVlgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSBkYXkgb2YgeWVhciB0b2tlbnMgYERgIGFuZCBgRERgO1xuICogICBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgZGF0ZWAgbXVzdCBub3QgYmUgSW52YWxpZCBEYXRlXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbG9jYWxpemVgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgZm9ybWF0TG9uZ2AgcHJvcGVydHlcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLndlZWtTdGFydHNPbmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDZcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDdcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnMgdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IHVzZSBgeXlgIGluc3RlYWQgb2YgYFlZYCBmb3IgZm9ybWF0dGluZyB5ZWFycyB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aCB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGBkZGAgaW5zdGVhZCBvZiBgRERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBmb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDExIEZlYnJ1YXJ5IDIwMTQgaW4gbWlkZGxlLWVuZGlhbiBmb3JtYXQ6XG4gKiB2YXIgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDEsIDExKSwgJ01NL2RkL3l5eXknKVxuICogLy89PiAnMDIvMTEvMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDIgSnVseSAyMDE0IGluIEVzcGVyYW50bzpcbiAqIGltcG9ydCB7IGVvTG9jYWxlIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogdmFyIHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgXCJkbyAnZGUnIE1NTU0geXl5eVwiLCB7XG4gKiAgIGxvY2FsZTogZW9Mb2NhbGVcbiAqIH0pXG4gKiAvLz0+ICcyLWEgZGUganVsaW8gMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXNjYXBlIHN0cmluZyBieSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyczpcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQobmV3IERhdGUoMjAxNCwgNiwgMiwgMTUpLCBcImggJ28nJ2Nsb2NrJ1wiKVxuICogLy89PiBcIjMgbydjbG9ja1wiXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0KGRpcnR5RGF0ZSwgZGlydHlGb3JtYXRTdHIsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGZvcm1hdFN0ciA9IFN0cmluZyhkaXJ0eUZvcm1hdFN0cik7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgZGVmYXVsdExvY2FsZTtcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAxIGFuZCA3IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoIShmaXJzdFdlZWtDb250YWluc0RhdGUgPj0gMSAmJiBmaXJzdFdlZWtDb250YWluc0RhdGUgPD0gNykpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZmlyc3RXZWVrQ29udGFpbnNEYXRlIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA3IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xuICB2YXIgd2Vla1N0YXJ0c09uID0gb3B0aW9ucy53ZWVrU3RhcnRzT24gPT0gbnVsbCA/IGRlZmF1bHRXZWVrU3RhcnRzT24gOiB0b0ludGVnZXIob3B0aW9ucy53ZWVrU3RhcnRzT24pOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKHdlZWtTdGFydHNPbiA+PSAwICYmIHdlZWtTdGFydHNPbiA8PSA2KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIGlmICghbG9jYWxlLmxvY2FsaXplKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xvY2FsZSBtdXN0IGNvbnRhaW4gbG9jYWxpemUgcHJvcGVydHknKTtcbiAgfVxuXG4gIGlmICghbG9jYWxlLmZvcm1hdExvbmcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5Jyk7XG4gIH1cblxuICB2YXIgb3JpZ2luYWxEYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG5cbiAgaWYgKCFpc1ZhbGlkKG9yaWdpbmFsRGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gIH0gLy8gQ29udmVydCB0aGUgZGF0ZSBpbiBzeXN0ZW0gdGltZXpvbmUgdG8gdGhlIHNhbWUgZGF0ZSBpbiBVVEMrMDA6MDAgdGltZXpvbmUuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gVVRDIGZ1bmN0aW9ucyB3aWxsIGJlIGltcGxlbWVudGVkLCBsb2NhbGVzIHdpbGwgYmUgY29tcGF0aWJsZSB3aXRoIHRoZW0uXG4gIC8vIFNlZSBhbiBpc3N1ZSBhYm91dCBVVEMgZnVuY3Rpb25zOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5cbiAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhvcmlnaW5hbERhdGUpO1xuICB2YXIgdXRjRGF0ZSA9IHN1Yk1pbGxpc2Vjb25kcyhvcmlnaW5hbERhdGUsIHRpbWV6b25lT2Zmc2V0KTtcbiAgdmFyIGZvcm1hdHRlck9wdGlvbnMgPSB7XG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiBmaXJzdFdlZWtDb250YWluc0RhdGUsXG4gICAgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24sXG4gICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgX29yaWdpbmFsRGF0ZTogb3JpZ2luYWxEYXRlXG4gIH07XG4gIHZhciByZXN1bHQgPSBmb3JtYXRTdHIubWF0Y2gobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHApLm1hcChmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gc3Vic3RyaW5nWzBdO1xuXG4gICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSAncCcgfHwgZmlyc3RDaGFyYWN0ZXIgPT09ICdQJykge1xuICAgICAgdmFyIGxvbmdGb3JtYXR0ZXIgPSBsb25nRm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XG4gICAgICByZXR1cm4gbG9uZ0Zvcm1hdHRlcihzdWJzdHJpbmcsIGxvY2FsZS5mb3JtYXRMb25nLCBmb3JtYXR0ZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic3RyaW5nO1xuICB9KS5qb2luKCcnKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zUmVnRXhwKS5tYXAoZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgIC8vIFJlcGxhY2UgdHdvIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJcbiAgICBpZiAoc3Vic3RyaW5nID09PSBcIicnXCIpIHtcbiAgICAgIHJldHVybiBcIidcIjtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICByZXR1cm4gY2xlYW5Fc2NhcGVkU3RyaW5nKHN1YnN0cmluZyk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHRlcnNbZmlyc3RDaGFyYWN0ZXJdO1xuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgaWYgKCFvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VucyAmJiBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4oc3Vic3RyaW5nKSkge1xuICAgICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHN1YnN0cmluZywgZGlydHlGb3JtYXRTdHIsIGRpcnR5RGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4oc3Vic3RyaW5nKSkge1xuICAgICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHN1YnN0cmluZywgZGlydHlGb3JtYXRTdHIsIGRpcnR5RGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JtYXR0ZXIodXRjRGF0ZSwgc3Vic3RyaW5nLCBsb2NhbGUubG9jYWxpemUsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChmaXJzdENoYXJhY3Rlci5tYXRjaCh1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdGb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXIgYCcgKyBmaXJzdENoYXJhY3RlciArICdgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnN0cmluZztcbiAgfSkuam9pbignJyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cClbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXCInXCIpO1xufSIsImltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGlzRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gdmFsdWUgYSBkYXRlP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLiBUaGUgZnVuY3Rpb24gd29ya3MgZm9yIGRhdGVzIHRyYW5zZmVycmVkIGFjcm9zcyBpZnJhbWVzLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGF0ZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgYSB2YWxpZCBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNEYXRlKG5ldyBEYXRlKCkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGFuIGludmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZShuZXcgRGF0ZShOYU4pKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBzb21lIHZhbHVlOlxuICogY29uc3QgcmVzdWx0ID0gaXNEYXRlKCcyMDE0LTAyLTMxJylcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGFuIG9iamVjdDpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZSh7fSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7XG59IiwiaW1wb3J0IGlzRGF0ZSBmcm9tIFwiLi4vaXNEYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGlzVmFsaWRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdmFsaWQ/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIGZhbHNlIGlmIGFyZ3VtZW50IGlzIEludmFsaWQgRGF0ZSBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gKiBBcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gRGF0ZSB1c2luZyBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIE5vdyBgaXNWYWxpZGAgZG9lc24ndCB0aHJvdyBhbiBleGNlcHRpb25cbiAqICAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICogICBJbnN0ZWFkLCBhcmd1bWVudCBpcyBjb252ZXJ0ZWQgYmVmb3JlaGFuZCB1c2luZyBgdG9EYXRlYC5cbiAqXG4gKiAgIEV4YW1wbGVzOlxuICpcbiAqICAgfCBgaXNWYWxpZGAgYXJndW1lbnQgICAgICAgIHwgQmVmb3JlIHYyLjAuMCB8IHYyLjAuMCBvbndhcmQgfFxuICogICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS18XG4gKiAgIHwgYG5ldyBEYXRlKClgICAgICAgICAgICAgICB8IGB0cnVlYCAgICAgICAgfCBgdHJ1ZWAgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoJzIwMTYtMDEtMDEnKWAgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZSgnJylgICAgICAgICAgICAgfCBgZmFsc2VgICAgICAgIHwgYGZhbHNlYCAgICAgICB8XG4gKiAgIHwgYG5ldyBEYXRlKDE0ODgzNzA4MzUwODEpYCB8IGB0cnVlYCAgICAgICAgfCBgdHJ1ZWAgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoTmFOKWAgICAgICAgICAgIHwgYGZhbHNlYCAgICAgICB8IGBmYWxzZWAgICAgICAgfFxuICogICB8IGAnMjAxNi0wMS0wMSdgICAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYGZhbHNlYCAgICAgICB8XG4gKiAgIHwgYCcnYCAgICAgICAgICAgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgMTQ4ODM3MDgzNTA4MWAgICAgICAgICAgIHwgYFR5cGVFcnJvcmAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBOYU5gICAgICAgICAgICAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYGZhbHNlYCAgICAgICB8XG4gKlxuICogICBXZSBpbnRyb2R1Y2UgdGhpcyBjaGFuZ2UgdG8gbWFrZSAqZGF0ZS1mbnMqIGNvbnNpc3RlbnQgd2l0aCBFQ01BU2NyaXB0IGJlaGF2aW9yXG4gKiAgIHRoYXQgdHJ5IHRvIGNvZXJjZSBhcmd1bWVudHMgdG8gdGhlIGV4cGVjdGVkIHR5cGVcbiAqICAgKHdoaWNoIGlzIGFsc28gdGhlIGNhc2Ugd2l0aCBvdGhlciAqZGF0ZS1mbnMqIGZ1bmN0aW9ucykuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRlIC0gdGhlIGRhdGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZGF0ZSBpcyB2YWxpZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoMjAxNCwgMSwgMzEpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsdWUsIGNvbnZlcnRhYmxlIGludG8gYSBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNWYWxpZCgxMzkzODA0ODAwMDAwKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgaW52YWxpZCBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgnJykpXG4gKiAvLz0+IGZhbHNlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNWYWxpZChkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKCFpc0RhdGUoZGlydHlEYXRlKSAmJiB0eXBlb2YgZGlydHlEYXRlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHJldHVybiAhaXNOYU4oTnVtYmVyKGRhdGUpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZvcm1hdExvbmdGbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIC8vIFRPRE86IFJlbW92ZSBTdHJpbmcoKVxuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICB2YXIgZm9ybWF0ID0gYXJncy5mb3JtYXRzW3dpZHRoXSB8fCBhcmdzLmZvcm1hdHNbYXJncy5kZWZhdWx0V2lkdGhdO1xuICAgIHJldHVybiBmb3JtYXQ7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRMb2NhbGl6ZUZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eUluZGV4LCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCA/IFN0cmluZyhvcHRpb25zLmNvbnRleHQpIDogJ3N0YW5kYWxvbmUnO1xuICAgIHZhciB2YWx1ZXNBcnJheTtcblxuICAgIGlmIChjb250ZXh0ID09PSAnZm9ybWF0dGluZycgJiYgYXJncy5mb3JtYXR0aW5nVmFsdWVzKSB7XG4gICAgICB2YXIgZGVmYXVsdFdpZHRoID0gYXJncy5kZWZhdWx0Rm9ybWF0dGluZ1dpZHRoIHx8IGFyZ3MuZGVmYXVsdFdpZHRoO1xuICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGRlZmF1bHRXaWR0aDtcbiAgICAgIHZhbHVlc0FycmF5ID0gYXJncy5mb3JtYXR0aW5nVmFsdWVzW3dpZHRoXSB8fCBhcmdzLmZvcm1hdHRpbmdWYWx1ZXNbZGVmYXVsdFdpZHRoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kZWZhdWx0V2lkdGggPSBhcmdzLmRlZmF1bHRXaWR0aDtcblxuICAgICAgdmFyIF93aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcblxuICAgICAgdmFsdWVzQXJyYXkgPSBhcmdzLnZhbHVlc1tfd2lkdGhdIHx8IGFyZ3MudmFsdWVzW19kZWZhdWx0V2lkdGhdO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGFyZ3MuYXJndW1lbnRDYWxsYmFjayA/IGFyZ3MuYXJndW1lbnRDYWxsYmFjayhkaXJ0eUluZGV4KSA6IGRpcnR5SW5kZXg7IC8vIEB0cy1pZ25vcmU6IEZvciBzb21lIHJlYXNvbiBUeXBlU2NyaXB0IGp1c3QgZG9uJ3Qgd2FudCB0byBtYXRjaCBpdCwgbm8gbWF0dGVyIGhvdyBoYXJkIHdlIHRyeS4gSSBjaGFsbGVuZ2UgeW91IHRvIHRyeSB0byByZW1vdmUgaXQhXG5cbiAgICByZXR1cm4gdmFsdWVzQXJyYXlbaW5kZXhdO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkTWF0Y2hGbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgdmFyIG1hdGNoUGF0dGVybiA9IHdpZHRoICYmIGFyZ3MubWF0Y2hQYXR0ZXJuc1t3aWR0aF0gfHwgYXJncy5tYXRjaFBhdHRlcm5zW2FyZ3MuZGVmYXVsdE1hdGNoV2lkdGhdO1xuICAgIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChtYXRjaFBhdHRlcm4pO1xuXG4gICAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWRTdHJpbmcgPSBtYXRjaFJlc3VsdFswXTtcbiAgICB2YXIgcGFyc2VQYXR0ZXJucyA9IHdpZHRoICYmIGFyZ3MucGFyc2VQYXR0ZXJuc1t3aWR0aF0gfHwgYXJncy5wYXJzZVBhdHRlcm5zW2FyZ3MuZGVmYXVsdFBhcnNlV2lkdGhdO1xuICAgIHZhciBrZXkgPSBBcnJheS5pc0FycmF5KHBhcnNlUGF0dGVybnMpID8gZmluZEluZGV4KHBhcnNlUGF0dGVybnMsIGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG1hdGNoZWRTdHJpbmcpO1xuICAgIH0pIDogZmluZEtleShwYXJzZVBhdHRlcm5zLCBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChtYXRjaGVkU3RyaW5nKTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2sgPyBhcmdzLnZhbHVlQ2FsbGJhY2soa2V5KSA6IGtleTtcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFjayA/IG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB2YXIgcmVzdCA9IHN0cmluZy5zbGljZShtYXRjaGVkU3RyaW5nLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHJlc3Q6IHJlc3RcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkgJiYgcHJlZGljYXRlKG9iamVjdFtrZXldKSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBrZXkgPSAwOyBrZXkgPCBhcnJheS5sZW5ndGg7IGtleSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtrZXldKSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2goYXJncy5tYXRjaFBhdHRlcm4pO1xuICAgIGlmICghbWF0Y2hSZXN1bHQpIHJldHVybiBudWxsO1xuICAgIHZhciBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MucGFyc2VQYXR0ZXJuKTtcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2sgPyBhcmdzLnZhbHVlQ2FsbGJhY2socGFyc2VSZXN1bHRbMF0pIDogcGFyc2VSZXN1bHRbMF07XG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG4gICAgdmFyIHJlc3QgPSBzdHJpbmcuc2xpY2UobWF0Y2hlZFN0cmluZy5sZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICByZXN0OiByZXN0XG4gICAgfTtcbiAgfTtcbn0iLCJ2YXIgZm9ybWF0RGlzdGFuY2VMb2NhbGUgPSB7XG4gIGxlc3NUaGFuWFNlY29uZHM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICd3ZW5pZ2VyIGFscyAxIFNla3VuZGUnLFxuICAgICAgb3RoZXI6ICd3ZW5pZ2VyIGFscyB7e2NvdW50fX0gU2VrdW5kZW4nXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJ3dlbmlnZXIgYWxzIDEgU2VrdW5kZScsXG4gICAgICBvdGhlcjogJ3dlbmlnZXIgYWxzIHt7Y291bnR9fSBTZWt1bmRlbidcbiAgICB9XG4gIH0sXG4gIHhTZWNvbmRzOiB7XG4gICAgc3RhbmRhbG9uZToge1xuICAgICAgb25lOiAnMSBTZWt1bmRlJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IFNla3VuZGVuJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICcxIFNla3VuZGUnLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gU2VrdW5kZW4nXG4gICAgfVxuICB9LFxuICBoYWxmQU1pbnV0ZToge1xuICAgIHN0YW5kYWxvbmU6ICdoYWxiZSBNaW51dGUnLFxuICAgIHdpdGhQcmVwb3NpdGlvbjogJ2hhbGJlbiBNaW51dGUnXG4gIH0sXG4gIGxlc3NUaGFuWE1pbnV0ZXM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICd3ZW5pZ2VyIGFscyAxIE1pbnV0ZScsXG4gICAgICBvdGhlcjogJ3dlbmlnZXIgYWxzIHt7Y291bnR9fSBNaW51dGVuJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICd3ZW5pZ2VyIGFscyAxIE1pbnV0ZScsXG4gICAgICBvdGhlcjogJ3dlbmlnZXIgYWxzIHt7Y291bnR9fSBNaW51dGVuJ1xuICAgIH1cbiAgfSxcbiAgeE1pbnV0ZXM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICcxIE1pbnV0ZScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBNaW51dGVuJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICcxIE1pbnV0ZScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBNaW51dGVuJ1xuICAgIH1cbiAgfSxcbiAgYWJvdXRYSG91cnM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICdldHdhIDEgU3R1bmRlJyxcbiAgICAgIG90aGVyOiAnZXR3YSB7e2NvdW50fX0gU3R1bmRlbidcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnZXR3YSAxIFN0dW5kZScsXG4gICAgICBvdGhlcjogJ2V0d2Ege3tjb3VudH19IFN0dW5kZW4nXG4gICAgfVxuICB9LFxuICB4SG91cnM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICcxIFN0dW5kZScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBTdHVuZGVuJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICcxIFN0dW5kZScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBTdHVuZGVuJ1xuICAgIH1cbiAgfSxcbiAgeERheXM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICcxIFRhZycsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBUYWdlJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICcxIFRhZycsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBUYWdlbidcbiAgICB9XG4gIH0sXG4gIGFib3V0WFdlZWtzOiB7XG4gICAgc3RhbmRhbG9uZToge1xuICAgICAgb25lOiAnZXR3YSAxIFdvY2hlJyxcbiAgICAgIG90aGVyOiAnZXR3YSB7e2NvdW50fX0gV29jaGVuJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICdldHdhIDEgV29jaGUnLFxuICAgICAgb3RoZXI6ICdldHdhIHt7Y291bnR9fSBXb2NoZW4nXG4gICAgfVxuICB9LFxuICB4V2Vla3M6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICcxIFdvY2hlJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IFdvY2hlbidcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnMSBXb2NoZScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBXb2NoZW4nXG4gICAgfVxuICB9LFxuICBhYm91dFhNb250aHM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICdldHdhIDEgTW9uYXQnLFxuICAgICAgb3RoZXI6ICdldHdhIHt7Y291bnR9fSBNb25hdGUnXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJ2V0d2EgMSBNb25hdCcsXG4gICAgICBvdGhlcjogJ2V0d2Ege3tjb3VudH19IE1vbmF0ZW4nXG4gICAgfVxuICB9LFxuICB4TW9udGhzOiB7XG4gICAgc3RhbmRhbG9uZToge1xuICAgICAgb25lOiAnMSBNb25hdCcsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBNb25hdGUnXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJzEgTW9uYXQnLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gTW9uYXRlbidcbiAgICB9XG4gIH0sXG4gIGFib3V0WFllYXJzOiB7XG4gICAgc3RhbmRhbG9uZToge1xuICAgICAgb25lOiAnZXR3YSAxIEphaHInLFxuICAgICAgb3RoZXI6ICdldHdhIHt7Y291bnR9fSBKYWhyZSdcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnZXR3YSAxIEphaHInLFxuICAgICAgb3RoZXI6ICdldHdhIHt7Y291bnR9fSBKYWhyZW4nXG4gICAgfVxuICB9LFxuICB4WWVhcnM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICcxIEphaHInLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gSmFocmUnXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJzEgSmFocicsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBKYWhyZW4nXG4gICAgfVxuICB9LFxuICBvdmVyWFllYXJzOiB7XG4gICAgc3RhbmRhbG9uZToge1xuICAgICAgb25lOiAnbWVociBhbHMgMSBKYWhyJyxcbiAgICAgIG90aGVyOiAnbWVociBhbHMge3tjb3VudH19IEphaHJlJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICdtZWhyIGFscyAxIEphaHInLFxuICAgICAgb3RoZXI6ICdtZWhyIGFscyB7e2NvdW50fX0gSmFocmVuJ1xuICAgIH1cbiAgfSxcbiAgYWxtb3N0WFllYXJzOiB7XG4gICAgc3RhbmRhbG9uZToge1xuICAgICAgb25lOiAnZmFzdCAxIEphaHInLFxuICAgICAgb3RoZXI6ICdmYXN0IHt7Y291bnR9fSBKYWhyZSdcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnZmFzdCAxIEphaHInLFxuICAgICAgb3RoZXI6ICdmYXN0IHt7Y291bnR9fSBKYWhyZW4nXG4gICAgfVxuICB9XG59O1xuXG52YXIgZm9ybWF0RGlzdGFuY2UgPSBmdW5jdGlvbiAodG9rZW4sIGNvdW50LCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQ7XG4gIHZhciB0b2tlblZhbHVlID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5hZGRTdWZmaXggPyBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0ud2l0aFByZXBvc2l0aW9uIDogZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLnN0YW5kYWxvbmU7XG5cbiAgaWYgKHR5cGVvZiB0b2tlblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWU7XG4gIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIFN0cmluZyhjb3VudCkpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiAmJiBvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2luICcgKyByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAndm9yICcgKyByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdERpc3RhbmNlOyIsImltcG9ydCBidWlsZEZvcm1hdExvbmdGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZEZvcm1hdExvbmdGbi9pbmRleC5qc1wiO1xuLy8gRElOIDUwMDg6IGh0dHBzOi8vZGUud2lraXBlZGlhLm9yZy93aWtpL0RhdHVtc2Zvcm1hdCNESU5fNTAwOFxudmFyIGRhdGVGb3JtYXRzID0ge1xuICBmdWxsOiAnRUVFRSwgZG8gTU1NTSB5JyxcbiAgLy8gTW9udGFnLCA3LiBKYW51YXIgMjAxOFxuICBsb25nOiAnZG8gTU1NTSB5JyxcbiAgLy8gNy4gSmFudWFyIDIwMThcbiAgbWVkaXVtOiAnZG8gTU1NIHknLFxuICAvLyA3LiBKYW4uIDIwMThcbiAgc2hvcnQ6ICdkZC5NTS55JyAvLyAwNy4wMS4yMDE4XG5cbn07XG52YXIgdGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6ICdISDptbTpzcyB6enp6JyxcbiAgbG9uZzogJ0hIOm1tOnNzIHonLFxuICBtZWRpdW06ICdISDptbTpzcycsXG4gIHNob3J0OiAnSEg6bW0nXG59O1xudmFyIGRhdGVUaW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogXCJ7e2RhdGV9fSAndW0nIHt7dGltZX19XCIsXG4gIGxvbmc6IFwie3tkYXRlfX0gJ3VtJyB7e3RpbWV9fVwiLFxuICBtZWRpdW06ICd7e2RhdGV9fSB7e3RpbWV9fScsXG4gIHNob3J0OiAne3tkYXRlfX0ge3t0aW1lfX0nXG59O1xudmFyIGZvcm1hdExvbmcgPSB7XG4gIGRhdGU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgdGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IHRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pLFxuICBkYXRlVGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVUaW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdExvbmc7IiwidmFyIGZvcm1hdFJlbGF0aXZlTG9jYWxlID0ge1xuICBsYXN0V2VlazogXCInbGV0enRlbicgZWVlZSAndW0nIHBcIixcbiAgeWVzdGVyZGF5OiBcIidnZXN0ZXJuIHVtJyBwXCIsXG4gIHRvZGF5OiBcIidoZXV0ZSB1bScgcFwiLFxuICB0b21vcnJvdzogXCInbW9yZ2VuIHVtJyBwXCIsXG4gIG5leHRXZWVrOiBcImVlZWUgJ3VtJyBwXCIsXG4gIG90aGVyOiAnUCdcbn07XG5cbnZhciBmb3JtYXRSZWxhdGl2ZSA9IGZ1bmN0aW9uICh0b2tlbiwgX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMpIHtcbiAgcmV0dXJuIGZvcm1hdFJlbGF0aXZlTG9jYWxlW3Rva2VuXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdFJlbGF0aXZlOyIsImltcG9ydCBidWlsZExvY2FsaXplRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRMb2NhbGl6ZUZuL2luZGV4LmpzXCI7XG52YXIgZXJhVmFsdWVzID0ge1xuICBuYXJyb3c6IFsndi5DaHIuJywgJ24uQ2hyLiddLFxuICBhYmJyZXZpYXRlZDogWyd2LkNoci4nLCAnbi5DaHIuJ10sXG4gIHdpZGU6IFsndm9yIENocmlzdHVzJywgJ25hY2ggQ2hyaXN0dXMnXVxufTtcbnZhciBxdWFydGVyVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnMScsICcyJywgJzMnLCAnNCddLFxuICBhYmJyZXZpYXRlZDogWydRMScsICdRMicsICdRMycsICdRNCddLFxuICB3aWRlOiBbJzEuIFF1YXJ0YWwnLCAnMi4gUXVhcnRhbCcsICczLiBRdWFydGFsJywgJzQuIFF1YXJ0YWwnXVxufTsgLy8gTm90ZTogaW4gR2VybWFuLCB0aGUgbmFtZXMgb2YgZGF5cyBvZiB0aGUgd2VlayBhbmQgbW9udGhzIGFyZSBjYXBpdGFsaXplZC5cbi8vIElmIHlvdSBhcmUgbWFraW5nIGEgbmV3IGxvY2FsZSBiYXNlZCBvbiB0aGlzIG9uZSwgY2hlY2sgaWYgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgdGhlIGxhbmd1YWdlIHlvdSdyZSB3b3JraW5nIG9uLlxuLy8gR2VuZXJhbGx5LCBmb3JtYXR0ZWQgZGF0ZXMgc2hvdWxkIGxvb2sgbGlrZSB0aGV5IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgc2VudGVuY2UsXG4vLyBlLmcuIGluIFNwYW5pc2ggbGFuZ3VhZ2UgdGhlIHdlZWtkYXlzIGFuZCBtb250aHMgc2hvdWxkIGJlIGluIHRoZSBsb3dlcmNhc2UuXG5cbnZhciBtb250aFZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ0onLCAnRicsICdNJywgJ0EnLCAnTScsICdKJywgJ0onLCAnQScsICdTJywgJ08nLCAnTicsICdEJ10sXG4gIGFiYnJldmlhdGVkOiBbJ0phbicsICdGZWInLCAnTcOkcicsICdBcHInLCAnTWFpJywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPa3QnLCAnTm92JywgJ0RleiddLFxuICB3aWRlOiBbJ0phbnVhcicsICdGZWJydWFyJywgJ03DpHJ6JywgJ0FwcmlsJywgJ01haScsICdKdW5pJywgJ0p1bGknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPa3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlemVtYmVyJ11cbn07IC8vIGh0dHBzOi8vc3QudW5pY29kZS5vcmcvY2xkci1hcHBzL3YjL2RlL0dyZWdvcmlhbi9cblxudmFyIGZvcm1hdHRpbmdNb250aFZhbHVlcyA9IHtcbiAgbmFycm93OiBtb250aFZhbHVlcy5uYXJyb3csXG4gIGFiYnJldmlhdGVkOiBbJ0phbi4nLCAnRmViLicsICdNw6RyeicsICdBcHIuJywgJ01haScsICdKdW5pJywgJ0p1bGknLCAnQXVnLicsICdTZXAuJywgJ09rdC4nLCAnTm92LicsICdEZXouJ10sXG4gIHdpZGU6IG1vbnRoVmFsdWVzLndpZGVcbn07XG52YXIgZGF5VmFsdWVzID0ge1xuICBuYXJyb3c6IFsnUycsICdNJywgJ0QnLCAnTScsICdEJywgJ0YnLCAnUyddLFxuICBzaG9ydDogWydTbycsICdNbycsICdEaScsICdNaScsICdEbycsICdGcicsICdTYSddLFxuICBhYmJyZXZpYXRlZDogWydTby4nLCAnTW8uJywgJ0RpLicsICdNaS4nLCAnRG8uJywgJ0ZyLicsICdTYS4nXSxcbiAgd2lkZTogWydTb25udGFnJywgJ01vbnRhZycsICdEaWVuc3RhZycsICdNaXR0d29jaCcsICdEb25uZXJzdGFnJywgJ0ZyZWl0YWcnLCAnU2Ftc3RhZyddXG59OyAvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9jbGRyL2NoYXJ0cy8zMi9zdW1tYXJ5L2RlLmh0bWwjMTg4MVxuXG52YXIgZGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ3ZtLicsXG4gICAgcG06ICdubS4nLFxuICAgIG1pZG5pZ2h0OiAnTWl0dGVybmFjaHQnLFxuICAgIG5vb246ICdNaXR0YWcnLFxuICAgIG1vcm5pbmc6ICdNb3JnZW4nLFxuICAgIGFmdGVybm9vbjogJ05hY2htLicsXG4gICAgZXZlbmluZzogJ0FiZW5kJyxcbiAgICBuaWdodDogJ05hY2h0J1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAndm9ybS4nLFxuICAgIHBtOiAnbmFjaG0uJyxcbiAgICBtaWRuaWdodDogJ01pdHRlcm5hY2h0JyxcbiAgICBub29uOiAnTWl0dGFnJyxcbiAgICBtb3JuaW5nOiAnTW9yZ2VuJyxcbiAgICBhZnRlcm5vb246ICdOYWNobWl0dGFnJyxcbiAgICBldmVuaW5nOiAnQWJlbmQnLFxuICAgIG5pZ2h0OiAnTmFjaHQnXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogJ3Zvcm1pdHRhZ3MnLFxuICAgIHBtOiAnbmFjaG1pdHRhZ3MnLFxuICAgIG1pZG5pZ2h0OiAnTWl0dGVybmFjaHQnLFxuICAgIG5vb246ICdNaXR0YWcnLFxuICAgIG1vcm5pbmc6ICdNb3JnZW4nLFxuICAgIGFmdGVybm9vbjogJ05hY2htaXR0YWcnLFxuICAgIGV2ZW5pbmc6ICdBYmVuZCcsXG4gICAgbmlnaHQ6ICdOYWNodCdcbiAgfVxufTtcbnZhciBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ3ZtLicsXG4gICAgcG06ICdubS4nLFxuICAgIG1pZG5pZ2h0OiAnTWl0dGVybmFjaHQnLFxuICAgIG5vb246ICdNaXR0YWcnLFxuICAgIG1vcm5pbmc6ICdtb3JnZW5zJyxcbiAgICBhZnRlcm5vb246ICduYWNobS4nLFxuICAgIGV2ZW5pbmc6ICdhYmVuZHMnLFxuICAgIG5pZ2h0OiAnbmFjaHRzJ1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAndm9ybS4nLFxuICAgIHBtOiAnbmFjaG0uJyxcbiAgICBtaWRuaWdodDogJ01pdHRlcm5hY2h0JyxcbiAgICBub29uOiAnTWl0dGFnJyxcbiAgICBtb3JuaW5nOiAnbW9yZ2VucycsXG4gICAgYWZ0ZXJub29uOiAnbmFjaG1pdHRhZ3MnLFxuICAgIGV2ZW5pbmc6ICdhYmVuZHMnLFxuICAgIG5pZ2h0OiAnbmFjaHRzJ1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICd2b3JtaXR0YWdzJyxcbiAgICBwbTogJ25hY2htaXR0YWdzJyxcbiAgICBtaWRuaWdodDogJ01pdHRlcm5hY2h0JyxcbiAgICBub29uOiAnTWl0dGFnJyxcbiAgICBtb3JuaW5nOiAnbW9yZ2VucycsXG4gICAgYWZ0ZXJub29uOiAnbmFjaG1pdHRhZ3MnLFxuICAgIGV2ZW5pbmc6ICdhYmVuZHMnLFxuICAgIG5pZ2h0OiAnbmFjaHRzJ1xuICB9XG59O1xuXG52YXIgb3JkaW5hbE51bWJlciA9IGZ1bmN0aW9uIChkaXJ0eU51bWJlcikge1xuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcbiAgcmV0dXJuIG51bWJlciArICcuJztcbn07XG5cbnZhciBsb2NhbGl6ZSA9IHtcbiAgb3JkaW5hbE51bWJlcjogb3JkaW5hbE51bWJlcixcbiAgZXJhOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZXJhVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBxdWFydGVyOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogcXVhcnRlclZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBhcmd1bWVudENhbGxiYWNrOiBmdW5jdGlvbiAocXVhcnRlcikge1xuICAgICAgcmV0dXJuIHF1YXJ0ZXIgLSAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXG4gICAgZm9ybWF0dGluZ1ZhbHVlczogZm9ybWF0dGluZ01vbnRoVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXk6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRGb3JtYXR0aW5nV2lkdGg6ICd3aWRlJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsaXplOyIsImltcG9ydCBidWlsZE1hdGNoRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRNYXRjaEZuL2luZGV4LmpzXCI7XG5pbXBvcnQgYnVpbGRNYXRjaFBhdHRlcm5GbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoUGF0dGVybkZuL2luZGV4LmpzXCI7XG52YXIgbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9eKFxcZCspKFxcLik/L2k7XG52YXIgcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9cXGQrL2k7XG52YXIgbWF0Y2hFcmFQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXih2XFwuPyA/Q2hyXFwuP3xuXFwuPyA/Q2hyXFwuPykvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKHZcXC4/ID9DaHJcXC4/fG5cXC4/ID9DaHJcXC4/KS9pLFxuICB3aWRlOiAvXih2b3IgQ2hyaXN0dXN8dm9yIHVuc2VyZXIgWmVpdHJlY2hudW5nfG5hY2ggQ2hyaXN0dXN8dW5zZXJlciBaZWl0cmVjaG51bmcpL2lcbn07XG52YXIgcGFyc2VFcmFQYXR0ZXJucyA9IHtcbiAgYW55OiBbL152L2ksIC9ebi9pXVxufTtcbnZhciBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXlsxMjM0XS9pLFxuICBhYmJyZXZpYXRlZDogL15xWzEyMzRdL2ksXG4gIHdpZGU6IC9eWzEyMzRdKFxcLik/IFF1YXJ0YWwvaVxufTtcbnZhciBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgYW55OiBbLzEvaSwgLzIvaSwgLzMvaSwgLzQvaV1cbn07XG52YXIgbWF0Y2hNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW2pmbWFzb25kXS9pLFxuICBhYmJyZXZpYXRlZDogL14oalthw6RdbnxmZWJ8bcOkclt6XT98YXByfG1haXxqdW5baV0/fGp1bFtpXT98YXVnfHNlcHxva3R8bm92fGRleilcXC4/L2ksXG4gIHdpZGU6IC9eKGphbnVhcnxmZWJydWFyfG3DpHJ6fGFwcmlsfG1haXxqdW5pfGp1bGl8YXVndXN0fHNlcHRlbWJlcnxva3RvYmVyfG5vdmVtYmVyfGRlemVtYmVyKS9pXG59O1xudmFyIHBhcnNlTW9udGhQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL15qL2ksIC9eZi9pLCAvXm0vaSwgL15hL2ksIC9ebS9pLCAvXmovaSwgL15qL2ksIC9eYS9pLCAvXnMvaSwgL15vL2ksIC9ebi9pLCAvXmQvaV0sXG4gIGFueTogWy9ealthw6RdL2ksIC9eZi9pLCAvXm3DpHIvaSwgL15hcC9pLCAvXm1haS9pLCAvXmp1bi9pLCAvXmp1bC9pLCAvXmF1L2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXVxufTtcbnZhciBtYXRjaERheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW3NtZG1mXS9pLFxuICBzaG9ydDogL14oc298bW98ZGl8bWl8ZG98ZnJ8c2EpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihzb24/fG1vbj98ZGllP3xtaXQ/fGRvbj98ZnJlP3xzYW0/KVxcLj8vaSxcbiAgd2lkZTogL14oc29ubnRhZ3xtb250YWd8ZGllbnN0YWd8bWl0dHdvY2h8ZG9ubmVyc3RhZ3xmcmVpdGFnfHNhbXN0YWcpL2lcbn07XG52YXIgcGFyc2VEYXlQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15zby9pLCAvXm1vL2ksIC9eZGkvaSwgL15taS9pLCAvXmRvL2ksIC9eZi9pLCAvXnNhL2ldXG59O1xudmFyIG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14odm1cXC4/fG5tXFwuP3xNaXR0ZXJuYWNodHxNaXR0YWd8bW9yZ2Vuc3xuYWNobVxcLj98YWJlbmRzfG5hY2h0cykvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKHZvcm1cXC4/fG5hY2htXFwuP3xNaXR0ZXJuYWNodHxNaXR0YWd8bW9yZ2Vuc3xuYWNobVxcLj98YWJlbmRzfG5hY2h0cykvaSxcbiAgd2lkZTogL14odm9ybWl0dGFnc3xuYWNobWl0dGFnc3xNaXR0ZXJuYWNodHxNaXR0YWd8bW9yZ2Vuc3xuYWNobWl0dGFnc3xhYmVuZHN8bmFjaHRzKS9pXG59O1xudmFyIHBhcnNlRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIGFueToge1xuICAgIGFtOiAvXnYvaSxcbiAgICBwbTogL15uL2ksXG4gICAgbWlkbmlnaHQ6IC9eTWl0dGUvaSxcbiAgICBub29uOiAvXk1pdHRhL2ksXG4gICAgbW9ybmluZzogL21vcmdlbnMvaSxcbiAgICBhZnRlcm5vb246IC9uYWNobWl0dGFncy9pLFxuICAgIC8vIHdpbGwgbmV2ZXIgYmUgbWF0Y2hlZC4gQWZ0ZXJub29uIGlzIG1hdGNoZWQgYnkgYHBtYFxuICAgIGV2ZW5pbmc6IC9hYmVuZHMvaSxcbiAgICBuaWdodDogL25hY2h0cy9pIC8vIHdpbGwgbmV2ZXIgYmUgbWF0Y2hlZC4gTmlnaHQgaXMgbWF0Y2hlZCBieSBgcG1gXG5cbiAgfVxufTtcbnZhciBtYXRjaCA9IHtcbiAgb3JkaW5hbE51bWJlcjogYnVpbGRNYXRjaFBhdHRlcm5Gbih7XG4gICAgbWF0Y2hQYXR0ZXJuOiBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHBhcnNlUGF0dGVybjogcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgfVxuICB9KSxcbiAgZXJhOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZUVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55JyxcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5OiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IG1hdGNoOyIsImltcG9ydCBmb3JtYXREaXN0YW5jZSBmcm9tIFwiLi9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzXCI7XG5pbXBvcnQgZm9ybWF0TG9uZyBmcm9tIFwiLi9fbGliL2Zvcm1hdExvbmcvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRSZWxhdGl2ZSBmcm9tIFwiLi9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzXCI7XG5pbXBvcnQgbG9jYWxpemUgZnJvbSBcIi4vX2xpYi9sb2NhbGl6ZS9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoIGZyb20gXCIuL19saWIvbWF0Y2gvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IEdlcm1hbiBsb2NhbGUuXG4gKiBAbGFuZ3VhZ2UgR2VybWFuXG4gKiBAaXNvLTYzOS0yIGRldVxuICogQGF1dGhvciBUaG9tYXMgRWlsbXN0ZWluZXIgW0BEZU11dV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0RlTXV1fVxuICogQGF1dGhvciBBc2lhIFtAYXNpYS10XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXNpYS10fVxuICogQGF1dGhvciBWYW4gVnVvbmcgTmdvIFtAdmFudnVvbmduZ29de0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS92YW52dW9uZ25nb31cbiAqIEBhdXRob3IgUm9tYW5Fcm5zdCBbQHBleF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BleH1cbiAqIEBhdXRob3IgUGhpbGlwcCBLZWNrIFtAUGhpbGlwcDkxXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vUGhpbGlwcDkxfVxuICovXG52YXIgbG9jYWxlID0ge1xuICBjb2RlOiAnZGUnLFxuICBmb3JtYXREaXN0YW5jZTogZm9ybWF0RGlzdGFuY2UsXG4gIGZvcm1hdExvbmc6IGZvcm1hdExvbmcsXG4gIGZvcm1hdFJlbGF0aXZlOiBmb3JtYXRSZWxhdGl2ZSxcbiAgbG9jYWxpemU6IGxvY2FsaXplLFxuICBtYXRjaDogbWF0Y2gsXG4gIG9wdGlvbnM6IHtcbiAgICB3ZWVrU3RhcnRzT246IDFcbiAgICAvKiBNb25kYXkgKi9cbiAgICAsXG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiA0XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBsb2NhbGU7IiwidmFyIGZvcm1hdERpc3RhbmNlTG9jYWxlID0ge1xuICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgb25lOiAnbGVzcyB0aGFuIGEgc2Vjb25kJyxcbiAgICBvdGhlcjogJ2xlc3MgdGhhbiB7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgaGFsZkFNaW51dGU6ICdoYWxmIGEgbWludXRlJyxcbiAgbGVzc1RoYW5YTWludXRlczoge1xuICAgIG9uZTogJ2xlc3MgdGhhbiBhIG1pbnV0ZScsXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiAnMSBtaW51dGUnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIGFib3V0WEhvdXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSBob3VyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeEhvdXJzOiB7XG4gICAgb25lOiAnMSBob3VyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeERheXM6IHtcbiAgICBvbmU6ICcxIGRheScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gZGF5cydcbiAgfSxcbiAgYWJvdXRYV2Vla3M6IHtcbiAgICBvbmU6ICdhYm91dCAxIHdlZWsnLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IHdlZWtzJ1xuICB9LFxuICB4V2Vla3M6IHtcbiAgICBvbmU6ICcxIHdlZWsnLFxuICAgIG90aGVyOiAne3tjb3VudH19IHdlZWtzJ1xuICB9LFxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6ICdhYm91dCAxIG1vbnRoJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIHhNb250aHM6IHtcbiAgICBvbmU6ICcxIG1vbnRoJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIGFib3V0WFllYXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgeFllYXJzOiB7XG4gICAgb25lOiAnMSB5ZWFyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgb3ZlclhZZWFyczoge1xuICAgIG9uZTogJ292ZXIgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ292ZXIge3tjb3VudH19IHllYXJzJ1xuICB9LFxuICBhbG1vc3RYWWVhcnM6IHtcbiAgICBvbmU6ICdhbG1vc3QgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2FsbW9zdCB7e2NvdW50fX0geWVhcnMnXG4gIH1cbn07XG5cbnZhciBmb3JtYXREaXN0YW5jZSA9IGZ1bmN0aW9uICh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIHRva2VuVmFsdWUgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl07XG5cbiAgaWYgKHR5cGVvZiB0b2tlblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWU7XG4gIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiAmJiBvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2luICcgKyByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAnIGFnbyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdERpc3RhbmNlOyIsImltcG9ydCBidWlsZEZvcm1hdExvbmdGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZEZvcm1hdExvbmdGbi9pbmRleC5qc1wiO1xudmFyIGRhdGVGb3JtYXRzID0ge1xuICBmdWxsOiAnRUVFRSwgTU1NTSBkbywgeScsXG4gIGxvbmc6ICdNTU1NIGRvLCB5JyxcbiAgbWVkaXVtOiAnTU1NIGQsIHknLFxuICBzaG9ydDogJ01NL2RkL3l5eXknXG59O1xudmFyIHRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiAnaDptbTpzcyBhIHp6enonLFxuICBsb25nOiAnaDptbTpzcyBhIHonLFxuICBtZWRpdW06ICdoOm1tOnNzIGEnLFxuICBzaG9ydDogJ2g6bW0gYSdcbn07XG52YXIgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbG9uZzogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIG1lZGl1bTogJ3t7ZGF0ZX19LCB7e3RpbWV9fScsXG4gIHNob3J0OiAne3tkYXRlfX0sIHt7dGltZX19J1xufTtcbnZhciBmb3JtYXRMb25nID0ge1xuICBkYXRlOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSksXG4gIHRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiB0aW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgZGF0ZVRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlVGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSlcbn07XG5leHBvcnQgZGVmYXVsdCBmb3JtYXRMb25nOyIsInZhciBmb3JtYXRSZWxhdGl2ZUxvY2FsZSA9IHtcbiAgbGFzdFdlZWs6IFwiJ2xhc3QnIGVlZWUgJ2F0JyBwXCIsXG4gIHllc3RlcmRheTogXCIneWVzdGVyZGF5IGF0JyBwXCIsXG4gIHRvZGF5OiBcIid0b2RheSBhdCcgcFwiLFxuICB0b21vcnJvdzogXCIndG9tb3Jyb3cgYXQnIHBcIixcbiAgbmV4dFdlZWs6IFwiZWVlZSAnYXQnIHBcIixcbiAgb3RoZXI6ICdQJ1xufTtcblxudmFyIGZvcm1hdFJlbGF0aXZlID0gZnVuY3Rpb24gKHRva2VuLCBfZGF0ZSwgX2Jhc2VEYXRlLCBfb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UmVsYXRpdmVMb2NhbGVbdG9rZW5dO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0UmVsYXRpdmU7IiwiaW1wb3J0IGJ1aWxkTG9jYWxpemVGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZExvY2FsaXplRm4vaW5kZXguanNcIjtcbnZhciBlcmFWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydCJywgJ0EnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnQkMnLCAnQUQnXSxcbiAgd2lkZTogWydCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJ11cbn07XG52YXIgcXVhcnRlclZhbHVlcyA9IHtcbiAgbmFycm93OiBbJzEnLCAnMicsICczJywgJzQnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnUTEnLCAnUTInLCAnUTMnLCAnUTQnXSxcbiAgd2lkZTogWycxc3QgcXVhcnRlcicsICcybmQgcXVhcnRlcicsICczcmQgcXVhcnRlcicsICc0dGggcXVhcnRlciddXG59OyAvLyBOb3RlOiBpbiBFbmdsaXNoLCB0aGUgbmFtZXMgb2YgZGF5cyBvZiB0aGUgd2VlayBhbmQgbW9udGhzIGFyZSBjYXBpdGFsaXplZC5cbi8vIElmIHlvdSBhcmUgbWFraW5nIGEgbmV3IGxvY2FsZSBiYXNlZCBvbiB0aGlzIG9uZSwgY2hlY2sgaWYgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgdGhlIGxhbmd1YWdlIHlvdSdyZSB3b3JraW5nIG9uLlxuLy8gR2VuZXJhbGx5LCBmb3JtYXR0ZWQgZGF0ZXMgc2hvdWxkIGxvb2sgbGlrZSB0aGV5IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgc2VudGVuY2UsXG4vLyBlLmcuIGluIFNwYW5pc2ggbGFuZ3VhZ2UgdGhlIHdlZWtkYXlzIGFuZCBtb250aHMgc2hvdWxkIGJlIGluIHRoZSBsb3dlcmNhc2UuXG5cbnZhciBtb250aFZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ0onLCAnRicsICdNJywgJ0EnLCAnTScsICdKJywgJ0onLCAnQScsICdTJywgJ08nLCAnTicsICdEJ10sXG4gIGFiYnJldmlhdGVkOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gIHdpZGU6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddXG59O1xudmFyIGRheVZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXSxcbiAgc2hvcnQ6IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIHdpZGU6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxufTtcbnZhciBkYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAnYScsXG4gICAgcG06ICdwJyxcbiAgICBtaWRuaWdodDogJ21pJyxcbiAgICBub29uOiAnbicsXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnbmlnaHQnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICdBTScsXG4gICAgcG06ICdQTScsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgICBuaWdodDogJ25pZ2h0J1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICdhLm0uJyxcbiAgICBwbTogJ3AubS4nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXG4gICAgbmlnaHQ6ICduaWdodCdcbiAgfVxufTtcbnZhciBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ2EnLFxuICAgIHBtOiAncCcsXG4gICAgbWlkbmlnaHQ6ICdtaScsXG4gICAgbm9vbjogJ24nLFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAnQU0nLFxuICAgIHBtOiAnUE0nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAnYS5tLicsXG4gICAgcG06ICdwLm0uJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXG4gIH1cbn07XG5cbnZhciBvcmRpbmFsTnVtYmVyID0gZnVuY3Rpb24gKGRpcnR5TnVtYmVyLCBfb3B0aW9ucykge1xuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTsgLy8gSWYgb3JkaW5hbCBudW1iZXJzIGRlcGVuZCBvbiBjb250ZXh0LCBmb3IgZXhhbXBsZSxcbiAgLy8gaWYgdGhleSBhcmUgZGlmZmVyZW50IGZvciBkaWZmZXJlbnQgZ3JhbW1hdGljYWwgZ2VuZGVycyxcbiAgLy8gdXNlIGBvcHRpb25zLnVuaXRgLlxuICAvL1xuICAvLyBgdW5pdGAgY2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXRlJywgJ2RheU9mWWVhcicsXG4gIC8vICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJy5cblxuICB2YXIgcmVtMTAwID0gbnVtYmVyICUgMTAwO1xuXG4gIGlmIChyZW0xMDAgPiAyMCB8fCByZW0xMDAgPCAxMCkge1xuICAgIHN3aXRjaCAocmVtMTAwICUgMTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdzdCc7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICduZCc7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdyZCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bWJlciArICd0aCc7XG59O1xuXG52YXIgbG9jYWxpemUgPSB7XG4gIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXIsXG4gIGVyYTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGVyYVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZScsXG4gICAgYXJndW1lbnRDYWxsYmFjazogZnVuY3Rpb24gKHF1YXJ0ZXIpIHtcbiAgICAgIHJldHVybiBxdWFydGVyIC0gMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IG1vbnRoVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXk6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRGb3JtYXR0aW5nV2lkdGg6ICd3aWRlJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsaXplOyIsImltcG9ydCBidWlsZE1hdGNoRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRNYXRjaEZuL2luZGV4LmpzXCI7XG5pbXBvcnQgYnVpbGRNYXRjaFBhdHRlcm5GbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoUGF0dGVybkZuL2luZGV4LmpzXCI7XG52YXIgbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9eKFxcZCspKHRofHN0fG5kfHJkKT8vaTtcbnZhciBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL1xcZCsvaTtcbnZhciBtYXRjaEVyYVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKGJ8YSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKGJcXC4/XFxzP2NcXC4/fGJcXC4/XFxzP2NcXC4/XFxzP2VcXC4/fGFcXC4/XFxzP2RcXC4/fGNcXC4/XFxzP2VcXC4/KS9pLFxuICB3aWRlOiAvXihiZWZvcmUgY2hyaXN0fGJlZm9yZSBjb21tb24gZXJhfGFubm8gZG9taW5pfGNvbW1vbiBlcmEpL2lcbn07XG52YXIgcGFyc2VFcmFQYXR0ZXJucyA9IHtcbiAgYW55OiBbL15iL2ksIC9eKGF8YykvaV1cbn07XG52YXIgbWF0Y2hRdWFydGVyUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9ecVsxMjM0XS9pLFxuICB3aWRlOiAvXlsxMjM0XSh0aHxzdHxuZHxyZCk/IHF1YXJ0ZXIvaVxufTtcbnZhciBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgYW55OiBbLzEvaSwgLzIvaSwgLzMvaSwgLzQvaV1cbn07XG52YXIgbWF0Y2hNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW2pmbWFzb25kXS9pLFxuICBhYmJyZXZpYXRlZDogL14oamFufGZlYnxtYXJ8YXByfG1heXxqdW58anVsfGF1Z3xzZXB8b2N0fG5vdnxkZWMpL2ksXG4gIHdpZGU6IC9eKGphbnVhcnl8ZmVicnVhcnl8bWFyY2h8YXByaWx8bWF5fGp1bmV8anVseXxhdWd1c3R8c2VwdGVtYmVyfG9jdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXIpL2lcbn07XG52YXIgcGFyc2VNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFsvXmovaSwgL15mL2ksIC9ebS9pLCAvXmEvaSwgL15tL2ksIC9eai9pLCAvXmovaSwgL15hL2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXSxcbiAgYW55OiBbL15qYS9pLCAvXmYvaSwgL15tYXIvaSwgL15hcC9pLCAvXm1heS9pLCAvXmp1bi9pLCAvXmp1bC9pLCAvXmF1L2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXVxufTtcbnZhciBtYXRjaERheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW3NtdHdmXS9pLFxuICBzaG9ydDogL14oc3V8bW98dHV8d2V8dGh8ZnJ8c2EpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihzdW58bW9ufHR1ZXx3ZWR8dGh1fGZyaXxzYXQpL2ksXG4gIHdpZGU6IC9eKHN1bmRheXxtb25kYXl8dHVlc2RheXx3ZWRuZXNkYXl8dGh1cnNkYXl8ZnJpZGF5fHNhdHVyZGF5KS9pXG59O1xudmFyIHBhcnNlRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9ecy9pLCAvXm0vaSwgL150L2ksIC9edy9pLCAvXnQvaSwgL15mL2ksIC9ecy9pXSxcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxufTtcbnZhciBtYXRjaERheVBlcmlvZFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKGF8cHxtaXxufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaSxcbiAgYW55OiAvXihbYXBdXFwuP1xccz9tXFwuP3xtaWRuaWdodHxub29ufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaVxufTtcbnZhciBwYXJzZURheVBlcmlvZFBhdHRlcm5zID0ge1xuICBhbnk6IHtcbiAgICBhbTogL15hL2ksXG4gICAgcG06IC9ecC9pLFxuICAgIG1pZG5pZ2h0OiAvXm1pL2ksXG4gICAgbm9vbjogL15uby9pLFxuICAgIG1vcm5pbmc6IC9tb3JuaW5nL2ksXG4gICAgYWZ0ZXJub29uOiAvYWZ0ZXJub29uL2ksXG4gICAgZXZlbmluZzogL2V2ZW5pbmcvaSxcbiAgICBuaWdodDogL25pZ2h0L2lcbiAgfVxufTtcbnZhciBtYXRjaCA9IHtcbiAgb3JkaW5hbE51bWJlcjogYnVpbGRNYXRjaFBhdHRlcm5Gbih7XG4gICAgbWF0Y2hQYXR0ZXJuOiBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHBhcnNlUGF0dGVybjogcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfSksXG4gIGVyYTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaEVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueScsXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnYW55JyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IG1hdGNoOyIsImltcG9ydCBmb3JtYXREaXN0YW5jZSBmcm9tIFwiLi9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzXCI7XG5pbXBvcnQgZm9ybWF0TG9uZyBmcm9tIFwiLi9fbGliL2Zvcm1hdExvbmcvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRSZWxhdGl2ZSBmcm9tIFwiLi9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzXCI7XG5pbXBvcnQgbG9jYWxpemUgZnJvbSBcIi4vX2xpYi9sb2NhbGl6ZS9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoIGZyb20gXCIuL19saWIvbWF0Y2gvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IEVuZ2xpc2ggbG9jYWxlIChVbml0ZWQgU3RhdGVzKS5cbiAqIEBsYW5ndWFnZSBFbmdsaXNoXG4gKiBAaXNvLTYzOS0yIGVuZ1xuICogQGF1dGhvciBTYXNoYSBLb3NzIFtAa29zc25vY29ycF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2tvc3Nub2NvcnB9XG4gKiBAYXV0aG9yIExlc2hhIEtvc3MgW0BsZXNoYWtvc3Nde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNoYWtvc3N9XG4gKi9cbnZhciBsb2NhbGUgPSB7XG4gIGNvZGU6ICdlbi1VUycsXG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMFxuICAgIC8qIFN1bmRheSAqL1xuICAgICxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDFcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsZTsiLCJ2YXIgZm9ybWF0RGlzdGFuY2VMb2NhbGUgPSB7XG4gIGxlc3NUaGFuWFNlY29uZHM6IHtcbiAgICBvbmU6ICfkuI3liLAgMSDnp5InLFxuICAgIG90aGVyOiAn5LiN5YiwIHt7Y291bnR9fSDnp5InXG4gIH0sXG4gIHhTZWNvbmRzOiB7XG4gICAgb25lOiAnMSDnp5InLFxuICAgIG90aGVyOiAne3tjb3VudH19IOenkidcbiAgfSxcbiAgaGFsZkFNaW51dGU6ICfljYrliIbpkp8nLFxuICBsZXNzVGhhblhNaW51dGVzOiB7XG4gICAgb25lOiAn5LiN5YiwIDEg5YiG6ZKfJyxcbiAgICBvdGhlcjogJ+S4jeWIsCB7e2NvdW50fX0g5YiG6ZKfJ1xuICB9LFxuICB4TWludXRlczoge1xuICAgIG9uZTogJzEg5YiG6ZKfJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSDliIbpkp8nXG4gIH0sXG4gIHhIb3Vyczoge1xuICAgIG9uZTogJzEg5bCP5pe2JyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSDlsI/ml7YnXG4gIH0sXG4gIGFib3V0WEhvdXJzOiB7XG4gICAgb25lOiAn5aSn57qmIDEg5bCP5pe2JyxcbiAgICBvdGhlcjogJ+Wkp+e6piB7e2NvdW50fX0g5bCP5pe2J1xuICB9LFxuICB4RGF5czoge1xuICAgIG9uZTogJzEg5aSpJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSDlpKknXG4gIH0sXG4gIGFib3V0WFdlZWtzOiB7XG4gICAgb25lOiAn5aSn57qmIDEg5Liq5pif5pyfJyxcbiAgICBvdGhlcjogJ+Wkp+e6piB7e2NvdW50fX0g5Liq5pif5pyfJ1xuICB9LFxuICB4V2Vla3M6IHtcbiAgICBvbmU6ICcxIOS4quaYn+acnycsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0g5Liq5pif5pyfJ1xuICB9LFxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6ICflpKfnuqYgMSDkuKrmnIgnLFxuICAgIG90aGVyOiAn5aSn57qmIHt7Y291bnR9fSDkuKrmnIgnXG4gIH0sXG4gIHhNb250aHM6IHtcbiAgICBvbmU6ICcxIOS4quaciCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0g5Liq5pyIJ1xuICB9LFxuICBhYm91dFhZZWFyczoge1xuICAgIG9uZTogJ+Wkp+e6piAxIOW5tCcsXG4gICAgb3RoZXI6ICflpKfnuqYge3tjb3VudH19IOW5tCdcbiAgfSxcbiAgeFllYXJzOiB7XG4gICAgb25lOiAnMSDlubQnLFxuICAgIG90aGVyOiAne3tjb3VudH19IOW5tCdcbiAgfSxcbiAgb3ZlclhZZWFyczoge1xuICAgIG9uZTogJ+i2hei/hyAxIOW5tCcsXG4gICAgb3RoZXI6ICfotoXov4cge3tjb3VudH19IOW5tCdcbiAgfSxcbiAgYWxtb3N0WFllYXJzOiB7XG4gICAgb25lOiAn5bCG6L+RIDEg5bm0JyxcbiAgICBvdGhlcjogJ+Wwhui/kSB7e2NvdW50fX0g5bm0J1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0RGlzdGFuY2UodG9rZW4sIGNvdW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmICh0eXBlb2YgZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXTtcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXS5vbmU7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFkZFN1ZmZpeCkge1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgJ+WGhSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAn5YmNJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSIsImltcG9ydCBidWlsZEZvcm1hdExvbmdGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZEZvcm1hdExvbmdGbi9pbmRleC5qc1wiO1xudmFyIGRhdGVGb3JtYXRzID0ge1xuICBmdWxsOiBcInkn5bm0J00n5pyIJ2Qn5pelJyBFRUVFXCIsXG4gIGxvbmc6IFwieSflubQnTSfmnIgnZCfml6UnXCIsXG4gIG1lZGl1bTogJ3l5eXktTU0tZGQnLFxuICBzaG9ydDogJ3l5LU1NLWRkJ1xufTtcbnZhciB0aW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogJ3p6enogYSBoOm1tOnNzJyxcbiAgbG9uZzogJ3ogYSBoOm1tOnNzJyxcbiAgbWVkaXVtOiAnYSBoOm1tOnNzJyxcbiAgc2hvcnQ6ICdhIGg6bW0nXG59O1xudmFyIGRhdGVUaW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogJ3t7ZGF0ZX19IHt7dGltZX19JyxcbiAgbG9uZzogJ3t7ZGF0ZX19IHt7dGltZX19JyxcbiAgbWVkaXVtOiAne3tkYXRlfX0ge3t0aW1lfX0nLFxuICBzaG9ydDogJ3t7ZGF0ZX19IHt7dGltZX19J1xufTtcbnZhciBmb3JtYXRMb25nID0ge1xuICBkYXRlOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSksXG4gIHRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiB0aW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgZGF0ZVRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlVGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSlcbn07XG5leHBvcnQgZGVmYXVsdCBmb3JtYXRMb25nOyIsImltcG9ydCBpc1NhbWVVVENXZWVrIGZyb20gXCIuLi8uLi8uLi8uLi9fbGliL2lzU2FtZVVUQ1dlZWsvaW5kZXguanNcIjtcblxuZnVuY3Rpb24gY2hlY2tXZWVrKF9kYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zLCBiYXNlRm9ybWF0KSB7XG4gIGlmIChpc1NhbWVVVENXZWVrKF9kYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zKSkge1xuICAgIHJldHVybiBiYXNlRm9ybWF0OyAvLyBpbiBzYW1lIHdlZWtcbiAgfSBlbHNlIGlmIChfZGF0ZS5nZXRUaW1lKCkgPiBfYmFzZURhdGUuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIFwiJ+S4i+S4qidcIiArIGJhc2VGb3JtYXQ7IC8vIGluIG5leHQgd2Vla1xuICB9XG5cbiAgcmV0dXJuIFwiJ+S4iuS4qidcIiArIGJhc2VGb3JtYXQ7IC8vIGluIGxhc3Qgd2Vla1xufVxuXG52YXIgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XG4gIGxhc3RXZWVrOiBjaGVja1dlZWssXG4gIC8vIGRheXMgYmVmb3JlIHllc3RlcmRheSwgbWF5YmUgaW4gdGhpcyB3ZWVrIG9yIGxhc3Qgd2Vla1xuICB5ZXN0ZXJkYXk6IFwiJ+aYqOWkqScgcFwiLFxuICB0b2RheTogXCIn5LuK5aSpJyBwXCIsXG4gIHRvbW9ycm93OiBcIifmmI7lpKknIHBcIixcbiAgbmV4dFdlZWs6IGNoZWNrV2VlayxcbiAgLy8gZGF5cyBhZnRlciB0b21vcnJvdywgbWF5YmUgaW4gdGhpcyB3ZWVrIG9yIG5leHQgd2Vla1xuICBvdGhlcjogJ1BQIHAnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmUodG9rZW4sIF9kYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zKSB7XG4gIHZhciBmb3JtYXQgPSBmb3JtYXRSZWxhdGl2ZUxvY2FsZVt0b2tlbl07XG5cbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm9ybWF0KF9kYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zLCAnZWVlZSBwJyk7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0O1xufSIsImltcG9ydCBidWlsZExvY2FsaXplRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRMb2NhbGl6ZUZuL2luZGV4LmpzXCI7XG52YXIgZXJhVmFsdWVzID0ge1xuICBuYXJyb3c6IFsn5YmNJywgJ+WFrOWFgyddLFxuICBhYmJyZXZpYXRlZDogWyfliY0nLCAn5YWs5YWDJ10sXG4gIHdpZGU6IFsn5YWs5YWD5YmNJywgJ+WFrOWFgyddXG59O1xudmFyIHF1YXJ0ZXJWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWycxJywgJzInLCAnMycsICc0J10sXG4gIGFiYnJldmlhdGVkOiBbJ+esrOS4gOWtoycsICfnrKzkuozlraMnLCAn56ys5LiJ5a2jJywgJ+esrOWbm+WtoyddLFxuICB3aWRlOiBbJ+esrOS4gOWto+W6picsICfnrKzkuozlraPluqYnLCAn56ys5LiJ5a2j5bqmJywgJ+esrOWbm+Wto+W6piddXG59O1xudmFyIG1vbnRoVmFsdWVzID0ge1xuICBuYXJyb3c6IFsn5LiAJywgJ+S6jCcsICfkuIknLCAn5ZubJywgJ+S6lCcsICflha0nLCAn5LiDJywgJ+WFqycsICfkuZ0nLCAn5Y2BJywgJ+WNgeS4gCcsICfljYHkuownXSxcbiAgYWJicmV2aWF0ZWQ6IFsnMeaciCcsICcy5pyIJywgJzPmnIgnLCAnNOaciCcsICc15pyIJywgJzbmnIgnLCAnN+aciCcsICc45pyIJywgJznmnIgnLCAnMTDmnIgnLCAnMTHmnIgnLCAnMTLmnIgnXSxcbiAgd2lkZTogWyfkuIDmnIgnLCAn5LqM5pyIJywgJ+S4ieaciCcsICflm5vmnIgnLCAn5LqU5pyIJywgJ+WFreaciCcsICfkuIPmnIgnLCAn5YWr5pyIJywgJ+S5neaciCcsICfljYHmnIgnLCAn5Y2B5LiA5pyIJywgJ+WNgeS6jOaciCddXG59O1xudmFyIGRheVZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ+aXpScsICfkuIAnLCAn5LqMJywgJ+S4iScsICflm5snLCAn5LqUJywgJ+WFrSddLFxuICBzaG9ydDogWyfml6UnLCAn5LiAJywgJ+S6jCcsICfkuIknLCAn5ZubJywgJ+S6lCcsICflha0nXSxcbiAgYWJicmV2aWF0ZWQ6IFsn5ZGo5pelJywgJ+WRqOS4gCcsICflkajkuownLCAn5ZGo5LiJJywgJ+WRqOWbmycsICflkajkupQnLCAn5ZGo5YWtJ10sXG4gIHdpZGU6IFsn5pif5pyf5pelJywgJ+aYn+acn+S4gCcsICfmmJ/mnJ/kuownLCAn5pif5pyf5LiJJywgJ+aYn+acn+WbmycsICfmmJ/mnJ/kupQnLCAn5pif5pyf5YWtJ11cbn07XG52YXIgZGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ+S4iicsXG4gICAgcG06ICfkuIsnLFxuICAgIG1pZG5pZ2h0OiAn5YeM5pmoJyxcbiAgICBub29uOiAn5Y2IJyxcbiAgICBtb3JuaW5nOiAn5pepJyxcbiAgICBhZnRlcm5vb246ICfkuIvljYgnLFxuICAgIGV2ZW5pbmc6ICfmmZonLFxuICAgIG5pZ2h0OiAn5aScJ1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAn5LiK5Y2IJyxcbiAgICBwbTogJ+S4i+WNiCcsXG4gICAgbWlkbmlnaHQ6ICflh4zmmagnLFxuICAgIG5vb246ICfkuK3ljYgnLFxuICAgIG1vcm5pbmc6ICfml6nmmagnLFxuICAgIGFmdGVybm9vbjogJ+S4reWNiCcsXG4gICAgZXZlbmluZzogJ+aZmuS4iicsXG4gICAgbmlnaHQ6ICflpJzpl7QnXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogJ+S4iuWNiCcsXG4gICAgcG06ICfkuIvljYgnLFxuICAgIG1pZG5pZ2h0OiAn5YeM5pmoJyxcbiAgICBub29uOiAn5Lit5Y2IJyxcbiAgICBtb3JuaW5nOiAn5pep5pmoJyxcbiAgICBhZnRlcm5vb246ICfkuK3ljYgnLFxuICAgIGV2ZW5pbmc6ICfmmZrkuIonLFxuICAgIG5pZ2h0OiAn5aSc6Ze0J1xuICB9XG59O1xudmFyIGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAn5LiKJyxcbiAgICBwbTogJ+S4iycsXG4gICAgbWlkbmlnaHQ6ICflh4zmmagnLFxuICAgIG5vb246ICfljYgnLFxuICAgIG1vcm5pbmc6ICfml6knLFxuICAgIGFmdGVybm9vbjogJ+S4i+WNiCcsXG4gICAgZXZlbmluZzogJ+aZmicsXG4gICAgbmlnaHQ6ICflpJwnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICfkuIrljYgnLFxuICAgIHBtOiAn5LiL5Y2IJyxcbiAgICBtaWRuaWdodDogJ+WHjOaZqCcsXG4gICAgbm9vbjogJ+S4reWNiCcsXG4gICAgbW9ybmluZzogJ+aXqeaZqCcsXG4gICAgYWZ0ZXJub29uOiAn5Lit5Y2IJyxcbiAgICBldmVuaW5nOiAn5pma5LiKJyxcbiAgICBuaWdodDogJ+WknOmXtCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAn5LiK5Y2IJyxcbiAgICBwbTogJ+S4i+WNiCcsXG4gICAgbWlkbmlnaHQ6ICflh4zmmagnLFxuICAgIG5vb246ICfkuK3ljYgnLFxuICAgIG1vcm5pbmc6ICfml6nmmagnLFxuICAgIGFmdGVybm9vbjogJ+S4reWNiCcsXG4gICAgZXZlbmluZzogJ+aZmuS4iicsXG4gICAgbmlnaHQ6ICflpJzpl7QnXG4gIH1cbn07XG5cbmZ1bmN0aW9uIG9yZGluYWxOdW1iZXIoZGlydHlOdW1iZXIsIGRpcnR5T3B0aW9ucykge1xuICAvLyBJZiBvcmRpbmFsIG51bWJlcnMgZGVwZW5kIG9uIGNvbnRleHQsIGZvciBleGFtcGxlLFxuICAvLyBpZiB0aGV5IGFyZSBkaWZmZXJlbnQgZm9yIGRpZmZlcmVudCBncmFtbWF0aWNhbCBnZW5kZXJzLFxuICAvLyB1c2UgYG9wdGlvbnMudW5pdGA6XG4gIC8vXG4gIC8vICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge31cbiAgLy8gICB2YXIgdW5pdCA9IFN0cmluZyhvcHRpb25zLnVuaXQpXG4gIC8vXG4gIC8vIHdoZXJlIGB1bml0YCBjYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RhdGUnLCAnZGF5T2ZZZWFyJyxcbiAgLy8gJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnXG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIHVuaXQgPSBTdHJpbmcob3B0aW9ucy51bml0KTtcblxuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlICdkYXRlJzpcbiAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKSArICfml6UnO1xuXG4gICAgY2FzZSAnaG91cic6XG4gICAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCkgKyAn5pe2JztcblxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCkgKyAn5YiGJztcblxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCkgKyAn56eSJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ+esrCAnICsgbnVtYmVyLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxudmFyIGxvY2FsaXplID0ge1xuICBvcmRpbmFsTnVtYmVyOiBvcmRpbmFsTnVtYmVyLFxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBxdWFydGVyVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGFyZ3VtZW50Q2FsbGJhY2s6IGZ1bmN0aW9uIChxdWFydGVyKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHF1YXJ0ZXIpIC0gMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IG1vbnRoVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXk6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRGb3JtYXR0aW5nV2lkdGg6ICd3aWRlJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsaXplOyIsImltcG9ydCBidWlsZE1hdGNoUGF0dGVybkZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4vaW5kZXguanNcIjtcbmltcG9ydCBidWlsZE1hdGNoRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRNYXRjaEZuL2luZGV4LmpzXCI7XG52YXIgbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9eKOesrFxccyopP1xcZCso5pelfOaXtnzliIZ856eSKT8vaTtcbnZhciBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL1xcZCsvaTtcbnZhciBtYXRjaEVyYVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKOWJjSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKOWJjSkvaSxcbiAgd2lkZTogL14o5YWs5YWD5YmNfOWFrOWFgykvaVxufTtcbnZhciBwYXJzZUVyYVBhdHRlcm5zID0ge1xuICBhbnk6IFsvXijliY0pL2ksIC9eKOWFrOWFgykvaV1cbn07XG52YXIgbWF0Y2hRdWFydGVyUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9e56ysW+S4gOS6jOS4ieWbm13liLsvaSxcbiAgd2lkZTogL17nrKxb5LiA5LqM5LiJ5ZubXeWIu+mSny9pXG59O1xudmFyIHBhcnNlUXVhcnRlclBhdHRlcm5zID0ge1xuICBhbnk6IFsvKDF85LiAKS9pLCAvKDJ85LqMKS9pLCAvKDN85LiJKS9pLCAvKDR85ZubKS9pXVxufTtcbnZhciBtYXRjaE1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14o5LiAfOS6jHzkuIl85ZubfOS6lHzlha185LiDfOWFq3zkuZ185Y2BW+S6jOS4gF0pL2ksXG4gIGFiYnJldmlhdGVkOiAvXijkuIB85LqMfOS4iXzlm5t85LqUfOWFrXzkuIN85YWrfOS5nXzljYFb5LqM5LiAXXxcXGR8MVsxMl0p5pyIL2ksXG4gIHdpZGU6IC9eKOS4gHzkuox85LiJfOWbm3zkupR85YWtfOS4g3zlhat85LmdfOWNgVvkuozkuIBdKeaciC9pXG59O1xudmFyIHBhcnNlTW9udGhQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL17kuIAvaSwgL17kuowvaSwgL17kuIkvaSwgL17lm5svaSwgL17kupQvaSwgL17lha0vaSwgL17kuIMvaSwgL17lhasvaSwgL17kuZ0vaSwgL17ljYEoPyEo5LiAfOS6jCkpL2ksIC9e5Y2B5LiAL2ksIC9e5Y2B5LqML2ldLFxuICBhbnk6IFsvXuS4gHwxL2ksIC9e5LqMfDIvaSwgL17kuIl8My9pLCAvXuWbm3w0L2ksIC9e5LqUfDUvaSwgL17lha18Ni9pLCAvXuS4g3w3L2ksIC9e5YWrfDgvaSwgL17kuZ18OS9pLCAvXuWNgSg/ISjkuIB85LqMKSl8MTAvaSwgL17ljYHkuIB8MTEvaSwgL17ljYHkuox8MTIvaV1cbn07XG52YXIgbWF0Y2hEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXlvkuIDkuozkuInlm5vkupTlha3ml6VdL2ksXG4gIHNob3J0OiAvXlvkuIDkuozkuInlm5vkupTlha3ml6VdL2ksXG4gIGFiYnJldmlhdGVkOiAvXuWRqFvkuIDkuozkuInlm5vkupTlha3ml6VdL2ksXG4gIHdpZGU6IC9e5pif5pyfW+S4gOS6jOS4ieWbm+S6lOWFreaXpV0vaVxufTtcbnZhciBwYXJzZURheVBhdHRlcm5zID0ge1xuICBhbnk6IFsv5pelL2ksIC/kuIAvaSwgL+S6jC9pLCAv5LiJL2ksIC/lm5svaSwgL+S6lC9pLCAv5YWtL2ldXG59O1xudmFyIG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIGFueTogL14o5LiK5Y2IP3zkuIvljYg/fOWNiOWknHxb5Lit5q2jXeWNiHzml6nkuIo/fOS4i+WNiHzmmZrkuIo/fOWHjOaZqHwpL2lcbn07XG52YXIgcGFyc2VEYXlQZXJpb2RQYXR0ZXJucyA9IHtcbiAgYW55OiB7XG4gICAgYW06IC9e5LiK5Y2IPy9pLFxuICAgIHBtOiAvXuS4i+WNiD8vaSxcbiAgICBtaWRuaWdodDogL17ljYjlpJwvaSxcbiAgICBub29uOiAvXlvkuK3mraNd5Y2IL2ksXG4gICAgbW9ybmluZzogL17ml6nkuIovaSxcbiAgICBhZnRlcm5vb246IC9e5LiL5Y2IL2ksXG4gICAgZXZlbmluZzogL17mmZrkuIo/L2ksXG4gICAgbmlnaHQ6IC9e5YeM5pmoL2lcbiAgfVxufTtcbnZhciBtYXRjaCA9IHtcbiAgb3JkaW5hbE51bWJlcjogYnVpbGRNYXRjaFBhdHRlcm5Gbih7XG4gICAgbWF0Y2hQYXR0ZXJuOiBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHBhcnNlUGF0dGVybjogcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfSksXG4gIGVyYTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaEVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueScsXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnYW55JyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IG1hdGNoOyIsImltcG9ydCBmb3JtYXREaXN0YW5jZSBmcm9tIFwiLi9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzXCI7XG5pbXBvcnQgZm9ybWF0TG9uZyBmcm9tIFwiLi9fbGliL2Zvcm1hdExvbmcvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRSZWxhdGl2ZSBmcm9tIFwiLi9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzXCI7XG5pbXBvcnQgbG9jYWxpemUgZnJvbSBcIi4vX2xpYi9sb2NhbGl6ZS9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoIGZyb20gXCIuL19saWIvbWF0Y2gvaW5kZXguanNcIjtcbi8qKlxuICogQHR5cGUge0xvY2FsZX1cbiAqIEBjYXRlZ29yeSBMb2NhbGVzXG4gKiBAc3VtbWFyeSBDaGluZXNlIFNpbXBsaWZpZWQgbG9jYWxlLlxuICogQGxhbmd1YWdlIENoaW5lc2UgU2ltcGxpZmllZFxuICogQGlzby02MzktMiB6aG9cbiAqIEBhdXRob3IgQ2hhbmd5dSBHZW5nIFtAS2luZ01hcmlvXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vS2luZ01hcmlvfVxuICogQGF1dGhvciBTb25nIFNodW95dW4gW0BmbmxjdHJsXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZm5sY3RybH1cbiAqIEBhdXRob3Igc2FicmluYU0gW0BzYWJyaW5hbWlhb117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NhYnJpbmFtaWFvfVxuICogQGF1dGhvciBDYXJuZXkgV3UgW0BjdWJpY3dvcmtde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWJpY3dvcmt9XG4gKiBAYXV0aG9yIFRlcnJlbmNlIExhbSBbQHNreXVwbGFtXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2t5dXBsYW19XG4gKi9cblxudmFyIGxvY2FsZSA9IHtcbiAgY29kZTogJ3poLUNOJyxcbiAgZm9ybWF0RGlzdGFuY2U6IGZvcm1hdERpc3RhbmNlLFxuICBmb3JtYXRMb25nOiBmb3JtYXRMb25nLFxuICBmb3JtYXRSZWxhdGl2ZTogZm9ybWF0UmVsYXRpdmUsXG4gIGxvY2FsaXplOiBsb2NhbGl6ZSxcbiAgbWF0Y2g6IG1hdGNoLFxuICBvcHRpb25zOiB7XG4gICAgd2Vla1N0YXJ0c09uOiAxXG4gICAgLyogTW9uZGF5ICovXG4gICAgLFxuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNFxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgbG9jYWxlOyIsImltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzXCI7XG5pbXBvcnQgYWRkTWlsbGlzZWNvbmRzIGZyb20gXCIuLi9hZGRNaWxsaXNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIHN1Yk1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIHN1YnRyYWN0ZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIHN1YnRyYWN0ZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgNzUwIG1pbGxpc2Vjb25kcyBmcm9tIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdWJNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NToyOS4yNTBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdWJNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlcihkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCAtYW1vdW50KTtcbn0iLCJpbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSB0b0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0cyBjbG9uZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ2xvbmUgdGhlIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUobmV3IERhdGUoMjAxNCwgMSwgMTEsIDExLCAzMCwgMzApKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCB0aGUgdGltZXN0YW1wIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUoMTM5MjA5ODQzMDAwMClcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9EYXRlKGFyZ3VtZW50KSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgYXJnU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KTsgLy8gQ2xvbmUgdGhlIGRhdGVcblxuICBpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBhcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgYXJnU3RyID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdudW1iZXInIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIGlmICgodHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCBhcmdTdHIgPT09ICdbb2JqZWN0IFN0cmluZ10nKSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXCJTdGFydGluZyB3aXRoIHYyLjAuMC1iZXRhLjEgZGF0ZS1mbnMgZG9lc24ndCBhY2NlcHQgc3RyaW5ncyBhcyBkYXRlIGFyZ3VtZW50cy4gUGxlYXNlIHVzZSBgcGFyc2VJU09gIHRvIHBhcnNlIHN0cmluZ3MuIFNlZTogaHR0cHM6Ly9naXQuaW8vZmp1bGVcIik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cbn0iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjIxJztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbicsXG4gICAgICBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gJ0ludmFsaWQgYHZhcmlhYmxlYCBvcHRpb24gcGFzc2VkIGludG8gYF8udGVtcGxhdGVgJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG4gIHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgICBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbiAgdmFyIHdyYXBGbGFncyA9IFtcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICAgIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICAgIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG4gIHZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHZhbGlkYXRlIHRoZSBgdmFsaWRhdGVgIG9wdGlvbiBpbiBgXy50ZW1wbGF0ZWAgdmFyaWFibGUuXG4gICAqXG4gICAqIEZvcmJpZHMgY2hhcmFjdGVycyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBjaGFuZ2UgdGhlIG1lYW5pbmcgb2YgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IGRlZmluaXRpb246XG4gICAqIC0gXCIoKSxcIiAobW9kaWZpY2F0aW9uIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMpXG4gICAqIC0gXCI9XCIgKGRlZmF1bHQgdmFsdWUpXG4gICAqIC0gXCJbXXt9XCIgKGRlc3RydWN0dXJpbmcgb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAgICogLSBcIi9cIiAoYmVnaW5uaW5nIG9mIGEgY29tbWVudClcbiAgICogLSB3aGl0ZXNwYWNlXG4gICAqL1xuICB2YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICAgIDogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICsrcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubGFzdEluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ICsgMTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgdW5lc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxVbmVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAxLjEuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID09IG51bGwgPyByb290IDogXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSk7XG5cbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICAgIHZhciBjb3JlSnNEYXRhID0gY29udGV4dFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKSk7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXG4gICAgICAgIFByb21pc2UgPSBnZXROYXRpdmUoY29udGV4dCwgJ1Byb21pc2UnKSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuICAgIHZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX19pbmRleF9fID0gMDtcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGFkZFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBEZWVwIGNsb25lXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgICB9XG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgICAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICAgICAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF0sXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kZWxheWAgYW5kIGBfLmRlZmVyYCB3aGljaCBhY2NlcHRzIGBhcmdzYFxuICAgICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAgICAgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgICAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgICAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5SYW5nZWAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gbnVtYmVyID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiBudW1iZXIgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmludGVyc2VjdGlvbmAsIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnRlcnNlY3Rpb24oYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluY2x1ZGVzID0gY29tcGFyYXRvciA/IGFycmF5SW5jbHVkZXNXaXRoIDogYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgICAgICBtYXhMZW5ndGggPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgICAgICA/IG5ldyBTZXRDYWNoZShvdGhJbmRleCAmJiBhcnJheSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFycmF5ID0gYXJyYXlzWzBdO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoIShzZWVuXG4gICAgICAgICAgICAgID8gY2FjaGVIYXMoc2VlbiwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICghKGNhY2hlXG4gICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZlcnRgIGFuZCBgXy5pbnZlcnRCeWAgd2hpY2ggaW52ZXJ0c1xuICAgICAqIGBvYmplY3RgIHdpdGggdmFsdWVzIHRyYW5zZm9ybWVkIGJ5IGBpdGVyYXRlZWAgYW5kIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUodmFsdWUpLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZva2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIG1ldGhvZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHZhciBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJyYXlCdWZmZXJgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJyYXlCdWZmZXJUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNEYXRlYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgICAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICAgICAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgICAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTHQodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VOdGgoYXJyYXksIG4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0luZGV4KG4sIGxlbmd0aCkgPyBhcnJheVtuXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpZGVudGl0eV07XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xuXG4gICAgICBpZiAoYXJyYXkgPT09IHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICAgICAqIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVwZWF0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIGlmICghc3RyaW5nIHx8IG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVTaXplYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHtcbiAgICAgIHZhciBhcnJheSA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhgIHdoaWNoXG4gICAgICogcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyBsb3cgOiBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKGNvbXB1dGVkICE9PSBudWxsICYmICFpc1N5bWJvbChjb21wdXRlZCkgJiZcbiAgICAgICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxuICAgICAqIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZVxuICAgICAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgIHZhciB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgICAgICB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvTnVtYmVyYCB3aGljaCBkb2Vzbid0IGVuc3VyZSBjb3JyZWN0XG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG5cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaW5kZXhdLFxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsIDEpLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGBiYXNlUmVzdGAgYWxpYXMgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYGlkZW50aXR5YCBieSBtb2R1bGVcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcblxuICAgIC8qKlxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi9cbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24gJiYgbmF0aXZlSXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaXRlcmF0ZWVcIiBmdW5jdGlvbi4gSWYgYF8uaXRlcmF0ZWVgIGlzIGN1c3RvbWl6ZWQsXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cbiAgICAgKiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCB0aGUgY2hvc2VuIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaXRlcmF0ZWUgfHwgaXRlcmF0ZWU7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGl0ZXJhdGVlID8gYmFzZUl0ZXJhdGVlIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgICAgOiBkYXRhLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICBpZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgICAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgd3JhcHBlciBgZGV0YWlsc2AgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIGBzb3VyY2VgIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gICAgICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShyZVdyYXBDb21tZW50LCAne1xcbi8qIFt3cmFwcGVkIHdpdGggJyArIGRldGFpbHMgKyAnXSAqL1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG90aGVyICE9ICdmdW5jdGlvbicgfHwgIShmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGlzIGNhcGFibGUgb2YgYmVpbmcgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2thYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICAgICAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICAgICAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gICAgICogZXhlY3V0ZWQgaW1wb3J0YW50LCBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlXG4gICAgICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAgICAgKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9BUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICAgICAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICAgICAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BzZXRUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vc2V0VGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyh3cmFwcGVyLCBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIHVwZGF0ZVdyYXBEZXRhaWxzKGdldFdyYXBEZXRhaWxzKHNvdXJjZSksIGJpdG1hc2spKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gICAgICogbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCAnKicsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xuICAgICAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gVGhlIGVsZW1lbnQgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxuICAgICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGgoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VCeWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAzIH0sIHsgJ3gnOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIGBpbmRleGVzYCBhbmQgcmV0dXJucyBhblxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqIHZhciBwdWxsZWQgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xuICAgICAqIC8vID0+IFsnYicsICdkJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBhcnJheU1hcChpbmRleGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqIFtgQXJyYXkjc2xpY2VgXShodHRwczovL21kbi5pby9BcnJheS9zbGljZSkgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcShbMSwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFpbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gICAgICogaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy53aXRob3V0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgeG9yID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxuICAgICAqIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICAgKiAgIC5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGF0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICsrcmVzdWx0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAgICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIENvbWJpbmluZyBzZXZlcmFsIHByZWRpY2F0ZXMgdXNpbmcgYF8ub3ZlckV2ZXJ5YCBvciBgXy5vdmVyU29tZWAuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8ub3ZlclNvbWUoW3sgJ2FnZSc6IDM2IH0sIFsnYWdlJywgNDBdXSkpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAgICAgKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXG4gICAgICogZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBlYWNoIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoby5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIga2V5QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxuICAgICAqIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiAzMCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxuICAgICAqIGlnbm9yaW5nIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0FSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcbiAgICAgKiBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LiBTZWVcbiAgICAgKiBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmRLZXkpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgICBtYXhXYWl0LFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB0aW1lcklkLFxuICAgICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgOiAodmFsdWUgPT09IDAgPyB2YWx1ZSA6IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgICAgIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gICAgICAvLyBhbmQgZXNjYXBlIHRoZSBjb21tZW50LCB0aHVzIGluamVjdGluZyBjb2RlIHRoYXQgZ2V0cyBldmFsZWQuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgICAgICAgID8gKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBhIGZvcmJpZGRlbiBjaGFyYWN0ZXIgd2FzIGZvdW5kIGluIGB2YXJpYWJsZWAsIHRvIHByZXZlbnRcbiAgICAgIC8vIHBvdGVudGlhbCBjb21tYW5kIGluamVjdGlvbiBhdHRhY2tzLlxuICAgICAgZWxzZSBpZiAocmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMudGVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUcmltKHN0cmluZyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksIF8ubWF0Y2hlcyh7ICdhJzogNCB9KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCAxKSwgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIG1hdGNoZXNGdW5jID0gXy5vdmVyU29tZShbeyAnYSc6IDEgfSwgeyAnYSc6IDIgfV0pXG4gICAgICogdmFyIG1hdGNoZXNQcm9wZXJ0eUZ1bmMgPSBfLm92ZXJTb21lKFtbJ2EnLCAxXSwgWydhJywgMl1dKVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUgKyAnJztcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywga2V5KSkge1xuICAgICAgICAgIHJlYWxOYW1lc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVhbE5hbWVzW2tleV0ucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJmdW5jdGlvbiBnZXRSYW5kb21JbnQobWF4KSB7XHJcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XHJcbn07XHJcblxyXG5jb25zdCBnZW5SYW5kb21IZXggPSBzaXplID0+IFsuLi5BcnJheShzaXplKV0ubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KS50b1N0cmluZygxNikpLmpvaW4oJycpO1xyXG5cclxuZnVuY3Rpb24gZ2VuUmFuZG9tTG9naW5Nc2coKSB7XHJcbiAgICAvLyBFLmcuIFwiTG9nSW4tZmFiMTY0YTMtMmY2My0wMDBkLTE1OWItM2I4Njg2OGQ4ZmZlXCJcclxuICAgIHJldHVybiBcIkxvZ0luLVwiICsgZ2VuUmFuZG9tSGV4KDgpICsgXCItXCIgKyBnZW5SYW5kb21IZXgoNCkgKyBcIi1cIiArIGdlblJhbmRvbUhleCg0KSArIFwiLVwiICsgZ2VuUmFuZG9tSGV4KDQpICsgXCItXCIgKyBnZW5SYW5kb21IZXgoMTIpO1xyXG59XHJcblxyXG5leHBvcnQgeyBnZXRSYW5kb21JbnQsIGdlblJhbmRvbUxvZ2luTXNnIH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JfbXNnKG1zZywgY2F0ZWdvcnkpIHtcclxuICAvLyBNYWtlIG5pY2UgZXJyb3IgbWVzc2FnZXMgdXNpbmcgQm9vdHN0cmFwIGFsZXJ0c1xyXG4gIGNvbnN0IGluc2VydF9zdHIgPSBcIjxkaXYgY2xhc3M9J2FsZXJ0IGFsZXJ0LWRpc21pc3NhYmxlIGZhZGUgc2hvdyBhbGVydC1cIiArIGNhdGVnb3J5ICsgXCInPiBcIiArIG1zZyArXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0bi1jbG9zZScgZGF0YS1icy1kaXNtaXNzPSdhbGVydCcgYXJpYS1sYWJlbD0nQ2xvc2UnIHN0eWxlPSdmbG9hdDogcmlnaHQnPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgIFwiICAgPC9idXR0b24+IDwvZGl2PlwiO1xyXG4gIGNvbnNvbGUubG9nKGluc2VydF9zdHIpO1xyXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWxlcnQtbWVzc2FnZXNcIikuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBpbnNlcnRfc3RyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNsZWVwKG1zKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xyXG59IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZGF0ZS1mbnMnO1xyXG5pbXBvcnQgeyBlblVTLCBkZSAsIHpoQ059IGZyb20gJ2RhdGUtZm5zL2xvY2FsZSc7XHJcbmNvbnN0IGxvY2FsZV9vYmogPSB7XHJcbiAgICBcImVuXCI6IGVuVVMsXHJcbiAgICBcImVuLVVTXCI6IGVuVVMsXHJcbiAgICBcImRlXCI6IGRlLFxyXG4gICAgXCJ6aFwiOiB6aENOLFxyXG4gICAgXCJ6aC1DTlwiOiB6aENOXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldExhbmcoKSB7XHJcbiAgICBpZiAobmF2aWdhdG9yLmxhbmd1YWdlcyAhPSB1bmRlZmluZWQpIFxyXG4gICAgICByZXR1cm4gbmF2aWdhdG9yLmxhbmd1YWdlc1swXTsgXHJcbiAgICByZXR1cm4gbmF2aWdhdG9yLmxhbmd1YWdlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0TG9jYWxlKCkge1xyXG4gICAgY29uc3QgbGFuZyA9IGdldExhbmcoKTtcclxuICAgIGxldCBsb2NhbGUgPSBsb2NhbGVfb2JqW2xhbmddO1xyXG5cclxuICAgIGlmICghbG9jYWxlKVxyXG4gICAgICAgIGxvY2FsZSA9IGxvY2FsZV9vYmpbXCJlblwiXTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGxvY2FsZTtcclxufTtcclxuXHJcbmNvbnN0IGxvY2FsZSA9IGdldExvY2FsZSgpO1xyXG4vLyBjb25zb2xlLmxvZyhsb2NhbGUpO1xyXG5cclxuZnVuY3Rpb24gZGF0ZVRpbWVGb3JtYXR0ZXIodGltZXN0YW1wKSB7XHJcbiAgICByZXR1cm4gZm9ybWF0KG5ldyBEYXRlKHRpbWVzdGFtcCksIFwiZGQvTU0veXl5eSBISDptbVwiKTtcclxuICAgIC8vcmV0dXJuIGZvcm1hdChuZXcgRGF0ZSh0aW1lc3RhbXApLCBcIlBwXCIsIHtcImxvY2FsZVwiOiBsb2NhbGVfb2JqW2xvY2FsZV19KTtcclxufVxyXG5cclxud2luZG93LmRhdGVUaW1lRm9ybWF0dGVyID0gZGF0ZVRpbWVGb3JtYXR0ZXI7XHJcblxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgJChcIiN0YWJsZS1zdGF0cy1tZXRhbW9uc1wiKS5vbihcInBvc3QtaGVhZGVyLmJzLnRhYmxlXCIsIGFkanVzdEV4cG9ydEJ1dHRvbik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHt9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gYWRqdXN0RXhwb3J0QnV0dG9uICgpIHtcclxuICAgIGNvbnN0IGV4cG9ydF9lbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJleHBvcnRcIik7XHJcbiAgICBpZiAoZXhwb3J0X2VsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gZXhwb3J0X2VsZW1lbnRzWzBdO1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJidXR0b25cIilbMF07XHJcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gXCJFeHBvcnRcIjtcclxuXHJcbiAgICAgICAgLy8gSWYgZGF0YSBpcyBub3QgYXZhaWxhYmxlLCBkaXNhYmxlIGJ1dHRvblxyXG4gICAgICAgIGlmICghICgkKFwiI3RhYmxlLXN0YXRzLW1ldGFtb25zXCIpWzBdLmRhdGFzZXQudXJsKSlcclxuICAgICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIGFkanVzdFRhYmxlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkanVzdFRhYmxlICgpIHtcclxuICAgIC8vIE1ha2VzIGJvcmRlcnMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGFibGUgaGVhZCB0byBzZXBhcmF0ZSBcIk1ldGFtb25cIiBhbmQgXCJSZXN1bHRzXCJcclxuICAgIGNvbnN0IGVsID0gJChcIi50ci1jbGFzcy0xXCIpWzBdO1xyXG4gICAgZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aFwiKVsxXS5zdHlsZS5ib3JkZXJMZWZ0ID0gXCIycHggc29saWQgIzQ0NDQ0NFwiO1xyXG4gICAgY29uc3QgZWwyID0gJChcIi50ci1jbGFzcy0yXCIpWzBdO1xyXG4gICAgZWwyLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGhcIilbNV0uc3R5bGUuYm9yZGVyTGVmdCA9IFwiMnB4IHNvbGlkICM0NDQ0NDRcIjtcclxufSIsImltcG9ydCB7IGdldFJhbmRvbUludCwgZXJyb3JfbXNnLCBzbGVlcCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCBfLCB7IHJlc3VsdCB9IGZyb20gXCJsb2Rhc2hcIjtcclxuXHJcbmZ1bmN0aW9uIGdldENvb2tpZShuYW1lKSB7XHJcbiAgY29uc3QgdmFsdWUgPSBgOyAke2RvY3VtZW50LmNvb2tpZX1gO1xyXG4gIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoYDsgJHtuYW1lfT1gKTtcclxuICBpZiAocGFydHMubGVuZ3RoID09PSAyKSByZXR1cm4gcGFydHMucG9wKCkuc3BsaXQoJzsnKS5zaGlmdCgpO1xyXG59O1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gbWFrZV9yZXF1ZXN0KCkge1xyXG4gICAgdmFyIGt2cGFpcnMgPSB7fTtcclxuICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1hbmFnZXItZm9ybVwiKTtcclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm0uZWxlbWVudHMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgdmFyIGUgPSBmb3JtLmVsZW1lbnRzW2ldOyBcclxuICAgICAgICBpZiAoZS50eXBlID09IFwiY2hlY2tib3hcIilcclxuICAgICAgICAgICAga3ZwYWlyc1tlLm5hbWVdID0gZS5jaGVja2VkID8gXCJvblwiIDogXCJvZmZcIjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGt2cGFpcnNbZS5uYW1lXSA9IGUudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgbWV0aG9kOiAncG9zdCcsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ1gtQ1NSRi1UT0tFTic6IGdldENvb2tpZSgnY3NyZl9hY2Nlc3NfdG9rZW4nKSxcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGt2cGFpcnMpXHJcbiAgICB9O1xyXG5cclxuICAgIGF3YWl0IGZldGNoKCcvbWFuYWdlcicsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmF0dGxlLXN1Ym1pdC1idXR0b25cIikpIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmF0dGxlLXN1Ym1pdC1idXR0b25cIikub25jbGljayA9IGFzeW5jICgpPT57XHJcbiAgICAgICAgLy9hd2FpdCBtYWtlX3JlcXVlc3QoKTtcclxuICAgICAgICBhd2FpdCBzdGFydEJhdHRsZXMoKTtcclxuICAgIH07XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGxvZyAodGV4dCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICBtZXRob2Q6ICdwb3N0JyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnWC1DU1JGLVRPS0VOJzogZ2V0Q29va2llKCdjc3JmX2FjY2Vzc190b2tlbicpLFxyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGV4dClcclxuICAgIH07XHJcblxyXG4gICAgYXdhaXQgZmV0Y2goJy9sb2cnLCBvcHRpb25zKTtcclxuXHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoX2xvb3AodXJsLCBtZXRob2QsIGRhdGEsIGhlYWRlcnMpIHtcclxuICAgIC8vbGV0IGggPSAgeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbid9O1xyXG4gICAgbGV0IGggPSAge307XHJcblx0aWYgKGhlYWRlcnMpIHtcclxuXHRcdE9iamVjdC5hc3NpZ24oaCwgaGVhZGVycyk7XHJcblx0fTtcclxuXHJcblx0Y29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgICAgICBoZWFkZXJzOiBoLFxyXG4gICAgICAgIGJvZHk6IGRhdGFcclxuICAgIH07XHJcblxyXG5cclxuXHRmb3IgKGxldCBuID0gMDsgbiA8IDU7IG4rKykge1xyXG4gICAgICAgIGF3YWl0IHNsZWVwKDAuNSk7XHJcblx0XHR0cnkge1xyXG4gICAgICAgICAgICAvLyBhd2FpdCBsb2coXCJGZXRjaCBcIiArIHVybCArIFwiIFwiICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xyXG5cdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlX2pzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIC8vYXdhaXQgbG9nKFwiUmVzcG9uc2UgXCIgKyBKU09OLnN0cmluZ2lmeShyZXNwb25zZV9qc29uKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZV9qc29uO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGF3YWl0IHNsZWVwKDIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVybGVuY29kZWQob2JqKSB7XHJcbiAgICByZXN1bHQgPSBfLmpvaW4oXy5tYXAoT2JqZWN0LmVudHJpZXMob2JqKSwgZnVuY3Rpb24obykge3JldHVybiBvWzBdICsgXCI9XCIgKyBvWzFdfSksIFwiJlwiKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8vIFVSTHMgdG8gbWFrZSBhcGkgY2FsbHNcclxuY29uc3QgQkFTRV9VUkwgPSBcImh0dHBzOi8vbWV0YW1vbi1hcGkucmFkaW9jYWNhLmNvbS91c20tYXBpXCI7XHJcbmNvbnN0IFRPS0VOX1VSTCA9IEJBU0VfVVJMICsgXCIvbG9naW5cIjtcclxuY29uc3QgTElTVF9NT05TVEVSX1VSTCA9IEJBU0VfVVJMICsgXCIvZ2V0V2FsbGV0UHJvcGVydHlCeVN5bWJvbFwiO1xyXG5jb25zdCBDSEFOR0VfRklHSFRFUl9VUkwgPSBCQVNFX1VSTCArIFwiL2lzRmlnaHRNb25zdGVyXCI7XHJcbmNvbnN0IFNUQVJUX0ZJR0hUX1VSTCA9IEJBU0VfVVJMICsgXCIvc3RhcnRCYXR0bGVcIjtcclxuY29uc3QgTElTVF9CQVRUTEVSX1VSTCA9IEJBU0VfVVJMICsgXCIvZ2V0QmF0dGVsT2JqZWN0c1wiO1xyXG5jb25zdCBXQUxMRVRfUFJPUEVSVFlfTElTVCA9IEJBU0VfVVJMICsgXCIvZ2V0V2FsbGV0UHJvcGVydHlMaXN0XCI7XHJcbmNvbnN0IExWTF9VUF9VUkwgPSBCQVNFX1VSTCArIFwiL3VwZGF0ZU1vbnN0ZXJcIjtcclxuY29uc3QgTUlOVF9FR0dfVVJMID0gQkFTRV9VUkwgKyBcIi9jb21wb3NlTW9uc3RlckVnZ1wiO1xyXG5cclxuY2xhc3MgTWV0YW1vbklzbGFuZCB7XHJcblx0Y29uc3RydWN0b3IoYWRkcmVzcywgc2lnbiwgbXNnKSB7XHJcblx0XHR0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xyXG5cdFx0dGhpcy5zaWduID0gc2lnbjtcclxuXHRcdHRoaXMubXNnID0gbXNnO1xyXG5cdFx0XHJcbiAgICAgICAgdGhpcy5ub3RfZW5vdWdoX21vbmV5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b3RhbF9icF9udW0gPSAwO1xyXG4gICAgICAgIHRoaXMudG90YWxfc3VjY2VzcyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbF9mYWlsID0gMDtcclxuICAgICAgICB0aGlzLm10bV9zdGF0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSBudWxsO1xyXG5cdH1cclxuXHRcclxuXHRhc3luYyBpbml0VG9rZW4oKSB7XHJcblx0XHRjb25zdCBwYXlsb2FkID0gXCJhZGRyZXNzPVwiICsgdGhpcy5hZGRyZXNzICsgXCImc2lnbj1cIiArIHRoaXMuc2lnbiArIFwiJm1zZz1cIiArIHRoaXMubXNnO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hfbG9vcChUT0tFTl9VUkwsIFwicG9zdFwiLCBwYXlsb2FkLCB7XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn0pO1xyXG5cclxuICAgICAgICBpZiAocmVzcG9uc2VbXCJjb2RlXCJdID09IFwiU1VDQ0VTU1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSByZXNwb25zZVtcImRhdGFcIl07XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gICAgXHJcblx0fVxyXG5cdFxyXG4gICAgYXN5bmMgY2hhbmdlRmlnaHRlcihtb25zdGVyX2lkKSB7XHJcbiAgICAgICAgLy8gU3dpdGNoIHRvIG5leHQgbWV0YW1vbiBpZiB5b3UgaGF2ZSBmZXdcclxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgICAgICBcIm1ldGFtb25JZFwiOiBtb25zdGVyX2lkLFxyXG4gICAgICAgICAgICBcImFkZHJlc3NcIjogdGhpcy5hZGRyZXNzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXdhaXQgZmV0Y2hfbG9vcChDSEFOR0VfRklHSFRFUl9VUkwsIFwicG9zdFwiLCB1cmxlbmNvZGVkKHBheWxvYWQpLCB0aGlzLmhlYWRlcnNUb2tlbkFuZENUKCkpO1xyXG5cdH1cclxuXHRcclxuXHRhc3luYyBsaXN0T3Bwb25lbnRzKG1vbnN0ZXJfaWQsIGZyb250PTEpIHtcclxuICAgICAgICAvLyBPYnRhaW4gbGlzdCBvZiBvcHBvbmVudHNcclxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgICAgICBcImFkZHJlc3NcIjogdGhpcy5hZGRyZXNzLFxyXG4gICAgICAgICAgICBcIm1ldGFtb25JZFwiOiBtb25zdGVyX2lkLFxyXG4gICAgICAgICAgICBcImZyb250XCI6IGZyb250LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hfbG9vcChMSVNUX0JBVFRMRVJfVVJMLCBcInBvc3RcIiwgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2VbXCJkYXRhXCJdW1wib2JqZWN0c1wiXTtcclxuXHR9XHJcblxyXG5cdGhlYWRlcnNUb2tlbiAoKSB7XHJcblx0XHRyZXR1cm4ge1wiYWNjZXNzVG9rZW5cIjogdGhpcy50b2tlbn07XHRcclxuXHR9XHJcblxyXG4gICAgaGVhZGVyc1Rva2VuQW5kQ1QgKCkge1xyXG5cdFx0cmV0dXJuIHtcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxyXG4gICAgICAgICAgICAgICAgXCJhY2Nlc3NUb2tlblwiOiB0aGlzLnRva2VufTtcdFxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0T2J0YWluIGxpc3Qgb2YgTWV0YW1vbnMgaW4gdGhlIHdhbGxldFxyXG5cdCAqL1xyXG5cdGFzeW5jIHVwZGF0ZVdhbGxldCgpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgIGxldCBwYWdlID0gMTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1wiYWRkcmVzc1wiOiB0aGlzLmFkZHJlc3MsIFwicGFnZVwiOiBwYWdlLCBcInBhZ2VTaXplXCI6IDYwfTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaF9sb29wKFdBTExFVF9QUk9QRVJUWV9MSVNULCBcInBvc3RcIiwgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlW1wiY29kZVwiXSAhPSBcIlNVQ0NFU1NcIilcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuXHRcdFx0Y29uc3QgbXRtcyA9IHJlc3BvbnNlW1wiZGF0YVwiXVtcIm1ldGFtb25MaXN0XCJdO1xyXG4gICAgICAgICAgICBpZiAobXRtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIG10bXMpO1xyXG4gICAgICAgICAgICAgICAgcGFnZSArPSAxO1xyXG5cdFx0XHR9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdFx0fTtcclxuXHRcdFxyXG4gICAgICAgIHRoaXMubWV0YW1vbnMgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgYSBtZXRhbW9uIHdpdGggdG9rZW4gbW9uc3Rlcl90b2tlbl9pZCBpbiB0aGUgbGlzdCBvZiBtZXRhbW9ucy5cclxuICAgICAqL1xyXG4gICAgbWV0YW1vbl9pZHgobW9uc3Rlcl90b2tlbl9pZCkge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgbW9uc3RlciBvZiB0aGlzLm1ldGFtb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChtb25zdGVyLnRva2VuSWQgPT0gbW9uc3Rlcl90b2tlbl9pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cdFxyXG5cdC8qKlxyXG5cdFBlcmZvcm0gYWxsIGJhdHRsZXMgb2YgYSBsaXN0IG9mIG1vbnN0ZXJzXHJcblx0ICovXHJcblx0YXN5bmMgYmF0dGxlIChtb25zdGVycywgc3RyYXRlZ3k9XCJ3ZWFrZXN0XCIsIGxldmVsdXA9dHJ1ZSkge1xyXG4gICAgICAgIC8vIGNvbnN0IHdhbGxldF9tb25zdGVycyA9IHRoaXMudXBkYXRlV2FsbGV0KCk7XHJcbiAgICAgICAgdGhpcy50b3RhbF9sZXZlbF91cHMgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBtb25zdGVyIG9mIG1vbnN0ZXJzKSB7XHJcblx0XHRcdGlmIChtb25zdGVyLnRlYXIgPT0gMClcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRlYXIgPSBtb25zdGVyLnRlYXI7XHJcbiAgICAgICAgICAgIC8vIGxldmVsID0gbW9uc3Rlci5nZXQoXCJsZXZlbFwiKVxyXG4gICAgICAgICAgICBjb25zdCBiYXR0bGVycyA9IGF3YWl0IHRoaXMubGlzdE9wcG9uZW50cyhtb25zdGVyLmlkKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0dGxlciA9IE1ldGFtb25Jc2xhbmQucGlja09wcG9uZW50KGJhdHRsZXJzLCBzdHJhdGVneSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldF9tb25zdGVyX2lkID0gYmF0dGxlci5pZDtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2hhbmdlRmlnaHRlcihtb25zdGVyLmlkKTtcclxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZDogUGFzcyB0aGUgaW5kZXggb2YgdGhlIG1vbnN0ZXIgaW4gdGhlIGN1cnJlbnQgdGFibGVcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIHVwZGF0ZU1ldGFtb25UYWJsZSB1c2VzIG1ldGFtb24gb2JqZWN0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBiYXR0bGVzXHJcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBsaXN0IG9mIG1ldGFtb25zIGluIG1pIGdldHMgdXBkYXRlZCBhZnRlciBsZXZlbCB1cHMsIHRodXMgaXQgd291bGQgbm90IGZpbmQgdGhlIG1ldGFtb25zIGFueW1vcmVcclxuICAgICAgICAgICAgY29uc3QgbW9uc3Rlcl90YWJsZV9pZHggPSB0aGlzLm1ldGFtb25faWR4KG1vbnN0ZXIudG9rZW5JZCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmF0dGxlTWV0YW1vbihtb25zdGVyLCBtb25zdGVyX3RhYmxlX2lkeCwgdGFyZ2V0X21vbnN0ZXJfaWQsIHRlYXIsIGxldmVsdXApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubm90X2Vub3VnaF9tb25leSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdFx0fVxyXG4gICAgICAgIFxyXG5cdFx0Y29uc3QgdG90YWxfY291bnQgPSB0aGlzLnRvdGFsX3N1Y2Nlc3MgKyB0aGlzLnRvdGFsX2ZhaWw7XHJcbiAgICAgICAgbGV0IHN1Y2Nlc3NfcGVyY2VudCA9IDAuMDtcclxuICAgICAgICBpZiAodG90YWxfY291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3NfcGVyY2VudCA9IHRoaXMudG90YWxfc3VjY2VzcyAvIHRvdGFsX2NvdW50O1xyXG5cdFx0fTtcclxuXHJcbiAgICAgICAgLy8gU3RhdHMgb2YgYWxsIGJhdHRsZXNcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgICAgICAgXCJ3b25cIjogdGhpcy50b3RhbF9zdWNjZXNzLFxyXG4gICAgICAgICAgICBcImRlZmVhdHNcIjogdGhpcy50b3RhbF9mYWlsLFxyXG4gICAgICAgICAgICBcIndpbl9yYXRlXCI6IHN1Y2Nlc3NfcGVyY2VudCxcclxuICAgICAgICAgICAgXCJmcmFnbWVudHNcIjogdGhpcy50b3RhbF9icF9udW0sXHJcbiAgICAgICAgICAgIFwibGV2ZWxfdXBzXCI6IHRoaXMudG90YWxfbGV2ZWxfdXBzLFxyXG4gICAgICAgICAgICBcInRpbWVzdGFtcFwiOiBEYXRlLm5vdygpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtzdGF0cywgdGhpcy5tdG1fc3RhdHNdO1xyXG5cdH1cclxuXHRcclxuICAgIC8qKlxyXG5cdE1haW4gbWV0aG9kIGZvciBiYXR0ZWxuZyB3aXRoIGEgc3BlY2lmaWMgbWV0YW1vblxyXG5cdCAqL1xyXG5cdGFzeW5jIGJhdHRsZU1ldGFtb24obW9uc3RlciwgbW9uc3Rlcl90YWJsZV9pZHgsIHRhcmdldF9tb25zdGVyX2lkLCBsb29wX2NvdW50PTEsIGxldmVsdXA9dHJ1ZSkge1xyXG4gICAgICAgIGxldCBzdWNjZXNzID0gMDtcclxuICAgICAgICBsZXQgZmFpbCA9IDA7XHJcbiAgICAgICAgbGV0IHRvdGFsX2JwX2ZyYWdtZW50X251bSA9IDA7XHJcbiAgICAgICAgY29uc3QgbXlfbW9uc3Rlcl9pZCA9IG1vbnN0ZXIuaWQ7XHJcbiAgICAgICAgY29uc3QgbXlfbW9uc3Rlcl90b2tlbl9pZCA9IHBhcnNlSW50KG1vbnN0ZXIudG9rZW5JZCk7XHJcbiAgICAgICAgbGV0IG15X2xldmVsID0gbW9uc3Rlci5sZXZlbDtcclxuICAgICAgICBjb25zdCBteV9wb3dlciA9IG1vbnN0ZXIuc2NhO1xyXG4gICAgICAgIGxldCBiYXR0bGVfbGV2ZWwgPSBNZXRhbW9uSXNsYW5kLnBpY2tCYXR0bGVMZXZlbChteV9sZXZlbCk7XHJcbiAgICAgICAgY29uc3QgaW5pdF90ZWFyID0gbW9uc3Rlci50ZWFyO1xyXG4gICAgICAgIGxldCBleHBlcmllbmNlID0gbW9uc3Rlci5leHA7XHJcbiAgICAgICAgbGV0IGV4cF90b19uZXh0ID0gbW9uc3Rlci5leHBNYXg7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGNvdW50ID0gMDsgY291bnQgPCBsb29wX2NvdW50OyBjb3VudCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm1vbnN0ZXJBXCI6IG15X21vbnN0ZXJfaWQsXHJcbiAgICAgICAgICAgICAgICBcIm1vbnN0ZXJCXCI6IHRhcmdldF9tb25zdGVyX2lkLFxyXG4gICAgICAgICAgICAgICAgXCJhZGRyZXNzXCI6IHRoaXMuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIFwiYmF0dGxlTGV2ZWxcIjogYmF0dGxlX2xldmVsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoX2xvb3AoU1RBUlRfRklHSFRfVVJMLCBcInBvc3RcIiwgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSByZXNwb25zZS5jb2RlO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA9PSBcIkJBVFRMRV9OT1BBWVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vdF9lbm91Z2hfbW9uZXkgPSB0cnVlO1xyXG5cdFx0XHRcdGVycm9yX21zZyhcIk5vdCBlbm91Z2ggdVJBQ0EgdG8gcGxheSBvbiBNZXRhbW9uIElzbGFuZCFcIiwgXCJkYW5nZXJcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHRcdFx0fVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09IFwiU1VDQ0VTU1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZ2h0X3Jlc3VsdCA9IGRhdGEuY2hhbGxlbmdlUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnBfZnJhZ21lbnRfbnVtID0gZGF0YS5icEZyYWdtZW50TnVtO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZXJpZW5jZV9pbmNyID0gZGF0YS5jaGFsbGVuZ2VFeHA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbGV2ZWwgdXBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1wibmZ0SWRcIjogbXlfbW9uc3Rlcl9pZCwgXCJhZGRyZXNzXCI6IHRoaXMuYWRkcmVzc31cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaF9sb29wKExWTF9VUF9VUkwsIFwicG9zdFwiLCAgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gcmVzLmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT0gXCJTVUNDRVNTXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXlfbGV2ZWwgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxlYWd1ZSBsZXZlbCBpZiBuZXcgbGV2ZWwgaXMgMjEgb3IgNDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0dGxlX2xldmVsID0gTWV0YW1vbklzbGFuZC5waWNrQmF0dGxlTGV2ZWwobXlfbGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsX2xldmVsX3VwcyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlcmllbmNlID0gZXhwZXJpZW5jZSAtIGV4cF90b19uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byB1cGRhdGUgdGhlIG1ldGFtb24gdG8gdXBkYXRlIHRoZSBleHBNYXggZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsX21vbnN0ZXJzID0gYXdhaXQgdGhpcy51cGRhdGVXYWxsZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwX3RvX25leHQgPSBhbGxfbW9uc3RlcnMuZmluZChlbGVtZW50ID0+IGVsZW1lbnQudG9rZW5JZCA9PSBteV9tb25zdGVyX3Rva2VuX2lkKS5leHBNYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbF9icF9udW0gKz0gYnBfZnJhZ21lbnRfbnVtO1xyXG4gICAgICAgICAgICAgICAgdG90YWxfYnBfZnJhZ21lbnRfbnVtICs9IGJwX2ZyYWdtZW50X251bTtcclxuICAgICAgICAgICAgICAgIGV4cGVyaWVuY2UgKz0gZXhwZXJpZW5jZV9pbmNyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZ2h0X3Jlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsX3N1Y2Nlc3MgKz0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG90YWxfZmFpbCArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBzdGF0ZSBpbiBVSVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlTWV0YW1vblRhYmxlKG1vbnN0ZXIsIG1vbnN0ZXJfdGFibGVfaWR4LCBteV9sZXZlbCwgZXhwZXJpZW5jZSwgaW5pdF90ZWFyIC0gY291bnQgLSAxLCBwcm9ncmVzc19mcm9tX3RlYXIoaW5pdF90ZWFyIC0gY291bnQgLSAxKSwgc3VjY2VzcywgdG90YWxfYnBfZnJhZ21lbnRfbnVtKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyX210bV9zdGF0cyA9IHtcclxuICAgICAgICAgICAgXCJtZXRhbW9uX2lkXCI6IG15X21vbnN0ZXJfdG9rZW5faWQsXHJcbiAgICAgICAgICAgIFwibGVhZ3VlX2xldmVsXCI6IGJhdHRsZV9sZXZlbCxcclxuICAgICAgICAgICAgXCJiYXR0bGVzXCI6IGxvb3BfY291bnQsXHJcbiAgICAgICAgICAgIFwicG93ZXJcIjogbXlfcG93ZXIsXHJcbiAgICAgICAgICAgIFwiZXhwZXJpZW5jZVwiOiBleHBlcmllbmNlLFxyXG4gICAgICAgICAgICBcIm1ldGFtb25fbGV2ZWxcIjogbXlfbGV2ZWwsXHJcbiAgICAgICAgICAgIFwicmFyaXR5XCI6IG1vbnN0ZXIucmFyaXR5LFxyXG4gICAgICAgICAgICBcIndvblwiOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICBcImZyYWdtZW50c1wiOiB0b3RhbF9icF9mcmFnbWVudF9udW0sXHJcbiAgICAgICAgICAgIFwidGltZXN0YW1wXCI6IERhdGUubm93KClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdG1fc3RhdHMucHVzaChjdXJyX210bV9zdGF0cyk7XHJcbiAgICB9XHJcblx0XHJcblx0YXN5bmMgbWludEVnZ3MgKCkge1xyXG4gICAgICAgIC8vIGF3YWl0IHRoaXMuaW5pdF90b2tlbigpO1xyXG5cclxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1wiYWRkcmVzc1wiOiB0aGlzLmFkZHJlc3N9O1xyXG5cclxuICAgICAgICBsZXQgbWludGVkX2VnZ3MgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoX2xvb3AoTUlOVF9FR0dfVVJMLCBcInBvc3RcIiwgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHJlc1tcImNvZGVcIl07XHJcbiAgICAgICAgICAgIGlmIChjb2RlICE9IFwiU1VDQ0VTU1wiKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIG1pbnRlZF9lZ2dzICs9IDE7XHJcblx0XHR9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNaW50ZWQgRWdncyBUb3RhbDogXCIgKyBtaW50ZWRfZWdncyk7XHJcbiAgICAgICAgcmV0dXJuIG1pbnRlZF9lZ2dzO1xyXG5cdH1cclxuXHRcclxuXHQvLyBTdGF0aWMgbWV0aG9kc1xyXG5cdFxyXG5cdC8qKlxyXG5cdFBpY2sgYW4gb3Bwb25lbnQgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gc3RyYXRlZ3kgKFwid2Vha2VzdFwiIG9yIFwicmFuZG9tXCIpXHJcblx0ICovXHJcblx0c3RhdGljIHBpY2tPcHBvbmVudChtb25zdGVyc19saXN0LCBzdHJhdGVneT1cIndlYWtlc3RcIikge1xyXG5cdCAgICBsZXQgYmF0dGxlcnMgPSBbXTtcclxuXHRcdGZvciAobGV0IG1vbnN0ZXIgb2YgbW9uc3RlcnNfbGlzdCkge1xyXG5cdFx0XHRpZiAobW9uc3RlcltcInJhcml0eVwiXSA9PSBcIk5cIilcclxuXHRcdFx0XHRiYXR0bGVycy5wdXNoKG1vbnN0ZXIpO1xyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0aWYgKGJhdHRsZXJzLmxlbmd0aCA9PSAwKSB7XHJcblx0XHRcdGZvciAobGV0IG1vbnN0ZXIgb2YgbW9uc3RlcnNfbGlzdCkge1xyXG5cdFx0XHRcdGlmIChtb25zdGVyW1wicmFyaXR5XCJdID09IFwiUlwiKVxyXG5cdFx0XHRcdFx0YmF0dGxlcnMucHVzaChtb25zdGVyKTtcclxuXHRcdFx0fTtcdFx0XHJcblx0XHR9O1xyXG5cdCAgICAgICAgXHJcblx0XHJcblx0ICAgIGlmIChzdHJhdGVneSA9PSBcIndlYWtlc3RcIilcclxuXHQgICAgICAgIHJldHVybiBNZXRhbW9uSXNsYW5kLnBpY2tPcHBvbmVudFdlYWtlc3QoYmF0dGxlcnMpO1xyXG5cdFx0ZWxzZSBpZiAoc3RyYXRlZ3kgPT0gXCJyYW5kb21cIilcclxuXHQgICAgICAgIHJldHVybiBNZXRhbW9uSXNsYW5kLnBpY2tPcHBvbmVudFJhbmRvbShiYXR0bGVycyk7XHRcdFxyXG5cdH07XHJcblx0XHJcblx0c3RhdGljIHBpY2tPcHBvbmVudFJhbmRvbShiYXR0bGVycykge1xyXG5cdCAgICByZXR1cm4gYmF0dGxlcnNbZ2V0UmFuZG9tSW50KGxlbihiYXR0bGVycykpXTtcclxuXHR9O1xyXG5cdFxyXG5cdHN0YXRpYyBwaWNrT3Bwb25lbnRXZWFrZXN0KGJhdHRsZXJzKSB7XHJcblx0ICAgIGxldCBiZXN0X2JhdHRsZXIgPSBiYXR0bGVyc1swXTtcclxuXHQgICAgbGV0IHNjb3JlX21pbiA9IGJlc3RfYmF0dGxlcltcInNjYVwiXTtcclxuXHQgICAgXHJcblx0XHRmb3IgKGxldCBiYXR0bGVyIG9mIGJhdHRsZXJzKSB7XHJcblx0ICAgICAgICBpZiAoYmF0dGxlcltcInNjYVwiXSA8IHNjb3JlX21pbikge1xyXG5cdCAgICAgICAgICAgIGJlc3RfYmF0dGxlciA9IGJhdHRsZXI7XHJcblx0ICAgICAgICAgICAgc2NvcmVfbWluID0gYmF0dGxlcltcInNjYVwiXTtcclxuXHRcdFx0fTtcclxuXHRcdH07XHJcblx0ICAgIHJldHVybiBiZXN0X2JhdHRsZXI7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHRQaWNrIGEgYmF0dGxlIGxlYWd1ZSAoY3VycmVudGx5IHRoZXJlIGFyZSAzISlcclxuXHQgKi9cclxuXHRzdGF0aWMgcGlja0JhdHRsZUxldmVsIChsZXZlbD0xKSB7XHJcblx0ICAgIGlmICgoMjEgPD0gbGV2ZWwpICYmIChsZXZlbCA8PSA0MCkpIHtcclxuXHQgICAgICAgIHJldHVybiAyO1xyXG5cdFx0fSBlbHNlIGlmICgoNDEgPD0gbGV2ZWwpICYmIChsZXZlbCA8PSA2MCkpIHtcclxuXHQgICAgICAgIHJldHVybiAzO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0ICAgIHJldHVybiAxO1xyXG5cdH07XHJcbn07XHJcblxyXG5sZXQgbWkgPSBudWxsO1xyXG5jb25zdCBNQVhfVEVBUiA9IDIwO1xyXG5cclxuZnVuY3Rpb24gcHJvZ3Jlc3NfZnJvbV90ZWFyKHRlYXIpIHtcclxuICAgIHJldHVybiAoTUFYX1RFQVIgLSB0ZWFyKSoxMDAuMC9NQVhfVEVBUjtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFtb25zIChhZGRyZXNzLCBzaWduLCBtc2cpIHtcclxuICAgIGVuYWJsZV9zdWJtaXRfYnV0dG9uKGZhbHNlKTtcclxuICAgIHNob3dfc3Bpbm5lcih0cnVlKTtcclxuICAgIGJ1dHRvbl90ZXh0KFwiTG9hZGluZy4uLlwiKTtcclxuXHJcbiAgICBhd2FpdCBsb2coXCJMb2FkaW5nIE1ldGFtb24gdGFibGUgXCIgKyBKU09OLnN0cmluZ2lmeSh7XCJhXCI6IDEsIFwiYlwiOiAyfSkpO1xyXG5cclxuICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcclxuICAgIGlmIChtaSA9PSBudWxsKSB7XHJcbiAgICAgICAgbWkgPSBuZXcgTWV0YW1vbklzbGFuZChhZGRyZXNzLCBzaWduLCBtc2cpO1xyXG4gICAgICAgIHN1Y2Nlc3MgPSBhd2FpdCBtaS5pbml0VG9rZW4oKTtcclxuXHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIGVycm9yX21zZyhcIkNvdWxkIG5vdCBsb2dpbiB0byBNZXRhbW9uIElzbGFuZCFcIiwgXCJkYW5nZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YW1vbnMgPSBhd2FpdCBtaS51cGRhdGVXYWxsZXQoKTtcclxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IF8ubWFwKG1ldGFtb25zLCBmdW5jdGlvbiAobSkge3JldHVybiBwcm9ncmVzc19mcm9tX3RlYXIobS50ZWFyKTt9KTtcclxuICAgICAgICBjb25zdCB3aW5zID0gQXJyYXkuZnJvbSgnLScucmVwZWF0KG1ldGFtb25zLmxlbmd0aCkpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50cyA9IEFycmF5LmZyb20oJy0nLnJlcGVhdChtZXRhbW9ucy5sZW5ndGgpKTtcclxuXHJcbiAgICAgICAgZmlsbE1ldGFtb25UYWJsZShtZXRhbW9ucywgcHJvZ3Jlc3MsIHdpbnMsIGZyYWdtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlX3N1Ym1pdF9idXR0b24odHJ1ZSk7XHJcbiAgICBzaG93X3NwaW5uZXIoZmFsc2UpO1xyXG4gICAgYnV0dG9uX3RleHQoXCJTdGFydCBiYXR0bGVzIVwiKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc3RhcnRCYXR0bGVzICgpIHtcclxuICAgIGlmICghbWkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGVuYWJsZV9zdWJtaXRfYnV0dG9uKGZhbHNlKTtcclxuICAgIHNob3dfc3Bpbm5lcih0cnVlKTtcclxuICAgIGJ1dHRvbl90ZXh0KFwiQmF0dGxpbmcuLi5cIik7XHJcblxyXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0cmF0ZWd5XCIpLnZhbHVlO1xyXG4gICAgY29uc3QgbGV2ZWx1cCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGV2ZWx1cFwiKS5jaGVja2VkO1xyXG4gICAgY29uc3QgbWludGVnZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1pbnRlZ2dzXCIpLmNoZWNrZWQ7XHJcbiAgICBjb25zdCBzdGF0aXN0aWNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0aXN0aWNzXCIpLmNoZWNrZWQ7XHJcblxyXG4gICAgbGV0IG1ldGFtb25zX3RvX3BsYXkgPSBbXTtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBmb3IgKGxldCBtZXRhbW9uIG9mIG1pLm1ldGFtb25zKSB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXRtXCIgKyBjb3VudCkuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBtZXRhbW9uc190b19wbGF5LnB1c2gobWV0YW1vbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvdW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWkuYmF0dGxlKG1ldGFtb25zX3RvX3BsYXksIHN0cmF0ZWd5LCBsZXZlbHVwKTtcclxuXHJcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHJlc3VsdFswXTtcclxuICAgICAgICBjb25zdCBtdG1fc3RhdHMgPSByZXN1bHRbMV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3RhdHNbXCJtaW50ZWRfZWdnc1wiXSA9IDA7XHJcbiAgICAgICAgaWYgKG1pbnRlZ2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbnRlZF9lZ2dzID0gYXdhaXQgbWkubWludEVnZ3MoKTtcclxuICAgICAgICAgICAgc3RhdHNbXCJtaW50ZWRfZWdnc1wiXSA9IG1pbnRlZF9lZ2dzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0YXRpc3RpY3MpXHJcbiAgICAgICAgICAgIHNlbmRTdGF0cyhbc3RhdHMsIG10bV9zdGF0cywgc3RhdGlzdGljc10pO1xyXG5cclxuICAgICAgICBmaWxsU3VtbWFyeVRhYmxlKHN0YXRzKTtcclxuICAgICAgICBzaG93X2JhdHRsZV9yZXN1bHRzKCk7XHJcbiAgICB9XHJcbiAgICBhd2FpdCBtaS51cGRhdGVXYWxsZXQoKTtcclxuICAgIFxyXG4gICAgZW5hYmxlX3N1Ym1pdF9idXR0b24odHJ1ZSk7XHJcbiAgICBzaG93X3NwaW5uZXIoZmFsc2UpO1xyXG4gICAgYnV0dG9uX3RleHQoXCJTdGFydCBiYXR0bGVzIVwiKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2VuZFN0YXRzKGRhdGEpIHtcclxuICAgIGF3YWl0IGZldGNoKCdzdGF0cycsIHtcclxuICAgICAgICBtZXRob2Q6ICdwb3N0JyxcclxuICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICAgJ1gtQ1NSRi1UT0tFTic6IGdldENvb2tpZSgnY3NyZl9hY2Nlc3NfdG9rZW4nKX0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyBVc2VyIEludGVyZmFjZVxyXG5cclxuZnVuY3Rpb24gZmlsbE1ldGFtb25UYWJsZSAobWV0YW1vbnMsIHByb2dyZXNzLCB3aW5zLCBmcmFnbWVudHMpIHtcclxuICAgIGNvbnN0IHRhYmxlX2JvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1ldGFtb25fdGFibGVfYm9keVwiKTtcclxuXHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG5cdGZvciAobGV0IG1ldGFtb24gb2YgbWV0YW1vbnMpIHtcclxuXHRcdC8vIDx0cj5cdFxyXG5cdFx0Y29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tib3hcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+IDxpbnB1dCBpZD1cIm10bScgKyBjb3VudCArICdcIiBuYW1lPVwibXRtJyArIGNvdW50ICsgJ1wiIHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwic2VsZWN0LWl0ZW0gY2hlY2tib3ggZm9ybS1jaGVjay1pbnB1dFwiIGNoZWNrZWQ+IDwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogVG9rZW4gSWRcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIG1ldGFtb24udG9rZW5JZCArICcgPC90ZD4nKTtcclxuICAgICAgICAvLyBEYXRhOiBQaWNcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+IDxpbWcgc3JjPVwiJyArIG1ldGFtb24uaW1hZ2VVcmwgICsgJ1wiIGFsdD1cIicgKyBtZXRhbW9uLnRva2VuSWQgKyAnXCI+PC90ZD4nKTtcclxuICAgICAgICAvLyBEYXRhOiBSYXJpdHlcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIG1ldGFtb24ucmFyaXR5ICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogUG93ZXJcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIG1ldGFtb24uc2NhICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogTGV2ZWxcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIG1ldGFtb24ubGV2ZWwgKyAnPGk+LycgKyBtZXRhbW9uLmxldmVsTWF4ICsgJzwvaT48L3RkPicpO1xyXG4gICAgICAgIC8vIERhdGE6IEV4cGVyaWVuY2VcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIG1ldGFtb24uZXhwICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogRXhwZXJpZW5jZVxyXG4gICAgICAgIHJvdy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgJzx0ZD4nICsgbWV0YW1vbi50ZWFyICsgJzxpPi8yMDwvaT48L3RkPicpO1xyXG4gICAgICAgIC8vIERhdGE6IFByb2dyZXNzIGJhclxyXG4gICAgICAgIGxldCBhZGRfY2xhc3MgPSBcIlwiO1xyXG4gICAgICAgIGlmIChwcm9ncmVzc1tjb3VudF0gPT0gMTAwKSB7XHJcbiAgICAgICAgICAgIGFkZF9jbGFzcyA9IFwicHJvZ3Jlc3NfZmluaXNoZWRcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPiA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIj4gPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhciAnICsgYWRkX2NsYXNzICsgJ1wiIHJvbGU9XCJwcm9ncmVzc2JhclwiIHN0eWxlPVwid2lkdGg6ICcgKyBwcm9ncmVzc1tjb3VudF0gKyAnJVwiIGFyaWEtdmFsdWVub3c9XCInICsgcHJvZ3Jlc3NbY291bnRdICsgJ1wiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiPjwvZGl2PjwvZGl2PjwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogV2luc1xyXG4gICAgICAgIHJvdy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgJzx0ZD4nICsgd2luc1tjb3VudF0gKyAnPC90ZD4nKTtcclxuICAgICAgICAvLyBEYXRhOiBGcmFnbWVudHNcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIGZyYWdtZW50c1tjb3VudF0gKyAnPC90ZD4nKTtcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHJvdyB0byB0YWJsZVxyXG4gICAgICAgIHRhYmxlX2JvZHkuYXBwZW5kQ2hpbGQocm93KTtcclxuICAgICAgICBjb3VudCsrO1xyXG5cdH1cclxuXHJcbiAgICBzZXRDaGVja2JveE9uQ2xpY2tFdmVudHMoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZU1ldGFtb25UYWJsZSAobWV0YW1vbiwgbW9uc3Rlcl90YWJsZV9pZHgsIGxldmVsLCBleHBlcmllbmNlLCB0ZWFyLCBwcm9ncmVzcywgd2lucywgZnJhZ21lbnRzKSB7XHJcbiAgICBjb25zdCB0YWJsZV9ib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZXRhbW9uX3RhYmxlX2JvZHlcIik7XHJcblxyXG4gICAgY29uc3QgdHJfdGFnID0gdGFibGVfYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRyXCIpW21vbnN0ZXJfdGFibGVfaWR4XTtcclxuXHJcbiAgICBpZiAoIXRyX3RhZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRhYmxlX2JvZHksIG1vbnN0ZXJfdGFibGVfaWR4LCB0YWJsZV9ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHJcIikubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0ZF90YWdzID0gdHJfdGFnLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIik7XHJcblxyXG4gICAgdGRfdGFnc1s1XS5pbm5lckhUTUwgPSBsZXZlbCArICc8aT4vJyArIG1ldGFtb24ubGV2ZWxNYXggKyAnPC9pPic7XHJcbiAgICB0ZF90YWdzWzZdLmlubmVySFRNTCA9IFN0cmluZyhleHBlcmllbmNlKTtcclxuICAgIHRkX3RhZ3NbN10uaW5uZXJIVE1MID0gdGVhciArICc8aT4vJyArIE1BWF9URUFSICsgJzwvaT4nO1xyXG4gICAgbGV0IGFkZF9jbGFzcyA9IFwiXCI7XHJcbiAgICBpZiAocHJvZ3Jlc3MgPT0gMTAwKSB7XHJcbiAgICAgICAgYWRkX2NsYXNzID0gXCJwcm9ncmVzc19maW5pc2hlZFwiXHJcbiAgICB9O1xyXG4gICAgdGRfdGFnc1s4XS5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cInByb2dyZXNzXCI+IDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXIgJyArIGFkZF9jbGFzcyArICdcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiBzdHlsZT1cIndpZHRoOiAnICsgcHJvZ3Jlc3MgKyAnJVwiIGFyaWEtdmFsdWVub3c9XCInICsgcHJvZ3Jlc3MgKyAnXCIgYXJpYS12YWx1ZW1pbj1cIjBcIiBhcmlhLXZhbHVlbWF4PVwiMTAwXCI+PC9kaXY+PC9kaXY+JztcclxuICAgIHRkX3RhZ3NbOV0uaW5uZXJIVE1MID0gU3RyaW5nKHdpbnMpO1xyXG4gICAgdGRfdGFnc1sxMF0uaW5uZXJIVE1MID0gU3RyaW5nKGZyYWdtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbGxTdW1tYXJ5VGFibGUgKHN0YXRzKSB7XHJcbiAgICBjb25zdCB0YWJsZV9ib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiYXR0bGUtcmVzdWx0c1wiKTtcclxuXHJcbiAgICBjb25zdCBzdGF0c19saXN0ID0gW3N0YXRzW1wid29uXCJdICsgc3RhdHNbXCJkZWZlYXRzXCJdLCBzdGF0c1tcIndvblwiXSwgc3RhdHNbXCJkZWZlYXRzXCJdLCAoTWF0aC5yb3VuZChzdGF0c1tcIndpbl9yYXRlXCJdICogMTAwMCkgLyAxMCkudG9GaXhlZCgxKSArIFwiJVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHNbXCJmcmFnbWVudHNcIl0sIHN0YXRzW1wibWludGVkX2VnZ3NcIl0sIHN0YXRzW1wibGV2ZWxfdXBzXCJdXTtcclxuICAgIGNvbnN0IHRyX3RhZ3MgPSB0YWJsZV9ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHJcIik7XHJcbiAgICBmb3IgKGxldCBuID0gMCA7IG4gPCBzdGF0c19saXN0Lmxlbmd0aCA7IG4rKykge1xyXG4gICAgICAgIGNvbnN0IHRkX3RhZyA9IHRyX3RhZ3Nbbl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKVsxXTtcclxuICAgICAgICB0ZF90YWcuaW5uZXJIVE1MID0gU3RyaW5nKHN0YXRzX2xpc3Rbbl0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYnV0dG9uX3RleHQgKGxhYmVsKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJhdHRsZS1zdWJtaXQtYnV0dG9uLXRleHRcIikudGV4dENvbnRlbnQgPSBsYWJlbDtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5hYmxlX3N1Ym1pdF9idXR0b24gKHZhbHVlKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJhdHRsZS1zdWJtaXQtYnV0dG9uXCIpLmRpc2FibGVkID0gIXZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93X3NwaW5uZXIgKHZhbHVlKSB7XHJcbiAgICBsZXQgc3RyX3ZhbCA9IHZhbHVlID8gXCJcIiA6IFwibm9uZVwiO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiYXR0bGUtc3VibWl0LWJ1dHRvblwiKS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic3Bpbm5lci1ib3JkZXJcIilbMF0uc3R5bGUuZGlzcGxheSA9IHN0cl92YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dfYmF0dGxlX3Jlc3VsdHMgKCkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiYXR0bGUtc3VibWl0LWJ1dHRvblwiKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRDaGVja2JveE9uQ2xpY2tFdmVudHMoKSB7XHJcbiAgICAvL2NvbHVtbiBjaGVja2JveCBzZWxlY3QgYWxsIG9yIGNhbmNlbFxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlbGVjdC1hbGxcIilbMF0ub25jbGljayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjaGVja2VkID0gdGhpcy5jaGVja2VkO1xyXG4gICAgICAgIFtdLmZvckVhY2guY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzZWxlY3QtaXRlbScpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICBpdGVtLmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL2NoZWNrIHNlbGVjdGVkIGl0ZW1zXHJcbiAgICBbXS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlbGVjdC1pdGVtXCIpLCAoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICBpdGVtLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcclxuICAgICAgICAgICAgbGV0IGFsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJzZWxlY3QtYWxsXCIpWzBdO1xyXG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgYm94ZXNcclxuICAgICAgICAgICAgY29uc3QgdG90YWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic2VsZWN0LWl0ZW1cIikubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgY2hlY2tlZCBib3hlc1xyXG4gICAgICAgICAgICBsZXQgbnVtX2NoZWNrZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc2VsZWN0LWl0ZW06Y2hlY2tlZCcpLmxlbmd0aDtcclxuICAgICAgICAgICAgYWxsLmNoZWNrZWQgPSBudW1fY2hlY2tlZD09PXRvdGFsO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciB0b29sdGlwVHJpZ2dlckxpc3QgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIl0nKSlcclxudmFyIHRvb2x0aXBMaXN0ID0gdG9vbHRpcFRyaWdnZXJMaXN0Lm1hcChmdW5jdGlvbiAodG9vbHRpcFRyaWdnZXJFbCkge1xyXG4gIHJldHVybiBuZXcgYm9vdHN0cmFwLlRvb2x0aXAodG9vbHRpcFRyaWdnZXJFbClcclxufSlcclxuXHJcblxyXG53aW5kb3cubG9hZE1ldGFtb25zID0gbG9hZE1ldGFtb25zO1xyXG4vL3dpbmRvdy5zdGFydEJhdHRsZXMgPSBzdGFydEJhdHRsZXM7IiwiaW1wb3J0IHsgbG9naW4gfSBmcm9tICcuL2xvZ2luLWF1dGguanMnO1xyXG5pbXBvcnQgeyBlcnJvcl9tc2cgfSBmcm9tICcuL3V0aWxzLmpzJztcclxuXHJcbmNvbnN0IEJTQ19DSEFJTl9JRCA9IDU2O1xyXG5cclxuW10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtZXRhbWFzay1sb2dpblwiKSwgKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICBpdGVtLm9uY2xpY2sgPSBhc3luYyAoKT0+e1xyXG4gICAgICAgIHRyeSAge1xyXG4gICAgICAgICAgICBpZiAoIWF3YWl0IGNoZWNrX21ldGFtYXNrKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNoZWNrX2NoYWluKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0X2FkZHJlc3MgPSBhd2FpdCBnZXRfd2FsbGV0X2FkZHJlc3MoKTtcclxuICAgICAgICAgICAgYXdhaXQgbG9naW4od2FsbGV0X2FkZHJlc3MsIHdpbmRvdy5ldGhlcmV1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09IDQwMDEpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yX21zZyhcIlVzZXIgZGVuaWVkIE1ldGFNYXNrIHRvIHNpZ24gdGhlIG1lc3NhZ2UuIFRoaXMgaXMgcmVxdWlyZWQgdG8gZW50ZXIgdGhlIE1ldGFtb24gSXNsYW5kLlwiLCBcImRhbmdlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gY2hlY2tfbWV0YW1hc2sod2FsbGV0X2FkZHJlc3MpXHJcbntcclxuICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHN1Y2Nlc3MgPSBldGhlcmV1bS5pc01ldGFNYXNrO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXN1Y2Nlc3Mpe1xyXG4gICAgICAgIGVycm9yX21zZyhcIkNhbm5vdCBmaW5kIE1ldGFtYXNrIVwiLCBcImRhbmdlclwiKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfY2hhaW4od2FsbGV0X2FkZHJlc3MpXHJcbntcclxuICAgIGlmIChldGhlcmV1bS5jaGFpbklkICE9IDU2KSB7XHJcbiAgICAgICAgZXJyb3JfbXNnKFwiWW91IG5lZWQgdG8gc3dpdGNoIHRvIEJpbmFuY2UgU21hcnQgQ2hhaW4gTWFpbm5ldCFcIiwgXCJkYW5nZXJcIik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldF93YWxsZXRfYWRkcmVzcygpXHJcbntcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7bWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIn0pO1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZVswXTtcclxuICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufSIsImltcG9ydCB7IGxvZ2luLCBoYW5kbGVfYXV0aCB9IGZyb20gXCIuL2xvZ2luLWF1dGguanNcIjtcclxuaW1wb3J0IHsgZ2VuUmFuZG9tTG9naW5Nc2csIGVycm9yX21zZyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCIuL2V0aGVycy01LjEuZXNtLm1pbi5qc1wiO1xyXG5cclxuLy9pbXBvcnQgbG9kYXNoIGZyb20gJ2xvZGFzaCc7XHJcbi8vIGltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzLXByb3ZpZGVyLWVuZ2luZVwiO1xyXG4vL2ltcG9ydCBXYWxsZXRDb25uZWN0UHJvdmlkZXIgZnJvbSBcIi4vd2FsbGV0Y29ubmVjdC13ZWIzLXByb3ZpZGVyXCI7XHJcblxyXG4vKiBpbXBvcnQgV2FsbGV0Q29ubmVjdENsaWVudCBmcm9tIFwiQHdhbGxldGNvbm5lY3QvY2xpZW50XCI7ICovXHJcbi8vY29uc3QgV2FsbGV0Q29ubmVjdFByb3ZpZGVyID0gd2luZG93LldhbGxldENvbm5lY3RQcm92aWRlci5kZWZhdWx0O1xyXG4vL2NvbnN0IFdlYjMgPSB3aW5kb3cuV2ViMy5kZWZhdWx0O1xyXG5sZXQgV2FsbGV0Q29ubmVjdFByb3ZpZGVyO1xyXG5pZiAod2luZG93LldhbGxldENvbm5lY3RQcm92aWRlcilcclxuICAgIFdhbGxldENvbm5lY3RQcm92aWRlciA9IHdpbmRvdy5XYWxsZXRDb25uZWN0UHJvdmlkZXIuZGVmYXVsdDtcclxuIFxyXG5sZXQgd2NfcHJvdmlkZXI7XHJcbiBcclxuW10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ3YWxsZXRjb25uZWN0LWxvZ2luXCIpLCAoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgIGl0ZW0ub25jbGljayA9IGFzeW5jICgpPT57XHJcbiAgICAgICAgLy8gIENyZWF0ZSBXYWxsZXRDb25uZWN0IFByb3ZpZGVyXHJcbiAgICAgICAgd2NfcHJvdmlkZXIgPSBuZXcgV2FsbGV0Q29ubmVjdFByb3ZpZGVyKHtcclxuICAgICAgICAgICAgLy9pbmZ1cmFJZDogXCIyN2U0ODRkY2Q5ZTNlZmNmZDI1YTgzYTc4Nzc3Y2RmMVwiLCAvLyBSZXF1aXJlZFxyXG4gICAgICAgICAgICBycGM6IHtcclxuICAgICAgICAgICAgICAgIDU2OiBcImh0dHBzOi8vYnNjLWRhdGFzZWVkLmJpbmFuY2Uub3JnL1wiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBjaGFpbklkOiA1NlxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYWNjb3VudHMgY2hhbmdlXHJcbiAgICAgICAgd2NfcHJvdmlkZXIub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKGFjY291bnRzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFjY291bnRzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gc2Vzc2lvbiBjb25uZWN0aW9uXHJcbiAgICAgICAgd2NfcHJvdmlkZXIub24oXCJjb25uZWN0XCIsIGNvbm5lY3QpO1xyXG5cclxuICAgICAgICAvL2lmIChnZXRfd2FsbGV0X2FkZHJlc3Mod2NfcHJvdmlkZXIpLmxlbmd0aCA+PSA0Mikge1xyXG4gICAgICAgICAgICAvL2F3YWl0IGNvbm5lY3QoKTtcclxuICAgICAgICAgICAgd2NfcHJvdmlkZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIC8vfVxyXG5cclxuICAgICAgICAgICAgLy8gIEVuYWJsZSBzZXNzaW9uICh0cmlnZ2VycyBRUiBDb2RlIG1vZGFsKVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgd2NfcHJvdmlkZXIuZW5hYmxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PSBcIkVycm9yOiBVc2VyIGNsb3NlZCBtb2RhbFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnKFwiVXNlciBjbG9zZWQgdGhlIHdpbmRvdyB0byBjb25uZWN0IHZpYSBXYWxsZXRDb25uZWN0LiBQbGVhc2UgbG9naW4gdG8gdXNlIE1ldGFtb24gTWFuYWdlci5cIiwgXCJkYW5nZXJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH07XHJcbn0pO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdCAoKSB7XHJcbiAgICBjb25zdCB3YWxsZXRfYWRkcmVzcyA9IGdldF93YWxsZXRfYWRkcmVzcyh3Y19wcm92aWRlcik7XHJcbiAgICBjb25zdCBtc2cgPSBnZW5SYW5kb21Mb2dpbk1zZygpO1xyXG5cclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHdjX3Byb3ZpZGVyLnNlbmQoXHJcbiAgICAgICAgJ3BlcnNvbmFsX3NpZ24nLFxyXG4gICAgICAgIFsgZXRoZXJzLnV0aWxzLmhleGxpZnkoZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKG1zZykpLCB3YWxsZXRfYWRkcmVzcy50b0xvd2VyQ2FzZSgpIF1cclxuICAgICk7XHJcblxyXG4gICAgY29uc29sZS5sb2coc2lnbmF0dXJlKTtcclxuXHJcbiAgICBhd2FpdCBoYW5kbGVfYXV0aCh3YWxsZXRfYWRkcmVzcywgbXNnLCBzaWduYXR1cmUpO1xyXG5cclxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCIvaW5kZXhcIjtcclxuXHJcbiAgICAvL2F3YWl0IGxvZ2luKHdhbGxldF9hZGRyZXNzLCB3Y19wcm92aWRlcik7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcih3Y19wcm92aWRlcik7XHJcbiAgICBjb25zdCBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduTWVzc2FnZShcIlRlc3RcIik7XHJcbiAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcclxuXHJcbiAgICBjb25zdCBhZGRyZXNzMiA9IHdjX3Byb3ZpZGVyLndjLmFjY291bnRzWzBdO1xyXG5cclxuICAgIGxldCBzaWduZWRNZXNzYWdlID0gYXdhaXQgd2NfcHJvdmlkZXIuc2VuZChcclxuICAgICAgICAncGVyc29uYWxfc2lnbicsXHJcbiAgICAgICAgWyBldGhlcnMudXRpbHMuaGV4bGlmeShldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoXCJUZXN0XCIpKSwgYWRkcmVzczIudG9Mb3dlckNhc2UoKSBdXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHdlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XHJcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHdlYjMuZXRoLmdldEFjY291bnRzKCk7XHJcbiAgICAqL1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0X3dhbGxldF9hZGRyZXNzKHdjX3Byb3ZpZGVyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiB3Y19wcm92aWRlci53Yy5hY2NvdW50c1swXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbn07IiwiaW1wb3J0IHsgZXJyb3JfbXNnIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcclxuXHJcbmZ1bmN0aW9uIHNob3dQcml2YWN5VG9hc3Qoc2hvdykge1xyXG4gICAgdmFyIHRvYXN0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnZHByVG9hc3QnKTtcclxuICAgIGlmICh0b2FzdEVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgdG9hc3QgPSBuZXcgYm9vdHN0cmFwLlRvYXN0KHRvYXN0RWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHNob3cpIHtcclxuICAgICAgICAgICAgdG9hc3Quc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdG9hc3QuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG4vLyBFdmVudCBMaXN0ZW5lclxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgaW5pdENvbnNlbnQpO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gaW5pdENvbnNlbnQgKCkge1xyXG4gICAgaWYgKGNvbnNlbnRSZXF1aXJlZCgpKSB7XHJcbiAgICAgICAgc2hvd1ByaXZhY3lUb2FzdCh0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IHNlbmRDb25zZW50KFwiTk9UX1JFUVVJUkVEXCIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIG5vdEFncmVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByaXZhY3ktbm90LWFncmVlJyk7XHJcbmlmIChub3RBZ3JlZSlcclxuICAgIG5vdEFncmVlLm9uY2xpY2sgPSBub3RBY2NlcHRHRFBSO1xyXG52YXIgYWdyZWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJpdmFjeS1hZ3JlZScpO1xyXG5pZiAoYWdyZWUpXHJcbiAgICBhZ3JlZS5vbmNsaWNrID0gYWNjZXB0R0RQUjtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIG5vdEFjY2VwdEdEUFIgKCkge1xyXG4gICAgc2hvd1ByaXZhY3lUb2FzdChmYWxzZSk7XHJcbiAgICBlcnJvcl9tc2coXCJZb3UgbmVlZCB0byBhY2NlcHQgdG8gcGxhY2luZyBjb29raWVzIHRvIHVzZSB0aGlzIHdlYnNpdGUuIEZ1bmN0aW9uYWxpdHkgd2lsbCBiZSByZXN0cmljdGVkLlwiLCBcImRhbmdlclwiKTtcclxuICAgIGF3YWl0IHNlbmRDb25zZW50KGZhbHNlKTtcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGFjY2VwdEdEUFIgKCkge1xyXG4gICAgYXdhaXQgc2VuZENvbnNlbnQodHJ1ZSk7XHJcbn07XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzZW5kQ29uc2VudChjb25zZW50KSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XCJjb25zZW50XCI6IGNvbnNlbnR9KVxyXG4gICAgfTtcclxuICAgIGF3YWl0IGZldGNoKCcvY29uc2VudCcsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB3aGV0aGVyIGEgY29uc2VudCB0byBzZXR0aW5nIGNvb2tpZXMgYWNjb3JkaW5nIHRvIHRlaCBHRFBSIGlzIHJlcXVpcmVkLlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgdXNlciBpcyBsaWtlbHkgbGl2aW5nIGluIEVVXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zZW50UmVxdWlyZWQoKSB7XHJcbiAgICBsZXQgdHogPSBcIlwiO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0eiA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAodHopIHtcclxuICAgICAgY2FzZSAnRXVyb3BlL1ZpZW5uYSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9CcnVzc2Vscyc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9Tb2ZpYSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9aYWdyZWInOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdBc2lhL0ZhbWFndXN0YSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0FzaWEvTmljb3NpYSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9QcmFndWUnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvQ29wZW5oYWdlbic6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9UYWxsaW5uJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0hlbHNpbmtpJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1BhcmlzJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0Jlcmxpbic6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9CdXNpbmdlbic6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9BdGhlbnMnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvQnVkYXBlc3QnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvRHVibGluJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1JvbWUnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvUmlnYSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9WaWxuaXVzJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0x1eGVtYm91cmcnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvTWFsdGEnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvQW1zdGVyZGFtJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1dhcnNhdyc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0F0bGFudGljL0F6b3Jlcyc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0F0bGFudGljL01hZGVpcmEnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvTGlzYm9uJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0J1Y2hhcmVzdCc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9CcmF0aXNsYXZhJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0xqdWJsamFuYSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0FmcmljYS9DZXV0YSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0F0bGFudGljL0NhbmFyeSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9NYWRyaWQnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvU3RvY2tob2xtJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9