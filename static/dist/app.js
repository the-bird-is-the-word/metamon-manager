/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./ethers-5.1.esm.min.js":
/*!*******************************!*\
  !*** ./ethers-5.1.esm.min.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContract": () => (/* binding */ BaseContract),
/* harmony export */   "BigNumber": () => (/* binding */ BigNumber),
/* harmony export */   "Contract": () => (/* binding */ Contract),
/* harmony export */   "ContractFactory": () => (/* binding */ ContractFactory),
/* harmony export */   "FixedNumber": () => (/* binding */ FixedNumber),
/* harmony export */   "Signer": () => (/* binding */ Signer),
/* harmony export */   "VoidSigner": () => (/* binding */ VoidSigner),
/* harmony export */   "Wallet": () => (/* binding */ Wallet),
/* harmony export */   "Wordlist": () => (/* binding */ Wordlist),
/* harmony export */   "constants": () => (/* binding */ index$1),
/* harmony export */   "errors": () => (/* binding */ ErrorCode),
/* harmony export */   "ethers": () => (/* binding */ ethers),
/* harmony export */   "getDefaultProvider": () => (/* binding */ getDefaultProvider),
/* harmony export */   "logger": () => (/* binding */ logger$H),
/* harmony export */   "providers": () => (/* binding */ index$3),
/* harmony export */   "utils": () => (/* binding */ utils$1),
/* harmony export */   "version": () => (/* binding */ version$o),
/* harmony export */   "wordlists": () => (/* binding */ wordlists)
/* harmony export */ });
var commonjsGlobal=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof __webpack_require__.g!=="undefined"?__webpack_require__.g:typeof self!=="undefined"?self:{};function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function createCommonjsModule(fn,basedir,module){return module={path:basedir,exports:{},require:function(path,base){return commonjsRequire(path,base===undefined||base===null?module.path:base)}},fn(module,module.exports),module.exports}function getDefaultExportFromNamespaceIfPresent(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")?n["default"]:n}function getDefaultExportFromNamespaceIfNotNamed(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")&&Object.keys(n).length===1?n["default"]:n}function getAugmentedNamespace(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:true});Object.keys(n).forEach(function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:true,get:function(){return n[k]}})});return a}function commonjsRequire(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var bn=createCommonjsModule(function(module){(function(module,exports){"use strict";function assert(val,msg){if(!val)throw new Error(msg||"Assertion failed")}function inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}function BN(number,base,endian){if(BN.isBN(number)){return number}this.negative=0;this.words=null;this.length=0;this.red=null;if(number!==null){if(base==="le"||base==="be"){endian=base;base=10}this._init(number||0,base||10,endian||"be")}}if(typeof module==="object"){module.exports=BN}else{exports.BN=BN}BN.BN=BN;BN.wordSize=26;var Buffer;try{if(typeof window!=="undefined"&&typeof window.Buffer!=="undefined"){Buffer=window.Buffer}else{Buffer=null.Buffer}}catch(e){}BN.isBN=function isBN(num){if(num instanceof BN){return true}return num!==null&&typeof num==="object"&&num.constructor.wordSize===BN.wordSize&&Array.isArray(num.words)};BN.max=function max(left,right){if(left.cmp(right)>0)return left;return right};BN.min=function min(left,right){if(left.cmp(right)<0)return left;return right};BN.prototype._init=function init(number,base,endian){if(typeof number==="number"){return this._initNumber(number,base,endian)}if(typeof number==="object"){return this._initArray(number,base,endian)}if(base==="hex"){base=16}assert(base===(base|0)&&base>=2&&base<=36);number=number.toString().replace(/\s+/g,"");var start=0;if(number[0]==="-"){start++;this.negative=1}if(start<number.length){if(base===16){this._parseHex(number,start,endian)}else{this._parseBase(number,base,start);if(endian==="le"){this._initArray(this.toArray(),base,endian)}}}};BN.prototype._initNumber=function _initNumber(number,base,endian){if(number<0){this.negative=1;number=-number}if(number<67108864){this.words=[number&67108863];this.length=1}else if(number<4503599627370496){this.words=[number&67108863,number/67108864&67108863];this.length=2}else{assert(number<9007199254740992);this.words=[number&67108863,number/67108864&67108863,1];this.length=3}if(endian!=="le")return;this._initArray(this.toArray(),base,endian)};BN.prototype._initArray=function _initArray(number,base,endian){assert(typeof number.length==="number");if(number.length<=0){this.words=[0];this.length=1;return this}this.length=Math.ceil(number.length/3);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0}var j,w;var off=0;if(endian==="be"){for(i=number.length-1,j=0;i>=0;i-=3){w=number[i]|number[i-1]<<8|number[i-2]<<16;this.words[j]|=w<<off&67108863;this.words[j+1]=w>>>26-off&67108863;off+=24;if(off>=26){off-=26;j++}}}else if(endian==="le"){for(i=0,j=0;i<number.length;i+=3){w=number[i]|number[i+1]<<8|number[i+2]<<16;this.words[j]|=w<<off&67108863;this.words[j+1]=w>>>26-off&67108863;off+=24;if(off>=26){off-=26;j++}}}return this.strip()};function parseHex4Bits(string,index){var c=string.charCodeAt(index);if(c>=65&&c<=70){return c-55}else if(c>=97&&c<=102){return c-87}else{return c-48&15}}function parseHexByte(string,lowerBound,index){var r=parseHex4Bits(string,index);if(index-1>=lowerBound){r|=parseHex4Bits(string,index-1)<<4}return r}BN.prototype._parseHex=function _parseHex(number,start,endian){this.length=Math.ceil((number.length-start)/6);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0}var off=0;var j=0;var w;if(endian==="be"){for(i=number.length-1;i>=start;i-=2){w=parseHexByte(number,start,i)<<off;this.words[j]|=w&67108863;if(off>=18){off-=18;j+=1;this.words[j]|=w>>>26}else{off+=8}}}else{var parseLength=number.length-start;for(i=parseLength%2===0?start+1:start;i<number.length;i+=2){w=parseHexByte(number,start,i)<<off;this.words[j]|=w&67108863;if(off>=18){off-=18;j+=1;this.words[j]|=w>>>26}else{off+=8}}}this.strip()};function parseBase(str,start,end,mul){var r=0;var len=Math.min(str.length,end);for(var i=start;i<len;i++){var c=str.charCodeAt(i)-48;r*=mul;if(c>=49){r+=c-49+10}else if(c>=17){r+=c-17+10}else{r+=c}}return r}BN.prototype._parseBase=function _parseBase(number,base,start){this.words=[0];this.length=1;for(var limbLen=0,limbPow=1;limbPow<=67108863;limbPow*=base){limbLen++}limbLen--;limbPow=limbPow/base|0;var total=number.length-start;var mod=total%limbLen;var end=Math.min(total,total-mod)+start;var word=0;for(var i=start;i<end;i+=limbLen){word=parseBase(number,i,i+limbLen,base);this.imuln(limbPow);if(this.words[0]+word<67108864){this.words[0]+=word}else{this._iaddn(word)}}if(mod!==0){var pow=1;word=parseBase(number,i,number.length,base);for(i=0;i<mod;i++){pow*=base}this.imuln(pow);if(this.words[0]+word<67108864){this.words[0]+=word}else{this._iaddn(word)}}this.strip()};BN.prototype.copy=function copy(dest){dest.words=new Array(this.length);for(var i=0;i<this.length;i++){dest.words[i]=this.words[i]}dest.length=this.length;dest.negative=this.negative;dest.red=this.red};BN.prototype.clone=function clone(){var r=new BN(null);this.copy(r);return r};BN.prototype._expand=function _expand(size){while(this.length<size){this.words[this.length++]=0}return this};BN.prototype.strip=function strip(){while(this.length>1&&this.words[this.length-1]===0){this.length--}return this._normSign()};BN.prototype._normSign=function _normSign(){if(this.length===1&&this.words[0]===0){this.negative=0}return this};BN.prototype.inspect=function inspect(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var zeros=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"];var groupSizes=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5];var groupBases=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];BN.prototype.toString=function toString(base,padding){base=base||10;padding=padding|0||1;var out;if(base===16||base==="hex"){out="";var off=0;var carry=0;for(var i=0;i<this.length;i++){var w=this.words[i];var word=((w<<off|carry)&16777215).toString(16);carry=w>>>24-off&16777215;if(carry!==0||i!==this.length-1){out=zeros[6-word.length]+word+out}else{out=word+out}off+=2;if(off>=26){off-=26;i--}}if(carry!==0){out=carry.toString(16)+out}while(out.length%padding!==0){out="0"+out}if(this.negative!==0){out="-"+out}return out}if(base===(base|0)&&base>=2&&base<=36){var groupSize=groupSizes[base];var groupBase=groupBases[base];out="";var c=this.clone();c.negative=0;while(!c.isZero()){var r=c.modn(groupBase).toString(base);c=c.idivn(groupBase);if(!c.isZero()){out=zeros[groupSize-r.length]+r+out}else{out=r+out}}if(this.isZero()){out="0"+out}while(out.length%padding!==0){out="0"+out}if(this.negative!==0){out="-"+out}return out}assert(false,"Base should be between 2 and 36")};BN.prototype.toNumber=function toNumber(){var ret=this.words[0];if(this.length===2){ret+=this.words[1]*67108864}else if(this.length===3&&this.words[2]===1){ret+=4503599627370496+this.words[1]*67108864}else if(this.length>2){assert(false,"Number can only safely store up to 53 bits")}return this.negative!==0?-ret:ret};BN.prototype.toJSON=function toJSON(){return this.toString(16)};BN.prototype.toBuffer=function toBuffer(endian,length){assert(typeof Buffer!=="undefined");return this.toArrayLike(Buffer,endian,length)};BN.prototype.toArray=function toArray(endian,length){return this.toArrayLike(Array,endian,length)};BN.prototype.toArrayLike=function toArrayLike(ArrayType,endian,length){var byteLength=this.byteLength();var reqLength=length||Math.max(1,byteLength);assert(byteLength<=reqLength,"byte array longer than desired length");assert(reqLength>0,"Requested array length <= 0");this.strip();var littleEndian=endian==="le";var res=new ArrayType(reqLength);var b,i;var q=this.clone();if(!littleEndian){for(i=0;i<reqLength-byteLength;i++){res[i]=0}for(i=0;!q.isZero();i++){b=q.andln(255);q.iushrn(8);res[reqLength-i-1]=b}}else{for(i=0;!q.isZero();i++){b=q.andln(255);q.iushrn(8);res[i]=b}for(;i<reqLength;i++){res[i]=0}}return res};if(Math.clz32){BN.prototype._countBits=function _countBits(w){return 32-Math.clz32(w)}}else{BN.prototype._countBits=function _countBits(w){var t=w;var r=0;if(t>=4096){r+=13;t>>>=13}if(t>=64){r+=7;t>>>=7}if(t>=8){r+=4;t>>>=4}if(t>=2){r+=2;t>>>=2}return r+t}}BN.prototype._zeroBits=function _zeroBits(w){if(w===0)return 26;var t=w;var r=0;if((t&8191)===0){r+=13;t>>>=13}if((t&127)===0){r+=7;t>>>=7}if((t&15)===0){r+=4;t>>>=4}if((t&3)===0){r+=2;t>>>=2}if((t&1)===0){r++}return r};BN.prototype.bitLength=function bitLength(){var w=this.words[this.length-1];var hi=this._countBits(w);return(this.length-1)*26+hi};function toBitArray(num){var w=new Array(num.bitLength());for(var bit=0;bit<w.length;bit++){var off=bit/26|0;var wbit=bit%26;w[bit]=(num.words[off]&1<<wbit)>>>wbit}return w}BN.prototype.zeroBits=function zeroBits(){if(this.isZero())return 0;var r=0;for(var i=0;i<this.length;i++){var b=this._zeroBits(this.words[i]);r+=b;if(b!==26)break}return r};BN.prototype.byteLength=function byteLength(){return Math.ceil(this.bitLength()/8)};BN.prototype.toTwos=function toTwos(width){if(this.negative!==0){return this.abs().inotn(width).iaddn(1)}return this.clone()};BN.prototype.fromTwos=function fromTwos(width){if(this.testn(width-1)){return this.notn(width).iaddn(1).ineg()}return this.clone()};BN.prototype.isNeg=function isNeg(){return this.negative!==0};BN.prototype.neg=function neg(){return this.clone().ineg()};BN.prototype.ineg=function ineg(){if(!this.isZero()){this.negative^=1}return this};BN.prototype.iuor=function iuor(num){while(this.length<num.length){this.words[this.length++]=0}for(var i=0;i<num.length;i++){this.words[i]=this.words[i]|num.words[i]}return this.strip()};BN.prototype.ior=function ior(num){assert((this.negative|num.negative)===0);return this.iuor(num)};BN.prototype.or=function or(num){if(this.length>num.length)return this.clone().ior(num);return num.clone().ior(this)};BN.prototype.uor=function uor(num){if(this.length>num.length)return this.clone().iuor(num);return num.clone().iuor(this)};BN.prototype.iuand=function iuand(num){var b;if(this.length>num.length){b=num}else{b=this}for(var i=0;i<b.length;i++){this.words[i]=this.words[i]&num.words[i]}this.length=b.length;return this.strip()};BN.prototype.iand=function iand(num){assert((this.negative|num.negative)===0);return this.iuand(num)};BN.prototype.and=function and(num){if(this.length>num.length)return this.clone().iand(num);return num.clone().iand(this)};BN.prototype.uand=function uand(num){if(this.length>num.length)return this.clone().iuand(num);return num.clone().iuand(this)};BN.prototype.iuxor=function iuxor(num){var a;var b;if(this.length>num.length){a=this;b=num}else{a=num;b=this}for(var i=0;i<b.length;i++){this.words[i]=a.words[i]^b.words[i]}if(this!==a){for(;i<a.length;i++){this.words[i]=a.words[i]}}this.length=a.length;return this.strip()};BN.prototype.ixor=function ixor(num){assert((this.negative|num.negative)===0);return this.iuxor(num)};BN.prototype.xor=function xor(num){if(this.length>num.length)return this.clone().ixor(num);return num.clone().ixor(this)};BN.prototype.uxor=function uxor(num){if(this.length>num.length)return this.clone().iuxor(num);return num.clone().iuxor(this)};BN.prototype.inotn=function inotn(width){assert(typeof width==="number"&&width>=0);var bytesNeeded=Math.ceil(width/26)|0;var bitsLeft=width%26;this._expand(bytesNeeded);if(bitsLeft>0){bytesNeeded--}for(var i=0;i<bytesNeeded;i++){this.words[i]=~this.words[i]&67108863}if(bitsLeft>0){this.words[i]=~this.words[i]&67108863>>26-bitsLeft}return this.strip()};BN.prototype.notn=function notn(width){return this.clone().inotn(width)};BN.prototype.setn=function setn(bit,val){assert(typeof bit==="number"&&bit>=0);var off=bit/26|0;var wbit=bit%26;this._expand(off+1);if(val){this.words[off]=this.words[off]|1<<wbit}else{this.words[off]=this.words[off]&~(1<<wbit)}return this.strip()};BN.prototype.iadd=function iadd(num){var r;if(this.negative!==0&&num.negative===0){this.negative=0;r=this.isub(num);this.negative^=1;return this._normSign()}else if(this.negative===0&&num.negative!==0){num.negative=0;r=this.isub(num);num.negative=1;return r._normSign()}var a,b;if(this.length>num.length){a=this;b=num}else{a=num;b=this}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)+(b.words[i]|0)+carry;this.words[i]=r&67108863;carry=r>>>26}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;this.words[i]=r&67108863;carry=r>>>26}this.length=a.length;if(carry!==0){this.words[this.length]=carry;this.length++}else if(a!==this){for(;i<a.length;i++){this.words[i]=a.words[i]}}return this};BN.prototype.add=function add(num){var res;if(num.negative!==0&&this.negative===0){num.negative=0;res=this.sub(num);num.negative^=1;return res}else if(num.negative===0&&this.negative!==0){this.negative=0;res=num.sub(this);this.negative=1;return res}if(this.length>num.length)return this.clone().iadd(num);return num.clone().iadd(this)};BN.prototype.isub=function isub(num){if(num.negative!==0){num.negative=0;var r=this.iadd(num);num.negative=1;return r._normSign()}else if(this.negative!==0){this.negative=0;this.iadd(num);this.negative=1;return this._normSign()}var cmp=this.cmp(num);if(cmp===0){this.negative=0;this.length=1;this.words[0]=0;return this}var a,b;if(cmp>0){a=this;b=num}else{a=num;b=this}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)-(b.words[i]|0)+carry;carry=r>>26;this.words[i]=r&67108863}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;carry=r>>26;this.words[i]=r&67108863}if(carry===0&&i<a.length&&a!==this){for(;i<a.length;i++){this.words[i]=a.words[i]}}this.length=Math.max(this.length,i);if(a!==this){this.negative=1}return this.strip()};BN.prototype.sub=function sub(num){return this.clone().isub(num)};function smallMulTo(self,num,out){out.negative=num.negative^self.negative;var len=self.length+num.length|0;out.length=len;len=len-1|0;var a=self.words[0]|0;var b=num.words[0]|0;var r=a*b;var lo=r&67108863;var carry=r/67108864|0;out.words[0]=lo;for(var k=1;k<len;k++){var ncarry=carry>>>26;var rword=carry&67108863;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j|0;a=self.words[i]|0;b=num.words[j]|0;r=a*b+rword;ncarry+=r/67108864|0;rword=r&67108863}out.words[k]=rword|0;carry=ncarry|0}if(carry!==0){out.words[k]=carry|0}else{out.length--}return out.strip()}var comb10MulTo=function comb10MulTo(self,num,out){var a=self.words;var b=num.words;var o=out.words;var c=0;var lo;var mid;var hi;var a0=a[0]|0;var al0=a0&8191;var ah0=a0>>>13;var a1=a[1]|0;var al1=a1&8191;var ah1=a1>>>13;var a2=a[2]|0;var al2=a2&8191;var ah2=a2>>>13;var a3=a[3]|0;var al3=a3&8191;var ah3=a3>>>13;var a4=a[4]|0;var al4=a4&8191;var ah4=a4>>>13;var a5=a[5]|0;var al5=a5&8191;var ah5=a5>>>13;var a6=a[6]|0;var al6=a6&8191;var ah6=a6>>>13;var a7=a[7]|0;var al7=a7&8191;var ah7=a7>>>13;var a8=a[8]|0;var al8=a8&8191;var ah8=a8>>>13;var a9=a[9]|0;var al9=a9&8191;var ah9=a9>>>13;var b0=b[0]|0;var bl0=b0&8191;var bh0=b0>>>13;var b1=b[1]|0;var bl1=b1&8191;var bh1=b1>>>13;var b2=b[2]|0;var bl2=b2&8191;var bh2=b2>>>13;var b3=b[3]|0;var bl3=b3&8191;var bh3=b3>>>13;var b4=b[4]|0;var bl4=b4&8191;var bh4=b4>>>13;var b5=b[5]|0;var bl5=b5&8191;var bh5=b5>>>13;var b6=b[6]|0;var bl6=b6&8191;var bh6=b6>>>13;var b7=b[7]|0;var bl7=b7&8191;var bh7=b7>>>13;var b8=b[8]|0;var bl8=b8&8191;var bh8=b8>>>13;var b9=b[9]|0;var bl9=b9&8191;var bh9=b9>>>13;out.negative=self.negative^num.negative;out.length=19;lo=Math.imul(al0,bl0);mid=Math.imul(al0,bh0);mid=mid+Math.imul(ah0,bl0)|0;hi=Math.imul(ah0,bh0);var w0=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w0>>>26)|0;w0&=67108863;lo=Math.imul(al1,bl0);mid=Math.imul(al1,bh0);mid=mid+Math.imul(ah1,bl0)|0;hi=Math.imul(ah1,bh0);lo=lo+Math.imul(al0,bl1)|0;mid=mid+Math.imul(al0,bh1)|0;mid=mid+Math.imul(ah0,bl1)|0;hi=hi+Math.imul(ah0,bh1)|0;var w1=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w1>>>26)|0;w1&=67108863;lo=Math.imul(al2,bl0);mid=Math.imul(al2,bh0);mid=mid+Math.imul(ah2,bl0)|0;hi=Math.imul(ah2,bh0);lo=lo+Math.imul(al1,bl1)|0;mid=mid+Math.imul(al1,bh1)|0;mid=mid+Math.imul(ah1,bl1)|0;hi=hi+Math.imul(ah1,bh1)|0;lo=lo+Math.imul(al0,bl2)|0;mid=mid+Math.imul(al0,bh2)|0;mid=mid+Math.imul(ah0,bl2)|0;hi=hi+Math.imul(ah0,bh2)|0;var w2=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w2>>>26)|0;w2&=67108863;lo=Math.imul(al3,bl0);mid=Math.imul(al3,bh0);mid=mid+Math.imul(ah3,bl0)|0;hi=Math.imul(ah3,bh0);lo=lo+Math.imul(al2,bl1)|0;mid=mid+Math.imul(al2,bh1)|0;mid=mid+Math.imul(ah2,bl1)|0;hi=hi+Math.imul(ah2,bh1)|0;lo=lo+Math.imul(al1,bl2)|0;mid=mid+Math.imul(al1,bh2)|0;mid=mid+Math.imul(ah1,bl2)|0;hi=hi+Math.imul(ah1,bh2)|0;lo=lo+Math.imul(al0,bl3)|0;mid=mid+Math.imul(al0,bh3)|0;mid=mid+Math.imul(ah0,bl3)|0;hi=hi+Math.imul(ah0,bh3)|0;var w3=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w3>>>26)|0;w3&=67108863;lo=Math.imul(al4,bl0);mid=Math.imul(al4,bh0);mid=mid+Math.imul(ah4,bl0)|0;hi=Math.imul(ah4,bh0);lo=lo+Math.imul(al3,bl1)|0;mid=mid+Math.imul(al3,bh1)|0;mid=mid+Math.imul(ah3,bl1)|0;hi=hi+Math.imul(ah3,bh1)|0;lo=lo+Math.imul(al2,bl2)|0;mid=mid+Math.imul(al2,bh2)|0;mid=mid+Math.imul(ah2,bl2)|0;hi=hi+Math.imul(ah2,bh2)|0;lo=lo+Math.imul(al1,bl3)|0;mid=mid+Math.imul(al1,bh3)|0;mid=mid+Math.imul(ah1,bl3)|0;hi=hi+Math.imul(ah1,bh3)|0;lo=lo+Math.imul(al0,bl4)|0;mid=mid+Math.imul(al0,bh4)|0;mid=mid+Math.imul(ah0,bl4)|0;hi=hi+Math.imul(ah0,bh4)|0;var w4=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w4>>>26)|0;w4&=67108863;lo=Math.imul(al5,bl0);mid=Math.imul(al5,bh0);mid=mid+Math.imul(ah5,bl0)|0;hi=Math.imul(ah5,bh0);lo=lo+Math.imul(al4,bl1)|0;mid=mid+Math.imul(al4,bh1)|0;mid=mid+Math.imul(ah4,bl1)|0;hi=hi+Math.imul(ah4,bh1)|0;lo=lo+Math.imul(al3,bl2)|0;mid=mid+Math.imul(al3,bh2)|0;mid=mid+Math.imul(ah3,bl2)|0;hi=hi+Math.imul(ah3,bh2)|0;lo=lo+Math.imul(al2,bl3)|0;mid=mid+Math.imul(al2,bh3)|0;mid=mid+Math.imul(ah2,bl3)|0;hi=hi+Math.imul(ah2,bh3)|0;lo=lo+Math.imul(al1,bl4)|0;mid=mid+Math.imul(al1,bh4)|0;mid=mid+Math.imul(ah1,bl4)|0;hi=hi+Math.imul(ah1,bh4)|0;lo=lo+Math.imul(al0,bl5)|0;mid=mid+Math.imul(al0,bh5)|0;mid=mid+Math.imul(ah0,bl5)|0;hi=hi+Math.imul(ah0,bh5)|0;var w5=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w5>>>26)|0;w5&=67108863;lo=Math.imul(al6,bl0);mid=Math.imul(al6,bh0);mid=mid+Math.imul(ah6,bl0)|0;hi=Math.imul(ah6,bh0);lo=lo+Math.imul(al5,bl1)|0;mid=mid+Math.imul(al5,bh1)|0;mid=mid+Math.imul(ah5,bl1)|0;hi=hi+Math.imul(ah5,bh1)|0;lo=lo+Math.imul(al4,bl2)|0;mid=mid+Math.imul(al4,bh2)|0;mid=mid+Math.imul(ah4,bl2)|0;hi=hi+Math.imul(ah4,bh2)|0;lo=lo+Math.imul(al3,bl3)|0;mid=mid+Math.imul(al3,bh3)|0;mid=mid+Math.imul(ah3,bl3)|0;hi=hi+Math.imul(ah3,bh3)|0;lo=lo+Math.imul(al2,bl4)|0;mid=mid+Math.imul(al2,bh4)|0;mid=mid+Math.imul(ah2,bl4)|0;hi=hi+Math.imul(ah2,bh4)|0;lo=lo+Math.imul(al1,bl5)|0;mid=mid+Math.imul(al1,bh5)|0;mid=mid+Math.imul(ah1,bl5)|0;hi=hi+Math.imul(ah1,bh5)|0;lo=lo+Math.imul(al0,bl6)|0;mid=mid+Math.imul(al0,bh6)|0;mid=mid+Math.imul(ah0,bl6)|0;hi=hi+Math.imul(ah0,bh6)|0;var w6=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w6>>>26)|0;w6&=67108863;lo=Math.imul(al7,bl0);mid=Math.imul(al7,bh0);mid=mid+Math.imul(ah7,bl0)|0;hi=Math.imul(ah7,bh0);lo=lo+Math.imul(al6,bl1)|0;mid=mid+Math.imul(al6,bh1)|0;mid=mid+Math.imul(ah6,bl1)|0;hi=hi+Math.imul(ah6,bh1)|0;lo=lo+Math.imul(al5,bl2)|0;mid=mid+Math.imul(al5,bh2)|0;mid=mid+Math.imul(ah5,bl2)|0;hi=hi+Math.imul(ah5,bh2)|0;lo=lo+Math.imul(al4,bl3)|0;mid=mid+Math.imul(al4,bh3)|0;mid=mid+Math.imul(ah4,bl3)|0;hi=hi+Math.imul(ah4,bh3)|0;lo=lo+Math.imul(al3,bl4)|0;mid=mid+Math.imul(al3,bh4)|0;mid=mid+Math.imul(ah3,bl4)|0;hi=hi+Math.imul(ah3,bh4)|0;lo=lo+Math.imul(al2,bl5)|0;mid=mid+Math.imul(al2,bh5)|0;mid=mid+Math.imul(ah2,bl5)|0;hi=hi+Math.imul(ah2,bh5)|0;lo=lo+Math.imul(al1,bl6)|0;mid=mid+Math.imul(al1,bh6)|0;mid=mid+Math.imul(ah1,bl6)|0;hi=hi+Math.imul(ah1,bh6)|0;lo=lo+Math.imul(al0,bl7)|0;mid=mid+Math.imul(al0,bh7)|0;mid=mid+Math.imul(ah0,bl7)|0;hi=hi+Math.imul(ah0,bh7)|0;var w7=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w7>>>26)|0;w7&=67108863;lo=Math.imul(al8,bl0);mid=Math.imul(al8,bh0);mid=mid+Math.imul(ah8,bl0)|0;hi=Math.imul(ah8,bh0);lo=lo+Math.imul(al7,bl1)|0;mid=mid+Math.imul(al7,bh1)|0;mid=mid+Math.imul(ah7,bl1)|0;hi=hi+Math.imul(ah7,bh1)|0;lo=lo+Math.imul(al6,bl2)|0;mid=mid+Math.imul(al6,bh2)|0;mid=mid+Math.imul(ah6,bl2)|0;hi=hi+Math.imul(ah6,bh2)|0;lo=lo+Math.imul(al5,bl3)|0;mid=mid+Math.imul(al5,bh3)|0;mid=mid+Math.imul(ah5,bl3)|0;hi=hi+Math.imul(ah5,bh3)|0;lo=lo+Math.imul(al4,bl4)|0;mid=mid+Math.imul(al4,bh4)|0;mid=mid+Math.imul(ah4,bl4)|0;hi=hi+Math.imul(ah4,bh4)|0;lo=lo+Math.imul(al3,bl5)|0;mid=mid+Math.imul(al3,bh5)|0;mid=mid+Math.imul(ah3,bl5)|0;hi=hi+Math.imul(ah3,bh5)|0;lo=lo+Math.imul(al2,bl6)|0;mid=mid+Math.imul(al2,bh6)|0;mid=mid+Math.imul(ah2,bl6)|0;hi=hi+Math.imul(ah2,bh6)|0;lo=lo+Math.imul(al1,bl7)|0;mid=mid+Math.imul(al1,bh7)|0;mid=mid+Math.imul(ah1,bl7)|0;hi=hi+Math.imul(ah1,bh7)|0;lo=lo+Math.imul(al0,bl8)|0;mid=mid+Math.imul(al0,bh8)|0;mid=mid+Math.imul(ah0,bl8)|0;hi=hi+Math.imul(ah0,bh8)|0;var w8=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w8>>>26)|0;w8&=67108863;lo=Math.imul(al9,bl0);mid=Math.imul(al9,bh0);mid=mid+Math.imul(ah9,bl0)|0;hi=Math.imul(ah9,bh0);lo=lo+Math.imul(al8,bl1)|0;mid=mid+Math.imul(al8,bh1)|0;mid=mid+Math.imul(ah8,bl1)|0;hi=hi+Math.imul(ah8,bh1)|0;lo=lo+Math.imul(al7,bl2)|0;mid=mid+Math.imul(al7,bh2)|0;mid=mid+Math.imul(ah7,bl2)|0;hi=hi+Math.imul(ah7,bh2)|0;lo=lo+Math.imul(al6,bl3)|0;mid=mid+Math.imul(al6,bh3)|0;mid=mid+Math.imul(ah6,bl3)|0;hi=hi+Math.imul(ah6,bh3)|0;lo=lo+Math.imul(al5,bl4)|0;mid=mid+Math.imul(al5,bh4)|0;mid=mid+Math.imul(ah5,bl4)|0;hi=hi+Math.imul(ah5,bh4)|0;lo=lo+Math.imul(al4,bl5)|0;mid=mid+Math.imul(al4,bh5)|0;mid=mid+Math.imul(ah4,bl5)|0;hi=hi+Math.imul(ah4,bh5)|0;lo=lo+Math.imul(al3,bl6)|0;mid=mid+Math.imul(al3,bh6)|0;mid=mid+Math.imul(ah3,bl6)|0;hi=hi+Math.imul(ah3,bh6)|0;lo=lo+Math.imul(al2,bl7)|0;mid=mid+Math.imul(al2,bh7)|0;mid=mid+Math.imul(ah2,bl7)|0;hi=hi+Math.imul(ah2,bh7)|0;lo=lo+Math.imul(al1,bl8)|0;mid=mid+Math.imul(al1,bh8)|0;mid=mid+Math.imul(ah1,bl8)|0;hi=hi+Math.imul(ah1,bh8)|0;lo=lo+Math.imul(al0,bl9)|0;mid=mid+Math.imul(al0,bh9)|0;mid=mid+Math.imul(ah0,bl9)|0;hi=hi+Math.imul(ah0,bh9)|0;var w9=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w9>>>26)|0;w9&=67108863;lo=Math.imul(al9,bl1);mid=Math.imul(al9,bh1);mid=mid+Math.imul(ah9,bl1)|0;hi=Math.imul(ah9,bh1);lo=lo+Math.imul(al8,bl2)|0;mid=mid+Math.imul(al8,bh2)|0;mid=mid+Math.imul(ah8,bl2)|0;hi=hi+Math.imul(ah8,bh2)|0;lo=lo+Math.imul(al7,bl3)|0;mid=mid+Math.imul(al7,bh3)|0;mid=mid+Math.imul(ah7,bl3)|0;hi=hi+Math.imul(ah7,bh3)|0;lo=lo+Math.imul(al6,bl4)|0;mid=mid+Math.imul(al6,bh4)|0;mid=mid+Math.imul(ah6,bl4)|0;hi=hi+Math.imul(ah6,bh4)|0;lo=lo+Math.imul(al5,bl5)|0;mid=mid+Math.imul(al5,bh5)|0;mid=mid+Math.imul(ah5,bl5)|0;hi=hi+Math.imul(ah5,bh5)|0;lo=lo+Math.imul(al4,bl6)|0;mid=mid+Math.imul(al4,bh6)|0;mid=mid+Math.imul(ah4,bl6)|0;hi=hi+Math.imul(ah4,bh6)|0;lo=lo+Math.imul(al3,bl7)|0;mid=mid+Math.imul(al3,bh7)|0;mid=mid+Math.imul(ah3,bl7)|0;hi=hi+Math.imul(ah3,bh7)|0;lo=lo+Math.imul(al2,bl8)|0;mid=mid+Math.imul(al2,bh8)|0;mid=mid+Math.imul(ah2,bl8)|0;hi=hi+Math.imul(ah2,bh8)|0;lo=lo+Math.imul(al1,bl9)|0;mid=mid+Math.imul(al1,bh9)|0;mid=mid+Math.imul(ah1,bl9)|0;hi=hi+Math.imul(ah1,bh9)|0;var w10=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w10>>>26)|0;w10&=67108863;lo=Math.imul(al9,bl2);mid=Math.imul(al9,bh2);mid=mid+Math.imul(ah9,bl2)|0;hi=Math.imul(ah9,bh2);lo=lo+Math.imul(al8,bl3)|0;mid=mid+Math.imul(al8,bh3)|0;mid=mid+Math.imul(ah8,bl3)|0;hi=hi+Math.imul(ah8,bh3)|0;lo=lo+Math.imul(al7,bl4)|0;mid=mid+Math.imul(al7,bh4)|0;mid=mid+Math.imul(ah7,bl4)|0;hi=hi+Math.imul(ah7,bh4)|0;lo=lo+Math.imul(al6,bl5)|0;mid=mid+Math.imul(al6,bh5)|0;mid=mid+Math.imul(ah6,bl5)|0;hi=hi+Math.imul(ah6,bh5)|0;lo=lo+Math.imul(al5,bl6)|0;mid=mid+Math.imul(al5,bh6)|0;mid=mid+Math.imul(ah5,bl6)|0;hi=hi+Math.imul(ah5,bh6)|0;lo=lo+Math.imul(al4,bl7)|0;mid=mid+Math.imul(al4,bh7)|0;mid=mid+Math.imul(ah4,bl7)|0;hi=hi+Math.imul(ah4,bh7)|0;lo=lo+Math.imul(al3,bl8)|0;mid=mid+Math.imul(al3,bh8)|0;mid=mid+Math.imul(ah3,bl8)|0;hi=hi+Math.imul(ah3,bh8)|0;lo=lo+Math.imul(al2,bl9)|0;mid=mid+Math.imul(al2,bh9)|0;mid=mid+Math.imul(ah2,bl9)|0;hi=hi+Math.imul(ah2,bh9)|0;var w11=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w11>>>26)|0;w11&=67108863;lo=Math.imul(al9,bl3);mid=Math.imul(al9,bh3);mid=mid+Math.imul(ah9,bl3)|0;hi=Math.imul(ah9,bh3);lo=lo+Math.imul(al8,bl4)|0;mid=mid+Math.imul(al8,bh4)|0;mid=mid+Math.imul(ah8,bl4)|0;hi=hi+Math.imul(ah8,bh4)|0;lo=lo+Math.imul(al7,bl5)|0;mid=mid+Math.imul(al7,bh5)|0;mid=mid+Math.imul(ah7,bl5)|0;hi=hi+Math.imul(ah7,bh5)|0;lo=lo+Math.imul(al6,bl6)|0;mid=mid+Math.imul(al6,bh6)|0;mid=mid+Math.imul(ah6,bl6)|0;hi=hi+Math.imul(ah6,bh6)|0;lo=lo+Math.imul(al5,bl7)|0;mid=mid+Math.imul(al5,bh7)|0;mid=mid+Math.imul(ah5,bl7)|0;hi=hi+Math.imul(ah5,bh7)|0;lo=lo+Math.imul(al4,bl8)|0;mid=mid+Math.imul(al4,bh8)|0;mid=mid+Math.imul(ah4,bl8)|0;hi=hi+Math.imul(ah4,bh8)|0;lo=lo+Math.imul(al3,bl9)|0;mid=mid+Math.imul(al3,bh9)|0;mid=mid+Math.imul(ah3,bl9)|0;hi=hi+Math.imul(ah3,bh9)|0;var w12=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w12>>>26)|0;w12&=67108863;lo=Math.imul(al9,bl4);mid=Math.imul(al9,bh4);mid=mid+Math.imul(ah9,bl4)|0;hi=Math.imul(ah9,bh4);lo=lo+Math.imul(al8,bl5)|0;mid=mid+Math.imul(al8,bh5)|0;mid=mid+Math.imul(ah8,bl5)|0;hi=hi+Math.imul(ah8,bh5)|0;lo=lo+Math.imul(al7,bl6)|0;mid=mid+Math.imul(al7,bh6)|0;mid=mid+Math.imul(ah7,bl6)|0;hi=hi+Math.imul(ah7,bh6)|0;lo=lo+Math.imul(al6,bl7)|0;mid=mid+Math.imul(al6,bh7)|0;mid=mid+Math.imul(ah6,bl7)|0;hi=hi+Math.imul(ah6,bh7)|0;lo=lo+Math.imul(al5,bl8)|0;mid=mid+Math.imul(al5,bh8)|0;mid=mid+Math.imul(ah5,bl8)|0;hi=hi+Math.imul(ah5,bh8)|0;lo=lo+Math.imul(al4,bl9)|0;mid=mid+Math.imul(al4,bh9)|0;mid=mid+Math.imul(ah4,bl9)|0;hi=hi+Math.imul(ah4,bh9)|0;var w13=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w13>>>26)|0;w13&=67108863;lo=Math.imul(al9,bl5);mid=Math.imul(al9,bh5);mid=mid+Math.imul(ah9,bl5)|0;hi=Math.imul(ah9,bh5);lo=lo+Math.imul(al8,bl6)|0;mid=mid+Math.imul(al8,bh6)|0;mid=mid+Math.imul(ah8,bl6)|0;hi=hi+Math.imul(ah8,bh6)|0;lo=lo+Math.imul(al7,bl7)|0;mid=mid+Math.imul(al7,bh7)|0;mid=mid+Math.imul(ah7,bl7)|0;hi=hi+Math.imul(ah7,bh7)|0;lo=lo+Math.imul(al6,bl8)|0;mid=mid+Math.imul(al6,bh8)|0;mid=mid+Math.imul(ah6,bl8)|0;hi=hi+Math.imul(ah6,bh8)|0;lo=lo+Math.imul(al5,bl9)|0;mid=mid+Math.imul(al5,bh9)|0;mid=mid+Math.imul(ah5,bl9)|0;hi=hi+Math.imul(ah5,bh9)|0;var w14=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w14>>>26)|0;w14&=67108863;lo=Math.imul(al9,bl6);mid=Math.imul(al9,bh6);mid=mid+Math.imul(ah9,bl6)|0;hi=Math.imul(ah9,bh6);lo=lo+Math.imul(al8,bl7)|0;mid=mid+Math.imul(al8,bh7)|0;mid=mid+Math.imul(ah8,bl7)|0;hi=hi+Math.imul(ah8,bh7)|0;lo=lo+Math.imul(al7,bl8)|0;mid=mid+Math.imul(al7,bh8)|0;mid=mid+Math.imul(ah7,bl8)|0;hi=hi+Math.imul(ah7,bh8)|0;lo=lo+Math.imul(al6,bl9)|0;mid=mid+Math.imul(al6,bh9)|0;mid=mid+Math.imul(ah6,bl9)|0;hi=hi+Math.imul(ah6,bh9)|0;var w15=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w15>>>26)|0;w15&=67108863;lo=Math.imul(al9,bl7);mid=Math.imul(al9,bh7);mid=mid+Math.imul(ah9,bl7)|0;hi=Math.imul(ah9,bh7);lo=lo+Math.imul(al8,bl8)|0;mid=mid+Math.imul(al8,bh8)|0;mid=mid+Math.imul(ah8,bl8)|0;hi=hi+Math.imul(ah8,bh8)|0;lo=lo+Math.imul(al7,bl9)|0;mid=mid+Math.imul(al7,bh9)|0;mid=mid+Math.imul(ah7,bl9)|0;hi=hi+Math.imul(ah7,bh9)|0;var w16=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w16>>>26)|0;w16&=67108863;lo=Math.imul(al9,bl8);mid=Math.imul(al9,bh8);mid=mid+Math.imul(ah9,bl8)|0;hi=Math.imul(ah9,bh8);lo=lo+Math.imul(al8,bl9)|0;mid=mid+Math.imul(al8,bh9)|0;mid=mid+Math.imul(ah8,bl9)|0;hi=hi+Math.imul(ah8,bh9)|0;var w17=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w17>>>26)|0;w17&=67108863;lo=Math.imul(al9,bl9);mid=Math.imul(al9,bh9);mid=mid+Math.imul(ah9,bl9)|0;hi=Math.imul(ah9,bh9);var w18=(c+lo|0)+((mid&8191)<<13)|0;c=(hi+(mid>>>13)|0)+(w18>>>26)|0;w18&=67108863;o[0]=w0;o[1]=w1;o[2]=w2;o[3]=w3;o[4]=w4;o[5]=w5;o[6]=w6;o[7]=w7;o[8]=w8;o[9]=w9;o[10]=w10;o[11]=w11;o[12]=w12;o[13]=w13;o[14]=w14;o[15]=w15;o[16]=w16;o[17]=w17;o[18]=w18;if(c!==0){o[19]=c;out.length++}return out};if(!Math.imul){comb10MulTo=smallMulTo}function bigMulTo(self,num,out){out.negative=num.negative^self.negative;out.length=self.length+num.length;var carry=0;var hncarry=0;for(var k=0;k<out.length-1;k++){var ncarry=hncarry;hncarry=0;var rword=carry&67108863;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j;var a=self.words[i]|0;var b=num.words[j]|0;var r=a*b;var lo=r&67108863;ncarry=ncarry+(r/67108864|0)|0;lo=lo+rword|0;rword=lo&67108863;ncarry=ncarry+(lo>>>26)|0;hncarry+=ncarry>>>26;ncarry&=67108863}out.words[k]=rword;carry=ncarry;ncarry=hncarry}if(carry!==0){out.words[k]=carry}else{out.length--}return out.strip()}function jumboMulTo(self,num,out){var fftm=new FFTM;return fftm.mulp(self,num,out)}BN.prototype.mulTo=function mulTo(num,out){var res;var len=this.length+num.length;if(this.length===10&&num.length===10){res=comb10MulTo(this,num,out)}else if(len<63){res=smallMulTo(this,num,out)}else if(len<1024){res=bigMulTo(this,num,out)}else{res=jumboMulTo(this,num,out)}return res};function FFTM(x,y){this.x=x;this.y=y}FFTM.prototype.makeRBT=function makeRBT(N){var t=new Array(N);var l=BN.prototype._countBits(N)-1;for(var i=0;i<N;i++){t[i]=this.revBin(i,l,N)}return t};FFTM.prototype.revBin=function revBin(x,l,N){if(x===0||x===N-1)return x;var rb=0;for(var i=0;i<l;i++){rb|=(x&1)<<l-i-1;x>>=1}return rb};FFTM.prototype.permute=function permute(rbt,rws,iws,rtws,itws,N){for(var i=0;i<N;i++){rtws[i]=rws[rbt[i]];itws[i]=iws[rbt[i]]}};FFTM.prototype.transform=function transform(rws,iws,rtws,itws,N,rbt){this.permute(rbt,rws,iws,rtws,itws,N);for(var s=1;s<N;s<<=1){var l=s<<1;var rtwdf=Math.cos(2*Math.PI/l);var itwdf=Math.sin(2*Math.PI/l);for(var p=0;p<N;p+=l){var rtwdf_=rtwdf;var itwdf_=itwdf;for(var j=0;j<s;j++){var re=rtws[p+j];var ie=itws[p+j];var ro=rtws[p+j+s];var io=itws[p+j+s];var rx=rtwdf_*ro-itwdf_*io;io=rtwdf_*io+itwdf_*ro;ro=rx;rtws[p+j]=re+ro;itws[p+j]=ie+io;rtws[p+j+s]=re-ro;itws[p+j+s]=ie-io;if(j!==l){rx=rtwdf*rtwdf_-itwdf*itwdf_;itwdf_=rtwdf*itwdf_+itwdf*rtwdf_;rtwdf_=rx}}}}};FFTM.prototype.guessLen13b=function guessLen13b(n,m){var N=Math.max(m,n)|1;var odd=N&1;var i=0;for(N=N/2|0;N;N=N>>>1){i++}return 1<<i+1+odd};FFTM.prototype.conjugate=function conjugate(rws,iws,N){if(N<=1)return;for(var i=0;i<N/2;i++){var t=rws[i];rws[i]=rws[N-i-1];rws[N-i-1]=t;t=iws[i];iws[i]=-iws[N-i-1];iws[N-i-1]=-t}};FFTM.prototype.normalize13b=function normalize13b(ws,N){var carry=0;for(var i=0;i<N/2;i++){var w=Math.round(ws[2*i+1]/N)*8192+Math.round(ws[2*i]/N)+carry;ws[i]=w&67108863;if(w<67108864){carry=0}else{carry=w/67108864|0}}return ws};FFTM.prototype.convert13b=function convert13b(ws,len,rws,N){var carry=0;for(var i=0;i<len;i++){carry=carry+(ws[i]|0);rws[2*i]=carry&8191;carry=carry>>>13;rws[2*i+1]=carry&8191;carry=carry>>>13}for(i=2*len;i<N;++i){rws[i]=0}assert(carry===0);assert((carry&~8191)===0)};FFTM.prototype.stub=function stub(N){var ph=new Array(N);for(var i=0;i<N;i++){ph[i]=0}return ph};FFTM.prototype.mulp=function mulp(x,y,out){var N=2*this.guessLen13b(x.length,y.length);var rbt=this.makeRBT(N);var _=this.stub(N);var rws=new Array(N);var rwst=new Array(N);var iwst=new Array(N);var nrws=new Array(N);var nrwst=new Array(N);var niwst=new Array(N);var rmws=out.words;rmws.length=N;this.convert13b(x.words,x.length,rws,N);this.convert13b(y.words,y.length,nrws,N);this.transform(rws,_,rwst,iwst,N,rbt);this.transform(nrws,_,nrwst,niwst,N,rbt);for(var i=0;i<N;i++){var rx=rwst[i]*nrwst[i]-iwst[i]*niwst[i];iwst[i]=rwst[i]*niwst[i]+iwst[i]*nrwst[i];rwst[i]=rx}this.conjugate(rwst,iwst,N);this.transform(rwst,iwst,rmws,_,N,rbt);this.conjugate(rmws,_,N);this.normalize13b(rmws,N);out.negative=x.negative^y.negative;out.length=x.length+y.length;return out.strip()};BN.prototype.mul=function mul(num){var out=new BN(null);out.words=new Array(this.length+num.length);return this.mulTo(num,out)};BN.prototype.mulf=function mulf(num){var out=new BN(null);out.words=new Array(this.length+num.length);return jumboMulTo(this,num,out)};BN.prototype.imul=function imul(num){return this.clone().mulTo(num,this)};BN.prototype.imuln=function imuln(num){assert(typeof num==="number");assert(num<67108864);var carry=0;for(var i=0;i<this.length;i++){var w=(this.words[i]|0)*num;var lo=(w&67108863)+(carry&67108863);carry>>=26;carry+=w/67108864|0;carry+=lo>>>26;this.words[i]=lo&67108863}if(carry!==0){this.words[i]=carry;this.length++}return this};BN.prototype.muln=function muln(num){return this.clone().imuln(num)};BN.prototype.sqr=function sqr(){return this.mul(this)};BN.prototype.isqr=function isqr(){return this.imul(this.clone())};BN.prototype.pow=function pow(num){var w=toBitArray(num);if(w.length===0)return new BN(1);var res=this;for(var i=0;i<w.length;i++,res=res.sqr()){if(w[i]!==0)break}if(++i<w.length){for(var q=res.sqr();i<w.length;i++,q=q.sqr()){if(w[i]===0)continue;res=res.mul(q)}}return res};BN.prototype.iushln=function iushln(bits){assert(typeof bits==="number"&&bits>=0);var r=bits%26;var s=(bits-r)/26;var carryMask=67108863>>>26-r<<26-r;var i;if(r!==0){var carry=0;for(i=0;i<this.length;i++){var newCarry=this.words[i]&carryMask;var c=(this.words[i]|0)-newCarry<<r;this.words[i]=c|carry;carry=newCarry>>>26-r}if(carry){this.words[i]=carry;this.length++}}if(s!==0){for(i=this.length-1;i>=0;i--){this.words[i+s]=this.words[i]}for(i=0;i<s;i++){this.words[i]=0}this.length+=s}return this.strip()};BN.prototype.ishln=function ishln(bits){assert(this.negative===0);return this.iushln(bits)};BN.prototype.iushrn=function iushrn(bits,hint,extended){assert(typeof bits==="number"&&bits>=0);var h;if(hint){h=(hint-hint%26)/26}else{h=0}var r=bits%26;var s=Math.min((bits-r)/26,this.length);var mask=67108863^67108863>>>r<<r;var maskedWords=extended;h-=s;h=Math.max(0,h);if(maskedWords){for(var i=0;i<s;i++){maskedWords.words[i]=this.words[i]}maskedWords.length=s}if(s===0){}else if(this.length>s){this.length-=s;for(i=0;i<this.length;i++){this.words[i]=this.words[i+s]}}else{this.words[0]=0;this.length=1}var carry=0;for(i=this.length-1;i>=0&&(carry!==0||i>=h);i--){var word=this.words[i]|0;this.words[i]=carry<<26-r|word>>>r;carry=word&mask}if(maskedWords&&carry!==0){maskedWords.words[maskedWords.length++]=carry}if(this.length===0){this.words[0]=0;this.length=1}return this.strip()};BN.prototype.ishrn=function ishrn(bits,hint,extended){assert(this.negative===0);return this.iushrn(bits,hint,extended)};BN.prototype.shln=function shln(bits){return this.clone().ishln(bits)};BN.prototype.ushln=function ushln(bits){return this.clone().iushln(bits)};BN.prototype.shrn=function shrn(bits){return this.clone().ishrn(bits)};BN.prototype.ushrn=function ushrn(bits){return this.clone().iushrn(bits)};BN.prototype.testn=function testn(bit){assert(typeof bit==="number"&&bit>=0);var r=bit%26;var s=(bit-r)/26;var q=1<<r;if(this.length<=s)return false;var w=this.words[s];return!!(w&q)};BN.prototype.imaskn=function imaskn(bits){assert(typeof bits==="number"&&bits>=0);var r=bits%26;var s=(bits-r)/26;assert(this.negative===0,"imaskn works only with positive numbers");if(this.length<=s){return this}if(r!==0){s++}this.length=Math.min(s,this.length);if(r!==0){var mask=67108863^67108863>>>r<<r;this.words[this.length-1]&=mask}return this.strip()};BN.prototype.maskn=function maskn(bits){return this.clone().imaskn(bits)};BN.prototype.iaddn=function iaddn(num){assert(typeof num==="number");assert(num<67108864);if(num<0)return this.isubn(-num);if(this.negative!==0){if(this.length===1&&(this.words[0]|0)<num){this.words[0]=num-(this.words[0]|0);this.negative=0;return this}this.negative=0;this.isubn(num);this.negative=1;return this}return this._iaddn(num)};BN.prototype._iaddn=function _iaddn(num){this.words[0]+=num;for(var i=0;i<this.length&&this.words[i]>=67108864;i++){this.words[i]-=67108864;if(i===this.length-1){this.words[i+1]=1}else{this.words[i+1]++}}this.length=Math.max(this.length,i+1);return this};BN.prototype.isubn=function isubn(num){assert(typeof num==="number");assert(num<67108864);if(num<0)return this.iaddn(-num);if(this.negative!==0){this.negative=0;this.iaddn(num);this.negative=1;return this}this.words[0]-=num;if(this.length===1&&this.words[0]<0){this.words[0]=-this.words[0];this.negative=1}else{for(var i=0;i<this.length&&this.words[i]<0;i++){this.words[i]+=67108864;this.words[i+1]-=1}}return this.strip()};BN.prototype.addn=function addn(num){return this.clone().iaddn(num)};BN.prototype.subn=function subn(num){return this.clone().isubn(num)};BN.prototype.iabs=function iabs(){this.negative=0;return this};BN.prototype.abs=function abs(){return this.clone().iabs()};BN.prototype._ishlnsubmul=function _ishlnsubmul(num,mul,shift){var len=num.length+shift;var i;this._expand(len);var w;var carry=0;for(i=0;i<num.length;i++){w=(this.words[i+shift]|0)+carry;var right=(num.words[i]|0)*mul;w-=right&67108863;carry=(w>>26)-(right/67108864|0);this.words[i+shift]=w&67108863}for(;i<this.length-shift;i++){w=(this.words[i+shift]|0)+carry;carry=w>>26;this.words[i+shift]=w&67108863}if(carry===0)return this.strip();assert(carry===-1);carry=0;for(i=0;i<this.length;i++){w=-(this.words[i]|0)+carry;carry=w>>26;this.words[i]=w&67108863}this.negative=1;return this.strip()};BN.prototype._wordDiv=function _wordDiv(num,mode){var shift=this.length-num.length;var a=this.clone();var b=num;var bhi=b.words[b.length-1]|0;var bhiBits=this._countBits(bhi);shift=26-bhiBits;if(shift!==0){b=b.ushln(shift);a.iushln(shift);bhi=b.words[b.length-1]|0}var m=a.length-b.length;var q;if(mode!=="mod"){q=new BN(null);q.length=m+1;q.words=new Array(q.length);for(var i=0;i<q.length;i++){q.words[i]=0}}var diff=a.clone()._ishlnsubmul(b,1,m);if(diff.negative===0){a=diff;if(q){q.words[m]=1}}for(var j=m-1;j>=0;j--){var qj=(a.words[b.length+j]|0)*67108864+(a.words[b.length+j-1]|0);qj=Math.min(qj/bhi|0,67108863);a._ishlnsubmul(b,qj,j);while(a.negative!==0){qj--;a.negative=0;a._ishlnsubmul(b,1,j);if(!a.isZero()){a.negative^=1}}if(q){q.words[j]=qj}}if(q){q.strip()}a.strip();if(mode!=="div"&&shift!==0){a.iushrn(shift)}return{div:q||null,mod:a}};BN.prototype.divmod=function divmod(num,mode,positive){assert(!num.isZero());if(this.isZero()){return{div:new BN(0),mod:new BN(0)}}var div,mod,res;if(this.negative!==0&&num.negative===0){res=this.neg().divmod(num,mode);if(mode!=="mod"){div=res.div.neg()}if(mode!=="div"){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.iadd(num)}}return{div:div,mod:mod}}if(this.negative===0&&num.negative!==0){res=this.divmod(num.neg(),mode);if(mode!=="mod"){div=res.div.neg()}return{div:div,mod:res.mod}}if((this.negative&num.negative)!==0){res=this.neg().divmod(num.neg(),mode);if(mode!=="div"){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.isub(num)}}return{div:res.div,mod:mod}}if(num.length>this.length||this.cmp(num)<0){return{div:new BN(0),mod:this}}if(num.length===1){if(mode==="div"){return{div:this.divn(num.words[0]),mod:null}}if(mode==="mod"){return{div:null,mod:new BN(this.modn(num.words[0]))}}return{div:this.divn(num.words[0]),mod:new BN(this.modn(num.words[0]))}}return this._wordDiv(num,mode)};BN.prototype.div=function div(num){return this.divmod(num,"div",false).div};BN.prototype.mod=function mod(num){return this.divmod(num,"mod",false).mod};BN.prototype.umod=function umod(num){return this.divmod(num,"mod",true).mod};BN.prototype.divRound=function divRound(num){var dm=this.divmod(num);if(dm.mod.isZero())return dm.div;var mod=dm.div.negative!==0?dm.mod.isub(num):dm.mod;var half=num.ushrn(1);var r2=num.andln(1);var cmp=mod.cmp(half);if(cmp<0||r2===1&&cmp===0)return dm.div;return dm.div.negative!==0?dm.div.isubn(1):dm.div.iaddn(1)};BN.prototype.modn=function modn(num){assert(num<=67108863);var p=(1<<26)%num;var acc=0;for(var i=this.length-1;i>=0;i--){acc=(p*acc+(this.words[i]|0))%num}return acc};BN.prototype.idivn=function idivn(num){assert(num<=67108863);var carry=0;for(var i=this.length-1;i>=0;i--){var w=(this.words[i]|0)+carry*67108864;this.words[i]=w/num|0;carry=w%num}return this.strip()};BN.prototype.divn=function divn(num){return this.clone().idivn(num)};BN.prototype.egcd=function egcd(p){assert(p.negative===0);assert(!p.isZero());var x=this;var y=p.clone();if(x.negative!==0){x=x.umod(p)}else{x=x.clone()}var A=new BN(1);var B=new BN(0);var C=new BN(0);var D=new BN(1);var g=0;while(x.isEven()&&y.isEven()){x.iushrn(1);y.iushrn(1);++g}var yp=y.clone();var xp=x.clone();while(!x.isZero()){for(var i=0,im=1;(x.words[0]&im)===0&&i<26;++i,im<<=1);if(i>0){x.iushrn(i);while(i-- >0){if(A.isOdd()||B.isOdd()){A.iadd(yp);B.isub(xp)}A.iushrn(1);B.iushrn(1)}}for(var j=0,jm=1;(y.words[0]&jm)===0&&j<26;++j,jm<<=1);if(j>0){y.iushrn(j);while(j-- >0){if(C.isOdd()||D.isOdd()){C.iadd(yp);D.isub(xp)}C.iushrn(1);D.iushrn(1)}}if(x.cmp(y)>=0){x.isub(y);A.isub(C);B.isub(D)}else{y.isub(x);C.isub(A);D.isub(B)}}return{a:C,b:D,gcd:y.iushln(g)}};BN.prototype._invmp=function _invmp(p){assert(p.negative===0);assert(!p.isZero());var a=this;var b=p.clone();if(a.negative!==0){a=a.umod(p)}else{a=a.clone()}var x1=new BN(1);var x2=new BN(0);var delta=b.clone();while(a.cmpn(1)>0&&b.cmpn(1)>0){for(var i=0,im=1;(a.words[0]&im)===0&&i<26;++i,im<<=1);if(i>0){a.iushrn(i);while(i-- >0){if(x1.isOdd()){x1.iadd(delta)}x1.iushrn(1)}}for(var j=0,jm=1;(b.words[0]&jm)===0&&j<26;++j,jm<<=1);if(j>0){b.iushrn(j);while(j-- >0){if(x2.isOdd()){x2.iadd(delta)}x2.iushrn(1)}}if(a.cmp(b)>=0){a.isub(b);x1.isub(x2)}else{b.isub(a);x2.isub(x1)}}var res;if(a.cmpn(1)===0){res=x1}else{res=x2}if(res.cmpn(0)<0){res.iadd(p)}return res};BN.prototype.gcd=function gcd(num){if(this.isZero())return num.abs();if(num.isZero())return this.abs();var a=this.clone();var b=num.clone();a.negative=0;b.negative=0;for(var shift=0;a.isEven()&&b.isEven();shift++){a.iushrn(1);b.iushrn(1)}do{while(a.isEven()){a.iushrn(1)}while(b.isEven()){b.iushrn(1)}var r=a.cmp(b);if(r<0){var t=a;a=b;b=t}else if(r===0||b.cmpn(1)===0){break}a.isub(b)}while(true);return b.iushln(shift)};BN.prototype.invm=function invm(num){return this.egcd(num).a.umod(num)};BN.prototype.isEven=function isEven(){return(this.words[0]&1)===0};BN.prototype.isOdd=function isOdd(){return(this.words[0]&1)===1};BN.prototype.andln=function andln(num){return this.words[0]&num};BN.prototype.bincn=function bincn(bit){assert(typeof bit==="number");var r=bit%26;var s=(bit-r)/26;var q=1<<r;if(this.length<=s){this._expand(s+1);this.words[s]|=q;return this}var carry=q;for(var i=s;carry!==0&&i<this.length;i++){var w=this.words[i]|0;w+=carry;carry=w>>>26;w&=67108863;this.words[i]=w}if(carry!==0){this.words[i]=carry;this.length++}return this};BN.prototype.isZero=function isZero(){return this.length===1&&this.words[0]===0};BN.prototype.cmpn=function cmpn(num){var negative=num<0;if(this.negative!==0&&!negative)return-1;if(this.negative===0&&negative)return 1;this.strip();var res;if(this.length>1){res=1}else{if(negative){num=-num}assert(num<=67108863,"Number is too big");var w=this.words[0]|0;res=w===num?0:w<num?-1:1}if(this.negative!==0)return-res|0;return res};BN.prototype.cmp=function cmp(num){if(this.negative!==0&&num.negative===0)return-1;if(this.negative===0&&num.negative!==0)return 1;var res=this.ucmp(num);if(this.negative!==0)return-res|0;return res};BN.prototype.ucmp=function ucmp(num){if(this.length>num.length)return 1;if(this.length<num.length)return-1;var res=0;for(var i=this.length-1;i>=0;i--){var a=this.words[i]|0;var b=num.words[i]|0;if(a===b)continue;if(a<b){res=-1}else if(a>b){res=1}break}return res};BN.prototype.gtn=function gtn(num){return this.cmpn(num)===1};BN.prototype.gt=function gt(num){return this.cmp(num)===1};BN.prototype.gten=function gten(num){return this.cmpn(num)>=0};BN.prototype.gte=function gte(num){return this.cmp(num)>=0};BN.prototype.ltn=function ltn(num){return this.cmpn(num)===-1};BN.prototype.lt=function lt(num){return this.cmp(num)===-1};BN.prototype.lten=function lten(num){return this.cmpn(num)<=0};BN.prototype.lte=function lte(num){return this.cmp(num)<=0};BN.prototype.eqn=function eqn(num){return this.cmpn(num)===0};BN.prototype.eq=function eq(num){return this.cmp(num)===0};BN.red=function red(num){return new Red(num)};BN.prototype.toRed=function toRed(ctx){assert(!this.red,"Already a number in reduction context");assert(this.negative===0,"red works only with positives");return ctx.convertTo(this)._forceRed(ctx)};BN.prototype.fromRed=function fromRed(){assert(this.red,"fromRed works only with numbers in reduction context");return this.red.convertFrom(this)};BN.prototype._forceRed=function _forceRed(ctx){this.red=ctx;return this};BN.prototype.forceRed=function forceRed(ctx){assert(!this.red,"Already a number in reduction context");return this._forceRed(ctx)};BN.prototype.redAdd=function redAdd(num){assert(this.red,"redAdd works only with red numbers");return this.red.add(this,num)};BN.prototype.redIAdd=function redIAdd(num){assert(this.red,"redIAdd works only with red numbers");return this.red.iadd(this,num)};BN.prototype.redSub=function redSub(num){assert(this.red,"redSub works only with red numbers");return this.red.sub(this,num)};BN.prototype.redISub=function redISub(num){assert(this.red,"redISub works only with red numbers");return this.red.isub(this,num)};BN.prototype.redShl=function redShl(num){assert(this.red,"redShl works only with red numbers");return this.red.shl(this,num)};BN.prototype.redMul=function redMul(num){assert(this.red,"redMul works only with red numbers");this.red._verify2(this,num);return this.red.mul(this,num)};BN.prototype.redIMul=function redIMul(num){assert(this.red,"redMul works only with red numbers");this.red._verify2(this,num);return this.red.imul(this,num)};BN.prototype.redSqr=function redSqr(){assert(this.red,"redSqr works only with red numbers");this.red._verify1(this);return this.red.sqr(this)};BN.prototype.redISqr=function redISqr(){assert(this.red,"redISqr works only with red numbers");this.red._verify1(this);return this.red.isqr(this)};BN.prototype.redSqrt=function redSqrt(){assert(this.red,"redSqrt works only with red numbers");this.red._verify1(this);return this.red.sqrt(this)};BN.prototype.redInvm=function redInvm(){assert(this.red,"redInvm works only with red numbers");this.red._verify1(this);return this.red.invm(this)};BN.prototype.redNeg=function redNeg(){assert(this.red,"redNeg works only with red numbers");this.red._verify1(this);return this.red.neg(this)};BN.prototype.redPow=function redPow(num){assert(this.red&&!num.red,"redPow(normalNum)");this.red._verify1(this);return this.red.pow(this,num)};var primes={k256:null,p224:null,p192:null,p25519:null};function MPrime(name,p){this.name=name;this.p=new BN(p,16);this.n=this.p.bitLength();this.k=new BN(1).iushln(this.n).isub(this.p);this.tmp=this._tmp()}MPrime.prototype._tmp=function _tmp(){var tmp=new BN(null);tmp.words=new Array(Math.ceil(this.n/13));return tmp};MPrime.prototype.ireduce=function ireduce(num){var r=num;var rlen;do{this.split(r,this.tmp);r=this.imulK(r);r=r.iadd(this.tmp);rlen=r.bitLength()}while(rlen>this.n);var cmp=rlen<this.n?-1:r.ucmp(this.p);if(cmp===0){r.words[0]=0;r.length=1}else if(cmp>0){r.isub(this.p)}else{if(r.strip!==undefined){r.strip()}else{r._strip()}}return r};MPrime.prototype.split=function split(input,out){input.iushrn(this.n,0,out)};MPrime.prototype.imulK=function imulK(num){return num.imul(this.k)};function K256(){MPrime.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}inherits(K256,MPrime);K256.prototype.split=function split(input,output){var mask=4194303;var outLen=Math.min(input.length,9);for(var i=0;i<outLen;i++){output.words[i]=input.words[i]}output.length=outLen;if(input.length<=9){input.words[0]=0;input.length=1;return}var prev=input.words[9];output.words[output.length++]=prev&mask;for(i=10;i<input.length;i++){var next=input.words[i]|0;input.words[i-10]=(next&mask)<<4|prev>>>22;prev=next}prev>>>=22;input.words[i-10]=prev;if(prev===0&&input.length>10){input.length-=10}else{input.length-=9}};K256.prototype.imulK=function imulK(num){num.words[num.length]=0;num.words[num.length+1]=0;num.length+=2;var lo=0;for(var i=0;i<num.length;i++){var w=num.words[i]|0;lo+=w*977;num.words[i]=lo&67108863;lo=w*64+(lo/67108864|0)}if(num.words[num.length-1]===0){num.length--;if(num.words[num.length-1]===0){num.length--}}return num};function P224(){MPrime.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}inherits(P224,MPrime);function P192(){MPrime.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}inherits(P192,MPrime);function P25519(){MPrime.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}inherits(P25519,MPrime);P25519.prototype.imulK=function imulK(num){var carry=0;for(var i=0;i<num.length;i++){var hi=(num.words[i]|0)*19+carry;var lo=hi&67108863;hi>>>=26;num.words[i]=lo;carry=hi}if(carry!==0){num.words[num.length++]=carry}return num};BN._prime=function prime(name){if(primes[name])return primes[name];var prime;if(name==="k256"){prime=new K256}else if(name==="p224"){prime=new P224}else if(name==="p192"){prime=new P192}else if(name==="p25519"){prime=new P25519}else{throw new Error("Unknown prime "+name)}primes[name]=prime;return prime};function Red(m){if(typeof m==="string"){var prime=BN._prime(m);this.m=prime.p;this.prime=prime}else{assert(m.gtn(1),"modulus must be greater than 1");this.m=m;this.prime=null}}Red.prototype._verify1=function _verify1(a){assert(a.negative===0,"red works only with positives");assert(a.red,"red works only with red numbers")};Red.prototype._verify2=function _verify2(a,b){assert((a.negative|b.negative)===0,"red works only with positives");assert(a.red&&a.red===b.red,"red works only with red numbers")};Red.prototype.imod=function imod(a){if(this.prime)return this.prime.ireduce(a)._forceRed(this);return a.umod(this.m)._forceRed(this)};Red.prototype.neg=function neg(a){if(a.isZero()){return a.clone()}return this.m.sub(a)._forceRed(this)};Red.prototype.add=function add(a,b){this._verify2(a,b);var res=a.add(b);if(res.cmp(this.m)>=0){res.isub(this.m)}return res._forceRed(this)};Red.prototype.iadd=function iadd(a,b){this._verify2(a,b);var res=a.iadd(b);if(res.cmp(this.m)>=0){res.isub(this.m)}return res};Red.prototype.sub=function sub(a,b){this._verify2(a,b);var res=a.sub(b);if(res.cmpn(0)<0){res.iadd(this.m)}return res._forceRed(this)};Red.prototype.isub=function isub(a,b){this._verify2(a,b);var res=a.isub(b);if(res.cmpn(0)<0){res.iadd(this.m)}return res};Red.prototype.shl=function shl(a,num){this._verify1(a);return this.imod(a.ushln(num))};Red.prototype.imul=function imul(a,b){this._verify2(a,b);return this.imod(a.imul(b))};Red.prototype.mul=function mul(a,b){this._verify2(a,b);return this.imod(a.mul(b))};Red.prototype.isqr=function isqr(a){return this.imul(a,a.clone())};Red.prototype.sqr=function sqr(a){return this.mul(a,a)};Red.prototype.sqrt=function sqrt(a){if(a.isZero())return a.clone();var mod3=this.m.andln(3);assert(mod3%2===1);if(mod3===3){var pow=this.m.add(new BN(1)).iushrn(2);return this.pow(a,pow)}var q=this.m.subn(1);var s=0;while(!q.isZero()&&q.andln(1)===0){s++;q.iushrn(1)}assert(!q.isZero());var one=new BN(1).toRed(this);var nOne=one.redNeg();var lpow=this.m.subn(1).iushrn(1);var z=this.m.bitLength();z=new BN(2*z*z).toRed(this);while(this.pow(z,lpow).cmp(nOne)!==0){z.redIAdd(nOne)}var c=this.pow(z,q);var r=this.pow(a,q.addn(1).iushrn(1));var t=this.pow(a,q);var m=s;while(t.cmp(one)!==0){var tmp=t;for(var i=0;tmp.cmp(one)!==0;i++){tmp=tmp.redSqr()}assert(i<m);var b=this.pow(c,new BN(1).iushln(m-i-1));r=r.redMul(b);c=b.redSqr();t=t.redMul(c);m=i}return r};Red.prototype.invm=function invm(a){var inv=a._invmp(this.m);if(inv.negative!==0){inv.negative=0;return this.imod(inv).redNeg()}else{return this.imod(inv)}};Red.prototype.pow=function pow(a,num){if(num.isZero())return new BN(1).toRed(this);if(num.cmpn(1)===0)return a.clone();var windowSize=4;var wnd=new Array(1<<windowSize);wnd[0]=new BN(1).toRed(this);wnd[1]=a;for(var i=2;i<wnd.length;i++){wnd[i]=this.mul(wnd[i-1],a)}var res=wnd[0];var current=0;var currentLen=0;var start=num.bitLength()%26;if(start===0){start=26}for(i=num.length-1;i>=0;i--){var word=num.words[i];for(var j=start-1;j>=0;j--){var bit=word>>j&1;if(res!==wnd[0]){res=this.sqr(res)}if(bit===0&&current===0){currentLen=0;continue}current<<=1;current|=bit;currentLen++;if(currentLen!==windowSize&&(i!==0||j!==0))continue;res=this.mul(res,wnd[current]);currentLen=0;current=0}start=26}return res};Red.prototype.convertTo=function convertTo(num){var r=num.umod(this.m);return r===num?r.clone():r};Red.prototype.convertFrom=function convertFrom(num){var res=num.clone();res.red=null;return res};BN.mont=function mont(num){return new Mont(num)};function Mont(m){Red.call(this,m);this.shift=this.m.bitLength();if(this.shift%26!==0){this.shift+=26-this.shift%26}this.r=new BN(1).iushln(this.shift);this.r2=this.imod(this.r.sqr());this.rinv=this.r._invmp(this.m);this.minv=this.rinv.mul(this.r).isubn(1).div(this.m);this.minv=this.minv.umod(this.r);this.minv=this.r.sub(this.minv)}inherits(Mont,Red);Mont.prototype.convertTo=function convertTo(num){return this.imod(num.ushln(this.shift))};Mont.prototype.convertFrom=function convertFrom(num){var r=this.imod(num.mul(this.rinv));r.red=null;return r};Mont.prototype.imul=function imul(a,b){if(a.isZero()||b.isZero()){a.words[0]=0;a.length=1;return a}var t=a.imul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m)}else if(u.cmpn(0)<0){res=u.iadd(this.m)}return res._forceRed(this)};Mont.prototype.mul=function mul(a,b){if(a.isZero()||b.isZero())return new BN(0)._forceRed(this);var t=a.mul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m)}else if(u.cmpn(0)<0){res=u.iadd(this.m)}return res._forceRed(this)};Mont.prototype.invm=function invm(a){var res=this.imod(a._invmp(this.m).mul(this.r2));return res._forceRed(this)}})( false||module,commonjsGlobal)});const version="logger/5.1.0";"use strict";let _permanentCensorErrors=false;let _censorErrors=false;const LogLevels={debug:1,default:2,info:2,warning:3,error:4,off:5};let _logLevel=LogLevels["default"];let _globalLogger=null;function _checkNormalize(){try{const missing=[];["NFD","NFC","NFKD","NFKC"].forEach(form=>{try{if("test".normalize(form)!=="test"){throw new Error("bad normalize")}}catch(error){missing.push(form)}});if(missing.length){throw new Error("missing "+missing.join(", "))}if(String.fromCharCode(233).normalize("NFD")!==String.fromCharCode(101,769)){throw new Error("broken implementation")}}catch(error){return error.message}return null}const _normalizeError=_checkNormalize();var LogLevel;(function(LogLevel){LogLevel["DEBUG"]="DEBUG";LogLevel["INFO"]="INFO";LogLevel["WARNING"]="WARNING";LogLevel["ERROR"]="ERROR";LogLevel["OFF"]="OFF"})(LogLevel||(LogLevel={}));var ErrorCode;(function(ErrorCode){ErrorCode["UNKNOWN_ERROR"]="UNKNOWN_ERROR";ErrorCode["NOT_IMPLEMENTED"]="NOT_IMPLEMENTED";ErrorCode["UNSUPPORTED_OPERATION"]="UNSUPPORTED_OPERATION";ErrorCode["NETWORK_ERROR"]="NETWORK_ERROR";ErrorCode["SERVER_ERROR"]="SERVER_ERROR";ErrorCode["TIMEOUT"]="TIMEOUT";ErrorCode["BUFFER_OVERRUN"]="BUFFER_OVERRUN";ErrorCode["NUMERIC_FAULT"]="NUMERIC_FAULT";ErrorCode["MISSING_NEW"]="MISSING_NEW";ErrorCode["INVALID_ARGUMENT"]="INVALID_ARGUMENT";ErrorCode["MISSING_ARGUMENT"]="MISSING_ARGUMENT";ErrorCode["UNEXPECTED_ARGUMENT"]="UNEXPECTED_ARGUMENT";ErrorCode["CALL_EXCEPTION"]="CALL_EXCEPTION";ErrorCode["INSUFFICIENT_FUNDS"]="INSUFFICIENT_FUNDS";ErrorCode["NONCE_EXPIRED"]="NONCE_EXPIRED";ErrorCode["REPLACEMENT_UNDERPRICED"]="REPLACEMENT_UNDERPRICED";ErrorCode["UNPREDICTABLE_GAS_LIMIT"]="UNPREDICTABLE_GAS_LIMIT"})(ErrorCode||(ErrorCode={}));class Logger{constructor(version){Object.defineProperty(this,"version",{enumerable:true,value:version,writable:false})}_log(logLevel,args){const level=logLevel.toLowerCase();if(LogLevels[level]==null){this.throwArgumentError("invalid log level name","logLevel",logLevel)}if(_logLevel>LogLevels[level]){return}console.log.apply(console,args)}debug(...args){this._log(Logger.levels.DEBUG,args)}info(...args){this._log(Logger.levels.INFO,args)}warn(...args){this._log(Logger.levels.WARNING,args)}makeError(message,code,params){if(_censorErrors){return this.makeError("censored error",code,{})}if(!code){code=Logger.errors.UNKNOWN_ERROR}if(!params){params={}}const messageDetails=[];Object.keys(params).forEach(key=>{try{messageDetails.push(key+"="+JSON.stringify(params[key]))}catch(error){messageDetails.push(key+"="+JSON.stringify(params[key].toString()))}});messageDetails.push(`code=${code}`);messageDetails.push(`version=${this.version}`);const reason=message;if(messageDetails.length){message+=" ("+messageDetails.join(", ")+")"}const error=new Error(message);error.reason=reason;error.code=code;Object.keys(params).forEach(function(key){error[key]=params[key]});return error}throwError(message,code,params){throw this.makeError(message,code,params)}throwArgumentError(message,name,value){return this.throwError(message,Logger.errors.INVALID_ARGUMENT,{argument:name,value:value})}assert(condition,message,code,params){if(!!condition){return}this.throwError(message,code,params)}assertArgument(condition,message,name,value){if(!!condition){return}this.throwArgumentError(message,name,value)}checkNormalize(message){if(message==null){message="platform missing String.prototype.normalize"}if(_normalizeError){this.throwError("platform missing String.prototype.normalize",Logger.errors.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:_normalizeError})}}checkSafeUint53(value,message){if(typeof value!=="number"){return}if(message==null){message="value not safe"}if(value<0||value>=9007199254740991){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"out-of-safe-range",value:value})}if(value%1){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"non-integer",value:value})}}checkArgumentCount(count,expectedCount,message){if(message){message=": "+message}else{message=""}if(count<expectedCount){this.throwError("missing argument"+message,Logger.errors.MISSING_ARGUMENT,{count:count,expectedCount:expectedCount})}if(count>expectedCount){this.throwError("too many arguments"+message,Logger.errors.UNEXPECTED_ARGUMENT,{count:count,expectedCount:expectedCount})}}checkNew(target,kind){if(target===Object||target==null){this.throwError("missing new",Logger.errors.MISSING_NEW,{name:kind.name})}}checkAbstract(target,kind){if(target===kind){this.throwError("cannot instantiate abstract class "+JSON.stringify(kind.name)+" directly; use a sub-class",Logger.errors.UNSUPPORTED_OPERATION,{name:target.name,operation:"new"})}else if(target===Object||target==null){this.throwError("missing new",Logger.errors.MISSING_NEW,{name:kind.name})}}static globalLogger(){if(!_globalLogger){_globalLogger=new Logger(version)}return _globalLogger}static setCensorship(censorship,permanent){if(!censorship&&permanent){this.globalLogger().throwError("cannot permanently disable censorship",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}if(_permanentCensorErrors){if(!censorship){return}this.globalLogger().throwError("error censorship permanent",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}_censorErrors=!!censorship;_permanentCensorErrors=!!permanent}static setLogLevel(logLevel){const level=LogLevels[logLevel.toLowerCase()];if(level==null){Logger.globalLogger().warn("invalid log level - "+logLevel);return}_logLevel=level}static from(version){return new Logger(version)}}Logger.errors=ErrorCode;Logger.levels=LogLevel;const version$1="bytes/5.1.0";"use strict";const logger=new Logger(version$1);function isHexable(value){return!!value.toHexString}function addSlice(array){if(array.slice){return array}array.slice=function(){const args=Array.prototype.slice.call(arguments);return addSlice(new Uint8Array(Array.prototype.slice.apply(array,args)))};return array}function isBytesLike(value){return isHexString(value)&&!(value.length%2)||isBytes(value)}function isBytes(value){if(value==null){return false}if(value.constructor===Uint8Array){return true}if(typeof value==="string"){return false}if(value.length==null){return false}for(let i=0;i<value.length;i++){const v=value[i];if(typeof v!=="number"||v<0||v>=256||v%1){return false}}return true}function arrayify(value,options){if(!options){options={}}if(typeof value==="number"){logger.checkSafeUint53(value,"invalid arrayify value");const result=[];while(value){result.unshift(value&255);value=parseInt(String(value/256))}if(result.length===0){result.push(0)}return addSlice(new Uint8Array(result))}if(options.allowMissingPrefix&&typeof value==="string"&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexable(value)){value=value.toHexString()}if(isHexString(value)){let hex=value.substring(2);if(hex.length%2){if(options.hexPad==="left"){hex="0x0"+hex.substring(2)}else if(options.hexPad==="right"){hex+="0"}else{logger.throwArgumentError("hex data is odd-length","value",value)}}const result=[];for(let i=0;i<hex.length;i+=2){result.push(parseInt(hex.substring(i,i+2),16))}return addSlice(new Uint8Array(result))}if(isBytes(value)){return addSlice(new Uint8Array(value))}return logger.throwArgumentError("invalid arrayify value","value",value)}function concat(items){const objects=items.map(item=>arrayify(item));const length=objects.reduce((accum,item)=>accum+item.length,0);const result=new Uint8Array(length);objects.reduce((offset,object)=>{result.set(object,offset);return offset+object.length},0);return addSlice(result)}function stripZeros(value){let result=arrayify(value);if(result.length===0){return result}let start=0;while(start<result.length&&result[start]===0){start++}if(start){result=result.slice(start)}return result}function zeroPad(value,length){value=arrayify(value);if(value.length>length){logger.throwArgumentError("value out of range","value",arguments[0])}const result=new Uint8Array(length);result.set(value,length-value.length);return addSlice(result)}function isHexString(value,length){if(typeof value!=="string"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(length&&value.length!==2+2*length){return false}return true}const HexCharacters="0123456789abcdef";function hexlify(value,options){if(!options){options={}}if(typeof value==="number"){logger.checkSafeUint53(value,"invalid hexlify value");let hex="";while(value){hex=HexCharacters[value&15]+hex;value=Math.floor(value/16)}if(hex.length){if(hex.length%2){hex="0"+hex}return"0x"+hex}return"0x00"}if(options.allowMissingPrefix&&typeof value==="string"&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexable(value)){return value.toHexString()}if(isHexString(value)){if(value.length%2){if(options.hexPad==="left"){value="0x0"+value.substring(2)}else if(options.hexPad==="right"){value+="0"}else{logger.throwArgumentError("hex data is odd-length","value",value)}}return value.toLowerCase()}if(isBytes(value)){let result="0x";for(let i=0;i<value.length;i++){let v=value[i];result+=HexCharacters[(v&240)>>4]+HexCharacters[v&15]}return result}return logger.throwArgumentError("invalid hexlify value","value",value)}function hexDataLength(data){if(typeof data!=="string"){data=hexlify(data)}else if(!isHexString(data)||data.length%2){return null}return(data.length-2)/2}function hexDataSlice(data,offset,endOffset){if(typeof data!=="string"){data=hexlify(data)}else if(!isHexString(data)||data.length%2){logger.throwArgumentError("invalid hexData","value",data)}offset=2+2*offset;if(endOffset!=null){return"0x"+data.substring(offset,2+2*endOffset)}return"0x"+data.substring(offset)}function hexConcat(items){let result="0x";items.forEach(item=>{result+=hexlify(item).substring(2)});return result}function hexValue(value){const trimmed=hexStripZeros(hexlify(value,{hexPad:"left"}));if(trimmed==="0x"){return"0x0"}return trimmed}function hexStripZeros(value){if(typeof value!=="string"){value=hexlify(value)}if(!isHexString(value)){logger.throwArgumentError("invalid hex string","value",value)}value=value.substring(2);let offset=0;while(offset<value.length&&value[offset]==="0"){offset++}return"0x"+value.substring(offset)}function hexZeroPad(value,length){if(typeof value!=="string"){value=hexlify(value)}else if(!isHexString(value)){logger.throwArgumentError("invalid hex string","value",value)}if(value.length>2*length+2){logger.throwArgumentError("value out of range","value",arguments[1])}while(value.length<2*length+2){value="0x0"+value.substring(2)}return value}function splitSignature(signature){const result={r:"0x",s:"0x",_vs:"0x",recoveryParam:0,v:0};if(isBytesLike(signature)){const bytes=arrayify(signature);if(bytes.length!==65){logger.throwArgumentError("invalid signature string; must be 65 bytes","signature",signature)}result.r=hexlify(bytes.slice(0,32));result.s=hexlify(bytes.slice(32,64));result.v=bytes[64];if(result.v<27){if(result.v===0||result.v===1){result.v+=27}else{logger.throwArgumentError("signature invalid v byte","signature",signature)}}result.recoveryParam=1-result.v%2;if(result.recoveryParam){bytes[32]|=128}result._vs=hexlify(bytes.slice(32,64))}else{result.r=signature.r;result.s=signature.s;result.v=signature.v;result.recoveryParam=signature.recoveryParam;result._vs=signature._vs;if(result._vs!=null){const vs=zeroPad(arrayify(result._vs),32);result._vs=hexlify(vs);const recoveryParam=vs[0]>=128?1:0;if(result.recoveryParam==null){result.recoveryParam=recoveryParam}else if(result.recoveryParam!==recoveryParam){logger.throwArgumentError("signature recoveryParam mismatch _vs","signature",signature)}vs[0]&=127;const s=hexlify(vs);if(result.s==null){result.s=s}else if(result.s!==s){logger.throwArgumentError("signature v mismatch _vs","signature",signature)}}if(result.recoveryParam==null){if(result.v==null){logger.throwArgumentError("signature missing v and recoveryParam","signature",signature)}else if(result.v===0||result.v===1){result.recoveryParam=result.v}else{result.recoveryParam=1-result.v%2}}else{if(result.v==null){result.v=27+result.recoveryParam}else if(result.recoveryParam!==1-result.v%2){logger.throwArgumentError("signature recoveryParam mismatch v","signature",signature)}}if(result.r==null||!isHexString(result.r)){logger.throwArgumentError("signature missing or invalid r","signature",signature)}else{result.r=hexZeroPad(result.r,32)}if(result.s==null||!isHexString(result.s)){logger.throwArgumentError("signature missing or invalid s","signature",signature)}else{result.s=hexZeroPad(result.s,32)}const vs=arrayify(result.s);if(vs[0]>=128){logger.throwArgumentError("signature s out of range","signature",signature)}if(result.recoveryParam){vs[0]|=128}const _vs=hexlify(vs);if(result._vs){if(!isHexString(result._vs)){logger.throwArgumentError("signature invalid _vs","signature",signature)}result._vs=hexZeroPad(result._vs,32)}if(result._vs==null){result._vs=_vs}else if(result._vs!==_vs){logger.throwArgumentError("signature _vs mismatch v and s","signature",signature)}}return result}function joinSignature(signature){signature=splitSignature(signature);return hexlify(concat([signature.r,signature.s,signature.recoveryParam?"0x1c":"0x1b"]))}const version$2="bignumber/5.1.1";"use strict";var BN=bn.BN;const logger$1=new Logger(version$2);const _constructorGuard={};const MAX_SAFE=9007199254740991;function isBigNumberish(value){return value!=null&&(BigNumber.isBigNumber(value)||typeof value==="number"&&value%1===0||typeof value==="string"&&!!value.match(/^-?[0-9]+$/)||isHexString(value)||typeof value==="bigint"||isBytes(value))}let _warnedToStringRadix=false;class BigNumber{constructor(constructorGuard,hex){logger$1.checkNew(new.target,BigNumber);if(constructorGuard!==_constructorGuard){logger$1.throwError("cannot call constructor directly; use BigNumber.from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new (BigNumber)"})}this._hex=hex;this._isBigNumber=true;Object.freeze(this)}fromTwos(value){return toBigNumber(toBN(this).fromTwos(value))}toTwos(value){return toBigNumber(toBN(this).toTwos(value))}abs(){if(this._hex[0]==="-"){return BigNumber.from(this._hex.substring(1))}return this}add(other){return toBigNumber(toBN(this).add(toBN(other)))}sub(other){return toBigNumber(toBN(this).sub(toBN(other)))}div(other){const o=BigNumber.from(other);if(o.isZero()){throwFault("division by zero","div")}return toBigNumber(toBN(this).div(toBN(other)))}mul(other){return toBigNumber(toBN(this).mul(toBN(other)))}mod(other){const value=toBN(other);if(value.isNeg()){throwFault("cannot modulo negative values","mod")}return toBigNumber(toBN(this).umod(value))}pow(other){const value=toBN(other);if(value.isNeg()){throwFault("cannot raise to negative values","pow")}return toBigNumber(toBN(this).pow(value))}and(other){const value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault("cannot 'and' negative values","and")}return toBigNumber(toBN(this).and(value))}or(other){const value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault("cannot 'or' negative values","or")}return toBigNumber(toBN(this).or(value))}xor(other){const value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault("cannot 'xor' negative values","xor")}return toBigNumber(toBN(this).xor(value))}mask(value){if(this.isNegative()||value<0){throwFault("cannot mask negative values","mask")}return toBigNumber(toBN(this).maskn(value))}shl(value){if(this.isNegative()||value<0){throwFault("cannot shift negative values","shl")}return toBigNumber(toBN(this).shln(value))}shr(value){if(this.isNegative()||value<0){throwFault("cannot shift negative values","shr")}return toBigNumber(toBN(this).shrn(value))}eq(other){return toBN(this).eq(toBN(other))}lt(other){return toBN(this).lt(toBN(other))}lte(other){return toBN(this).lte(toBN(other))}gt(other){return toBN(this).gt(toBN(other))}gte(other){return toBN(this).gte(toBN(other))}isNegative(){return this._hex[0]==="-"}isZero(){return toBN(this).isZero()}toNumber(){try{return toBN(this).toNumber()}catch(error){throwFault("overflow","toNumber",this.toString())}return null}toBigInt(){try{return BigInt(this.toString())}catch(e){}return logger$1.throwError("this platform does not support BigInt",Logger.errors.UNSUPPORTED_OPERATION,{value:this.toString()})}toString(){if(arguments.length>0){if(arguments[0]===10){if(!_warnedToStringRadix){_warnedToStringRadix=true;logger$1.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")}}else if(arguments[0]===16){logger$1.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",Logger.errors.UNEXPECTED_ARGUMENT,{})}else{logger$1.throwError("BigNumber.toString does not accept parameters",Logger.errors.UNEXPECTED_ARGUMENT,{})}}return toBN(this).toString(10)}toHexString(){return this._hex}toJSON(key){return{type:"BigNumber",hex:this.toHexString()}}static from(value){if(value instanceof BigNumber){return value}if(typeof value==="string"){if(value.match(/^-?0x[0-9a-f]+$/i)){return new BigNumber(_constructorGuard,toHex(value))}if(value.match(/^-?[0-9]+$/)){return new BigNumber(_constructorGuard,toHex(new BN(value)))}return logger$1.throwArgumentError("invalid BigNumber string","value",value)}if(typeof value==="number"){if(value%1){throwFault("underflow","BigNumber.from",value)}if(value>=MAX_SAFE||value<=-MAX_SAFE){throwFault("overflow","BigNumber.from",value)}return BigNumber.from(String(value))}const anyValue=value;if(typeof anyValue==="bigint"){return BigNumber.from(anyValue.toString())}if(isBytes(anyValue)){return BigNumber.from(hexlify(anyValue))}if(anyValue){if(anyValue.toHexString){const hex=anyValue.toHexString();if(typeof hex==="string"){return BigNumber.from(hex)}}else{let hex=anyValue._hex;if(hex==null&&anyValue.type==="BigNumber"){hex=anyValue.hex}if(typeof hex==="string"){if(isHexString(hex)||hex[0]==="-"&&isHexString(hex.substring(1))){return BigNumber.from(hex)}}}}return logger$1.throwArgumentError("invalid BigNumber value","value",value)}static isBigNumber(value){return!!(value&&value._isBigNumber)}}function toHex(value){if(typeof value!=="string"){return toHex(value.toString(16))}if(value[0]==="-"){value=value.substring(1);if(value[0]==="-"){logger$1.throwArgumentError("invalid hex","value",value)}value=toHex(value);if(value==="0x00"){return value}return"-"+value}if(value.substring(0,2)!=="0x"){value="0x"+value}if(value==="0x"){return"0x00"}if(value.length%2){value="0x0"+value.substring(2)}while(value.length>4&&value.substring(0,4)==="0x00"){value="0x"+value.substring(4)}return value}function toBigNumber(value){return BigNumber.from(toHex(value))}function toBN(value){const hex=BigNumber.from(value).toHexString();if(hex[0]==="-"){return new BN("-"+hex.substring(3),16)}return new BN(hex.substring(2),16)}function throwFault(fault,operation,value){const params={fault:fault,operation:operation};if(value!=null){params.value=value}return logger$1.throwError(fault,Logger.errors.NUMERIC_FAULT,params)}function _base36To16(value){return new BN(value,36).toString(16)}function _base16To36(value){return new BN(value,16).toString(36)}"use strict";const logger$2=new Logger(version$2);const _constructorGuard$1={};const Zero=BigNumber.from(0);const NegativeOne=BigNumber.from(-1);function throwFault$1(message,fault,operation,value){const params={fault:fault,operation:operation};if(value!==undefined){params.value=value}return logger$2.throwError(message,Logger.errors.NUMERIC_FAULT,params)}let zeros="0";while(zeros.length<256){zeros+=zeros}function getMultiplier(decimals){if(typeof decimals!=="number"){try{decimals=BigNumber.from(decimals).toNumber()}catch(e){}}if(typeof decimals==="number"&&decimals>=0&&decimals<=256&&!(decimals%1)){return"1"+zeros.substring(0,decimals)}return logger$2.throwArgumentError("invalid decimal size","decimals",decimals)}function formatFixed(value,decimals){if(decimals==null){decimals=0}const multiplier=getMultiplier(decimals);value=BigNumber.from(value);const negative=value.lt(Zero);if(negative){value=value.mul(NegativeOne)}let fraction=value.mod(multiplier).toString();while(fraction.length<multiplier.length-1){fraction="0"+fraction}fraction=fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];const whole=value.div(multiplier).toString();value=whole+"."+fraction;if(negative){value="-"+value}return value}function parseFixed(value,decimals){if(decimals==null){decimals=0}const multiplier=getMultiplier(decimals);if(typeof value!=="string"||!value.match(/^-?[0-9.,]+$/)){logger$2.throwArgumentError("invalid decimal value","value",value)}if(multiplier.length-1===0){return BigNumber.from(value)}const negative=value.substring(0,1)==="-";if(negative){value=value.substring(1)}if(value==="."){logger$2.throwArgumentError("missing value","value",value)}const comps=value.split(".");if(comps.length>2){logger$2.throwArgumentError("too many decimal points","value",value)}let whole=comps[0],fraction=comps[1];if(!whole){whole="0"}if(!fraction){fraction="0"}if(fraction.length>multiplier.length-1){throwFault$1("fractional component exceeds decimals","underflow","parseFixed")}while(fraction.length<multiplier.length-1){fraction+="0"}const wholeValue=BigNumber.from(whole);const fractionValue=BigNumber.from(fraction);let wei=wholeValue.mul(multiplier).add(fractionValue);if(negative){wei=wei.mul(NegativeOne)}return wei}class FixedFormat{constructor(constructorGuard,signed,width,decimals){if(constructorGuard!==_constructorGuard$1){logger$2.throwError("cannot use FixedFormat constructor; use FixedFormat.from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new FixedFormat"})}this.signed=signed;this.width=width;this.decimals=decimals;this.name=(signed?"":"u")+"fixed"+String(width)+"x"+String(decimals);this._multiplier=getMultiplier(decimals);Object.freeze(this)}static from(value){if(value instanceof FixedFormat){return value}let signed=true;let width=128;let decimals=18;if(typeof value==="string"){if(value==="fixed"){}else if(value==="ufixed"){signed=false}else if(value!=null){const match=value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);if(!match){logger$2.throwArgumentError("invalid fixed format","format",value)}signed=match[1]!=="u";width=parseInt(match[2]);decimals=parseInt(match[3])}}else if(value){const check=(key,type,defaultValue)=>{if(value[key]==null){return defaultValue}if(typeof value[key]!==type){logger$2.throwArgumentError("invalid fixed format ("+key+" not "+type+")","format."+key,value[key])}return value[key]};signed=check("signed","boolean",signed);width=check("width","number",width);decimals=check("decimals","number",decimals)}if(width%8){logger$2.throwArgumentError("invalid fixed format width (not byte aligned)","format.width",width)}if(decimals>80){logger$2.throwArgumentError("invalid fixed format (decimals too large)","format.decimals",decimals)}return new FixedFormat(_constructorGuard$1,signed,width,decimals)}}class FixedNumber{constructor(constructorGuard,hex,value,format){logger$2.checkNew(new.target,FixedNumber);if(constructorGuard!==_constructorGuard$1){logger$2.throwError("cannot use FixedNumber constructor; use FixedNumber.from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new FixedFormat"})}this.format=format;this._hex=hex;this._value=value;this._isFixedNumber=true;Object.freeze(this)}_checkFormat(other){if(this.format.name!==other.format.name){logger$2.throwArgumentError("incompatible format; use fixedNumber.toFormat","other",other)}}addUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.add(b),this.format.decimals,this.format)}subUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.sub(b),this.format.decimals,this.format)}mulUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier),this.format.decimals,this.format)}divUnsafe(other){this._checkFormat(other);const a=parseFixed(this._value,this.format.decimals);const b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b),this.format.decimals,this.format)}floor(){let comps=this.toString().split(".");let result=FixedNumber.from(comps[0],this.format);const hasFraction=!comps[1].match(/^(0*)$/);if(this.isNegative()&&hasFraction){result=result.subUnsafe(ONE)}return result}ceiling(){let comps=this.toString().split(".");let result=FixedNumber.from(comps[0],this.format);const hasFraction=!comps[1].match(/^(0*)$/);if(!this.isNegative()&&hasFraction){result=result.addUnsafe(ONE)}return result}round(decimals){if(decimals==null){decimals=0}let comps=this.toString().split(".");if(decimals<0||decimals>80||decimals%1){logger$2.throwArgumentError("invalid decimal count","decimals",decimals)}if(comps[1].length<=decimals){return this}const factor=FixedNumber.from("1"+zeros.substring(0,decimals));return this.mulUnsafe(factor).addUnsafe(BUMP).floor().divUnsafe(factor)}isZero(){return this._value==="0.0"}isNegative(){return this._value[0]==="-"}toString(){return this._value}toHexString(width){if(width==null){return this._hex}if(width%8){logger$2.throwArgumentError("invalid byte width","width",width)}const hex=BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();return hexZeroPad(hex,width/8)}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(format){return FixedNumber.fromString(this._value,format)}static fromValue(value,decimals,format){if(format==null&&decimals!=null&&!isBigNumberish(decimals)){format=decimals;decimals=null}if(decimals==null){decimals=0}if(format==null){format="fixed"}return FixedNumber.fromString(formatFixed(value,decimals),FixedFormat.from(format))}static fromString(value,format){if(format==null){format="fixed"}const fixedFormat=FixedFormat.from(format);const numeric=parseFixed(value,fixedFormat.decimals);if(!fixedFormat.signed&&numeric.lt(Zero)){throwFault$1("unsigned value cannot be negative","overflow","value",value)}let hex=null;if(fixedFormat.signed){hex=numeric.toTwos(fixedFormat.width).toHexString()}else{hex=numeric.toHexString();hex=hexZeroPad(hex,fixedFormat.width/8)}const decimal=formatFixed(numeric,fixedFormat.decimals);return new FixedNumber(_constructorGuard$1,hex,decimal,fixedFormat)}static fromBytes(value,format){if(format==null){format="fixed"}const fixedFormat=FixedFormat.from(format);if(arrayify(value).length>fixedFormat.width/8){throw new Error("overflow")}let numeric=BigNumber.from(value);if(fixedFormat.signed){numeric=numeric.fromTwos(fixedFormat.width)}const hex=numeric.toTwos((fixedFormat.signed?0:1)+fixedFormat.width).toHexString();const decimal=formatFixed(numeric,fixedFormat.decimals);return new FixedNumber(_constructorGuard$1,hex,decimal,fixedFormat)}static from(value,format){if(typeof value==="string"){return FixedNumber.fromString(value,format)}if(isBytes(value)){return FixedNumber.fromBytes(value,format)}try{return FixedNumber.fromValue(value,0,format)}catch(error){if(error.code!==Logger.errors.INVALID_ARGUMENT){throw error}}return logger$2.throwArgumentError("invalid FixedNumber value","value",value)}static isFixedNumber(value){return!!(value&&value._isFixedNumber)}}const ONE=FixedNumber.from(1);const BUMP=FixedNumber.from("0.5");const version$3="properties/5.1.0";"use strict";var __awaiter=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$3=new Logger(version$3);function defineReadOnly(object,name,value){Object.defineProperty(object,name,{enumerable:true,value:value,writable:false})}function getStatic(ctor,key){for(let i=0;i<32;i++){if(ctor[key]){return ctor[key]}if(!ctor.prototype||typeof ctor.prototype!=="object"){break}ctor=Object.getPrototypeOf(ctor.prototype).constructor}return null}function resolveProperties(object){return __awaiter(this,void 0,void 0,function*(){const promises=Object.keys(object).map(key=>{const value=object[key];return Promise.resolve(value).then(v=>({key:key,value:v}))});const results=yield Promise.all(promises);return results.reduce((accum,result)=>{accum[result.key]=result.value;return accum},{})})}function checkProperties(object,properties){if(!object||typeof object!=="object"){logger$3.throwArgumentError("invalid object","object",object)}Object.keys(object).forEach(key=>{if(!properties[key]){logger$3.throwArgumentError("invalid object key - "+key,"transaction:"+key,object)}})}function shallowCopy(object){const result={};for(const key in object){result[key]=object[key]}return result}const opaque={bigint:true,boolean:true,function:true,number:true,string:true};function _isFrozen(object){if(object===undefined||object===null||opaque[typeof object]){return true}if(Array.isArray(object)||typeof object==="object"){if(!Object.isFrozen(object)){return false}const keys=Object.keys(object);for(let i=0;i<keys.length;i++){if(!_isFrozen(object[keys[i]])){return false}}return true}return logger$3.throwArgumentError(`Cannot deepCopy ${typeof object}`,"object",object)}function _deepCopy(object){if(_isFrozen(object)){return object}if(Array.isArray(object)){return Object.freeze(object.map(item=>deepCopy(item)))}if(typeof object==="object"){const result={};for(const key in object){const value=object[key];if(value===undefined){continue}defineReadOnly(result,key,deepCopy(value))}return result}return logger$3.throwArgumentError(`Cannot deepCopy ${typeof object}`,"object",object)}function deepCopy(object){return _deepCopy(object)}class Description{constructor(info){for(const key in info){this[key]=deepCopy(info[key])}}}const version$4="abi/5.1.2";"use strict";const logger$4=new Logger(version$4);const _constructorGuard$2={};let ModifiersBytes={calldata:true,memory:true,storage:true};let ModifiersNest={calldata:true,memory:true};function checkModifier(type,name){if(type==="bytes"||type==="string"){if(ModifiersBytes[name]){return true}}else if(type==="address"){if(name==="payable"){return true}}else if(type.indexOf("[")>=0||type==="tuple"){if(ModifiersNest[name]){return true}}if(ModifiersBytes[name]||name==="payable"){logger$4.throwArgumentError("invalid modifier","name",name)}return false}function parseParamType(param,allowIndexed){let originalParam=param;function throwError(i){logger$4.throwArgumentError(`unexpected character at position ${i}`,"param",param)}param=param.replace(/\s/g," ");function newNode(parent){let node={type:"",name:"",parent:parent,state:{allowType:true}};if(allowIndexed){node.indexed=false}return node}let parent={type:"",name:"",state:{allowType:true}};let node=parent;for(let i=0;i<param.length;i++){let c=param[i];switch(c){case"(":if(node.state.allowType&&node.type===""){node.type="tuple"}else if(!node.state.allowParams){throwError(i)}node.state.allowType=false;node.type=verifyType(node.type);node.components=[newNode(node)];node=node.components[0];break;case")":delete node.state;if(node.name==="indexed"){if(!allowIndexed){throwError(i)}node.indexed=true;node.name=""}if(checkModifier(node.type,node.name)){node.name=""}node.type=verifyType(node.type);let child=node;node=node.parent;if(!node){throwError(i)}delete child.parent;node.state.allowParams=false;node.state.allowName=true;node.state.allowArray=true;break;case",":delete node.state;if(node.name==="indexed"){if(!allowIndexed){throwError(i)}node.indexed=true;node.name=""}if(checkModifier(node.type,node.name)){node.name=""}node.type=verifyType(node.type);let sibling=newNode(node.parent);node.parent.components.push(sibling);delete node.parent;node=sibling;break;case" ":if(node.state.allowType){if(node.type!==""){node.type=verifyType(node.type);delete node.state.allowType;node.state.allowName=true;node.state.allowParams=true}}if(node.state.allowName){if(node.name!==""){if(node.name==="indexed"){if(!allowIndexed){throwError(i)}if(node.indexed){throwError(i)}node.indexed=true;node.name=""}else if(checkModifier(node.type,node.name)){node.name=""}else{node.state.allowName=false}}}break;case"[":if(!node.state.allowArray){throwError(i)}node.type+=c;node.state.allowArray=false;node.state.allowName=false;node.state.readArray=true;break;case"]":if(!node.state.readArray){throwError(i)}node.type+=c;node.state.readArray=false;node.state.allowArray=true;node.state.allowName=true;break;default:if(node.state.allowType){node.type+=c;node.state.allowParams=true;node.state.allowArray=true}else if(node.state.allowName){node.name+=c;delete node.state.allowArray}else if(node.state.readArray){node.type+=c}else{throwError(i)}}}if(node.parent){logger$4.throwArgumentError("unexpected eof","param",param)}delete parent.state;if(node.name==="indexed"){if(!allowIndexed){throwError(originalParam.length-7)}if(node.indexed){throwError(originalParam.length-7)}node.indexed=true;node.name=""}else if(checkModifier(node.type,node.name)){node.name=""}parent.type=verifyType(parent.type);return parent}function populate(object,params){for(let key in params){defineReadOnly(object,key,params[key])}}const FormatTypes=Object.freeze({sighash:"sighash",minimal:"minimal",full:"full",json:"json"});const paramTypeArray=new RegExp(/^(.*)\[([0-9]*)\]$/);class ParamType{constructor(constructorGuard,params){if(constructorGuard!==_constructorGuard$2){logger$4.throwError("use fromString",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new ParamType()"})}populate(this,params);let match=this.type.match(paramTypeArray);if(match){populate(this,{arrayLength:parseInt(match[2]||"-1"),arrayChildren:ParamType.fromObject({type:match[1],components:this.components}),baseType:"array"})}else{populate(this,{arrayLength:null,arrayChildren:null,baseType:this.components!=null?"tuple":this.type})}this._isParamType=true;Object.freeze(this)}format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){let result={type:this.baseType==="tuple"?"tuple":this.type,name:this.name||undefined};if(typeof this.indexed==="boolean"){result.indexed=this.indexed}if(this.components){result.components=this.components.map(comp=>JSON.parse(comp.format(format)))}return JSON.stringify(result)}let result="";if(this.baseType==="array"){result+=this.arrayChildren.format(format);result+="["+(this.arrayLength<0?"":String(this.arrayLength))+"]"}else{if(this.baseType==="tuple"){if(format!==FormatTypes.sighash){result+=this.type}result+="("+this.components.map(comp=>comp.format(format)).join(format===FormatTypes.full?", ":",")+")"}else{result+=this.type}}if(format!==FormatTypes.sighash){if(this.indexed===true){result+=" indexed"}if(format===FormatTypes.full&&this.name){result+=" "+this.name}}return result}static from(value,allowIndexed){if(typeof value==="string"){return ParamType.fromString(value,allowIndexed)}return ParamType.fromObject(value)}static fromObject(value){if(ParamType.isParamType(value)){return value}return new ParamType(_constructorGuard$2,{name:value.name||null,type:verifyType(value.type),indexed:value.indexed==null?null:!!value.indexed,components:value.components?value.components.map(ParamType.fromObject):null})}static fromString(value,allowIndexed){function ParamTypify(node){return ParamType.fromObject({name:node.name,type:node.type,indexed:node.indexed,components:node.components})}return ParamTypify(parseParamType(value,!!allowIndexed))}static isParamType(value){return!!(value!=null&&value._isParamType)}}function parseParams(value,allowIndex){return splitNesting(value).map(param=>ParamType.fromString(param,allowIndex))}class Fragment{constructor(constructorGuard,params){if(constructorGuard!==_constructorGuard$2){logger$4.throwError("use a static from method",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new Fragment()"})}populate(this,params);this._isFragment=true;Object.freeze(this)}static from(value){if(Fragment.isFragment(value)){return value}if(typeof value==="string"){return Fragment.fromString(value)}return Fragment.fromObject(value)}static fromObject(value){if(Fragment.isFragment(value)){return value}switch(value.type){case"function":return FunctionFragment.fromObject(value);case"event":return EventFragment.fromObject(value);case"constructor":return ConstructorFragment.fromObject(value);case"error":case"fallback":case"receive":return null}return logger$4.throwArgumentError("invalid fragment object","value",value)}static fromString(value){value=value.replace(/\s/g," ");value=value.replace(/\(/g," (").replace(/\)/g,") ").replace(/\s+/g," ");value=value.trim();if(value.split(" ")[0]==="event"){return EventFragment.fromString(value.substring(5).trim())}else if(value.split(" ")[0]==="function"){return FunctionFragment.fromString(value.substring(8).trim())}else if(value.split("(")[0].trim()==="constructor"){return ConstructorFragment.fromString(value.trim())}return logger$4.throwArgumentError("unsupported fragment","value",value)}static isFragment(value){return!!(value&&value._isFragment)}}class EventFragment extends Fragment{format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){return JSON.stringify({type:"event",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}let result="";if(format!==FormatTypes.sighash){result+="event "}result+=this.name+"("+this.inputs.map(input=>input.format(format)).join(format===FormatTypes.full?", ":",")+") ";if(format!==FormatTypes.sighash){if(this.anonymous){result+="anonymous "}}return result.trim()}static from(value){if(typeof value==="string"){return EventFragment.fromString(value)}return EventFragment.fromObject(value)}static fromObject(value){if(EventFragment.isEventFragment(value)){return value}if(value.type!=="event"){logger$4.throwArgumentError("invalid event object","value",value)}const params={name:verifyIdentifier(value.name),anonymous:value.anonymous,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],type:"event"};return new EventFragment(_constructorGuard$2,params)}static fromString(value){let match=value.match(regexParen);if(!match){logger$4.throwArgumentError("invalid event string","value",value)}let anonymous=false;match[3].split(" ").forEach(modifier=>{switch(modifier.trim()){case"anonymous":anonymous=true;break;case"":break;default:logger$4.warn("unknown modifier: "+modifier)}});return EventFragment.fromObject({name:match[1].trim(),anonymous:anonymous,inputs:parseParams(match[2],true),type:"event"})}static isEventFragment(value){return value&&value._isFragment&&value.type==="event"}}function parseGas(value,params){params.gas=null;let comps=value.split("@");if(comps.length!==1){if(comps.length>2){logger$4.throwArgumentError("invalid human-readable ABI signature","value",value)}if(!comps[1].match(/^[0-9]+$/)){logger$4.throwArgumentError("invalid human-readable ABI signature gas","value",value)}params.gas=BigNumber.from(comps[1]);return comps[0]}return value}function parseModifiers(value,params){params.constant=false;params.payable=false;params.stateMutability="nonpayable";value.split(" ").forEach(modifier=>{switch(modifier.trim()){case"constant":params.constant=true;break;case"payable":params.payable=true;params.stateMutability="payable";break;case"nonpayable":params.payable=false;params.stateMutability="nonpayable";break;case"pure":params.constant=true;params.stateMutability="pure";break;case"view":params.constant=true;params.stateMutability="view";break;case"external":case"public":case"":break;default:console.log("unknown modifier: "+modifier)}})}function verifyState(value){let result={constant:false,payable:true,stateMutability:"payable"};if(value.stateMutability!=null){result.stateMutability=value.stateMutability;result.constant=result.stateMutability==="view"||result.stateMutability==="pure";if(value.constant!=null){if(!!value.constant!==result.constant){logger$4.throwArgumentError("cannot have constant function with mutability "+result.stateMutability,"value",value)}}result.payable=result.stateMutability==="payable";if(value.payable!=null){if(!!value.payable!==result.payable){logger$4.throwArgumentError("cannot have payable function with mutability "+result.stateMutability,"value",value)}}}else if(value.payable!=null){result.payable=!!value.payable;if(value.constant==null&&!result.payable&&value.type!=="constructor"){logger$4.throwArgumentError("unable to determine stateMutability","value",value)}result.constant=!!value.constant;if(result.constant){result.stateMutability="view"}else{result.stateMutability=result.payable?"payable":"nonpayable"}if(result.payable&&result.constant){logger$4.throwArgumentError("cannot have constant payable function","value",value)}}else if(value.constant!=null){result.constant=!!value.constant;result.payable=!result.constant;result.stateMutability=result.constant?"view":"payable"}else if(value.type!=="constructor"){logger$4.throwArgumentError("unable to determine stateMutability","value",value)}return result}class ConstructorFragment extends Fragment{format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){return JSON.stringify({type:"constructor",stateMutability:this.stateMutability!=="nonpayable"?this.stateMutability:undefined,payable:this.payable,gas:this.gas?this.gas.toNumber():undefined,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}if(format===FormatTypes.sighash){logger$4.throwError("cannot format a constructor for sighash",Logger.errors.UNSUPPORTED_OPERATION,{operation:"format(sighash)"})}let result="constructor("+this.inputs.map(input=>input.format(format)).join(format===FormatTypes.full?", ":",")+") ";if(this.stateMutability&&this.stateMutability!=="nonpayable"){result+=this.stateMutability+" "}return result.trim()}static from(value){if(typeof value==="string"){return ConstructorFragment.fromString(value)}return ConstructorFragment.fromObject(value)}static fromObject(value){if(ConstructorFragment.isConstructorFragment(value)){return value}if(value.type!=="constructor"){logger$4.throwArgumentError("invalid constructor object","value",value)}let state=verifyState(value);if(state.constant){logger$4.throwArgumentError("constructor cannot be constant","value",value)}const params={name:null,type:value.type,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],payable:state.payable,stateMutability:state.stateMutability,gas:value.gas?BigNumber.from(value.gas):null};return new ConstructorFragment(_constructorGuard$2,params)}static fromString(value){let params={type:"constructor"};value=parseGas(value,params);let parens=value.match(regexParen);if(!parens||parens[1].trim()!=="constructor"){logger$4.throwArgumentError("invalid constructor string","value",value)}params.inputs=parseParams(parens[2].trim(),false);parseModifiers(parens[3].trim(),params);return ConstructorFragment.fromObject(params)}static isConstructorFragment(value){return value&&value._isFragment&&value.type==="constructor"}}class FunctionFragment extends ConstructorFragment{format(format){if(!format){format=FormatTypes.sighash}if(!FormatTypes[format]){logger$4.throwArgumentError("invalid format type","format",format)}if(format===FormatTypes.json){return JSON.stringify({type:"function",name:this.name,constant:this.constant,stateMutability:this.stateMutability!=="nonpayable"?this.stateMutability:undefined,payable:this.payable,gas:this.gas?this.gas.toNumber():undefined,inputs:this.inputs.map(input=>JSON.parse(input.format(format))),outputs:this.outputs.map(output=>JSON.parse(output.format(format)))})}let result="";if(format!==FormatTypes.sighash){result+="function "}result+=this.name+"("+this.inputs.map(input=>input.format(format)).join(format===FormatTypes.full?", ":",")+") ";if(format!==FormatTypes.sighash){if(this.stateMutability){if(this.stateMutability!=="nonpayable"){result+=this.stateMutability+" "}}else if(this.constant){result+="view "}if(this.outputs&&this.outputs.length){result+="returns ("+this.outputs.map(output=>output.format(format)).join(", ")+") "}if(this.gas!=null){result+="@"+this.gas.toString()+" "}}return result.trim()}static from(value){if(typeof value==="string"){return FunctionFragment.fromString(value)}return FunctionFragment.fromObject(value)}static fromObject(value){if(FunctionFragment.isFunctionFragment(value)){return value}if(value.type!=="function"){logger$4.throwArgumentError("invalid function object","value",value)}let state=verifyState(value);const params={type:value.type,name:verifyIdentifier(value.name),constant:state.constant,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],outputs:value.outputs?value.outputs.map(ParamType.fromObject):[],payable:state.payable,stateMutability:state.stateMutability,gas:value.gas?BigNumber.from(value.gas):null};return new FunctionFragment(_constructorGuard$2,params)}static fromString(value){let params={type:"function"};value=parseGas(value,params);let comps=value.split(" returns ");if(comps.length>2){logger$4.throwArgumentError("invalid function string","value",value)}let parens=comps[0].match(regexParen);if(!parens){logger$4.throwArgumentError("invalid function signature","value",value)}params.name=parens[1].trim();if(params.name){verifyIdentifier(params.name)}params.inputs=parseParams(parens[2],false);parseModifiers(parens[3].trim(),params);if(comps.length>1){let returns=comps[1].match(regexParen);if(returns[1].trim()!=""||returns[3].trim()!=""){logger$4.throwArgumentError("unexpected tokens","value",value)}params.outputs=parseParams(returns[2],false)}else{params.outputs=[]}return FunctionFragment.fromObject(params)}static isFunctionFragment(value){return value&&value._isFragment&&value.type==="function"}}function verifyType(type){if(type.match(/^uint($|[^1-9])/)){type="uint256"+type.substring(4)}else if(type.match(/^int($|[^1-9])/)){type="int256"+type.substring(3)}return type}const regexIdentifier=new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");function verifyIdentifier(value){if(!value||!value.match(regexIdentifier)){logger$4.throwArgumentError(`invalid identifier "${value}"`,"value",value)}return value}const regexParen=new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");function splitNesting(value){value=value.trim();let result=[];let accum="";let depth=0;for(let offset=0;offset<value.length;offset++){let c=value[offset];if(c===","&&depth===0){result.push(accum);accum=""}else{accum+=c;if(c==="("){depth++}else if(c===")"){depth--;if(depth===-1){logger$4.throwArgumentError("unbalanced parenthesis","value",value)}}}}if(accum){result.push(accum)}return result}"use strict";const logger$5=new Logger(version$4);function checkResultErrors(result){const errors=[];const checkErrors=function(path,object){if(!Array.isArray(object)){return}for(let key in object){const childPath=path.slice();childPath.push(key);try{checkErrors(childPath,object[key])}catch(error){errors.push({path:childPath,error:error})}}};checkErrors([],result);return errors}class Coder{constructor(name,type,localName,dynamic){this.name=name;this.type=type;this.localName=localName;this.dynamic=dynamic}_throwError(message,value){logger$5.throwArgumentError(message,this.localName,value)}}class Writer{constructor(wordSize){defineReadOnly(this,"wordSize",wordSize||32);this._data=[];this._dataLength=0;this._padding=new Uint8Array(wordSize)}get data(){return hexConcat(this._data)}get length(){return this._dataLength}_writeData(data){this._data.push(data);this._dataLength+=data.length;return data.length}appendWriter(writer){return this._writeData(concat(writer._data))}writeBytes(value){let bytes=arrayify(value);const paddingOffset=bytes.length%this.wordSize;if(paddingOffset){bytes=concat([bytes,this._padding.slice(paddingOffset)])}return this._writeData(bytes)}_getValue(value){let bytes=arrayify(BigNumber.from(value));if(bytes.length>this.wordSize){logger$5.throwError("value out-of-bounds",Logger.errors.BUFFER_OVERRUN,{length:this.wordSize,offset:bytes.length})}if(bytes.length%this.wordSize){bytes=concat([this._padding.slice(bytes.length%this.wordSize),bytes])}return bytes}writeValue(value){return this._writeData(this._getValue(value))}writeUpdatableValue(){const offset=this._data.length;this._data.push(this._padding);this._dataLength+=this.wordSize;return value=>{this._data[offset]=this._getValue(value)}}}class Reader{constructor(data,wordSize,coerceFunc,allowLoose){defineReadOnly(this,"_data",arrayify(data));defineReadOnly(this,"wordSize",wordSize||32);defineReadOnly(this,"_coerceFunc",coerceFunc);defineReadOnly(this,"allowLoose",allowLoose);this._offset=0}get data(){return hexlify(this._data)}get consumed(){return this._offset}static coerce(name,value){let match=name.match("^u?int([0-9]+)$");if(match&&parseInt(match[1])<=48){value=value.toNumber()}return value}coerce(name,value){if(this._coerceFunc){return this._coerceFunc(name,value)}return Reader.coerce(name,value)}_peekBytes(offset,length,loose){let alignedLength=Math.ceil(length/this.wordSize)*this.wordSize;if(this._offset+alignedLength>this._data.length){if(this.allowLoose&&loose&&this._offset+length<=this._data.length){alignedLength=length}else{logger$5.throwError("data out-of-bounds",Logger.errors.BUFFER_OVERRUN,{length:this._data.length,offset:this._offset+alignedLength})}}return this._data.slice(this._offset,this._offset+alignedLength)}subReader(offset){return new Reader(this._data.slice(this._offset+offset),this.wordSize,this._coerceFunc,this.allowLoose)}readBytes(length,loose){let bytes=this._peekBytes(0,length,!!loose);this._offset+=bytes.length;return bytes.slice(0,length)}readValue(){return BigNumber.from(this.readBytes(this.wordSize))}}var sha3=createCommonjsModule(function(module){(function(){"use strict";var root=typeof window==="object"?window:{};var NODE_JS=!root.JS_SHA3_NO_NODE_JS&&typeof process==="object"&&process.versions&&process.versions.node;if(NODE_JS){root=commonjsGlobal}var COMMON_JS=!root.JS_SHA3_NO_COMMON_JS&&"object"==="object"&&module.exports;var HEX_CHARS="0123456789abcdef".split("");var SHAKE_PADDING=[31,7936,2031616,520093696];var KECCAK_PADDING=[1,256,65536,16777216];var PADDING=[6,1536,393216,100663296];var SHIFT=[0,8,16,24];var RC=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648];var BITS=[224,256,384,512];var SHAKE_BITS=[128,256];var OUTPUT_TYPES=["hex","buffer","arrayBuffer","array"];var createOutputMethod=function(bits,padding,outputType){return function(message){return new Keccak(bits,padding,bits).update(message)[outputType]()}};var createShakeOutputMethod=function(bits,padding,outputType){return function(message,outputBits){return new Keccak(bits,padding,outputBits).update(message)[outputType]()}};var createMethod=function(bits,padding){var method=createOutputMethod(bits,padding,"hex");method.create=function(){return new Keccak(bits,padding,bits)};method.update=function(message){return method.create().update(message)};for(var i=0;i<OUTPUT_TYPES.length;++i){var type=OUTPUT_TYPES[i];method[type]=createOutputMethod(bits,padding,type)}return method};var createShakeMethod=function(bits,padding){var method=createShakeOutputMethod(bits,padding,"hex");method.create=function(outputBits){return new Keccak(bits,padding,outputBits)};method.update=function(message,outputBits){return method.create(outputBits).update(message)};for(var i=0;i<OUTPUT_TYPES.length;++i){var type=OUTPUT_TYPES[i];method[type]=createShakeOutputMethod(bits,padding,type)}return method};var algorithms=[{name:"keccak",padding:KECCAK_PADDING,bits:BITS,createMethod:createMethod},{name:"sha3",padding:PADDING,bits:BITS,createMethod:createMethod},{name:"shake",padding:SHAKE_PADDING,bits:SHAKE_BITS,createMethod:createShakeMethod}];var methods={},methodNames=[];for(var i=0;i<algorithms.length;++i){var algorithm=algorithms[i];var bits=algorithm.bits;for(var j=0;j<bits.length;++j){var methodName=algorithm.name+"_"+bits[j];methodNames.push(methodName);methods[methodName]=algorithm.createMethod(bits[j],algorithm.padding)}}function Keccak(bits,padding,outputBits){this.blocks=[];this.s=[];this.padding=padding;this.outputBits=outputBits;this.reset=true;this.block=0;this.start=0;this.blockCount=1600-(bits<<1)>>5;this.byteCount=this.blockCount<<2;this.outputBlocks=outputBits>>5;this.extraBytes=(outputBits&31)>>3;for(var i=0;i<50;++i){this.s[i]=0}}Keccak.prototype.update=function(message){var notString=typeof message!=="string";if(notString&&message.constructor===ArrayBuffer){message=new Uint8Array(message)}var length=message.length,blocks=this.blocks,byteCount=this.byteCount,blockCount=this.blockCount,index=0,s=this.s,i,code;while(index<length){if(this.reset){this.reset=false;blocks[0]=this.block;for(i=1;i<blockCount+1;++i){blocks[i]=0}}if(notString){for(i=this.start;index<length&&i<byteCount;++index){blocks[i>>2]|=message[index]<<SHIFT[i++&3]}}else{for(i=this.start;index<length&&i<byteCount;++index){code=message.charCodeAt(index);if(code<128){blocks[i>>2]|=code<<SHIFT[i++&3]}else if(code<2048){blocks[i>>2]|=(192|code>>6)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}else if(code<55296||code>=57344){blocks[i>>2]|=(224|code>>12)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>6&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}else{code=65536+((code&1023)<<10|message.charCodeAt(++index)&1023);blocks[i>>2]|=(240|code>>18)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>12&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>6&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}}}this.lastByteIndex=i;if(i>=byteCount){this.start=i-byteCount;this.block=blocks[blockCount];for(i=0;i<blockCount;++i){s[i]^=blocks[i]}f(s);this.reset=true}else{this.start=i}}return this};Keccak.prototype.finalize=function(){var blocks=this.blocks,i=this.lastByteIndex,blockCount=this.blockCount,s=this.s;blocks[i>>2]|=this.padding[i&3];if(this.lastByteIndex===this.byteCount){blocks[0]=blocks[blockCount];for(i=1;i<blockCount+1;++i){blocks[i]=0}}blocks[blockCount-1]|=2147483648;for(i=0;i<blockCount;++i){s[i]^=blocks[i]}f(s)};Keccak.prototype.toString=Keccak.prototype.hex=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var hex="",block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){block=s[i];hex+=HEX_CHARS[block>>4&15]+HEX_CHARS[block&15]+HEX_CHARS[block>>12&15]+HEX_CHARS[block>>8&15]+HEX_CHARS[block>>20&15]+HEX_CHARS[block>>16&15]+HEX_CHARS[block>>28&15]+HEX_CHARS[block>>24&15]}if(j%blockCount===0){f(s);i=0}}if(extraBytes){block=s[i];if(extraBytes>0){hex+=HEX_CHARS[block>>4&15]+HEX_CHARS[block&15]}if(extraBytes>1){hex+=HEX_CHARS[block>>12&15]+HEX_CHARS[block>>8&15]}if(extraBytes>2){hex+=HEX_CHARS[block>>20&15]+HEX_CHARS[block>>16&15]}}return hex};Keccak.prototype.arrayBuffer=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var bytes=this.outputBits>>3;var buffer;if(extraBytes){buffer=new ArrayBuffer(outputBlocks+1<<2)}else{buffer=new ArrayBuffer(bytes)}var array=new Uint32Array(buffer);while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){array[j]=s[i]}if(j%blockCount===0){f(s)}}if(extraBytes){array[i]=s[i];buffer=buffer.slice(0,bytes)}return buffer};Keccak.prototype.buffer=Keccak.prototype.arrayBuffer;Keccak.prototype.digest=Keccak.prototype.array=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var array=[],offset,block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){offset=j<<2;block=s[i];array[offset]=block&255;array[offset+1]=block>>8&255;array[offset+2]=block>>16&255;array[offset+3]=block>>24&255}if(j%blockCount===0){f(s)}}if(extraBytes){offset=j<<2;block=s[i];if(extraBytes>0){array[offset]=block&255}if(extraBytes>1){array[offset+1]=block>>8&255}if(extraBytes>2){array[offset+2]=block>>16&255}}return array};var f=function(s){var h,l,n,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31,b32,b33,b34,b35,b36,b37,b38,b39,b40,b41,b42,b43,b44,b45,b46,b47,b48,b49;for(n=0;n<48;n+=2){c0=s[0]^s[10]^s[20]^s[30]^s[40];c1=s[1]^s[11]^s[21]^s[31]^s[41];c2=s[2]^s[12]^s[22]^s[32]^s[42];c3=s[3]^s[13]^s[23]^s[33]^s[43];c4=s[4]^s[14]^s[24]^s[34]^s[44];c5=s[5]^s[15]^s[25]^s[35]^s[45];c6=s[6]^s[16]^s[26]^s[36]^s[46];c7=s[7]^s[17]^s[27]^s[37]^s[47];c8=s[8]^s[18]^s[28]^s[38]^s[48];c9=s[9]^s[19]^s[29]^s[39]^s[49];h=c8^(c2<<1|c3>>>31);l=c9^(c3<<1|c2>>>31);s[0]^=h;s[1]^=l;s[10]^=h;s[11]^=l;s[20]^=h;s[21]^=l;s[30]^=h;s[31]^=l;s[40]^=h;s[41]^=l;h=c0^(c4<<1|c5>>>31);l=c1^(c5<<1|c4>>>31);s[2]^=h;s[3]^=l;s[12]^=h;s[13]^=l;s[22]^=h;s[23]^=l;s[32]^=h;s[33]^=l;s[42]^=h;s[43]^=l;h=c2^(c6<<1|c7>>>31);l=c3^(c7<<1|c6>>>31);s[4]^=h;s[5]^=l;s[14]^=h;s[15]^=l;s[24]^=h;s[25]^=l;s[34]^=h;s[35]^=l;s[44]^=h;s[45]^=l;h=c4^(c8<<1|c9>>>31);l=c5^(c9<<1|c8>>>31);s[6]^=h;s[7]^=l;s[16]^=h;s[17]^=l;s[26]^=h;s[27]^=l;s[36]^=h;s[37]^=l;s[46]^=h;s[47]^=l;h=c6^(c0<<1|c1>>>31);l=c7^(c1<<1|c0>>>31);s[8]^=h;s[9]^=l;s[18]^=h;s[19]^=l;s[28]^=h;s[29]^=l;s[38]^=h;s[39]^=l;s[48]^=h;s[49]^=l;b0=s[0];b1=s[1];b32=s[11]<<4|s[10]>>>28;b33=s[10]<<4|s[11]>>>28;b14=s[20]<<3|s[21]>>>29;b15=s[21]<<3|s[20]>>>29;b46=s[31]<<9|s[30]>>>23;b47=s[30]<<9|s[31]>>>23;b28=s[40]<<18|s[41]>>>14;b29=s[41]<<18|s[40]>>>14;b20=s[2]<<1|s[3]>>>31;b21=s[3]<<1|s[2]>>>31;b2=s[13]<<12|s[12]>>>20;b3=s[12]<<12|s[13]>>>20;b34=s[22]<<10|s[23]>>>22;b35=s[23]<<10|s[22]>>>22;b16=s[33]<<13|s[32]>>>19;b17=s[32]<<13|s[33]>>>19;b48=s[42]<<2|s[43]>>>30;b49=s[43]<<2|s[42]>>>30;b40=s[5]<<30|s[4]>>>2;b41=s[4]<<30|s[5]>>>2;b22=s[14]<<6|s[15]>>>26;b23=s[15]<<6|s[14]>>>26;b4=s[25]<<11|s[24]>>>21;b5=s[24]<<11|s[25]>>>21;b36=s[34]<<15|s[35]>>>17;b37=s[35]<<15|s[34]>>>17;b18=s[45]<<29|s[44]>>>3;b19=s[44]<<29|s[45]>>>3;b10=s[6]<<28|s[7]>>>4;b11=s[7]<<28|s[6]>>>4;b42=s[17]<<23|s[16]>>>9;b43=s[16]<<23|s[17]>>>9;b24=s[26]<<25|s[27]>>>7;b25=s[27]<<25|s[26]>>>7;b6=s[36]<<21|s[37]>>>11;b7=s[37]<<21|s[36]>>>11;b38=s[47]<<24|s[46]>>>8;b39=s[46]<<24|s[47]>>>8;b30=s[8]<<27|s[9]>>>5;b31=s[9]<<27|s[8]>>>5;b12=s[18]<<20|s[19]>>>12;b13=s[19]<<20|s[18]>>>12;b44=s[29]<<7|s[28]>>>25;b45=s[28]<<7|s[29]>>>25;b26=s[38]<<8|s[39]>>>24;b27=s[39]<<8|s[38]>>>24;b8=s[48]<<14|s[49]>>>18;b9=s[49]<<14|s[48]>>>18;s[0]=b0^~b2&b4;s[1]=b1^~b3&b5;s[10]=b10^~b12&b14;s[11]=b11^~b13&b15;s[20]=b20^~b22&b24;s[21]=b21^~b23&b25;s[30]=b30^~b32&b34;s[31]=b31^~b33&b35;s[40]=b40^~b42&b44;s[41]=b41^~b43&b45;s[2]=b2^~b4&b6;s[3]=b3^~b5&b7;s[12]=b12^~b14&b16;s[13]=b13^~b15&b17;s[22]=b22^~b24&b26;s[23]=b23^~b25&b27;s[32]=b32^~b34&b36;s[33]=b33^~b35&b37;s[42]=b42^~b44&b46;s[43]=b43^~b45&b47;s[4]=b4^~b6&b8;s[5]=b5^~b7&b9;s[14]=b14^~b16&b18;s[15]=b15^~b17&b19;s[24]=b24^~b26&b28;s[25]=b25^~b27&b29;s[34]=b34^~b36&b38;s[35]=b35^~b37&b39;s[44]=b44^~b46&b48;s[45]=b45^~b47&b49;s[6]=b6^~b8&b0;s[7]=b7^~b9&b1;s[16]=b16^~b18&b10;s[17]=b17^~b19&b11;s[26]=b26^~b28&b20;s[27]=b27^~b29&b21;s[36]=b36^~b38&b30;s[37]=b37^~b39&b31;s[46]=b46^~b48&b40;s[47]=b47^~b49&b41;s[8]=b8^~b0&b2;s[9]=b9^~b1&b3;s[18]=b18^~b10&b12;s[19]=b19^~b11&b13;s[28]=b28^~b20&b22;s[29]=b29^~b21&b23;s[38]=b38^~b30&b32;s[39]=b39^~b31&b33;s[48]=b48^~b40&b42;s[49]=b49^~b41&b43;s[0]^=RC[n];s[1]^=RC[n+1]}};if(COMMON_JS){module.exports=methods}else{for(var i=0;i<methodNames.length;++i){root[methodNames[i]]=methods[methodNames[i]]}}})()});"use strict";function keccak256(data){return"0x"+sha3.keccak_256(arrayify(data))}const version$5="rlp/5.1.0";"use strict";const logger$6=new Logger(version$5);function arrayifyInteger(value){const result=[];while(value){result.unshift(value&255);value>>=8}return result}function unarrayifyInteger(data,offset,length){let result=0;for(let i=0;i<length;i++){result=result*256+data[offset+i]}return result}function _encode(object){if(Array.isArray(object)){let payload=[];object.forEach(function(child){payload=payload.concat(_encode(child))});if(payload.length<=55){payload.unshift(192+payload.length);return payload}const length=arrayifyInteger(payload.length);length.unshift(247+length.length);return length.concat(payload)}if(!isBytesLike(object)){logger$6.throwArgumentError("RLP object must be BytesLike","object",object)}const data=Array.prototype.slice.call(arrayify(object));if(data.length===1&&data[0]<=127){return data}else if(data.length<=55){data.unshift(128+data.length);return data}const length=arrayifyInteger(data.length);length.unshift(183+length.length);return length.concat(data)}function encode(object){return hexlify(_encode(object))}function _decodeChildren(data,offset,childOffset,length){const result=[];while(childOffset<offset+1+length){const decoded=_decode(data,childOffset);result.push(decoded.result);childOffset+=decoded.consumed;if(childOffset>offset+1+length){logger$6.throwError("child data too short",Logger.errors.BUFFER_OVERRUN,{})}}return{consumed:1+length,result:result}}function _decode(data,offset){if(data.length===0){logger$6.throwError("data too short",Logger.errors.BUFFER_OVERRUN,{})}if(data[offset]>=248){const lengthLength=data[offset]-247;if(offset+1+lengthLength>data.length){logger$6.throwError("data short segment too short",Logger.errors.BUFFER_OVERRUN,{})}const length=unarrayifyInteger(data,offset+1,lengthLength);if(offset+1+lengthLength+length>data.length){logger$6.throwError("data long segment too short",Logger.errors.BUFFER_OVERRUN,{})}return _decodeChildren(data,offset,offset+1+lengthLength,lengthLength+length)}else if(data[offset]>=192){const length=data[offset]-192;if(offset+1+length>data.length){logger$6.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{})}return _decodeChildren(data,offset,offset+1,length)}else if(data[offset]>=184){const lengthLength=data[offset]-183;if(offset+1+lengthLength>data.length){logger$6.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{})}const length=unarrayifyInteger(data,offset+1,lengthLength);if(offset+1+lengthLength+length>data.length){logger$6.throwError("data array too short",Logger.errors.BUFFER_OVERRUN,{})}const result=hexlify(data.slice(offset+1+lengthLength,offset+1+lengthLength+length));return{consumed:1+lengthLength+length,result:result}}else if(data[offset]>=128){const length=data[offset]-128;if(offset+1+length>data.length){logger$6.throwError("data too short",Logger.errors.BUFFER_OVERRUN,{})}const result=hexlify(data.slice(offset+1,offset+1+length));return{consumed:1+length,result:result}}return{consumed:1,result:hexlify(data[offset])}}function decode(data){const bytes=arrayify(data);const decoded=_decode(bytes,0);if(decoded.consumed!==bytes.length){logger$6.throwArgumentError("invalid rlp data","data",data)}return decoded.result}var index=Object.freeze({__proto__:null,encode:encode,decode:decode});const version$6="address/5.1.0";"use strict";const logger$7=new Logger(version$6);function getChecksumAddress(address){if(!isHexString(address,20)){logger$7.throwArgumentError("invalid address","address",address)}address=address.toLowerCase();const chars=address.substring(2).split("");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=arrayify(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return"0x"+chars.join("")}const MAX_SAFE_INTEGER=9007199254740991;function log10(x){if(Math.log10){return Math.log10(x)}return Math.log(x)/Math.LN10}const ibanLookup={};for(let i=0;i<10;i++){ibanLookup[String(i)]=String(i)}for(let i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i)}const safeDigits=Math.floor(log10(MAX_SAFE_INTEGER));function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+"00";let expanded=address.split("").map(c=>{return ibanLookup[c]}).join("");while(expanded.length>=safeDigits){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum="0"+checksum}return checksum}function getAddress(address){let result=null;if(typeof address!=="string"){logger$7.throwArgumentError("invalid address","address",address)}if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(address.substring(0,2)!=="0x"){address="0x"+address}result=getChecksumAddress(address);if(address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&result!==address){logger$7.throwArgumentError("bad address checksum","address",address)}}else if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){if(address.substring(2,4)!==ibanChecksum(address)){logger$7.throwArgumentError("bad icap checksum","address",address)}result=_base36To16(address.substring(4));while(result.length<40){result="0"+result}result=getChecksumAddress("0x"+result)}else{logger$7.throwArgumentError("invalid address","address",address)}return result}function isAddress(address){try{getAddress(address);return true}catch(error){}return false}function getIcapAddress(address){let base36=_base16To36(getAddress(address).substring(2)).toUpperCase();while(base36.length<30){base36="0"+base36}return"XE"+ibanChecksum("XE00"+base36)+base36}function getContractAddress(transaction){let from=null;try{from=getAddress(transaction.from)}catch(error){logger$7.throwArgumentError("missing from address","transaction",transaction)}const nonce=stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));return getAddress(hexDataSlice(keccak256(encode([from,nonce])),12))}function getCreate2Address(from,salt,initCodeHash){if(hexDataLength(salt)!==32){logger$7.throwArgumentError("salt must be 32 bytes","salt",salt)}if(hexDataLength(initCodeHash)!==32){logger$7.throwArgumentError("initCodeHash must be 32 bytes","initCodeHash",initCodeHash)}return getAddress(hexDataSlice(keccak256(concat(["0xff",getAddress(from),salt,initCodeHash])),12))}"use strict";class AddressCoder extends Coder{constructor(localName){super("address","address",localName,false)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(writer,value){try{getAddress(value)}catch(error){this._throwError(error.message,value)}return writer.writeValue(value)}decode(reader){return getAddress(hexZeroPad(reader.readValue().toHexString(),20))}}"use strict";class AnonymousCoder extends Coder{constructor(coder){super(coder.name,coder.type,undefined,coder.dynamic);this.coder=coder}defaultValue(){return this.coder.defaultValue()}encode(writer,value){return this.coder.encode(writer,value)}decode(reader){return this.coder.decode(reader)}}"use strict";const logger$8=new Logger(version$4);function pack(writer,coders,values){let arrayValues=null;if(Array.isArray(values)){arrayValues=values}else if(values&&typeof values==="object"){let unique={};arrayValues=coders.map(coder=>{const name=coder.localName;if(!name){logger$8.throwError("cannot encode object for signature with missing names",Logger.errors.INVALID_ARGUMENT,{argument:"values",coder:coder,value:values})}if(unique[name]){logger$8.throwError("cannot encode object for signature with duplicate names",Logger.errors.INVALID_ARGUMENT,{argument:"values",coder:coder,value:values})}unique[name]=true;return values[name]})}else{logger$8.throwArgumentError("invalid tuple value","tuple",values)}if(coders.length!==arrayValues.length){logger$8.throwArgumentError("types/value length mismatch","tuple",values)}let staticWriter=new Writer(writer.wordSize);let dynamicWriter=new Writer(writer.wordSize);let updateFuncs=[];coders.forEach((coder,index)=>{let value=arrayValues[index];if(coder.dynamic){let dynamicOffset=dynamicWriter.length;coder.encode(dynamicWriter,value);let updateFunc=staticWriter.writeUpdatableValue();updateFuncs.push(baseOffset=>{updateFunc(baseOffset+dynamicOffset)})}else{coder.encode(staticWriter,value)}});updateFuncs.forEach(func=>{func(staticWriter.length)});let length=writer.appendWriter(staticWriter);length+=writer.appendWriter(dynamicWriter);return length}function unpack(reader,coders){let values=[];let baseReader=reader.subReader(0);coders.forEach(coder=>{let value=null;if(coder.dynamic){let offset=reader.readValue();let offsetReader=baseReader.subReader(offset.toNumber());try{value=coder.decode(offsetReader)}catch(error){if(error.code===Logger.errors.BUFFER_OVERRUN){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}else{try{value=coder.decode(reader)}catch(error){if(error.code===Logger.errors.BUFFER_OVERRUN){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}if(value!=undefined){values.push(value)}});const uniqueNames=coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name==="length"){name="_length"}if(values[name]!=null){return}const value=values[index];if(value instanceof Error){Object.defineProperty(values,name,{get:()=>{throw value}})}else{values[name]=value}});for(let i=0;i<values.length;i++){const value=values[i];if(value instanceof Error){Object.defineProperty(values,i,{get:()=>{throw value}})}}return Object.freeze(values)}class ArrayCoder extends Coder{constructor(coder,length,localName){const type=coder.type+"["+(length>=0?length:"")+"]";const dynamic=length===-1||coder.dynamic;super("array",type,localName,dynamic);this.coder=coder;this.length=length}defaultValue(){const defaultChild=this.coder.defaultValue();const result=[];for(let i=0;i<this.length;i++){result.push(defaultChild)}return result}encode(writer,value){if(!Array.isArray(value)){this._throwError("expected array value",value)}let count=this.length;if(count===-1){count=value.length;writer.writeValue(value.length)}logger$8.checkArgumentCount(value.length,count,"coder array"+(this.localName?" "+this.localName:""));let coders=[];for(let i=0;i<value.length;i++){coders.push(this.coder)}return pack(writer,coders,value)}decode(reader){let count=this.length;if(count===-1){count=reader.readValue().toNumber();if(count*32>reader._data.length){logger$8.throwError("insufficient data length",Logger.errors.BUFFER_OVERRUN,{length:reader._data.length,count:count})}}let coders=[];for(let i=0;i<count;i++){coders.push(new AnonymousCoder(this.coder))}return reader.coerce(this.name,unpack(reader,coders))}}"use strict";class BooleanCoder extends Coder{constructor(localName){super("bool","bool",localName,false)}defaultValue(){return false}encode(writer,value){return writer.writeValue(value?1:0)}decode(reader){return reader.coerce(this.type,!reader.readValue().isZero())}}"use strict";class DynamicBytesCoder extends Coder{constructor(type,localName){super(type,type,localName,true)}defaultValue(){return"0x"}encode(writer,value){value=arrayify(value);let length=writer.writeValue(value.length);length+=writer.writeBytes(value);return length}decode(reader){return reader.readBytes(reader.readValue().toNumber(),true)}}class BytesCoder extends DynamicBytesCoder{constructor(localName){super("bytes",localName)}decode(reader){return reader.coerce(this.name,hexlify(super.decode(reader)))}}"use strict";class FixedBytesCoder extends Coder{constructor(size,localName){let name="bytes"+String(size);super(name,name,localName,false);this.size=size}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+this.size*2)}encode(writer,value){let data=arrayify(value);if(data.length!==this.size){this._throwError("incorrect data length",value)}return writer.writeBytes(data)}decode(reader){return reader.coerce(this.name,hexlify(reader.readBytes(this.size)))}}"use strict";class NullCoder extends Coder{constructor(localName){super("null","",localName,false)}defaultValue(){return null}encode(writer,value){if(value!=null){this._throwError("not null",value)}return writer.writeBytes([])}decode(reader){reader.readBytes(0);return reader.coerce(this.name,null)}}const AddressZero="0x0000000000000000000000000000000000000000";const NegativeOne$1=BigNumber.from(-1);const Zero$1=BigNumber.from(0);const One=BigNumber.from(1);const Two=BigNumber.from(2);const WeiPerEther=BigNumber.from("1000000000000000000");const MaxUint256=BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const HashZero="0x0000000000000000000000000000000000000000000000000000000000000000";const EtherSymbol="";"use strict";var index$1=Object.freeze({__proto__:null,AddressZero:AddressZero,NegativeOne:NegativeOne$1,Zero:Zero$1,One:One,Two:Two,WeiPerEther:WeiPerEther,MaxUint256:MaxUint256,HashZero:HashZero,EtherSymbol:EtherSymbol});"use strict";class NumberCoder extends Coder{constructor(size,signed,localName){const name=(signed?"int":"uint")+size*8;super(name,name,localName,false);this.size=size;this.signed=signed}defaultValue(){return 0}encode(writer,value){let v=BigNumber.from(value);let maxUintValue=MaxUint256.mask(writer.wordSize*8);if(this.signed){let bounds=maxUintValue.mask(this.size*8-1);if(v.gt(bounds)||v.lt(bounds.add(One).mul(NegativeOne$1))){this._throwError("value out-of-bounds",value)}}else if(v.lt(Zero$1)||v.gt(maxUintValue.mask(this.size*8))){this._throwError("value out-of-bounds",value)}v=v.toTwos(this.size*8).mask(this.size*8);if(this.signed){v=v.fromTwos(this.size*8).toTwos(8*writer.wordSize)}return writer.writeValue(v)}decode(reader){let value=reader.readValue().mask(this.size*8);if(this.signed){value=value.fromTwos(this.size*8)}return reader.coerce(this.name,value)}}const version$7="strings/5.1.0";"use strict";const logger$9=new Logger(version$7);var UnicodeNormalizationForm;(function(UnicodeNormalizationForm){UnicodeNormalizationForm["current"]="";UnicodeNormalizationForm["NFC"]="NFC";UnicodeNormalizationForm["NFD"]="NFD";UnicodeNormalizationForm["NFKC"]="NFKC";UnicodeNormalizationForm["NFKD"]="NFKD"})(UnicodeNormalizationForm||(UnicodeNormalizationForm={}));var Utf8ErrorReason;(function(Utf8ErrorReason){Utf8ErrorReason["UNEXPECTED_CONTINUE"]="unexpected continuation byte";Utf8ErrorReason["BAD_PREFIX"]="bad codepoint prefix";Utf8ErrorReason["OVERRUN"]="string overrun";Utf8ErrorReason["MISSING_CONTINUE"]="missing continuation byte";Utf8ErrorReason["OUT_OF_RANGE"]="out of UTF-8 range";Utf8ErrorReason["UTF16_SURROGATE"]="UTF-16 surrogate";Utf8ErrorReason["OVERLONG"]="overlong representation"})(Utf8ErrorReason||(Utf8ErrorReason={}));function errorFunc(reason,offset,bytes,output,badCodepoint){return logger$9.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`,"bytes",bytes)}function ignoreFunc(reason,offset,bytes,output,badCodepoint){if(reason===Utf8ErrorReason.BAD_PREFIX||reason===Utf8ErrorReason.UNEXPECTED_CONTINUE){let i=0;for(let o=offset+1;o<bytes.length;o++){if(bytes[o]>>6!==2){break}i++}return i}if(reason===Utf8ErrorReason.OVERRUN){return bytes.length-offset-1}return 0}function replaceFunc(reason,offset,bytes,output,badCodepoint){if(reason===Utf8ErrorReason.OVERLONG){output.push(badCodepoint);return 0}output.push(65533);return ignoreFunc(reason,offset,bytes,output,badCodepoint)}const Utf8ErrorFuncs=Object.freeze({error:errorFunc,ignore:ignoreFunc,replace:replaceFunc});function getUtf8CodePoints(bytes,onError){if(onError==null){onError=Utf8ErrorFuncs.error}bytes=arrayify(bytes);const result=[];let i=0;while(i<bytes.length){const c=bytes[i++];if(c>>7===0){result.push(c);continue}let extraLength=null;let overlongMask=null;if((c&224)===192){extraLength=1;overlongMask=127}else if((c&240)===224){extraLength=2;overlongMask=2047}else if((c&248)===240){extraLength=3;overlongMask=65535}else{if((c&192)===128){i+=onError(Utf8ErrorReason.UNEXPECTED_CONTINUE,i-1,bytes,result)}else{i+=onError(Utf8ErrorReason.BAD_PREFIX,i-1,bytes,result)}continue}if(i-1+extraLength>=bytes.length){i+=onError(Utf8ErrorReason.OVERRUN,i-1,bytes,result);continue}let res=c&(1<<8-extraLength-1)-1;for(let j=0;j<extraLength;j++){let nextChar=bytes[i];if((nextChar&192)!=128){i+=onError(Utf8ErrorReason.MISSING_CONTINUE,i,bytes,result);res=null;break}res=res<<6|nextChar&63;i++}if(res===null){continue}if(res>1114111){i+=onError(Utf8ErrorReason.OUT_OF_RANGE,i-1-extraLength,bytes,result,res);continue}if(res>=55296&&res<=57343){i+=onError(Utf8ErrorReason.UTF16_SURROGATE,i-1-extraLength,bytes,result,res);continue}if(res<=overlongMask){i+=onError(Utf8ErrorReason.OVERLONG,i-1-extraLength,bytes,result,res);continue}result.push(res)}return result}function toUtf8Bytes(str,form=UnicodeNormalizationForm.current){if(form!=UnicodeNormalizationForm.current){logger$9.checkNormalize();str=str.normalize(form)}let result=[];for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){result.push(c)}else if(c<2048){result.push(c>>6|192);result.push(c&63|128)}else if((c&64512)==55296){i++;const c2=str.charCodeAt(i);if(i>=str.length||(c2&64512)!==56320){throw new Error("invalid utf-8 string")}const pair=65536+((c&1023)<<10)+(c2&1023);result.push(pair>>18|240);result.push(pair>>12&63|128);result.push(pair>>6&63|128);result.push(pair&63|128)}else{result.push(c>>12|224);result.push(c>>6&63|128);result.push(c&63|128)}}return arrayify(result)}function escapeChar(value){const hex="0000"+value.toString(16);return"\\u"+hex.substring(hex.length-4)}function _toEscapedUtf8String(bytes,onError){return'"'+getUtf8CodePoints(bytes,onError).map(codePoint=>{if(codePoint<256){switch(codePoint){case 8:return"\\b";case 9:return"\\t";case 10:return"\\n";case 13:return"\\r";case 34:return'\\"';case 92:return"\\\\"}if(codePoint>=32&&codePoint<127){return String.fromCharCode(codePoint)}}if(codePoint<=65535){return escapeChar(codePoint)}codePoint-=65536;return escapeChar((codePoint>>10&1023)+55296)+escapeChar((codePoint&1023)+56320)}).join("")+'"'}function _toUtf8String(codePoints){return codePoints.map(codePoint=>{if(codePoint<=65535){return String.fromCharCode(codePoint)}codePoint-=65536;return String.fromCharCode((codePoint>>10&1023)+55296,(codePoint&1023)+56320)}).join("")}function toUtf8String(bytes,onError){return _toUtf8String(getUtf8CodePoints(bytes,onError))}function toUtf8CodePoints(str,form=UnicodeNormalizationForm.current){return getUtf8CodePoints(toUtf8Bytes(str,form))}"use strict";function formatBytes32String(text){const bytes=toUtf8Bytes(text);if(bytes.length>31){throw new Error("bytes32 string must be less than 32 bytes")}return hexlify(concat([bytes,HashZero]).slice(0,32))}function parseBytes32String(bytes){const data=arrayify(bytes);if(data.length!==32){throw new Error("invalid bytes32 - not 32 bytes long")}if(data[31]!==0){throw new Error("invalid bytes32 string - no null terminator")}let length=31;while(data[length-1]===0){length--}return toUtf8String(data.slice(0,length))}"use strict";function bytes2(data){if(data.length%4!==0){throw new Error("bad data")}let result=[];for(let i=0;i<data.length;i+=4){result.push(parseInt(data.substring(i,i+4),16))}return result}function createTable(data,func){if(!func){func=function(value){return[parseInt(value,16)]}}let lo=0;let result={};data.split(",").forEach(pair=>{let comps=pair.split(":");lo+=parseInt(comps[0],16);result[lo]=func(comps[1])});return result}function createRangeTable(data){let hi=0;return data.split(",").map(v=>{let comps=v.split("-");if(comps.length===1){comps[1]="0"}else if(comps[1]===""){comps[1]="1"}let lo=hi+parseInt(comps[0],16);hi=parseInt(comps[1],16);return{l:lo,h:hi}})}function matchMap(value,ranges){let lo=0;for(let i=0;i<ranges.length;i++){let range=ranges[i];lo+=range.l;if(value>=lo&&value<=lo+range.h&&(value-lo)%(range.d||1)===0){if(range.e&&range.e.indexOf(value-lo)!==-1){continue}return range}}return null}const Table_A_1_ranges=createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");const Table_B_1_flags="ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(v=>parseInt(v,16));const Table_B_2_ranges=[{h:25,s:32,l:65},{h:30,s:32,e:[23],l:127},{h:54,s:1,e:[48],l:64,d:2},{h:14,s:1,l:57,d:2},{h:44,s:1,l:17,d:2},{h:10,s:1,e:[2,6,8],l:61,d:2},{h:16,s:1,l:68,d:2},{h:84,s:1,e:[18,24,66],l:19,d:2},{h:26,s:32,e:[17],l:435},{h:22,s:1,l:71,d:2},{h:15,s:80,l:40},{h:31,s:32,l:16},{h:32,s:1,l:80,d:2},{h:52,s:1,l:42,d:2},{h:12,s:1,l:55,d:2},{h:40,s:1,e:[38],l:15,d:2},{h:14,s:1,l:48,d:2},{h:37,s:48,l:49},{h:148,s:1,l:6351,d:2},{h:88,s:1,l:160,d:2},{h:15,s:16,l:704},{h:25,s:26,l:854},{h:25,s:32,l:55915},{h:37,s:40,l:1247},{h:25,s:-119711,l:53248},{h:25,s:-119763,l:52},{h:25,s:-119815,l:52},{h:25,s:-119867,e:[1,4,5,7,8,11,12,17],l:52},{h:25,s:-119919,l:52},{h:24,s:-119971,e:[2,7,8,17],l:52},{h:24,s:-120023,e:[2,7,13,15,16,17],l:52},{h:25,s:-120075,l:52},{h:25,s:-120127,l:52},{h:25,s:-120179,l:52},{h:25,s:-120231,l:52},{h:25,s:-120283,l:52},{h:25,s:-120335,l:52},{h:24,s:-119543,e:[17],l:56},{h:24,s:-119601,e:[17],l:58},{h:24,s:-119659,e:[17],l:58},{h:24,s:-119717,e:[17],l:58},{h:24,s:-119775,e:[17],l:58}];const Table_B_2_lut_abs=createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");const Table_B_2_lut_rel=createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");const Table_B_2_complex=createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D",bytes2);const Table_C_ranges=createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");function flatten(values){return values.reduce((accum,value)=>{value.forEach(value=>{accum.push(value)});return accum},[])}function _nameprepTableA1(codepoint){return!!matchMap(codepoint,Table_A_1_ranges)}function _nameprepTableB2(codepoint){let range=matchMap(codepoint,Table_B_2_ranges);if(range){return[codepoint+range.s]}let codes=Table_B_2_lut_abs[codepoint];if(codes){return codes}let shift=Table_B_2_lut_rel[codepoint];if(shift){return[codepoint+shift[0]]}let complex=Table_B_2_complex[codepoint];if(complex){return complex}return null}function _nameprepTableC(codepoint){return!!matchMap(codepoint,Table_C_ranges)}function nameprep(value){if(value.match(/^[a-z0-9-]*$/i)&&value.length<=59){return value.toLowerCase()}let codes=toUtf8CodePoints(value);codes=flatten(codes.map(code=>{if(Table_B_1_flags.indexOf(code)>=0){return[]}if(code>=65024&&code<=65039){return[]}let codesTableB2=_nameprepTableB2(code);if(codesTableB2){return codesTableB2}return[code]}));codes=toUtf8CodePoints(_toUtf8String(codes),UnicodeNormalizationForm.NFKC);codes.forEach(code=>{if(_nameprepTableC(code)){throw new Error("STRINGPREP_CONTAINS_PROHIBITED")}});codes.forEach(code=>{if(_nameprepTableA1(code)){throw new Error("STRINGPREP_CONTAINS_UNASSIGNED")}});let name=_toUtf8String(codes);if(name.substring(0,1)==="-"||name.substring(2,4)==="--"||name.substring(name.length-1)==="-"){throw new Error("invalid hyphen")}if(name.length>63){throw new Error("too long")}return name}"use strict";"use strict";class StringCoder extends DynamicBytesCoder{constructor(localName){super("string",localName)}defaultValue(){return""}encode(writer,value){return super.encode(writer,toUtf8Bytes(value))}decode(reader){return toUtf8String(super.decode(reader))}}"use strict";class TupleCoder extends Coder{constructor(coders,localName){let dynamic=false;const types=[];coders.forEach(coder=>{if(coder.dynamic){dynamic=true}types.push(coder.type)});const type="tuple("+types.join(",")+")";super("tuple",type,localName,dynamic);this.coders=coders}defaultValue(){const values=[];this.coders.forEach(coder=>{values.push(coder.defaultValue())});const uniqueNames=this.coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});this.coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name==="length"){name="_length"}if(values[name]!=null){return}values[name]=values[index]});return Object.freeze(values)}encode(writer,value){return pack(writer,this.coders,value)}decode(reader){return reader.coerce(this.name,unpack(reader,this.coders))}}"use strict";const logger$a=new Logger(version$4);const paramTypeBytes=new RegExp(/^bytes([0-9]*)$/);const paramTypeNumber=new RegExp(/^(u?int)([0-9]*)$/);class AbiCoder{constructor(coerceFunc){logger$a.checkNew(new.target,AbiCoder);defineReadOnly(this,"coerceFunc",coerceFunc||null)}_getCoder(param){switch(param.baseType){case"address":return new AddressCoder(param.name);case"bool":return new BooleanCoder(param.name);case"string":return new StringCoder(param.name);case"bytes":return new BytesCoder(param.name);case"array":return new ArrayCoder(this._getCoder(param.arrayChildren),param.arrayLength,param.name);case"tuple":return new TupleCoder((param.components||[]).map(component=>{return this._getCoder(component)}),param.name);case"":return new NullCoder(param.name)}let match=param.type.match(paramTypeNumber);if(match){let size=parseInt(match[2]||"256");if(size===0||size>256||size%8!==0){logger$a.throwArgumentError("invalid "+match[1]+" bit length","param",param)}return new NumberCoder(size/8,match[1]==="int",param.name)}match=param.type.match(paramTypeBytes);if(match){let size=parseInt(match[1]);if(size===0||size>32){logger$a.throwArgumentError("invalid bytes length","param",param)}return new FixedBytesCoder(size,param.name)}return logger$a.throwArgumentError("invalid type","type",param.type)}_getWordSize(){return 32}_getReader(data,allowLoose){return new Reader(data,this._getWordSize(),this.coerceFunc,allowLoose)}_getWriter(){return new Writer(this._getWordSize())}getDefaultValue(types){const coders=types.map(type=>this._getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.defaultValue()}encode(types,values){if(types.length!==values.length){logger$a.throwError("types/values length mismatch",Logger.errors.INVALID_ARGUMENT,{count:{types:types.length,values:values.length},value:{types:types,values:values}})}const coders=types.map(type=>this._getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");const writer=this._getWriter();coder.encode(writer,values);return writer.data}decode(types,data,loose){const coders=types.map(type=>this._getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.decode(this._getReader(arrayify(data),loose))}}const defaultAbiCoder=new AbiCoder;function id(text){return keccak256(toUtf8Bytes(text))}const version$8="hash/5.1.0";const logger$b=new Logger(version$8);const Zeros=new Uint8Array(32);Zeros.fill(0);const Partition=new RegExp("^((.*)\\.)?([^.]+)$");function isValidName(name){try{const comps=name.split(".");for(let i=0;i<comps.length;i++){if(nameprep(comps[i]).length===0){throw new Error("empty")}}return true}catch(error){}return false}function namehash(name){if(typeof name!=="string"){logger$b.throwArgumentError("invalid address - "+String(name),"name",name)}let result=Zeros;while(name.length){const partition=name.match(Partition);const label=toUtf8Bytes(nameprep(partition[3]));result=keccak256(concat([result,keccak256(label)]));name=partition[2]||""}return hexlify(result)}const messagePrefix="Ethereum Signed Message:\n";function hashMessage(message){if(typeof message==="string"){message=toUtf8Bytes(message)}return keccak256(concat([toUtf8Bytes(messagePrefix),toUtf8Bytes(String(message.length)),message]))}var __awaiter$1=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$c=new Logger(version$8);const padding=new Uint8Array(32);padding.fill(0);const NegativeOne$2=BigNumber.from(-1);const Zero$2=BigNumber.from(0);const One$1=BigNumber.from(1);const MaxUint256$1=BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function hexPadRight(value){const bytes=arrayify(value);const padOffset=bytes.length%32;if(padOffset){return hexConcat([bytes,padding.slice(padOffset)])}return hexlify(bytes)}const hexTrue=hexZeroPad(One$1.toHexString(),32);const hexFalse=hexZeroPad(Zero$2.toHexString(),32);const domainFieldTypes={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"};const domainFieldNames=["name","version","chainId","verifyingContract","salt"];function checkString(key){return function(value){if(typeof value!=="string"){logger$c.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`,`domain.${key}`,value)}return value}}const domainChecks={name:checkString("name"),version:checkString("version"),chainId:function(value){try{return BigNumber.from(value).toString()}catch(error){}return logger$c.throwArgumentError(`invalid domain value for "chainId"`,"domain.chainId",value)},verifyingContract:function(value){try{return getAddress(value).toLowerCase()}catch(error){}return logger$c.throwArgumentError(`invalid domain value "verifyingContract"`,"domain.verifyingContract",value)},salt:function(value){try{const bytes=arrayify(value);if(bytes.length!==32){throw new Error("bad length")}return hexlify(bytes)}catch(error){}return logger$c.throwArgumentError(`invalid domain value "salt"`,"domain.salt",value)}};function getBaseEncoder(type){{const match=type.match(/^(u?)int(\d*)$/);if(match){const signed=match[1]==="";const width=parseInt(match[2]||"256");if(width%8!==0||width>256||match[2]&&match[2]!==String(width)){logger$c.throwArgumentError("invalid numeric width","type",type)}const boundsUpper=MaxUint256$1.mask(signed?width-1:width);const boundsLower=signed?boundsUpper.add(One$1).mul(NegativeOne$2):Zero$2;return function(value){const v=BigNumber.from(value);if(v.lt(boundsLower)||v.gt(boundsUpper)){logger$c.throwArgumentError(`value out-of-bounds for ${type}`,"value",value)}return hexZeroPad(v.toTwos(256).toHexString(),32)}}}{const match=type.match(/^bytes(\d+)$/);if(match){const width=parseInt(match[1]);if(width===0||width>32||match[1]!==String(width)){logger$c.throwArgumentError("invalid bytes width","type",type)}return function(value){const bytes=arrayify(value);if(bytes.length!==width){logger$c.throwArgumentError(`invalid length for ${type}`,"value",value)}return hexPadRight(value)}}}switch(type){case"address":return function(value){return hexZeroPad(getAddress(value),32)};case"bool":return function(value){return!value?hexFalse:hexTrue};case"bytes":return function(value){return keccak256(value)};case"string":return function(value){return id(value)}}return null}function encodeType(name,fields){return`${name}(${fields.map(({name:name,type:type})=>type+" "+name).join(",")})`}class TypedDataEncoder{constructor(types){defineReadOnly(this,"types",Object.freeze(deepCopy(types)));defineReadOnly(this,"_encoderCache",{});defineReadOnly(this,"_types",{});const links={};const parents={};const subtypes={};Object.keys(types).forEach(type=>{links[type]={};parents[type]=[];subtypes[type]={}});for(const name in types){const uniqueNames={};types[name].forEach(field=>{if(uniqueNames[field.name]){logger$c.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`,"types",types)}uniqueNames[field.name]=true;const baseType=field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];if(baseType===name){logger$c.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`,"types",types)}const encoder=getBaseEncoder(baseType);if(encoder){return}if(!parents[baseType]){logger$c.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`,"types",types)}parents[baseType].push(name);links[name][baseType]=true})}const primaryTypes=Object.keys(parents).filter(n=>parents[n].length===0);if(primaryTypes.length===0){logger$c.throwArgumentError("missing primary type","types",types)}else if(primaryTypes.length>1){logger$c.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map(t=>JSON.stringify(t)).join(", ")}`,"types",types)}defineReadOnly(this,"primaryType",primaryTypes[0]);function checkCircular(type,found){if(found[type]){logger$c.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`,"types",types)}found[type]=true;Object.keys(links[type]).forEach(child=>{if(!parents[child]){return}checkCircular(child,found);Object.keys(found).forEach(subtype=>{subtypes[subtype][child]=true})});delete found[type]}checkCircular(this.primaryType,{});for(const name in subtypes){const st=Object.keys(subtypes[name]);st.sort();this._types[name]=encodeType(name,types[name])+st.map(t=>encodeType(t,types[t])).join("")}}getEncoder(type){let encoder=this._encoderCache[type];if(!encoder){encoder=this._encoderCache[type]=this._getEncoder(type)}return encoder}_getEncoder(type){{const encoder=getBaseEncoder(type);if(encoder){return encoder}}const match=type.match(/^(.*)(\x5b(\d*)\x5d)$/);if(match){const subtype=match[1];const subEncoder=this.getEncoder(subtype);const length=parseInt(match[3]);return value=>{if(length>=0&&value.length!==length){logger$c.throwArgumentError("array length mismatch; expected length ${ arrayLength }","value",value)}let result=value.map(subEncoder);if(this._types[subtype]){result=result.map(keccak256)}return keccak256(hexConcat(result))}}const fields=this.types[type];if(fields){const encodedType=id(this._types[type]);return value=>{const values=fields.map(({name:name,type:type})=>{const result=this.getEncoder(type)(value[name]);if(this._types[type]){return keccak256(result)}return result});values.unshift(encodedType);return hexConcat(values)}}return logger$c.throwArgumentError(`unknown type: ${type}`,"type",type)}encodeType(name){const result=this._types[name];if(!result){logger$c.throwArgumentError(`unknown type: ${JSON.stringify(name)}`,"name",name)}return result}encodeData(type,value){return this.getEncoder(type)(value)}hashStruct(name,value){return keccak256(this.encodeData(name,value))}encode(value){return this.encodeData(this.primaryType,value)}hash(value){return this.hashStruct(this.primaryType,value)}_visit(type,value,callback){{const encoder=getBaseEncoder(type);if(encoder){return callback(type,value)}}const match=type.match(/^(.*)(\x5b(\d*)\x5d)$/);if(match){const subtype=match[1];const length=parseInt(match[3]);if(length>=0&&value.length!==length){logger$c.throwArgumentError("array length mismatch; expected length ${ arrayLength }","value",value)}return value.map(v=>this._visit(subtype,v,callback))}const fields=this.types[type];if(fields){return fields.reduce((accum,{name:name,type:type})=>{accum[name]=this._visit(type,value[name],callback);return accum},{})}return logger$c.throwArgumentError(`unknown type: ${type}`,"type",type)}visit(value,callback){return this._visit(this.primaryType,value,callback)}static from(types){return new TypedDataEncoder(types)}static getPrimaryType(types){return TypedDataEncoder.from(types).primaryType}static hashStruct(name,types,value){return TypedDataEncoder.from(types).hashStruct(name,value)}static hashDomain(domain){const domainFields=[];for(const name in domain){const type=domainFieldTypes[name];if(!type){logger$c.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`,"domain",domain)}domainFields.push({name:name,type:type})}domainFields.sort((a,b)=>{return domainFieldNames.indexOf(a.name)-domainFieldNames.indexOf(b.name)});return TypedDataEncoder.hashStruct("EIP712Domain",{EIP712Domain:domainFields},domain)}static encode(domain,types,value){return hexConcat(["0x1901",TypedDataEncoder.hashDomain(domain),TypedDataEncoder.from(types).hash(value)])}static hash(domain,types,value){return keccak256(TypedDataEncoder.encode(domain,types,value))}static resolveNames(domain,types,value,resolveName){return __awaiter$1(this,void 0,void 0,function*(){domain=shallowCopy(domain);const ensCache={};if(domain.verifyingContract&&!isHexString(domain.verifyingContract,20)){ensCache[domain.verifyingContract]="0x"}const encoder=TypedDataEncoder.from(types);encoder.visit(value,(type,value)=>{if(type==="address"&&!isHexString(value,20)){ensCache[value]="0x"}return value});for(const name in ensCache){ensCache[name]=yield resolveName(name)}if(domain.verifyingContract&&ensCache[domain.verifyingContract]){domain.verifyingContract=ensCache[domain.verifyingContract]}value=encoder.visit(value,(type,value)=>{if(type==="address"&&ensCache[value]){return ensCache[value]}return value});return{domain:domain,value:value}})}static getPayload(domain,types,value){TypedDataEncoder.hashDomain(domain);const domainValues={};const domainTypes=[];domainFieldNames.forEach(name=>{const value=domain[name];if(value==null){return}domainValues[name]=domainChecks[name](value);domainTypes.push({name:name,type:domainFieldTypes[name]})});const encoder=TypedDataEncoder.from(types);const typesWithDomain=shallowCopy(types);if(typesWithDomain.EIP712Domain){logger$c.throwArgumentError("types must not contain EIP712Domain type","types.EIP712Domain",types)}else{typesWithDomain.EIP712Domain=domainTypes}encoder.encode(value);return{types:typesWithDomain,domain:domainValues,primaryType:encoder.primaryType,message:encoder.visit(value,(type,value)=>{if(type.match(/^bytes(\d*)/)){return hexlify(arrayify(value))}if(type.match(/^u?int/)){return BigNumber.from(value).toString()}switch(type){case"address":return value.toLowerCase();case"bool":return!!value;case"string":if(typeof value!=="string"){logger$c.throwArgumentError(`invalid string`,"value",value)}return value}return logger$c.throwArgumentError("unsupported type","type",type)})}}}"use strict";"use strict";const logger$d=new Logger(version$4);class LogDescription extends Description{}class TransactionDescription extends Description{}class Indexed extends Description{static isIndexed(value){return!!(value&&value._isIndexed)}}function wrapAccessError(property,error){const wrap=new Error(`deferred error during ABI decoding triggered accessing ${property}`);wrap.error=error;return wrap}class Interface{constructor(fragments){logger$d.checkNew(new.target,Interface);let abi=[];if(typeof fragments==="string"){abi=JSON.parse(fragments)}else{abi=fragments}defineReadOnly(this,"fragments",abi.map(fragment=>{return Fragment.from(fragment)}).filter(fragment=>fragment!=null));defineReadOnly(this,"_abiCoder",getStatic(new.target,"getAbiCoder")());defineReadOnly(this,"functions",{});defineReadOnly(this,"errors",{});defineReadOnly(this,"events",{});defineReadOnly(this,"structs",{});this.fragments.forEach(fragment=>{let bucket=null;switch(fragment.type){case"constructor":if(this.deploy){logger$d.warn("duplicate definition - constructor");return}defineReadOnly(this,"deploy",fragment);return;case"function":bucket=this.functions;break;case"event":bucket=this.events;break;default:return}let signature=fragment.format();if(bucket[signature]){logger$d.warn("duplicate definition - "+signature);return}bucket[signature]=fragment});if(!this.deploy){defineReadOnly(this,"deploy",ConstructorFragment.from({payable:false,type:"constructor"}))}defineReadOnly(this,"_isInterface",true)}format(format){if(!format){format=FormatTypes.full}if(format===FormatTypes.sighash){logger$d.throwArgumentError("interface does not support formatting sighash","format",format)}const abi=this.fragments.map(fragment=>fragment.format(format));if(format===FormatTypes.json){return JSON.stringify(abi.map(j=>JSON.parse(j)))}return abi}static getAbiCoder(){return defaultAbiCoder}static getAddress(address){return getAddress(address)}static getSighash(functionFragment){return hexDataSlice(id(functionFragment.format()),0,4)}static getEventTopic(eventFragment){return id(eventFragment.format())}getFunction(nameOrSignatureOrSighash){if(isHexString(nameOrSignatureOrSighash)){for(const name in this.functions){if(nameOrSignatureOrSighash===this.getSighash(name)){return this.functions[name]}}logger$d.throwArgumentError("no matching function","sighash",nameOrSignatureOrSighash)}if(nameOrSignatureOrSighash.indexOf("(")===-1){const name=nameOrSignatureOrSighash.trim();const matching=Object.keys(this.functions).filter(f=>f.split("(")[0]===name);if(matching.length===0){logger$d.throwArgumentError("no matching function","name",name)}else if(matching.length>1){logger$d.throwArgumentError("multiple matching functions","name",name)}return this.functions[matching[0]]}const result=this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];if(!result){logger$d.throwArgumentError("no matching function","signature",nameOrSignatureOrSighash)}return result}getEvent(nameOrSignatureOrTopic){if(isHexString(nameOrSignatureOrTopic)){const topichash=nameOrSignatureOrTopic.toLowerCase();for(const name in this.events){if(topichash===this.getEventTopic(name)){return this.events[name]}}logger$d.throwArgumentError("no matching event","topichash",topichash)}if(nameOrSignatureOrTopic.indexOf("(")===-1){const name=nameOrSignatureOrTopic.trim();const matching=Object.keys(this.events).filter(f=>f.split("(")[0]===name);if(matching.length===0){logger$d.throwArgumentError("no matching event","name",name)}else if(matching.length>1){logger$d.throwArgumentError("multiple matching events","name",name)}return this.events[matching[0]]}const result=this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];if(!result){logger$d.throwArgumentError("no matching event","signature",nameOrSignatureOrTopic)}return result}getSighash(functionFragment){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}return getStatic(this.constructor,"getSighash")(functionFragment)}getEventTopic(eventFragment){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}return getStatic(this.constructor,"getEventTopic")(eventFragment)}_decodeParams(params,data){return this._abiCoder.decode(params,data)}_encodeParams(params,values){return this._abiCoder.encode(params,values)}encodeDeploy(values){return this._encodeParams(this.deploy.inputs,values||[])}decodeFunctionData(functionFragment,data){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}const bytes=arrayify(data);if(hexlify(bytes.slice(0,4))!==this.getSighash(functionFragment)){logger$d.throwArgumentError(`data signature does not match function ${functionFragment.name}.`,"data",hexlify(bytes))}return this._decodeParams(functionFragment.inputs,bytes.slice(4))}encodeFunctionData(functionFragment,values){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}return hexlify(concat([this.getSighash(functionFragment),this._encodeParams(functionFragment.inputs,values||[])]))}decodeFunctionResult(functionFragment,data){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}let bytes=arrayify(data);let reason=null;let errorSignature=null;switch(bytes.length%this._abiCoder._getWordSize()){case 0:try{return this._abiCoder.decode(functionFragment.outputs,bytes)}catch(error){}break;case 4:if(hexlify(bytes.slice(0,4))==="0x08c379a0"){errorSignature="Error(string)";reason=this._abiCoder.decode(["string"],bytes.slice(4))[0]}break}return logger$d.throwError("call revert exception",Logger.errors.CALL_EXCEPTION,{method:functionFragment.format(),errorSignature:errorSignature,errorArgs:[reason],reason:reason})}encodeFunctionResult(functionFragment,values){if(typeof functionFragment==="string"){functionFragment=this.getFunction(functionFragment)}return hexlify(this._abiCoder.encode(functionFragment.outputs,values||[]))}encodeFilterTopics(eventFragment,values){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}if(values.length>eventFragment.inputs.length){logger$d.throwError("too many arguments for "+eventFragment.format(),Logger.errors.UNEXPECTED_ARGUMENT,{argument:"values",value:values})}let topics=[];if(!eventFragment.anonymous){topics.push(this.getEventTopic(eventFragment))}const encodeTopic=(param,value)=>{if(param.type==="string"){return id(value)}else if(param.type==="bytes"){return keccak256(hexlify(value))}if(param.type==="address"){this._abiCoder.encode(["address"],[value])}return hexZeroPad(hexlify(value),32)};values.forEach((value,index)=>{let param=eventFragment.inputs[index];if(!param.indexed){if(value!=null){logger$d.throwArgumentError("cannot filter non-indexed parameters; must be null","contract."+param.name,value)}return}if(value==null){topics.push(null)}else if(param.baseType==="array"||param.baseType==="tuple"){logger$d.throwArgumentError("filtering with tuples or arrays not supported","contract."+param.name,value)}else if(Array.isArray(value)){topics.push(value.map(value=>encodeTopic(param,value)))}else{topics.push(encodeTopic(param,value))}});while(topics.length&&topics[topics.length-1]===null){topics.pop()}return topics}encodeEventLog(eventFragment,values){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}const topics=[];const dataTypes=[];const dataValues=[];if(!eventFragment.anonymous){topics.push(this.getEventTopic(eventFragment))}if(values.length!==eventFragment.inputs.length){logger$d.throwArgumentError("event arguments/values mismatch","values",values)}eventFragment.inputs.forEach((param,index)=>{const value=values[index];if(param.indexed){if(param.type==="string"){topics.push(id(value))}else if(param.type==="bytes"){topics.push(keccak256(value))}else if(param.baseType==="tuple"||param.baseType==="array"){throw new Error("not implemented")}else{topics.push(this._abiCoder.encode([param.type],[value]))}}else{dataTypes.push(param);dataValues.push(value)}});return{data:this._abiCoder.encode(dataTypes,dataValues),topics:topics}}decodeEventLog(eventFragment,data,topics){if(typeof eventFragment==="string"){eventFragment=this.getEvent(eventFragment)}if(topics!=null&&!eventFragment.anonymous){let topicHash=this.getEventTopic(eventFragment);if(!isHexString(topics[0],32)||topics[0].toLowerCase()!==topicHash){logger$d.throwError("fragment/topic mismatch",Logger.errors.INVALID_ARGUMENT,{argument:"topics[0]",expected:topicHash,value:topics[0]})}topics=topics.slice(1)}let indexed=[];let nonIndexed=[];let dynamic=[];eventFragment.inputs.forEach((param,index)=>{if(param.indexed){if(param.type==="string"||param.type==="bytes"||param.baseType==="tuple"||param.baseType==="array"){indexed.push(ParamType.fromObject({type:"bytes32",name:param.name}));dynamic.push(true)}else{indexed.push(param);dynamic.push(false)}}else{nonIndexed.push(param);dynamic.push(false)}});let resultIndexed=topics!=null?this._abiCoder.decode(indexed,concat(topics)):null;let resultNonIndexed=this._abiCoder.decode(nonIndexed,data,true);let result=[];let nonIndexedIndex=0,indexedIndex=0;eventFragment.inputs.forEach((param,index)=>{if(param.indexed){if(resultIndexed==null){result[index]=new Indexed({_isIndexed:true,hash:null})}else if(dynamic[index]){result[index]=new Indexed({_isIndexed:true,hash:resultIndexed[indexedIndex++]})}else{try{result[index]=resultIndexed[indexedIndex++]}catch(error){result[index]=error}}}else{try{result[index]=resultNonIndexed[nonIndexedIndex++]}catch(error){result[index]=error}}if(param.name&&result[param.name]==null){const value=result[index];if(value instanceof Error){Object.defineProperty(result,param.name,{get:()=>{throw wrapAccessError(`property ${JSON.stringify(param.name)}`,value)}})}else{result[param.name]=value}}});for(let i=0;i<result.length;i++){const value=result[i];if(value instanceof Error){Object.defineProperty(result,i,{get:()=>{throw wrapAccessError(`index ${i}`,value)}})}}return Object.freeze(result)}parseTransaction(tx){let fragment=this.getFunction(tx.data.substring(0,10).toLowerCase());if(!fragment){return null}return new TransactionDescription({args:this._abiCoder.decode(fragment.inputs,"0x"+tx.data.substring(10)),functionFragment:fragment,name:fragment.name,signature:fragment.format(),sighash:this.getSighash(fragment),value:BigNumber.from(tx.value||"0")})}parseLog(log){let fragment=this.getEvent(log.topics[0]);if(!fragment||fragment.anonymous){return null}return new LogDescription({eventFragment:fragment,name:fragment.name,signature:fragment.format(),topic:this.getEventTopic(fragment),args:this.decodeEventLog(fragment,log.data,log.topics)})}static isInterface(value){return!!(value&&value._isInterface)}}"use strict";const version$9="abstract-provider/5.1.0";"use strict";const logger$e=new Logger(version$9);class ForkEvent extends Description{static isForkEvent(value){return!!(value&&value._isForkEvent)}}class BlockForkEvent extends ForkEvent{constructor(blockHash,expiry){if(!isHexString(blockHash,32)){logger$e.throwArgumentError("invalid blockHash","blockHash",blockHash)}super({_isForkEvent:true,_isBlockForkEvent:true,expiry:expiry||0,blockHash:blockHash})}}class TransactionForkEvent extends ForkEvent{constructor(hash,expiry){if(!isHexString(hash,32)){logger$e.throwArgumentError("invalid transaction hash","hash",hash)}super({_isForkEvent:true,_isTransactionForkEvent:true,expiry:expiry||0,hash:hash})}}class TransactionOrderForkEvent extends ForkEvent{constructor(beforeHash,afterHash,expiry){if(!isHexString(beforeHash,32)){logger$e.throwArgumentError("invalid transaction hash","beforeHash",beforeHash)}if(!isHexString(afterHash,32)){logger$e.throwArgumentError("invalid transaction hash","afterHash",afterHash)}super({_isForkEvent:true,_isTransactionOrderForkEvent:true,expiry:expiry||0,beforeHash:beforeHash,afterHash:afterHash})}}class Provider{constructor(){logger$e.checkAbstract(new.target,Provider);defineReadOnly(this,"_isProvider",true)}addListener(eventName,listener){return this.on(eventName,listener)}removeListener(eventName,listener){return this.off(eventName,listener)}static isProvider(value){return!!(value&&value._isProvider)}}const version$a="abstract-signer/5.1.0";"use strict";var __awaiter$2=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$f=new Logger(version$a);const allowedTransactionKeys=["accessList","chainId","data","from","gasLimit","gasPrice","nonce","to","type","value"];const forwardErrors=[Logger.errors.INSUFFICIENT_FUNDS,Logger.errors.NONCE_EXPIRED,Logger.errors.REPLACEMENT_UNDERPRICED];class Signer{constructor(){logger$f.checkAbstract(new.target,Signer);defineReadOnly(this,"_isSigner",true)}getBalance(blockTag){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getBalance");return yield this.provider.getBalance(this.getAddress(),blockTag)})}getTransactionCount(blockTag){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getTransactionCount");return yield this.provider.getTransactionCount(this.getAddress(),blockTag)})}estimateGas(transaction){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("estimateGas");const tx=yield resolveProperties(this.checkTransaction(transaction));return yield this.provider.estimateGas(tx)})}call(transaction,blockTag){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("call");const tx=yield resolveProperties(this.checkTransaction(transaction));return yield this.provider.call(tx,blockTag)})}sendTransaction(transaction){this._checkProvider("sendTransaction");return this.populateTransaction(transaction).then(tx=>{return this.signTransaction(tx).then(signedTx=>{return this.provider.sendTransaction(signedTx)})})}getChainId(){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getChainId");const network=yield this.provider.getNetwork();return network.chainId})}getGasPrice(){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("getGasPrice");return yield this.provider.getGasPrice()})}resolveName(name){return __awaiter$2(this,void 0,void 0,function*(){this._checkProvider("resolveName");return yield this.provider.resolveName(name)})}checkTransaction(transaction){for(const key in transaction){if(allowedTransactionKeys.indexOf(key)===-1){logger$f.throwArgumentError("invalid transaction key: "+key,"transaction",transaction)}}const tx=shallowCopy(transaction);if(tx.from==null){tx.from=this.getAddress()}else{tx.from=Promise.all([Promise.resolve(tx.from),this.getAddress()]).then(result=>{if(result[0].toLowerCase()!==result[1].toLowerCase()){logger$f.throwArgumentError("from address mismatch","transaction",transaction)}return result[0]})}return tx}populateTransaction(transaction){return __awaiter$2(this,void 0,void 0,function*(){const tx=yield resolveProperties(this.checkTransaction(transaction));if(tx.to!=null){tx.to=Promise.resolve(tx.to).then(to=>__awaiter$2(this,void 0,void 0,function*(){if(to==null){return null}const address=yield this.resolveName(to);if(address==null){logger$f.throwArgumentError("provided ENS name resolves to null","tx.to",to)}return address}))}if(tx.gasPrice==null){tx.gasPrice=this.getGasPrice()}if(tx.nonce==null){tx.nonce=this.getTransactionCount("pending")}if(tx.gasLimit==null){tx.gasLimit=this.estimateGas(tx).catch(error=>{if(forwardErrors.indexOf(error.code)>=0){throw error}return logger$f.throwError("cannot estimate gas; transaction may fail or may require manual gas limit",Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,tx:tx})})}if(tx.chainId==null){tx.chainId=this.getChainId()}else{tx.chainId=Promise.all([Promise.resolve(tx.chainId),this.getChainId()]).then(results=>{if(results[1]!==0&&results[0]!==results[1]){logger$f.throwArgumentError("chainId address mismatch","transaction",transaction)}return results[0]})}return yield resolveProperties(tx)})}_checkProvider(operation){if(!this.provider){logger$f.throwError("missing provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:operation||"_checkProvider"})}}static isSigner(value){return!!(value&&value._isSigner)}}class VoidSigner extends Signer{constructor(address,provider){logger$f.checkNew(new.target,VoidSigner);super();defineReadOnly(this,"address",address);defineReadOnly(this,"provider",provider||null)}getAddress(){return Promise.resolve(this.address)}_fail(message,operation){return Promise.resolve().then(()=>{logger$f.throwError(message,Logger.errors.UNSUPPORTED_OPERATION,{operation:operation})})}signMessage(message){return this._fail("VoidSigner cannot sign messages","signMessage")}signTransaction(transaction){return this._fail("VoidSigner cannot sign transactions","signTransaction")}_signTypedData(domain,types,value){return this._fail("VoidSigner cannot sign typed data","signTypedData")}connect(provider){return new VoidSigner(this.address,provider)}}var minimalisticAssert=assert;function assert(val,msg){if(!val)throw new Error(msg||"Assertion failed")}assert.equal=function assertEqual(l,r,msg){if(l!=r)throw new Error(msg||"Assertion failed: "+l+" != "+r)};var inherits_browser=createCommonjsModule(function(module){if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}}else{module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}}}});var inherits=createCommonjsModule(function(module){try{var util=null;if(typeof util.inherits!=="function")throw"";module.exports=util.inherits}catch(e){module.exports=inherits_browser}});"use strict";var inherits_1=inherits;function toArray(msg,enc){if(Array.isArray(msg))return msg.slice();if(!msg)return[];var res=[];if(typeof msg==="string"){if(!enc){for(var i=0;i<msg.length;i++){var c=msg.charCodeAt(i);var hi=c>>8;var lo=c&255;if(hi)res.push(hi,lo);else res.push(lo)}}else if(enc==="hex"){msg=msg.replace(/[^a-z0-9]+/gi,"");if(msg.length%2!==0)msg="0"+msg;for(i=0;i<msg.length;i+=2)res.push(parseInt(msg[i]+msg[i+1],16))}}else{for(i=0;i<msg.length;i++)res[i]=msg[i]|0}return res}var toArray_1=toArray;function toHex$1(msg){var res="";for(var i=0;i<msg.length;i++)res+=zero2(msg[i].toString(16));return res}var toHex_1=toHex$1;function htonl(w){var res=w>>>24|w>>>8&65280|w<<8&16711680|(w&255)<<24;return res>>>0}var htonl_1=htonl;function toHex32(msg,endian){var res="";for(var i=0;i<msg.length;i++){var w=msg[i];if(endian==="little")w=htonl(w);res+=zero8(w.toString(16))}return res}var toHex32_1=toHex32;function zero2(word){if(word.length===1)return"0"+word;else return word}var zero2_1=zero2;function zero8(word){if(word.length===7)return"0"+word;else if(word.length===6)return"00"+word;else if(word.length===5)return"000"+word;else if(word.length===4)return"0000"+word;else if(word.length===3)return"00000"+word;else if(word.length===2)return"000000"+word;else if(word.length===1)return"0000000"+word;else return word}var zero8_1=zero8;function join32(msg,start,end,endian){var len=end-start;minimalisticAssert(len%4===0);var res=new Array(len/4);for(var i=0,k=start;i<res.length;i++,k+=4){var w;if(endian==="big")w=msg[k]<<24|msg[k+1]<<16|msg[k+2]<<8|msg[k+3];else w=msg[k+3]<<24|msg[k+2]<<16|msg[k+1]<<8|msg[k];res[i]=w>>>0}return res}var join32_1=join32;function split32(msg,endian){var res=new Array(msg.length*4);for(var i=0,k=0;i<msg.length;i++,k+=4){var m=msg[i];if(endian==="big"){res[k]=m>>>24;res[k+1]=m>>>16&255;res[k+2]=m>>>8&255;res[k+3]=m&255}else{res[k+3]=m>>>24;res[k+2]=m>>>16&255;res[k+1]=m>>>8&255;res[k]=m&255}}return res}var split32_1=split32;function rotr32(w,b){return w>>>b|w<<32-b}var rotr32_1=rotr32;function rotl32(w,b){return w<<b|w>>>32-b}var rotl32_1=rotl32;function sum32(a,b){return a+b>>>0}var sum32_1=sum32;function sum32_3(a,b,c){return a+b+c>>>0}var sum32_3_1=sum32_3;function sum32_4(a,b,c,d){return a+b+c+d>>>0}var sum32_4_1=sum32_4;function sum32_5(a,b,c,d,e){return a+b+c+d+e>>>0}var sum32_5_1=sum32_5;function sum64(buf,pos,ah,al){var bh=buf[pos];var bl=buf[pos+1];var lo=al+bl>>>0;var hi=(lo<al?1:0)+ah+bh;buf[pos]=hi>>>0;buf[pos+1]=lo}var sum64_1=sum64;function sum64_hi(ah,al,bh,bl){var lo=al+bl>>>0;var hi=(lo<al?1:0)+ah+bh;return hi>>>0}var sum64_hi_1=sum64_hi;function sum64_lo(ah,al,bh,bl){var lo=al+bl;return lo>>>0}var sum64_lo_1=sum64_lo;function sum64_4_hi(ah,al,bh,bl,ch,cl,dh,dl){var carry=0;var lo=al;lo=lo+bl>>>0;carry+=lo<al?1:0;lo=lo+cl>>>0;carry+=lo<cl?1:0;lo=lo+dl>>>0;carry+=lo<dl?1:0;var hi=ah+bh+ch+dh+carry;return hi>>>0}var sum64_4_hi_1=sum64_4_hi;function sum64_4_lo(ah,al,bh,bl,ch,cl,dh,dl){var lo=al+bl+cl+dl;return lo>>>0}var sum64_4_lo_1=sum64_4_lo;function sum64_5_hi(ah,al,bh,bl,ch,cl,dh,dl,eh,el){var carry=0;var lo=al;lo=lo+bl>>>0;carry+=lo<al?1:0;lo=lo+cl>>>0;carry+=lo<cl?1:0;lo=lo+dl>>>0;carry+=lo<dl?1:0;lo=lo+el>>>0;carry+=lo<el?1:0;var hi=ah+bh+ch+dh+eh+carry;return hi>>>0}var sum64_5_hi_1=sum64_5_hi;function sum64_5_lo(ah,al,bh,bl,ch,cl,dh,dl,eh,el){var lo=al+bl+cl+dl+el;return lo>>>0}var sum64_5_lo_1=sum64_5_lo;function rotr64_hi(ah,al,num){var r=al<<32-num|ah>>>num;return r>>>0}var rotr64_hi_1=rotr64_hi;function rotr64_lo(ah,al,num){var r=ah<<32-num|al>>>num;return r>>>0}var rotr64_lo_1=rotr64_lo;function shr64_hi(ah,al,num){return ah>>>num}var shr64_hi_1=shr64_hi;function shr64_lo(ah,al,num){var r=ah<<32-num|al>>>num;return r>>>0}var shr64_lo_1=shr64_lo;var utils={inherits:inherits_1,toArray:toArray_1,toHex:toHex_1,htonl:htonl_1,toHex32:toHex32_1,zero2:zero2_1,zero8:zero8_1,join32:join32_1,split32:split32_1,rotr32:rotr32_1,rotl32:rotl32_1,sum32:sum32_1,sum32_3:sum32_3_1,sum32_4:sum32_4_1,sum32_5:sum32_5_1,sum64:sum64_1,sum64_hi:sum64_hi_1,sum64_lo:sum64_lo_1,sum64_4_hi:sum64_4_hi_1,sum64_4_lo:sum64_4_lo_1,sum64_5_hi:sum64_5_hi_1,sum64_5_lo:sum64_5_lo_1,rotr64_hi:rotr64_hi_1,rotr64_lo:rotr64_lo_1,shr64_hi:shr64_hi_1,shr64_lo:shr64_lo_1};"use strict";function BlockHash(){this.pending=null;this.pendingTotal=0;this.blockSize=this.constructor.blockSize;this.outSize=this.constructor.outSize;this.hmacStrength=this.constructor.hmacStrength;this.padLength=this.constructor.padLength/8;this.endian="big";this._delta8=this.blockSize/8;this._delta32=this.blockSize/32}var BlockHash_1=BlockHash;BlockHash.prototype.update=function update(msg,enc){msg=utils.toArray(msg,enc);if(!this.pending)this.pending=msg;else this.pending=this.pending.concat(msg);this.pendingTotal+=msg.length;if(this.pending.length>=this._delta8){msg=this.pending;var r=msg.length%this._delta8;this.pending=msg.slice(msg.length-r,msg.length);if(this.pending.length===0)this.pending=null;msg=utils.join32(msg,0,msg.length-r,this.endian);for(var i=0;i<msg.length;i+=this._delta32)this._update(msg,i,i+this._delta32)}return this};BlockHash.prototype.digest=function digest(enc){this.update(this._pad());minimalisticAssert(this.pending===null);return this._digest(enc)};BlockHash.prototype._pad=function pad(){var len=this.pendingTotal;var bytes=this._delta8;var k=bytes-(len+this.padLength)%bytes;var res=new Array(k+this.padLength);res[0]=128;for(var i=1;i<k;i++)res[i]=0;len<<=3;if(this.endian==="big"){for(var t=8;t<this.padLength;t++)res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=len>>>24&255;res[i++]=len>>>16&255;res[i++]=len>>>8&255;res[i++]=len&255}else{res[i++]=len&255;res[i++]=len>>>8&255;res[i++]=len>>>16&255;res[i++]=len>>>24&255;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;for(t=8;t<this.padLength;t++)res[i++]=0}return res};var common={BlockHash:BlockHash_1};"use strict";var rotr32$1=utils.rotr32;function ft_1(s,x,y,z){if(s===0)return ch32(x,y,z);if(s===1||s===3)return p32(x,y,z);if(s===2)return maj32(x,y,z)}var ft_1_1=ft_1;function ch32(x,y,z){return x&y^~x&z}var ch32_1=ch32;function maj32(x,y,z){return x&y^x&z^y&z}var maj32_1=maj32;function p32(x,y,z){return x^y^z}var p32_1=p32;function s0_256(x){return rotr32$1(x,2)^rotr32$1(x,13)^rotr32$1(x,22)}var s0_256_1=s0_256;function s1_256(x){return rotr32$1(x,6)^rotr32$1(x,11)^rotr32$1(x,25)}var s1_256_1=s1_256;function g0_256(x){return rotr32$1(x,7)^rotr32$1(x,18)^x>>>3}var g0_256_1=g0_256;function g1_256(x){return rotr32$1(x,17)^rotr32$1(x,19)^x>>>10}var g1_256_1=g1_256;var common$1={ft_1:ft_1_1,ch32:ch32_1,maj32:maj32_1,p32:p32_1,s0_256:s0_256_1,s1_256:s1_256_1,g0_256:g0_256_1,g1_256:g1_256_1};"use strict";var rotl32$1=utils.rotl32;var sum32$1=utils.sum32;var sum32_5$1=utils.sum32_5;var ft_1$1=common$1.ft_1;var BlockHash$1=common.BlockHash;var sha1_K=[1518500249,1859775393,2400959708,3395469782];function SHA1(){if(!(this instanceof SHA1))return new SHA1;BlockHash$1.call(this);this.h=[1732584193,4023233417,2562383102,271733878,3285377520];this.W=new Array(80)}utils.inherits(SHA1,BlockHash$1);var _1=SHA1;SHA1.blockSize=512;SHA1.outSize=160;SHA1.hmacStrength=80;SHA1.padLength=64;SHA1.prototype._update=function _update(msg,start){var W=this.W;for(var i=0;i<16;i++)W[i]=msg[start+i];for(;i<W.length;i++)W[i]=rotl32$1(W[i-3]^W[i-8]^W[i-14]^W[i-16],1);var a=this.h[0];var b=this.h[1];var c=this.h[2];var d=this.h[3];var e=this.h[4];for(i=0;i<W.length;i++){var s=~~(i/20);var t=sum32_5$1(rotl32$1(a,5),ft_1$1(s,b,c,d),e,W[i],sha1_K[s]);e=d;d=c;c=rotl32$1(b,30);b=a;a=t}this.h[0]=sum32$1(this.h[0],a);this.h[1]=sum32$1(this.h[1],b);this.h[2]=sum32$1(this.h[2],c);this.h[3]=sum32$1(this.h[3],d);this.h[4]=sum32$1(this.h[4],e)};SHA1.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"big");else return utils.split32(this.h,"big")};"use strict";var sum32$2=utils.sum32;var sum32_4$1=utils.sum32_4;var sum32_5$2=utils.sum32_5;var ch32$1=common$1.ch32;var maj32$1=common$1.maj32;var s0_256$1=common$1.s0_256;var s1_256$1=common$1.s1_256;var g0_256$1=common$1.g0_256;var g1_256$1=common$1.g1_256;var BlockHash$2=common.BlockHash;var sha256_K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function SHA256(){if(!(this instanceof SHA256))return new SHA256;BlockHash$2.call(this);this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];this.k=sha256_K;this.W=new Array(64)}utils.inherits(SHA256,BlockHash$2);var _256=SHA256;SHA256.blockSize=512;SHA256.outSize=256;SHA256.hmacStrength=192;SHA256.padLength=64;SHA256.prototype._update=function _update(msg,start){var W=this.W;for(var i=0;i<16;i++)W[i]=msg[start+i];for(;i<W.length;i++)W[i]=sum32_4$1(g1_256$1(W[i-2]),W[i-7],g0_256$1(W[i-15]),W[i-16]);var a=this.h[0];var b=this.h[1];var c=this.h[2];var d=this.h[3];var e=this.h[4];var f=this.h[5];var g=this.h[6];var h=this.h[7];minimalisticAssert(this.k.length===W.length);for(i=0;i<W.length;i++){var T1=sum32_5$2(h,s1_256$1(e),ch32$1(e,f,g),this.k[i],W[i]);var T2=sum32$2(s0_256$1(a),maj32$1(a,b,c));h=g;g=f;f=e;e=sum32$2(d,T1);d=c;c=b;b=a;a=sum32$2(T1,T2)}this.h[0]=sum32$2(this.h[0],a);this.h[1]=sum32$2(this.h[1],b);this.h[2]=sum32$2(this.h[2],c);this.h[3]=sum32$2(this.h[3],d);this.h[4]=sum32$2(this.h[4],e);this.h[5]=sum32$2(this.h[5],f);this.h[6]=sum32$2(this.h[6],g);this.h[7]=sum32$2(this.h[7],h)};SHA256.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"big");else return utils.split32(this.h,"big")};"use strict";function SHA224(){if(!(this instanceof SHA224))return new SHA224;_256.call(this);this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}utils.inherits(SHA224,_256);var _224=SHA224;SHA224.blockSize=512;SHA224.outSize=224;SHA224.hmacStrength=192;SHA224.padLength=64;SHA224.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h.slice(0,7),"big");else return utils.split32(this.h.slice(0,7),"big")};"use strict";var rotr64_hi$1=utils.rotr64_hi;var rotr64_lo$1=utils.rotr64_lo;var shr64_hi$1=utils.shr64_hi;var shr64_lo$1=utils.shr64_lo;var sum64$1=utils.sum64;var sum64_hi$1=utils.sum64_hi;var sum64_lo$1=utils.sum64_lo;var sum64_4_hi$1=utils.sum64_4_hi;var sum64_4_lo$1=utils.sum64_4_lo;var sum64_5_hi$1=utils.sum64_5_hi;var sum64_5_lo$1=utils.sum64_5_lo;var BlockHash$3=common.BlockHash;var sha512_K=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function SHA512(){if(!(this instanceof SHA512))return new SHA512;BlockHash$3.call(this);this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209];this.k=sha512_K;this.W=new Array(160)}utils.inherits(SHA512,BlockHash$3);var _512=SHA512;SHA512.blockSize=1024;SHA512.outSize=512;SHA512.hmacStrength=192;SHA512.padLength=128;SHA512.prototype._prepareBlock=function _prepareBlock(msg,start){var W=this.W;for(var i=0;i<32;i++)W[i]=msg[start+i];for(;i<W.length;i+=2){var c0_hi=g1_512_hi(W[i-4],W[i-3]);var c0_lo=g1_512_lo(W[i-4],W[i-3]);var c1_hi=W[i-14];var c1_lo=W[i-13];var c2_hi=g0_512_hi(W[i-30],W[i-29]);var c2_lo=g0_512_lo(W[i-30],W[i-29]);var c3_hi=W[i-32];var c3_lo=W[i-31];W[i]=sum64_4_hi$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo);W[i+1]=sum64_4_lo$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo)}};SHA512.prototype._update=function _update(msg,start){this._prepareBlock(msg,start);var W=this.W;var ah=this.h[0];var al=this.h[1];var bh=this.h[2];var bl=this.h[3];var ch=this.h[4];var cl=this.h[5];var dh=this.h[6];var dl=this.h[7];var eh=this.h[8];var el=this.h[9];var fh=this.h[10];var fl=this.h[11];var gh=this.h[12];var gl=this.h[13];var hh=this.h[14];var hl=this.h[15];minimalisticAssert(this.k.length===W.length);for(var i=0;i<W.length;i+=2){var c0_hi=hh;var c0_lo=hl;var c1_hi=s1_512_hi(eh,el);var c1_lo=s1_512_lo(eh,el);var c2_hi=ch64_hi(eh,el,fh,fl,gh,gl);var c2_lo=ch64_lo(eh,el,fh,fl,gh,gl);var c3_hi=this.k[i];var c3_lo=this.k[i+1];var c4_hi=W[i];var c4_lo=W[i+1];var T1_hi=sum64_5_hi$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo,c4_hi,c4_lo);var T1_lo=sum64_5_lo$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo,c4_hi,c4_lo);c0_hi=s0_512_hi(ah,al);c0_lo=s0_512_lo(ah,al);c1_hi=maj64_hi(ah,al,bh,bl,ch,cl);c1_lo=maj64_lo(ah,al,bh,bl,ch,cl);var T2_hi=sum64_hi$1(c0_hi,c0_lo,c1_hi,c1_lo);var T2_lo=sum64_lo$1(c0_hi,c0_lo,c1_hi,c1_lo);hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;eh=sum64_hi$1(dh,dl,T1_hi,T1_lo);el=sum64_lo$1(dl,dl,T1_hi,T1_lo);dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;ah=sum64_hi$1(T1_hi,T1_lo,T2_hi,T2_lo);al=sum64_lo$1(T1_hi,T1_lo,T2_hi,T2_lo)}sum64$1(this.h,0,ah,al);sum64$1(this.h,2,bh,bl);sum64$1(this.h,4,ch,cl);sum64$1(this.h,6,dh,dl);sum64$1(this.h,8,eh,el);sum64$1(this.h,10,fh,fl);sum64$1(this.h,12,gh,gl);sum64$1(this.h,14,hh,hl)};SHA512.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"big");else return utils.split32(this.h,"big")};function ch64_hi(xh,xl,yh,yl,zh){var r=xh&yh^~xh&zh;if(r<0)r+=4294967296;return r}function ch64_lo(xh,xl,yh,yl,zh,zl){var r=xl&yl^~xl&zl;if(r<0)r+=4294967296;return r}function maj64_hi(xh,xl,yh,yl,zh){var r=xh&yh^xh&zh^yh&zh;if(r<0)r+=4294967296;return r}function maj64_lo(xh,xl,yh,yl,zh,zl){var r=xl&yl^xl&zl^yl&zl;if(r<0)r+=4294967296;return r}function s0_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,28);var c1_hi=rotr64_hi$1(xl,xh,2);var c2_hi=rotr64_hi$1(xl,xh,7);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function s0_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,28);var c1_lo=rotr64_lo$1(xl,xh,2);var c2_lo=rotr64_lo$1(xl,xh,7);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}function s1_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,14);var c1_hi=rotr64_hi$1(xh,xl,18);var c2_hi=rotr64_hi$1(xl,xh,9);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function s1_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,14);var c1_lo=rotr64_lo$1(xh,xl,18);var c2_lo=rotr64_lo$1(xl,xh,9);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}function g0_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,1);var c1_hi=rotr64_hi$1(xh,xl,8);var c2_hi=shr64_hi$1(xh,xl,7);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function g0_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,1);var c1_lo=rotr64_lo$1(xh,xl,8);var c2_lo=shr64_lo$1(xh,xl,7);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}function g1_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,19);var c1_hi=rotr64_hi$1(xl,xh,29);var c2_hi=shr64_hi$1(xh,xl,6);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=4294967296;return r}function g1_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,19);var c1_lo=rotr64_lo$1(xl,xh,29);var c2_lo=shr64_lo$1(xh,xl,6);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=4294967296;return r}"use strict";function SHA384(){if(!(this instanceof SHA384))return new SHA384;_512.call(this);this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}utils.inherits(SHA384,_512);var _384=SHA384;SHA384.blockSize=1024;SHA384.outSize=384;SHA384.hmacStrength=192;SHA384.padLength=128;SHA384.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h.slice(0,12),"big");else return utils.split32(this.h.slice(0,12),"big")};"use strict";var sha1=_1;var sha224=_224;var sha256=_256;var sha384=_384;var sha512=_512;var sha={sha1:sha1,sha224:sha224,sha256:sha256,sha384:sha384,sha512:sha512};"use strict";var rotl32$2=utils.rotl32;var sum32$3=utils.sum32;var sum32_3$1=utils.sum32_3;var sum32_4$2=utils.sum32_4;var BlockHash$4=common.BlockHash;function RIPEMD160(){if(!(this instanceof RIPEMD160))return new RIPEMD160;BlockHash$4.call(this);this.h=[1732584193,4023233417,2562383102,271733878,3285377520];this.endian="little"}utils.inherits(RIPEMD160,BlockHash$4);var ripemd160=RIPEMD160;RIPEMD160.blockSize=512;RIPEMD160.outSize=160;RIPEMD160.hmacStrength=192;RIPEMD160.padLength=64;RIPEMD160.prototype._update=function update(msg,start){var A=this.h[0];var B=this.h[1];var C=this.h[2];var D=this.h[3];var E=this.h[4];var Ah=A;var Bh=B;var Ch=C;var Dh=D;var Eh=E;for(var j=0;j<80;j++){var T=sum32$3(rotl32$2(sum32_4$2(A,f(j,B,C,D),msg[r[j]+start],K(j)),s[j]),E);A=E;E=D;D=rotl32$2(C,10);C=B;B=T;T=sum32$3(rotl32$2(sum32_4$2(Ah,f(79-j,Bh,Ch,Dh),msg[rh[j]+start],Kh(j)),sh[j]),Eh);Ah=Eh;Eh=Dh;Dh=rotl32$2(Ch,10);Ch=Bh;Bh=T}T=sum32_3$1(this.h[1],C,Dh);this.h[1]=sum32_3$1(this.h[2],D,Eh);this.h[2]=sum32_3$1(this.h[3],E,Ah);this.h[3]=sum32_3$1(this.h[4],A,Bh);this.h[4]=sum32_3$1(this.h[0],B,Ch);this.h[0]=T};RIPEMD160.prototype._digest=function digest(enc){if(enc==="hex")return utils.toHex32(this.h,"little");else return utils.split32(this.h,"little")};function f(j,x,y,z){if(j<=15)return x^y^z;else if(j<=31)return x&y|~x&z;else if(j<=47)return(x|~y)^z;else if(j<=63)return x&z|y&~z;else return x^(y|~z)}function K(j){if(j<=15)return 0;else if(j<=31)return 1518500249;else if(j<=47)return 1859775393;else if(j<=63)return 2400959708;else return 2840853838}function Kh(j){if(j<=15)return 1352829926;else if(j<=31)return 1548603684;else if(j<=47)return 1836072691;else if(j<=63)return 2053994217;else return 0}var r=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13];var rh=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11];var s=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6];var sh=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11];var ripemd={ripemd160:ripemd160};"use strict";function Hmac(hash,key,enc){if(!(this instanceof Hmac))return new Hmac(hash,key,enc);this.Hash=hash;this.blockSize=hash.blockSize/8;this.outSize=hash.outSize/8;this.inner=null;this.outer=null;this._init(utils.toArray(key,enc))}var hmac=Hmac;Hmac.prototype._init=function init(key){if(key.length>this.blockSize)key=(new this.Hash).update(key).digest();minimalisticAssert(key.length<=this.blockSize);for(var i=key.length;i<this.blockSize;i++)key.push(0);for(i=0;i<key.length;i++)key[i]^=54;this.inner=(new this.Hash).update(key);for(i=0;i<key.length;i++)key[i]^=106;this.outer=(new this.Hash).update(key)};Hmac.prototype.update=function update(msg,enc){this.inner.update(msg,enc);return this};Hmac.prototype.digest=function digest(enc){this.outer.update(this.inner.digest());return this.outer.digest(enc)};var hash_1=createCommonjsModule(function(module,exports){var hash=exports;hash.utils=utils;hash.common=common;hash.sha=sha;hash.ripemd=ripemd;hash.hmac=hmac;hash.sha1=hash.sha.sha1;hash.sha256=hash.sha.sha256;hash.sha224=hash.sha.sha224;hash.sha384=hash.sha.sha384;hash.sha512=hash.sha.sha512;hash.ripemd160=hash.ripemd.ripemd160});var commonjsGlobal$1=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof __webpack_require__.g!=="undefined"?__webpack_require__.g:typeof self!=="undefined"?self:{};function getDefaultExportFromCjs$1(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}function createCommonjsModule$1(fn,basedir,module){return module={path:basedir,exports:{},require:function(path,base){return commonjsRequire$1(path,base===undefined||base===null?module.path:base)}},fn(module,module.exports),module.exports}function getDefaultExportFromNamespaceIfPresent$1(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")?n["default"]:n}function getDefaultExportFromNamespaceIfNotNamed$1(n){return n&&Object.prototype.hasOwnProperty.call(n,"default")&&Object.keys(n).length===1?n["default"]:n}function getAugmentedNamespace$1(n){if(n.__esModule)return n;var a=Object.defineProperty({},"__esModule",{value:true});Object.keys(n).forEach(function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:true,get:function(){return n[k]}})});return a}function commonjsRequire$1(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var minimalisticAssert$1=assert$1;function assert$1(val,msg){if(!val)throw new Error(msg||"Assertion failed")}assert$1.equal=function assertEqual(l,r,msg){if(l!=r)throw new Error(msg||"Assertion failed: "+l+" != "+r)};var utils_1=createCommonjsModule$1(function(module,exports){"use strict";var utils=exports;function toArray(msg,enc){if(Array.isArray(msg))return msg.slice();if(!msg)return[];var res=[];if(typeof msg!=="string"){for(var i=0;i<msg.length;i++)res[i]=msg[i]|0;return res}if(enc==="hex"){msg=msg.replace(/[^a-z0-9]+/gi,"");if(msg.length%2!==0)msg="0"+msg;for(var i=0;i<msg.length;i+=2)res.push(parseInt(msg[i]+msg[i+1],16))}else{for(var i=0;i<msg.length;i++){var c=msg.charCodeAt(i);var hi=c>>8;var lo=c&255;if(hi)res.push(hi,lo);else res.push(lo)}}return res}utils.toArray=toArray;function zero2(word){if(word.length===1)return"0"+word;else return word}utils.zero2=zero2;function toHex(msg){var res="";for(var i=0;i<msg.length;i++)res+=zero2(msg[i].toString(16));return res}utils.toHex=toHex;utils.encode=function encode(arr,enc){if(enc==="hex")return toHex(arr);else return arr}});var utils_1$1=createCommonjsModule$1(function(module,exports){"use strict";var utils=exports;utils.assert=minimalisticAssert$1;utils.toArray=utils_1.toArray;utils.zero2=utils_1.zero2;utils.toHex=utils_1.toHex;utils.encode=utils_1.encode;function getNAF(num,w,bits){var naf=new Array(Math.max(num.bitLength(),bits)+1);naf.fill(0);var ws=1<<w+1;var k=num.clone();for(var i=0;i<naf.length;i++){var z;var mod=k.andln(ws-1);if(k.isOdd()){if(mod>(ws>>1)-1)z=(ws>>1)-mod;else z=mod;k.isubn(z)}else{z=0}naf[i]=z;k.iushrn(1)}return naf}utils.getNAF=getNAF;function getJSF(k1,k2){var jsf=[[],[]];k1=k1.clone();k2=k2.clone();var d1=0;var d2=0;var m8;while(k1.cmpn(-d1)>0||k2.cmpn(-d2)>0){var m14=k1.andln(3)+d1&3;var m24=k2.andln(3)+d2&3;if(m14===3)m14=-1;if(m24===3)m24=-1;var u1;if((m14&1)===0){u1=0}else{m8=k1.andln(7)+d1&7;if((m8===3||m8===5)&&m24===2)u1=-m14;else u1=m14}jsf[0].push(u1);var u2;if((m24&1)===0){u2=0}else{m8=k2.andln(7)+d2&7;if((m8===3||m8===5)&&m14===2)u2=-m24;else u2=m24}jsf[1].push(u2);if(2*d1===u1+1)d1=1-d1;if(2*d2===u2+1)d2=1-d2;k1.iushrn(1);k2.iushrn(1)}return jsf}utils.getJSF=getJSF;function cachedProperty(obj,name,computer){var key="_"+name;obj.prototype[name]=function cachedProperty(){return this[key]!==undefined?this[key]:this[key]=computer.call(this)}}utils.cachedProperty=cachedProperty;function parseBytes(bytes){return typeof bytes==="string"?utils.toArray(bytes,"hex"):bytes}utils.parseBytes=parseBytes;function intFromLE(bytes){return new bn(bytes,"hex","le")}utils.intFromLE=intFromLE});"use strict";var getNAF=utils_1$1.getNAF;var getJSF=utils_1$1.getJSF;var assert$1$1=utils_1$1.assert;function BaseCurve(type,conf){this.type=type;this.p=new bn(conf.p,16);this.red=conf.prime?bn.red(conf.prime):bn.mont(this.p);this.zero=new bn(0).toRed(this.red);this.one=new bn(1).toRed(this.red);this.two=new bn(2).toRed(this.red);this.n=conf.n&&new bn(conf.n,16);this.g=conf.g&&this.pointFromJSON(conf.g,conf.gRed);this._wnafT1=new Array(4);this._wnafT2=new Array(4);this._wnafT3=new Array(4);this._wnafT4=new Array(4);this._bitLength=this.n?this.n.bitLength():0;var adjustCount=this.n&&this.p.div(this.n);if(!adjustCount||adjustCount.cmpn(100)>0){this.redN=null}else{this._maxwellTrick=true;this.redN=this.n.toRed(this.red)}}var base=BaseCurve;BaseCurve.prototype.point=function point(){throw new Error("Not implemented")};BaseCurve.prototype.validate=function validate(){throw new Error("Not implemented")};BaseCurve.prototype._fixedNafMul=function _fixedNafMul(p,k){assert$1$1(p.precomputed);var doubles=p._getDoubles();var naf=getNAF(k,1,this._bitLength);var I=(1<<doubles.step+1)-(doubles.step%2===0?2:1);I/=3;var repr=[];var j;var nafW;for(j=0;j<naf.length;j+=doubles.step){nafW=0;for(var l=j+doubles.step-1;l>=j;l--)nafW=(nafW<<1)+naf[l];repr.push(nafW)}var a=this.jpoint(null,null,null);var b=this.jpoint(null,null,null);for(var i=I;i>0;i--){for(j=0;j<repr.length;j++){nafW=repr[j];if(nafW===i)b=b.mixedAdd(doubles.points[j]);else if(nafW===-i)b=b.mixedAdd(doubles.points[j].neg())}a=a.add(b)}return a.toP()};BaseCurve.prototype._wnafMul=function _wnafMul(p,k){var w=4;var nafPoints=p._getNAFPoints(w);w=nafPoints.wnd;var wnd=nafPoints.points;var naf=getNAF(k,w,this._bitLength);var acc=this.jpoint(null,null,null);for(var i=naf.length-1;i>=0;i--){for(var l=0;i>=0&&naf[i]===0;i--)l++;if(i>=0)l++;acc=acc.dblp(l);if(i<0)break;var z=naf[i];assert$1$1(z!==0);if(p.type==="affine"){if(z>0)acc=acc.mixedAdd(wnd[z-1>>1]);else acc=acc.mixedAdd(wnd[-z-1>>1].neg())}else{if(z>0)acc=acc.add(wnd[z-1>>1]);else acc=acc.add(wnd[-z-1>>1].neg())}}return p.type==="affine"?acc.toP():acc};BaseCurve.prototype._wnafMulAdd=function _wnafMulAdd(defW,points,coeffs,len,jacobianResult){var wndWidth=this._wnafT1;var wnd=this._wnafT2;var naf=this._wnafT3;var max=0;var i;var j;var p;for(i=0;i<len;i++){p=points[i];var nafPoints=p._getNAFPoints(defW);wndWidth[i]=nafPoints.wnd;wnd[i]=nafPoints.points}for(i=len-1;i>=1;i-=2){var a=i-1;var b=i;if(wndWidth[a]!==1||wndWidth[b]!==1){naf[a]=getNAF(coeffs[a],wndWidth[a],this._bitLength);naf[b]=getNAF(coeffs[b],wndWidth[b],this._bitLength);max=Math.max(naf[a].length,max);max=Math.max(naf[b].length,max);continue}var comb=[points[a],null,null,points[b]];if(points[a].y.cmp(points[b].y)===0){comb[1]=points[a].add(points[b]);comb[2]=points[a].toJ().mixedAdd(points[b].neg())}else if(points[a].y.cmp(points[b].y.redNeg())===0){comb[1]=points[a].toJ().mixedAdd(points[b]);comb[2]=points[a].add(points[b].neg())}else{comb[1]=points[a].toJ().mixedAdd(points[b]);comb[2]=points[a].toJ().mixedAdd(points[b].neg())}var index=[-3,-1,-5,-7,0,7,5,1,3];var jsf=getJSF(coeffs[a],coeffs[b]);max=Math.max(jsf[0].length,max);naf[a]=new Array(max);naf[b]=new Array(max);for(j=0;j<max;j++){var ja=jsf[0][j]|0;var jb=jsf[1][j]|0;naf[a][j]=index[(ja+1)*3+(jb+1)];naf[b][j]=0;wnd[a]=comb}}var acc=this.jpoint(null,null,null);var tmp=this._wnafT4;for(i=max;i>=0;i--){var k=0;while(i>=0){var zero=true;for(j=0;j<len;j++){tmp[j]=naf[j][i]|0;if(tmp[j]!==0)zero=false}if(!zero)break;k++;i--}if(i>=0)k++;acc=acc.dblp(k);if(i<0)break;for(j=0;j<len;j++){var z=tmp[j];p;if(z===0)continue;else if(z>0)p=wnd[j][z-1>>1];else if(z<0)p=wnd[j][-z-1>>1].neg();if(p.type==="affine")acc=acc.mixedAdd(p);else acc=acc.add(p)}}for(i=0;i<len;i++)wnd[i]=null;if(jacobianResult)return acc;else return acc.toP()};function BasePoint(curve,type){this.curve=curve;this.type=type;this.precomputed=null}BaseCurve.BasePoint=BasePoint;BasePoint.prototype.eq=function eq(){throw new Error("Not implemented")};BasePoint.prototype.validate=function validate(){return this.curve.validate(this)};BaseCurve.prototype.decodePoint=function decodePoint(bytes,enc){bytes=utils_1$1.toArray(bytes,enc);var len=this.p.byteLength();if((bytes[0]===4||bytes[0]===6||bytes[0]===7)&&bytes.length-1===2*len){if(bytes[0]===6)assert$1$1(bytes[bytes.length-1]%2===0);else if(bytes[0]===7)assert$1$1(bytes[bytes.length-1]%2===1);var res=this.point(bytes.slice(1,1+len),bytes.slice(1+len,1+2*len));return res}else if((bytes[0]===2||bytes[0]===3)&&bytes.length-1===len){return this.pointFromX(bytes.slice(1,1+len),bytes[0]===3)}throw new Error("Unknown point format")};BasePoint.prototype.encodeCompressed=function encodeCompressed(enc){return this.encode(enc,true)};BasePoint.prototype._encode=function _encode(compact){var len=this.curve.p.byteLength();var x=this.getX().toArray("be",len);if(compact)return[this.getY().isEven()?2:3].concat(x);return[4].concat(x,this.getY().toArray("be",len))};BasePoint.prototype.encode=function encode(enc,compact){return utils_1$1.encode(this._encode(compact),enc)};BasePoint.prototype.precompute=function precompute(power){if(this.precomputed)return this;var precomputed={doubles:null,naf:null,beta:null};precomputed.naf=this._getNAFPoints(8);precomputed.doubles=this._getDoubles(4,power);precomputed.beta=this._getBeta();this.precomputed=precomputed;return this};BasePoint.prototype._hasDoubles=function _hasDoubles(k){if(!this.precomputed)return false;var doubles=this.precomputed.doubles;if(!doubles)return false;return doubles.points.length>=Math.ceil((k.bitLength()+1)/doubles.step)};BasePoint.prototype._getDoubles=function _getDoubles(step,power){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;var doubles=[this];var acc=this;for(var i=0;i<power;i+=step){for(var j=0;j<step;j++)acc=acc.dbl();doubles.push(acc)}return{step:step,points:doubles}};BasePoint.prototype._getNAFPoints=function _getNAFPoints(wnd){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;var res=[this];var max=(1<<wnd)-1;var dbl=max===1?null:this.dbl();for(var i=1;i<max;i++)res[i]=res[i-1].add(dbl);return{wnd:wnd,points:res}};BasePoint.prototype._getBeta=function _getBeta(){return null};BasePoint.prototype.dblp=function dblp(k){var r=this;for(var i=0;i<k;i++)r=r.dbl();return r};var inherits_browser$1=createCommonjsModule$1(function(module){if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}}else{module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}}}});"use strict";var assert$2=utils_1$1.assert;function ShortCurve(conf){base.call(this,"short",conf);this.a=new bn(conf.a,16).toRed(this.red);this.b=new bn(conf.b,16).toRed(this.red);this.tinv=this.two.redInvm();this.zeroA=this.a.fromRed().cmpn(0)===0;this.threeA=this.a.fromRed().sub(this.p).cmpn(-3)===0;this.endo=this._getEndomorphism(conf);this._endoWnafT1=new Array(4);this._endoWnafT2=new Array(4)}inherits_browser$1(ShortCurve,base);var short_1=ShortCurve;ShortCurve.prototype._getEndomorphism=function _getEndomorphism(conf){if(!this.zeroA||!this.g||!this.n||this.p.modn(3)!==1)return;var beta;var lambda;if(conf.beta){beta=new bn(conf.beta,16).toRed(this.red)}else{var betas=this._getEndoRoots(this.p);beta=betas[0].cmp(betas[1])<0?betas[0]:betas[1];beta=beta.toRed(this.red)}if(conf.lambda){lambda=new bn(conf.lambda,16)}else{var lambdas=this._getEndoRoots(this.n);if(this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta))===0){lambda=lambdas[0]}else{lambda=lambdas[1];assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta))===0)}}var basis;if(conf.basis){basis=conf.basis.map(function(vec){return{a:new bn(vec.a,16),b:new bn(vec.b,16)}})}else{basis=this._getEndoBasis(lambda)}return{beta:beta,lambda:lambda,basis:basis}};ShortCurve.prototype._getEndoRoots=function _getEndoRoots(num){var red=num===this.p?this.red:bn.mont(num);var tinv=new bn(2).toRed(red).redInvm();var ntinv=tinv.redNeg();var s=new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);var l1=ntinv.redAdd(s).fromRed();var l2=ntinv.redSub(s).fromRed();return[l1,l2]};ShortCurve.prototype._getEndoBasis=function _getEndoBasis(lambda){var aprxSqrt=this.n.ushrn(Math.floor(this.n.bitLength()/2));var u=lambda;var v=this.n.clone();var x1=new bn(1);var y1=new bn(0);var x2=new bn(0);var y2=new bn(1);var a0;var b0;var a1;var b1;var a2;var b2;var prevR;var i=0;var r;var x;while(u.cmpn(0)!==0){var q=v.div(u);r=v.sub(q.mul(u));x=x2.sub(q.mul(x1));var y=y2.sub(q.mul(y1));if(!a1&&r.cmp(aprxSqrt)<0){a0=prevR.neg();b0=x1;a1=r.neg();b1=x}else if(a1&&++i===2){break}prevR=r;v=u;u=r;x2=x1;x1=x;y2=y1;y1=y}a2=r.neg();b2=x;var len1=a1.sqr().add(b1.sqr());var len2=a2.sqr().add(b2.sqr());if(len2.cmp(len1)>=0){a2=a0;b2=b0}if(a1.negative){a1=a1.neg();b1=b1.neg()}if(a2.negative){a2=a2.neg();b2=b2.neg()}return[{a:a1,b:b1},{a:a2,b:b2}]};ShortCurve.prototype._endoSplit=function _endoSplit(k){var basis=this.endo.basis;var v1=basis[0];var v2=basis[1];var c1=v2.b.mul(k).divRound(this.n);var c2=v1.b.neg().mul(k).divRound(this.n);var p1=c1.mul(v1.a);var p2=c2.mul(v2.a);var q1=c1.mul(v1.b);var q2=c2.mul(v2.b);var k1=k.sub(p1).sub(p2);var k2=q1.add(q2).neg();return{k1:k1,k2:k2}};ShortCurve.prototype.pointFromX=function pointFromX(x,odd){x=new bn(x,16);if(!x.red)x=x.toRed(this.red);var y2=x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);var y=y2.redSqrt();if(y.redSqr().redSub(y2).cmp(this.zero)!==0)throw new Error("invalid point");var isOdd=y.fromRed().isOdd();if(odd&&!isOdd||!odd&&isOdd)y=y.redNeg();return this.point(x,y)};ShortCurve.prototype.validate=function validate(point){if(point.inf)return true;var x=point.x;var y=point.y;var ax=this.a.redMul(x);var rhs=x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);return y.redSqr().redISub(rhs).cmpn(0)===0};ShortCurve.prototype._endoWnafMulAdd=function _endoWnafMulAdd(points,coeffs,jacobianResult){var npoints=this._endoWnafT1;var ncoeffs=this._endoWnafT2;for(var i=0;i<points.length;i++){var split=this._endoSplit(coeffs[i]);var p=points[i];var beta=p._getBeta();if(split.k1.negative){split.k1.ineg();p=p.neg(true)}if(split.k2.negative){split.k2.ineg();beta=beta.neg(true)}npoints[i*2]=p;npoints[i*2+1]=beta;ncoeffs[i*2]=split.k1;ncoeffs[i*2+1]=split.k2}var res=this._wnafMulAdd(1,npoints,ncoeffs,i*2,jacobianResult);for(var j=0;j<i*2;j++){npoints[j]=null;ncoeffs[j]=null}return res};function Point(curve,x,y,isRed){base.BasePoint.call(this,curve,"affine");if(x===null&&y===null){this.x=null;this.y=null;this.inf=true}else{this.x=new bn(x,16);this.y=new bn(y,16);if(isRed){this.x.forceRed(this.curve.red);this.y.forceRed(this.curve.red)}if(!this.x.red)this.x=this.x.toRed(this.curve.red);if(!this.y.red)this.y=this.y.toRed(this.curve.red);this.inf=false}}inherits_browser$1(Point,base.BasePoint);ShortCurve.prototype.point=function point(x,y,isRed){return new Point(this,x,y,isRed)};ShortCurve.prototype.pointFromJSON=function pointFromJSON(obj,red){return Point.fromJSON(this,obj,red)};Point.prototype._getBeta=function _getBeta(){if(!this.curve.endo)return;var pre=this.precomputed;if(pre&&pre.beta)return pre.beta;var beta=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(pre){var curve=this.curve;var endoMul=function(p){return curve.point(p.x.redMul(curve.endo.beta),p.y)};pre.beta=beta;beta.precomputed={beta:null,naf:pre.naf&&{wnd:pre.naf.wnd,points:pre.naf.points.map(endoMul)},doubles:pre.doubles&&{step:pre.doubles.step,points:pre.doubles.points.map(endoMul)}}}return beta};Point.prototype.toJSON=function toJSON(){if(!this.precomputed)return[this.x,this.y];return[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]};Point.fromJSON=function fromJSON(curve,obj,red){if(typeof obj==="string")obj=JSON.parse(obj);var res=curve.point(obj[0],obj[1],red);if(!obj[2])return res;function obj2point(obj){return curve.point(obj[0],obj[1],red)}var pre=obj[2];res.precomputed={beta:null,doubles:pre.doubles&&{step:pre.doubles.step,points:[res].concat(pre.doubles.points.map(obj2point))},naf:pre.naf&&{wnd:pre.naf.wnd,points:[res].concat(pre.naf.points.map(obj2point))}};return res};Point.prototype.inspect=function inspect(){if(this.isInfinity())return"<EC Point Infinity>";return"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"};Point.prototype.isInfinity=function isInfinity(){return this.inf};Point.prototype.add=function add(p){if(this.inf)return p;if(p.inf)return this;if(this.eq(p))return this.dbl();if(this.neg().eq(p))return this.curve.point(null,null);if(this.x.cmp(p.x)===0)return this.curve.point(null,null);var c=this.y.redSub(p.y);if(c.cmpn(0)!==0)c=c.redMul(this.x.redSub(p.x).redInvm());var nx=c.redSqr().redISub(this.x).redISub(p.x);var ny=c.redMul(this.x.redSub(nx)).redISub(this.y);return this.curve.point(nx,ny)};Point.prototype.dbl=function dbl(){if(this.inf)return this;var ys1=this.y.redAdd(this.y);if(ys1.cmpn(0)===0)return this.curve.point(null,null);var a=this.curve.a;var x2=this.x.redSqr();var dyinv=ys1.redInvm();var c=x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);var nx=c.redSqr().redISub(this.x.redAdd(this.x));var ny=c.redMul(this.x.redSub(nx)).redISub(this.y);return this.curve.point(nx,ny)};Point.prototype.getX=function getX(){return this.x.fromRed()};Point.prototype.getY=function getY(){return this.y.fromRed()};Point.prototype.mul=function mul(k){k=new bn(k,16);if(this.isInfinity())return this;else if(this._hasDoubles(k))return this.curve._fixedNafMul(this,k);else if(this.curve.endo)return this.curve._endoWnafMulAdd([this],[k]);else return this.curve._wnafMul(this,k)};Point.prototype.mulAdd=function mulAdd(k1,p2,k2){var points=[this,p2];var coeffs=[k1,k2];if(this.curve.endo)return this.curve._endoWnafMulAdd(points,coeffs);else return this.curve._wnafMulAdd(1,points,coeffs,2)};Point.prototype.jmulAdd=function jmulAdd(k1,p2,k2){var points=[this,p2];var coeffs=[k1,k2];if(this.curve.endo)return this.curve._endoWnafMulAdd(points,coeffs,true);else return this.curve._wnafMulAdd(1,points,coeffs,2,true)};Point.prototype.eq=function eq(p){return this===p||this.inf===p.inf&&(this.inf||this.x.cmp(p.x)===0&&this.y.cmp(p.y)===0)};Point.prototype.neg=function neg(_precompute){if(this.inf)return this;var res=this.curve.point(this.x,this.y.redNeg());if(_precompute&&this.precomputed){var pre=this.precomputed;var negate=function(p){return p.neg()};res.precomputed={naf:pre.naf&&{wnd:pre.naf.wnd,points:pre.naf.points.map(negate)},doubles:pre.doubles&&{step:pre.doubles.step,points:pre.doubles.points.map(negate)}}}return res};Point.prototype.toJ=function toJ(){if(this.inf)return this.curve.jpoint(null,null,null);var res=this.curve.jpoint(this.x,this.y,this.curve.one);return res};function JPoint(curve,x,y,z){base.BasePoint.call(this,curve,"jacobian");if(x===null&&y===null&&z===null){this.x=this.curve.one;this.y=this.curve.one;this.z=new bn(0)}else{this.x=new bn(x,16);this.y=new bn(y,16);this.z=new bn(z,16)}if(!this.x.red)this.x=this.x.toRed(this.curve.red);if(!this.y.red)this.y=this.y.toRed(this.curve.red);if(!this.z.red)this.z=this.z.toRed(this.curve.red);this.zOne=this.z===this.curve.one}inherits_browser$1(JPoint,base.BasePoint);ShortCurve.prototype.jpoint=function jpoint(x,y,z){return new JPoint(this,x,y,z)};JPoint.prototype.toP=function toP(){if(this.isInfinity())return this.curve.point(null,null);var zinv=this.z.redInvm();var zinv2=zinv.redSqr();var ax=this.x.redMul(zinv2);var ay=this.y.redMul(zinv2).redMul(zinv);return this.curve.point(ax,ay)};JPoint.prototype.neg=function neg(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)};JPoint.prototype.add=function add(p){if(this.isInfinity())return p;if(p.isInfinity())return this;var pz2=p.z.redSqr();var z2=this.z.redSqr();var u1=this.x.redMul(pz2);var u2=p.x.redMul(z2);var s1=this.y.redMul(pz2.redMul(p.z));var s2=p.y.redMul(z2.redMul(this.z));var h=u1.redSub(u2);var r=s1.redSub(s2);if(h.cmpn(0)===0){if(r.cmpn(0)!==0)return this.curve.jpoint(null,null,null);else return this.dbl()}var h2=h.redSqr();var h3=h2.redMul(h);var v=u1.redMul(h2);var nx=r.redSqr().redIAdd(h3).redISub(v).redISub(v);var ny=r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));var nz=this.z.redMul(p.z).redMul(h);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.mixedAdd=function mixedAdd(p){if(this.isInfinity())return p.toJ();if(p.isInfinity())return this;var z2=this.z.redSqr();var u1=this.x;var u2=p.x.redMul(z2);var s1=this.y;var s2=p.y.redMul(z2).redMul(this.z);var h=u1.redSub(u2);var r=s1.redSub(s2);if(h.cmpn(0)===0){if(r.cmpn(0)!==0)return this.curve.jpoint(null,null,null);else return this.dbl()}var h2=h.redSqr();var h3=h2.redMul(h);var v=u1.redMul(h2);var nx=r.redSqr().redIAdd(h3).redISub(v).redISub(v);var ny=r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));var nz=this.z.redMul(h);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.dblp=function dblp(pow){if(pow===0)return this;if(this.isInfinity())return this;if(!pow)return this.dbl();var i;if(this.curve.zeroA||this.curve.threeA){var r=this;for(i=0;i<pow;i++)r=r.dbl();return r}var a=this.curve.a;var tinv=this.curve.tinv;var jx=this.x;var jy=this.y;var jz=this.z;var jz4=jz.redSqr().redSqr();var jyd=jy.redAdd(jy);for(i=0;i<pow;i++){var jx2=jx.redSqr();var jyd2=jyd.redSqr();var jyd4=jyd2.redSqr();var c=jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));var t1=jx.redMul(jyd2);var nx=c.redSqr().redISub(t1.redAdd(t1));var t2=t1.redISub(nx);var dny=c.redMul(t2);dny=dny.redIAdd(dny).redISub(jyd4);var nz=jyd.redMul(jz);if(i+1<pow)jz4=jz4.redMul(jyd4);jx=nx;jz=nz;jyd=dny}return this.curve.jpoint(jx,jyd.redMul(tinv),jz)};JPoint.prototype.dbl=function dbl(){if(this.isInfinity())return this;if(this.curve.zeroA)return this._zeroDbl();else if(this.curve.threeA)return this._threeDbl();else return this._dbl()};JPoint.prototype._zeroDbl=function _zeroDbl(){var nx;var ny;var nz;if(this.zOne){var xx=this.x.redSqr();var yy=this.y.redSqr();var yyyy=yy.redSqr();var s=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);s=s.redIAdd(s);var m=xx.redAdd(xx).redIAdd(xx);var t=m.redSqr().redISub(s).redISub(s);var yyyy8=yyyy.redIAdd(yyyy);yyyy8=yyyy8.redIAdd(yyyy8);yyyy8=yyyy8.redIAdd(yyyy8);nx=t;ny=m.redMul(s.redISub(t)).redISub(yyyy8);nz=this.y.redAdd(this.y)}else{var a=this.x.redSqr();var b=this.y.redSqr();var c=b.redSqr();var d=this.x.redAdd(b).redSqr().redISub(a).redISub(c);d=d.redIAdd(d);var e=a.redAdd(a).redIAdd(a);var f=e.redSqr();var c8=c.redIAdd(c);c8=c8.redIAdd(c8);c8=c8.redIAdd(c8);nx=f.redISub(d).redISub(d);ny=e.redMul(d.redISub(nx)).redISub(c8);nz=this.y.redMul(this.z);nz=nz.redIAdd(nz)}return this.curve.jpoint(nx,ny,nz)};JPoint.prototype._threeDbl=function _threeDbl(){var nx;var ny;var nz;if(this.zOne){var xx=this.x.redSqr();var yy=this.y.redSqr();var yyyy=yy.redSqr();var s=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);s=s.redIAdd(s);var m=xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);var t=m.redSqr().redISub(s).redISub(s);nx=t;var yyyy8=yyyy.redIAdd(yyyy);yyyy8=yyyy8.redIAdd(yyyy8);yyyy8=yyyy8.redIAdd(yyyy8);ny=m.redMul(s.redISub(t)).redISub(yyyy8);nz=this.y.redAdd(this.y)}else{var delta=this.z.redSqr();var gamma=this.y.redSqr();var beta=this.x.redMul(gamma);var alpha=this.x.redSub(delta).redMul(this.x.redAdd(delta));alpha=alpha.redAdd(alpha).redIAdd(alpha);var beta4=beta.redIAdd(beta);beta4=beta4.redIAdd(beta4);var beta8=beta4.redAdd(beta4);nx=alpha.redSqr().redISub(beta8);nz=this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);var ggamma8=gamma.redSqr();ggamma8=ggamma8.redIAdd(ggamma8);ggamma8=ggamma8.redIAdd(ggamma8);ggamma8=ggamma8.redIAdd(ggamma8);ny=alpha.redMul(beta4.redISub(nx)).redISub(ggamma8)}return this.curve.jpoint(nx,ny,nz)};JPoint.prototype._dbl=function _dbl(){var a=this.curve.a;var jx=this.x;var jy=this.y;var jz=this.z;var jz4=jz.redSqr().redSqr();var jx2=jx.redSqr();var jy2=jy.redSqr();var c=jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));var jxd4=jx.redAdd(jx);jxd4=jxd4.redIAdd(jxd4);var t1=jxd4.redMul(jy2);var nx=c.redSqr().redISub(t1.redAdd(t1));var t2=t1.redISub(nx);var jyd8=jy2.redSqr();jyd8=jyd8.redIAdd(jyd8);jyd8=jyd8.redIAdd(jyd8);jyd8=jyd8.redIAdd(jyd8);var ny=c.redMul(t2).redISub(jyd8);var nz=jy.redAdd(jy).redMul(jz);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.trpl=function trpl(){if(!this.curve.zeroA)return this.dbl().add(this);var xx=this.x.redSqr();var yy=this.y.redSqr();var zz=this.z.redSqr();var yyyy=yy.redSqr();var m=xx.redAdd(xx).redIAdd(xx);var mm=m.redSqr();var e=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);e=e.redIAdd(e);e=e.redAdd(e).redIAdd(e);e=e.redISub(mm);var ee=e.redSqr();var t=yyyy.redIAdd(yyyy);t=t.redIAdd(t);t=t.redIAdd(t);t=t.redIAdd(t);var u=m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);var yyu4=yy.redMul(u);yyu4=yyu4.redIAdd(yyu4);yyu4=yyu4.redIAdd(yyu4);var nx=this.x.redMul(ee).redISub(yyu4);nx=nx.redIAdd(nx);nx=nx.redIAdd(nx);var ny=this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));ny=ny.redIAdd(ny);ny=ny.redIAdd(ny);ny=ny.redIAdd(ny);var nz=this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);return this.curve.jpoint(nx,ny,nz)};JPoint.prototype.mul=function mul(k,kbase){k=new bn(k,kbase);return this.curve._wnafMul(this,k)};JPoint.prototype.eq=function eq(p){if(p.type==="affine")return this.eq(p.toJ());if(this===p)return true;var z2=this.z.redSqr();var pz2=p.z.redSqr();if(this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0)!==0)return false;var z3=z2.redMul(this.z);var pz3=pz2.redMul(p.z);return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0)===0};JPoint.prototype.eqXToP=function eqXToP(x){var zs=this.z.redSqr();var rx=x.toRed(this.curve.red).redMul(zs);if(this.x.cmp(rx)===0)return true;var xc=x.clone();var t=this.curve.redN.redMul(zs);for(;;){xc.iadd(this.curve.n);if(xc.cmp(this.curve.p)>=0)return false;rx.redIAdd(t);if(this.x.cmp(rx)===0)return true}};JPoint.prototype.inspect=function inspect(){if(this.isInfinity())return"<EC JPoint Infinity>";return"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"};JPoint.prototype.isInfinity=function isInfinity(){return this.z.cmpn(0)===0};var curve_1=createCommonjsModule$1(function(module,exports){"use strict";var curve=exports;curve.base=base;curve.short=short_1;curve.mont=null;curve.edwards=null});var curves_1=createCommonjsModule$1(function(module,exports){"use strict";var curves=exports;var assert=utils_1$1.assert;function PresetCurve(options){if(options.type==="short")this.curve=new curve_1.short(options);else if(options.type==="edwards")this.curve=new curve_1.edwards(options);else this.curve=new curve_1.mont(options);this.g=this.curve.g;this.n=this.curve.n;this.hash=options.hash;assert(this.g.validate(),"Invalid curve");assert(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}curves.PresetCurve=PresetCurve;function defineCurve(name,options){Object.defineProperty(curves,name,{configurable:true,enumerable:true,get:function(){var curve=new PresetCurve(options);Object.defineProperty(curves,name,{configurable:true,enumerable:true,value:curve});return curve}})}defineCurve("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:hash_1.sha256,gRed:false,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]});defineCurve("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:hash_1.sha256,gRed:false,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]});defineCurve("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:hash_1.sha256,gRed:false,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]});defineCurve("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f "+"5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 "+"f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:hash_1.sha384,gRed:false,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 "+"5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 "+"0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]});defineCurve("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b "+"99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd "+"3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff "+"ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 "+"f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:hash_1.sha512,gRed:false,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 "+"053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 "+"a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 "+"579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 "+"3fad0761 353c7086 a272c240 88be9476 9fd16650"]});defineCurve("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:hash_1.sha256,gRed:false,g:["9"]});defineCurve("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:hash_1.sha256,gRed:false,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});var pre;try{pre=null.crash()}catch(e){pre=undefined}defineCurve("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:hash_1.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:false,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",pre]})});"use strict";function HmacDRBG(options){if(!(this instanceof HmacDRBG))return new HmacDRBG(options);this.hash=options.hash;this.predResist=!!options.predResist;this.outLen=this.hash.outSize;this.minEntropy=options.minEntropy||this.hash.hmacStrength;this._reseed=null;this.reseedInterval=null;this.K=null;this.V=null;var entropy=utils_1.toArray(options.entropy,options.entropyEnc||"hex");var nonce=utils_1.toArray(options.nonce,options.nonceEnc||"hex");var pers=utils_1.toArray(options.pers,options.persEnc||"hex");minimalisticAssert$1(entropy.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits");this._init(entropy,nonce,pers)}var hmacDrbg=HmacDRBG;HmacDRBG.prototype._init=function init(entropy,nonce,pers){var seed=entropy.concat(nonce).concat(pers);this.K=new Array(this.outLen/8);this.V=new Array(this.outLen/8);for(var i=0;i<this.V.length;i++){this.K[i]=0;this.V[i]=1}this._update(seed);this._reseed=1;this.reseedInterval=281474976710656};HmacDRBG.prototype._hmac=function hmac(){return new hash_1.hmac(this.hash,this.K)};HmacDRBG.prototype._update=function update(seed){var kmac=this._hmac().update(this.V).update([0]);if(seed)kmac=kmac.update(seed);this.K=kmac.digest();this.V=this._hmac().update(this.V).digest();if(!seed)return;this.K=this._hmac().update(this.V).update([1]).update(seed).digest();this.V=this._hmac().update(this.V).digest()};HmacDRBG.prototype.reseed=function reseed(entropy,entropyEnc,add,addEnc){if(typeof entropyEnc!=="string"){addEnc=add;add=entropyEnc;entropyEnc=null}entropy=utils_1.toArray(entropy,entropyEnc);add=utils_1.toArray(add,addEnc);minimalisticAssert$1(entropy.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits");this._update(entropy.concat(add||[]));this._reseed=1};HmacDRBG.prototype.generate=function generate(len,enc,add,addEnc){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");if(typeof enc!=="string"){addEnc=add;add=enc;enc=null}if(add){add=utils_1.toArray(add,addEnc||"hex");this._update(add)}var temp=[];while(temp.length<len){this.V=this._hmac().update(this.V).digest();temp=temp.concat(this.V)}var res=temp.slice(0,len);this._update(add);this._reseed++;return utils_1.encode(res,enc)};"use strict";var assert$3=utils_1$1.assert;function KeyPair(ec,options){this.ec=ec;this.priv=null;this.pub=null;if(options.priv)this._importPrivate(options.priv,options.privEnc);if(options.pub)this._importPublic(options.pub,options.pubEnc)}var key=KeyPair;KeyPair.fromPublic=function fromPublic(ec,pub,enc){if(pub instanceof KeyPair)return pub;return new KeyPair(ec,{pub:pub,pubEnc:enc})};KeyPair.fromPrivate=function fromPrivate(ec,priv,enc){if(priv instanceof KeyPair)return priv;return new KeyPair(ec,{priv:priv,privEnc:enc})};KeyPair.prototype.validate=function validate(){var pub=this.getPublic();if(pub.isInfinity())return{result:false,reason:"Invalid public key"};if(!pub.validate())return{result:false,reason:"Public key is not a point"};if(!pub.mul(this.ec.curve.n).isInfinity())return{result:false,reason:"Public key * N != O"};return{result:true,reason:null}};KeyPair.prototype.getPublic=function getPublic(compact,enc){if(typeof compact==="string"){enc=compact;compact=null}if(!this.pub)this.pub=this.ec.g.mul(this.priv);if(!enc)return this.pub;return this.pub.encode(enc,compact)};KeyPair.prototype.getPrivate=function getPrivate(enc){if(enc==="hex")return this.priv.toString(16,2);else return this.priv};KeyPair.prototype._importPrivate=function _importPrivate(key,enc){this.priv=new bn(key,enc||16);this.priv=this.priv.umod(this.ec.curve.n)};KeyPair.prototype._importPublic=function _importPublic(key,enc){if(key.x||key.y){if(this.ec.curve.type==="mont"){assert$3(key.x,"Need x coordinate")}else if(this.ec.curve.type==="short"||this.ec.curve.type==="edwards"){assert$3(key.x&&key.y,"Need both x and y coordinate")}this.pub=this.ec.curve.point(key.x,key.y);return}this.pub=this.ec.curve.decodePoint(key,enc)};KeyPair.prototype.derive=function derive(pub){if(!pub.validate()){assert$3(pub.validate(),"public point not validated")}return pub.mul(this.priv).getX()};KeyPair.prototype.sign=function sign(msg,enc,options){return this.ec.sign(msg,this,enc,options)};KeyPair.prototype.verify=function verify(msg,signature){return this.ec.verify(msg,signature,this)};KeyPair.prototype.inspect=function inspect(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"};"use strict";var assert$4=utils_1$1.assert;function Signature(options,enc){if(options instanceof Signature)return options;if(this._importDER(options,enc))return;assert$4(options.r&&options.s,"Signature without r or s");this.r=new bn(options.r,16);this.s=new bn(options.s,16);if(options.recoveryParam===undefined)this.recoveryParam=null;else this.recoveryParam=options.recoveryParam}var signature=Signature;function Position(){this.place=0}function getLength(buf,p){var initial=buf[p.place++];if(!(initial&128)){return initial}var octetLen=initial&15;if(octetLen===0||octetLen>4){return false}var val=0;for(var i=0,off=p.place;i<octetLen;i++,off++){val<<=8;val|=buf[off];val>>>=0}if(val<=127){return false}p.place=off;return val}function rmPadding(buf){var i=0;var len=buf.length-1;while(!buf[i]&&!(buf[i+1]&128)&&i<len){i++}if(i===0){return buf}return buf.slice(i)}Signature.prototype._importDER=function _importDER(data,enc){data=utils_1$1.toArray(data,enc);var p=new Position;if(data[p.place++]!==48){return false}var len=getLength(data,p);if(len===false){return false}if(len+p.place!==data.length){return false}if(data[p.place++]!==2){return false}var rlen=getLength(data,p);if(rlen===false){return false}var r=data.slice(p.place,rlen+p.place);p.place+=rlen;if(data[p.place++]!==2){return false}var slen=getLength(data,p);if(slen===false){return false}if(data.length!==slen+p.place){return false}var s=data.slice(p.place,slen+p.place);if(r[0]===0){if(r[1]&128){r=r.slice(1)}else{return false}}if(s[0]===0){if(s[1]&128){s=s.slice(1)}else{return false}}this.r=new bn(r);this.s=new bn(s);this.recoveryParam=null;return true};function constructLength(arr,len){if(len<128){arr.push(len);return}var octets=1+(Math.log(len)/Math.LN2>>>3);arr.push(octets|128);while(--octets){arr.push(len>>>(octets<<3)&255)}arr.push(len)}Signature.prototype.toDER=function toDER(enc){var r=this.r.toArray();var s=this.s.toArray();if(r[0]&128)r=[0].concat(r);if(s[0]&128)s=[0].concat(s);r=rmPadding(r);s=rmPadding(s);while(!s[0]&&!(s[1]&128)){s=s.slice(1)}var arr=[2];constructLength(arr,r.length);arr=arr.concat(r);arr.push(2);constructLength(arr,s.length);var backHalf=arr.concat(s);var res=[48];constructLength(res,backHalf.length);res=res.concat(backHalf);return utils_1$1.encode(res,enc)};"use strict";var rand=function(){throw new Error("unsupported")};var assert$5=utils_1$1.assert;function EC(options){if(!(this instanceof EC))return new EC(options);if(typeof options==="string"){assert$5(Object.prototype.hasOwnProperty.call(curves_1,options),"Unknown curve "+options);options=curves_1[options]}if(options instanceof curves_1.PresetCurve)options={curve:options};this.curve=options.curve.curve;this.n=this.curve.n;this.nh=this.n.ushrn(1);this.g=this.curve.g;this.g=options.curve.g;this.g.precompute(options.curve.n.bitLength()+1);this.hash=options.hash||options.curve.hash}var ec=EC;EC.prototype.keyPair=function keyPair(options){return new key(this,options)};EC.prototype.keyFromPrivate=function keyFromPrivate(priv,enc){return key.fromPrivate(this,priv,enc)};EC.prototype.keyFromPublic=function keyFromPublic(pub,enc){return key.fromPublic(this,pub,enc)};EC.prototype.genKeyPair=function genKeyPair(options){if(!options)options={};var drbg=new hmacDrbg({hash:this.hash,pers:options.pers,persEnc:options.persEnc||"utf8",entropy:options.entropy||rand(this.hash.hmacStrength),entropyEnc:options.entropy&&options.entropyEnc||"utf8",nonce:this.n.toArray()});var bytes=this.n.byteLength();var ns2=this.n.sub(new bn(2));for(;;){var priv=new bn(drbg.generate(bytes));if(priv.cmp(ns2)>0)continue;priv.iaddn(1);return this.keyFromPrivate(priv)}};EC.prototype._truncateToN=function _truncateToN(msg,truncOnly){var delta=msg.byteLength()*8-this.n.bitLength();if(delta>0)msg=msg.ushrn(delta);if(!truncOnly&&msg.cmp(this.n)>=0)return msg.sub(this.n);else return msg};EC.prototype.sign=function sign(msg,key,enc,options){if(typeof enc==="object"){options=enc;enc=null}if(!options)options={};key=this.keyFromPrivate(key,enc);msg=this._truncateToN(new bn(msg,16));var bytes=this.n.byteLength();var bkey=key.getPrivate().toArray("be",bytes);var nonce=msg.toArray("be",bytes);var drbg=new hmacDrbg({hash:this.hash,entropy:bkey,nonce:nonce,pers:options.pers,persEnc:options.persEnc||"utf8"});var ns1=this.n.sub(new bn(1));for(var iter=0;;iter++){var k=options.k?options.k(iter):new bn(drbg.generate(this.n.byteLength()));k=this._truncateToN(k,true);if(k.cmpn(1)<=0||k.cmp(ns1)>=0)continue;var kp=this.g.mul(k);if(kp.isInfinity())continue;var kpX=kp.getX();var r=kpX.umod(this.n);if(r.cmpn(0)===0)continue;var s=k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));s=s.umod(this.n);if(s.cmpn(0)===0)continue;var recoveryParam=(kp.getY().isOdd()?1:0)|(kpX.cmp(r)!==0?2:0);if(options.canonical&&s.cmp(this.nh)>0){s=this.n.sub(s);recoveryParam^=1}return new signature({r:r,s:s,recoveryParam:recoveryParam})}};EC.prototype.verify=function verify(msg,signature$1,key,enc){msg=this._truncateToN(new bn(msg,16));key=this.keyFromPublic(key,enc);signature$1=new signature(signature$1,"hex");var r=signature$1.r;var s=signature$1.s;if(r.cmpn(1)<0||r.cmp(this.n)>=0)return false;if(s.cmpn(1)<0||s.cmp(this.n)>=0)return false;var sinv=s.invm(this.n);var u1=sinv.mul(msg).umod(this.n);var u2=sinv.mul(r).umod(this.n);var p;if(!this.curve._maxwellTrick){p=this.g.mulAdd(u1,key.getPublic(),u2);if(p.isInfinity())return false;return p.getX().umod(this.n).cmp(r)===0}p=this.g.jmulAdd(u1,key.getPublic(),u2);if(p.isInfinity())return false;return p.eqXToP(r)};EC.prototype.recoverPubKey=function(msg,signature$1,j,enc){assert$5((3&j)===j,"The recovery param is more than two bits");signature$1=new signature(signature$1,enc);var n=this.n;var e=new bn(msg);var r=signature$1.r;var s=signature$1.s;var isYOdd=j&1;var isSecondKey=j>>1;if(r.cmp(this.curve.p.umod(this.curve.n))>=0&&isSecondKey)throw new Error("Unable to find sencond key candinate");if(isSecondKey)r=this.curve.pointFromX(r.add(this.curve.n),isYOdd);else r=this.curve.pointFromX(r,isYOdd);var rInv=signature$1.r.invm(n);var s1=n.sub(e).mul(rInv).umod(n);var s2=s.mul(rInv).umod(n);return this.g.mulAdd(s1,r,s2)};EC.prototype.getKeyRecoveryParam=function(e,signature$1,Q,enc){signature$1=new signature(signature$1,enc);if(signature$1.recoveryParam!==null)return signature$1.recoveryParam;for(var i=0;i<4;i++){var Qprime;try{Qprime=this.recoverPubKey(e,signature$1,i)}catch(e){continue}if(Qprime.eq(Q))return i}throw new Error("Unable to find valid recovery factor")};var elliptic_1=createCommonjsModule$1(function(module,exports){"use strict";var elliptic=exports;elliptic.version={version:"6.5.4"}.version;elliptic.utils=utils_1$1;elliptic.rand=function(){throw new Error("unsupported")};elliptic.curve=curve_1;elliptic.curves=curves_1;elliptic.ec=ec;elliptic.eddsa=null});var EC$1=elliptic_1.ec;const version$b="signing-key/5.1.0";"use strict";const logger$g=new Logger(version$b);let _curve=null;function getCurve(){if(!_curve){_curve=new EC$1("secp256k1")}return _curve}class SigningKey{constructor(privateKey){defineReadOnly(this,"curve","secp256k1");defineReadOnly(this,"privateKey",hexlify(privateKey));const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey));defineReadOnly(this,"publicKey","0x"+keyPair.getPublic(false,"hex"));defineReadOnly(this,"compressedPublicKey","0x"+keyPair.getPublic(true,"hex"));defineReadOnly(this,"_isSigningKey",true)}_addPoint(other){const p0=getCurve().keyFromPublic(arrayify(this.publicKey));const p1=getCurve().keyFromPublic(arrayify(other));return"0x"+p0.pub.add(p1.pub).encodeCompressed("hex")}signDigest(digest){const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey));const digestBytes=arrayify(digest);if(digestBytes.length!==32){logger$g.throwArgumentError("bad digest length","digest",digest)}const signature=keyPair.sign(digestBytes,{canonical:true});return splitSignature({recoveryParam:signature.recoveryParam,r:hexZeroPad("0x"+signature.r.toString(16),32),s:hexZeroPad("0x"+signature.s.toString(16),32)})}computeSharedSecret(otherKey){const keyPair=getCurve().keyFromPrivate(arrayify(this.privateKey));const otherKeyPair=getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));return hexZeroPad("0x"+keyPair.derive(otherKeyPair.getPublic()).toString(16),32)}static isSigningKey(value){return!!(value&&value._isSigningKey)}}function recoverPublicKey(digest,signature){const sig=splitSignature(signature);const rs={r:arrayify(sig.r),s:arrayify(sig.s)};return"0x"+getCurve().recoverPubKey(arrayify(digest),rs,sig.recoveryParam).encode("hex",false)}function computePublicKey(key,compressed){const bytes=arrayify(key);if(bytes.length===32){const signingKey=new SigningKey(bytes);if(compressed){return"0x"+getCurve().keyFromPrivate(bytes).getPublic(true,"hex")}return signingKey.publicKey}else if(bytes.length===33){if(compressed){return hexlify(bytes)}return"0x"+getCurve().keyFromPublic(bytes).getPublic(false,"hex")}else if(bytes.length===65){if(!compressed){return hexlify(bytes)}return"0x"+getCurve().keyFromPublic(bytes).getPublic(true,"hex")}return logger$g.throwArgumentError("invalid public or private key","key","[REDACTED]")}const version$c="transactions/5.1.1";"use strict";const logger$h=new Logger(version$c);function handleAddress(value){if(value==="0x"){return null}return getAddress(value)}function handleNumber(value){if(value==="0x"){return Zero$1}return BigNumber.from(value)}const transactionFields=[{name:"nonce",maxLength:32,numeric:true},{name:"gasPrice",maxLength:32,numeric:true},{name:"gasLimit",maxLength:32,numeric:true},{name:"to",length:20},{name:"value",maxLength:32,numeric:true},{name:"data"}];const allowedTransactionKeys$1={chainId:true,data:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true};function computeAddress(key){const publicKey=computePublicKey(key);return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey,1)),12))}function recoverAddress(digest,signature){return computeAddress(recoverPublicKey(arrayify(digest),signature))}function formatNumber(value,name){const result=stripZeros(BigNumber.from(value).toHexString());if(result.length>32){logger$h.throwArgumentError("invalid length for "+name,"transaction:"+name,value)}return result}function accessSetify(addr,storageKeys){return{address:getAddress(addr),storageKeys:(storageKeys||[]).map((storageKey,index)=>{if(hexDataLength(storageKey)!==32){logger$h.throwArgumentError("invalid access list storageKey",`accessList[${addr}:${index}]`,storageKey)}return storageKey.toLowerCase()})}}function accessListify(value){if(Array.isArray(value)){return value.map((set,index)=>{if(Array.isArray(set)){if(set.length>2){logger$h.throwArgumentError("access list expected to be [ address, storageKeys[] ]",`value[${index}]`,set)}return accessSetify(set[0],set[1])}return accessSetify(set.address,set.storageKeys)})}const result=Object.keys(value).map(addr=>{const storageKeys=value[addr].reduce((accum,storageKey)=>{accum[storageKey]=true;return accum},{});return accessSetify(addr,Object.keys(storageKeys).sort())});result.sort((a,b)=>a.address.localeCompare(b.address));return result}function formatAccessList(value){return accessListify(value).map(set=>[set.address,set.storageKeys])}function _serializeEip2930(transaction,signature){const fields=[formatNumber(transaction.chainId||0,"chainId"),formatNumber(transaction.nonce||0,"nonce"),formatNumber(transaction.gasPrice||0,"gasPrice"),formatNumber(transaction.gasLimit||0,"gasLimit"),transaction.to!=null?getAddress(transaction.to):"0x",formatNumber(transaction.value||0,"value"),transaction.data||"0x",formatAccessList(transaction.accessList||[])];if(signature){const sig=splitSignature(signature);fields.push(formatNumber(sig.recoveryParam,"recoveryParam"));fields.push(stripZeros(sig.r));fields.push(stripZeros(sig.s))}return hexConcat(["0x01",encode(fields)])}function _serialize(transaction,signature){checkProperties(transaction,allowedTransactionKeys$1);const raw=[];transactionFields.forEach(function(fieldInfo){let value=transaction[fieldInfo.name]||[];const options={};if(fieldInfo.numeric){options.hexPad="left"}value=arrayify(hexlify(value,options));if(fieldInfo.length&&value.length!==fieldInfo.length&&value.length>0){logger$h.throwArgumentError("invalid length for "+fieldInfo.name,"transaction:"+fieldInfo.name,value)}if(fieldInfo.maxLength){value=stripZeros(value);if(value.length>fieldInfo.maxLength){logger$h.throwArgumentError("invalid length for "+fieldInfo.name,"transaction:"+fieldInfo.name,value)}}raw.push(hexlify(value))});let chainId=0;if(transaction.chainId!=null){chainId=transaction.chainId;if(typeof chainId!=="number"){logger$h.throwArgumentError("invalid transaction.chainId","transaction",transaction)}}else if(signature&&!isBytesLike(signature)&&signature.v>28){chainId=Math.floor((signature.v-35)/2)}if(chainId!==0){raw.push(hexlify(chainId));raw.push("0x");raw.push("0x")}if(!signature){return encode(raw)}const sig=splitSignature(signature);let v=27+sig.recoveryParam;if(chainId!==0){raw.pop();raw.pop();raw.pop();v+=chainId*2+8;if(sig.v>28&&sig.v!==v){logger$h.throwArgumentError("transaction.chainId/signature.v mismatch","signature",signature)}}else if(sig.v!==v){logger$h.throwArgumentError("transaction.chainId/signature.v mismatch","signature",signature)}raw.push(hexlify(v));raw.push(stripZeros(arrayify(sig.r)));raw.push(stripZeros(arrayify(sig.s)));return encode(raw)}function serialize(transaction,signature){if(transaction.type==null){if(transaction.accessList!=null){logger$h.throwArgumentError("untyped transactions do not support accessList; include type: 1","transaction",transaction)}return _serialize(transaction,signature)}switch(transaction.type){case 1:return _serializeEip2930(transaction,signature);default:break}return logger$h.throwError(`unsupported transaction type: ${transaction.type}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"serializeTransaction",transactionType:transaction.type})}function _parseEip2930(payload){const transaction=decode(payload.slice(1));if(transaction.length!==8&&transaction.length!==11){logger$h.throwArgumentError("invalid component count for transaction type: 1","payload",hexlify(payload))}const tx={type:1,chainId:handleNumber(transaction[0]).toNumber(),nonce:handleNumber(transaction[1]).toNumber(),gasPrice:handleNumber(transaction[2]),gasLimit:handleNumber(transaction[3]),to:handleAddress(transaction[4]),value:handleNumber(transaction[5]),data:transaction[6],accessList:accessListify(transaction[7])};if(transaction.length===8){return tx}try{const recid=handleNumber(transaction[8]).toNumber();if(recid!==0&&recid!==1){throw new Error("bad recid")}tx.v=recid}catch(error){logger$h.throwArgumentError("invalid v for transaction type: 1","v",transaction[8])}tx.r=hexZeroPad(transaction[9],32);tx.s=hexZeroPad(transaction[10],32);try{const digest=keccak256(_serializeEip2930(tx));tx.from=recoverAddress(digest,{r:tx.r,s:tx.s,recoveryParam:tx.v})}catch(error){console.log(error)}tx.hash=keccak256(payload);return tx}function _parse(rawTransaction){const transaction=decode(rawTransaction);if(transaction.length!==9&&transaction.length!==6){logger$h.throwArgumentError("invalid raw transaction","rawTransaction",rawTransaction)}const tx={nonce:handleNumber(transaction[0]).toNumber(),gasPrice:handleNumber(transaction[1]),gasLimit:handleNumber(transaction[2]),to:handleAddress(transaction[3]),value:handleNumber(transaction[4]),data:transaction[5],chainId:0};if(transaction.length===6){return tx}try{tx.v=BigNumber.from(transaction[6]).toNumber()}catch(error){console.log(error);return tx}tx.r=hexZeroPad(transaction[7],32);tx.s=hexZeroPad(transaction[8],32);if(BigNumber.from(tx.r).isZero()&&BigNumber.from(tx.s).isZero()){tx.chainId=tx.v;tx.v=0}else{tx.chainId=Math.floor((tx.v-35)/2);if(tx.chainId<0){tx.chainId=0}let recoveryParam=tx.v-27;const raw=transaction.slice(0,6);if(tx.chainId!==0){raw.push(hexlify(tx.chainId));raw.push("0x");raw.push("0x");recoveryParam-=tx.chainId*2+8}const digest=keccak256(encode(raw));try{tx.from=recoverAddress(digest,{r:hexlify(tx.r),s:hexlify(tx.s),recoveryParam:recoveryParam})}catch(error){console.log(error)}tx.hash=keccak256(rawTransaction)}tx.type=null;return tx}function parse(rawTransaction){const payload=arrayify(rawTransaction);if(payload[0]>127){return _parse(payload)}switch(payload[0]){case 1:return _parseEip2930(payload);default:break}return logger$h.throwError(`unsupported transaction type: ${payload[0]}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"parseTransaction",transactionType:payload[0]})}const version$d="contracts/5.1.1";"use strict";var __awaiter$3=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$i=new Logger(version$d);const allowedTransactionKeys$2={chainId:true,data:true,from:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true,type:true,accessList:true};function resolveName(resolver,nameOrPromise){return __awaiter$3(this,void 0,void 0,function*(){const name=yield nameOrPromise;try{return getAddress(name)}catch(error){}if(!resolver){logger$i.throwError("a provider or signer is needed to resolve ENS names",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resolveName"})}const address=yield resolver.resolveName(name);if(address==null){logger$i.throwArgumentError("resolver or addr is not configured for ENS name","name",name)}return address})}function resolveAddresses(resolver,value,paramType){return __awaiter$3(this,void 0,void 0,function*(){if(Array.isArray(paramType)){return yield Promise.all(paramType.map((paramType,index)=>{return resolveAddresses(resolver,Array.isArray(value)?value[index]:value[paramType.name],paramType)}))}if(paramType.type==="address"){return yield resolveName(resolver,value)}if(paramType.type==="tuple"){return yield resolveAddresses(resolver,value,paramType.components)}if(paramType.baseType==="array"){if(!Array.isArray(value)){return Promise.reject(new Error("invalid value for array"))}return yield Promise.all(value.map(v=>resolveAddresses(resolver,v,paramType.arrayChildren)))}return value})}function populateTransaction(contract,fragment,args){return __awaiter$3(this,void 0,void 0,function*(){let overrides={};if(args.length===fragment.inputs.length+1&&typeof args[args.length-1]==="object"){overrides=shallowCopy(args.pop())}logger$i.checkArgumentCount(args.length,fragment.inputs.length,"passed to contract");if(contract.signer){if(overrides.from){overrides.from=resolveProperties({override:resolveName(contract.signer,overrides.from),signer:contract.signer.getAddress()}).then(check=>__awaiter$3(this,void 0,void 0,function*(){if(getAddress(check.signer)!==check.override){logger$i.throwError("Contract with a Signer cannot override from",Logger.errors.UNSUPPORTED_OPERATION,{operation:"overrides.from"})}return check.override}))}else{overrides.from=contract.signer.getAddress()}}else if(overrides.from){overrides.from=resolveName(contract.provider,overrides.from)}const resolved=yield resolveProperties({args:resolveAddresses(contract.signer||contract.provider,args,fragment.inputs),address:contract.resolvedAddress,overrides:resolveProperties(overrides)||{}});const data=contract.interface.encodeFunctionData(fragment,resolved.args);const tx={data:data,to:resolved.address};const ro=resolved.overrides;if(ro.nonce!=null){tx.nonce=BigNumber.from(ro.nonce).toNumber()}if(ro.gasLimit!=null){tx.gasLimit=BigNumber.from(ro.gasLimit)}if(ro.gasPrice!=null){tx.gasPrice=BigNumber.from(ro.gasPrice)}if(ro.from!=null){tx.from=ro.from}if(ro.type!=null){tx.type=ro.type}if(ro.accessList!=null){tx.accessList=accessListify(ro.accessList)}if(tx.gasLimit==null&&fragment.gas!=null){let intrinsic=21e3;const bytes=arrayify(data);for(let i=0;i<bytes.length;i++){intrinsic+=4;if(bytes[i]){intrinsic+=64}}tx.gasLimit=BigNumber.from(fragment.gas).add(intrinsic)}if(ro.value){const roValue=BigNumber.from(ro.value);if(!roValue.isZero()&&!fragment.payable){logger$i.throwError("non-payable method cannot override value",Logger.errors.UNSUPPORTED_OPERATION,{operation:"overrides.value",value:overrides.value})}tx.value=roValue}delete overrides.nonce;delete overrides.gasLimit;delete overrides.gasPrice;delete overrides.from;delete overrides.value;delete overrides.type;delete overrides.accessList;const leftovers=Object.keys(overrides).filter(key=>overrides[key]!=null);if(leftovers.length){logger$i.throwError(`cannot override ${leftovers.map(l=>JSON.stringify(l)).join(",")}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"overrides",overrides:leftovers})}return tx})}function buildPopulate(contract,fragment){return function(...args){return populateTransaction(contract,fragment,args)}}function buildEstimate(contract,fragment){const signerOrProvider=contract.signer||contract.provider;return function(...args){return __awaiter$3(this,void 0,void 0,function*(){if(!signerOrProvider){logger$i.throwError("estimate require a provider or signer",Logger.errors.UNSUPPORTED_OPERATION,{operation:"estimateGas"})}const tx=yield populateTransaction(contract,fragment,args);return yield signerOrProvider.estimateGas(tx)})}}function buildCall(contract,fragment,collapseSimple){const signerOrProvider=contract.signer||contract.provider;return function(...args){return __awaiter$3(this,void 0,void 0,function*(){let blockTag=undefined;if(args.length===fragment.inputs.length+1&&typeof args[args.length-1]==="object"){const overrides=shallowCopy(args.pop());if(overrides.blockTag!=null){blockTag=yield overrides.blockTag}delete overrides.blockTag;args.push(overrides)}if(contract.deployTransaction!=null){yield contract._deployed(blockTag)}const tx=yield populateTransaction(contract,fragment,args);const result=yield signerOrProvider.call(tx,blockTag);try{let value=contract.interface.decodeFunctionResult(fragment,result);if(collapseSimple&&fragment.outputs.length===1){value=value[0]}return value}catch(error){if(error.code===Logger.errors.CALL_EXCEPTION){error.address=contract.address;error.args=args;error.transaction=tx}throw error}})}}function buildSend(contract,fragment){return function(...args){return __awaiter$3(this,void 0,void 0,function*(){if(!contract.signer){logger$i.throwError("sending a transaction requires a signer",Logger.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction"})}if(contract.deployTransaction!=null){yield contract._deployed()}const txRequest=yield populateTransaction(contract,fragment,args);const tx=yield contract.signer.sendTransaction(txRequest);const wait=tx.wait.bind(tx);tx.wait=(confirmations=>{return wait(confirmations).then(receipt=>{receipt.events=receipt.logs.map(log=>{let event=deepCopy(log);let parsed=null;try{parsed=contract.interface.parseLog(log)}catch(e){}if(parsed){event.args=parsed.args;event.decode=((data,topics)=>{return contract.interface.decodeEventLog(parsed.eventFragment,data,topics)});event.event=parsed.name;event.eventSignature=parsed.signature}event.removeListener=(()=>{return contract.provider});event.getBlock=(()=>{return contract.provider.getBlock(receipt.blockHash)});event.getTransaction=(()=>{return contract.provider.getTransaction(receipt.transactionHash)});event.getTransactionReceipt=(()=>{return Promise.resolve(receipt)});return event});return receipt})});return tx})}}function buildDefault(contract,fragment,collapseSimple){if(fragment.constant){return buildCall(contract,fragment,collapseSimple)}return buildSend(contract,fragment)}function getEventTag(filter){if(filter.address&&(filter.topics==null||filter.topics.length===0)){return"*"}return(filter.address||"*")+"@"+(filter.topics?filter.topics.map(topic=>{if(Array.isArray(topic)){return topic.join("|")}return topic}).join(":"):"")}class RunningEvent{constructor(tag,filter){defineReadOnly(this,"tag",tag);defineReadOnly(this,"filter",filter);this._listeners=[]}addListener(listener,once){this._listeners.push({listener:listener,once:once})}removeListener(listener){let done=false;this._listeners=this._listeners.filter(item=>{if(done||item.listener!==listener){return true}done=true;return false})}removeAllListeners(){this._listeners=[]}listeners(){return this._listeners.map(i=>i.listener)}listenerCount(){return this._listeners.length}run(args){const listenerCount=this.listenerCount();this._listeners=this._listeners.filter(item=>{const argsCopy=args.slice();setTimeout(()=>{item.listener.apply(this,argsCopy)},0);return!item.once});return listenerCount}prepareEvent(event){}getEmit(event){return[event]}}class ErrorRunningEvent extends RunningEvent{constructor(){super("error",null)}}class FragmentRunningEvent extends RunningEvent{constructor(address,contractInterface,fragment,topics){const filter={address:address};let topic=contractInterface.getEventTopic(fragment);if(topics){if(topic!==topics[0]){logger$i.throwArgumentError("topic mismatch","topics",topics)}filter.topics=topics.slice()}else{filter.topics=[topic]}super(getEventTag(filter),filter);defineReadOnly(this,"address",address);defineReadOnly(this,"interface",contractInterface);defineReadOnly(this,"fragment",fragment)}prepareEvent(event){super.prepareEvent(event);event.event=this.fragment.name;event.eventSignature=this.fragment.format();event.decode=((data,topics)=>{return this.interface.decodeEventLog(this.fragment,data,topics)});try{event.args=this.interface.decodeEventLog(this.fragment,event.data,event.topics)}catch(error){event.args=null;event.decodeError=error}}getEmit(event){const errors=checkResultErrors(event.args);if(errors.length){throw errors[0].error}const args=(event.args||[]).slice();args.push(event);return args}}class WildcardRunningEvent extends RunningEvent{constructor(address,contractInterface){super("*",{address:address});defineReadOnly(this,"address",address);defineReadOnly(this,"interface",contractInterface)}prepareEvent(event){super.prepareEvent(event);try{const parsed=this.interface.parseLog(event);event.event=parsed.name;event.eventSignature=parsed.signature;event.decode=((data,topics)=>{return this.interface.decodeEventLog(parsed.eventFragment,data,topics)});event.args=parsed.args}catch(error){}}}class BaseContract{constructor(addressOrName,contractInterface,signerOrProvider){logger$i.checkNew(new.target,Contract);defineReadOnly(this,"interface",getStatic(new.target,"getInterface")(contractInterface));if(signerOrProvider==null){defineReadOnly(this,"provider",null);defineReadOnly(this,"signer",null)}else if(Signer.isSigner(signerOrProvider)){defineReadOnly(this,"provider",signerOrProvider.provider||null);defineReadOnly(this,"signer",signerOrProvider)}else if(Provider.isProvider(signerOrProvider)){defineReadOnly(this,"provider",signerOrProvider);defineReadOnly(this,"signer",null)}else{logger$i.throwArgumentError("invalid signer or provider","signerOrProvider",signerOrProvider)}defineReadOnly(this,"callStatic",{});defineReadOnly(this,"estimateGas",{});defineReadOnly(this,"functions",{});defineReadOnly(this,"populateTransaction",{});defineReadOnly(this,"filters",{});{const uniqueFilters={};Object.keys(this.interface.events).forEach(eventSignature=>{const event=this.interface.events[eventSignature];defineReadOnly(this.filters,eventSignature,(...args)=>{return{address:this.address,topics:this.interface.encodeFilterTopics(event,args)}});if(!uniqueFilters[event.name]){uniqueFilters[event.name]=[]}uniqueFilters[event.name].push(eventSignature)});Object.keys(uniqueFilters).forEach(name=>{const filters=uniqueFilters[name];if(filters.length===1){defineReadOnly(this.filters,name,this.filters[filters[0]])}else{logger$i.warn(`Duplicate definition of ${name} (${filters.join(", ")})`)}})}defineReadOnly(this,"_runningEvents",{});defineReadOnly(this,"_wrappedEmits",{});if(addressOrName==null){logger$i.throwArgumentError("invalid contract address or ENS name","addressOrName",addressOrName)}defineReadOnly(this,"address",addressOrName);if(this.provider){defineReadOnly(this,"resolvedAddress",resolveName(this.provider,addressOrName))}else{try{defineReadOnly(this,"resolvedAddress",Promise.resolve(getAddress(addressOrName)))}catch(error){logger$i.throwError("provider is required to use ENS name as contract address",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new Contract"})}}const uniqueNames={};const uniqueSignatures={};Object.keys(this.interface.functions).forEach(signature=>{const fragment=this.interface.functions[signature];if(uniqueSignatures[signature]){logger$i.warn(`Duplicate ABI entry for ${JSON.stringify(name)}`);return}uniqueSignatures[signature]=true;{const name=fragment.name;if(!uniqueNames[name]){uniqueNames[name]=[]}uniqueNames[name].push(signature)}if(this[signature]==null){defineReadOnly(this,signature,buildDefault(this,fragment,true))}if(this.functions[signature]==null){defineReadOnly(this.functions,signature,buildDefault(this,fragment,false))}if(this.callStatic[signature]==null){defineReadOnly(this.callStatic,signature,buildCall(this,fragment,true))}if(this.populateTransaction[signature]==null){defineReadOnly(this.populateTransaction,signature,buildPopulate(this,fragment))}if(this.estimateGas[signature]==null){defineReadOnly(this.estimateGas,signature,buildEstimate(this,fragment))}});Object.keys(uniqueNames).forEach(name=>{const signatures=uniqueNames[name];if(signatures.length>1){return}const signature=signatures[0];try{if(this[name]==null){defineReadOnly(this,name,this[signature])}}catch(e){}if(this.functions[name]==null){defineReadOnly(this.functions,name,this.functions[signature])}if(this.callStatic[name]==null){defineReadOnly(this.callStatic,name,this.callStatic[signature])}if(this.populateTransaction[name]==null){defineReadOnly(this.populateTransaction,name,this.populateTransaction[signature])}if(this.estimateGas[name]==null){defineReadOnly(this.estimateGas,name,this.estimateGas[signature])}})}static getContractAddress(transaction){return getContractAddress(transaction)}static getInterface(contractInterface){if(Interface.isInterface(contractInterface)){return contractInterface}return new Interface(contractInterface)}deployed(){return this._deployed()}_deployed(blockTag){if(!this._deployedPromise){if(this.deployTransaction){this._deployedPromise=this.deployTransaction.wait().then(()=>{return this})}else{this._deployedPromise=this.provider.getCode(this.address,blockTag).then(code=>{if(code==="0x"){logger$i.throwError("contract not deployed",Logger.errors.UNSUPPORTED_OPERATION,{contractAddress:this.address,operation:"getDeployed"})}return this})}}return this._deployedPromise}fallback(overrides){if(!this.signer){logger$i.throwError("sending a transactions require a signer",Logger.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction(fallback)"})}const tx=shallowCopy(overrides||{});["from","to"].forEach(function(key){if(tx[key]==null){return}logger$i.throwError("cannot override "+key,Logger.errors.UNSUPPORTED_OPERATION,{operation:key})});tx.to=this.resolvedAddress;return this.deployed().then(()=>{return this.signer.sendTransaction(tx)})}connect(signerOrProvider){if(typeof signerOrProvider==="string"){signerOrProvider=new VoidSigner(signerOrProvider,this.provider)}const contract=new this.constructor(this.address,this.interface,signerOrProvider);if(this.deployTransaction){defineReadOnly(contract,"deployTransaction",this.deployTransaction)}return contract}attach(addressOrName){return new this.constructor(addressOrName,this.interface,this.signer||this.provider)}static isIndexed(value){return Indexed.isIndexed(value)}_normalizeRunningEvent(runningEvent){if(this._runningEvents[runningEvent.tag]){return this._runningEvents[runningEvent.tag]}return runningEvent}_getRunningEvent(eventName){if(typeof eventName==="string"){if(eventName==="error"){return this._normalizeRunningEvent(new ErrorRunningEvent)}if(eventName==="event"){return this._normalizeRunningEvent(new RunningEvent("event",null))}if(eventName==="*"){return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface))}const fragment=this.interface.getEvent(eventName);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,fragment))}if(eventName.topics&&eventName.topics.length>0){try{const topic=eventName.topics[0];if(typeof topic!=="string"){throw new Error("invalid topic")}const fragment=this.interface.getEvent(topic);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,fragment,eventName.topics))}catch(error){}const filter={address:this.address,topics:eventName.topics};return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter),filter))}return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface))}_checkRunningEvents(runningEvent){if(runningEvent.listenerCount()===0){delete this._runningEvents[runningEvent.tag];const emit=this._wrappedEmits[runningEvent.tag];if(emit&&runningEvent.filter){this.provider.off(runningEvent.filter,emit);delete this._wrappedEmits[runningEvent.tag]}}}_wrapEvent(runningEvent,log,listener){const event=deepCopy(log);event.removeListener=(()=>{if(!listener){return}runningEvent.removeListener(listener);this._checkRunningEvents(runningEvent)});event.getBlock=(()=>{return this.provider.getBlock(log.blockHash)});event.getTransaction=(()=>{return this.provider.getTransaction(log.transactionHash)});event.getTransactionReceipt=(()=>{return this.provider.getTransactionReceipt(log.transactionHash)});runningEvent.prepareEvent(event);return event}_addEventListener(runningEvent,listener,once){if(!this.provider){logger$i.throwError("events require a provider or a signer with a provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"once"})}runningEvent.addListener(listener,once);this._runningEvents[runningEvent.tag]=runningEvent;if(!this._wrappedEmits[runningEvent.tag]){const wrappedEmit=log=>{let event=this._wrapEvent(runningEvent,log,listener);if(event.decodeError==null){try{const args=runningEvent.getEmit(event);this.emit(runningEvent.filter,...args)}catch(error){event.decodeError=error.error}}if(runningEvent.filter!=null){this.emit("event",event)}if(event.decodeError!=null){this.emit("error",event.decodeError,event)}};this._wrappedEmits[runningEvent.tag]=wrappedEmit;if(runningEvent.filter!=null){this.provider.on(runningEvent.filter,wrappedEmit)}}}queryFilter(event,fromBlockOrBlockhash,toBlock){const runningEvent=this._getRunningEvent(event);const filter=shallowCopy(runningEvent.filter);if(typeof fromBlockOrBlockhash==="string"&&isHexString(fromBlockOrBlockhash,32)){if(toBlock!=null){logger$i.throwArgumentError("cannot specify toBlock with blockhash","toBlock",toBlock)}filter.blockHash=fromBlockOrBlockhash}else{filter.fromBlock=fromBlockOrBlockhash!=null?fromBlockOrBlockhash:0;filter.toBlock=toBlock!=null?toBlock:"latest"}return this.provider.getLogs(filter).then(logs=>{return logs.map(log=>this._wrapEvent(runningEvent,log,null))})}on(event,listener){this._addEventListener(this._getRunningEvent(event),listener,false);return this}once(event,listener){this._addEventListener(this._getRunningEvent(event),listener,true);return this}emit(eventName,...args){if(!this.provider){return false}const runningEvent=this._getRunningEvent(eventName);const result=runningEvent.run(args)>0;this._checkRunningEvents(runningEvent);return result}listenerCount(eventName){if(!this.provider){return 0}if(eventName==null){return Object.keys(this._runningEvents).reduce((accum,key)=>{return accum+this._runningEvents[key].listenerCount()},0)}return this._getRunningEvent(eventName).listenerCount()}listeners(eventName){if(!this.provider){return[]}if(eventName==null){const result=[];for(let tag in this._runningEvents){this._runningEvents[tag].listeners().forEach(listener=>{result.push(listener)})}return result}return this._getRunningEvent(eventName).listeners()}removeAllListeners(eventName){if(!this.provider){return this}if(eventName==null){for(const tag in this._runningEvents){const runningEvent=this._runningEvents[tag];runningEvent.removeAllListeners();this._checkRunningEvents(runningEvent)}return this}const runningEvent=this._getRunningEvent(eventName);runningEvent.removeAllListeners();this._checkRunningEvents(runningEvent);return this}off(eventName,listener){if(!this.provider){return this}const runningEvent=this._getRunningEvent(eventName);runningEvent.removeListener(listener);this._checkRunningEvents(runningEvent);return this}removeListener(eventName,listener){return this.off(eventName,listener)}}class Contract extends BaseContract{}class ContractFactory{constructor(contractInterface,bytecode,signer){let bytecodeHex=null;if(typeof bytecode==="string"){bytecodeHex=bytecode}else if(isBytes(bytecode)){bytecodeHex=hexlify(bytecode)}else if(bytecode&&typeof bytecode.object==="string"){bytecodeHex=bytecode.object}else{bytecodeHex="!"}if(bytecodeHex.substring(0,2)!=="0x"){bytecodeHex="0x"+bytecodeHex}if(!isHexString(bytecodeHex)||bytecodeHex.length%2){logger$i.throwArgumentError("invalid bytecode","bytecode",bytecode)}if(signer&&!Signer.isSigner(signer)){logger$i.throwArgumentError("invalid signer","signer",signer)}defineReadOnly(this,"bytecode",bytecodeHex);defineReadOnly(this,"interface",getStatic(new.target,"getInterface")(contractInterface));defineReadOnly(this,"signer",signer||null)}getDeployTransaction(...args){let tx={};if(args.length===this.interface.deploy.inputs.length+1&&typeof args[args.length-1]==="object"){tx=shallowCopy(args.pop());for(const key in tx){if(!allowedTransactionKeys$2[key]){throw new Error("unknown transaction override "+key)}}}["data","from","to"].forEach(key=>{if(tx[key]==null){return}logger$i.throwError("cannot override "+key,Logger.errors.UNSUPPORTED_OPERATION,{operation:key})});logger$i.checkArgumentCount(args.length,this.interface.deploy.inputs.length," in Contract constructor");tx.data=hexlify(concat([this.bytecode,this.interface.encodeDeploy(args)]));return tx}deploy(...args){return __awaiter$3(this,void 0,void 0,function*(){let overrides={};if(args.length===this.interface.deploy.inputs.length+1){overrides=args.pop()}logger$i.checkArgumentCount(args.length,this.interface.deploy.inputs.length," in Contract constructor");const params=yield resolveAddresses(this.signer,args,this.interface.deploy.inputs);params.push(overrides);const unsignedTx=this.getDeployTransaction(...params);const tx=yield this.signer.sendTransaction(unsignedTx);const address=getStatic(this.constructor,"getContractAddress")(tx);const contract=getStatic(this.constructor,"getContract")(address,this.interface,this.signer);defineReadOnly(contract,"deployTransaction",tx);return contract})}attach(address){return this.constructor.getContract(address,this.interface,this.signer)}connect(signer){return new this.constructor(this.interface,this.bytecode,signer)}static fromSolidity(compilerOutput,signer){if(compilerOutput==null){logger$i.throwError("missing compiler output",Logger.errors.MISSING_ARGUMENT,{argument:"compilerOutput"})}if(typeof compilerOutput==="string"){compilerOutput=JSON.parse(compilerOutput)}const abi=compilerOutput.abi;let bytecode=null;if(compilerOutput.bytecode){bytecode=compilerOutput.bytecode}else if(compilerOutput.evm&&compilerOutput.evm.bytecode){bytecode=compilerOutput.evm.bytecode}return new this(abi,bytecode,signer)}static getInterface(contractInterface){return Contract.getInterface(contractInterface)}static getContractAddress(tx){return getContractAddress(tx)}static getContract(address,contractInterface,signer){return new Contract(address,contractInterface,signer)}}class BaseX{constructor(alphabet){defineReadOnly(this,"alphabet",alphabet);defineReadOnly(this,"base",alphabet.length);defineReadOnly(this,"_alphabetMap",{});defineReadOnly(this,"_leader",alphabet.charAt(0));for(let i=0;i<alphabet.length;i++){this._alphabetMap[alphabet.charAt(i)]=i}}encode(value){let source=arrayify(value);if(source.length===0){return""}let digits=[0];for(let i=0;i<source.length;++i){let carry=source[i];for(let j=0;j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%this.base;carry=carry/this.base|0}while(carry>0){digits.push(carry%this.base);carry=carry/this.base|0}}let string="";for(let k=0;source[k]===0&&k<source.length-1;++k){string+=this._leader}for(let q=digits.length-1;q>=0;--q){string+=this.alphabet[digits[q]]}return string}decode(value){if(typeof value!=="string"){throw new TypeError("Expected String")}let bytes=[];if(value.length===0){return new Uint8Array(bytes)}bytes.push(0);for(let i=0;i<value.length;i++){let byte=this._alphabetMap[value[i]];if(byte===undefined){throw new Error("Non-base"+this.base+" character")}let carry=byte;for(let j=0;j<bytes.length;++j){carry+=bytes[j]*this.base;bytes[j]=carry&255;carry>>=8}while(carry>0){bytes.push(carry&255);carry>>=8}}for(let k=0;value[k]===this._leader&&k<value.length-1;++k){bytes.push(0)}return arrayify(new Uint8Array(bytes.reverse()))}}const Base32=new BaseX("abcdefghijklmnopqrstuvwxyz234567");const Base58=new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");var SupportedAlgorithm;(function(SupportedAlgorithm){SupportedAlgorithm["sha256"]="sha256";SupportedAlgorithm["sha512"]="sha512"})(SupportedAlgorithm||(SupportedAlgorithm={}));const version$e="sha2/5.1.0";"use strict";const logger$j=new Logger(version$e);function ripemd160$1(data){return"0x"+hash_1.ripemd160().update(arrayify(data)).digest("hex")}function sha256$1(data){return"0x"+hash_1.sha256().update(arrayify(data)).digest("hex")}function sha512$1(data){return"0x"+hash_1.sha512().update(arrayify(data)).digest("hex")}function computeHmac(algorithm,key,data){if(!SupportedAlgorithm[algorithm]){logger$j.throwError("unsupported algorithm "+algorithm,Logger.errors.UNSUPPORTED_OPERATION,{operation:"hmac",algorithm:algorithm})}return"0x"+hash_1.hmac(hash_1[algorithm],arrayify(key)).update(arrayify(data)).digest("hex")}"use strict";function pbkdf2(password,salt,iterations,keylen,hashAlgorithm){password=arrayify(password);salt=arrayify(salt);let hLen;let l=1;const DK=new Uint8Array(keylen);const block1=new Uint8Array(salt.length+4);block1.set(salt);let r;let T;for(let i=1;i<=l;i++){block1[salt.length]=i>>24&255;block1[salt.length+1]=i>>16&255;block1[salt.length+2]=i>>8&255;block1[salt.length+3]=i&255;let U=arrayify(computeHmac(hashAlgorithm,password,block1));if(!hLen){hLen=U.length;T=new Uint8Array(hLen);l=Math.ceil(keylen/hLen);r=keylen-(l-1)*hLen}T.set(U);for(let j=1;j<iterations;j++){U=arrayify(computeHmac(hashAlgorithm,password,U));for(let k=0;k<hLen;k++)T[k]^=U[k]}const destPos=(i-1)*hLen;const len=i===l?r:hLen;DK.set(arrayify(T).slice(0,len),destPos)}return hexlify(DK)}const version$f="wordlists/5.1.0";"use strict";const exportWordlist=false;const logger$k=new Logger(version$f);class Wordlist{constructor(locale){logger$k.checkAbstract(new.target,Wordlist);defineReadOnly(this,"locale",locale)}split(mnemonic){return mnemonic.toLowerCase().split(/ +/g)}join(words){return words.join(" ")}static check(wordlist){const words=[];for(let i=0;i<2048;i++){const word=wordlist.getWord(i);if(i!==wordlist.getWordIndex(word)){return"0x"}words.push(word)}return id(words.join("\n")+"\n")}static register(lang,name){if(!name){name=lang.locale}if(exportWordlist){try{const anyGlobal=window;if(anyGlobal._ethers&&anyGlobal._ethers.wordlists){if(!anyGlobal._ethers.wordlists[name]){defineReadOnly(anyGlobal._ethers.wordlists,name,lang)}}}catch(error){}}}}"use strict";const words="AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk";let wordlist=null;function loadWords(lang){if(wordlist!=null){return}wordlist=words.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ");if(Wordlist.check(lang)!=="0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a"){wordlist=null;throw new Error("BIP39 Wordlist for en (English) FAILED")}}class LangCz extends Wordlist{constructor(){super("cz")}getWord(index){loadWords(this);return wordlist[index]}getWordIndex(word){loadWords(this);return wordlist.indexOf(word)}}const langCz=new LangCz;Wordlist.register(langCz);"use strict";const words$1="AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";let wordlist$1=null;function loadWords$1(lang){if(wordlist$1!=null){return}wordlist$1=words$1.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ");if(Wordlist.check(lang)!=="0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"){wordlist$1=null;throw new Error("BIP39 Wordlist for en (English) FAILED")}}class LangEn extends Wordlist{constructor(){super("en")}getWord(index){loadWords$1(this);return wordlist$1[index]}getWordIndex(word){loadWords$1(this);return wordlist$1.indexOf(word)}}const langEn=new LangEn;Wordlist.register(langEn);"use strict";const words$2="A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo";const lookup={};let wordlist$2=null;function dropDiacritic(word){logger$k.checkNormalize();return toUtf8String(Array.prototype.filter.call(toUtf8Bytes(word.normalize("NFD").toLowerCase()),c=>{return c>=65&&c<=90||c>=97&&c<=123}))}function expand(word){const output=[];Array.prototype.forEach.call(toUtf8Bytes(word),c=>{if(c===47){output.push(204);output.push(129)}else if(c===126){output.push(110);output.push(204);output.push(131)}else{output.push(c)}});return toUtf8String(output)}function loadWords$2(lang){if(wordlist$2!=null){return}wordlist$2=words$2.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ").map(w=>expand(w));wordlist$2.forEach((word,index)=>{lookup[dropDiacritic(word)]=index});if(Wordlist.check(lang)!=="0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300"){wordlist$2=null;throw new Error("BIP39 Wordlist for es (Spanish) FAILED")}}class LangEs extends Wordlist{constructor(){super("es")}getWord(index){loadWords$2(this);return wordlist$2[index]}getWordIndex(word){loadWords$2(this);return lookup[dropDiacritic(word)]}}const langEs=new LangEs;Wordlist.register(langEs);"use strict";const words$3="AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie";let wordlist$3=null;const lookup$1={};function dropDiacritic$1(word){logger$k.checkNormalize();return toUtf8String(Array.prototype.filter.call(toUtf8Bytes(word.normalize("NFD").toLowerCase()),c=>{return c>=65&&c<=90||c>=97&&c<=123}))}function expand$1(word){const output=[];Array.prototype.forEach.call(toUtf8Bytes(word),c=>{if(c===47){output.push(204);output.push(129)}else if(c===45){output.push(204);output.push(128)}else{output.push(c)}});return toUtf8String(output)}function loadWords$3(lang){if(wordlist$3!=null){return}wordlist$3=words$3.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ").map(w=>expand$1(w));wordlist$3.forEach((word,index)=>{lookup$1[dropDiacritic$1(word)]=index});if(Wordlist.check(lang)!=="0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045"){wordlist$3=null;throw new Error("BIP39 Wordlist for fr (French) FAILED")}}class LangFr extends Wordlist{constructor(){super("fr")}getWord(index){loadWords$3(this);return wordlist$3[index]}getWordIndex(word){loadWords$3(this);return lookup$1[dropDiacritic$1(word)]}}const langFr=new LangFr;Wordlist.register(langFr);"use strict";const data=["AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR","ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR","AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm","ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC","BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD","QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD","IJBEJqXZJ"];const mapping="~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";let wordlist$4=null;function hex(word){return hexlify(toUtf8Bytes(word))}const KiYoKu="0xe3818de38284e3818f";const KyoKu="0xe3818de38283e3818f";function loadWords$4(lang){if(wordlist$4!==null){return}wordlist$4=[];const transform={};transform[toUtf8String([227,130,154])]=false;transform[toUtf8String([227,130,153])]=false;transform[toUtf8String([227,130,133])]=toUtf8String([227,130,134]);transform[toUtf8String([227,129,163])]=toUtf8String([227,129,164]);transform[toUtf8String([227,130,131])]=toUtf8String([227,130,132]);transform[toUtf8String([227,130,135])]=toUtf8String([227,130,136]);function normalize(word){let result="";for(let i=0;i<word.length;i++){let kana=word[i];const target=transform[kana];if(target===false){continue}if(target){kana=target}result+=kana}return result}function sortJapanese(a,b){a=normalize(a);b=normalize(b);if(a<b){return-1}if(a>b){return 1}return 0}for(let length=3;length<=9;length++){const d=data[length-3];for(let offset=0;offset<d.length;offset+=length){const word=[];for(let i=0;i<length;i++){const k=mapping.indexOf(d[offset+i]);word.push(227);word.push(k&64?130:129);word.push((k&63)+128)}wordlist$4.push(toUtf8String(word))}}wordlist$4.sort(sortJapanese);if(hex(wordlist$4[442])===KiYoKu&&hex(wordlist$4[443])===KyoKu){const tmp=wordlist$4[442];wordlist$4[442]=wordlist$4[443];wordlist$4[443]=tmp}if(Wordlist.check(lang)!=="0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600"){wordlist$4=null;throw new Error("BIP39 Wordlist for ja (Japanese) FAILED")}}class LangJa extends Wordlist{constructor(){super("ja")}getWord(index){loadWords$4(this);return wordlist$4[index]}getWordIndex(word){loadWords$4(this);return wordlist$4.indexOf(word)}split(mnemonic){logger$k.checkNormalize();return mnemonic.split(/(?:\u3000| )+/g)}join(words){return words.join("")}}const langJa=new LangJa;Wordlist.register(langJa);"use strict";const data$1=["OYAa","ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@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!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6","ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv","AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo","AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg","HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb","AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"];const codes="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";function getHangul(code){if(code>=40){code=code+168-40}else if(code>=19){code=code+97-19}return toUtf8String([225,(code>>6)+132,(code&63)+128])}let wordlist$5=null;function loadWords$5(lang){if(wordlist$5!=null){return}wordlist$5=[];data$1.forEach((data,length)=>{length+=4;for(let i=0;i<data.length;i+=length){let word="";for(let j=0;j<length;j++){word+=getHangul(codes.indexOf(data[i+j]))}wordlist$5.push(word)}});wordlist$5.sort();if(Wordlist.check(lang)!=="0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a"){wordlist$5=null;throw new Error("BIP39 Wordlist for ko (Korean) FAILED")}}class LangKo extends Wordlist{constructor(){super("ko")}getWord(index){loadWords$5(this);return wordlist$5[index]}getWordIndex(word){loadWords$5(this);return wordlist$5.indexOf(word)}}const langKo=new LangKo;Wordlist.register(langKo);"use strict";const words$4="AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa";let wordlist$6=null;function loadWords$6(lang){if(wordlist$6!=null){return}wordlist$6=words$4.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" ");if(Wordlist.check(lang)!=="0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620"){wordlist$6=null;throw new Error("BIP39 Wordlist for it (Italian) FAILED")}}class LangIt extends Wordlist{constructor(){super("it")}getWord(index){loadWords$6(this);return wordlist$6[index]}getWordIndex(word){loadWords$6(this);return wordlist$6.indexOf(word)}}const langIt=new LangIt;Wordlist.register(langIt);"use strict";const data$2="}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";const deltaData="FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";const wordlist$7={zh_cn:null,zh_tw:null};const Checks={zh_cn:"0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",zh_tw:"0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"};const codes$1="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";const style="~!@#$%^&*_-=[]{}|;:,.()<>?";function loadWords$7(lang){if(wordlist$7[lang.locale]!==null){return}wordlist$7[lang.locale]=[];let deltaOffset=0;for(let i=0;i<2048;i++){const s=style.indexOf(data$2[i*3]);const bytes=[228+(s>>2),128+codes$1.indexOf(data$2[i*3+1]),128+codes$1.indexOf(data$2[i*3+2])];if(lang.locale==="zh_tw"){const common=s%4;for(let i=common;i<3;i++){bytes[i]=codes$1.indexOf(deltaData[deltaOffset++])+(i==0?228:128)}}wordlist$7[lang.locale].push(toUtf8String(bytes))}if(Wordlist.check(lang)!==Checks[lang.locale]){wordlist$7[lang.locale]=null;throw new Error("BIP39 Wordlist for "+lang.locale+" (Chinese) FAILED")}}class LangZh extends Wordlist{constructor(country){super("zh_"+country)}getWord(index){loadWords$7(this);return wordlist$7[this.locale][index]}getWordIndex(word){loadWords$7(this);return wordlist$7[this.locale].indexOf(word)}split(mnemonic){mnemonic=mnemonic.replace(/(?:\u3000| )+/g,"");return mnemonic.split("")}}const langZhCn=new LangZh("cn");Wordlist.register(langZhCn);Wordlist.register(langZhCn,"zh");const langZhTw=new LangZh("tw");Wordlist.register(langZhTw);const wordlists={cz:langCz,en:langEn,es:langEs,fr:langFr,it:langIt,ja:langJa,ko:langKo,zh:langZhCn,zh_cn:langZhCn,zh_tw:langZhTw};"use strict";const version$g="hdnode/5.1.0";"use strict";const logger$l=new Logger(version$g);const N=BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const MasterSecret=toUtf8Bytes("Bitcoin seed");const HardenedBit=2147483648;function getUpperMask(bits){return(1<<bits)-1<<8-bits}function getLowerMask(bits){return(1<<bits)-1}function bytes32(value){return hexZeroPad(hexlify(value),32)}function base58check(data){return Base58.encode(concat([data,hexDataSlice(sha256$1(sha256$1(data)),0,4)]))}function getWordlist(wordlist){if(wordlist==null){return wordlists["en"]}if(typeof wordlist==="string"){const words=wordlists[wordlist];if(words==null){logger$l.throwArgumentError("unknown locale","wordlist",wordlist)}return words}return wordlist}const _constructorGuard$3={};const defaultPath="m/44'/60'/0'/0/0";class HDNode{constructor(constructorGuard,privateKey,publicKey,parentFingerprint,chainCode,index,depth,mnemonicOrPath){logger$l.checkNew(new.target,HDNode);if(constructorGuard!==_constructorGuard$3){throw new Error("HDNode constructor cannot be called directly")}if(privateKey){const signingKey=new SigningKey(privateKey);defineReadOnly(this,"privateKey",signingKey.privateKey);defineReadOnly(this,"publicKey",signingKey.compressedPublicKey)}else{defineReadOnly(this,"privateKey",null);defineReadOnly(this,"publicKey",hexlify(publicKey))}defineReadOnly(this,"parentFingerprint",parentFingerprint);defineReadOnly(this,"fingerprint",hexDataSlice(ripemd160$1(sha256$1(this.publicKey)),0,4));defineReadOnly(this,"address",computeAddress(this.publicKey));defineReadOnly(this,"chainCode",chainCode);defineReadOnly(this,"index",index);defineReadOnly(this,"depth",depth);if(mnemonicOrPath==null){defineReadOnly(this,"mnemonic",null);defineReadOnly(this,"path",null)}else if(typeof mnemonicOrPath==="string"){defineReadOnly(this,"mnemonic",null);defineReadOnly(this,"path",mnemonicOrPath)}else{defineReadOnly(this,"mnemonic",mnemonicOrPath);defineReadOnly(this,"path",mnemonicOrPath.path)}}get extendedKey(){if(this.depth>=256){throw new Error("Depth too large!")}return base58check(concat([this.privateKey!=null?"0x0488ADE4":"0x0488B21E",hexlify(this.depth),this.parentFingerprint,hexZeroPad(hexlify(this.index),4),this.chainCode,this.privateKey!=null?concat(["0x00",this.privateKey]):this.publicKey]))}neuter(){return new HDNode(_constructorGuard$3,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,this.path)}_derive(index){if(index>4294967295){throw new Error("invalid index - "+String(index))}let path=this.path;if(path){path+="/"+(index&~HardenedBit)}const data=new Uint8Array(37);if(index&HardenedBit){if(!this.privateKey){throw new Error("cannot derive child of neutered node")}data.set(arrayify(this.privateKey),1);if(path){path+="'"}}else{data.set(arrayify(this.publicKey))}for(let i=24;i>=0;i-=8){data[33+(i>>3)]=index>>24-i&255}const I=arrayify(computeHmac(SupportedAlgorithm.sha512,this.chainCode,data));const IL=I.slice(0,32);const IR=I.slice(32);let ki=null;let Ki=null;if(this.privateKey){ki=bytes32(BigNumber.from(IL).add(this.privateKey).mod(N))}else{const ek=new SigningKey(hexlify(IL));Ki=ek._addPoint(this.publicKey)}let mnemonicOrPath=path;const srcMnemonic=this.mnemonic;if(srcMnemonic){mnemonicOrPath=Object.freeze({phrase:srcMnemonic.phrase,path:path,locale:srcMnemonic.locale||"en"})}return new HDNode(_constructorGuard$3,ki,Ki,this.fingerprint,bytes32(IR),index,this.depth+1,mnemonicOrPath)}derivePath(path){const components=path.split("/");if(components.length===0||components[0]==="m"&&this.depth!==0){throw new Error("invalid path - "+path)}if(components[0]==="m"){components.shift()}let result=this;for(let i=0;i<components.length;i++){const component=components[i];if(component.match(/^[0-9]+'$/)){const index=parseInt(component.substring(0,component.length-1));if(index>=HardenedBit){throw new Error("invalid path index - "+component)}result=result._derive(HardenedBit+index)}else if(component.match(/^[0-9]+$/)){const index=parseInt(component);if(index>=HardenedBit){throw new Error("invalid path index - "+component)}result=result._derive(index)}else{throw new Error("invalid path component - "+component)}}return result}static _fromSeed(seed,mnemonic){const seedArray=arrayify(seed);if(seedArray.length<16||seedArray.length>64){throw new Error("invalid seed")}const I=arrayify(computeHmac(SupportedAlgorithm.sha512,MasterSecret,seedArray));return new HDNode(_constructorGuard$3,bytes32(I.slice(0,32)),null,"0x00000000",bytes32(I.slice(32)),0,0,mnemonic)}static fromMnemonic(mnemonic,password,wordlist){wordlist=getWordlist(wordlist);mnemonic=entropyToMnemonic(mnemonicToEntropy(mnemonic,wordlist),wordlist);return HDNode._fromSeed(mnemonicToSeed(mnemonic,password),{phrase:mnemonic,path:"m",locale:wordlist.locale})}static fromSeed(seed){return HDNode._fromSeed(seed,null)}static fromExtendedKey(extendedKey){const bytes=Base58.decode(extendedKey);if(bytes.length!==82||base58check(bytes.slice(0,78))!==extendedKey){logger$l.throwArgumentError("invalid extended key","extendedKey","[REDACTED]")}const depth=bytes[4];const parentFingerprint=hexlify(bytes.slice(5,9));const index=parseInt(hexlify(bytes.slice(9,13)).substring(2),16);const chainCode=hexlify(bytes.slice(13,45));const key=bytes.slice(45,78);switch(hexlify(bytes.slice(0,4))){case"0x0488b21e":case"0x043587cf":return new HDNode(_constructorGuard$3,null,hexlify(key),parentFingerprint,chainCode,index,depth,null);case"0x0488ade4":case"0x04358394 ":if(key[0]!==0){break}return new HDNode(_constructorGuard$3,hexlify(key.slice(1)),null,parentFingerprint,chainCode,index,depth,null)}return logger$l.throwArgumentError("invalid extended key","extendedKey","[REDACTED]")}}function mnemonicToSeed(mnemonic,password){if(!password){password=""}const salt=toUtf8Bytes("mnemonic"+password,UnicodeNormalizationForm.NFKD);return pbkdf2(toUtf8Bytes(mnemonic,UnicodeNormalizationForm.NFKD),salt,2048,64,"sha512")}function mnemonicToEntropy(mnemonic,wordlist){wordlist=getWordlist(wordlist);logger$l.checkNormalize();const words=wordlist.split(mnemonic);if(words.length%3!==0){throw new Error("invalid mnemonic")}const entropy=arrayify(new Uint8Array(Math.ceil(11*words.length/8)));let offset=0;for(let i=0;i<words.length;i++){let index=wordlist.getWordIndex(words[i].normalize("NFKD"));if(index===-1){throw new Error("invalid mnemonic")}for(let bit=0;bit<11;bit++){if(index&1<<10-bit){entropy[offset>>3]|=1<<7-offset%8}offset++}}const entropyBits=32*words.length/3;const checksumBits=words.length/3;const checksumMask=getUpperMask(checksumBits);const checksum=arrayify(sha256$1(entropy.slice(0,entropyBits/8)))[0]&checksumMask;if(checksum!==(entropy[entropy.length-1]&checksumMask)){throw new Error("invalid checksum")}return hexlify(entropy.slice(0,entropyBits/8))}function entropyToMnemonic(entropy,wordlist){wordlist=getWordlist(wordlist);entropy=arrayify(entropy);if(entropy.length%4!==0||entropy.length<16||entropy.length>32){throw new Error("invalid entropy")}const indices=[0];let remainingBits=11;for(let i=0;i<entropy.length;i++){if(remainingBits>8){indices[indices.length-1]<<=8;indices[indices.length-1]|=entropy[i];remainingBits-=8}else{indices[indices.length-1]<<=remainingBits;indices[indices.length-1]|=entropy[i]>>8-remainingBits;indices.push(entropy[i]&getLowerMask(8-remainingBits));remainingBits+=3}}const checksumBits=entropy.length/4;const checksum=arrayify(sha256$1(entropy))[0]&getUpperMask(checksumBits);indices[indices.length-1]<<=checksumBits;indices[indices.length-1]|=checksum>>8-checksumBits;return wordlist.join(indices.map(index=>wordlist.getWord(index)))}function isValidMnemonic(mnemonic,wordlist){try{mnemonicToEntropy(mnemonic,wordlist);return true}catch(error){}return false}const version$h="random/5.1.0";"use strict";const logger$m=new Logger(version$h);let anyGlobal=null;try{anyGlobal=window;if(anyGlobal==null){throw new Error("try next")}}catch(error){try{anyGlobal=__webpack_require__.g;if(anyGlobal==null){throw new Error("try next")}}catch(error){anyGlobal={}}}let crypto=anyGlobal.crypto||anyGlobal.msCrypto;if(!crypto||!crypto.getRandomValues){logger$m.warn("WARNING: Missing strong random number source");crypto={getRandomValues:function(buffer){return logger$m.throwError("no secure random source avaialble",Logger.errors.UNSUPPORTED_OPERATION,{operation:"crypto.getRandomValues"})}}}function randomBytes(length){if(length<=0||length>1024||length%1){logger$m.throwArgumentError("invalid length","length",length)}const result=new Uint8Array(length);crypto.getRandomValues(result);return arrayify(result)}"use strict";function shuffled(array){array=array.slice();for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));const tmp=array[i];array[i]=array[j];array[j]=tmp}return array}"use strict";var aesJs=createCommonjsModule(function(module,exports){"use strict";(function(root){function checkInt(value){return parseInt(value)===value}function checkInts(arrayish){if(!checkInt(arrayish.length)){return false}for(var i=0;i<arrayish.length;i++){if(!checkInt(arrayish[i])||arrayish[i]<0||arrayish[i]>255){return false}}return true}function coerceArray(arg,copy){if(arg.buffer&&ArrayBuffer.isView(arg)&&arg.name==="Uint8Array"){if(copy){if(arg.slice){arg=arg.slice()}else{arg=Array.prototype.slice.call(arg)}}return arg}if(Array.isArray(arg)){if(!checkInts(arg)){throw new Error("Array contains invalid value: "+arg)}return new Uint8Array(arg)}if(checkInt(arg.length)&&checkInts(arg)){return new Uint8Array(arg)}throw new Error("unsupported array-like object")}function createArray(length){return new Uint8Array(length)}function copyArray(sourceArray,targetArray,targetStart,sourceStart,sourceEnd){if(sourceStart!=null||sourceEnd!=null){if(sourceArray.slice){sourceArray=sourceArray.slice(sourceStart,sourceEnd)}else{sourceArray=Array.prototype.slice.call(sourceArray,sourceStart,sourceEnd)}}targetArray.set(sourceArray,targetStart)}var convertUtf8=function(){function toBytes(text){var result=[],i=0;text=encodeURI(text);while(i<text.length){var c=text.charCodeAt(i++);if(c===37){result.push(parseInt(text.substr(i,2),16));i+=2}else{result.push(c)}}return coerceArray(result)}function fromBytes(bytes){var result=[],i=0;while(i<bytes.length){var c=bytes[i];if(c<128){result.push(String.fromCharCode(c));i++}else if(c>191&&c<224){result.push(String.fromCharCode((c&31)<<6|bytes[i+1]&63));i+=2}else{result.push(String.fromCharCode((c&15)<<12|(bytes[i+1]&63)<<6|bytes[i+2]&63));i+=3}}return result.join("")}return{toBytes:toBytes,fromBytes:fromBytes}}();var convertHex=function(){function toBytes(text){var result=[];for(var i=0;i<text.length;i+=2){result.push(parseInt(text.substr(i,2),16))}return result}var Hex="0123456789abcdef";function fromBytes(bytes){var result=[];for(var i=0;i<bytes.length;i++){var v=bytes[i];result.push(Hex[(v&240)>>4]+Hex[v&15])}return result.join("")}return{toBytes:toBytes,fromBytes:fromBytes}}();var numberOfRounds={16:10,24:12,32:14};var rcon=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145];var S=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];var Si=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125];var T1=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986];var T2=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766];var T3=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126];var T4=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436];var T5=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890];var T6=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935];var T7=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600];var T8=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480];var U1=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795];var U2=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855];var U3=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150];var U4=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function convertToInt32(bytes){var result=[];for(var i=0;i<bytes.length;i+=4){result.push(bytes[i]<<24|bytes[i+1]<<16|bytes[i+2]<<8|bytes[i+3])}return result}var AES=function(key){if(!(this instanceof AES)){throw Error("AES must be instanitated with `new`")}Object.defineProperty(this,"key",{value:coerceArray(key,true)});this._prepare()};AES.prototype._prepare=function(){var rounds=numberOfRounds[this.key.length];if(rounds==null){throw new Error("invalid key size (must be 16, 24 or 32 bytes)")}this._Ke=[];this._Kd=[];for(var i=0;i<=rounds;i++){this._Ke.push([0,0,0,0]);this._Kd.push([0,0,0,0])}var roundKeyCount=(rounds+1)*4;var KC=this.key.length/4;var tk=convertToInt32(this.key);var index;for(var i=0;i<KC;i++){index=i>>2;this._Ke[index][i%4]=tk[i];this._Kd[rounds-index][i%4]=tk[i]}var rconpointer=0;var t=KC,tt;while(t<roundKeyCount){tt=tk[KC-1];tk[0]^=S[tt>>16&255]<<24^S[tt>>8&255]<<16^S[tt&255]<<8^S[tt>>24&255]^rcon[rconpointer]<<24;rconpointer+=1;if(KC!=8){for(var i=1;i<KC;i++){tk[i]^=tk[i-1]}}else{for(var i=1;i<KC/2;i++){tk[i]^=tk[i-1]}tt=tk[KC/2-1];tk[KC/2]^=S[tt&255]^S[tt>>8&255]<<8^S[tt>>16&255]<<16^S[tt>>24&255]<<24;for(var i=KC/2+1;i<KC;i++){tk[i]^=tk[i-1]}}var i=0,r,c;while(i<KC&&t<roundKeyCount){r=t>>2;c=t%4;this._Ke[r][c]=tk[i];this._Kd[rounds-r][c]=tk[i++];t++}}for(var r=1;r<rounds;r++){for(var c=0;c<4;c++){tt=this._Kd[r][c];this._Kd[r][c]=U1[tt>>24&255]^U2[tt>>16&255]^U3[tt>>8&255]^U4[tt&255]}}};AES.prototype.encrypt=function(plaintext){if(plaintext.length!=16){throw new Error("invalid plaintext size (must be 16 bytes)")}var rounds=this._Ke.length-1;var a=[0,0,0,0];var t=convertToInt32(plaintext);for(var i=0;i<4;i++){t[i]^=this._Ke[0][i]}for(var r=1;r<rounds;r++){for(var i=0;i<4;i++){a[i]=T1[t[i]>>24&255]^T2[t[(i+1)%4]>>16&255]^T3[t[(i+2)%4]>>8&255]^T4[t[(i+3)%4]&255]^this._Ke[r][i]}t=a.slice()}var result=createArray(16),tt;for(var i=0;i<4;i++){tt=this._Ke[rounds][i];result[4*i]=(S[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(S[t[(i+1)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(S[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(S[t[(i+3)%4]&255]^tt)&255}return result};AES.prototype.decrypt=function(ciphertext){if(ciphertext.length!=16){throw new Error("invalid ciphertext size (must be 16 bytes)")}var rounds=this._Kd.length-1;var a=[0,0,0,0];var t=convertToInt32(ciphertext);for(var i=0;i<4;i++){t[i]^=this._Kd[0][i]}for(var r=1;r<rounds;r++){for(var i=0;i<4;i++){a[i]=T5[t[i]>>24&255]^T6[t[(i+3)%4]>>16&255]^T7[t[(i+2)%4]>>8&255]^T8[t[(i+1)%4]&255]^this._Kd[r][i]}t=a.slice()}var result=createArray(16),tt;for(var i=0;i<4;i++){tt=this._Kd[rounds][i];result[4*i]=(Si[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(Si[t[(i+3)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(Si[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(Si[t[(i+1)%4]&255]^tt)&255}return result};var ModeOfOperationECB=function(key){if(!(this instanceof ModeOfOperationECB)){throw Error("AES must be instanitated with `new`")}this.description="Electronic Code Block";this.name="ecb";this._aes=new AES(key)};ModeOfOperationECB.prototype.encrypt=function(plaintext){plaintext=coerceArray(plaintext);if(plaintext.length%16!==0){throw new Error("invalid plaintext size (must be multiple of 16 bytes)")}var ciphertext=createArray(plaintext.length);var block=createArray(16);for(var i=0;i<plaintext.length;i+=16){copyArray(plaintext,block,0,i,i+16);block=this._aes.encrypt(block);copyArray(block,ciphertext,i)}return ciphertext};ModeOfOperationECB.prototype.decrypt=function(ciphertext){ciphertext=coerceArray(ciphertext);if(ciphertext.length%16!==0){throw new Error("invalid ciphertext size (must be multiple of 16 bytes)")}var plaintext=createArray(ciphertext.length);var block=createArray(16);for(var i=0;i<ciphertext.length;i+=16){copyArray(ciphertext,block,0,i,i+16);block=this._aes.decrypt(block);copyArray(block,plaintext,i)}return plaintext};var ModeOfOperationCBC=function(key,iv){if(!(this instanceof ModeOfOperationCBC)){throw Error("AES must be instanitated with `new`")}this.description="Cipher Block Chaining";this.name="cbc";if(!iv){iv=createArray(16)}else if(iv.length!=16){throw new Error("invalid initialation vector size (must be 16 bytes)")}this._lastCipherblock=coerceArray(iv,true);this._aes=new AES(key)};ModeOfOperationCBC.prototype.encrypt=function(plaintext){plaintext=coerceArray(plaintext);if(plaintext.length%16!==0){throw new Error("invalid plaintext size (must be multiple of 16 bytes)")}var ciphertext=createArray(plaintext.length);var block=createArray(16);for(var i=0;i<plaintext.length;i+=16){copyArray(plaintext,block,0,i,i+16);for(var j=0;j<16;j++){block[j]^=this._lastCipherblock[j]}this._lastCipherblock=this._aes.encrypt(block);copyArray(this._lastCipherblock,ciphertext,i)}return ciphertext};ModeOfOperationCBC.prototype.decrypt=function(ciphertext){ciphertext=coerceArray(ciphertext);if(ciphertext.length%16!==0){throw new Error("invalid ciphertext size (must be multiple of 16 bytes)")}var plaintext=createArray(ciphertext.length);var block=createArray(16);for(var i=0;i<ciphertext.length;i+=16){copyArray(ciphertext,block,0,i,i+16);block=this._aes.decrypt(block);for(var j=0;j<16;j++){plaintext[i+j]=block[j]^this._lastCipherblock[j]}copyArray(ciphertext,this._lastCipherblock,0,i,i+16)}return plaintext};var ModeOfOperationCFB=function(key,iv,segmentSize){if(!(this instanceof ModeOfOperationCFB)){throw Error("AES must be instanitated with `new`")}this.description="Cipher Feedback";this.name="cfb";if(!iv){iv=createArray(16)}else if(iv.length!=16){throw new Error("invalid initialation vector size (must be 16 size)")}if(!segmentSize){segmentSize=1}this.segmentSize=segmentSize;this._shiftRegister=coerceArray(iv,true);this._aes=new AES(key)};ModeOfOperationCFB.prototype.encrypt=function(plaintext){if(plaintext.length%this.segmentSize!=0){throw new Error("invalid plaintext size (must be segmentSize bytes)")}var encrypted=coerceArray(plaintext,true);var xorSegment;for(var i=0;i<encrypted.length;i+=this.segmentSize){xorSegment=this._aes.encrypt(this._shiftRegister);for(var j=0;j<this.segmentSize;j++){encrypted[i+j]^=xorSegment[j]}copyArray(this._shiftRegister,this._shiftRegister,0,this.segmentSize);copyArray(encrypted,this._shiftRegister,16-this.segmentSize,i,i+this.segmentSize)}return encrypted};ModeOfOperationCFB.prototype.decrypt=function(ciphertext){if(ciphertext.length%this.segmentSize!=0){throw new Error("invalid ciphertext size (must be segmentSize bytes)")}var plaintext=coerceArray(ciphertext,true);var xorSegment;for(var i=0;i<plaintext.length;i+=this.segmentSize){xorSegment=this._aes.encrypt(this._shiftRegister);for(var j=0;j<this.segmentSize;j++){plaintext[i+j]^=xorSegment[j]}copyArray(this._shiftRegister,this._shiftRegister,0,this.segmentSize);copyArray(ciphertext,this._shiftRegister,16-this.segmentSize,i,i+this.segmentSize)}return plaintext};var ModeOfOperationOFB=function(key,iv){if(!(this instanceof ModeOfOperationOFB)){throw Error("AES must be instanitated with `new`")}this.description="Output Feedback";this.name="ofb";if(!iv){iv=createArray(16)}else if(iv.length!=16){throw new Error("invalid initialation vector size (must be 16 bytes)")}this._lastPrecipher=coerceArray(iv,true);this._lastPrecipherIndex=16;this._aes=new AES(key)};ModeOfOperationOFB.prototype.encrypt=function(plaintext){var encrypted=coerceArray(plaintext,true);for(var i=0;i<encrypted.length;i++){if(this._lastPrecipherIndex===16){this._lastPrecipher=this._aes.encrypt(this._lastPrecipher);this._lastPrecipherIndex=0}encrypted[i]^=this._lastPrecipher[this._lastPrecipherIndex++]}return encrypted};ModeOfOperationOFB.prototype.decrypt=ModeOfOperationOFB.prototype.encrypt;var Counter=function(initialValue){if(!(this instanceof Counter)){throw Error("Counter must be instanitated with `new`")}if(initialValue!==0&&!initialValue){initialValue=1}if(typeof initialValue==="number"){this._counter=createArray(16);this.setValue(initialValue)}else{this.setBytes(initialValue)}};Counter.prototype.setValue=function(value){if(typeof value!=="number"||parseInt(value)!=value){throw new Error("invalid counter value (must be an integer)")}for(var index=15;index>=0;--index){this._counter[index]=value%256;value=value>>8}};Counter.prototype.setBytes=function(bytes){bytes=coerceArray(bytes,true);if(bytes.length!=16){throw new Error("invalid counter bytes size (must be 16 bytes)")}this._counter=bytes};Counter.prototype.increment=function(){for(var i=15;i>=0;i--){if(this._counter[i]===255){this._counter[i]=0}else{this._counter[i]++;break}}};var ModeOfOperationCTR=function(key,counter){if(!(this instanceof ModeOfOperationCTR)){throw Error("AES must be instanitated with `new`")}this.description="Counter";this.name="ctr";if(!(counter instanceof Counter)){counter=new Counter(counter)}this._counter=counter;this._remainingCounter=null;this._remainingCounterIndex=16;this._aes=new AES(key)};ModeOfOperationCTR.prototype.encrypt=function(plaintext){var encrypted=coerceArray(plaintext,true);for(var i=0;i<encrypted.length;i++){if(this._remainingCounterIndex===16){this._remainingCounter=this._aes.encrypt(this._counter._counter);this._remainingCounterIndex=0;this._counter.increment()}encrypted[i]^=this._remainingCounter[this._remainingCounterIndex++]}return encrypted};ModeOfOperationCTR.prototype.decrypt=ModeOfOperationCTR.prototype.encrypt;function pkcs7pad(data){data=coerceArray(data,true);var padder=16-data.length%16;var result=createArray(data.length+padder);copyArray(data,result);for(var i=data.length;i<result.length;i++){result[i]=padder}return result}function pkcs7strip(data){data=coerceArray(data,true);if(data.length<16){throw new Error("PKCS#7 invalid length")}var padder=data[data.length-1];if(padder>16){throw new Error("PKCS#7 padding byte out of range")}var length=data.length-padder;for(var i=0;i<padder;i++){if(data[length+i]!==padder){throw new Error("PKCS#7 invalid padding byte")}}var result=createArray(length);copyArray(data,result,0,0,length);return result}var aesjs={AES:AES,Counter:Counter,ModeOfOperation:{ecb:ModeOfOperationECB,cbc:ModeOfOperationCBC,cfb:ModeOfOperationCFB,ofb:ModeOfOperationOFB,ctr:ModeOfOperationCTR},utils:{hex:convertHex,utf8:convertUtf8},padding:{pkcs7:{pad:pkcs7pad,strip:pkcs7strip}},_arrayTest:{coerceArray:coerceArray,createArray:createArray,copyArray:copyArray}};if(true){module.exports=aesjs}else {}})(commonjsGlobal)});const version$i="json-wallets/5.1.0";"use strict";function looseArrayify(hexString){if(typeof hexString==="string"&&hexString.substring(0,2)!=="0x"){hexString="0x"+hexString}return arrayify(hexString)}function zpad(value,length){value=String(value);while(value.length<length){value="0"+value}return value}function getPassword(password){if(typeof password==="string"){return toUtf8Bytes(password,UnicodeNormalizationForm.NFKC)}return arrayify(password)}function searchPath(object,path){let currentChild=object;const comps=path.toLowerCase().split("/");for(let i=0;i<comps.length;i++){let matchingChild=null;for(const key in currentChild){if(key.toLowerCase()===comps[i]){matchingChild=currentChild[key];break}}if(matchingChild===null){return null}currentChild=matchingChild}return currentChild}function uuidV4(randomBytes){const bytes=arrayify(randomBytes);bytes[6]=bytes[6]&15|64;bytes[8]=bytes[8]&63|128;const value=hexlify(bytes);return[value.substring(2,10),value.substring(10,14),value.substring(14,18),value.substring(18,22),value.substring(22,34)].join("-")}"use strict";const logger$n=new Logger(version$i);class CrowdsaleAccount extends Description{isCrowdsaleAccount(value){return!!(value&&value._isCrowdsaleAccount)}}function decrypt(json,password){const data=JSON.parse(json);password=getPassword(password);const ethaddr=getAddress(searchPath(data,"ethaddr"));const encseed=looseArrayify(searchPath(data,"encseed"));if(!encseed||encseed.length%16!==0){logger$n.throwArgumentError("invalid encseed","json",json)}const key=arrayify(pbkdf2(password,password,2e3,32,"sha256")).slice(0,16);const iv=encseed.slice(0,16);const encryptedSeed=encseed.slice(16);const aesCbc=new aesJs.ModeOfOperation.cbc(key,iv);const seed=aesJs.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));let seedHex="";for(let i=0;i<seed.length;i++){seedHex+=String.fromCharCode(seed[i])}const seedHexBytes=toUtf8Bytes(seedHex);const privateKey=keccak256(seedHexBytes);return new CrowdsaleAccount({_isCrowdsaleAccount:true,address:ethaddr,privateKey:privateKey})}"use strict";function isCrowdsaleWallet(json){let data=null;try{data=JSON.parse(json)}catch(error){return false}return data.encseed&&data.ethaddr}function isKeystoreWallet(json){let data=null;try{data=JSON.parse(json)}catch(error){return false}if(!data.version||parseInt(data.version)!==data.version||parseInt(data.version)!==3){return false}return true}function getJsonWalletAddress(json){if(isCrowdsaleWallet(json)){try{return getAddress(JSON.parse(json).ethaddr)}catch(error){return null}}if(isKeystoreWallet(json)){try{return getAddress(JSON.parse(json).address)}catch(error){return null}}return null}var scrypt=createCommonjsModule(function(module,exports){"use strict";(function(root){const MAX_VALUE=2147483647;function SHA256(m){const K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);let h0=1779033703,h1=3144134277,h2=1013904242,h3=2773480762;let h4=1359893119,h5=2600822924,h6=528734635,h7=1541459225;const w=new Uint32Array(64);function blocks(p){let off=0,len=p.length;while(len>=64){let a=h0,b=h1,c=h2,d=h3,e=h4,f=h5,g=h6,h=h7,u,i,j,t1,t2;for(i=0;i<16;i++){j=off+i*4;w[i]=(p[j]&255)<<24|(p[j+1]&255)<<16|(p[j+2]&255)<<8|p[j+3]&255}for(i=16;i<64;i++){u=w[i-2];t1=(u>>>17|u<<32-17)^(u>>>19|u<<32-19)^u>>>10;u=w[i-15];t2=(u>>>7|u<<32-7)^(u>>>18|u<<32-18)^u>>>3;w[i]=(t1+w[i-7]|0)+(t2+w[i-16]|0)|0}for(i=0;i<64;i++){t1=(((e>>>6|e<<32-6)^(e>>>11|e<<32-11)^(e>>>25|e<<32-25))+(e&f^~e&g)|0)+(h+(K[i]+w[i]|0)|0)|0;t2=((a>>>2|a<<32-2)^(a>>>13|a<<32-13)^(a>>>22|a<<32-22))+(a&b^a&c^b&c)|0;h=g;g=f;f=e;e=d+t1|0;d=c;c=b;b=a;a=t1+t2|0}h0=h0+a|0;h1=h1+b|0;h2=h2+c|0;h3=h3+d|0;h4=h4+e|0;h5=h5+f|0;h6=h6+g|0;h7=h7+h|0;off+=64;len-=64}}blocks(m);let i,bytesLeft=m.length%64,bitLenHi=m.length/536870912|0,bitLenLo=m.length<<3,numZeros=bytesLeft<56?56:120,p=m.slice(m.length-bytesLeft,m.length);p.push(128);for(i=bytesLeft+1;i<numZeros;i++){p.push(0)}p.push(bitLenHi>>>24&255);p.push(bitLenHi>>>16&255);p.push(bitLenHi>>>8&255);p.push(bitLenHi>>>0&255);p.push(bitLenLo>>>24&255);p.push(bitLenLo>>>16&255);p.push(bitLenLo>>>8&255);p.push(bitLenLo>>>0&255);blocks(p);return[h0>>>24&255,h0>>>16&255,h0>>>8&255,h0>>>0&255,h1>>>24&255,h1>>>16&255,h1>>>8&255,h1>>>0&255,h2>>>24&255,h2>>>16&255,h2>>>8&255,h2>>>0&255,h3>>>24&255,h3>>>16&255,h3>>>8&255,h3>>>0&255,h4>>>24&255,h4>>>16&255,h4>>>8&255,h4>>>0&255,h5>>>24&255,h5>>>16&255,h5>>>8&255,h5>>>0&255,h6>>>24&255,h6>>>16&255,h6>>>8&255,h6>>>0&255,h7>>>24&255,h7>>>16&255,h7>>>8&255,h7>>>0&255]}function PBKDF2_HMAC_SHA256_OneIter(password,salt,dkLen){password=password.length<=64?password:SHA256(password);const innerLen=64+salt.length+4;const inner=new Array(innerLen);const outerKey=new Array(64);let i;let dk=[];for(i=0;i<64;i++){inner[i]=54}for(i=0;i<password.length;i++){inner[i]^=password[i]}for(i=0;i<salt.length;i++){inner[64+i]=salt[i]}for(i=innerLen-4;i<innerLen;i++){inner[i]=0}for(i=0;i<64;i++)outerKey[i]=92;for(i=0;i<password.length;i++)outerKey[i]^=password[i];function incrementCounter(){for(let i=innerLen-1;i>=innerLen-4;i--){inner[i]++;if(inner[i]<=255)return;inner[i]=0}}while(dkLen>=32){incrementCounter();dk=dk.concat(SHA256(outerKey.concat(SHA256(inner))));dkLen-=32}if(dkLen>0){incrementCounter();dk=dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0,dkLen))}return dk}function blockmix_salsa8(BY,Yi,r,x,_X){let i;arraycopy(BY,(2*r-1)*16,_X,0,16);for(i=0;i<2*r;i++){blockxor(BY,i*16,_X,16);salsa20_8(_X,x);arraycopy(_X,0,BY,Yi+i*16,16)}for(i=0;i<r;i++){arraycopy(BY,Yi+i*2*16,BY,i*16,16)}for(i=0;i<r;i++){arraycopy(BY,Yi+(i*2+1)*16,BY,(i+r)*16,16)}}function R(a,b){return a<<b|a>>>32-b}function salsa20_8(B,x){arraycopy(B,0,x,0,16);for(let i=8;i>0;i-=2){x[4]^=R(x[0]+x[12],7);x[8]^=R(x[4]+x[0],9);x[12]^=R(x[8]+x[4],13);x[0]^=R(x[12]+x[8],18);x[9]^=R(x[5]+x[1],7);x[13]^=R(x[9]+x[5],9);x[1]^=R(x[13]+x[9],13);x[5]^=R(x[1]+x[13],18);x[14]^=R(x[10]+x[6],7);x[2]^=R(x[14]+x[10],9);x[6]^=R(x[2]+x[14],13);x[10]^=R(x[6]+x[2],18);x[3]^=R(x[15]+x[11],7);x[7]^=R(x[3]+x[15],9);x[11]^=R(x[7]+x[3],13);x[15]^=R(x[11]+x[7],18);x[1]^=R(x[0]+x[3],7);x[2]^=R(x[1]+x[0],9);x[3]^=R(x[2]+x[1],13);x[0]^=R(x[3]+x[2],18);x[6]^=R(x[5]+x[4],7);x[7]^=R(x[6]+x[5],9);x[4]^=R(x[7]+x[6],13);x[5]^=R(x[4]+x[7],18);x[11]^=R(x[10]+x[9],7);x[8]^=R(x[11]+x[10],9);x[9]^=R(x[8]+x[11],13);x[10]^=R(x[9]+x[8],18);x[12]^=R(x[15]+x[14],7);x[13]^=R(x[12]+x[15],9);x[14]^=R(x[13]+x[12],13);x[15]^=R(x[14]+x[13],18)}for(let i=0;i<16;++i){B[i]+=x[i]}}function blockxor(S,Si,D,len){for(let i=0;i<len;i++){D[i]^=S[Si+i]}}function arraycopy(src,srcPos,dest,destPos,length){while(length--){dest[destPos++]=src[srcPos++]}}function checkBufferish(o){if(!o||typeof o.length!=="number"){return false}for(let i=0;i<o.length;i++){const v=o[i];if(typeof v!=="number"||v%1||v<0||v>=256){return false}}return true}function ensureInteger(value,name){if(typeof value!=="number"||value%1){throw new Error("invalid "+name)}return value}function _scrypt(password,salt,N,r,p,dkLen,callback){N=ensureInteger(N,"N");r=ensureInteger(r,"r");p=ensureInteger(p,"p");dkLen=ensureInteger(dkLen,"dkLen");if(N===0||(N&N-1)!==0){throw new Error("N must be power of 2")}if(N>MAX_VALUE/128/r){throw new Error("N too large")}if(r>MAX_VALUE/128/p){throw new Error("r too large")}if(!checkBufferish(password)){throw new Error("password must be an array or buffer")}password=Array.prototype.slice.call(password);if(!checkBufferish(salt)){throw new Error("salt must be an array or buffer")}salt=Array.prototype.slice.call(salt);let b=PBKDF2_HMAC_SHA256_OneIter(password,salt,p*128*r);const B=new Uint32Array(p*32*r);for(let i=0;i<B.length;i++){const j=i*4;B[i]=(b[j+3]&255)<<24|(b[j+2]&255)<<16|(b[j+1]&255)<<8|(b[j+0]&255)<<0}const XY=new Uint32Array(64*r);const V=new Uint32Array(32*r*N);const Yi=32*r;const x=new Uint32Array(16);const _X=new Uint32Array(16);const totalOps=p*N*2;let currentOp=0;let lastPercent10=null;let stop=false;let state=0;let i0=0,i1;let Bi;const limit=callback?parseInt(1e3/r):4294967295;const nextTick=typeof setImmediate!=="undefined"?setImmediate:setTimeout;const incrementalSMix=function(){if(stop){return callback(new Error("cancelled"),currentOp/totalOps)}let steps;switch(state){case 0:Bi=i0*32*r;arraycopy(B,Bi,XY,0,Yi);state=1;i1=0;case 1:steps=N-i1;if(steps>limit){steps=limit}for(let i=0;i<steps;i++){arraycopy(XY,0,V,(i1+i)*Yi,Yi);blockmix_salsa8(XY,Yi,r,x,_X)}i1+=steps;currentOp+=steps;if(callback){const percent10=parseInt(1e3*currentOp/totalOps);if(percent10!==lastPercent10){stop=callback(null,currentOp/totalOps);if(stop){break}lastPercent10=percent10}}if(i1<N){break}i1=0;state=2;case 2:steps=N-i1;if(steps>limit){steps=limit}for(let i=0;i<steps;i++){const offset=(2*r-1)*16;const j=XY[offset]&N-1;blockxor(V,j*Yi,XY,Yi);blockmix_salsa8(XY,Yi,r,x,_X)}i1+=steps;currentOp+=steps;if(callback){const percent10=parseInt(1e3*currentOp/totalOps);if(percent10!==lastPercent10){stop=callback(null,currentOp/totalOps);if(stop){break}lastPercent10=percent10}}if(i1<N){break}arraycopy(XY,0,B,Bi,Yi);i0++;if(i0<p){state=0;break}b=[];for(let i=0;i<B.length;i++){b.push(B[i]>>0&255);b.push(B[i]>>8&255);b.push(B[i]>>16&255);b.push(B[i]>>24&255)}const derivedKey=PBKDF2_HMAC_SHA256_OneIter(password,b,dkLen);if(callback){callback(null,1,derivedKey)}return derivedKey}if(callback){nextTick(incrementalSMix)}};if(!callback){while(true){const derivedKey=incrementalSMix();if(derivedKey!=undefined){return derivedKey}}}incrementalSMix()}const lib={scrypt:function(password,salt,N,r,p,dkLen,progressCallback){return new Promise(function(resolve,reject){let lastProgress=0;if(progressCallback){progressCallback(0)}_scrypt(password,salt,N,r,p,dkLen,function(error,progress,key){if(error){reject(error)}else if(key){if(progressCallback&&lastProgress!==1){progressCallback(1)}resolve(new Uint8Array(key))}else if(progressCallback&&progress!==lastProgress){lastProgress=progress;return progressCallback(progress)}})})},syncScrypt:function(password,salt,N,r,p,dkLen){return new Uint8Array(_scrypt(password,salt,N,r,p,dkLen))}};if(true){module.exports=lib}else {}})(commonjsGlobal)});"use strict";var __awaiter$4=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$o=new Logger(version$i);function hasMnemonic(value){return value!=null&&value.mnemonic&&value.mnemonic.phrase}class KeystoreAccount extends Description{isKeystoreAccount(value){return!!(value&&value._isKeystoreAccount)}}function _decrypt(data,key,ciphertext){const cipher=searchPath(data,"crypto/cipher");if(cipher==="aes-128-ctr"){const iv=looseArrayify(searchPath(data,"crypto/cipherparams/iv"));const counter=new aesJs.Counter(iv);const aesCtr=new aesJs.ModeOfOperation.ctr(key,counter);return arrayify(aesCtr.decrypt(ciphertext))}return null}function _getAccount(data,key){const ciphertext=looseArrayify(searchPath(data,"crypto/ciphertext"));const computedMAC=hexlify(keccak256(concat([key.slice(16,32),ciphertext]))).substring(2);if(computedMAC!==searchPath(data,"crypto/mac").toLowerCase()){throw new Error("invalid password")}const privateKey=_decrypt(data,key.slice(0,16),ciphertext);if(!privateKey){logger$o.throwError("unsupported cipher",Logger.errors.UNSUPPORTED_OPERATION,{operation:"decrypt"})}const mnemonicKey=key.slice(32,64);const address=computeAddress(privateKey);if(data.address){let check=data.address.toLowerCase();if(check.substring(0,2)!=="0x"){check="0x"+check}if(getAddress(check)!==address){throw new Error("address mismatch")}}const account={_isKeystoreAccount:true,address:address,privateKey:hexlify(privateKey)};if(searchPath(data,"x-ethers/version")==="0.1"){const mnemonicCiphertext=looseArrayify(searchPath(data,"x-ethers/mnemonicCiphertext"));const mnemonicIv=looseArrayify(searchPath(data,"x-ethers/mnemonicCounter"));const mnemonicCounter=new aesJs.Counter(mnemonicIv);const mnemonicAesCtr=new aesJs.ModeOfOperation.ctr(mnemonicKey,mnemonicCounter);const path=searchPath(data,"x-ethers/path")||defaultPath;const locale=searchPath(data,"x-ethers/locale")||"en";const entropy=arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));try{const mnemonic=entropyToMnemonic(entropy,locale);const node=HDNode.fromMnemonic(mnemonic,null,locale).derivePath(path);if(node.privateKey!=account.privateKey){throw new Error("mnemonic mismatch")}account.mnemonic=node.mnemonic}catch(error){if(error.code!==Logger.errors.INVALID_ARGUMENT||error.argument!=="wordlist"){throw error}}}return new KeystoreAccount(account)}function pbkdf2Sync(passwordBytes,salt,count,dkLen,prfFunc){return arrayify(pbkdf2(passwordBytes,salt,count,dkLen,prfFunc))}function pbkdf2$1(passwordBytes,salt,count,dkLen,prfFunc){return Promise.resolve(pbkdf2Sync(passwordBytes,salt,count,dkLen,prfFunc))}function _computeKdfKey(data,password,pbkdf2Func,scryptFunc,progressCallback){const passwordBytes=getPassword(password);const kdf=searchPath(data,"crypto/kdf");if(kdf&&typeof kdf==="string"){const throwError=function(name,value){return logger$o.throwArgumentError("invalid key-derivation function parameters",name,value)};if(kdf.toLowerCase()==="scrypt"){const salt=looseArrayify(searchPath(data,"crypto/kdfparams/salt"));const N=parseInt(searchPath(data,"crypto/kdfparams/n"));const r=parseInt(searchPath(data,"crypto/kdfparams/r"));const p=parseInt(searchPath(data,"crypto/kdfparams/p"));if(!N||!r||!p){throwError("kdf",kdf)}if((N&N-1)!==0){throwError("N",N)}const dkLen=parseInt(searchPath(data,"crypto/kdfparams/dklen"));if(dkLen!==32){throwError("dklen",dkLen)}return scryptFunc(passwordBytes,salt,N,r,p,64,progressCallback)}else if(kdf.toLowerCase()==="pbkdf2"){const salt=looseArrayify(searchPath(data,"crypto/kdfparams/salt"));let prfFunc=null;const prf=searchPath(data,"crypto/kdfparams/prf");if(prf==="hmac-sha256"){prfFunc="sha256"}else if(prf==="hmac-sha512"){prfFunc="sha512"}else{throwError("prf",prf)}const count=parseInt(searchPath(data,"crypto/kdfparams/c"));const dkLen=parseInt(searchPath(data,"crypto/kdfparams/dklen"));if(dkLen!==32){throwError("dklen",dkLen)}return pbkdf2Func(passwordBytes,salt,count,dkLen,prfFunc)}}return logger$o.throwArgumentError("unsupported key-derivation function","kdf",kdf)}function decryptSync(json,password){const data=JSON.parse(json);const key=_computeKdfKey(data,password,pbkdf2Sync,scrypt.syncScrypt);return _getAccount(data,key)}function decrypt$1(json,password,progressCallback){return __awaiter$4(this,void 0,void 0,function*(){const data=JSON.parse(json);const key=yield _computeKdfKey(data,password,pbkdf2$1,scrypt.scrypt,progressCallback);return _getAccount(data,key)})}function encrypt(account,password,options,progressCallback){try{if(getAddress(account.address)!==computeAddress(account.privateKey)){throw new Error("address/privateKey mismatch")}if(hasMnemonic(account)){const mnemonic=account.mnemonic;const node=HDNode.fromMnemonic(mnemonic.phrase,null,mnemonic.locale).derivePath(mnemonic.path||defaultPath);if(node.privateKey!=account.privateKey){throw new Error("mnemonic mismatch")}}}catch(e){return Promise.reject(e)}if(typeof options==="function"&&!progressCallback){progressCallback=options;options={}}if(!options){options={}}const privateKey=arrayify(account.privateKey);const passwordBytes=getPassword(password);let entropy=null;let path=null;let locale=null;if(hasMnemonic(account)){const srcMnemonic=account.mnemonic;entropy=arrayify(mnemonicToEntropy(srcMnemonic.phrase,srcMnemonic.locale||"en"));path=srcMnemonic.path||defaultPath;locale=srcMnemonic.locale||"en"}let client=options.client;if(!client){client="ethers.js"}let salt=null;if(options.salt){salt=arrayify(options.salt)}else{salt=randomBytes(32)}let iv=null;if(options.iv){iv=arrayify(options.iv);if(iv.length!==16){throw new Error("invalid iv")}}else{iv=randomBytes(16)}let uuidRandom=null;if(options.uuid){uuidRandom=arrayify(options.uuid);if(uuidRandom.length!==16){throw new Error("invalid uuid")}}else{uuidRandom=randomBytes(16)}let N=1<<17,r=8,p=1;if(options.scrypt){if(options.scrypt.N){N=options.scrypt.N}if(options.scrypt.r){r=options.scrypt.r}if(options.scrypt.p){p=options.scrypt.p}}return scrypt.scrypt(passwordBytes,salt,N,r,p,64,progressCallback).then(key=>{key=arrayify(key);const derivedKey=key.slice(0,16);const macPrefix=key.slice(16,32);const mnemonicKey=key.slice(32,64);const counter=new aesJs.Counter(iv);const aesCtr=new aesJs.ModeOfOperation.ctr(derivedKey,counter);const ciphertext=arrayify(aesCtr.encrypt(privateKey));const mac=keccak256(concat([macPrefix,ciphertext]));const data={address:account.address.substring(2).toLowerCase(),id:uuidV4(uuidRandom),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:hexlify(iv).substring(2)},ciphertext:hexlify(ciphertext).substring(2),kdf:"scrypt",kdfparams:{salt:hexlify(salt).substring(2),n:N,dklen:32,p:p,r:r},mac:mac.substring(2)}};if(entropy){const mnemonicIv=randomBytes(16);const mnemonicCounter=new aesJs.Counter(mnemonicIv);const mnemonicAesCtr=new aesJs.ModeOfOperation.ctr(mnemonicKey,mnemonicCounter);const mnemonicCiphertext=arrayify(mnemonicAesCtr.encrypt(entropy));const now=new Date;const timestamp=now.getUTCFullYear()+"-"+zpad(now.getUTCMonth()+1,2)+"-"+zpad(now.getUTCDate(),2)+"T"+zpad(now.getUTCHours(),2)+"-"+zpad(now.getUTCMinutes(),2)+"-"+zpad(now.getUTCSeconds(),2)+".0Z";data["x-ethers"]={client:client,gethFilename:"UTC--"+timestamp+"--"+data.address,mnemonicCounter:hexlify(mnemonicIv).substring(2),mnemonicCiphertext:hexlify(mnemonicCiphertext).substring(2),path:path,locale:locale,version:"0.1"}}return JSON.stringify(data)})}"use strict";function decryptJsonWallet(json,password,progressCallback){if(isCrowdsaleWallet(json)){if(progressCallback){progressCallback(0)}const account=decrypt(json,password);if(progressCallback){progressCallback(1)}return Promise.resolve(account)}if(isKeystoreWallet(json)){return decrypt$1(json,password,progressCallback)}return Promise.reject(new Error("invalid JSON wallet"))}function decryptJsonWalletSync(json,password){if(isCrowdsaleWallet(json)){return decrypt(json,password)}if(isKeystoreWallet(json)){return decryptSync(json,password)}throw new Error("invalid JSON wallet")}const version$j="wallet/5.1.0";"use strict";var __awaiter$5=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$p=new Logger(version$j);function isAccount(value){return value!=null&&isHexString(value.privateKey,32)&&value.address!=null}function hasMnemonic$1(value){const mnemonic=value.mnemonic;return mnemonic&&mnemonic.phrase}class Wallet extends Signer{constructor(privateKey,provider){logger$p.checkNew(new.target,Wallet);super();if(isAccount(privateKey)){const signingKey=new SigningKey(privateKey.privateKey);defineReadOnly(this,"_signingKey",()=>signingKey);defineReadOnly(this,"address",computeAddress(this.publicKey));if(this.address!==getAddress(privateKey.address)){logger$p.throwArgumentError("privateKey/address mismatch","privateKey","[REDACTED]")}if(hasMnemonic$1(privateKey)){const srcMnemonic=privateKey.mnemonic;defineReadOnly(this,"_mnemonic",()=>({phrase:srcMnemonic.phrase,path:srcMnemonic.path||defaultPath,locale:srcMnemonic.locale||"en"}));const mnemonic=this.mnemonic;const node=HDNode.fromMnemonic(mnemonic.phrase,null,mnemonic.locale).derivePath(mnemonic.path);if(computeAddress(node.privateKey)!==this.address){logger$p.throwArgumentError("mnemonic/address mismatch","privateKey","[REDACTED]")}}else{defineReadOnly(this,"_mnemonic",()=>null)}}else{if(SigningKey.isSigningKey(privateKey)){if(privateKey.curve!=="secp256k1"){logger$p.throwArgumentError("unsupported curve; must be secp256k1","privateKey","[REDACTED]")}defineReadOnly(this,"_signingKey",()=>privateKey)}else{if(typeof privateKey==="string"){if(privateKey.match(/^[0-9a-f]*$/i)&&privateKey.length===64){privateKey="0x"+privateKey}}const signingKey=new SigningKey(privateKey);defineReadOnly(this,"_signingKey",()=>signingKey)}defineReadOnly(this,"_mnemonic",()=>null);defineReadOnly(this,"address",computeAddress(this.publicKey))}if(provider&&!Provider.isProvider(provider)){logger$p.throwArgumentError("invalid provider","provider",provider)}defineReadOnly(this,"provider",provider||null)}get mnemonic(){return this._mnemonic()}get privateKey(){return this._signingKey().privateKey}get publicKey(){return this._signingKey().publicKey}getAddress(){return Promise.resolve(this.address)}connect(provider){return new Wallet(this,provider)}signTransaction(transaction){return resolveProperties(transaction).then(tx=>{if(tx.from!=null){if(getAddress(tx.from)!==this.address){logger$p.throwArgumentError("transaction from address mismatch","transaction.from",transaction.from)}delete tx.from}const signature=this._signingKey().signDigest(keccak256(serialize(tx)));return serialize(tx,signature)})}signMessage(message){return __awaiter$5(this,void 0,void 0,function*(){return joinSignature(this._signingKey().signDigest(hashMessage(message)))})}_signTypedData(domain,types,value){return __awaiter$5(this,void 0,void 0,function*(){const populated=yield TypedDataEncoder.resolveNames(domain,types,value,name=>{if(this.provider==null){logger$p.throwError("cannot resolve ENS names without a provider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resolveName",value:name})}return this.provider.resolveName(name)});return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain,types,populated.value)))})}encrypt(password,options,progressCallback){if(typeof options==="function"&&!progressCallback){progressCallback=options;options={}}if(progressCallback&&typeof progressCallback!=="function"){throw new Error("invalid callback")}if(!options){options={}}return encrypt(this,password,options,progressCallback)}static createRandom(options){let entropy=randomBytes(16);if(!options){options={}}if(options.extraEntropy){entropy=arrayify(hexDataSlice(keccak256(concat([entropy,options.extraEntropy])),0,16))}const mnemonic=entropyToMnemonic(entropy,options.locale);return Wallet.fromMnemonic(mnemonic,options.path,options.locale)}static fromEncryptedJson(json,password,progressCallback){return decryptJsonWallet(json,password,progressCallback).then(account=>{return new Wallet(account)})}static fromEncryptedJsonSync(json,password){return new Wallet(decryptJsonWalletSync(json,password))}static fromMnemonic(mnemonic,path,wordlist){if(!path){path=defaultPath}return new Wallet(HDNode.fromMnemonic(mnemonic,null,wordlist).derivePath(path))}}function verifyMessage(message,signature){return recoverAddress(hashMessage(message),signature)}function verifyTypedData(domain,types,value,signature){return recoverAddress(TypedDataEncoder.hash(domain,types,value),signature)}const version$k="networks/5.1.0";"use strict";const logger$q=new Logger(version$k);function isRenetworkable(value){return value&&typeof value.renetwork==="function"}function ethDefaultProvider(network){const func=function(providers,options){if(options==null){options={}}const providerList=[];if(providers.InfuraProvider){try{providerList.push(new providers.InfuraProvider(network,options.infura))}catch(error){}}if(providers.EtherscanProvider){try{providerList.push(new providers.EtherscanProvider(network,options.etherscan))}catch(error){}}if(providers.AlchemyProvider){const skip=["goerli","ropsten","rinkeby"];try{const provider=new providers.AlchemyProvider(network,options.alchemy);if(provider.network&&skip.indexOf(provider.network.name)===-1){providerList.push(provider)}}catch(error){}}if(providers.PocketProvider){const skip=["goerli","ropsten","rinkeby"];try{const provider=new providers.PocketProvider(network);if(provider.network&&skip.indexOf(provider.network.name)===-1){providerList.push(provider)}}catch(error){}}if(providers.CloudflareProvider){try{providerList.push(new providers.CloudflareProvider(network))}catch(error){}}if(providerList.length===0){return null}if(providers.FallbackProvider){let quorum=1;if(options.quorum!=null){quorum=options.quorum}else if(network==="homestead"){quorum=2}return new providers.FallbackProvider(providerList,quorum)}return providerList[0]};func.renetwork=function(network){return ethDefaultProvider(network)};return func}function etcDefaultProvider(url,network){const func=function(providers,options){if(providers.JsonRpcProvider){return new providers.JsonRpcProvider(url,network)}return null};func.renetwork=function(network){return etcDefaultProvider(url,network)};return func}const homestead={chainId:1,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"homestead",_defaultProvider:ethDefaultProvider("homestead")};const ropsten={chainId:3,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"ropsten",_defaultProvider:ethDefaultProvider("ropsten")};const classicMordor={chainId:63,name:"classicMordor",_defaultProvider:etcDefaultProvider("https://www.ethercluster.com/mordor","classicMordor")};const networks={unspecified:{chainId:0,name:"unspecified"},homestead:homestead,mainnet:homestead,morden:{chainId:2,name:"morden"},ropsten:ropsten,testnet:ropsten,rinkeby:{chainId:4,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"rinkeby",_defaultProvider:ethDefaultProvider("rinkeby")},kovan:{chainId:42,name:"kovan",_defaultProvider:ethDefaultProvider("kovan")},goerli:{chainId:5,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"goerli",_defaultProvider:ethDefaultProvider("goerli")},classic:{chainId:61,name:"classic",_defaultProvider:etcDefaultProvider("https://www.ethercluster.com/etc","classic")},classicMorden:{chainId:62,name:"classicMorden"},classicMordor:classicMordor,classicTestnet:classicMordor,classicKotti:{chainId:6,name:"classicKotti",_defaultProvider:etcDefaultProvider("https://www.ethercluster.com/kotti","classicKotti")}};function getNetwork(network){if(network==null){return null}if(typeof network==="number"){for(const name in networks){const standard=networks[name];if(standard.chainId===network){return{name:standard.name,chainId:standard.chainId,ensAddress:standard.ensAddress||null,_defaultProvider:standard._defaultProvider||null}}}return{chainId:network,name:"unknown"}}if(typeof network==="string"){const standard=networks[network];if(standard==null){return null}return{name:standard.name,chainId:standard.chainId,ensAddress:standard.ensAddress,_defaultProvider:standard._defaultProvider||null}}const standard=networks[network.name];if(!standard){if(typeof network.chainId!=="number"){logger$q.throwArgumentError("invalid network chainId","network",network)}return network}if(network.chainId!==0&&network.chainId!==standard.chainId){logger$q.throwArgumentError("network chainId mismatch","network",network)}let defaultProvider=network._defaultProvider||null;if(defaultProvider==null&&standard._defaultProvider){if(isRenetworkable(standard._defaultProvider)){defaultProvider=standard._defaultProvider.renetwork(network)}else{defaultProvider=standard._defaultProvider}}return{name:network.name,chainId:standard.chainId,ensAddress:network.ensAddress||standard.ensAddress||null,_defaultProvider:defaultProvider}}"use strict";function decode$1(textData){textData=atob(textData);const data=[];for(let i=0;i<textData.length;i++){data.push(textData.charCodeAt(i))}return arrayify(data)}function encode$1(data){data=arrayify(data);let textData="";for(let i=0;i<data.length;i++){textData+=String.fromCharCode(data[i])}return btoa(textData)}"use strict";var index$2=Object.freeze({__proto__:null,decode:decode$1,encode:encode$1});const version$l="web/5.1.0";"use strict";var __awaiter$6=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};function getUrl(href,options){return __awaiter$6(this,void 0,void 0,function*(){if(options==null){options={}}const request={method:options.method||"GET",headers:options.headers||{},body:options.body||undefined,mode:"cors",cache:"no-cache",credentials:"same-origin",redirect:"follow",referrer:"client"};const response=yield fetch(href,request);const body=yield response.arrayBuffer();const headers={};if(response.headers.forEach){response.headers.forEach((value,key)=>{headers[key.toLowerCase()]=value})}else{response.headers.keys().forEach(key=>{headers[key.toLowerCase()]=response.headers.get(key)})}return{headers:headers,statusCode:response.status,statusMessage:response.statusText,body:arrayify(new Uint8Array(body))}})}"use strict";var __awaiter$7=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$r=new Logger(version$l);function staller(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}function bodyify(value,type){if(value==null){return null}if(typeof value==="string"){return value}if(isBytesLike(value)){if(type&&(type.split("/")[0]==="text"||type.split(";")[0].trim()==="application/json")){try{return toUtf8String(value)}catch(error){}}return hexlify(value)}return value}function _fetchData(connection,body,processFunc){const attemptLimit=typeof connection==="object"&&connection.throttleLimit!=null?connection.throttleLimit:12;logger$r.assertArgument(attemptLimit>0&&attemptLimit%1===0,"invalid connection throttle limit","connection.throttleLimit",attemptLimit);const throttleCallback=typeof connection==="object"?connection.throttleCallback:null;const throttleSlotInterval=typeof connection==="object"&&typeof connection.throttleSlotInterval==="number"?connection.throttleSlotInterval:100;logger$r.assertArgument(throttleSlotInterval>0&&throttleSlotInterval%1===0,"invalid connection throttle slot interval","connection.throttleSlotInterval",throttleSlotInterval);const headers={};let url=null;const options={method:"GET"};let allow304=false;let timeout=2*60*1e3;if(typeof connection==="string"){url=connection}else if(typeof connection==="object"){if(connection==null||connection.url==null){logger$r.throwArgumentError("missing URL","connection.url",connection)}url=connection.url;if(typeof connection.timeout==="number"&&connection.timeout>0){timeout=connection.timeout}if(connection.headers){for(const key in connection.headers){headers[key.toLowerCase()]={key:key,value:String(connection.headers[key])};if(["if-none-match","if-modified-since"].indexOf(key.toLowerCase())>=0){allow304=true}}}options.allowGzip=!!connection.allowGzip;if(connection.user!=null&&connection.password!=null){if(url.substring(0,6)!=="https:"&&connection.allowInsecureAuthentication!==true){logger$r.throwError("basic authentication requires a secure https url",Logger.errors.INVALID_ARGUMENT,{argument:"url",url:url,user:connection.user,password:"[REDACTED]"})}const authorization=connection.user+":"+connection.password;headers["authorization"]={key:"Authorization",value:"Basic "+encode$1(toUtf8Bytes(authorization))}}}if(body){options.method="POST";options.body=body;if(headers["content-type"]==null){headers["content-type"]={key:"Content-Type",value:"application/octet-stream"}}if(headers["content-length"]==null){headers["content-length"]={key:"Content-Length",value:String(body.length)}}}const flatHeaders={};Object.keys(headers).forEach(key=>{const header=headers[key];flatHeaders[header.key]=header.value});options.headers=flatHeaders;const runningTimeout=function(){let timer=null;const promise=new Promise(function(resolve,reject){if(timeout){timer=setTimeout(()=>{if(timer==null){return}timer=null;reject(logger$r.makeError("timeout",Logger.errors.TIMEOUT,{requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,timeout:timeout,url:url}))},timeout)}});const cancel=function(){if(timer==null){return}clearTimeout(timer);timer=null};return{promise:promise,cancel:cancel}}();const runningFetch=function(){return __awaiter$7(this,void 0,void 0,function*(){for(let attempt=0;attempt<attemptLimit;attempt++){let response=null;try{response=yield getUrl(url,options);if(response.statusCode===429&&attempt<attemptLimit){let tryAgain=true;if(throttleCallback){tryAgain=yield throttleCallback(attempt,url)}if(tryAgain){let stall=0;const retryAfter=response.headers["retry-after"];if(typeof retryAfter==="string"&&retryAfter.match(/^[1-9][0-9]*$/)){stall=parseInt(retryAfter)*1e3}else{stall=throttleSlotInterval*parseInt(String(Math.random()*Math.pow(2,attempt)))}yield staller(stall);continue}}}catch(error){response=error.response;if(response==null){runningTimeout.cancel();logger$r.throwError("missing response",Logger.errors.SERVER_ERROR,{requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,serverError:error,url:url})}}let body=response.body;if(allow304&&response.statusCode===304){body=null}else if(response.statusCode<200||response.statusCode>=300){runningTimeout.cancel();logger$r.throwError("bad response",Logger.errors.SERVER_ERROR,{status:response.statusCode,headers:response.headers,body:bodyify(body,response.headers?response.headers["content-type"]:null),requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,url:url})}if(processFunc){try{const result=yield processFunc(body,response);runningTimeout.cancel();return result}catch(error){if(error.throttleRetry&&attempt<attemptLimit){let tryAgain=true;if(throttleCallback){tryAgain=yield throttleCallback(attempt,url)}if(tryAgain){const timeout=throttleSlotInterval*parseInt(String(Math.random()*Math.pow(2,attempt)));yield staller(timeout);continue}}runningTimeout.cancel();logger$r.throwError("processing response error",Logger.errors.SERVER_ERROR,{body:bodyify(body,response.headers?response.headers["content-type"]:null),error:error,requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,url:url})}}runningTimeout.cancel();return body}return logger$r.throwError("failed response",Logger.errors.SERVER_ERROR,{requestBody:bodyify(options.body,flatHeaders["content-type"]),requestMethod:options.method,url:url})})}();return Promise.race([runningTimeout.promise,runningFetch])}function fetchJson(connection,json,processFunc){let processJsonFunc=(value,response)=>{let result=null;if(value!=null){try{result=JSON.parse(toUtf8String(value))}catch(error){logger$r.throwError("invalid JSON",Logger.errors.SERVER_ERROR,{body:value,error:error})}}if(processFunc){result=processFunc(result,response)}return result};let body=null;if(json!=null){body=toUtf8Bytes(json);const updated=typeof connection==="string"?{url:connection}:shallowCopy(connection);if(updated.headers){const hasContentType=Object.keys(updated.headers).filter(k=>k.toLowerCase()==="content-type").length!==0;if(!hasContentType){updated.headers=shallowCopy(updated.headers);updated.headers["content-type"]="application/json"}}else{updated.headers={"content-type":"application/json"}}connection=updated}return _fetchData(connection,body,processJsonFunc)}function poll(func,options){if(!options){options={}}options=shallowCopy(options);if(options.floor==null){options.floor=0}if(options.ceiling==null){options.ceiling=1e4}if(options.interval==null){options.interval=250}return new Promise(function(resolve,reject){let timer=null;let done=false;const cancel=()=>{if(done){return false}done=true;if(timer){clearTimeout(timer)}return true};if(options.timeout){timer=setTimeout(()=>{if(cancel()){reject(new Error("timeout"))}},options.timeout)}const retryLimit=options.retryLimit;let attempt=0;function check(){return func().then(function(result){if(result!==undefined){if(cancel()){resolve(result)}}else if(options.oncePoll){options.oncePoll.once("poll",check)}else if(options.onceBlock){options.onceBlock.once("block",check)}else if(!done){attempt++;if(attempt>retryLimit){if(cancel()){reject(new Error("retry limit reached"))}return}let timeout=options.interval*parseInt(String(Math.random()*Math.pow(2,attempt)));if(timeout<options.floor){timeout=options.floor}if(timeout>options.ceiling){timeout=options.ceiling}setTimeout(check,timeout)}return null},function(error){if(cancel()){reject(error)}})}check()})}"use strict";var ALPHABET="qpzry9x8gf2tvdw0s3jn54khce6mua7l";var ALPHABET_MAP={};for(var z=0;z<ALPHABET.length;z++){var x=ALPHABET.charAt(z);if(ALPHABET_MAP[x]!==undefined)throw new TypeError(x+" is ambiguous");ALPHABET_MAP[x]=z}function polymodStep(pre){var b=pre>>25;return(pre&33554431)<<5^-(b>>0&1)&996825010^-(b>>1&1)&642813549^-(b>>2&1)&513874426^-(b>>3&1)&1027748829^-(b>>4&1)&705979059}function prefixChk(prefix){var chk=1;for(var i=0;i<prefix.length;++i){var c=prefix.charCodeAt(i);if(c<33||c>126)return"Invalid prefix ("+prefix+")";chk=polymodStep(chk)^c>>5}chk=polymodStep(chk);for(i=0;i<prefix.length;++i){var v=prefix.charCodeAt(i);chk=polymodStep(chk)^v&31}return chk}function encode$2(prefix,words,LIMIT){LIMIT=LIMIT||90;if(prefix.length+7+words.length>LIMIT)throw new TypeError("Exceeds length limit");prefix=prefix.toLowerCase();var chk=prefixChk(prefix);if(typeof chk==="string")throw new Error(chk);var result=prefix+"1";for(var i=0;i<words.length;++i){var x=words[i];if(x>>5!==0)throw new Error("Non 5-bit word");chk=polymodStep(chk)^x;result+=ALPHABET.charAt(x)}for(i=0;i<6;++i){chk=polymodStep(chk)}chk^=1;for(i=0;i<6;++i){var v=chk>>(5-i)*5&31;result+=ALPHABET.charAt(v)}return result}function __decode(str,LIMIT){LIMIT=LIMIT||90;if(str.length<8)return str+" too short";if(str.length>LIMIT)return"Exceeds length limit";var lowered=str.toLowerCase();var uppered=str.toUpperCase();if(str!==lowered&&str!==uppered)return"Mixed-case string "+str;str=lowered;var split=str.lastIndexOf("1");if(split===-1)return"No separator character for "+str;if(split===0)return"Missing prefix for "+str;var prefix=str.slice(0,split);var wordChars=str.slice(split+1);if(wordChars.length<6)return"Data too short";var chk=prefixChk(prefix);if(typeof chk==="string")return chk;var words=[];for(var i=0;i<wordChars.length;++i){var c=wordChars.charAt(i);var v=ALPHABET_MAP[c];if(v===undefined)return"Unknown character "+c;chk=polymodStep(chk)^v;if(i+6>=wordChars.length)continue;words.push(v)}if(chk!==1)return"Invalid checksum for "+str;return{prefix:prefix,words:words}}function decodeUnsafe(){var res=__decode.apply(null,arguments);if(typeof res==="object")return res}function decode$2(str){var res=__decode.apply(null,arguments);if(typeof res==="object")return res;throw new Error(res)}function convert(data,inBits,outBits,pad){var value=0;var bits=0;var maxV=(1<<outBits)-1;var result=[];for(var i=0;i<data.length;++i){value=value<<inBits|data[i];bits+=inBits;while(bits>=outBits){bits-=outBits;result.push(value>>bits&maxV)}}if(pad){if(bits>0){result.push(value<<outBits-bits&maxV)}}else{if(bits>=inBits)return"Excess padding";if(value<<outBits-bits&maxV)return"Non-zero padding"}return result}function toWordsUnsafe(bytes){var res=convert(bytes,8,5,true);if(Array.isArray(res))return res}function toWords(bytes){var res=convert(bytes,8,5,true);if(Array.isArray(res))return res;throw new Error(res)}function fromWordsUnsafe(words){var res=convert(words,5,8,false);if(Array.isArray(res))return res}function fromWords(words){var res=convert(words,5,8,false);if(Array.isArray(res))return res;throw new Error(res)}var bech32={decodeUnsafe:decodeUnsafe,decode:decode$2,encode:encode$2,toWordsUnsafe:toWordsUnsafe,toWords:toWords,fromWordsUnsafe:fromWordsUnsafe,fromWords:fromWords};const version$m="providers/5.1.2";"use strict";const logger$s=new Logger(version$m);class Formatter{constructor(){logger$s.checkNew(new.target,Formatter);this.formats=this.getDefaultFormats()}getDefaultFormats(){const formats={};const address=this.address.bind(this);const bigNumber=this.bigNumber.bind(this);const blockTag=this.blockTag.bind(this);const data=this.data.bind(this);const hash=this.hash.bind(this);const hex=this.hex.bind(this);const number=this.number.bind(this);const strictData=v=>{return this.data(v,true)};formats.transaction={hash:hash,type:Formatter.allowNull(number,null),accessList:Formatter.allowNull(this.accessList.bind(this),null),blockHash:Formatter.allowNull(hash,null),blockNumber:Formatter.allowNull(number,null),transactionIndex:Formatter.allowNull(number,null),confirmations:Formatter.allowNull(number,null),from:address,gasPrice:bigNumber,gasLimit:bigNumber,to:Formatter.allowNull(address,null),value:bigNumber,nonce:number,data:data,r:Formatter.allowNull(this.uint256),s:Formatter.allowNull(this.uint256),v:Formatter.allowNull(number),creates:Formatter.allowNull(address,null),raw:Formatter.allowNull(data)};formats.transactionRequest={from:Formatter.allowNull(address),nonce:Formatter.allowNull(number),gasLimit:Formatter.allowNull(bigNumber),gasPrice:Formatter.allowNull(bigNumber),to:Formatter.allowNull(address),value:Formatter.allowNull(bigNumber),data:Formatter.allowNull(strictData),type:Formatter.allowNull(number),accessList:Formatter.allowNull(this.accessList.bind(this),null)};formats.receiptLog={transactionIndex:number,blockNumber:number,transactionHash:hash,address:address,topics:Formatter.arrayOf(hash),data:data,logIndex:number,blockHash:hash};formats.receipt={to:Formatter.allowNull(this.address,null),from:Formatter.allowNull(this.address,null),contractAddress:Formatter.allowNull(address,null),transactionIndex:number,root:Formatter.allowNull(hex),gasUsed:bigNumber,logsBloom:Formatter.allowNull(data),blockHash:hash,transactionHash:hash,logs:Formatter.arrayOf(this.receiptLog.bind(this)),blockNumber:number,confirmations:Formatter.allowNull(number,null),cumulativeGasUsed:bigNumber,status:Formatter.allowNull(number)};formats.block={hash:hash,parentHash:hash,number:number,timestamp:number,nonce:Formatter.allowNull(hex),difficulty:this.difficulty.bind(this),gasLimit:bigNumber,gasUsed:bigNumber,miner:address,extraData:data,transactions:Formatter.allowNull(Formatter.arrayOf(hash))};formats.blockWithTransactions=shallowCopy(formats.block);formats.blockWithTransactions.transactions=Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));formats.filter={fromBlock:Formatter.allowNull(blockTag,undefined),toBlock:Formatter.allowNull(blockTag,undefined),blockHash:Formatter.allowNull(hash,undefined),address:Formatter.allowNull(address,undefined),topics:Formatter.allowNull(this.topics.bind(this),undefined)};formats.filterLog={blockNumber:Formatter.allowNull(number),blockHash:Formatter.allowNull(hash),transactionIndex:number,removed:Formatter.allowNull(this.boolean.bind(this)),address:address,data:Formatter.allowFalsish(data,"0x"),topics:Formatter.arrayOf(hash),transactionHash:hash,logIndex:number};return formats}accessList(accessList){return accessListify(accessList||[])}number(number){if(number==="0x"){return 0}return BigNumber.from(number).toNumber()}bigNumber(value){return BigNumber.from(value)}boolean(value){if(typeof value==="boolean"){return value}if(typeof value==="string"){value=value.toLowerCase();if(value==="true"){return true}if(value==="false"){return false}}throw new Error("invalid boolean - "+value)}hex(value,strict){if(typeof value==="string"){if(!strict&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexString(value)){return value.toLowerCase()}}return logger$s.throwArgumentError("invalid hash","value",value)}data(value,strict){const result=this.hex(value,strict);if(result.length%2!==0){throw new Error("invalid data; odd-length - "+value)}return result}address(value){return getAddress(value)}callAddress(value){if(!isHexString(value,32)){return null}const address=getAddress(hexDataSlice(value,12));return address===AddressZero?null:address}contractAddress(value){return getContractAddress(value)}blockTag(blockTag){if(blockTag==null){return"latest"}if(blockTag==="earliest"){return"0x0"}if(blockTag==="latest"||blockTag==="pending"){return blockTag}if(typeof blockTag==="number"||isHexString(blockTag)){return hexValue(blockTag)}throw new Error("invalid blockTag")}hash(value,strict){const result=this.hex(value,strict);if(hexDataLength(result)!==32){return logger$s.throwArgumentError("invalid hash","value",value)}return result}difficulty(value){if(value==null){return null}const v=BigNumber.from(value);try{return v.toNumber()}catch(error){}return null}uint256(value){if(!isHexString(value)){throw new Error("invalid uint256")}return hexZeroPad(value,32)}_block(value,format){if(value.author!=null&&value.miner==null){value.miner=value.author}return Formatter.check(format,value)}block(value){return this._block(value,this.formats.block)}blockWithTransactions(value){return this._block(value,this.formats.blockWithTransactions)}transactionRequest(value){return Formatter.check(this.formats.transactionRequest,value)}transactionResponse(transaction){if(transaction.gas!=null&&transaction.gasLimit==null){transaction.gasLimit=transaction.gas}if(transaction.to&&BigNumber.from(transaction.to).isZero()){transaction.to="0x0000000000000000000000000000000000000000"}if(transaction.input!=null&&transaction.data==null){transaction.data=transaction.input}if(transaction.to==null&&transaction.creates==null){transaction.creates=this.contractAddress(transaction)}if(transaction.type===1&&transaction.accessList==null){transaction.accessList=[]}const result=Formatter.check(this.formats.transaction,transaction);if(transaction.chainId!=null){let chainId=transaction.chainId;if(isHexString(chainId)){chainId=BigNumber.from(chainId).toNumber()}result.chainId=chainId}else{let chainId=transaction.networkId;if(chainId==null&&result.v==null){chainId=transaction.chainId}if(isHexString(chainId)){chainId=BigNumber.from(chainId).toNumber()}if(typeof chainId!=="number"&&result.v!=null){chainId=(result.v-35)/2;if(chainId<0){chainId=0}chainId=parseInt(chainId)}if(typeof chainId!=="number"){chainId=0}result.chainId=chainId}if(result.blockHash&&result.blockHash.replace(/0/g,"")==="x"){result.blockHash=null}return result}transaction(value){return parse(value)}receiptLog(value){return Formatter.check(this.formats.receiptLog,value)}receipt(value){const result=Formatter.check(this.formats.receipt,value);if(result.root!=null){if(result.root.length<=4){const value=BigNumber.from(result.root).toNumber();if(value===0||value===1){if(result.status!=null&&result.status!==value){logger$s.throwArgumentError("alt-root-status/status mismatch","value",{root:result.root,status:result.status})}result.status=value;delete result.root}else{logger$s.throwArgumentError("invalid alt-root-status","value.root",result.root)}}else if(result.root.length!==66){logger$s.throwArgumentError("invalid root hash","value.root",result.root)}}if(result.status!=null){result.byzantium=true}return result}topics(value){if(Array.isArray(value)){return value.map(v=>this.topics(v))}else if(value!=null){return this.hash(value,true)}return null}filter(value){return Formatter.check(this.formats.filter,value)}filterLog(value){return Formatter.check(this.formats.filterLog,value)}static check(format,object){const result={};for(const key in format){try{const value=format[key](object[key]);if(value!==undefined){result[key]=value}}catch(error){error.checkKey=key;error.checkValue=object[key];throw error}}return result}static allowNull(format,nullValue){return function(value){if(value==null){return nullValue}return format(value)}}static allowFalsish(format,replaceValue){return function(value){if(!value){return replaceValue}return format(value)}}static arrayOf(format){return function(array){if(!Array.isArray(array)){throw new Error("not an array")}const result=[];array.forEach(function(value){result.push(format(value))});return result}}}function isCommunityResourcable(value){return value&&typeof value.isCommunityResource==="function"}function isCommunityResource(value){return isCommunityResourcable(value)&&value.isCommunityResource()}let throttleMessage=false;function showThrottleMessage(){if(throttleMessage){return}throttleMessage=true;console.log("========= NOTICE =========");console.log("Request-Rate Exceeded  (this message will not be repeated)");console.log("");console.log("The default API keys for each service are provided as a highly-throttled,");console.log("community resource for low-traffic projects and early prototyping.");console.log("");console.log("While your application will continue to function, we highly recommended");console.log("signing up for your own API keys to improve performance, increase your");console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");console.log("");console.log("For more details: https://docs.ethers.io/api-keys/");console.log("==========================")}"use strict";var __awaiter$8=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$t=new Logger(version$m);function checkTopic(topic){if(topic==null){return"null"}if(hexDataLength(topic)!==32){logger$t.throwArgumentError("invalid topic","topic",topic)}return topic.toLowerCase()}function serializeTopics(topics){topics=topics.slice();while(topics.length>0&&topics[topics.length-1]==null){topics.pop()}return topics.map(topic=>{if(Array.isArray(topic)){const unique={};topic.forEach(topic=>{unique[checkTopic(topic)]=true});const sorted=Object.keys(unique);sorted.sort();return sorted.join("|")}else{return checkTopic(topic)}}).join("&")}function deserializeTopics(data){if(data===""){return[]}return data.split(/&/g).map(topic=>{if(topic===""){return[]}const comps=topic.split("|").map(topic=>{return topic==="null"?null:topic});return comps.length===1?comps[0]:comps})}function getEventTag$1(eventName){if(typeof eventName==="string"){eventName=eventName.toLowerCase();if(hexDataLength(eventName)===32){return"tx:"+eventName}if(eventName.indexOf(":")===-1){return eventName}}else if(Array.isArray(eventName)){return"filter:*:"+serializeTopics(eventName)}else if(ForkEvent.isForkEvent(eventName)){logger$t.warn("not implemented");throw new Error("not implemented")}else if(eventName&&typeof eventName==="object"){return"filter:"+(eventName.address||"*")+":"+serializeTopics(eventName.topics||[])}throw new Error("invalid event - "+eventName)}function getTime(){return(new Date).getTime()}function stall(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}const PollableEvents=["block","network","pending","poll"];class Event{constructor(tag,listener,once){defineReadOnly(this,"tag",tag);defineReadOnly(this,"listener",listener);defineReadOnly(this,"once",once)}get event(){switch(this.type){case"tx":return this.hash;case"filter":return this.filter}return this.tag}get type(){return this.tag.split(":")[0]}get hash(){const comps=this.tag.split(":");if(comps[0]!=="tx"){return null}return comps[1]}get filter(){const comps=this.tag.split(":");if(comps[0]!=="filter"){return null}const address=comps[1];const topics=deserializeTopics(comps[2]);const filter={};if(topics.length>0){filter.topics=topics}if(address&&address!=="*"){filter.address=address}return filter}pollable(){return this.tag.indexOf(":")>=0||PollableEvents.indexOf(this.tag)>=0}}const coinInfos={0:{symbol:"btc",p2pkh:0,p2sh:5,prefix:"bc"},2:{symbol:"ltc",p2pkh:48,p2sh:50,prefix:"ltc"},3:{symbol:"doge",p2pkh:30,p2sh:22},60:{symbol:"eth",ilk:"eth"},61:{symbol:"etc",ilk:"eth"},700:{symbol:"xdai",ilk:"eth"}};function bytes32ify(value){return hexZeroPad(BigNumber.from(value).toHexString(),32)}function base58Encode(data){return Base58.encode(concat([data,hexDataSlice(sha256$1(sha256$1(data)),0,4)]))}class Resolver{constructor(provider,address,name){defineReadOnly(this,"provider",provider);defineReadOnly(this,"name",name);defineReadOnly(this,"address",provider.formatter.address(address))}_fetchBytes(selector,parameters){return __awaiter$8(this,void 0,void 0,function*(){const transaction={to:this.address,data:hexConcat([selector,namehash(this.name),parameters||"0x"])};const result=yield this.provider.call(transaction);if(result==="0x"){return null}const offset=BigNumber.from(hexDataSlice(result,0,32)).toNumber();const length=BigNumber.from(hexDataSlice(result,offset,offset+32)).toNumber();return hexDataSlice(result,offset+32,offset+32+length)})}_getAddress(coinType,hexBytes){const coinInfo=coinInfos[String(coinType)];if(coinInfo==null){logger$t.throwError(`unsupported coin type: ${coinType}`,Logger.errors.UNSUPPORTED_OPERATION,{operation:`getAddress(${coinType})`})}if(coinInfo.ilk==="eth"){return this.provider.formatter.address(hexBytes)}const bytes=arrayify(hexBytes);if(coinInfo.p2pkh!=null){const p2pkh=hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);if(p2pkh){const length=parseInt(p2pkh[1],16);if(p2pkh[2].length===length*2&&length>=1&&length<=75){return base58Encode(concat([[coinInfo.p2pkh],"0x"+p2pkh[2]]))}}}if(coinInfo.p2sh!=null){const p2sh=hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);if(p2sh){const length=parseInt(p2sh[1],16);if(p2sh[2].length===length*2&&length>=1&&length<=75){return base58Encode(concat([[coinInfo.p2sh],"0x"+p2sh[2]]))}}}if(coinInfo.prefix!=null){const length=bytes[1];let version=bytes[0];if(version===0){if(length!==20&&length!==32){version=-1}}else{version=-1}if(version>=0&&bytes.length===2+length&&length>=1&&length<=75){const words=bech32.toWords(bytes.slice(2));words.unshift(version);return bech32.encode(coinInfo.prefix,words)}}return null}getAddress(coinType){return __awaiter$8(this,void 0,void 0,function*(){if(coinType==null){coinType=60}if(coinType===60){const transaction={to:this.address,data:"0x3b3b57de"+namehash(this.name).substring(2)};const hexBytes=yield this.provider.call(transaction);if(hexBytes==="0x"||hexBytes===HashZero){return null}return this.provider.formatter.callAddress(hexBytes)}const hexBytes=yield this._fetchBytes("0xf1cb7e06",bytes32ify(coinType));if(hexBytes==null||hexBytes==="0x"){return null}const address=this._getAddress(coinType,hexBytes);if(address==null){logger$t.throwError(`invalid or unsupported coin data`,Logger.errors.UNSUPPORTED_OPERATION,{operation:`getAddress(${coinType})`,coinType:coinType,data:hexBytes})}return address})}getContentHash(){return __awaiter$8(this,void 0,void 0,function*(){const hexBytes=yield this._fetchBytes("0xbc1c58d1");if(hexBytes==null||hexBytes==="0x"){return null}const ipfs=hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);if(ipfs){const length=parseInt(ipfs[3],16);if(ipfs[4].length===length*2){return"ipfs://"+Base58.encode("0x"+ipfs[1])}}const swarm=hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);if(swarm){if(swarm[1].length===32*2){return"bzz://"+swarm[1]}}return logger$t.throwError(`invalid or unsupported content hash data`,Logger.errors.UNSUPPORTED_OPERATION,{operation:"getContentHash()",data:hexBytes})})}getText(key){return __awaiter$8(this,void 0,void 0,function*(){let keyBytes=toUtf8Bytes(key);keyBytes=concat([bytes32ify(64),bytes32ify(keyBytes.length),keyBytes]);if(keyBytes.length%32!==0){keyBytes=concat([keyBytes,hexZeroPad("0x",32-key.length%32)])}const hexBytes=yield this._fetchBytes("0x59d1d43c",hexlify(keyBytes));if(hexBytes==null||hexBytes==="0x"){return null}return toUtf8String(hexBytes)})}}let defaultFormatter=null;let nextPollId=1;class BaseProvider extends Provider{constructor(network){logger$t.checkNew(new.target,Provider);super();this._events=[];this._emitted={block:-2};this.formatter=new.target.getFormatter();defineReadOnly(this,"anyNetwork",network==="any");if(this.anyNetwork){network=this.detectNetwork()}if(network instanceof Promise){this._networkPromise=network;network.catch(error=>{});this._ready().catch(error=>{})}else{const knownNetwork=getStatic(new.target,"getNetwork")(network);if(knownNetwork){defineReadOnly(this,"_network",knownNetwork);this.emit("network",knownNetwork,null)}else{logger$t.throwArgumentError("invalid network","network",network)}}this._maxInternalBlockNumber=-1024;this._lastBlockNumber=-2;this._pollingInterval=4e3;this._fastQueryDate=0}_ready(){return __awaiter$8(this,void 0,void 0,function*(){if(this._network==null){let network=null;if(this._networkPromise){try{network=yield this._networkPromise}catch(error){}}if(network==null){network=yield this.detectNetwork()}if(!network){logger$t.throwError("no network detected",Logger.errors.UNKNOWN_ERROR,{})}if(this._network==null){if(this.anyNetwork){this._network=network}else{defineReadOnly(this,"_network",network)}this.emit("network",network,null)}}return this._network})}get ready(){return poll(()=>{return this._ready().then(network=>{return network},error=>{if(error.code===Logger.errors.NETWORK_ERROR&&error.event==="noNetwork"){return undefined}throw error})})}static getFormatter(){if(defaultFormatter==null){defaultFormatter=new Formatter}return defaultFormatter}static getNetwork(network){return getNetwork(network==null?"homestead":network)}_getInternalBlockNumber(maxAge){return __awaiter$8(this,void 0,void 0,function*(){yield this._ready();if(maxAge>0){while(this._internalBlockNumber){const internalBlockNumber=this._internalBlockNumber;try{const result=yield internalBlockNumber;if(getTime()-result.respTime<=maxAge){return result.blockNumber}break}catch(error){if(this._internalBlockNumber===internalBlockNumber){break}}}}const reqTime=getTime();const checkInternalBlockNumber=resolveProperties({blockNumber:this.perform("getBlockNumber",{}),networkError:this.getNetwork().then(network=>null,error=>error)}).then(({blockNumber:blockNumber,networkError:networkError})=>{if(networkError){if(this._internalBlockNumber===checkInternalBlockNumber){this._internalBlockNumber=null}throw networkError}const respTime=getTime();blockNumber=BigNumber.from(blockNumber).toNumber();if(blockNumber<this._maxInternalBlockNumber){blockNumber=this._maxInternalBlockNumber}this._maxInternalBlockNumber=blockNumber;this._setFastBlockNumber(blockNumber);return{blockNumber:blockNumber,reqTime:reqTime,respTime:respTime}});this._internalBlockNumber=checkInternalBlockNumber;checkInternalBlockNumber.catch(error=>{if(this._internalBlockNumber===checkInternalBlockNumber){this._internalBlockNumber=null}});return(yield checkInternalBlockNumber).blockNumber})}poll(){return __awaiter$8(this,void 0,void 0,function*(){const pollId=nextPollId++;const runners=[];let blockNumber=null;try{blockNumber=yield this._getInternalBlockNumber(100+this.pollingInterval/2)}catch(error){this.emit("error",error);return}this._setFastBlockNumber(blockNumber);this.emit("poll",pollId,blockNumber);if(blockNumber===this._lastBlockNumber){this.emit("didPoll",pollId);return}if(this._emitted.block===-2){this._emitted.block=blockNumber-1}if(Math.abs(this._emitted.block-blockNumber)>1e3){logger$t.warn("network block skew detected; skipping block events");this.emit("error",logger$t.makeError("network block skew detected",Logger.errors.NETWORK_ERROR,{blockNumber:blockNumber,event:"blockSkew",previousBlockNumber:this._emitted.block}));this.emit("block",blockNumber)}else{for(let i=this._emitted.block+1;i<=blockNumber;i++){this.emit("block",i)}}if(this._emitted.block!==blockNumber){this._emitted.block=blockNumber;Object.keys(this._emitted).forEach(key=>{if(key==="block"){return}const eventBlockNumber=this._emitted[key];if(eventBlockNumber==="pending"){return}if(blockNumber-eventBlockNumber>12){delete this._emitted[key]}})}if(this._lastBlockNumber===-2){this._lastBlockNumber=blockNumber-1}this._events.forEach(event=>{switch(event.type){case"tx":{const hash=event.hash;let runner=this.getTransactionReceipt(hash).then(receipt=>{if(!receipt||receipt.blockNumber==null){return null}this._emitted["t:"+hash]=receipt.blockNumber;this.emit(hash,receipt);return null}).catch(error=>{this.emit("error",error)});runners.push(runner);break}case"filter":{const filter=event.filter;filter.fromBlock=this._lastBlockNumber+1;filter.toBlock=blockNumber;const runner=this.getLogs(filter).then(logs=>{if(logs.length===0){return}logs.forEach(log=>{this._emitted["b:"+log.blockHash]=log.blockNumber;this._emitted["t:"+log.transactionHash]=log.blockNumber;this.emit(filter,log)})}).catch(error=>{this.emit("error",error)});runners.push(runner);break}}});this._lastBlockNumber=blockNumber;Promise.all(runners).then(()=>{this.emit("didPoll",pollId)}).catch(error=>{this.emit("error",error)});return})}resetEventsBlock(blockNumber){this._lastBlockNumber=blockNumber-1;if(this.polling){this.poll()}}get network(){return this._network}detectNetwork(){return __awaiter$8(this,void 0,void 0,function*(){return logger$t.throwError("provider does not support network detection",Logger.errors.UNSUPPORTED_OPERATION,{operation:"provider.detectNetwork"})})}getNetwork(){return __awaiter$8(this,void 0,void 0,function*(){const network=yield this._ready();const currentNetwork=yield this.detectNetwork();if(network.chainId!==currentNetwork.chainId){if(this.anyNetwork){this._network=currentNetwork;this._lastBlockNumber=-2;this._fastBlockNumber=null;this._fastBlockNumberPromise=null;this._fastQueryDate=0;this._emitted.block=-2;this._maxInternalBlockNumber=-1024;this._internalBlockNumber=null;this.emit("network",currentNetwork,network);yield stall(0);return this._network}const error=logger$t.makeError("underlying network changed",Logger.errors.NETWORK_ERROR,{event:"changed",network:network,detectedNetwork:currentNetwork});this.emit("error",error);throw error}return network})}get blockNumber(){this._getInternalBlockNumber(100+this.pollingInterval/2).then(blockNumber=>{this._setFastBlockNumber(blockNumber)},error=>{});return this._fastBlockNumber!=null?this._fastBlockNumber:-1}get polling(){return this._poller!=null}set polling(value){if(value&&!this._poller){this._poller=setInterval(()=>{this.poll()},this.pollingInterval);if(!this._bootstrapPoll){this._bootstrapPoll=setTimeout(()=>{this.poll();this._bootstrapPoll=setTimeout(()=>{if(!this._poller){this.poll()}this._bootstrapPoll=null},this.pollingInterval)},0)}}else if(!value&&this._poller){clearInterval(this._poller);this._poller=null}}get pollingInterval(){return this._pollingInterval}set pollingInterval(value){if(typeof value!=="number"||value<=0||parseInt(String(value))!=value){throw new Error("invalid polling interval")}this._pollingInterval=value;if(this._poller){clearInterval(this._poller);this._poller=setInterval(()=>{this.poll()},this._pollingInterval)}}_getFastBlockNumber(){const now=getTime();if(now-this._fastQueryDate>2*this._pollingInterval){this._fastQueryDate=now;this._fastBlockNumberPromise=this.getBlockNumber().then(blockNumber=>{if(this._fastBlockNumber==null||blockNumber>this._fastBlockNumber){this._fastBlockNumber=blockNumber}return this._fastBlockNumber})}return this._fastBlockNumberPromise}_setFastBlockNumber(blockNumber){if(this._fastBlockNumber!=null&&blockNumber<this._fastBlockNumber){return}this._fastQueryDate=getTime();if(this._fastBlockNumber==null||blockNumber>this._fastBlockNumber){this._fastBlockNumber=blockNumber;this._fastBlockNumberPromise=Promise.resolve(blockNumber)}}waitForTransaction(transactionHash,confirmations,timeout){return __awaiter$8(this,void 0,void 0,function*(){if(confirmations==null){confirmations=1}const receipt=yield this.getTransactionReceipt(transactionHash);if((receipt?receipt.confirmations:0)>=confirmations){return receipt}return new Promise((resolve,reject)=>{let timer=null;let done=false;const handler=receipt=>{if(receipt.confirmations<confirmations){return}if(timer){clearTimeout(timer)}if(done){return}done=true;this.removeListener(transactionHash,handler);resolve(receipt)};this.on(transactionHash,handler);if(typeof timeout==="number"&&timeout>0){timer=setTimeout(()=>{if(done){return}timer=null;done=true;this.removeListener(transactionHash,handler);reject(logger$t.makeError("timeout exceeded",Logger.errors.TIMEOUT,{timeout:timeout}))},timeout);if(timer.unref){timer.unref()}}})})}getBlockNumber(){return __awaiter$8(this,void 0,void 0,function*(){return this._getInternalBlockNumber(0)})}getGasPrice(){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const result=yield this.perform("getGasPrice",{});try{return BigNumber.from(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getGasPrice",result:result,error:error})}})}getBalance(addressOrName,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("getBalance",params);try{return BigNumber.from(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getBalance",params:params,result:result,error:error})}})}getTransactionCount(addressOrName,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("getTransactionCount",params);try{return BigNumber.from(result).toNumber()}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getTransactionCount",params:params,result:result,error:error})}})}getCode(addressOrName,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("getCode",params);try{return hexlify(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getCode",params:params,result:result,error:error})}})}getStorageAt(addressOrName,position,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag),position:Promise.resolve(position).then(p=>hexValue(p))});const result=yield this.perform("getStorageAt",params);try{return hexlify(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"getStorageAt",params:params,result:result,error:error})}})}_wrapTransaction(tx,hash){if(hash!=null&&hexDataLength(hash)!==32){throw new Error("invalid response - sendTransaction")}const result=tx;if(hash!=null&&tx.hash!==hash){logger$t.throwError("Transaction hash mismatch from Provider.sendTransaction.",Logger.errors.UNKNOWN_ERROR,{expectedHash:tx.hash,returnedHash:hash})}result.wait=(confirmations=>__awaiter$8(this,void 0,void 0,function*(){if(confirmations!==0){this._emitted["t:"+tx.hash]="pending"}const receipt=yield this.waitForTransaction(tx.hash,confirmations);if(receipt==null&&confirmations===0){return null}this._emitted["t:"+tx.hash]=receipt.blockNumber;if(receipt.status===0){logger$t.throwError("transaction failed",Logger.errors.CALL_EXCEPTION,{transactionHash:tx.hash,transaction:tx,receipt:receipt})}return receipt}));return result}sendTransaction(signedTransaction){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const hexTx=yield Promise.resolve(signedTransaction).then(t=>hexlify(t));const tx=this.formatter.transaction(signedTransaction);try{const hash=yield this.perform("sendTransaction",{signedTransaction:hexTx});return this._wrapTransaction(tx,hash)}catch(error){error.transaction=tx;error.transactionHash=tx.hash;throw error}})}_getTransactionRequest(transaction){return __awaiter$8(this,void 0,void 0,function*(){const values=yield transaction;const tx={};["from","to"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v?this._getAddress(v):null)});["gasLimit","gasPrice","value"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v?BigNumber.from(v):null)});["type"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v!=null?v:null)});if(values.accessList){tx.accessList=this.formatter.accessList(values.accessList)}["data"].forEach(key=>{if(values[key]==null){return}tx[key]=Promise.resolve(values[key]).then(v=>v?hexlify(v):null)});return this.formatter.transactionRequest(yield resolveProperties(tx))})}_getFilter(filter){return __awaiter$8(this,void 0,void 0,function*(){filter=yield filter;const result={};if(filter.address!=null){result.address=this._getAddress(filter.address)}["blockHash","topics"].forEach(key=>{if(filter[key]==null){return}result[key]=filter[key]});["fromBlock","toBlock"].forEach(key=>{if(filter[key]==null){return}result[key]=this._getBlockTag(filter[key])});return this.formatter.filter(yield resolveProperties(result))})}call(transaction,blockTag){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({transaction:this._getTransactionRequest(transaction),blockTag:this._getBlockTag(blockTag)});const result=yield this.perform("call",params);try{return hexlify(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"call",params:params,result:result,error:error})}})}estimateGas(transaction){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({transaction:this._getTransactionRequest(transaction)});const result=yield this.perform("estimateGas",params);try{return BigNumber.from(result)}catch(error){return logger$t.throwError("bad result from backend",Logger.errors.SERVER_ERROR,{method:"estimateGas",params:params,result:result,error:error})}})}_getAddress(addressOrName){return __awaiter$8(this,void 0,void 0,function*(){const address=yield this.resolveName(addressOrName);if(address==null){logger$t.throwError("ENS name not configured",Logger.errors.UNSUPPORTED_OPERATION,{operation:`resolveName(${JSON.stringify(addressOrName)})`})}return address})}_getBlock(blockHashOrBlockTag,includeTransactions){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();blockHashOrBlockTag=yield blockHashOrBlockTag;let blockNumber=-128;const params={includeTransactions:!!includeTransactions};if(isHexString(blockHashOrBlockTag,32)){params.blockHash=blockHashOrBlockTag}else{try{params.blockTag=this.formatter.blockTag(yield this._getBlockTag(blockHashOrBlockTag));if(isHexString(params.blockTag)){blockNumber=parseInt(params.blockTag.substring(2),16)}}catch(error){logger$t.throwArgumentError("invalid block hash or block tag","blockHashOrBlockTag",blockHashOrBlockTag)}}return poll(()=>__awaiter$8(this,void 0,void 0,function*(){const block=yield this.perform("getBlock",params);if(block==null){if(params.blockHash!=null){if(this._emitted["b:"+params.blockHash]==null){return null}}if(params.blockTag!=null){if(blockNumber>this._emitted.block){return null}}return undefined}if(includeTransactions){let blockNumber=null;for(let i=0;i<block.transactions.length;i++){const tx=block.transactions[i];if(tx.blockNumber==null){tx.confirmations=0}else if(tx.confirmations==null){if(blockNumber==null){blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval)}let confirmations=blockNumber-tx.blockNumber+1;if(confirmations<=0){confirmations=1}tx.confirmations=confirmations}}return this.formatter.blockWithTransactions(block)}return this.formatter.block(block)}),{oncePoll:this})})}getBlock(blockHashOrBlockTag){return this._getBlock(blockHashOrBlockTag,false)}getBlockWithTransactions(blockHashOrBlockTag){return this._getBlock(blockHashOrBlockTag,true)}getTransaction(transactionHash){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();transactionHash=yield transactionHash;const params={transactionHash:this.formatter.hash(transactionHash,true)};return poll(()=>__awaiter$8(this,void 0,void 0,function*(){const result=yield this.perform("getTransaction",params);if(result==null){if(this._emitted["t:"+transactionHash]==null){return null}return undefined}const tx=this.formatter.transactionResponse(result);if(tx.blockNumber==null){tx.confirmations=0}else if(tx.confirmations==null){const blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval);let confirmations=blockNumber-tx.blockNumber+1;if(confirmations<=0){confirmations=1}tx.confirmations=confirmations}return this._wrapTransaction(tx)}),{oncePoll:this})})}getTransactionReceipt(transactionHash){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();transactionHash=yield transactionHash;const params={transactionHash:this.formatter.hash(transactionHash,true)};return poll(()=>__awaiter$8(this,void 0,void 0,function*(){const result=yield this.perform("getTransactionReceipt",params);if(result==null){if(this._emitted["t:"+transactionHash]==null){return null}return undefined}if(result.blockHash==null){return undefined}const receipt=this.formatter.receipt(result);if(receipt.blockNumber==null){receipt.confirmations=0}else if(receipt.confirmations==null){const blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval);let confirmations=blockNumber-receipt.blockNumber+1;if(confirmations<=0){confirmations=1}receipt.confirmations=confirmations}return receipt}),{oncePoll:this})})}getLogs(filter){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();const params=yield resolveProperties({filter:this._getFilter(filter)});const logs=yield this.perform("getLogs",params);logs.forEach(log=>{if(log.removed==null){log.removed=false}});return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)})}getEtherPrice(){return __awaiter$8(this,void 0,void 0,function*(){yield this.getNetwork();return this.perform("getEtherPrice",{})})}_getBlockTag(blockTag){return __awaiter$8(this,void 0,void 0,function*(){blockTag=yield blockTag;if(typeof blockTag==="number"&&blockTag<0){if(blockTag%1){logger$t.throwArgumentError("invalid BlockTag","blockTag",blockTag)}let blockNumber=yield this._getInternalBlockNumber(100+2*this.pollingInterval);blockNumber+=blockTag;if(blockNumber<0){blockNumber=0}return this.formatter.blockTag(blockNumber)}return this.formatter.blockTag(blockTag)})}getResolver(name){return __awaiter$8(this,void 0,void 0,function*(){const address=yield this._getResolver(name);if(address==null){return null}return new Resolver(this,address,name)})}_getResolver(name){return __awaiter$8(this,void 0,void 0,function*(){const network=yield this.getNetwork();if(!network.ensAddress){logger$t.throwError("network does not support ENS",Logger.errors.UNSUPPORTED_OPERATION,{operation:"ENS",network:network.name})}const transaction={to:network.ensAddress,data:"0x0178b8bf"+namehash(name).substring(2)};return this.formatter.callAddress(yield this.call(transaction))})}resolveName(name){return __awaiter$8(this,void 0,void 0,function*(){name=yield name;try{return Promise.resolve(this.formatter.address(name))}catch(error){if(isHexString(name)){throw error}}if(typeof name!=="string"){logger$t.throwArgumentError("invalid ENS name","name",name)}const resolver=yield this.getResolver(name);if(!resolver){return null}return yield resolver.getAddress()})}lookupAddress(address){return __awaiter$8(this,void 0,void 0,function*(){address=yield address;address=this.formatter.address(address);const reverseName=address.substring(2).toLowerCase()+".addr.reverse";const resolverAddress=yield this._getResolver(reverseName);if(!resolverAddress){return null}let bytes=arrayify(yield this.call({to:resolverAddress,data:"0x691f3431"+namehash(reverseName).substring(2)}));if(bytes.length<32||!BigNumber.from(bytes.slice(0,32)).eq(32)){return null}bytes=bytes.slice(32);if(bytes.length<32){return null}const length=BigNumber.from(bytes.slice(0,32)).toNumber();bytes=bytes.slice(32);if(length>bytes.length){return null}const name=toUtf8String(bytes.slice(0,length));const addr=yield this.resolveName(name);if(addr!=address){return null}return name})}perform(method,params){return logger$t.throwError(method+" not implemented",Logger.errors.NOT_IMPLEMENTED,{operation:method})}_startEvent(event){this.polling=this._events.filter(e=>e.pollable()).length>0}_stopEvent(event){this.polling=this._events.filter(e=>e.pollable()).length>0}_addEventListener(eventName,listener,once){const event=new Event(getEventTag$1(eventName),listener,once);this._events.push(event);this._startEvent(event);return this}on(eventName,listener){return this._addEventListener(eventName,listener,false)}once(eventName,listener){return this._addEventListener(eventName,listener,true)}emit(eventName,...args){let result=false;let stopped=[];let eventTag=getEventTag$1(eventName);this._events=this._events.filter(event=>{if(event.tag!==eventTag){return true}setTimeout(()=>{event.listener.apply(this,args)},0);result=true;if(event.once){stopped.push(event);return false}return true});stopped.forEach(event=>{this._stopEvent(event)});return result}listenerCount(eventName){if(!eventName){return this._events.length}let eventTag=getEventTag$1(eventName);return this._events.filter(event=>{return event.tag===eventTag}).length}listeners(eventName){if(eventName==null){return this._events.map(event=>event.listener)}let eventTag=getEventTag$1(eventName);return this._events.filter(event=>event.tag===eventTag).map(event=>event.listener)}off(eventName,listener){if(listener==null){return this.removeAllListeners(eventName)}const stopped=[];let found=false;let eventTag=getEventTag$1(eventName);this._events=this._events.filter(event=>{if(event.tag!==eventTag||event.listener!=listener){return true}if(found){return true}found=true;stopped.push(event);return false});stopped.forEach(event=>{this._stopEvent(event)});return this}removeAllListeners(eventName){let stopped=[];if(eventName==null){stopped=this._events;this._events=[]}else{const eventTag=getEventTag$1(eventName);this._events=this._events.filter(event=>{if(event.tag!==eventTag){return true}stopped.push(event);return false})}stopped.forEach(event=>{this._stopEvent(event)});return this}}"use strict";var __awaiter$9=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$u=new Logger(version$m);const errorGas=["call","estimateGas"];function checkError(method,error,params){if(method==="call"&&error.code===Logger.errors.SERVER_ERROR){const e=error.error;if(e&&e.message.match("reverted")&&isHexString(e.data)){return e.data}}let message=error.message;if(error.code===Logger.errors.SERVER_ERROR&&error.error&&typeof error.error.message==="string"){message=error.error.message}else if(typeof error.body==="string"){message=error.body}else if(typeof error.responseText==="string"){message=error.responseText}message=(message||"").toLowerCase();const transaction=params.transaction||params.signedTransaction;if(message.match(/insufficient funds/)){logger$u.throwError("insufficient funds for intrinsic transaction cost",Logger.errors.INSUFFICIENT_FUNDS,{error:error,method:method,transaction:transaction})}if(message.match(/nonce too low/)){logger$u.throwError("nonce has already been used",Logger.errors.NONCE_EXPIRED,{error:error,method:method,transaction:transaction})}if(message.match(/replacement transaction underpriced/)){logger$u.throwError("replacement fee too low",Logger.errors.REPLACEMENT_UNDERPRICED,{error:error,method:method,transaction:transaction})}if(message.match(/only replay-protected/)){logger$u.throwError("legacy pre-eip-155 transactions not supported",Logger.errors.UNSUPPORTED_OPERATION,{error:error,method:method,transaction:transaction})}if(errorGas.indexOf(method)>=0&&message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)){logger$u.throwError("cannot estimate gas; transaction may fail or may require manual gas limit",Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,method:method,transaction:transaction})}throw error}function timer(timeout){return new Promise(function(resolve){setTimeout(resolve,timeout)})}function getResult(payload){if(payload.error){const error=new Error(payload.error.message);error.code=payload.error.code;error.data=payload.error.data;throw error}return payload.result}function getLowerCase(value){if(value){return value.toLowerCase()}return value}const _constructorGuard$4={};class JsonRpcSigner extends Signer{constructor(constructorGuard,provider,addressOrIndex){logger$u.checkNew(new.target,JsonRpcSigner);super();if(constructorGuard!==_constructorGuard$4){throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner")}defineReadOnly(this,"provider",provider);if(addressOrIndex==null){addressOrIndex=0}if(typeof addressOrIndex==="string"){defineReadOnly(this,"_address",this.provider.formatter.address(addressOrIndex));defineReadOnly(this,"_index",null)}else if(typeof addressOrIndex==="number"){defineReadOnly(this,"_index",addressOrIndex);defineReadOnly(this,"_address",null)}else{logger$u.throwArgumentError("invalid address or index","addressOrIndex",addressOrIndex)}}connect(provider){return logger$u.throwError("cannot alter JSON-RPC Signer connection",Logger.errors.UNSUPPORTED_OPERATION,{operation:"connect"})}connectUnchecked(){return new UncheckedJsonRpcSigner(_constructorGuard$4,this.provider,this._address||this._index)}getAddress(){if(this._address){return Promise.resolve(this._address)}return this.provider.send("eth_accounts",[]).then(accounts=>{if(accounts.length<=this._index){logger$u.throwError("unknown account #"+this._index,Logger.errors.UNSUPPORTED_OPERATION,{operation:"getAddress"})}return this.provider.formatter.address(accounts[this._index])})}sendUncheckedTransaction(transaction){transaction=shallowCopy(transaction);const fromAddress=this.getAddress().then(address=>{if(address){address=address.toLowerCase()}return address});if(transaction.gasLimit==null){const estimate=shallowCopy(transaction);estimate.from=fromAddress;transaction.gasLimit=this.provider.estimateGas(estimate)}return resolveProperties({tx:resolveProperties(transaction),sender:fromAddress}).then(({tx:tx,sender:sender})=>{if(tx.from!=null){if(tx.from.toLowerCase()!==sender){logger$u.throwArgumentError("from address mismatch","transaction",transaction)}}else{tx.from=sender}const hexTx=this.provider.constructor.hexlifyTransaction(tx,{from:true});return this.provider.send("eth_sendTransaction",[hexTx]).then(hash=>{return hash},error=>{return checkError("sendTransaction",error,hexTx)})})}signTransaction(transaction){return logger$u.throwError("signing transactions is unsupported",Logger.errors.UNSUPPORTED_OPERATION,{operation:"signTransaction"})}sendTransaction(transaction){return this.sendUncheckedTransaction(transaction).then(hash=>{return poll(()=>{return this.provider.getTransaction(hash).then(tx=>{if(tx===null){return undefined}return this.provider._wrapTransaction(tx,hash)})},{onceBlock:this.provider}).catch(error=>{error.transactionHash=hash;throw error})})}signMessage(message){return __awaiter$9(this,void 0,void 0,function*(){const data=typeof message==="string"?toUtf8Bytes(message):message;const address=yield this.getAddress();return yield this.provider.send("eth_sign",[address.toLowerCase(),hexlify(data)])})}_signTypedData(domain,types,value){return __awaiter$9(this,void 0,void 0,function*(){const populated=yield TypedDataEncoder.resolveNames(domain,types,value,name=>{return this.provider.resolveName(name)});const address=yield this.getAddress();return yield this.provider.send("eth_signTypedData_v4",[address.toLowerCase(),JSON.stringify(TypedDataEncoder.getPayload(populated.domain,types,populated.value))])})}unlock(password){return __awaiter$9(this,void 0,void 0,function*(){const provider=this.provider;const address=yield this.getAddress();return provider.send("personal_unlockAccount",[address.toLowerCase(),password,null])})}}class UncheckedJsonRpcSigner extends JsonRpcSigner{sendTransaction(transaction){return this.sendUncheckedTransaction(transaction).then(hash=>{return{hash:hash,nonce:null,gasLimit:null,gasPrice:null,data:null,value:null,chainId:null,confirmations:0,from:null,wait:confirmations=>{return this.provider.waitForTransaction(hash,confirmations)}}})}}const allowedTransactionKeys$3={chainId:true,data:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true,type:true,accessList:true};class JsonRpcProvider extends BaseProvider{constructor(url,network){logger$u.checkNew(new.target,JsonRpcProvider);let networkOrReady=network;if(networkOrReady==null){networkOrReady=new Promise((resolve,reject)=>{setTimeout(()=>{this.detectNetwork().then(network=>{resolve(network)},error=>{reject(error)})},0)})}super(networkOrReady);if(!url){url=getStatic(this.constructor,"defaultUrl")()}if(typeof url==="string"){defineReadOnly(this,"connection",Object.freeze({url:url}))}else{defineReadOnly(this,"connection",Object.freeze(shallowCopy(url)))}this._nextId=42}get _cache(){if(this._eventLoopCache==null){this._eventLoopCache={}}return this._eventLoopCache}static defaultUrl(){return"http://localhost:8545"}detectNetwork(){if(!this._cache["detectNetwork"]){this._cache["detectNetwork"]=this._uncachedDetectNetwork();setTimeout(()=>{this._cache["detectNetwork"]=null},0)}return this._cache["detectNetwork"]}_uncachedDetectNetwork(){return __awaiter$9(this,void 0,void 0,function*(){yield timer(0);let chainId=null;try{chainId=yield this.send("eth_chainId",[])}catch(error){try{chainId=yield this.send("net_version",[])}catch(error){}}if(chainId!=null){const getNetwork=getStatic(this.constructor,"getNetwork");try{return getNetwork(BigNumber.from(chainId).toNumber())}catch(error){return logger$u.throwError("could not detect network",Logger.errors.NETWORK_ERROR,{chainId:chainId,event:"invalidNetwork",serverError:error})}}return logger$u.throwError("could not detect network",Logger.errors.NETWORK_ERROR,{event:"noNetwork"})})}getSigner(addressOrIndex){return new JsonRpcSigner(_constructorGuard$4,this,addressOrIndex)}getUncheckedSigner(addressOrIndex){return this.getSigner(addressOrIndex).connectUnchecked()}listAccounts(){return this.send("eth_accounts",[]).then(accounts=>{return accounts.map(a=>this.formatter.address(a))})}send(method,params){const request={method:method,params:params,id:this._nextId++,jsonrpc:"2.0"};this.emit("debug",{action:"request",request:deepCopy(request),provider:this});const cache=["eth_chainId","eth_blockNumber"].indexOf(method)>=0;if(cache&&this._cache[method]){return this._cache[method]}const result=fetchJson(this.connection,JSON.stringify(request),getResult).then(result=>{this.emit("debug",{action:"response",request:request,response:result,provider:this});return result},error=>{this.emit("debug",{action:"response",error:error,request:request,provider:this});throw error});if(cache){this._cache[method]=result;setTimeout(()=>{this._cache[method]=null},0)}return result}prepareRequest(method,params){switch(method){case"getBlockNumber":return["eth_blockNumber",[]];case"getGasPrice":return["eth_gasPrice",[]];case"getBalance":return["eth_getBalance",[getLowerCase(params.address),params.blockTag]];case"getTransactionCount":return["eth_getTransactionCount",[getLowerCase(params.address),params.blockTag]];case"getCode":return["eth_getCode",[getLowerCase(params.address),params.blockTag]];case"getStorageAt":return["eth_getStorageAt",[getLowerCase(params.address),params.position,params.blockTag]];case"sendTransaction":return["eth_sendRawTransaction",[params.signedTransaction]];case"getBlock":if(params.blockTag){return["eth_getBlockByNumber",[params.blockTag,!!params.includeTransactions]]}else if(params.blockHash){return["eth_getBlockByHash",[params.blockHash,!!params.includeTransactions]]}return null;case"getTransaction":return["eth_getTransactionByHash",[params.transactionHash]];case"getTransactionReceipt":return["eth_getTransactionReceipt",[params.transactionHash]];case"call":{const hexlifyTransaction=getStatic(this.constructor,"hexlifyTransaction");return["eth_call",[hexlifyTransaction(params.transaction,{from:true}),params.blockTag]]}case"estimateGas":{const hexlifyTransaction=getStatic(this.constructor,"hexlifyTransaction");return["eth_estimateGas",[hexlifyTransaction(params.transaction,{from:true})]]}case"getLogs":if(params.filter&&params.filter.address!=null){params.filter.address=getLowerCase(params.filter.address)}return["eth_getLogs",[params.filter]];default:break}return null}perform(method,params){return __awaiter$9(this,void 0,void 0,function*(){const args=this.prepareRequest(method,params);if(args==null){logger$u.throwError(method+" not implemented",Logger.errors.NOT_IMPLEMENTED,{operation:method})}try{return yield this.send(args[0],args[1])}catch(error){return checkError(method,error,params)}})}_startEvent(event){if(event.tag==="pending"){this._startPending()}super._startEvent(event)}_startPending(){if(this._pendingFilter!=null){return}const self=this;const pendingFilter=this.send("eth_newPendingTransactionFilter",[]);this._pendingFilter=pendingFilter;pendingFilter.then(function(filterId){function poll(){self.send("eth_getFilterChanges",[filterId]).then(function(hashes){if(self._pendingFilter!=pendingFilter){return null}let seq=Promise.resolve();hashes.forEach(function(hash){self._emitted["t:"+hash.toLowerCase()]="pending";seq=seq.then(function(){return self.getTransaction(hash).then(function(tx){self.emit("pending",tx);return null})})});return seq.then(function(){return timer(1e3)})}).then(function(){if(self._pendingFilter!=pendingFilter){self.send("eth_uninstallFilter",[filterId]);return}setTimeout(function(){poll()},0);return null}).catch(error=>{})}poll();return filterId}).catch(error=>{})}_stopEvent(event){if(event.tag==="pending"&&this.listenerCount("pending")===0){this._pendingFilter=null}super._stopEvent(event)}static hexlifyTransaction(transaction,allowExtra){const allowed=shallowCopy(allowedTransactionKeys$3);if(allowExtra){for(const key in allowExtra){if(allowExtra[key]){allowed[key]=true}}}checkProperties(transaction,allowed);const result={};["gasLimit","gasPrice","type","nonce","value"].forEach(function(key){if(transaction[key]==null){return}const value=hexValue(transaction[key]);if(key==="gasLimit"){key="gas"}result[key]=value});["from","to","data"].forEach(function(key){if(transaction[key]==null){return}result[key]=hexlify(transaction[key])});if(transaction.accessList){result["accessList"]=accessListify(transaction.accessList)}return result}}"use strict";let WS=null;try{WS=WebSocket;if(WS==null){throw new Error("inject please")}}catch(error){const logger=new Logger(version$m);WS=function(){logger.throwError("WebSockets not supported in this environment",Logger.errors.UNSUPPORTED_OPERATION,{operation:"new WebSocket()"})}}"use strict";var __awaiter$a=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$v=new Logger(version$m);let NextId=1;class WebSocketProvider extends JsonRpcProvider{constructor(url,network){if(network==="any"){logger$v.throwError("WebSocketProvider does not support 'any' network yet",Logger.errors.UNSUPPORTED_OPERATION,{operation:"network:any"})}super(url,network);this._pollingInterval=-1;this._wsReady=false;defineReadOnly(this,"_websocket",new WS(this.connection.url));defineReadOnly(this,"_requests",{});defineReadOnly(this,"_subs",{});defineReadOnly(this,"_subIds",{});defineReadOnly(this,"_detectNetwork",super.detectNetwork());this._websocket.onopen=(()=>{this._wsReady=true;Object.keys(this._requests).forEach(id=>{this._websocket.send(this._requests[id].payload)})});this._websocket.onmessage=(messageEvent=>{const data=messageEvent.data;const result=JSON.parse(data);if(result.id!=null){const id=String(result.id);const request=this._requests[id];delete this._requests[id];if(result.result!==undefined){request.callback(null,result.result);this.emit("debug",{action:"response",request:JSON.parse(request.payload),response:result.result,provider:this})}else{let error=null;if(result.error){error=new Error(result.error.message||"unknown error");defineReadOnly(error,"code",result.error.code||null);defineReadOnly(error,"response",data)}else{error=new Error("unknown error")}request.callback(error,undefined);this.emit("debug",{action:"response",error:error,request:JSON.parse(request.payload),provider:this})}}else if(result.method==="eth_subscription"){const sub=this._subs[result.params.subscription];if(sub){sub.processFunc(result.params.result)}}else{console.warn("this should not happen")}});const fauxPoll=setInterval(()=>{this.emit("poll")},1e3);if(fauxPoll.unref){fauxPoll.unref()}}detectNetwork(){return this._detectNetwork}get pollingInterval(){return 0}resetEventsBlock(blockNumber){logger$v.throwError("cannot reset events block on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"resetEventBlock"})}set pollingInterval(value){logger$v.throwError("cannot set polling interval on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setPollingInterval"})}poll(){return __awaiter$a(this,void 0,void 0,function*(){return null})}set polling(value){if(!value){return}logger$v.throwError("cannot set polling on WebSocketProvider",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setPolling"})}send(method,params){const rid=NextId++;return new Promise((resolve,reject)=>{function callback(error,result){if(error){return reject(error)}return resolve(result)}const payload=JSON.stringify({method:method,params:params,id:rid,jsonrpc:"2.0"});this.emit("debug",{action:"request",request:JSON.parse(payload),provider:this});this._requests[String(rid)]={callback:callback,payload:payload};if(this._wsReady){this._websocket.send(payload)}})}static defaultUrl(){return"ws://localhost:8546"}_subscribe(tag,param,processFunc){return __awaiter$a(this,void 0,void 0,function*(){let subIdPromise=this._subIds[tag];if(subIdPromise==null){subIdPromise=Promise.all(param).then(param=>{return this.send("eth_subscribe",param)});this._subIds[tag]=subIdPromise}const subId=yield subIdPromise;this._subs[subId]={tag:tag,processFunc:processFunc}})}_startEvent(event){switch(event.type){case"block":this._subscribe("block",["newHeads"],result=>{const blockNumber=BigNumber.from(result.number).toNumber();this._emitted.block=blockNumber;this.emit("block",blockNumber)});break;case"pending":this._subscribe("pending",["newPendingTransactions"],result=>{this.emit("pending",result)});break;case"filter":this._subscribe(event.tag,["logs",this._getFilter(event.filter)],result=>{if(result.removed==null){result.removed=false}this.emit(event.filter,this.formatter.filterLog(result))});break;case"tx":{const emitReceipt=event=>{const hash=event.hash;this.getTransactionReceipt(hash).then(receipt=>{if(!receipt){return}this.emit(hash,receipt)})};emitReceipt(event);this._subscribe("tx",["newHeads"],result=>{this._events.filter(e=>e.type==="tx").forEach(emitReceipt)});break}case"debug":case"poll":case"willPoll":case"didPoll":case"error":break;default:console.log("unhandled:",event);break}}_stopEvent(event){let tag=event.tag;if(event.type==="tx"){if(this._events.filter(e=>e.type==="tx").length){return}tag="tx"}else if(this.listenerCount(event.event)){return}const subId=this._subIds[tag];if(!subId){return}delete this._subIds[tag];subId.then(subId=>{if(!this._subs[subId]){return}delete this._subs[subId];this.send("eth_unsubscribe",[subId])})}destroy(){return __awaiter$a(this,void 0,void 0,function*(){if(this._websocket.readyState===WS.CONNECTING){yield new Promise(resolve=>{this._websocket.onopen=function(){resolve(true)};this._websocket.onerror=function(){resolve(false)}})}this._websocket.close(1e3)})}}"use strict";var __awaiter$b=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$w=new Logger(version$m);class StaticJsonRpcProvider extends JsonRpcProvider{detectNetwork(){const _super=Object.create(null,{detectNetwork:{get:()=>super.detectNetwork}});return __awaiter$b(this,void 0,void 0,function*(){let network=this.network;if(network==null){network=yield _super.detectNetwork.call(this);if(!network){logger$w.throwError("no network detected",Logger.errors.UNKNOWN_ERROR,{})}if(this._network==null){defineReadOnly(this,"_network",network);this.emit("network",network,null)}}return network})}}class UrlJsonRpcProvider extends StaticJsonRpcProvider{constructor(network,apiKey){logger$w.checkAbstract(new.target,UrlJsonRpcProvider);network=getStatic(new.target,"getNetwork")(network);apiKey=getStatic(new.target,"getApiKey")(apiKey);const connection=getStatic(new.target,"getUrl")(network,apiKey);super(connection,network);if(typeof apiKey==="string"){defineReadOnly(this,"apiKey",apiKey)}else if(apiKey!=null){Object.keys(apiKey).forEach(key=>{defineReadOnly(this,key,apiKey[key])})}}_startPending(){logger$w.warn("WARNING: API provider does not support pending filters")}isCommunityResource(){return false}getSigner(address){return logger$w.throwError("API provider does not support signing",Logger.errors.UNSUPPORTED_OPERATION,{operation:"getSigner"})}listAccounts(){return Promise.resolve([])}static getApiKey(apiKey){return apiKey}static getUrl(network,apiKey){return logger$w.throwError("not implemented; sub-classes must override getUrl",Logger.errors.NOT_IMPLEMENTED,{operation:"getUrl"})}}"use strict";const logger$x=new Logger(version$m);const defaultApiKey="_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";class AlchemyWebSocketProvider extends WebSocketProvider{constructor(network,apiKey){const provider=new AlchemyProvider(network,apiKey);const url=provider.connection.url.replace(/^http/i,"ws").replace(".alchemyapi.",".ws.alchemyapi.");super(url,provider.network);defineReadOnly(this,"apiKey",provider.apiKey)}isCommunityResource(){return this.apiKey===defaultApiKey}}class AlchemyProvider extends UrlJsonRpcProvider{static getWebSocketProvider(network,apiKey){return new AlchemyWebSocketProvider(network,apiKey)}static getApiKey(apiKey){if(apiKey==null){return defaultApiKey}if(apiKey&&typeof apiKey!=="string"){logger$x.throwArgumentError("invalid apiKey","apiKey",apiKey)}return apiKey}static getUrl(network,apiKey){let host=null;switch(network.name){case"homestead":host="eth-mainnet.alchemyapi.io/v2/";break;case"ropsten":host="eth-ropsten.alchemyapi.io/v2/";break;case"rinkeby":host="eth-rinkeby.alchemyapi.io/v2/";break;case"goerli":host="eth-goerli.alchemyapi.io/v2/";break;case"kovan":host="eth-kovan.alchemyapi.io/v2/";break;default:logger$x.throwArgumentError("unsupported network","network",arguments[0])}return{allowGzip:true,url:"https:/"+"/"+host+apiKey,throttleCallback:(attempt,url)=>{if(apiKey===defaultApiKey){showThrottleMessage()}return Promise.resolve(true)}}}isCommunityResource(){return this.apiKey===defaultApiKey}}"use strict";var __awaiter$c=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$y=new Logger(version$m);class CloudflareProvider extends UrlJsonRpcProvider{static getApiKey(apiKey){if(apiKey!=null){logger$y.throwArgumentError("apiKey not supported for cloudflare","apiKey",apiKey)}return null}static getUrl(network,apiKey){let host=null;switch(network.name){case"homestead":host="https://cloudflare-eth.com/";break;default:logger$y.throwArgumentError("unsupported network","network",arguments[0])}return host}perform(method,params){const _super=Object.create(null,{perform:{get:()=>super.perform}});return __awaiter$c(this,void 0,void 0,function*(){if(method==="getBlockNumber"){const block=yield _super.perform.call(this,"getBlock",{blockTag:"latest"});return block.number}return _super.perform.call(this,method,params)})}}"use strict";var __awaiter$d=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$z=new Logger(version$m);function getTransactionPostData(transaction){const result={};for(let key in transaction){if(transaction[key]==null){continue}let value=transaction[key];if({type:true,gasLimit:true,gasPrice:true,nonce:true,value:true}[key]){value=hexValue(hexlify(value))}else if(key==="accessList"){const sets=accessListify(value);value="["+sets.map(set=>{return`{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`}).join(",")+"]"}else{value=hexlify(value)}result[key]=value}return result}function getResult$1(result){if(result.status==0&&(result.message==="No records found"||result.message==="No transactions found")){return result.result}if(result.status!=1||result.message!="OK"){const error=new Error("invalid response");error.result=JSON.stringify(result);if((result.result||"").toLowerCase().indexOf("rate limit")>=0){error.throttleRetry=true}throw error}return result.result}function getJsonResult(result){if(result&&result.status==0&&result.message=="NOTOK"&&(result.result||"").toLowerCase().indexOf("rate limit")>=0){const error=new Error("throttled response");error.result=JSON.stringify(result);error.throttleRetry=true;throw error}if(result.jsonrpc!="2.0"){const error=new Error("invalid response");error.result=JSON.stringify(result);throw error}if(result.error){const error=new Error(result.error.message||"unknown error");if(result.error.code){error.code=result.error.code}if(result.error.data){error.data=result.error.data}throw error}return result.result}function checkLogTag(blockTag){if(blockTag==="pending"){throw new Error("pending not supported")}if(blockTag==="latest"){return blockTag}return parseInt(blockTag.substring(2),16)}const defaultApiKey$1="9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";function checkError$1(method,error,transaction){if(method==="call"&&error.code===Logger.errors.SERVER_ERROR){const e=error.error;if(e&&e.message.match("reverted")&&isHexString(e.data)){return e.data}}let message=error.message;if(error.code===Logger.errors.SERVER_ERROR){if(error.error&&typeof error.error.message==="string"){message=error.error.message}else if(typeof error.body==="string"){message=error.body}else if(typeof error.responseText==="string"){message=error.responseText}}message=(message||"").toLowerCase();if(message.match(/insufficient funds/)){logger$z.throwError("insufficient funds for intrinsic transaction cost",Logger.errors.INSUFFICIENT_FUNDS,{error:error,method:method,transaction:transaction})}if(message.match(/same hash was already imported|transaction nonce is too low/)){logger$z.throwError("nonce has already been used",Logger.errors.NONCE_EXPIRED,{error:error,method:method,transaction:transaction})}if(message.match(/another transaction with same nonce/)){logger$z.throwError("replacement fee too low",Logger.errors.REPLACEMENT_UNDERPRICED,{error:error,method:method,transaction:transaction})}if(message.match(/execution failed due to an exception/)){logger$z.throwError("cannot estimate gas; transaction may fail or may require manual gas limit",Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,method:method,transaction:transaction})}throw error}class EtherscanProvider extends BaseProvider{constructor(network,apiKey){logger$z.checkNew(new.target,EtherscanProvider);super(network);let name="invalid";if(this.network){name=this.network.name}let baseUrl=null;switch(name){case"homestead":baseUrl="https://api.etherscan.io";break;case"ropsten":baseUrl="https://api-ropsten.etherscan.io";break;case"rinkeby":baseUrl="https://api-rinkeby.etherscan.io";break;case"kovan":baseUrl="https://api-kovan.etherscan.io";break;case"goerli":baseUrl="https://api-goerli.etherscan.io";break;default:throw new Error("unsupported network")}defineReadOnly(this,"baseUrl",baseUrl);defineReadOnly(this,"apiKey",apiKey||defaultApiKey$1)}detectNetwork(){return __awaiter$d(this,void 0,void 0,function*(){return this.network})}perform(method,params){const _super=Object.create(null,{perform:{get:()=>super.perform}});return __awaiter$d(this,void 0,void 0,function*(){let url=this.baseUrl+"/api";let apiKey="";if(this.apiKey){apiKey+="&apikey="+this.apiKey}const get=(url,payload,procFunc)=>__awaiter$d(this,void 0,void 0,function*(){this.emit("debug",{action:"request",request:url,provider:this});const connection={url:url,throttleSlotInterval:1e3,throttleCallback:(attempt,url)=>{if(this.isCommunityResource()){showThrottleMessage()}return Promise.resolve(true)}};let payloadStr=null;if(payload){connection.headers={"content-type":"application/x-www-form-urlencoded; charset=UTF-8"};payloadStr=Object.keys(payload).map(key=>{return`${key}=${payload[key]}`}).join("&")}const result=yield fetchJson(connection,payloadStr,procFunc||getJsonResult);this.emit("debug",{action:"response",request:url,response:deepCopy(result),provider:this});return result});switch(method){case"getBlockNumber":url+="?module=proxy&action=eth_blockNumber"+apiKey;return get(url,null);case"getGasPrice":url+="?module=proxy&action=eth_gasPrice"+apiKey;return get(url,null);case"getBalance":url+="?module=account&action=balance&address="+params.address;url+="&tag="+params.blockTag+apiKey;return get(url,null,getResult$1);case"getTransactionCount":url+="?module=proxy&action=eth_getTransactionCount&address="+params.address;url+="&tag="+params.blockTag+apiKey;return get(url,null);case"getCode":url+="?module=proxy&action=eth_getCode&address="+params.address;url+="&tag="+params.blockTag+apiKey;return get(url,null);case"getStorageAt":url+="?module=proxy&action=eth_getStorageAt&address="+params.address;url+="&position="+params.position;url+="&tag="+params.blockTag+apiKey;return get(url,null);case"sendTransaction":return get(url,{module:"proxy",action:"eth_sendRawTransaction",hex:params.signedTransaction,apikey:this.apiKey}).catch(error=>{return checkError$1("sendTransaction",error,params.signedTransaction)});case"getBlock":if(params.blockTag){url+="?module=proxy&action=eth_getBlockByNumber&tag="+params.blockTag;if(params.includeTransactions){url+="&boolean=true"}else{url+="&boolean=false"}url+=apiKey;return get(url,null)}throw new Error("getBlock by blockHash not implemented");case"getTransaction":url+="?module=proxy&action=eth_getTransactionByHash&txhash="+params.transactionHash;url+=apiKey;return get(url,null);case"getTransactionReceipt":url+="?module=proxy&action=eth_getTransactionReceipt&txhash="+params.transactionHash;url+=apiKey;return get(url,null);case"call":{if(params.blockTag!=="latest"){throw new Error("EtherscanProvider does not support blockTag for call")}const postData=getTransactionPostData(params.transaction);postData.module="proxy";postData.action="eth_call";postData.apikey=this.apiKey;try{return yield get(url,postData)}catch(error){return checkError$1("call",error,params.transaction)}}case"estimateGas":{const postData=getTransactionPostData(params.transaction);postData.module="proxy";postData.action="eth_estimateGas";postData.apikey=this.apiKey;try{return yield get(url,postData)}catch(error){return checkError$1("estimateGas",error,params.transaction)}}case"getLogs":{url+="?module=logs&action=getLogs";if(params.filter.fromBlock){url+="&fromBlock="+checkLogTag(params.filter.fromBlock)}if(params.filter.toBlock){url+="&toBlock="+checkLogTag(params.filter.toBlock)}if(params.filter.address){url+="&address="+params.filter.address}if(params.filter.topics&&params.filter.topics.length>0){if(params.filter.topics.length>1){logger$z.throwError("unsupported topic count",Logger.errors.UNSUPPORTED_OPERATION,{topics:params.filter.topics})}if(params.filter.topics.length===1){const topic0=params.filter.topics[0];if(typeof topic0!=="string"||topic0.length!==66){logger$z.throwError("unsupported topic format",Logger.errors.UNSUPPORTED_OPERATION,{topic0:topic0})}url+="&topic0="+topic0}}url+=apiKey;const logs=yield get(url,null,getResult$1);let blocks={};for(let i=0;i<logs.length;i++){const log=logs[i];if(log.blockHash!=null){continue}if(blocks[log.blockNumber]==null){const block=yield this.getBlock(log.blockNumber);if(block){blocks[log.blockNumber]=block.hash}}log.blockHash=blocks[log.blockNumber]}return logs}case"getEtherPrice":if(this.network.name!=="homestead"){return 0}url+="?module=stats&action=ethprice";url+=apiKey;return parseFloat((yield get(url,null,getResult$1)).ethusd);default:break}return _super.perform.call(this,method,params)})}getHistory(addressOrName,startBlock,endBlock){let url=this.baseUrl;let apiKey="";if(this.apiKey){apiKey+="&apikey="+this.apiKey}if(startBlock==null){startBlock=0}if(endBlock==null){endBlock=99999999}return this.resolveName(addressOrName).then(address=>{url+="/api?module=account&action=txlist&address="+address;url+="&startblock="+startBlock;url+="&endblock="+endBlock;url+="&sort=asc"+apiKey;this.emit("debug",{action:"request",request:url,provider:this});const connection={url:url,throttleSlotInterval:1e3,throttleCallback:(attempt,url)=>{if(this.apiKey===defaultApiKey$1){showThrottleMessage()}return Promise.resolve(true)}};return fetchJson(connection,null,getResult$1).then(result=>{this.emit("debug",{action:"response",request:url,response:deepCopy(result),provider:this});let output=[];result.forEach(tx=>{["contractAddress","to"].forEach(function(key){if(tx[key]==""){delete tx[key]}});if(tx.creates==null&&tx.contractAddress!=null){tx.creates=tx.contractAddress}let item=this.formatter.transactionResponse(tx);if(tx.timeStamp){item.timestamp=parseInt(tx.timeStamp)}output.push(item)});return output})})}isCommunityResource(){return this.apiKey===defaultApiKey$1}}"use strict";var __awaiter$e=window&&window.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const logger$A=new Logger(version$m);function now(){return(new Date).getTime()}function checkNetworks(networks){let result=null;for(let i=0;i<networks.length;i++){const network=networks[i];if(network==null){return null}if(result){if(!(result.name===network.name&&result.chainId===network.chainId&&(result.ensAddress===network.ensAddress||result.ensAddress==null&&network.ensAddress==null))){logger$A.throwArgumentError("provider mismatch","networks",networks)}}else{result=network}}return result}function median(values,maxDelta){values=values.slice().sort();const middle=Math.floor(values.length/2);if(values.length%2){return values[middle]}const a=values[middle-1],b=values[middle];if(maxDelta!=null&&Math.abs(a-b)>maxDelta){return null}return(a+b)/2}function serialize$1(value){if(value===null){return"null"}else if(typeof value==="number"||typeof value==="boolean"){return JSON.stringify(value)}else if(typeof value==="string"){return value}else if(BigNumber.isBigNumber(value)){return value.toString()}else if(Array.isArray(value)){return JSON.stringify(value.map(i=>serialize$1(i)))}else if(typeof value==="object"){const keys=Object.keys(value);keys.sort();return"{"+keys.map(key=>{let v=value[key];if(typeof v==="function"){v="[function]"}else{v=serialize$1(v)}return JSON.stringify(key)+":"+v}).join(",")+"}"}throw new Error("unknown value type: "+typeof value)}let nextRid=1;function stall$1(duration){let cancel=null;let timer=null;let promise=new Promise(resolve=>{cancel=function(){if(timer){clearTimeout(timer);timer=null}resolve()};timer=setTimeout(cancel,duration)});const wait=func=>{promise=promise.then(func);return promise};function getPromise(){return promise}return{cancel:cancel,getPromise:getPromise,wait:wait}}const ForwardErrors=[Logger.errors.CALL_EXCEPTION,Logger.errors.INSUFFICIENT_FUNDS,Logger.errors.NONCE_EXPIRED,Logger.errors.REPLACEMENT_UNDERPRICED,Logger.errors.UNPREDICTABLE_GAS_LIMIT];const ForwardProperties=["address","args","errorArgs","errorSignature","method","transaction"];function exposeDebugConfig(config,now){const result={weight:config.weight};Object.defineProperty(result,"provider",{get:()=>config.provider});if(config.start){result.start=config.start}if(now){result.duration=now-config.start}if(config.done){if(config.error){result.error=config.error}else{result.result=config.result||null}}return result}function normalizedTally(normalize,quorum){return function(configs){const tally={};configs.forEach(c=>{const value=normalize(c.result);if(!tally[value]){tally[value]={count:0,result:c.result}}tally[value].count++});const keys=Object.keys(tally);for(let i=0;i<keys.length;i++){const check=tally[keys[i]];if(check.count>=quorum){return check.result}}return undefined}}function getProcessFunc(provider,method,params){let normalize=serialize$1;switch(method){case"getBlockNumber":return function(configs){const values=configs.map(c=>c.result);let blockNumber=median(configs.map(c=>c.result),2);if(blockNumber==null){return undefined}blockNumber=Math.ceil(blockNumber);if(values.indexOf(blockNumber+1)>=0){blockNumber++}if(blockNumber>=provider._highestBlockNumber){provider._highestBlockNumber=blockNumber}return provider._highestBlockNumber};case"getGasPrice":return function(configs){const values=configs.map(c=>c.result);values.sort();return values[Math.floor(values.length/2)]};case"getEtherPrice":return function(configs){return median(configs.map(c=>c.result))};case"getBalance":case"getTransactionCount":case"getCode":case"getStorageAt":case"call":case"estimateGas":case"getLogs":break;case"getTransaction":case"getTransactionReceipt":normalize=function(tx){if(tx==null){return null}tx=shallowCopy(tx);tx.confirmations=-1;return serialize$1(tx)};break;case"getBlock":if(params.includeTransactions){normalize=function(block){if(block==null){return null}block=shallowCopy(block);block.transactions=block.transactions.map(tx=>{tx=shallowCopy(tx);tx.confirmations=-1;return tx});return serialize$1(block)}}else{normalize=function(block){if(block==null){return null}return serialize$1(block)}}break;default:throw new Error("unknown method: "+method)}return normalizedTally(normalize,provider.quorum)}function waitForSync(config,blockNumber){return __awaiter$e(this,void 0,void 0,function*(){const provider=config.provider;if(provider.blockNumber!=null&&provider.blockNumber>=blockNumber||blockNumber===-1){return provider}return poll(()=>{return new Promise((resolve,reject)=>{setTimeout(function(){if(provider.blockNumber>=blockNumber){return resolve(provider)}if(config.cancelled){return resolve(null)}return resolve(undefined)},0)})},{oncePoll:provider})})}function getRunner(config,currentBlockNumber,method,params){return __awaiter$e(this,void 0,void 0,function*(){let provider=config.provider;switch(method){case"getBlockNumber":case"getGasPrice":return provider[method]();case"getEtherPrice":if(provider.getEtherPrice){return provider.getEtherPrice()}break;case"getBalance":case"getTransactionCount":case"getCode":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider[method](params.address,params.blockTag||"latest");case"getStorageAt":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider.getStorageAt(params.address,params.position,params.blockTag||"latest");case"getBlock":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider[params.includeTransactions?"getBlockWithTransactions":"getBlock"](params.blockTag||params.blockHash);case"call":case"estimateGas":if(params.blockTag&&isHexString(params.blockTag)){provider=yield waitForSync(config,currentBlockNumber)}return provider[method](params.transaction);case"getTransaction":case"getTransactionReceipt":return provider[method](params.transactionHash);case"getLogs":{let filter=params.filter;if(filter.fromBlock&&isHexString(filter.fromBlock)||filter.toBlock&&isHexString(filter.toBlock)){provider=yield waitForSync(config,currentBlockNumber)}return provider.getLogs(filter)}}return logger$A.throwError("unknown method error",Logger.errors.UNKNOWN_ERROR,{method:method,params:params})})}class FallbackProvider extends BaseProvider{constructor(providers,quorum){logger$A.checkNew(new.target,FallbackProvider);if(providers.length===0){logger$A.throwArgumentError("missing providers","providers",providers)}const providerConfigs=providers.map((configOrProvider,index)=>{if(Provider.isProvider(configOrProvider)){const stallTimeout=isCommunityResource(configOrProvider)?2e3:750;const priority=1;return Object.freeze({provider:configOrProvider,weight:1,stallTimeout:stallTimeout,priority:priority})}const config=shallowCopy(configOrProvider);if(config.priority==null){config.priority=1}if(config.stallTimeout==null){config.stallTimeout=isCommunityResource(configOrProvider)?2e3:750}if(config.weight==null){config.weight=1}const weight=config.weight;if(weight%1||weight>512||weight<1){logger$A.throwArgumentError("invalid weight; must be integer in [1, 512]",`providers[${index}].weight`,weight)}return Object.freeze(config)});const total=providerConfigs.reduce((accum,c)=>accum+c.weight,0);if(quorum==null){quorum=total/2}else if(quorum>total){logger$A.throwArgumentError("quorum will always fail; larger than total weight","quorum",quorum)}let networkOrReady=checkNetworks(providerConfigs.map(c=>c.provider.network));if(networkOrReady==null){networkOrReady=new Promise((resolve,reject)=>{setTimeout(()=>{this.detectNetwork().then(resolve,reject)},0)})}super(networkOrReady);defineReadOnly(this,"providerConfigs",Object.freeze(providerConfigs));defineReadOnly(this,"quorum",quorum);this._highestBlockNumber=-1}detectNetwork(){return __awaiter$e(this,void 0,void 0,function*(){const networks=yield Promise.all(this.providerConfigs.map(c=>c.provider.getNetwork()));return checkNetworks(networks)})}perform(method,params){return __awaiter$e(this,void 0,void 0,function*(){if(method==="sendTransaction"){const results=yield Promise.all(this.providerConfigs.map(c=>{return c.provider.sendTransaction(params.signedTransaction).then(result=>{return result.hash},error=>{return error})}));for(let i=0;i<results.length;i++){const result=results[i];if(typeof result==="string"){return result}}throw results[0]}if(this._highestBlockNumber===-1&&method!=="getBlockNumber"){yield this.getBlockNumber()}const processFunc=getProcessFunc(this,method,params);const configs=shuffled(this.providerConfigs.map(shallowCopy));configs.sort((a,b)=>a.priority-b.priority);const currentBlockNumber=this._highestBlockNumber;let i=0;let first=true;while(true){const t0=now();let inflightWeight=configs.filter(c=>c.runner&&t0-c.start<c.stallTimeout).reduce((accum,c)=>accum+c.weight,0);while(inflightWeight<this.quorum&&i<configs.length){const config=configs[i++];const rid=nextRid++;config.start=now();config.staller=stall$1(config.stallTimeout);config.staller.wait(()=>{config.staller=null});config.runner=getRunner(config,currentBlockNumber,method,params).then(result=>{config.done=true;config.result=result;if(this.listenerCount("debug")){this.emit("debug",{action:"request",rid:rid,backend:exposeDebugConfig(config,now()),request:{method:method,params:deepCopy(params)},provider:this})}},error=>{config.done=true;config.error=error;if(this.listenerCount("debug")){this.emit("debug",{action:"request",rid:rid,backend:exposeDebugConfig(config,now()),request:{method:method,params:deepCopy(params)},provider:this})}});if(this.listenerCount("debug")){this.emit("debug",{action:"request",rid:rid,backend:exposeDebugConfig(config,null),request:{method:method,params:deepCopy(params)},provider:this})}inflightWeight+=config.weight}const waiting=[];configs.forEach(c=>{if(c.done||!c.runner){return}waiting.push(c.runner);if(c.staller){waiting.push(c.staller.getPromise())}});if(waiting.length){yield Promise.race(waiting)}const results=configs.filter(c=>c.done&&c.error==null);if(results.length>=this.quorum){const result=processFunc(results);if(result!==undefined){configs.forEach(c=>{if(c.staller){c.staller.cancel()}c.cancelled=true});return result}if(!first){yield stall$1(100).getPromise()}first=false}const errors=configs.reduce((accum,c)=>{if(!c.done||c.error==null){return accum}const code=c.error.code;if(ForwardErrors.indexOf(code)>=0){if(!accum[code]){accum[code]={error:c.error,weight:0}}accum[code].weight+=c.weight}return accum},{});Object.keys(errors).forEach(errorCode=>{const tally=errors[errorCode];if(tally.weight<this.quorum){return}configs.forEach(c=>{if(c.staller){c.staller.cancel()}c.cancelled=true});const e=tally.error;const props={};ForwardProperties.forEach(name=>{if(e[name]==null){return}props[name]=e[name]});logger$A.throwError(e.reason||e.message,errorCode,props)});if(configs.filter(c=>!c.done).length===0){break}}configs.forEach(c=>{if(c.staller){c.staller.cancel()}c.cancelled=true});return logger$A.throwError("failed to meet quorum",Logger.errors.SERVER_ERROR,{method:method,params:params,results:configs.map(c=>exposeDebugConfig(c)),provider:this})})}}"use strict";const IpcProvider=null;"use strict";const logger$B=new Logger(version$m);const defaultProjectId="84842078b09946638c03157f83405213";class InfuraWebSocketProvider extends WebSocketProvider{constructor(network,apiKey){const provider=new InfuraProvider(network,apiKey);const connection=provider.connection;if(connection.password){logger$B.throwError("INFURA WebSocket project secrets unsupported",Logger.errors.UNSUPPORTED_OPERATION,{operation:"InfuraProvider.getWebSocketProvider()"})}const url=connection.url.replace(/^http/i,"ws").replace("/v3/","/ws/v3/");super(url,network);defineReadOnly(this,"apiKey",provider.projectId);defineReadOnly(this,"projectId",provider.projectId);defineReadOnly(this,"projectSecret",provider.projectSecret)}isCommunityResource(){return this.projectId===defaultProjectId}}class InfuraProvider extends UrlJsonRpcProvider{static getWebSocketProvider(network,apiKey){return new InfuraWebSocketProvider(network,apiKey)}static getApiKey(apiKey){const apiKeyObj={apiKey:defaultProjectId,projectId:defaultProjectId,projectSecret:null};if(apiKey==null){return apiKeyObj}if(typeof apiKey==="string"){apiKeyObj.projectId=apiKey}else if(apiKey.projectSecret!=null){logger$B.assertArgument(typeof apiKey.projectId==="string","projectSecret requires a projectId","projectId",apiKey.projectId);logger$B.assertArgument(typeof apiKey.projectSecret==="string","invalid projectSecret","projectSecret","[REDACTED]");apiKeyObj.projectId=apiKey.projectId;apiKeyObj.projectSecret=apiKey.projectSecret}else if(apiKey.projectId){apiKeyObj.projectId=apiKey.projectId}apiKeyObj.apiKey=apiKeyObj.projectId;return apiKeyObj}static getUrl(network,apiKey){let host=null;switch(network?network.name:"unknown"){case"homestead":host="mainnet.infura.io";break;case"ropsten":host="ropsten.infura.io";break;case"rinkeby":host="rinkeby.infura.io";break;case"kovan":host="kovan.infura.io";break;case"goerli":host="goerli.infura.io";break;default:logger$B.throwError("unsupported network",Logger.errors.INVALID_ARGUMENT,{argument:"network",value:network})}const connection={allowGzip:true,url:"https:/"+"/"+host+"/v3/"+apiKey.projectId,throttleCallback:(attempt,url)=>{if(apiKey.projectId===defaultProjectId){showThrottleMessage()}return Promise.resolve(true)}};if(apiKey.projectSecret!=null){connection.user="";connection.password=apiKey.projectSecret}return connection}isCommunityResource(){return this.projectId===defaultProjectId}}class JsonRpcBatchProvider extends JsonRpcProvider{send(method,params){const request={method:method,params:params,id:this._nextId++,jsonrpc:"2.0"};if(this._pendingBatch==null){this._pendingBatch=[]}const inflightRequest={request:request,resolve:null,reject:null};const promise=new Promise((resolve,reject)=>{inflightRequest.resolve=resolve;inflightRequest.reject=reject});this._pendingBatch.push(inflightRequest);if(!this._pendingBatchAggregator){this._pendingBatchAggregator=setTimeout(()=>{const batch=this._pendingBatch;this._pendingBatch=null;this._pendingBatchAggregator=null;const request=batch.map(inflight=>inflight.request);this.emit("debug",{action:"requestBatch",request:deepCopy(request),provider:this});return fetchJson(this.connection,JSON.stringify(request)).then(result=>{this.emit("debug",{action:"response",request:request,response:result,provider:this});batch.forEach((inflightRequest,index)=>{const payload=result[index];if(payload.error){const error=new Error(payload.error.message);error.code=payload.error.code;error.data=payload.error.data;inflightRequest.reject(error)}else{inflightRequest.resolve(payload.result)}})},error=>{this.emit("debug",{action:"response",error:error,request:request,provider:this});batch.forEach(inflightRequest=>{inflightRequest.reject(error)})})},10)}return promise}}"use strict";const logger$C=new Logger(version$m);const defaultApiKey$2="ETHERS_JS_SHARED";class NodesmithProvider extends UrlJsonRpcProvider{static getApiKey(apiKey){if(apiKey&&typeof apiKey!=="string"){logger$C.throwArgumentError("invalid apiKey","apiKey",apiKey)}return apiKey||defaultApiKey$2}static getUrl(network,apiKey){logger$C.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");let host=null;switch(network.name){case"homestead":host="https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";break;case"ropsten":host="https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";break;case"rinkeby":host="https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";break;case"goerli":host="https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";break;case"kovan":host="https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";break;default:logger$C.throwArgumentError("unsupported network","network",arguments[0])}return host+"?apiKey="+apiKey}}"use strict";const logger$D=new Logger(version$m);const defaultApplicationIds={homestead:"6004bcd10040261633ade990",ropsten:"6004bd4d0040261633ade991",rinkeby:"6004bda20040261633ade994",goerli:"6004bd860040261633ade992"};class PocketProvider extends UrlJsonRpcProvider{constructor(network,apiKey){if(apiKey==null){const n=getStatic(new.target,"getNetwork")(network);if(n){const applicationId=defaultApplicationIds[n.name];if(applicationId){apiKey={applicationId:applicationId,loadBalancer:true}}}if(apiKey==null){logger$D.throwError("unsupported network",Logger.errors.INVALID_ARGUMENT,{argument:"network",value:network})}}super(network,apiKey)}static getApiKey(apiKey){if(apiKey==null){logger$D.throwArgumentError("PocketProvider.getApiKey does not support null apiKey","apiKey",apiKey)}const apiKeyObj={applicationId:null,loadBalancer:false,applicationSecretKey:null};if(typeof apiKey==="string"){apiKeyObj.applicationId=apiKey}else if(apiKey.applicationSecretKey!=null){logger$D.assertArgument(typeof apiKey.applicationId==="string","applicationSecretKey requires an applicationId","applicationId",apiKey.applicationId);logger$D.assertArgument(typeof apiKey.applicationSecretKey==="string","invalid applicationSecretKey","applicationSecretKey","[REDACTED]");apiKeyObj.applicationId=apiKey.applicationId;apiKeyObj.applicationSecretKey=apiKey.applicationSecretKey;apiKeyObj.loadBalancer=!!apiKey.loadBalancer}else if(apiKey.applicationId){logger$D.assertArgument(typeof apiKey.applicationId==="string","apiKey.applicationId must be a string","apiKey.applicationId",apiKey.applicationId);apiKeyObj.applicationId=apiKey.applicationId;apiKeyObj.loadBalancer=!!apiKey.loadBalancer}else{logger$D.throwArgumentError("unsupported PocketProvider apiKey","apiKey",apiKey)}return apiKeyObj}static getUrl(network,apiKey){let host=null;switch(network?network.name:"unknown"){case"homestead":host="eth-mainnet.gateway.pokt.network";break;case"ropsten":host="eth-ropsten.gateway.pokt.network";break;case"rinkeby":host="eth-rinkeby.gateway.pokt.network";break;case"goerli":host="eth-goerli.gateway.pokt.network";break;default:logger$D.throwError("unsupported network",Logger.errors.INVALID_ARGUMENT,{argument:"network",value:network})}let url=null;if(apiKey.loadBalancer){url=`https://${host}/v1/lb/${apiKey.applicationId}`}else{url=`https://${host}/v1/${apiKey.applicationId}`}const connection={url:url};connection.headers={};if(apiKey.applicationSecretKey!=null){connection.user="";connection.password=apiKey.applicationSecretKey}return connection}isCommunityResource(){return this.applicationId===defaultApplicationIds[this.network.name]}}"use strict";const logger$E=new Logger(version$m);let _nextId=1;function buildWeb3LegacyFetcher(provider,sendFunc){return function(method,params){if(method=="eth_sign"&&(provider.isMetaMask||provider.isStatus)){method="personal_sign";params=[params[1],params[0]]}const request={method:method,params:params,id:_nextId++,jsonrpc:"2.0"};return new Promise((resolve,reject)=>{sendFunc(request,function(error,result){if(error){return reject(error)}if(result.error){const error=new Error(result.error.message);error.code=result.error.code;error.data=result.error.data;return reject(error)}resolve(result.result)})})}}function buildEip1193Fetcher(provider){return function(method,params){if(params==null){params=[]}if(method=="eth_sign"&&(provider.isMetaMask||provider.isStatus)){method="personal_sign";params=[params[1],params[0]]}return provider.request({method:method,params:params})}}class Web3Provider extends JsonRpcProvider{constructor(provider,network){logger$E.checkNew(new.target,Web3Provider);if(provider==null){logger$E.throwArgumentError("missing provider","provider",provider)}let path=null;let jsonRpcFetchFunc=null;let subprovider=null;if(typeof provider==="function"){path="unknown:";jsonRpcFetchFunc=provider}else{path=provider.host||provider.path||"";if(!path&&provider.isMetaMask){path="metamask"}subprovider=provider;if(provider.request){if(path===""){path="eip-1193:"}jsonRpcFetchFunc=buildEip1193Fetcher(provider)}else if(provider.sendAsync){jsonRpcFetchFunc=buildWeb3LegacyFetcher(provider,provider.sendAsync.bind(provider))}else if(provider.send){jsonRpcFetchFunc=buildWeb3LegacyFetcher(provider,provider.send.bind(provider))}else{logger$E.throwArgumentError("unsupported provider","provider",provider)}if(!path){path="unknown:"}}super(path,network);defineReadOnly(this,"jsonRpcFetchFunc",jsonRpcFetchFunc);defineReadOnly(this,"provider",subprovider)}send(method,params){return this.jsonRpcFetchFunc(method,params)}}"use strict";const logger$F=new Logger(version$m);function getDefaultProvider(network,options){if(network==null){network="homestead"}if(typeof network==="string"){const match=network.match(/^(ws|http)s?:/i);if(match){switch(match[1]){case"http":return new JsonRpcProvider(network);case"ws":return new WebSocketProvider(network);default:logger$F.throwArgumentError("unsupported URL scheme","network",network)}}}const n=getNetwork(network);if(!n||!n._defaultProvider){logger$F.throwError("unsupported getDefaultProvider network",Logger.errors.NETWORK_ERROR,{operation:"getDefaultProvider",network:network})}return n._defaultProvider({FallbackProvider:FallbackProvider,AlchemyProvider:AlchemyProvider,CloudflareProvider:CloudflareProvider,EtherscanProvider:EtherscanProvider,InfuraProvider:InfuraProvider,JsonRpcProvider:JsonRpcProvider,NodesmithProvider:NodesmithProvider,PocketProvider:PocketProvider,Web3Provider:Web3Provider,IpcProvider:IpcProvider},options)}var index$3=Object.freeze({__proto__:null,Provider:Provider,BaseProvider:BaseProvider,Resolver:Resolver,UrlJsonRpcProvider:UrlJsonRpcProvider,FallbackProvider:FallbackProvider,AlchemyProvider:AlchemyProvider,AlchemyWebSocketProvider:AlchemyWebSocketProvider,CloudflareProvider:CloudflareProvider,EtherscanProvider:EtherscanProvider,InfuraProvider:InfuraProvider,InfuraWebSocketProvider:InfuraWebSocketProvider,JsonRpcProvider:JsonRpcProvider,JsonRpcBatchProvider:JsonRpcBatchProvider,NodesmithProvider:NodesmithProvider,PocketProvider:PocketProvider,StaticJsonRpcProvider:StaticJsonRpcProvider,Web3Provider:Web3Provider,WebSocketProvider:WebSocketProvider,IpcProvider:IpcProvider,JsonRpcSigner:JsonRpcSigner,getDefaultProvider:getDefaultProvider,getNetwork:getNetwork,isCommunityResource:isCommunityResource,isCommunityResourcable:isCommunityResourcable,showThrottleMessage:showThrottleMessage,Formatter:Formatter});"use strict";const regexBytes=new RegExp("^bytes([0-9]+)$");const regexNumber=new RegExp("^(u?int)([0-9]*)$");const regexArray=new RegExp("^(.*)\\[([0-9]*)\\]$");const Zeros$1="0000000000000000000000000000000000000000000000000000000000000000";function _pack(type,value,isArray){switch(type){case"address":if(isArray){return zeroPad(value,32)}return arrayify(value);case"string":return toUtf8Bytes(value);case"bytes":return arrayify(value);case"bool":value=value?"0x01":"0x00";if(isArray){return zeroPad(value,32)}return arrayify(value)}let match=type.match(regexNumber);if(match){let size=parseInt(match[2]||"256");if(match[2]&&String(size)!==match[2]||size%8!==0||size===0||size>256){throw new Error("invalid number type - "+type)}if(isArray){size=256}value=BigNumber.from(value).toTwos(size);return zeroPad(value,size/8)}match=type.match(regexBytes);if(match){const size=parseInt(match[1]);if(String(size)!==match[1]||size===0||size>32){throw new Error("invalid bytes type - "+type)}if(arrayify(value).byteLength!==size){throw new Error("invalid value for "+type)}if(isArray){return arrayify((value+Zeros$1).substring(0,66))}return value}match=type.match(regexArray);if(match&&Array.isArray(value)){const baseType=match[1];const count=parseInt(match[2]||String(value.length));if(count!=value.length){throw new Error("invalid value for "+type)}const result=[];value.forEach(function(value){result.push(_pack(baseType,value,true))});return concat(result)}throw new Error("invalid type - "+type)}function pack$1(types,values){if(types.length!=values.length){throw new Error("type/value count mismatch")}const tight=[];types.forEach(function(type,index){tight.push(_pack(type,values[index]))});return hexlify(concat(tight))}function keccak256$1(types,values){return keccak256(pack$1(types,values))}function sha256$2(types,values){return sha256$1(pack$1(types,values))}const version$n="units/5.1.0";"use strict";const logger$G=new Logger(version$n);const names=["wei","kwei","mwei","gwei","szabo","finney","ether"];function commify(value){const comps=String(value).split(".");if(comps.length>2||!comps[0].match(/^-?[0-9]*$/)||comps[1]&&!comps[1].match(/^[0-9]*$/)||value==="."||value==="-."){logger$G.throwArgumentError("invalid value","value",value)}let whole=comps[0];let negative="";if(whole.substring(0,1)==="-"){negative="-";whole=whole.substring(1)}while(whole.substring(0,1)==="0"){whole=whole.substring(1)}if(whole===""){whole="0"}let suffix="";if(comps.length===2){suffix="."+(comps[1]||"0")}while(suffix.length>2&&suffix[suffix.length-1]==="0"){suffix=suffix.substring(0,suffix.length-1)}const formatted=[];while(whole.length){if(whole.length<=3){formatted.unshift(whole);break}else{const index=whole.length-3;formatted.unshift(whole.substring(index));whole=whole.substring(0,index)}}return negative+formatted.join(",")+suffix}function formatUnits(value,unitName){if(typeof unitName==="string"){const index=names.indexOf(unitName);if(index!==-1){unitName=3*index}}return formatFixed(value,unitName!=null?unitName:18)}function parseUnits(value,unitName){if(typeof value!=="string"){logger$G.throwArgumentError("value must be a string","value",value)}if(typeof unitName==="string"){const index=names.indexOf(unitName);if(index!==-1){unitName=3*index}}return parseFixed(value,unitName!=null?unitName:18)}function formatEther(wei){return formatUnits(wei,18)}function parseEther(ether){return parseUnits(ether,18)}"use strict";var utils$1=Object.freeze({__proto__:null,AbiCoder:AbiCoder,defaultAbiCoder:defaultAbiCoder,Fragment:Fragment,EventFragment:EventFragment,FunctionFragment:FunctionFragment,ParamType:ParamType,FormatTypes:FormatTypes,checkResultErrors:checkResultErrors,Logger:Logger,RLP:index,_fetchData:_fetchData,fetchJson:fetchJson,poll:poll,checkProperties:checkProperties,deepCopy:deepCopy,defineReadOnly:defineReadOnly,getStatic:getStatic,resolveProperties:resolveProperties,shallowCopy:shallowCopy,arrayify:arrayify,concat:concat,stripZeros:stripZeros,zeroPad:zeroPad,isBytes:isBytes,isBytesLike:isBytesLike,defaultPath:defaultPath,HDNode:HDNode,SigningKey:SigningKey,Interface:Interface,LogDescription:LogDescription,TransactionDescription:TransactionDescription,base58:Base58,base64:index$2,hexlify:hexlify,isHexString:isHexString,hexConcat:hexConcat,hexStripZeros:hexStripZeros,hexValue:hexValue,hexZeroPad:hexZeroPad,hexDataLength:hexDataLength,hexDataSlice:hexDataSlice,nameprep:nameprep,_toEscapedUtf8String:_toEscapedUtf8String,toUtf8Bytes:toUtf8Bytes,toUtf8CodePoints:toUtf8CodePoints,toUtf8String:toUtf8String,Utf8ErrorFuncs:Utf8ErrorFuncs,formatBytes32String:formatBytes32String,parseBytes32String:parseBytes32String,hashMessage:hashMessage,namehash:namehash,isValidName:isValidName,id:id,_TypedDataEncoder:TypedDataEncoder,getAddress:getAddress,getIcapAddress:getIcapAddress,getContractAddress:getContractAddress,getCreate2Address:getCreate2Address,isAddress:isAddress,formatEther:formatEther,parseEther:parseEther,formatUnits:formatUnits,parseUnits:parseUnits,commify:commify,computeHmac:computeHmac,keccak256:keccak256,ripemd160:ripemd160$1,sha256:sha256$1,sha512:sha512$1,randomBytes:randomBytes,shuffled:shuffled,solidityPack:pack$1,solidityKeccak256:keccak256$1,soliditySha256:sha256$2,splitSignature:splitSignature,joinSignature:joinSignature,accessListify:accessListify,parseTransaction:parse,serializeTransaction:serialize,getJsonWalletAddress:getJsonWalletAddress,computeAddress:computeAddress,recoverAddress:recoverAddress,computePublicKey:computePublicKey,recoverPublicKey:recoverPublicKey,verifyMessage:verifyMessage,verifyTypedData:verifyTypedData,mnemonicToEntropy:mnemonicToEntropy,entropyToMnemonic:entropyToMnemonic,isValidMnemonic:isValidMnemonic,mnemonicToSeed:mnemonicToSeed,get SupportedAlgorithm(){return SupportedAlgorithm},get UnicodeNormalizationForm(){return UnicodeNormalizationForm},get Utf8ErrorReason(){return Utf8ErrorReason},Indexed:Indexed});const version$o="ethers/5.1.4";"use strict";const logger$H=new Logger(version$o);var ethers=Object.freeze({__proto__:null,Signer:Signer,Wallet:Wallet,VoidSigner:VoidSigner,getDefaultProvider:getDefaultProvider,providers:index$3,BaseContract:BaseContract,Contract:Contract,ContractFactory:ContractFactory,BigNumber:BigNumber,FixedNumber:FixedNumber,constants:index$1,get errors(){return ErrorCode},logger:logger$H,utils:utils$1,wordlists:wordlists,version:version$o,Wordlist:Wordlist});"use strict";try{const anyGlobal=window;if(anyGlobal._ethers==null){anyGlobal._ethers=ethers}}catch(error){}

/***/ }),

/***/ "./login-auth.js":
/*!***********************!*\
  !*** ./login-auth.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "login": () => (/* binding */ login),
/* harmony export */   "handle_auth": () => (/* binding */ handle_auth)
/* harmony export */ });
/* harmony import */ var _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ethers-5.1.esm.min.js */ "./ethers-5.1.esm.min.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./utils.js");



async function login(wallet_address, web3)
{
    const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.genRandomLoginMsg)();

    const provider = new _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_0__.ethers.providers.Web3Provider(web3);
    const signer = provider.getSigner();
    const signature = await signer.signMessage(msg);

    await handle_auth(wallet_address, msg, signature);

    window.location.href = "/index";
}

async function handle_auth(wallet_address, msg, signature)
{
    console.log(wallet_address);
    console.log(signature);

    const data = {address: wallet_address, message: msg, signature: signature}

    await fetch('login', {
            method: 'post',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
}


/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addLeadingZeros)
/* harmony export */ });
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/formatters/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/formatters/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../_lib/getUTCDayOfYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js");
/* harmony import */ var _lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js");
/* harmony import */ var _lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../_lib/getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
/* harmony import */ var _lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../_lib/getUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js");
/* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");
/* harmony import */ var _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lightFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js");







var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

var formatters = {
  // Era
  G: function (date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].y(date, token);
  },
  // Local week-numbering year
  Y: function (date, token, localize, options) {
    var signedWeekYear = (0,_lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function (date, token) {
    var isoWeekYear = (0,_lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date); // Padding

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    var year = date.getUTCFullYear();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(year, token.length);
  },
  // Quarter
  Q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function (date, token, localize, options) {
    var week = (0,_lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(week, token.length);
  },
  // ISO week of year
  I: function (date, token, localize) {
    var isoWeek = (0,_lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeek, token.length);
  },
  // Day of the month
  d: function (date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].d(date, token);
  },
  // Day of year
  D: function (date, token, localize) {
    var dayOfYear = (0,_lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dayOfYear, token.length);
  },
  // Day of week
  E: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].h(date, token);
  },
  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].H(date, token);
  },
  // Hour [0-11]
  K: function (date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Hour [1-24]
  k: function (date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Minute
  m: function (date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].m(date, token);
  },
  // Second
  s: function (date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].s(date, token);
  },
  // Fraction of second
  S: function (date, token) {
    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.floor(absOffset / 60), 2);
  var minutes = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../addLeadingZeros/index.js */ "./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js");

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters = {
  // Year
  y: function (date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function (date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(month + 1, 2);
  },
  // Day of the month
  d: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function (date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours(), token.length);
  },
  // Minute
  m: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function (date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function (date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fractionalSeconds, token.length);
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/format/longFormatters/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}

function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}

function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (longFormatters);

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTimezoneOffsetInMilliseconds)
/* harmony export */ });
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCDayOfYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCISOWeekYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCISOWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
/* harmony import */ var _startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");




var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date).getTime() - (0,_startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCWeekYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/getUTCWeek/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/getUTCWeek/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");




var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeek(dirtyDate, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, options).getTime() - (0,_startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isSameUTCWeek)
/* harmony export */ });
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");

 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function isSameUTCWeek(dirtyDateLeft, dirtyDateRight, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeftStartOfWeek = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft, options);
  var dateRightStartOfWeek = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/protectedTokens/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isProtectedDayOfYearToken": () => (/* binding */ isProtectedDayOfYearToken),
/* harmony export */   "isProtectedWeekYearToken": () => (/* binding */ isProtectedWeekYearToken),
/* harmony export */   "throwProtectedError": () => (/* binding */ throwProtectedError)
/* harmony export */ });
var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/requiredArgs/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ requiredArgs)
/* harmony export */ });
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCISOWeekYear)
/* harmony export */ });
/* harmony import */ var _getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getUTCISOWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js");
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startOfUTCISOWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var year = (0,_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuary);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCISOWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var weekStartsOn = 1;
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCWeekYear)
/* harmony export */ });
/* harmony import */ var _getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getUTCWeekYear/index.js */ "./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../startOfUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.firstWeekContainsDate);
  var year = (0,_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(firstWeek, dirtyOptions);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");


 // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/toInteger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/toInteger/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toInteger)
/* harmony export */ });
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/addMilliseconds/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/addMilliseconds/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addMilliseconds)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var timestamp = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate).getTime();
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
  return new Date(timestamp + amount);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/format/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/format/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
/* harmony import */ var _isValid_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../isValid/index.js */ "./node_modules/date-fns/esm/isValid/index.js");
/* harmony import */ var _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../locale/en-US/index.js */ "./node_modules/date-fns/esm/locale/en-US/index.js");
/* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../subMilliseconds/index.js */ "./node_modules/date-fns/esm/subMilliseconds/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_lib/format/formatters/index.js */ "./node_modules/date-fns/esm/_lib/format/formatters/index.js");
/* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_lib/format/longFormatters/index.js */ "./node_modules/date-fns/esm/_lib/format/longFormatters/index.js");
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../_lib/getTimezoneOffsetInMilliseconds/index.js */ "./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js");
/* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_lib/protectedTokens/index.js */ "./node_modules/date-fns/esm/_lib/protectedTokens/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");









 // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The second argument is now required for the sake of explicitness.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   format(new Date(2016, 0, 1))
 *
 *   // v2.0.0 onward
 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
 *   ```
 *
 * - New format string API for `format` function
 *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
 *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
 *
 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);

  if (!(0,_isValid_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(originalDate);
  var utcDate = (0,_subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_7__["default"][firstCharacter];
      return longFormatter(substring, locale.formatLong, formatterOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }

    var formatter = _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_8__["default"][firstCharacter];

    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedWeekYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(substring, dirtyFormatStr, dirtyDate);
      }

      if (!options.useAdditionalDayOfYearTokens && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.isProtectedDayOfYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_9__.throwProtectedError)(substring, dirtyFormatStr, dirtyDate);
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/isDate/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  return value instanceof Date || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isValid/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/isValid/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isValid)
/* harmony export */ });
/* harmony import */ var _isDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../isDate/index.js */ "./node_modules/date-fns/esm/isDate/index.js");
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Now `isValid` doesn't throw an exception
 *   if the first argument is not an instance of Date.
 *   Instead, argument is converted beforehand using `toDate`.
 *
 *   Examples:
 *
 *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
 *   |---------------------------|---------------|---------------|
 *   | `new Date()`              | `true`        | `true`        |
 *   | `new Date('2016-01-01')`  | `true`        | `true`        |
 *   | `new Date('')`            | `false`       | `false`       |
 *   | `new Date(1488370835081)` | `true`        | `true`        |
 *   | `new Date(NaN)`           | `false`       | `false`       |
 *   | `'2016-01-01'`            | `TypeError`   | `false`       |
 *   | `''`                      | `TypeError`   | `false`       |
 *   | `1488370835081`           | `TypeError`   | `true`        |
 *   | `NaN`                     | `TypeError`   | `false`       |
 *
 *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
 *   that try to coerce arguments to the expected type
 *   (which is also the case with other *date-fns* functions).
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);

  if (!(0,_isDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  return !isNaN(Number(date));
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildFormatLongFn)
/* harmony export */ });
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildLocalizeFn)
/* harmony export */ });
function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildMatchFn)
/* harmony export */ });
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildMatchPatternFn)
/* harmony export */ });
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/formatDistance/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/formatDistance/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatDistanceLocale = {
  lessThanXSeconds: {
    standalone: {
      one: 'weniger als 1 Sekunde',
      other: 'weniger als {{count}} Sekunden'
    },
    withPreposition: {
      one: 'weniger als 1 Sekunde',
      other: 'weniger als {{count}} Sekunden'
    }
  },
  xSeconds: {
    standalone: {
      one: '1 Sekunde',
      other: '{{count}} Sekunden'
    },
    withPreposition: {
      one: '1 Sekunde',
      other: '{{count}} Sekunden'
    }
  },
  halfAMinute: {
    standalone: 'halbe Minute',
    withPreposition: 'halben Minute'
  },
  lessThanXMinutes: {
    standalone: {
      one: 'weniger als 1 Minute',
      other: 'weniger als {{count}} Minuten'
    },
    withPreposition: {
      one: 'weniger als 1 Minute',
      other: 'weniger als {{count}} Minuten'
    }
  },
  xMinutes: {
    standalone: {
      one: '1 Minute',
      other: '{{count}} Minuten'
    },
    withPreposition: {
      one: '1 Minute',
      other: '{{count}} Minuten'
    }
  },
  aboutXHours: {
    standalone: {
      one: 'etwa 1 Stunde',
      other: 'etwa {{count}} Stunden'
    },
    withPreposition: {
      one: 'etwa 1 Stunde',
      other: 'etwa {{count}} Stunden'
    }
  },
  xHours: {
    standalone: {
      one: '1 Stunde',
      other: '{{count}} Stunden'
    },
    withPreposition: {
      one: '1 Stunde',
      other: '{{count}} Stunden'
    }
  },
  xDays: {
    standalone: {
      one: '1 Tag',
      other: '{{count}} Tage'
    },
    withPreposition: {
      one: '1 Tag',
      other: '{{count}} Tagen'
    }
  },
  aboutXWeeks: {
    standalone: {
      one: 'etwa 1 Woche',
      other: 'etwa {{count}} Wochen'
    },
    withPreposition: {
      one: 'etwa 1 Woche',
      other: 'etwa {{count}} Wochen'
    }
  },
  xWeeks: {
    standalone: {
      one: '1 Woche',
      other: '{{count}} Wochen'
    },
    withPreposition: {
      one: '1 Woche',
      other: '{{count}} Wochen'
    }
  },
  aboutXMonths: {
    standalone: {
      one: 'etwa 1 Monat',
      other: 'etwa {{count}} Monate'
    },
    withPreposition: {
      one: 'etwa 1 Monat',
      other: 'etwa {{count}} Monaten'
    }
  },
  xMonths: {
    standalone: {
      one: '1 Monat',
      other: '{{count}} Monate'
    },
    withPreposition: {
      one: '1 Monat',
      other: '{{count}} Monaten'
    }
  },
  aboutXYears: {
    standalone: {
      one: 'etwa 1 Jahr',
      other: 'etwa {{count}} Jahre'
    },
    withPreposition: {
      one: 'etwa 1 Jahr',
      other: 'etwa {{count}} Jahren'
    }
  },
  xYears: {
    standalone: {
      one: '1 Jahr',
      other: '{{count}} Jahre'
    },
    withPreposition: {
      one: '1 Jahr',
      other: '{{count}} Jahren'
    }
  },
  overXYears: {
    standalone: {
      one: 'mehr als 1 Jahr',
      other: 'mehr als {{count}} Jahre'
    },
    withPreposition: {
      one: 'mehr als 1 Jahr',
      other: 'mehr als {{count}} Jahren'
    }
  },
  almostXYears: {
    standalone: {
      one: 'fast 1 Jahr',
      other: 'fast {{count}} Jahre'
    },
    withPreposition: {
      one: 'fast 1 Jahr',
      other: 'fast {{count}} Jahren'
    }
  }
};

var formatDistance = function (token, count, options) {
  var result;
  var tokenValue = options !== null && options !== void 0 && options.addSuffix ? formatDistanceLocale[token].withPreposition : formatDistanceLocale[token].standalone;

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', String(count));
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return 'vor ' + result;
    }
  }

  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatDistance);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/formatLong/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/formatLong/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");

// DIN 5008: https://de.wikipedia.org/wiki/Datumsformat#DIN_5008
var dateFormats = {
  full: 'EEEE, do MMMM y',
  // Montag, 7. Januar 2018
  long: 'do MMMM y',
  // 7. Januar 2018
  medium: 'do MMM y',
  // 7. Jan. 2018
  short: 'dd.MM.y' // 07.01.2018

};
var timeFormats = {
  full: 'HH:mm:ss zzzz',
  long: 'HH:mm:ss z',
  medium: 'HH:mm:ss',
  short: 'HH:mm'
};
var dateTimeFormats = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: '{{date}} {{time}}',
  short: '{{date}} {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/formatRelative/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/formatRelative/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatRelativeLocale = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: 'P'
};

var formatRelative = function (token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatRelative);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/localize/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/localize/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");

var eraValues = {
  narrow: ['v.Chr.', 'n.Chr.'],
  abbreviated: ['v.Chr.', 'n.Chr.'],
  wide: ['vor Christus', 'nach Christus']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal']
}; // Note: in German, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  wide: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
}; // https://st.unicode.org/cldr-apps/v#/de/Gregorian/

var formattingMonthValues = {
  narrow: monthValues.narrow,
  abbreviated: ['Jan.', 'Feb.', 'Mrz', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'],
  wide: monthValues.wide
};
var dayValues = {
  narrow: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  short: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
  abbreviated: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
  wide: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag']
}; // https://www.unicode.org/cldr/charts/32/summary/de.html#1881

var dayPeriodValues = {
  narrow: {
    am: 'vm.',
    pm: 'nm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'Morgen',
    afternoon: 'Nachm.',
    evening: 'Abend',
    night: 'Nacht'
  },
  abbreviated: {
    am: 'vorm.',
    pm: 'nachm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'Morgen',
    afternoon: 'Nachmittag',
    evening: 'Abend',
    night: 'Nacht'
  },
  wide: {
    am: 'vormittags',
    pm: 'nachmittags',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'Morgen',
    afternoon: 'Nachmittag',
    evening: 'Abend',
    night: 'Nacht'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'vm.',
    pm: 'nm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'morgens',
    afternoon: 'nachm.',
    evening: 'abends',
    night: 'nachts'
  },
  abbreviated: {
    am: 'vorm.',
    pm: 'nachm.',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'morgens',
    afternoon: 'nachmittags',
    evening: 'abends',
    night: 'nachts'
  },
  wide: {
    am: 'vormittags',
    pm: 'nachmittags',
    midnight: 'Mitternacht',
    noon: 'Mittag',
    morning: 'morgens',
    afternoon: 'nachmittags',
    evening: 'abends',
    night: 'nachts'
  }
};

var ordinalNumber = function (dirtyNumber) {
  var number = Number(dirtyNumber);
  return number + '.';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    formattingValues: formattingMonthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/_lib/match/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/_lib/match/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");


var matchOrdinalNumberPattern = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
var parseEraPatterns = {
  any: [/^v/i, /^n/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(j[a]n|feb|mr[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
  wide: /^(januar|februar|mrz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^j[a]/i, /^f/i, /^mr/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
var parseDayPatterns = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i // will never be matched. Night is matched by `pm`

  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/de/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/de/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/formatDistance/index.js");
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/formatLong/index.js");
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/formatRelative/index.js");
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/localize/index.js");
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/de/_lib/match/index.js");






/**
 * @type {Locale}
 * @category Locales
 * @summary German locale.
 * @language German
 * @iso-639-2 deu
 * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
 * @author Asia [@asia-t]{@link https://github.com/asia-t}
 * @author Van Vuong Ngo [@vanvuongngo]{@link https://github.com/vanvuongngo}
 * @author RomanErnst [@pex]{@link https://github.com/pex}
 * @author Philipp Keck [@Philipp91]{@link https://github.com/Philipp91}
 */
var locale = {
  code: 'de',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 1
    /* Monday */
    ,
    firstWeekContainsDate: 4
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function (token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatDistance);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function (token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatRelative);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function (dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");


var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/en-US/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/en-US/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js");
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js");
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js");
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js");
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js");






/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatDistance)
/* harmony export */ });
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xSeconds: {
    one: '1 ',
    other: '{{count}} '
  },
  halfAMinute: '',
  lessThanXMinutes: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMinutes: {
    one: '1 ',
    other: '{{count}} '
  },
  xHours: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXHours: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xDays: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXWeeks: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xWeeks: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXMonths: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMonths: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xYears: {
    one: '1 ',
    other: '{{count}} '
  },
  overXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  almostXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return result + '';
    } else {
      return result + '';
    }
  }

  return result;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildFormatLongFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js");

var dateFormats = {
  full: "y''M''d'' EEEE",
  long: "y''M''d''",
  medium: 'yyyy-MM-dd',
  short: 'yy-MM-dd'
};
var timeFormats = {
  full: 'zzzz a h:mm:ss',
  long: 'z a h:mm:ss',
  medium: 'a h:mm:ss',
  short: 'a h:mm'
};
var dateTimeFormats = {
  full: '{{date}} {{time}}',
  long: '{{date}} {{time}}',
  medium: '{{date}} {{time}}',
  short: '{{date}} {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatRelative)
/* harmony export */ });
/* harmony import */ var _lib_isSameUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../_lib/isSameUTCWeek/index.js */ "./node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js");


function checkWeek(_date, _baseDate, _options, baseFormat) {
  if ((0,_lib_isSameUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_date, _baseDate, _options)) {
    return baseFormat; // in same week
  } else if (_date.getTime() > _baseDate.getTime()) {
    return "''" + baseFormat; // in next week
  }

  return "''" + baseFormat; // in last week
}

var formatRelativeLocale = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: 'PP p'
};
function formatRelative(token, _date, _baseDate, _options) {
  var format = formatRelativeLocale[token];

  if (typeof format === 'function') {
    return format(_date, _baseDate, _options, 'eeee p');
  }

  return format;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildLocalizeFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js");

var eraValues = {
  narrow: ['', ''],
  abbreviated: ['', ''],
  wide: ['', '']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['', '', '', ''],
  wide: ['', '', '', '']
};
var monthValues = {
  narrow: ['', '', '', '', '', '', '', '', '', '', '', ''],
  abbreviated: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  wide: ['', '', '', '', '', '', '', '', '', '', '', '']
};
var dayValues = {
  narrow: ['', '', '', '', '', '', ''],
  short: ['', '', '', '', '', '', ''],
  abbreviated: ['', '', '', '', '', '', ''],
  wide: ['', '', '', '', '', '', '']
};
var dayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};

function ordinalNumber(dirtyNumber, dirtyOptions) {
  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`:
  //
  //   var options = dirtyOptions || {}
  //   var unit = String(options.unit)
  //
  // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'
  var number = Number(dirtyNumber);
  var options = dirtyOptions || {};
  var unit = String(options.unit);

  switch (unit) {
    case 'date':
      return number.toString() + '';

    case 'hour':
      return number.toString() + '';

    case 'minute':
      return number.toString() + '';

    case 'second':
      return number.toString() + '';

    default:
      return ' ' + number.toString();
  }
}

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_lib/buildMatchPatternFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js");
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_lib/buildMatchFn/index.js */ "./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js");


var matchOrdinalNumberPattern = /^(\s*)?\d+(|||)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^()/i,
  abbreviated: /^()/i,
  wide: /^(|)/i
};
var parseEraPatterns = {
  any: [/^()/i, /^()/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
var parseQuarterPatterns = {
  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
var matchMonthPatterns = {
  narrow: /^(|||||||||[])/i,
  abbreviated: /^(|||||||||[]|\d|1[12])/i,
  wide: /^(|||||||||[])/i
};
var parseMonthPatterns = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^(?!(|))/i, /^/i, /^/i],
  any: [/^|1/i, /^|2/i, /^|3/i, /^|4/i, /^|5/i, /^|6/i, /^|7/i, /^|8/i, /^|9/i, /^(?!(|))|10/i, /^|11/i, /^|12/i]
};
var matchDayPatterns = {
  narrow: /^[]/i,
  short: /^[]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
var parseDayPatterns = {
  any: [//i, //i, //i, //i, //i, //i, //i]
};
var matchDayPeriodPatterns = {
  any: /^(?|?||[]|?||?||)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^?/i,
    pm: /^?/i,
    midnight: /^/i,
    noon: /^[]/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^?/i,
    night: /^/i
  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);

/***/ }),

/***/ "./node_modules/date-fns/esm/locale/zh-CN/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/esm/locale/zh-CN/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/formatDistance/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js");
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/formatLong/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js");
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/formatRelative/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js");
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/localize/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js");
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_lib/match/index.js */ "./node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js");





/**
 * @type {Locale}
 * @category Locales
 * @summary Chinese Simplified locale.
 * @language Chinese Simplified
 * @iso-639-2 zho
 * @author Changyu Geng [@KingMario]{@link https://github.com/KingMario}
 * @author Song Shuoyun [@fnlctrl]{@link https://github.com/fnlctrl}
 * @author sabrinaM [@sabrinamiao]{@link https://github.com/sabrinamiao}
 * @author Carney Wu [@cubicwork]{@link https://github.com/cubicwork}
 * @author Terrence Lam [@skyuplam]{@link https://github.com/skyuplam}
 */

var locale = {
  code: 'zh-CN',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 1
    /* Monday */
    ,
    firstWeekContainsDate: 4
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),

/***/ "./node_modules/date-fns/esm/subMilliseconds/index.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/esm/subMilliseconds/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ subMilliseconds)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addMilliseconds/index.js */ "./node_modules/date-fns/esm/addMilliseconds/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
  return (0,_addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/toDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/toDate/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ }),

/***/ "./utils.js":
/*!******************!*\
  !*** ./utils.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getRandomInt": () => (/* binding */ getRandomInt),
/* harmony export */   "genRandomLoginMsg": () => (/* binding */ genRandomLoginMsg),
/* harmony export */   "error_msg": () => (/* binding */ error_msg),
/* harmony export */   "sleep": () => (/* binding */ sleep)
/* harmony export */ });
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
};

const genRandomHex = size => [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');

function genRandomLoginMsg() {
    // E.g. "LogIn-fab164a3-2f63-000d-159b-3b86868d8ffe"
    return "LogIn-" + genRandomHex(8) + "-" + genRandomHex(4) + "-" + genRandomHex(4) + "-" + genRandomHex(4) + "-" + genRandomHex(12);
}



function error_msg(msg, category) {
  // Make nice error messages using Bootstrap alerts
  const insert_str = "<div class='alert alert-dismissable fade show alert-" + category + "'> " + msg +
                     "  <button type='button' class='btn-close' data-bs-dismiss='alert' aria-label='Close' style='float: right'>" +
                      "   </button> </div>";
  console.log(insert_str);
  document.getElementById("alert-messages").insertAdjacentHTML('beforeend', insert_str);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!***********************!*\
  !*** ./statistics.js ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/format/index.js");
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! date-fns/locale */ "./node_modules/date-fns/esm/locale/en-US/index.js");
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns/locale */ "./node_modules/date-fns/esm/locale/de/index.js");
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns/locale */ "./node_modules/date-fns/esm/locale/zh-CN/index.js");


const locale_obj = {
    "en": date_fns_locale__WEBPACK_IMPORTED_MODULE_0__["default"],
    "en-US": date_fns_locale__WEBPACK_IMPORTED_MODULE_0__["default"],
    "de": date_fns_locale__WEBPACK_IMPORTED_MODULE_1__["default"],
    "zh": date_fns_locale__WEBPACK_IMPORTED_MODULE_2__["default"],
    "zh-CN": date_fns_locale__WEBPACK_IMPORTED_MODULE_2__["default"]
}

function getLang() {
    if (navigator.languages != undefined) 
      return navigator.languages[0]; 
    return navigator.language;
};

function getLocale() {
    const lang = getLang();
    let locale = locale_obj[lang];

    if (!locale)
        locale = locale_obj["en"];
    
    return locale;
};

const locale = getLocale();
// console.log(locale);

function dateTimeFormatter(timestamp) {
    return (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(new Date(timestamp), "dd/MM/yyyy HH:mm");
    //return format(new Date(timestamp), "Pp", {"locale": locale_obj[locale]});
}

window.dateTimeFormatter = dateTimeFormatter;

document.addEventListener("DOMContentLoaded", function (event) {
    try {
        $("#table-stats-metamons").on("post-header.bs.table", adjustExportButton);
    }
    catch (error) {}
});

function adjustExportButton () {
    const export_elements = document.getElementsByClassName("export");
    if (export_elements.length > 0) {
        const element = export_elements[0];
        const button = element.getElementsByTagName("button")[0];
        button.textContent = "Export";

        // If data is not available, disable button
        if (! ($("#table-stats-metamons")[0].dataset.url))
            button.disabled = true
    }

    adjustTable();
}

function adjustTable () {
    // Makes borders in the middle of the table head to separate "Metamon" and "Results"
    const el = $(".tr-class-1")[0];
    el.getElementsByTagName("th")[1].style.borderLeft = "2px solid #444444";
    const el2 = $(".tr-class-2")[0];
    el2.getElementsByTagName("th")[5].style.borderLeft = "2px solid #444444";
}
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!********************!*\
  !*** ./manager.js ***!
  \********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./utils.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);



function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
};

async function make_request() {
    var kvpairs = {};
    const form = document.getElementById("manager-form");
    for ( var i = 0; i < form.elements.length; i++ ) {
        var e = form.elements[i]; 
        if (e.type == "checkbox")
            kvpairs[e.name] = e.checked ? "on" : "off";
        else
            kvpairs[e.name] = e.value;
    };

    const options = {
        method: 'post',
        credentials: 'same-origin',
        headers: {
          'X-CSRF-TOKEN': getCookie('csrf_access_token'),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(kvpairs)
    };

    await fetch('/manager', options);
};

if (document.getElementById("battle-submit-button")) {
    document.getElementById("battle-submit-button").onclick = async ()=>{
        //await make_request();
        await startBattles();
    };
}

async function fetch_loop(url, method, data, headers) {
    //let h =  {'Content-Type': 'application/json'};
    let h =  {};
	if (headers) {
		Object.assign(h, headers);
	};

	const options = {
        method: method,
        headers: h,
        body: data
    };


	for (let n = 0; n < 5; n++) {
        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(0.5);
		try {
            // await log("Fetch " + url + " " + JSON.stringify(options));
			const response = await fetch(url, options);
            const response_json = await response.json();
            //await log("Response " + JSON.stringify(response_json));
            return response_json;
		} catch (err) {
			await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(2);
		}
	}
	
};

function urlencoded(obj) {
    lodash__WEBPACK_IMPORTED_MODULE_1__.result = lodash__WEBPACK_IMPORTED_MODULE_1___default().join(lodash__WEBPACK_IMPORTED_MODULE_1___default().map(Object.entries(obj), function(o) {return o[0] + "=" + o[1]}), "&");
    return lodash__WEBPACK_IMPORTED_MODULE_1__.result;
}

// URLs to make api calls
const BASE_URL = "https://metamon-api.radiocaca.com/usm-api";
const TOKEN_URL = BASE_URL + "/login";
const LIST_MONSTER_URL = BASE_URL + "/getWalletPropertyBySymbol";
const CHANGE_FIGHTER_URL = BASE_URL + "/isFightMonster";
const START_FIGHT_URL = BASE_URL + "/startBattle";
const LIST_BATTLER_URL = BASE_URL + "/getBattelObjects";
const WALLET_PROPERTY_LIST = BASE_URL + "/getWalletPropertyList";
const LVL_UP_URL = BASE_URL + "/updateMonster";
const MINT_EGG_URL = BASE_URL + "/composeMonsterEgg";
const CHECK_BAG_URL = BASE_URL + "/checkBag";

class MetamonIsland {
	constructor(address, sign, msg) {
		this.address = address;
		this.sign = sign;
		this.msg = msg;
		
        this.not_enough_money = false;
        this.total_bp_num = 0;
        this.total_success = 0;
        this.total_fail = 0;
        this.mtm_stats = [];
        this.token = null;
	}
	
	async initToken() {
		const payload = "address=" + this.address + "&sign=" + this.sign + "&msg=" + this.msg + "&network=1";
        const response = await fetch_loop(TOKEN_URL, "post", payload, {"Content-Type": "application/x-www-form-urlencoded"});

        if (response["code"] == "SUCCESS") {
            this.token = response.data.accessToken;
            return true;
        }
        else {
            return false;
        }    
	}
	
    async changeFighter(monster_id) {
        // Switch to next metamon if you have few
        const payload = {
            "metamonId": monster_id,
            "address": this.address,
        };
        await fetch_loop(CHANGE_FIGHTER_URL, "post", urlencoded(payload), this.headersTokenAndCT());
	}
	
	async listOpponents(monster_id, front=1) {
        // Obtain list of opponents
        const payload = {
            "address": this.address,
            "metamonId": monster_id,
            "front": front,
        };

        const response = await fetch_loop(LIST_BATTLER_URL, "post", urlencoded(payload), this.headersTokenAndCT());
        return response["data"]["objects"];
	}

	headersToken () {
		return {"accessToken": this.token};	
	}

    headersTokenAndCT () {
		return {"Content-Type": "application/x-www-form-urlencoded",
                "accessToken": this.token};	
	}

	/**
	Obtain list of Metamons in the wallet
	 */
	async updateWallet() {
        let data = [];
        let page = 1;
        while (true) {
            const payload = {"address": this.address, "page": page, "pageSize": 60};
            const response = await fetch_loop(WALLET_PROPERTY_LIST, "post", urlencoded(payload), this.headersTokenAndCT());
            if (response["code"] != "SUCCESS")
                break;

			const mtms = response["data"]["metamonList"];
            if (mtms.length > 0) {
                // On 18/01/2022 the API seems to be changed
                let added = false;
                for (let mtm of mtms) {
                    if (this.metamon_idx(mtm.tokenId, data) == -1) {
                        data.push(mtm);
                        added = true;
                    }
                }

                if (!added)
                    break;
                
                page += 1;
			}
            else
                break;
		};

        // Sort metamon list
        data.sort((monster1, monster2) => monster1.tokenId - monster2.tokenId);
		
        this.metamons = data;
        return data;
	}

    /**
     * Return the index of a metamon with token monster_token_id in the list of metamons.
     */
    metamon_idx(monster_token_id, metamons) {
        let count = 0;
        for (let monster of metamons) {
            if (monster.tokenId == monster_token_id) {
                return count;
            }
            count++;
        }
        return -1;
    }
	
	/**
	Perform all battles of a list of monsters
	 */
	async battle (monsters, strategy="weakest", levelup=true) {
        // const wallet_monsters = this.updateWallet();
        this.total_level_ups = 0;

        for (let monster of monsters) {
			if (monster.tear == 0)
				continue;

            const tear = monster.tear;
            // level = monster.get("level")
            const battlers = await this.listOpponents(monster.id);
            const battler = MetamonIsland.pickOpponent(battlers, strategy);
            const target_monster_id = battler.id;

            await this.changeFighter(monster.id);
            // Workaround: Pass the index of the monster in the current table
            // This is required because updateMetamonTable uses metamon objects at the beginning of the battles
            // However, the list of metamons in mi gets updated after level ups, thus it would not find the metamons anymore
            const monster_table_idx = this.metamon_idx(monster.tokenId, this.metamons);
            await this.battleMetamon(monster, monster_table_idx, target_monster_id, tear, levelup);

            if (this.not_enough_money)
                break;
		}
        
		const total_count = this.total_success + this.total_fail;
        let success_percent = 0.0;
        if (total_count > 0) {
            success_percent = this.total_success / total_count;
		};

        // Stats of all battles
        const stats = {
            "won": this.total_success,
            "defeats": this.total_fail,
            "win_rate": success_percent,
            "fragments": this.total_bp_num,
            "level_ups": this.total_level_ups,
            "timestamp": Date.now()
        };

        return [stats, this.mtm_stats];
	}
	
    /**
	Main method for battelng with a specific metamon
	 */
	async battleMetamon(monster, monster_table_idx, target_monster_id, loop_count=1, levelup=true) {
        let success = 0;
        let fail = 0;
        let total_bp_fragment_num = 0;
        const my_monster_id = monster.id;
        const my_monster_token_id = parseInt(monster.tokenId);
        let my_level = monster.level;
        const my_power = monster.sca;
        let battle_level = MetamonIsland.pickBattleLevel(my_level);
        const init_tear = monster.tear;
        let experience = monster.exp;
        let exp_to_next = monster.expMax;

        for (let count = 0; count < loop_count; count++) {
            const payload = {
                "monsterA": my_monster_id,
                "monsterB": target_monster_id,
                "address": this.address,
                "battleLevel": battle_level,
            };
            const response = await fetch_loop(START_FIGHT_URL, "post", urlencoded(payload), this.headersTokenAndCT());

            const code = response.code;
            if (code == "BATTLE_NOPAY") {
                this.not_enough_money = true;
				(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.error_msg)("Not enough uRACA to play on Metamon Island!", "danger");
                break;
			}
            else if (code == "SUCCESS") {
                const data = response.data;
                const fight_result = data.challengeResult;
                const bp_fragment_num = data.bpFragmentNum;
                const experience_incr = data.challengeExp;

                if (levelup) {
                    // Try to level up
                    const payload = {"nftId": my_monster_id, "address": this.address}
                    const res = await fetch_loop(LVL_UP_URL, "post",  urlencoded(payload), this.headersTokenAndCT());
                    const code = res.code;
                    if (code == "SUCCESS") {
                        my_level += 1;
                        // Update league level if new level is 21 or 41
                        battle_level = MetamonIsland.pickBattleLevel(my_level);
                        this.total_level_ups += 1;
                        experience = experience - exp_to_next;
                        // Now we need to update the metamon to update the expMax field
                        const all_monsters = await this.updateWallet();
                        exp_to_next = all_monsters.find(element => element.tokenId == my_monster_token_id).expMax;
                    };
                };

                this.total_bp_num += bp_fragment_num;
                total_bp_fragment_num += bp_fragment_num;
                experience += experience_incr;
                if (fight_result) {
                    success += 1;
                    this.total_success += 1;
                } else {
                    fail += 1;
                    this.total_fail += 1;
                }

                // Change state in UI
                updateMetamonTable(monster, monster_table_idx, my_level, experience, init_tear - count - 1, progress_from_tear(init_tear - count - 1), success, total_bp_fragment_num);
            };
        };

        const curr_mtm_stats = {
            "metamon_id": my_monster_token_id,
            "league_level": battle_level,
            "battles": loop_count,
            "power": my_power,
            "experience": experience,
            "metamon_level": my_level,
            "rarity": monster.rarity,
            "won": success,
            "fragments": total_bp_fragment_num,
            "timestamp": Date.now()
        }
        this.mtm_stats.push(curr_mtm_stats);
    }
	
	async mintEggs () {
        // await this.init_token();

		const payload = {"address": this.address};
		let totalEggFragments = 0;

        // Check current egg fragments
		const bagRes = await fetch_loop(CHECK_BAG_URL, "post", urlencoded(payload), this.headersTokenAndCT());

		const items = bagRes.data.item; 
        for (const item of items) {
			if (item.bpType == 1) {
				totalEggFragments = item.bpNum;
				break;
			}
		}
        const totalEggs = parseInt(parseInt(totalEggFragments) / 1000);

		if (totalEggs < 1) 
			return 0;

		const res = await fetch_loop(MINT_EGG_URL, "post", urlencoded(payload), this.headersTokenAndCT());
		const code = res["code"];
		if (code != "SUCCESS")
			return 0;

        console.log("Minted Eggs Total: " + totalEggs);
        return totalEggs;
	}
	
	// Static methods
	
	/**
	Pick an opponent according to a given strategy ("weakest" or "random")
	 */
	static pickOpponent(monsters_list, strategy="weakest") {
	    let battlers = [];
		for (let monster of monsters_list) {
			if (monster["rarity"] == "N")
				battlers.push(monster);
		};
		
		if (battlers.length == 0) {
			for (let monster of monsters_list) {
				if (monster["rarity"] == "R")
					battlers.push(monster);
			};		
		};
	        
	
	    if (strategy == "weakest")
	        return MetamonIsland.pickOpponentWeakest(battlers);
		else if (strategy == "random")
	        return MetamonIsland.pickOpponentRandom(battlers);		
	};
	
	static pickOpponentRandom(battlers) {
	    return battlers[(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getRandomInt)(len(battlers))];
	};
	
	static pickOpponentWeakest(battlers) {
	    let best_battler = battlers[0];
	    let score_min = best_battler["sca"];
	    
		for (let battler of battlers) {
	        if (battler["sca"] < score_min) {
	            best_battler = battler;
	            score_min = battler["sca"];
			};
		};
	    return best_battler;
	};
	
	/**
	Pick a battle league (currently there are 3!)
	 */
	static pickBattleLevel (level=1) {
	    if ((21 <= level) && (level <= 40)) {
	        return 2;
		} else if ((41 <= level) && (level <= 60)) {
	        return 3;
		}
		
	    return 1;
	};
};

let mi = null;
const MAX_TEAR = 20;

function progress_from_tear(tear) {
    return (MAX_TEAR - tear)*100.0/MAX_TEAR;
}

async function loadMetamons (address, sign, msg) {
    enable_submit_button(false);
    show_spinner(true);
    button_text("Loading...");

    let success = true;
    if (mi == null) {
        mi = new MetamonIsland(address, sign, msg);
        success = await mi.initToken();

        if (!success) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.error_msg)("Could not login to Metamon Island!", "danger");
        }
    }

    if (success) {
        const metamons = await mi.updateWallet();
        const progress = lodash__WEBPACK_IMPORTED_MODULE_1___default().map(metamons, function (m) {return progress_from_tear(m.tear);});
        const wins = Array.from('-'.repeat(metamons.length));
        const fragments = Array.from('-'.repeat(metamons.length));

        fillMetamonTable(metamons, progress, wins, fragments);
    }

    enable_submit_button(true);
    show_spinner(false);
    button_text("Start battles!");
}

async function startBattles () {
    if (!mi)
        return;

    enable_submit_button(false);
    show_spinner(true);
    button_text("Battling...");

    const strategy = document.getElementById("strategy").value;
    const levelup = document.getElementById("levelup").checked;
    const minteggs = document.getElementById("minteggs").checked;
    const statistics = document.getElementById("statistics").checked;

    let metamons_to_play = [];
    let count = 0;
    for (let metamon of mi.metamons) {
        if (document.getElementById("mtm" + count).checked) {
            metamons_to_play.push(metamon);
        }
        count++;
    }

    const result = await mi.battle(metamons_to_play, strategy, levelup);

    if (result.length > 0) {
        const stats = result[0];
        const mtm_stats = result[1];
        
        stats.minted_eggs = 0;
        if (minteggs) {
            const minted_eggs = await mi.mintEggs();
            stats.minted_eggs = minted_eggs;
        }

        if (statistics)
            sendStats([stats, mtm_stats]);

        fillSummaryTable(stats);
        show_battle_results();
    }
    await mi.updateWallet();
    
    enable_submit_button(true);
    show_spinner(false);
    button_text("Start battles!");
}

async function sendStats(data) {
    await fetch('stats', {
        method: 'post',
        headers: {'Content-Type': 'application/json',
                  'X-CSRF-TOKEN': getCookie('csrf_access_token')},
        body: JSON.stringify(data)
    });
}

// User Interface

function fillMetamonTable (metamons, progress, wins, fragments) {
    const table_body = document.getElementById("metamon_table_body");

    let count = 0;
	for (let metamon of metamons) {
		// <tr>	
		const row = document.createElement('tr');

        // Checkbox
        row.insertAdjacentHTML("beforeend", '<td> <input id="mtm' + count + '" name="mtm' + count + '" type="checkbox" class="select-item checkbox form-check-input" checked> </td>');
        // Data: Token Id
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.tokenId + ' </td>');
        // Data: Pic
        row.insertAdjacentHTML("beforeend", '<td> <img src="' + metamon.imageUrl  + '" alt="' + metamon.tokenId + '"></td>');
        // Data: Rarity
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.rarity + '</td>');
        // Data: Power
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.sca + '</td>');
        // Data: Level
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.level + '<i>/' + metamon.levelMax + '</i></td>');
        // Data: Experience
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.exp + '</td>');
        // Data: Experience
        row.insertAdjacentHTML("beforeend", '<td>' + metamon.tear + '<i>/20</i></td>');
        // Data: Progress bar
        let add_class = "";
        if (progress[count] == 100) {
            add_class = "progress_finished"
        };
        row.insertAdjacentHTML("beforeend", '<td> <div class="progress"> <div class="progress-bar ' + add_class + '" role="progressbar" style="width: ' + progress[count] + '%" aria-valuenow="' + progress[count] + '" aria-valuemin="0" aria-valuemax="100"></div></div></td>');
        // Data: Wins
        row.insertAdjacentHTML("beforeend", '<td>' + wins[count] + '</td>');
        // Data: Fragments
        row.insertAdjacentHTML("beforeend", '<td>' + fragments[count] + '</td>');

        // Append a new row to table
        table_body.appendChild(row);
        count++;
	}

    setCheckboxOnClickEvents();
};

function updateMetamonTable (metamon, monster_table_idx, level, experience, tear, progress, wins, fragments) {
    const table_body = document.getElementById("metamon_table_body");

    const tr_tag = table_body.getElementsByTagName("tr")[monster_table_idx];

    if (!tr_tag) {
        console.log(table_body, monster_table_idx, table_body.getElementsByTagName("tr").length);
    }

    const td_tags = tr_tag.getElementsByTagName("td");

    td_tags[5].innerHTML = level + '<i>/' + metamon.levelMax + '</i>';
    td_tags[6].innerHTML = String(experience);
    td_tags[7].innerHTML = tear + '<i>/' + MAX_TEAR + '</i>';
    let add_class = "";
    if (progress == 100) {
        add_class = "progress_finished"
    };
    td_tags[8].innerHTML = '<div class="progress"> <div class="progress-bar ' + add_class + '" role="progressbar" style="width: ' + progress + '%" aria-valuenow="' + progress + '" aria-valuemin="0" aria-valuemax="100"></div></div>';
    td_tags[9].innerHTML = String(wins);
    td_tags[10].innerHTML = String(fragments);
}

function fillSummaryTable (stats) {
    const table_body = document.getElementById("battle-results");

    const stats_list = [stats["won"] + stats["defeats"], stats["won"], stats["defeats"], (Math.round(stats["win_rate"] * 1000) / 10).toFixed(1) + "%", 
                        stats["fragments"], stats["minted_eggs"], stats["level_ups"]];
    const tr_tags = table_body.getElementsByTagName("tr");
    for (let n = 0 ; n < stats_list.length ; n++) {
        const td_tag = tr_tags[n].getElementsByTagName("td")[1];
        td_tag.innerHTML = String(stats_list[n]);
    }
};

function button_text (label) {
    document.getElementById("battle-submit-button-text").textContent = label;
}

function enable_submit_button (value) {
    document.getElementById("battle-submit-button").disabled = !value;
}

function show_spinner (value) {
    let str_val = value ? "" : "none";
    document.getElementById("battle-submit-button").getElementsByClassName("spinner-border")[0].style.display = str_val;
}

function show_battle_results () {
    document.getElementById("battle-submit-button").style.display = "block";
}

function setCheckboxOnClickEvents() {
    //column checkbox select all or cancel
    document.getElementsByClassName("select-all")[0].onclick = function() {
        var checked = this.checked;
        [].forEach.call(document.getElementsByClassName('select-item'), function(item, index) {
            item.checked = checked;
        });
    };

    //check selected items
    [].forEach.call(document.getElementsByClassName("select-item"), (item, index) => {
        item.onclick = function() {
            const checked = this.checked;
            let all = document.getElementsByClassName("select-all")[0];
            // number of boxes
            const total = document.getElementsByClassName("select-item").length;
            // number of checked boxes
            let num_checked = document.querySelectorAll('.select-item:checked').length;
            all.checked = num_checked===total;
        };
    });
};

var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
  return new bootstrap.Tooltip(tooltipTriggerEl)
})


window.loadMetamons = loadMetamons;
//window.startBattles = startBattles;
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!*********************!*\
  !*** ./mm-login.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _login_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login-auth.js */ "./login-auth.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./utils.js");



const BSC_CHAIN_ID = 56;

[].forEach.call(document.getElementsByClassName("metamask-login"), (item, index) => {
    item.onclick = async () => {
		login_metamask();
	}
});

async function login_metamask() {
	const provider = await detectEthereumProvider()

	if (provider) {
		try  {
			if (!await check_chain(provider)) {
				return false;
			}

			const wallet_address = await get_wallet_address(provider);
			await (0,_login_auth_js__WEBPACK_IMPORTED_MODULE_0__.login)(wallet_address, provider);
		}
		catch(error) {
			if (error.code == 4001) {
				(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("An error occurred. Try again and if the error persists, please contact me.", "danger");
			}
		}
	} else {
	  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("Cannot find Metamask!", "danger");
	  return false;
	}
};

async function check_chain(provider)
{
	if (provider.chainId !== BSC_CHAIN_ID) {
		try {
		  	await provider.request({
				method: 'wallet_switchEthereumChain',
				params: [{ chainId: "0x38" }]
			});
		} catch (err) {
			// This error code indicates that the chain has not been added to MetaMask
			if (err.code === 4902) {
				try {
					await provider.request({
						method: 'wallet_addEthereumChain',
						params: [
							{
							chainName: 'Binance Chain',
							chainId: "0x38",
							nativeCurrency: { name: 'BNB', decimals: 18, symbol: 'BNB' },
							rpcUrls: ['https://bsc-dataseed.binance.org/']
							}
						]
					});
				}
				catch (err) {
					(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("You need to switch to Binance Chain to login!", "danger");
					return false;
				}
			}
		}
	}
    return true;
}

async function get_wallet_address(provider)
{
    try {
        let response = await provider.request({method: "eth_requestAccounts"});
        return response[0];
    } catch(e) {
        console.log(error);
        return 0;
    }
}
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!********************************!*\
  !*** ./walletconnect-login.js ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _login_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login-auth.js */ "./login-auth.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./utils.js");
/* harmony import */ var _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ethers-5.1.esm.min.js */ "./ethers-5.1.esm.min.js");




//import lodash from 'lodash';
// import Web3 from "web3-provider-engine";
//import WalletConnectProvider from "./walletconnect-web3-provider";

/* import WalletConnectClient from "@walletconnect/client"; */
//const WalletConnectProvider = window.WalletConnectProvider.default;
//const Web3 = window.Web3.default;
let WalletConnectProvider;
if (window.WalletConnectProvider)
    WalletConnectProvider = window.WalletConnectProvider.default;
 
let wc_provider;
 
[].forEach.call(document.getElementsByClassName("walletconnect-login"), (item, index) => {
    item.onclick = async ()=>{
        //  Create WalletConnect Provider
        wc_provider = new WalletConnectProvider({
            //infuraId: "27e484dcd9e3efcfd25a83a78777cdf1", // Required
            rpc: {
                56: "https://bsc-dataseed.binance.org/"
              },
              chainId: 56
        });

        // Subscribe to accounts change
        wc_provider.on("accountsChanged", (accounts) => {
            console.log(accounts);
        });
        
        // Subscribe to session connection
        wc_provider.on("connect", connect);

        //if (get_wallet_address(wc_provider).length >= 42) {
            //await connect();
            wc_provider.disconnect();
        //}

            //  Enable session (triggers QR Code modal)
            try {
                await wc_provider.enable();
            }
            catch(error) {
                if (error == "Error: User closed modal") {
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.error_msg)("User closed the window to connect via WalletConnect. Please login to use Metamon Manager.", "danger");
                }
            }
        
    };
});

async function connect () {
    const wallet_address = get_wallet_address(wc_provider);
    const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.genRandomLoginMsg)();

    const signature = await wc_provider.send(
        'personal_sign',
        [ _ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_2__.ethers.utils.hexlify(_ethers_5_1_esm_min_js__WEBPACK_IMPORTED_MODULE_2__.ethers.utils.toUtf8Bytes(msg)), wallet_address.toLowerCase() ]
    );

    console.log(signature);

    await (0,_login_auth_js__WEBPACK_IMPORTED_MODULE_0__.handle_auth)(wallet_address, msg, signature);

    window.location.href = "/index";

    //await login(wallet_address, wc_provider);

        /*
    const provider = new ethers.providers.Web3Provider(wc_provider);
    const signer = provider.getSigner();
    const signature = await signer.signMessage("Test");
    const address = await signer.getAddress();

    const address2 = wc_provider.wc.accounts[0];

    let signedMessage = await wc_provider.send(
        'personal_sign',
        [ ethers.utils.hexlify(ethers.utils.toUtf8Bytes("Test")), address2.toLowerCase() ]
    );

    const web3 = new Web3(provider);
    const accounts = await web3.eth.getAccounts();
    */
};

function get_wallet_address(wc_provider) {
    try {
        return wc_provider.wc.accounts[0].toLowerCase();
    } catch(e) {
        console.log(e);
        return "";
    }
};
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************!*\
  !*** ./toasts.js ***!
  \*******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./utils.js");


function showPrivacyToast(show) {
    var toastElement = document.getElementById('gdprToast');
    if (toastElement) {
        var toast = new bootstrap.Toast(toastElement);
        if (show) {
            toast.show();
        }
        else {
            toast.hide();
        }
    };
};

// Event Listener
document.addEventListener('DOMContentLoaded', initConsent);

async function initConsent () {
    if (consentRequired()) {
        showPrivacyToast(true);
    }
    else {
        await sendConsent("NOT_REQUIRED");
    }
};

var notAgree = document.getElementById('privacy-not-agree');
if (notAgree)
    notAgree.onclick = notAcceptGDPR;
var agree = document.getElementById('privacy-agree');
if (agree)
    agree.onclick = acceptGDPR;

async function notAcceptGDPR () {
    showPrivacyToast(false);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.error_msg)("You need to accept to placing cookies to use this website. Functionality will be restricted.", "danger");
    await sendConsent(false);
};

async function acceptGDPR () {
    await sendConsent(true);
};

async function sendConsent(consent) {
    const options = {
        method: 'post',
        headers: {
            'Content-Type': 'application/json'
          },
        body: JSON.stringify({"consent": consent})
    };
    await fetch('/consent', options);
};

/**
 * Determine whether a consent to setting cookies according to teh GDPR is required.
 * @returns true if a user is likely living in EU
 */
function consentRequired() {
    let tz = "";
    try {
        tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch (err) {
        return true;
    }

    switch (tz) {
      case 'Europe/Vienna':
        return true;
      case 'Europe/Brussels':
        return true;
      case 'Europe/Sofia':
        return true;
      case 'Europe/Zagreb':
        return true;
      case 'Asia/Famagusta':
        return true;
      case 'Asia/Nicosia':
        return true;
      case 'Europe/Prague':
        return true;
      case 'Europe/Copenhagen':
        return true;
      case 'Europe/Tallinn':
        return true;
      case 'Europe/Helsinki':
        return true;
      case 'Europe/Paris':
        return true;
      case 'Europe/Berlin':
        return true;
      case 'Europe/Busingen':
        return true;
      case 'Europe/Athens':
        return true;
      case 'Europe/Budapest':
        return true;
      case 'Europe/Dublin':
        return true;
      case 'Europe/Rome':
        return true;
      case 'Europe/Riga':
        return true;
      case 'Europe/Vilnius':
        return true;
      case 'Europe/Luxembourg':
        return true;
      case 'Europe/Malta':
        return true;
      case 'Europe/Amsterdam':
        return true;
      case 'Europe/Warsaw':
        return true;
      case 'Atlantic/Azores':
        return true;
      case 'Atlantic/Madeira':
        return true;
      case 'Europe/Lisbon':
        return true;
      case 'Europe/Bucharest':
        return true;
      case 'Europe/Bratislava':
        return true;
      case 'Europe/Ljubljana':
        return true;
      case 'Africa/Ceuta':
        return true;
      case 'Atlantic/Canary':
        return true;
      case 'Europe/Madrid':
        return true;
      case 'Europe/Stockholm':
        return true;
      default:
        return false;
    }
};
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0IsY0FBYyxnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0IsY0FBYyxnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0IsY0FBYyxnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixnQkFBZ0Isd0NBQXdDLGNBQWMsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQixtQ0FBbUMsZ0NBQWdDLGFBQWEsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQixtQ0FBbUMsZ0NBQWdDLGFBQWEsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsYUFBYSxzQkFBc0IsdUJBQXVCLDZCQUE2QixzQkFBc0IsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQixtQ0FBbUMsZ0NBQWdDLGFBQWEsc0JBQXNCLHVCQUF1Qiw2QkFBNkIsc0JBQXNCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDJCQUEy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RUE7QUFDQSxlQUFlLHFFQUFlO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxRUFBZTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUscUVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxxRUFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLFdBQVcscUVBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsV0FBVyxtRUFBaUI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLG1FQUFp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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2YsRUFBRSxzRUFBWTtBQUNkLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx3S0FBd0s7O0FBRXhLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsUUFBUTtBQUNSLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUSxVQUFVO0FBQ2pDLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxVQUFVO0FBQ2pDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxVQUFVO0FBQ2pDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFl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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsV0FBVztBQUNsQyxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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LElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRO0FBQ3BFO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLE9BQU8sZ0JBQWdCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBMkQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9EQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQUsseUJBQXlCLG1DQUFtQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpRUFBaUU7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRSIsInNvdXJjZXMiOlsid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL2V0aGVycy01LjEuZXNtLm1pbi5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9sb2dpbi1hdXRoLmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9hZGRMZWFkaW5nWmVyb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2Zvcm1hdC9mb3JtYXR0ZXJzL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9mb3JtYXQvbGlnaHRGb3JtYXR0ZXJzL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9mb3JtYXQvbG9uZ0Zvcm1hdHRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFVUQ0RheU9mWWVhci9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZ2V0VVRDSVNPV2Vla1llYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFVUQ0lTT1dlZWsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFVUQ1dlZWtZZWFyL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRVVENXZWVrL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9pc1NhbWVVVENXZWVrL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9wcm90ZWN0ZWRUb2tlbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvc3RhcnRPZlVUQ0lTT1dlZWtZZWFyL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9zdGFydE9mVVRDSVNPV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvc3RhcnRPZlVUQ1dlZWtZZWFyL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9zdGFydE9mVVRDV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vYWRkTWlsbGlzZWNvbmRzL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vZm9ybWF0L2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNEYXRlL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNWYWxpZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL19saWIvYnVpbGRMb2NhbGl6ZUZuL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL19saWIvYnVpbGRNYXRjaEZuL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL19saWIvYnVpbGRNYXRjaFBhdHRlcm5Gbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9kZS9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2RlL19saWIvZm9ybWF0TG9uZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9kZS9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2RlL19saWIvbG9jYWxpemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZGUvX2xpYi9tYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2VuLVVTL19saWIvZm9ybWF0TG9uZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2VuLVVTL19saWIvbG9jYWxpemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9tYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS96aC1DTi9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL3poLUNOL19saWIvZm9ybWF0TG9uZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS96aC1DTi9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL3poLUNOL19saWIvbG9jYWxpemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvemgtQ04vX2xpYi9tYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS96aC1DTi9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3N1Yk1pbGxpc2Vjb25kcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3RvRGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi91dGlscy5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vc3RhdGlzdGljcy5qcyIsIndlYnBhY2s6Ly9tZXRhbW9uLW1hbmFnZXIvLi9tYW5hZ2VyLmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL21tLWxvZ2luLmpzIiwid2VicGFjazovL21ldGFtb24tbWFuYWdlci8uL3dhbGxldGNvbm5lY3QtbG9naW4uanMiLCJ3ZWJwYWNrOi8vbWV0YW1vbi1tYW5hZ2VyLy4vdG9hc3RzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb25qc0dsb2JhbD10eXBlb2YgZ2xvYmFsVGhpcyE9PVwidW5kZWZpbmVkXCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6dHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnt9O2Z1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHgpe3JldHVybiB4JiZ4Ll9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LFwiZGVmYXVsdFwiKT94W1wiZGVmYXVsdFwiXTp4fWZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLGJhc2VkaXIsbW9kdWxlKXtyZXR1cm4gbW9kdWxlPXtwYXRoOmJhc2VkaXIsZXhwb3J0czp7fSxyZXF1aXJlOmZ1bmN0aW9uKHBhdGgsYmFzZSl7cmV0dXJuIGNvbW1vbmpzUmVxdWlyZShwYXRoLGJhc2U9PT11bmRlZmluZWR8fGJhc2U9PT1udWxsP21vZHVsZS5wYXRoOmJhc2UpfX0sZm4obW9kdWxlLG1vZHVsZS5leHBvcnRzKSxtb2R1bGUuZXhwb3J0c31mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmUHJlc2VudChuKXtyZXR1cm4gbiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJkZWZhdWx0XCIpP25bXCJkZWZhdWx0XCJdOm59ZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZk5vdE5hbWVkKG4pe3JldHVybiBuJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixcImRlZmF1bHRcIikmJk9iamVjdC5rZXlzKG4pLmxlbmd0aD09PTE/bltcImRlZmF1bHRcIl06bn1mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2Uobil7aWYobi5fX2VzTW9kdWxlKXJldHVybiBuO3ZhciBhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO09iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24oayl7dmFyIGQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLGspO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGssZC5nZXQ/ZDp7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2tdfX0pfSk7cmV0dXJuIGF9ZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlKCl7dGhyb3cgbmV3IEVycm9yKFwiRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgQHJvbGx1cC9wbHVnaW4tY29tbW9uanNcIil9dmFyIGJuPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKG1vZHVsZSl7KGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBhc3NlcnQodmFsLG1zZyl7aWYoIXZhbCl0aHJvdyBuZXcgRXJyb3IobXNnfHxcIkFzc2VydGlvbiBmYWlsZWRcIil9ZnVuY3Rpb24gaW5oZXJpdHMoY3RvcixzdXBlckN0b3Ipe2N0b3Iuc3VwZXJfPXN1cGVyQ3Rvcjt2YXIgVGVtcEN0b3I9ZnVuY3Rpb24oKXt9O1RlbXBDdG9yLnByb3RvdHlwZT1zdXBlckN0b3IucHJvdG90eXBlO2N0b3IucHJvdG90eXBlPW5ldyBUZW1wQ3RvcjtjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1jdG9yfWZ1bmN0aW9uIEJOKG51bWJlcixiYXNlLGVuZGlhbil7aWYoQk4uaXNCTihudW1iZXIpKXtyZXR1cm4gbnVtYmVyfXRoaXMubmVnYXRpdmU9MDt0aGlzLndvcmRzPW51bGw7dGhpcy5sZW5ndGg9MDt0aGlzLnJlZD1udWxsO2lmKG51bWJlciE9PW51bGwpe2lmKGJhc2U9PT1cImxlXCJ8fGJhc2U9PT1cImJlXCIpe2VuZGlhbj1iYXNlO2Jhc2U9MTB9dGhpcy5faW5pdChudW1iZXJ8fDAsYmFzZXx8MTAsZW5kaWFufHxcImJlXCIpfX1pZih0eXBlb2YgbW9kdWxlPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9Qk59ZWxzZXtleHBvcnRzLkJOPUJOfUJOLkJOPUJOO0JOLndvcmRTaXplPTI2O3ZhciBCdWZmZXI7dHJ5e2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2Ygd2luZG93LkJ1ZmZlciE9PVwidW5kZWZpbmVkXCIpe0J1ZmZlcj13aW5kb3cuQnVmZmVyfWVsc2V7QnVmZmVyPW51bGwuQnVmZmVyfX1jYXRjaChlKXt9Qk4uaXNCTj1mdW5jdGlvbiBpc0JOKG51bSl7aWYobnVtIGluc3RhbmNlb2YgQk4pe3JldHVybiB0cnVlfXJldHVybiBudW0hPT1udWxsJiZ0eXBlb2YgbnVtPT09XCJvYmplY3RcIiYmbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplPT09Qk4ud29yZFNpemUmJkFycmF5LmlzQXJyYXkobnVtLndvcmRzKX07Qk4ubWF4PWZ1bmN0aW9uIG1heChsZWZ0LHJpZ2h0KXtpZihsZWZ0LmNtcChyaWdodCk+MClyZXR1cm4gbGVmdDtyZXR1cm4gcmlnaHR9O0JOLm1pbj1mdW5jdGlvbiBtaW4obGVmdCxyaWdodCl7aWYobGVmdC5jbXAocmlnaHQpPDApcmV0dXJuIGxlZnQ7cmV0dXJuIHJpZ2h0fTtCTi5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24gaW5pdChudW1iZXIsYmFzZSxlbmRpYW4pe2lmKHR5cGVvZiBudW1iZXI9PT1cIm51bWJlclwiKXtyZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsYmFzZSxlbmRpYW4pfWlmKHR5cGVvZiBudW1iZXI9PT1cIm9iamVjdFwiKXtyZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlcixiYXNlLGVuZGlhbil9aWYoYmFzZT09PVwiaGV4XCIpe2Jhc2U9MTZ9YXNzZXJ0KGJhc2U9PT0oYmFzZXwwKSYmYmFzZT49MiYmYmFzZTw9MzYpO251bWJlcj1udW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csXCJcIik7dmFyIHN0YXJ0PTA7aWYobnVtYmVyWzBdPT09XCItXCIpe3N0YXJ0Kys7dGhpcy5uZWdhdGl2ZT0xfWlmKHN0YXJ0PG51bWJlci5sZW5ndGgpe2lmKGJhc2U9PT0xNil7dGhpcy5fcGFyc2VIZXgobnVtYmVyLHN0YXJ0LGVuZGlhbil9ZWxzZXt0aGlzLl9wYXJzZUJhc2UobnVtYmVyLGJhc2Usc3RhcnQpO2lmKGVuZGlhbj09PVwibGVcIil7dGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLGJhc2UsZW5kaWFuKX19fX07Qk4ucHJvdG90eXBlLl9pbml0TnVtYmVyPWZ1bmN0aW9uIF9pbml0TnVtYmVyKG51bWJlcixiYXNlLGVuZGlhbil7aWYobnVtYmVyPDApe3RoaXMubmVnYXRpdmU9MTtudW1iZXI9LW51bWJlcn1pZihudW1iZXI8NjcxMDg4NjQpe3RoaXMud29yZHM9W251bWJlciY2NzEwODg2M107dGhpcy5sZW5ndGg9MX1lbHNlIGlmKG51bWJlcjw0NTAzNTk5NjI3MzcwNDk2KXt0aGlzLndvcmRzPVtudW1iZXImNjcxMDg4NjMsbnVtYmVyLzY3MTA4ODY0JjY3MTA4ODYzXTt0aGlzLmxlbmd0aD0yfWVsc2V7YXNzZXJ0KG51bWJlcjw5MDA3MTk5MjU0NzQwOTkyKTt0aGlzLndvcmRzPVtudW1iZXImNjcxMDg4NjMsbnVtYmVyLzY3MTA4ODY0JjY3MTA4ODYzLDFdO3RoaXMubGVuZ3RoPTN9aWYoZW5kaWFuIT09XCJsZVwiKXJldHVybjt0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksYmFzZSxlbmRpYW4pfTtCTi5wcm90b3R5cGUuX2luaXRBcnJheT1mdW5jdGlvbiBfaW5pdEFycmF5KG51bWJlcixiYXNlLGVuZGlhbil7YXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoPT09XCJudW1iZXJcIik7aWYobnVtYmVyLmxlbmd0aDw9MCl7dGhpcy53b3Jkcz1bMF07dGhpcy5sZW5ndGg9MTtyZXR1cm4gdGhpc310aGlzLmxlbmd0aD1NYXRoLmNlaWwobnVtYmVyLmxlbmd0aC8zKTt0aGlzLndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3RoaXMud29yZHNbaV09MH12YXIgaix3O3ZhciBvZmY9MDtpZihlbmRpYW49PT1cImJlXCIpe2ZvcihpPW51bWJlci5sZW5ndGgtMSxqPTA7aT49MDtpLT0zKXt3PW51bWJlcltpXXxudW1iZXJbaS0xXTw8OHxudW1iZXJbaS0yXTw8MTY7dGhpcy53b3Jkc1tqXXw9dzw8b2ZmJjY3MTA4ODYzO3RoaXMud29yZHNbaisxXT13Pj4+MjYtb2ZmJjY3MTA4ODYzO29mZis9MjQ7aWYob2ZmPj0yNil7b2ZmLT0yNjtqKyt9fX1lbHNlIGlmKGVuZGlhbj09PVwibGVcIil7Zm9yKGk9MCxqPTA7aTxudW1iZXIubGVuZ3RoO2krPTMpe3c9bnVtYmVyW2ldfG51bWJlcltpKzFdPDw4fG51bWJlcltpKzJdPDwxNjt0aGlzLndvcmRzW2pdfD13PDxvZmYmNjcxMDg4NjM7dGhpcy53b3Jkc1tqKzFdPXc+Pj4yNi1vZmYmNjcxMDg4NjM7b2ZmKz0yNDtpZihvZmY+PTI2KXtvZmYtPTI2O2orK319fXJldHVybiB0aGlzLnN0cmlwKCl9O2Z1bmN0aW9uIHBhcnNlSGV4NEJpdHMoc3RyaW5nLGluZGV4KXt2YXIgYz1zdHJpbmcuY2hhckNvZGVBdChpbmRleCk7aWYoYz49NjUmJmM8PTcwKXtyZXR1cm4gYy01NX1lbHNlIGlmKGM+PTk3JiZjPD0xMDIpe3JldHVybiBjLTg3fWVsc2V7cmV0dXJuIGMtNDgmMTV9fWZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZShzdHJpbmcsbG93ZXJCb3VuZCxpbmRleCl7dmFyIHI9cGFyc2VIZXg0Qml0cyhzdHJpbmcsaW5kZXgpO2lmKGluZGV4LTE+PWxvd2VyQm91bmQpe3J8PXBhcnNlSGV4NEJpdHMoc3RyaW5nLGluZGV4LTEpPDw0fXJldHVybiByfUJOLnByb3RvdHlwZS5fcGFyc2VIZXg9ZnVuY3Rpb24gX3BhcnNlSGV4KG51bWJlcixzdGFydCxlbmRpYW4pe3RoaXMubGVuZ3RoPU1hdGguY2VpbCgobnVtYmVyLmxlbmd0aC1zdGFydCkvNik7dGhpcy53b3Jkcz1uZXcgQXJyYXkodGhpcy5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt0aGlzLndvcmRzW2ldPTB9dmFyIG9mZj0wO3ZhciBqPTA7dmFyIHc7aWYoZW5kaWFuPT09XCJiZVwiKXtmb3IoaT1udW1iZXIubGVuZ3RoLTE7aT49c3RhcnQ7aS09Mil7dz1wYXJzZUhleEJ5dGUobnVtYmVyLHN0YXJ0LGkpPDxvZmY7dGhpcy53b3Jkc1tqXXw9dyY2NzEwODg2MztpZihvZmY+PTE4KXtvZmYtPTE4O2orPTE7dGhpcy53b3Jkc1tqXXw9dz4+PjI2fWVsc2V7b2ZmKz04fX19ZWxzZXt2YXIgcGFyc2VMZW5ndGg9bnVtYmVyLmxlbmd0aC1zdGFydDtmb3IoaT1wYXJzZUxlbmd0aCUyPT09MD9zdGFydCsxOnN0YXJ0O2k8bnVtYmVyLmxlbmd0aDtpKz0yKXt3PXBhcnNlSGV4Qnl0ZShudW1iZXIsc3RhcnQsaSk8PG9mZjt0aGlzLndvcmRzW2pdfD13JjY3MTA4ODYzO2lmKG9mZj49MTgpe29mZi09MTg7ais9MTt0aGlzLndvcmRzW2pdfD13Pj4+MjZ9ZWxzZXtvZmYrPTh9fX10aGlzLnN0cmlwKCl9O2Z1bmN0aW9uIHBhcnNlQmFzZShzdHIsc3RhcnQsZW5kLG11bCl7dmFyIHI9MDt2YXIgbGVuPU1hdGgubWluKHN0ci5sZW5ndGgsZW5kKTtmb3IodmFyIGk9c3RhcnQ7aTxsZW47aSsrKXt2YXIgYz1zdHIuY2hhckNvZGVBdChpKS00ODtyKj1tdWw7aWYoYz49NDkpe3IrPWMtNDkrMTB9ZWxzZSBpZihjPj0xNyl7cis9Yy0xNysxMH1lbHNle3IrPWN9fXJldHVybiByfUJOLnByb3RvdHlwZS5fcGFyc2VCYXNlPWZ1bmN0aW9uIF9wYXJzZUJhc2UobnVtYmVyLGJhc2Usc3RhcnQpe3RoaXMud29yZHM9WzBdO3RoaXMubGVuZ3RoPTE7Zm9yKHZhciBsaW1iTGVuPTAsbGltYlBvdz0xO2xpbWJQb3c8PTY3MTA4ODYzO2xpbWJQb3cqPWJhc2Upe2xpbWJMZW4rK31saW1iTGVuLS07bGltYlBvdz1saW1iUG93L2Jhc2V8MDt2YXIgdG90YWw9bnVtYmVyLmxlbmd0aC1zdGFydDt2YXIgbW9kPXRvdGFsJWxpbWJMZW47dmFyIGVuZD1NYXRoLm1pbih0b3RhbCx0b3RhbC1tb2QpK3N0YXJ0O3ZhciB3b3JkPTA7Zm9yKHZhciBpPXN0YXJ0O2k8ZW5kO2krPWxpbWJMZW4pe3dvcmQ9cGFyc2VCYXNlKG51bWJlcixpLGkrbGltYkxlbixiYXNlKTt0aGlzLmltdWxuKGxpbWJQb3cpO2lmKHRoaXMud29yZHNbMF0rd29yZDw2NzEwODg2NCl7dGhpcy53b3Jkc1swXSs9d29yZH1lbHNle3RoaXMuX2lhZGRuKHdvcmQpfX1pZihtb2QhPT0wKXt2YXIgcG93PTE7d29yZD1wYXJzZUJhc2UobnVtYmVyLGksbnVtYmVyLmxlbmd0aCxiYXNlKTtmb3IoaT0wO2k8bW9kO2krKyl7cG93Kj1iYXNlfXRoaXMuaW11bG4ocG93KTtpZih0aGlzLndvcmRzWzBdK3dvcmQ8NjcxMDg4NjQpe3RoaXMud29yZHNbMF0rPXdvcmR9ZWxzZXt0aGlzLl9pYWRkbih3b3JkKX19dGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGRlc3Qpe2Rlc3Qud29yZHM9bmV3IEFycmF5KHRoaXMubGVuZ3RoKTtmb3IodmFyIGk9MDtpPHRoaXMubGVuZ3RoO2krKyl7ZGVzdC53b3Jkc1tpXT10aGlzLndvcmRzW2ldfWRlc3QubGVuZ3RoPXRoaXMubGVuZ3RoO2Rlc3QubmVnYXRpdmU9dGhpcy5uZWdhdGl2ZTtkZXN0LnJlZD10aGlzLnJlZH07Qk4ucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uIGNsb25lKCl7dmFyIHI9bmV3IEJOKG51bGwpO3RoaXMuY29weShyKTtyZXR1cm4gcn07Qk4ucHJvdG90eXBlLl9leHBhbmQ9ZnVuY3Rpb24gX2V4cGFuZChzaXplKXt3aGlsZSh0aGlzLmxlbmd0aDxzaXplKXt0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdPTB9cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5zdHJpcD1mdW5jdGlvbiBzdHJpcCgpe3doaWxlKHRoaXMubGVuZ3RoPjEmJnRoaXMud29yZHNbdGhpcy5sZW5ndGgtMV09PT0wKXt0aGlzLmxlbmd0aC0tfXJldHVybiB0aGlzLl9ub3JtU2lnbigpfTtCTi5wcm90b3R5cGUuX25vcm1TaWduPWZ1bmN0aW9uIF9ub3JtU2lnbigpe2lmKHRoaXMubGVuZ3RoPT09MSYmdGhpcy53b3Jkc1swXT09PTApe3RoaXMubmVnYXRpdmU9MH1yZXR1cm4gdGhpc307Qk4ucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3JldHVybih0aGlzLnJlZD9cIjxCTi1SOiBcIjpcIjxCTjogXCIpK3RoaXMudG9TdHJpbmcoMTYpK1wiPlwifTt2YXIgemVyb3M9W1wiXCIsXCIwXCIsXCIwMFwiLFwiMDAwXCIsXCIwMDAwXCIsXCIwMDAwMFwiLFwiMDAwMDAwXCIsXCIwMDAwMDAwXCIsXCIwMDAwMDAwMFwiLFwiMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJdO3ZhciBncm91cFNpemVzPVswLDAsMjUsMTYsMTIsMTEsMTAsOSw4LDgsNyw3LDcsNyw2LDYsNiw2LDYsNiw2LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDVdO3ZhciBncm91cEJhc2VzPVswLDAsMzM1NTQ0MzIsNDMwNDY3MjEsMTY3NzcyMTYsNDg4MjgxMjUsNjA0NjYxNzYsNDAzNTM2MDcsMTY3NzcyMTYsNDMwNDY3MjEsMWU3LDE5NDg3MTcxLDM1ODMxODA4LDYyNzQ4NTE3LDc1Mjk1MzYsMTEzOTA2MjUsMTY3NzcyMTYsMjQxMzc1NjksMzQwMTIyMjQsNDcwNDU4ODEsNjRlNiw0MDg0MTAxLDUxNTM2MzIsNjQzNjM0Myw3OTYyNjI0LDk3NjU2MjUsMTE4ODEzNzYsMTQzNDg5MDcsMTcyMTAzNjgsMjA1MTExNDksMjQzZTUsMjg2MjkxNTEsMzM1NTQ0MzIsMzkxMzUzOTMsNDU0MzU0MjQsNTI1MjE4NzUsNjA0NjYxNzZdO0JOLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZyhiYXNlLHBhZGRpbmcpe2Jhc2U9YmFzZXx8MTA7cGFkZGluZz1wYWRkaW5nfDB8fDE7dmFyIG91dDtpZihiYXNlPT09MTZ8fGJhc2U9PT1cImhleFwiKXtvdXQ9XCJcIjt2YXIgb2ZmPTA7dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3ZhciB3PXRoaXMud29yZHNbaV07dmFyIHdvcmQ9KCh3PDxvZmZ8Y2FycnkpJjE2Nzc3MjE1KS50b1N0cmluZygxNik7Y2Fycnk9dz4+PjI0LW9mZiYxNjc3NzIxNTtpZihjYXJyeSE9PTB8fGkhPT10aGlzLmxlbmd0aC0xKXtvdXQ9emVyb3NbNi13b3JkLmxlbmd0aF0rd29yZCtvdXR9ZWxzZXtvdXQ9d29yZCtvdXR9b2ZmKz0yO2lmKG9mZj49MjYpe29mZi09MjY7aS0tfX1pZihjYXJyeSE9PTApe291dD1jYXJyeS50b1N0cmluZygxNikrb3V0fXdoaWxlKG91dC5sZW5ndGglcGFkZGluZyE9PTApe291dD1cIjBcIitvdXR9aWYodGhpcy5uZWdhdGl2ZSE9PTApe291dD1cIi1cIitvdXR9cmV0dXJuIG91dH1pZihiYXNlPT09KGJhc2V8MCkmJmJhc2U+PTImJmJhc2U8PTM2KXt2YXIgZ3JvdXBTaXplPWdyb3VwU2l6ZXNbYmFzZV07dmFyIGdyb3VwQmFzZT1ncm91cEJhc2VzW2Jhc2VdO291dD1cIlwiO3ZhciBjPXRoaXMuY2xvbmUoKTtjLm5lZ2F0aXZlPTA7d2hpbGUoIWMuaXNaZXJvKCkpe3ZhciByPWMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO2M9Yy5pZGl2bihncm91cEJhc2UpO2lmKCFjLmlzWmVybygpKXtvdXQ9emVyb3NbZ3JvdXBTaXplLXIubGVuZ3RoXStyK291dH1lbHNle291dD1yK291dH19aWYodGhpcy5pc1plcm8oKSl7b3V0PVwiMFwiK291dH13aGlsZShvdXQubGVuZ3RoJXBhZGRpbmchPT0wKXtvdXQ9XCIwXCIrb3V0fWlmKHRoaXMubmVnYXRpdmUhPT0wKXtvdXQ9XCItXCIrb3V0fXJldHVybiBvdXR9YXNzZXJ0KGZhbHNlLFwiQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNlwiKX07Qk4ucHJvdG90eXBlLnRvTnVtYmVyPWZ1bmN0aW9uIHRvTnVtYmVyKCl7dmFyIHJldD10aGlzLndvcmRzWzBdO2lmKHRoaXMubGVuZ3RoPT09Mil7cmV0Kz10aGlzLndvcmRzWzFdKjY3MTA4ODY0fWVsc2UgaWYodGhpcy5sZW5ndGg9PT0zJiZ0aGlzLndvcmRzWzJdPT09MSl7cmV0Kz00NTAzNTk5NjI3MzcwNDk2K3RoaXMud29yZHNbMV0qNjcxMDg4NjR9ZWxzZSBpZih0aGlzLmxlbmd0aD4yKXthc3NlcnQoZmFsc2UsXCJOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHNcIil9cmV0dXJuIHRoaXMubmVnYXRpdmUhPT0wPy1yZXQ6cmV0fTtCTi5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybiB0aGlzLnRvU3RyaW5nKDE2KX07Qk4ucHJvdG90eXBlLnRvQnVmZmVyPWZ1bmN0aW9uIHRvQnVmZmVyKGVuZGlhbixsZW5ndGgpe2Fzc2VydCh0eXBlb2YgQnVmZmVyIT09XCJ1bmRlZmluZWRcIik7cmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLGVuZGlhbixsZW5ndGgpfTtCTi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbiB0b0FycmF5KGVuZGlhbixsZW5ndGgpe3JldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LGVuZGlhbixsZW5ndGgpfTtCTi5wcm90b3R5cGUudG9BcnJheUxpa2U9ZnVuY3Rpb24gdG9BcnJheUxpa2UoQXJyYXlUeXBlLGVuZGlhbixsZW5ndGgpe3ZhciBieXRlTGVuZ3RoPXRoaXMuYnl0ZUxlbmd0aCgpO3ZhciByZXFMZW5ndGg9bGVuZ3RofHxNYXRoLm1heCgxLGJ5dGVMZW5ndGgpO2Fzc2VydChieXRlTGVuZ3RoPD1yZXFMZW5ndGgsXCJieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoXCIpO2Fzc2VydChyZXFMZW5ndGg+MCxcIlJlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMFwiKTt0aGlzLnN0cmlwKCk7dmFyIGxpdHRsZUVuZGlhbj1lbmRpYW49PT1cImxlXCI7dmFyIHJlcz1uZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7dmFyIGIsaTt2YXIgcT10aGlzLmNsb25lKCk7aWYoIWxpdHRsZUVuZGlhbil7Zm9yKGk9MDtpPHJlcUxlbmd0aC1ieXRlTGVuZ3RoO2krKyl7cmVzW2ldPTB9Zm9yKGk9MDshcS5pc1plcm8oKTtpKyspe2I9cS5hbmRsbigyNTUpO3EuaXVzaHJuKDgpO3Jlc1tyZXFMZW5ndGgtaS0xXT1ifX1lbHNle2ZvcihpPTA7IXEuaXNaZXJvKCk7aSsrKXtiPXEuYW5kbG4oMjU1KTtxLml1c2hybig4KTtyZXNbaV09Yn1mb3IoO2k8cmVxTGVuZ3RoO2krKyl7cmVzW2ldPTB9fXJldHVybiByZXN9O2lmKE1hdGguY2x6MzIpe0JOLnByb3RvdHlwZS5fY291bnRCaXRzPWZ1bmN0aW9uIF9jb3VudEJpdHModyl7cmV0dXJuIDMyLU1hdGguY2x6MzIodyl9fWVsc2V7Qk4ucHJvdG90eXBlLl9jb3VudEJpdHM9ZnVuY3Rpb24gX2NvdW50Qml0cyh3KXt2YXIgdD13O3ZhciByPTA7aWYodD49NDA5Nil7cis9MTM7dD4+Pj0xM31pZih0Pj02NCl7cis9Nzt0Pj4+PTd9aWYodD49OCl7cis9NDt0Pj4+PTR9aWYodD49Mil7cis9Mjt0Pj4+PTJ9cmV0dXJuIHIrdH19Qk4ucHJvdG90eXBlLl96ZXJvQml0cz1mdW5jdGlvbiBfemVyb0JpdHModyl7aWYodz09PTApcmV0dXJuIDI2O3ZhciB0PXc7dmFyIHI9MDtpZigodCY4MTkxKT09PTApe3IrPTEzO3Q+Pj49MTN9aWYoKHQmMTI3KT09PTApe3IrPTc7dD4+Pj03fWlmKCh0JjE1KT09PTApe3IrPTQ7dD4+Pj00fWlmKCh0JjMpPT09MCl7cis9Mjt0Pj4+PTJ9aWYoKHQmMSk9PT0wKXtyKyt9cmV0dXJuIHJ9O0JOLnByb3RvdHlwZS5iaXRMZW5ndGg9ZnVuY3Rpb24gYml0TGVuZ3RoKCl7dmFyIHc9dGhpcy53b3Jkc1t0aGlzLmxlbmd0aC0xXTt2YXIgaGk9dGhpcy5fY291bnRCaXRzKHcpO3JldHVybih0aGlzLmxlbmd0aC0xKSoyNitoaX07ZnVuY3Rpb24gdG9CaXRBcnJheShudW0pe3ZhciB3PW5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO2Zvcih2YXIgYml0PTA7Yml0PHcubGVuZ3RoO2JpdCsrKXt2YXIgb2ZmPWJpdC8yNnwwO3ZhciB3Yml0PWJpdCUyNjt3W2JpdF09KG51bS53b3Jkc1tvZmZdJjE8PHdiaXQpPj4+d2JpdH1yZXR1cm4gd31CTi5wcm90b3R5cGUuemVyb0JpdHM9ZnVuY3Rpb24gemVyb0JpdHMoKXtpZih0aGlzLmlzWmVybygpKXJldHVybiAwO3ZhciByPTA7Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3ZhciBiPXRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO3IrPWI7aWYoYiE9PTI2KWJyZWFrfXJldHVybiByfTtCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aD1mdW5jdGlvbiBieXRlTGVuZ3RoKCl7cmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpLzgpfTtCTi5wcm90b3R5cGUudG9Ud29zPWZ1bmN0aW9uIHRvVHdvcyh3aWR0aCl7aWYodGhpcy5uZWdhdGl2ZSE9PTApe3JldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKX1yZXR1cm4gdGhpcy5jbG9uZSgpfTtCTi5wcm90b3R5cGUuZnJvbVR3b3M9ZnVuY3Rpb24gZnJvbVR3b3Mod2lkdGgpe2lmKHRoaXMudGVzdG4od2lkdGgtMSkpe3JldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKX1yZXR1cm4gdGhpcy5jbG9uZSgpfTtCTi5wcm90b3R5cGUuaXNOZWc9ZnVuY3Rpb24gaXNOZWcoKXtyZXR1cm4gdGhpcy5uZWdhdGl2ZSE9PTB9O0JOLnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24gbmVnKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCl9O0JOLnByb3RvdHlwZS5pbmVnPWZ1bmN0aW9uIGluZWcoKXtpZighdGhpcy5pc1plcm8oKSl7dGhpcy5uZWdhdGl2ZV49MX1yZXR1cm4gdGhpc307Qk4ucHJvdG90eXBlLml1b3I9ZnVuY3Rpb24gaXVvcihudW0pe3doaWxlKHRoaXMubGVuZ3RoPG51bS5sZW5ndGgpe3RoaXMud29yZHNbdGhpcy5sZW5ndGgrK109MH1mb3IodmFyIGk9MDtpPG51bS5sZW5ndGg7aSsrKXt0aGlzLndvcmRzW2ldPXRoaXMud29yZHNbaV18bnVtLndvcmRzW2ldfXJldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5pb3I9ZnVuY3Rpb24gaW9yKG51bSl7YXNzZXJ0KCh0aGlzLm5lZ2F0aXZlfG51bS5uZWdhdGl2ZSk9PT0wKTtyZXR1cm4gdGhpcy5pdW9yKG51bSl9O0JOLnByb3RvdHlwZS5vcj1mdW5jdGlvbiBvcihudW0pe2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtyZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpfTtCTi5wcm90b3R5cGUudW9yPWZ1bmN0aW9uIHVvcihudW0pe2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7cmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyl9O0JOLnByb3RvdHlwZS5pdWFuZD1mdW5jdGlvbiBpdWFuZChudW0pe3ZhciBiO2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpe2I9bnVtfWVsc2V7Yj10aGlzfWZvcih2YXIgaT0wO2k8Yi5sZW5ndGg7aSsrKXt0aGlzLndvcmRzW2ldPXRoaXMud29yZHNbaV0mbnVtLndvcmRzW2ldfXRoaXMubGVuZ3RoPWIubGVuZ3RoO3JldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5pYW5kPWZ1bmN0aW9uIGlhbmQobnVtKXthc3NlcnQoKHRoaXMubmVnYXRpdmV8bnVtLm5lZ2F0aXZlKT09PTApO3JldHVybiB0aGlzLml1YW5kKG51bSl9O0JOLnByb3RvdHlwZS5hbmQ9ZnVuY3Rpb24gYW5kKG51bSl7aWYodGhpcy5sZW5ndGg+bnVtLmxlbmd0aClyZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtyZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKX07Qk4ucHJvdG90eXBlLnVhbmQ9ZnVuY3Rpb24gdWFuZChudW0pe2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO3JldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKX07Qk4ucHJvdG90eXBlLml1eG9yPWZ1bmN0aW9uIGl1eG9yKG51bSl7dmFyIGE7dmFyIGI7aWYodGhpcy5sZW5ndGg+bnVtLmxlbmd0aCl7YT10aGlzO2I9bnVtfWVsc2V7YT1udW07Yj10aGlzfWZvcih2YXIgaT0wO2k8Yi5sZW5ndGg7aSsrKXt0aGlzLndvcmRzW2ldPWEud29yZHNbaV1eYi53b3Jkc1tpXX1pZih0aGlzIT09YSl7Zm9yKDtpPGEubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT1hLndvcmRzW2ldfX10aGlzLmxlbmd0aD1hLmxlbmd0aDtyZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuaXhvcj1mdW5jdGlvbiBpeG9yKG51bSl7YXNzZXJ0KCh0aGlzLm5lZ2F0aXZlfG51bS5uZWdhdGl2ZSk9PT0wKTtyZXR1cm4gdGhpcy5pdXhvcihudW0pfTtCTi5wcm90b3R5cGUueG9yPWZ1bmN0aW9uIHhvcihudW0pe2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7cmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyl9O0JOLnByb3RvdHlwZS51eG9yPWZ1bmN0aW9uIHV4b3IobnVtKXtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtyZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyl9O0JOLnByb3RvdHlwZS5pbm90bj1mdW5jdGlvbiBpbm90bih3aWR0aCl7YXNzZXJ0KHR5cGVvZiB3aWR0aD09PVwibnVtYmVyXCImJndpZHRoPj0wKTt2YXIgYnl0ZXNOZWVkZWQ9TWF0aC5jZWlsKHdpZHRoLzI2KXwwO3ZhciBiaXRzTGVmdD13aWR0aCUyNjt0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO2lmKGJpdHNMZWZ0PjApe2J5dGVzTmVlZGVkLS19Zm9yKHZhciBpPTA7aTxieXRlc05lZWRlZDtpKyspe3RoaXMud29yZHNbaV09fnRoaXMud29yZHNbaV0mNjcxMDg4NjN9aWYoYml0c0xlZnQ+MCl7dGhpcy53b3Jkc1tpXT1+dGhpcy53b3Jkc1tpXSY2NzEwODg2Mz4+MjYtYml0c0xlZnR9cmV0dXJuIHRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLm5vdG49ZnVuY3Rpb24gbm90bih3aWR0aCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCl9O0JOLnByb3RvdHlwZS5zZXRuPWZ1bmN0aW9uIHNldG4oYml0LHZhbCl7YXNzZXJ0KHR5cGVvZiBiaXQ9PT1cIm51bWJlclwiJiZiaXQ+PTApO3ZhciBvZmY9Yml0LzI2fDA7dmFyIHdiaXQ9Yml0JTI2O3RoaXMuX2V4cGFuZChvZmYrMSk7aWYodmFsKXt0aGlzLndvcmRzW29mZl09dGhpcy53b3Jkc1tvZmZdfDE8PHdiaXR9ZWxzZXt0aGlzLndvcmRzW29mZl09dGhpcy53b3Jkc1tvZmZdJn4oMTw8d2JpdCl9cmV0dXJuIHRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLmlhZGQ9ZnVuY3Rpb24gaWFkZChudW0pe3ZhciByO2lmKHRoaXMubmVnYXRpdmUhPT0wJiZudW0ubmVnYXRpdmU9PT0wKXt0aGlzLm5lZ2F0aXZlPTA7cj10aGlzLmlzdWIobnVtKTt0aGlzLm5lZ2F0aXZlXj0xO3JldHVybiB0aGlzLl9ub3JtU2lnbigpfWVsc2UgaWYodGhpcy5uZWdhdGl2ZT09PTAmJm51bS5uZWdhdGl2ZSE9PTApe251bS5uZWdhdGl2ZT0wO3I9dGhpcy5pc3ViKG51bSk7bnVtLm5lZ2F0aXZlPTE7cmV0dXJuIHIuX25vcm1TaWduKCl9dmFyIGEsYjtpZih0aGlzLmxlbmd0aD5udW0ubGVuZ3RoKXthPXRoaXM7Yj1udW19ZWxzZXthPW51bTtiPXRoaXN9dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPTA7aTxiLmxlbmd0aDtpKyspe3I9KGEud29yZHNbaV18MCkrKGIud29yZHNbaV18MCkrY2Fycnk7dGhpcy53b3Jkc1tpXT1yJjY3MTA4ODYzO2NhcnJ5PXI+Pj4yNn1mb3IoO2NhcnJ5IT09MCYmaTxhLmxlbmd0aDtpKyspe3I9KGEud29yZHNbaV18MCkrY2Fycnk7dGhpcy53b3Jkc1tpXT1yJjY3MTA4ODYzO2NhcnJ5PXI+Pj4yNn10aGlzLmxlbmd0aD1hLmxlbmd0aDtpZihjYXJyeSE9PTApe3RoaXMud29yZHNbdGhpcy5sZW5ndGhdPWNhcnJ5O3RoaXMubGVuZ3RoKyt9ZWxzZSBpZihhIT09dGhpcyl7Zm9yKDtpPGEubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT1hLndvcmRzW2ldfX1yZXR1cm4gdGhpc307Qk4ucHJvdG90eXBlLmFkZD1mdW5jdGlvbiBhZGQobnVtKXt2YXIgcmVzO2lmKG51bS5uZWdhdGl2ZSE9PTAmJnRoaXMubmVnYXRpdmU9PT0wKXtudW0ubmVnYXRpdmU9MDtyZXM9dGhpcy5zdWIobnVtKTtudW0ubmVnYXRpdmVePTE7cmV0dXJuIHJlc31lbHNlIGlmKG51bS5uZWdhdGl2ZT09PTAmJnRoaXMubmVnYXRpdmUhPT0wKXt0aGlzLm5lZ2F0aXZlPTA7cmVzPW51bS5zdWIodGhpcyk7dGhpcy5uZWdhdGl2ZT0xO3JldHVybiByZXN9aWYodGhpcy5sZW5ndGg+bnVtLmxlbmd0aClyZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtyZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKX07Qk4ucHJvdG90eXBlLmlzdWI9ZnVuY3Rpb24gaXN1YihudW0pe2lmKG51bS5uZWdhdGl2ZSE9PTApe251bS5uZWdhdGl2ZT0wO3ZhciByPXRoaXMuaWFkZChudW0pO251bS5uZWdhdGl2ZT0xO3JldHVybiByLl9ub3JtU2lnbigpfWVsc2UgaWYodGhpcy5uZWdhdGl2ZSE9PTApe3RoaXMubmVnYXRpdmU9MDt0aGlzLmlhZGQobnVtKTt0aGlzLm5lZ2F0aXZlPTE7cmV0dXJuIHRoaXMuX25vcm1TaWduKCl9dmFyIGNtcD10aGlzLmNtcChudW0pO2lmKGNtcD09PTApe3RoaXMubmVnYXRpdmU9MDt0aGlzLmxlbmd0aD0xO3RoaXMud29yZHNbMF09MDtyZXR1cm4gdGhpc312YXIgYSxiO2lmKGNtcD4wKXthPXRoaXM7Yj1udW19ZWxzZXthPW51bTtiPXRoaXN9dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPTA7aTxiLmxlbmd0aDtpKyspe3I9KGEud29yZHNbaV18MCktKGIud29yZHNbaV18MCkrY2Fycnk7Y2Fycnk9cj4+MjY7dGhpcy53b3Jkc1tpXT1yJjY3MTA4ODYzfWZvcig7Y2FycnkhPT0wJiZpPGEubGVuZ3RoO2krKyl7cj0oYS53b3Jkc1tpXXwwKStjYXJyeTtjYXJyeT1yPj4yNjt0aGlzLndvcmRzW2ldPXImNjcxMDg4NjN9aWYoY2Fycnk9PT0wJiZpPGEubGVuZ3RoJiZhIT09dGhpcyl7Zm9yKDtpPGEubGVuZ3RoO2krKyl7dGhpcy53b3Jkc1tpXT1hLndvcmRzW2ldfX10aGlzLmxlbmd0aD1NYXRoLm1heCh0aGlzLmxlbmd0aCxpKTtpZihhIT09dGhpcyl7dGhpcy5uZWdhdGl2ZT0xfXJldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24gc3ViKG51bSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSl9O2Z1bmN0aW9uIHNtYWxsTXVsVG8oc2VsZixudW0sb3V0KXtvdXQubmVnYXRpdmU9bnVtLm5lZ2F0aXZlXnNlbGYubmVnYXRpdmU7dmFyIGxlbj1zZWxmLmxlbmd0aCtudW0ubGVuZ3RofDA7b3V0Lmxlbmd0aD1sZW47bGVuPWxlbi0xfDA7dmFyIGE9c2VsZi53b3Jkc1swXXwwO3ZhciBiPW51bS53b3Jkc1swXXwwO3ZhciByPWEqYjt2YXIgbG89ciY2NzEwODg2Mzt2YXIgY2Fycnk9ci82NzEwODg2NHwwO291dC53b3Jkc1swXT1sbztmb3IodmFyIGs9MTtrPGxlbjtrKyspe3ZhciBuY2Fycnk9Y2Fycnk+Pj4yNjt2YXIgcndvcmQ9Y2FycnkmNjcxMDg4NjM7dmFyIG1heEo9TWF0aC5taW4oayxudW0ubGVuZ3RoLTEpO2Zvcih2YXIgaj1NYXRoLm1heCgwLGstc2VsZi5sZW5ndGgrMSk7ajw9bWF4SjtqKyspe3ZhciBpPWstanwwO2E9c2VsZi53b3Jkc1tpXXwwO2I9bnVtLndvcmRzW2pdfDA7cj1hKmIrcndvcmQ7bmNhcnJ5Kz1yLzY3MTA4ODY0fDA7cndvcmQ9ciY2NzEwODg2M31vdXQud29yZHNba109cndvcmR8MDtjYXJyeT1uY2Fycnl8MH1pZihjYXJyeSE9PTApe291dC53b3Jkc1trXT1jYXJyeXwwfWVsc2V7b3V0Lmxlbmd0aC0tfXJldHVybiBvdXQuc3RyaXAoKX12YXIgY29tYjEwTXVsVG89ZnVuY3Rpb24gY29tYjEwTXVsVG8oc2VsZixudW0sb3V0KXt2YXIgYT1zZWxmLndvcmRzO3ZhciBiPW51bS53b3Jkczt2YXIgbz1vdXQud29yZHM7dmFyIGM9MDt2YXIgbG87dmFyIG1pZDt2YXIgaGk7dmFyIGEwPWFbMF18MDt2YXIgYWwwPWEwJjgxOTE7dmFyIGFoMD1hMD4+PjEzO3ZhciBhMT1hWzFdfDA7dmFyIGFsMT1hMSY4MTkxO3ZhciBhaDE9YTE+Pj4xMzt2YXIgYTI9YVsyXXwwO3ZhciBhbDI9YTImODE5MTt2YXIgYWgyPWEyPj4+MTM7dmFyIGEzPWFbM118MDt2YXIgYWwzPWEzJjgxOTE7dmFyIGFoMz1hMz4+PjEzO3ZhciBhND1hWzRdfDA7dmFyIGFsND1hNCY4MTkxO3ZhciBhaDQ9YTQ+Pj4xMzt2YXIgYTU9YVs1XXwwO3ZhciBhbDU9YTUmODE5MTt2YXIgYWg1PWE1Pj4+MTM7dmFyIGE2PWFbNl18MDt2YXIgYWw2PWE2JjgxOTE7dmFyIGFoNj1hNj4+PjEzO3ZhciBhNz1hWzddfDA7dmFyIGFsNz1hNyY4MTkxO3ZhciBhaDc9YTc+Pj4xMzt2YXIgYTg9YVs4XXwwO3ZhciBhbDg9YTgmODE5MTt2YXIgYWg4PWE4Pj4+MTM7dmFyIGE5PWFbOV18MDt2YXIgYWw5PWE5JjgxOTE7dmFyIGFoOT1hOT4+PjEzO3ZhciBiMD1iWzBdfDA7dmFyIGJsMD1iMCY4MTkxO3ZhciBiaDA9YjA+Pj4xMzt2YXIgYjE9YlsxXXwwO3ZhciBibDE9YjEmODE5MTt2YXIgYmgxPWIxPj4+MTM7dmFyIGIyPWJbMl18MDt2YXIgYmwyPWIyJjgxOTE7dmFyIGJoMj1iMj4+PjEzO3ZhciBiMz1iWzNdfDA7dmFyIGJsMz1iMyY4MTkxO3ZhciBiaDM9YjM+Pj4xMzt2YXIgYjQ9Yls0XXwwO3ZhciBibDQ9YjQmODE5MTt2YXIgYmg0PWI0Pj4+MTM7dmFyIGI1PWJbNV18MDt2YXIgYmw1PWI1JjgxOTE7dmFyIGJoNT1iNT4+PjEzO3ZhciBiNj1iWzZdfDA7dmFyIGJsNj1iNiY4MTkxO3ZhciBiaDY9YjY+Pj4xMzt2YXIgYjc9Yls3XXwwO3ZhciBibDc9YjcmODE5MTt2YXIgYmg3PWI3Pj4+MTM7dmFyIGI4PWJbOF18MDt2YXIgYmw4PWI4JjgxOTE7dmFyIGJoOD1iOD4+PjEzO3ZhciBiOT1iWzldfDA7dmFyIGJsOT1iOSY4MTkxO3ZhciBiaDk9Yjk+Pj4xMztvdXQubmVnYXRpdmU9c2VsZi5uZWdhdGl2ZV5udW0ubmVnYXRpdmU7b3V0Lmxlbmd0aD0xOTtsbz1NYXRoLmltdWwoYWwwLGJsMCk7bWlkPU1hdGguaW11bChhbDAsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDAsYmwwKXwwO2hpPU1hdGguaW11bChhaDAsYmgwKTt2YXIgdzA9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcwPj4+MjYpfDA7dzAmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDEsYmwwKTttaWQ9TWF0aC5pbXVsKGFsMSxiaDApO21pZD1taWQrTWF0aC5pbXVsKGFoMSxibDApfDA7aGk9TWF0aC5pbXVsKGFoMSxiaDApO2xvPWxvK01hdGguaW11bChhbDAsYmwxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMCxiaDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgwLGJsMSl8MDtoaT1oaStNYXRoLmltdWwoYWgwLGJoMSl8MDt2YXIgdzE9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHcxPj4+MjYpfDA7dzEmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDIsYmwwKTttaWQ9TWF0aC5pbXVsKGFsMixiaDApO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDApfDA7aGk9TWF0aC5pbXVsKGFoMixiaDApO2xvPWxvK01hdGguaW11bChhbDEsYmwxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsMSl8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoMSl8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsMil8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmgyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDIpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDIpfDA7dmFyIHcyPShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3Mj4+PjI2KXwwO3cyJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWwzLGJsMCk7bWlkPU1hdGguaW11bChhbDMsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDMsYmwwKXwwO2hpPU1hdGguaW11bChhaDMsYmgwKTtsbz1sbytNYXRoLmltdWwoYWwyLGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDIsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMixiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsMSxibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwxLGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDEsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDEsYmgyKXwwO2xvPWxvK01hdGguaW11bChhbDAsYmwzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMCxiaDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgwLGJsMyl8MDtoaT1oaStNYXRoLmltdWwoYWgwLGJoMyl8MDt2YXIgdzM9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHczPj4+MjYpfDA7dzMmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDQsYmwwKTttaWQ9TWF0aC5pbXVsKGFsNCxiaDApO21pZD1taWQrTWF0aC5pbXVsKGFoNCxibDApfDA7aGk9TWF0aC5pbXVsKGFoNCxiaDApO2xvPWxvK01hdGguaW11bChhbDMsYmwxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMyxiaDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsMSl8MDtoaT1oaStNYXRoLmltdWwoYWgzLGJoMSl8MDtsbz1sbytNYXRoLmltdWwoYWwyLGJsMil8MDttaWQ9bWlkK01hdGguaW11bChhbDIsYmgyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDIpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMixiaDIpfDA7bG89bG8rTWF0aC5pbXVsKGFsMSxibDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwxLGJoMyl8MDttaWQ9bWlkK01hdGguaW11bChhaDEsYmwzKXwwO2hpPWhpK01hdGguaW11bChhaDEsYmgzKXwwO2xvPWxvK01hdGguaW11bChhbDAsYmw0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMCxiaDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgwLGJsNCl8MDtoaT1oaStNYXRoLmltdWwoYWgwLGJoNCl8MDt2YXIgdzQ9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHc0Pj4+MjYpfDA7dzQmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDUsYmwwKTttaWQ9TWF0aC5pbXVsKGFsNSxiaDApO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDApfDA7aGk9TWF0aC5pbXVsKGFoNSxiaDApO2xvPWxvK01hdGguaW11bChhbDQsYmwxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNCxiaDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg0LGJsMSl8MDtoaT1oaStNYXRoLmltdWwoYWg0LGJoMSl8MDtsbz1sbytNYXRoLmltdWwoYWwzLGJsMil8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmgyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDIpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDIpfDA7bG89bG8rTWF0aC5pbXVsKGFsMixibDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoMyl8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmwzKXwwO2hpPWhpK01hdGguaW11bChhaDIsYmgzKXwwO2xvPWxvK01hdGguaW11bChhbDEsYmw0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsNCl8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoNCl8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsNSl8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmg1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDUpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDUpfDA7dmFyIHc1PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3NT4+PjI2KXwwO3c1Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw2LGJsMCk7bWlkPU1hdGguaW11bChhbDYsYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDYsYmwwKXwwO2hpPU1hdGguaW11bChhaDYsYmgwKTtsbz1sbytNYXRoLmltdWwoYWw1LGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsNCxibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw0LGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDQsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDQsYmgyKXwwO2xvPWxvK01hdGguaW11bChhbDMsYmwzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMyxiaDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsMyl8MDtoaT1oaStNYXRoLmltdWwoYWgzLGJoMyl8MDtsbz1sbytNYXRoLmltdWwoYWwyLGJsNCl8MDttaWQ9bWlkK01hdGguaW11bChhbDIsYmg0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDQpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMixiaDQpfDA7bG89bG8rTWF0aC5pbXVsKGFsMSxibDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwxLGJoNSl8MDttaWQ9bWlkK01hdGguaW11bChhaDEsYmw1KXwwO2hpPWhpK01hdGguaW11bChhaDEsYmg1KXwwO2xvPWxvK01hdGguaW11bChhbDAsYmw2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMCxiaDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgwLGJsNil8MDtoaT1oaStNYXRoLmltdWwoYWgwLGJoNil8MDt2YXIgdzY9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHc2Pj4+MjYpfDA7dzYmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDcsYmwwKTttaWQ9TWF0aC5pbXVsKGFsNyxiaDApO21pZD1taWQrTWF0aC5pbXVsKGFoNyxibDApfDA7aGk9TWF0aC5pbXVsKGFoNyxiaDApO2xvPWxvK01hdGguaW11bChhbDYsYmwxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsMSl8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoMSl8MDtsbz1sbytNYXRoLmltdWwoYWw1LGJsMil8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmgyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDIpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDIpfDA7bG89bG8rTWF0aC5pbXVsKGFsNCxibDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw0LGJoMyl8MDttaWQ9bWlkK01hdGguaW11bChhaDQsYmwzKXwwO2hpPWhpK01hdGguaW11bChhaDQsYmgzKXwwO2xvPWxvK01hdGguaW11bChhbDMsYmw0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMyxiaDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsNCl8MDtoaT1oaStNYXRoLmltdWwoYWgzLGJoNCl8MDtsbz1sbytNYXRoLmltdWwoYWwyLGJsNSl8MDttaWQ9bWlkK01hdGguaW11bChhbDIsYmg1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDUpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMixiaDUpfDA7bG89bG8rTWF0aC5pbXVsKGFsMSxibDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwxLGJoNil8MDttaWQ9bWlkK01hdGguaW11bChhaDEsYmw2KXwwO2hpPWhpK01hdGguaW11bChhaDEsYmg2KXwwO2xvPWxvK01hdGguaW11bChhbDAsYmw3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMCxiaDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgwLGJsNyl8MDtoaT1oaStNYXRoLmltdWwoYWgwLGJoNyl8MDt2YXIgdzc9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHc3Pj4+MjYpfDA7dzcmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDgsYmwwKTttaWQ9TWF0aC5pbXVsKGFsOCxiaDApO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDApfDA7aGk9TWF0aC5pbXVsKGFoOCxiaDApO2xvPWxvK01hdGguaW11bChhbDcsYmwxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNyxiaDEpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg3LGJsMSl8MDtoaT1oaStNYXRoLmltdWwoYWg3LGJoMSl8MDtsbz1sbytNYXRoLmltdWwoYWw2LGJsMil8MDttaWQ9bWlkK01hdGguaW11bChhbDYsYmgyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNixibDIpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNixiaDIpfDA7bG89bG8rTWF0aC5pbXVsKGFsNSxibDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw1LGJoMyl8MDttaWQ9bWlkK01hdGguaW11bChhaDUsYmwzKXwwO2hpPWhpK01hdGguaW11bChhaDUsYmgzKXwwO2xvPWxvK01hdGguaW11bChhbDQsYmw0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNCxiaDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg0LGJsNCl8MDtoaT1oaStNYXRoLmltdWwoYWg0LGJoNCl8MDtsbz1sbytNYXRoLmltdWwoYWwzLGJsNSl8MDttaWQ9bWlkK01hdGguaW11bChhbDMsYmg1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMyxibDUpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMyxiaDUpfDA7bG89bG8rTWF0aC5pbXVsKGFsMixibDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwyLGJoNil8MDttaWQ9bWlkK01hdGguaW11bChhaDIsYmw2KXwwO2hpPWhpK01hdGguaW11bChhaDIsYmg2KXwwO2xvPWxvK01hdGguaW11bChhbDEsYmw3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMSxiaDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgxLGJsNyl8MDtoaT1oaStNYXRoLmltdWwoYWgxLGJoNyl8MDtsbz1sbytNYXRoLmltdWwoYWwwLGJsOCl8MDttaWQ9bWlkK01hdGguaW11bChhbDAsYmg4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMCxibDgpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMCxiaDgpfDA7dmFyIHc4PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3OD4+PjI2KXwwO3c4Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsMCk7bWlkPU1hdGguaW11bChhbDksYmgwKTttaWQ9bWlkK01hdGguaW11bChhaDksYmwwKXwwO2hpPU1hdGguaW11bChhaDksYmgwKTtsbz1sbytNYXRoLmltdWwoYWw4LGJsMSl8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmgxKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDEpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDEpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoMil8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmwyKXwwO2hpPWhpK01hdGguaW11bChhaDcsYmgyKXwwO2xvPWxvK01hdGguaW11bChhbDYsYmwzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDMpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsMyl8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoMyl8MDtsbz1sbytNYXRoLmltdWwoYWw1LGJsNCl8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmg0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDQpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDQpfDA7bG89bG8rTWF0aC5pbXVsKGFsNCxibDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw0LGJoNSl8MDttaWQ9bWlkK01hdGguaW11bChhaDQsYmw1KXwwO2hpPWhpK01hdGguaW11bChhaDQsYmg1KXwwO2xvPWxvK01hdGguaW11bChhbDMsYmw2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMyxiaDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsNil8MDtoaT1oaStNYXRoLmltdWwoYWgzLGJoNil8MDtsbz1sbytNYXRoLmltdWwoYWwyLGJsNyl8MDttaWQ9bWlkK01hdGguaW11bChhbDIsYmg3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDcpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMixiaDcpfDA7bG89bG8rTWF0aC5pbXVsKGFsMSxibDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwxLGJoOCl8MDttaWQ9bWlkK01hdGguaW11bChhaDEsYmw4KXwwO2hpPWhpK01hdGguaW11bChhaDEsYmg4KXwwO2xvPWxvK01hdGguaW11bChhbDAsYmw5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMCxiaDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgwLGJsOSl8MDtoaT1oaStNYXRoLmltdWwoYWgwLGJoOSl8MDt2YXIgdzk9KGMrbG98MCkrKChtaWQmODE5MSk8PDEzKXwwO2M9KGhpKyhtaWQ+Pj4xMyl8MCkrKHc5Pj4+MjYpfDA7dzkmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDksYmwxKTttaWQ9TWF0aC5pbXVsKGFsOSxiaDEpO21pZD1taWQrTWF0aC5pbXVsKGFoOSxibDEpfDA7aGk9TWF0aC5pbXVsKGFoOSxiaDEpO2xvPWxvK01hdGguaW11bChhbDgsYmwyKXwwO21pZD1taWQrTWF0aC5pbXVsKGFsOCxiaDIpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg4LGJsMil8MDtoaT1oaStNYXRoLmltdWwoYWg4LGJoMil8MDtsbz1sbytNYXRoLmltdWwoYWw3LGJsMyl8MDttaWQ9bWlkK01hdGguaW11bChhbDcsYmgzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNyxibDMpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNyxiaDMpfDA7bG89bG8rTWF0aC5pbXVsKGFsNixibDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw2LGJoNCl8MDttaWQ9bWlkK01hdGguaW11bChhaDYsYmw0KXwwO2hpPWhpK01hdGguaW11bChhaDYsYmg0KXwwO2xvPWxvK01hdGguaW11bChhbDUsYmw1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNSxiaDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg1LGJsNSl8MDtoaT1oaStNYXRoLmltdWwoYWg1LGJoNSl8MDtsbz1sbytNYXRoLmltdWwoYWw0LGJsNil8MDttaWQ9bWlkK01hdGguaW11bChhbDQsYmg2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNCxibDYpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNCxiaDYpfDA7bG89bG8rTWF0aC5pbXVsKGFsMyxibDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWwzLGJoNyl8MDttaWQ9bWlkK01hdGguaW11bChhaDMsYmw3KXwwO2hpPWhpK01hdGguaW11bChhaDMsYmg3KXwwO2xvPWxvK01hdGguaW11bChhbDIsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMixiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgyLGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWgyLGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWwxLGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDEsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMSxibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMSxiaDkpfDA7dmFyIHcxMD0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzEwPj4+MjYpfDA7dzEwJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsMik7bWlkPU1hdGguaW11bChhbDksYmgyKTttaWQ9bWlkK01hdGguaW11bChhaDksYmwyKXwwO2hpPU1hdGguaW11bChhaDksYmgyKTtsbz1sbytNYXRoLmltdWwoYWw4LGJsMyl8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmgzKXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDMpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDMpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDQpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoNCl8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmw0KXwwO2hpPWhpK01hdGguaW11bChhaDcsYmg0KXwwO2xvPWxvK01hdGguaW11bChhbDYsYmw1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsNSl8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoNSl8MDtsbz1sbytNYXRoLmltdWwoYWw1LGJsNil8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmg2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDYpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDYpfDA7bG89bG8rTWF0aC5pbXVsKGFsNCxibDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw0LGJoNyl8MDttaWQ9bWlkK01hdGguaW11bChhaDQsYmw3KXwwO2hpPWhpK01hdGguaW11bChhaDQsYmg3KXwwO2xvPWxvK01hdGguaW11bChhbDMsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMyxiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWgzLGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWwyLGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDIsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoMixibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoMixiaDkpfDA7dmFyIHcxMT0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzExPj4+MjYpfDA7dzExJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsMyk7bWlkPU1hdGguaW11bChhbDksYmgzKTttaWQ9bWlkK01hdGguaW11bChhaDksYmwzKXwwO2hpPU1hdGguaW11bChhaDksYmgzKTtsbz1sbytNYXRoLmltdWwoYWw4LGJsNCl8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmg0KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDQpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDQpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoNSl8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmw1KXwwO2hpPWhpK01hdGguaW11bChhaDcsYmg1KXwwO2xvPWxvK01hdGguaW11bChhbDYsYmw2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDYpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsNil8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoNil8MDtsbz1sbytNYXRoLmltdWwoYWw1LGJsNyl8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmg3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDcpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDcpfDA7bG89bG8rTWF0aC5pbXVsKGFsNCxibDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw0LGJoOCl8MDttaWQ9bWlkK01hdGguaW11bChhaDQsYmw4KXwwO2hpPWhpK01hdGguaW11bChhaDQsYmg4KXwwO2xvPWxvK01hdGguaW11bChhbDMsYmw5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsMyxiaDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWgzLGJsOSl8MDtoaT1oaStNYXRoLmltdWwoYWgzLGJoOSl8MDt2YXIgdzEyPShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3MTI+Pj4yNil8MDt3MTImPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDksYmw0KTttaWQ9TWF0aC5pbXVsKGFsOSxiaDQpO21pZD1taWQrTWF0aC5pbXVsKGFoOSxibDQpfDA7aGk9TWF0aC5pbXVsKGFoOSxiaDQpO2xvPWxvK01hdGguaW11bChhbDgsYmw1KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsOCxiaDUpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg4LGJsNSl8MDtoaT1oaStNYXRoLmltdWwoYWg4LGJoNSl8MDtsbz1sbytNYXRoLmltdWwoYWw3LGJsNil8MDttaWQ9bWlkK01hdGguaW11bChhbDcsYmg2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNyxibDYpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNyxiaDYpfDA7bG89bG8rTWF0aC5pbXVsKGFsNixibDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw2LGJoNyl8MDttaWQ9bWlkK01hdGguaW11bChhaDYsYmw3KXwwO2hpPWhpK01hdGguaW11bChhaDYsYmg3KXwwO2xvPWxvK01hdGguaW11bChhbDUsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNSxiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg1LGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWg1LGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWw0LGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDQsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNCxibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNCxiaDkpfDA7dmFyIHcxMz0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzEzPj4+MjYpfDA7dzEzJj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsNSk7bWlkPU1hdGguaW11bChhbDksYmg1KTttaWQ9bWlkK01hdGguaW11bChhaDksYmw1KXwwO2hpPU1hdGguaW11bChhaDksYmg1KTtsbz1sbytNYXRoLmltdWwoYWw4LGJsNil8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmg2KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDYpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDYpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDcpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoNyl8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmw3KXwwO2hpPWhpK01hdGguaW11bChhaDcsYmg3KXwwO2xvPWxvK01hdGguaW11bChhbDYsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWw1LGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDUsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNSxibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNSxiaDkpfDA7dmFyIHcxND0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzE0Pj4+MjYpfDA7dzE0Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsNik7bWlkPU1hdGguaW11bChhbDksYmg2KTttaWQ9bWlkK01hdGguaW11bChhaDksYmw2KXwwO2hpPU1hdGguaW11bChhaDksYmg2KTtsbz1sbytNYXRoLmltdWwoYWw4LGJsNyl8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmg3KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDcpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDcpfDA7bG89bG8rTWF0aC5pbXVsKGFsNyxibDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWw3LGJoOCl8MDttaWQ9bWlkK01hdGguaW11bChhaDcsYmw4KXwwO2hpPWhpK01hdGguaW11bChhaDcsYmg4KXwwO2xvPWxvK01hdGguaW11bChhbDYsYmw5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsNixiaDkpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg2LGJsOSl8MDtoaT1oaStNYXRoLmltdWwoYWg2LGJoOSl8MDt2YXIgdzE1PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3MTU+Pj4yNil8MDt3MTUmPTY3MTA4ODYzO2xvPU1hdGguaW11bChhbDksYmw3KTttaWQ9TWF0aC5pbXVsKGFsOSxiaDcpO21pZD1taWQrTWF0aC5pbXVsKGFoOSxibDcpfDA7aGk9TWF0aC5pbXVsKGFoOSxiaDcpO2xvPWxvK01hdGguaW11bChhbDgsYmw4KXwwO21pZD1taWQrTWF0aC5pbXVsKGFsOCxiaDgpfDA7bWlkPW1pZCtNYXRoLmltdWwoYWg4LGJsOCl8MDtoaT1oaStNYXRoLmltdWwoYWg4LGJoOCl8MDtsbz1sbytNYXRoLmltdWwoYWw3LGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDcsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoNyxibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoNyxiaDkpfDA7dmFyIHcxNj0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzE2Pj4+MjYpfDA7dzE2Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsOCk7bWlkPU1hdGguaW11bChhbDksYmg4KTttaWQ9bWlkK01hdGguaW11bChhaDksYmw4KXwwO2hpPU1hdGguaW11bChhaDksYmg4KTtsbz1sbytNYXRoLmltdWwoYWw4LGJsOSl8MDttaWQ9bWlkK01hdGguaW11bChhbDgsYmg5KXwwO21pZD1taWQrTWF0aC5pbXVsKGFoOCxibDkpfDA7aGk9aGkrTWF0aC5pbXVsKGFoOCxiaDkpfDA7dmFyIHcxNz0oYytsb3wwKSsoKG1pZCY4MTkxKTw8MTMpfDA7Yz0oaGkrKG1pZD4+PjEzKXwwKSsodzE3Pj4+MjYpfDA7dzE3Jj02NzEwODg2Mztsbz1NYXRoLmltdWwoYWw5LGJsOSk7bWlkPU1hdGguaW11bChhbDksYmg5KTttaWQ9bWlkK01hdGguaW11bChhaDksYmw5KXwwO2hpPU1hdGguaW11bChhaDksYmg5KTt2YXIgdzE4PShjK2xvfDApKygobWlkJjgxOTEpPDwxMyl8MDtjPShoaSsobWlkPj4+MTMpfDApKyh3MTg+Pj4yNil8MDt3MTgmPTY3MTA4ODYzO29bMF09dzA7b1sxXT13MTtvWzJdPXcyO29bM109dzM7b1s0XT13NDtvWzVdPXc1O29bNl09dzY7b1s3XT13NztvWzhdPXc4O29bOV09dzk7b1sxMF09dzEwO29bMTFdPXcxMTtvWzEyXT13MTI7b1sxM109dzEzO29bMTRdPXcxNDtvWzE1XT13MTU7b1sxNl09dzE2O29bMTddPXcxNztvWzE4XT13MTg7aWYoYyE9PTApe29bMTldPWM7b3V0Lmxlbmd0aCsrfXJldHVybiBvdXR9O2lmKCFNYXRoLmltdWwpe2NvbWIxME11bFRvPXNtYWxsTXVsVG99ZnVuY3Rpb24gYmlnTXVsVG8oc2VsZixudW0sb3V0KXtvdXQubmVnYXRpdmU9bnVtLm5lZ2F0aXZlXnNlbGYubmVnYXRpdmU7b3V0Lmxlbmd0aD1zZWxmLmxlbmd0aCtudW0ubGVuZ3RoO3ZhciBjYXJyeT0wO3ZhciBobmNhcnJ5PTA7Zm9yKHZhciBrPTA7azxvdXQubGVuZ3RoLTE7aysrKXt2YXIgbmNhcnJ5PWhuY2Fycnk7aG5jYXJyeT0wO3ZhciByd29yZD1jYXJyeSY2NzEwODg2Mzt2YXIgbWF4Sj1NYXRoLm1pbihrLG51bS5sZW5ndGgtMSk7Zm9yKHZhciBqPU1hdGgubWF4KDAsay1zZWxmLmxlbmd0aCsxKTtqPD1tYXhKO2orKyl7dmFyIGk9ay1qO3ZhciBhPXNlbGYud29yZHNbaV18MDt2YXIgYj1udW0ud29yZHNbal18MDt2YXIgcj1hKmI7dmFyIGxvPXImNjcxMDg4NjM7bmNhcnJ5PW5jYXJyeSsoci82NzEwODg2NHwwKXwwO2xvPWxvK3J3b3JkfDA7cndvcmQ9bG8mNjcxMDg4NjM7bmNhcnJ5PW5jYXJyeSsobG8+Pj4yNil8MDtobmNhcnJ5Kz1uY2Fycnk+Pj4yNjtuY2FycnkmPTY3MTA4ODYzfW91dC53b3Jkc1trXT1yd29yZDtjYXJyeT1uY2Fycnk7bmNhcnJ5PWhuY2Fycnl9aWYoY2FycnkhPT0wKXtvdXQud29yZHNba109Y2Fycnl9ZWxzZXtvdXQubGVuZ3RoLS19cmV0dXJuIG91dC5zdHJpcCgpfWZ1bmN0aW9uIGp1bWJvTXVsVG8oc2VsZixudW0sb3V0KXt2YXIgZmZ0bT1uZXcgRkZUTTtyZXR1cm4gZmZ0bS5tdWxwKHNlbGYsbnVtLG91dCl9Qk4ucHJvdG90eXBlLm11bFRvPWZ1bmN0aW9uIG11bFRvKG51bSxvdXQpe3ZhciByZXM7dmFyIGxlbj10aGlzLmxlbmd0aCtudW0ubGVuZ3RoO2lmKHRoaXMubGVuZ3RoPT09MTAmJm51bS5sZW5ndGg9PT0xMCl7cmVzPWNvbWIxME11bFRvKHRoaXMsbnVtLG91dCl9ZWxzZSBpZihsZW48NjMpe3Jlcz1zbWFsbE11bFRvKHRoaXMsbnVtLG91dCl9ZWxzZSBpZihsZW48MTAyNCl7cmVzPWJpZ011bFRvKHRoaXMsbnVtLG91dCl9ZWxzZXtyZXM9anVtYm9NdWxUbyh0aGlzLG51bSxvdXQpfXJldHVybiByZXN9O2Z1bmN0aW9uIEZGVE0oeCx5KXt0aGlzLng9eDt0aGlzLnk9eX1GRlRNLnByb3RvdHlwZS5tYWtlUkJUPWZ1bmN0aW9uIG1ha2VSQlQoTil7dmFyIHQ9bmV3IEFycmF5KE4pO3ZhciBsPUJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pLTE7Zm9yKHZhciBpPTA7aTxOO2krKyl7dFtpXT10aGlzLnJldkJpbihpLGwsTil9cmV0dXJuIHR9O0ZGVE0ucHJvdG90eXBlLnJldkJpbj1mdW5jdGlvbiByZXZCaW4oeCxsLE4pe2lmKHg9PT0wfHx4PT09Ti0xKXJldHVybiB4O3ZhciByYj0wO2Zvcih2YXIgaT0wO2k8bDtpKyspe3JifD0oeCYxKTw8bC1pLTE7eD4+PTF9cmV0dXJuIHJifTtGRlRNLnByb3RvdHlwZS5wZXJtdXRlPWZ1bmN0aW9uIHBlcm11dGUocmJ0LHJ3cyxpd3MscnR3cyxpdHdzLE4pe2Zvcih2YXIgaT0wO2k8TjtpKyspe3J0d3NbaV09cndzW3JidFtpXV07aXR3c1tpXT1pd3NbcmJ0W2ldXX19O0ZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbiB0cmFuc2Zvcm0ocndzLGl3cyxydHdzLGl0d3MsTixyYnQpe3RoaXMucGVybXV0ZShyYnQscndzLGl3cyxydHdzLGl0d3MsTik7Zm9yKHZhciBzPTE7czxOO3M8PD0xKXt2YXIgbD1zPDwxO3ZhciBydHdkZj1NYXRoLmNvcygyKk1hdGguUEkvbCk7dmFyIGl0d2RmPU1hdGguc2luKDIqTWF0aC5QSS9sKTtmb3IodmFyIHA9MDtwPE47cCs9bCl7dmFyIHJ0d2RmXz1ydHdkZjt2YXIgaXR3ZGZfPWl0d2RmO2Zvcih2YXIgaj0wO2o8cztqKyspe3ZhciByZT1ydHdzW3Aral07dmFyIGllPWl0d3NbcCtqXTt2YXIgcm89cnR3c1twK2orc107dmFyIGlvPWl0d3NbcCtqK3NdO3ZhciByeD1ydHdkZl8qcm8taXR3ZGZfKmlvO2lvPXJ0d2RmXyppbytpdHdkZl8qcm87cm89cng7cnR3c1twK2pdPXJlK3JvO2l0d3NbcCtqXT1pZStpbztydHdzW3AraitzXT1yZS1ybztpdHdzW3AraitzXT1pZS1pbztpZihqIT09bCl7cng9cnR3ZGYqcnR3ZGZfLWl0d2RmKml0d2RmXztpdHdkZl89cnR3ZGYqaXR3ZGZfK2l0d2RmKnJ0d2RmXztydHdkZl89cnh9fX19fTtGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYj1mdW5jdGlvbiBndWVzc0xlbjEzYihuLG0pe3ZhciBOPU1hdGgubWF4KG0sbil8MTt2YXIgb2RkPU4mMTt2YXIgaT0wO2ZvcihOPU4vMnwwO047Tj1OPj4+MSl7aSsrfXJldHVybiAxPDxpKzErb2RkfTtGRlRNLnByb3RvdHlwZS5jb25qdWdhdGU9ZnVuY3Rpb24gY29uanVnYXRlKHJ3cyxpd3MsTil7aWYoTjw9MSlyZXR1cm47Zm9yKHZhciBpPTA7aTxOLzI7aSsrKXt2YXIgdD1yd3NbaV07cndzW2ldPXJ3c1tOLWktMV07cndzW04taS0xXT10O3Q9aXdzW2ldO2l3c1tpXT0taXdzW04taS0xXTtpd3NbTi1pLTFdPS10fX07RkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiPWZ1bmN0aW9uIG5vcm1hbGl6ZTEzYih3cyxOKXt2YXIgY2Fycnk9MDtmb3IodmFyIGk9MDtpPE4vMjtpKyspe3ZhciB3PU1hdGgucm91bmQod3NbMippKzFdL04pKjgxOTIrTWF0aC5yb3VuZCh3c1syKmldL04pK2NhcnJ5O3dzW2ldPXcmNjcxMDg4NjM7aWYodzw2NzEwODg2NCl7Y2Fycnk9MH1lbHNle2NhcnJ5PXcvNjcxMDg4NjR8MH19cmV0dXJuIHdzfTtGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiPWZ1bmN0aW9uIGNvbnZlcnQxM2Iod3MsbGVuLHJ3cyxOKXt2YXIgY2Fycnk9MDtmb3IodmFyIGk9MDtpPGxlbjtpKyspe2NhcnJ5PWNhcnJ5Kyh3c1tpXXwwKTtyd3NbMippXT1jYXJyeSY4MTkxO2NhcnJ5PWNhcnJ5Pj4+MTM7cndzWzIqaSsxXT1jYXJyeSY4MTkxO2NhcnJ5PWNhcnJ5Pj4+MTN9Zm9yKGk9MipsZW47aTxOOysraSl7cndzW2ldPTB9YXNzZXJ0KGNhcnJ5PT09MCk7YXNzZXJ0KChjYXJyeSZ+ODE5MSk9PT0wKX07RkZUTS5wcm90b3R5cGUuc3R1Yj1mdW5jdGlvbiBzdHViKE4pe3ZhciBwaD1uZXcgQXJyYXkoTik7Zm9yKHZhciBpPTA7aTxOO2krKyl7cGhbaV09MH1yZXR1cm4gcGh9O0ZGVE0ucHJvdG90eXBlLm11bHA9ZnVuY3Rpb24gbXVscCh4LHksb3V0KXt2YXIgTj0yKnRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgseS5sZW5ndGgpO3ZhciByYnQ9dGhpcy5tYWtlUkJUKE4pO3ZhciBfPXRoaXMuc3R1YihOKTt2YXIgcndzPW5ldyBBcnJheShOKTt2YXIgcndzdD1uZXcgQXJyYXkoTik7dmFyIGl3c3Q9bmV3IEFycmF5KE4pO3ZhciBucndzPW5ldyBBcnJheShOKTt2YXIgbnJ3c3Q9bmV3IEFycmF5KE4pO3ZhciBuaXdzdD1uZXcgQXJyYXkoTik7dmFyIHJtd3M9b3V0LndvcmRzO3Jtd3MubGVuZ3RoPU47dGhpcy5jb252ZXJ0MTNiKHgud29yZHMseC5sZW5ndGgscndzLE4pO3RoaXMuY29udmVydDEzYih5LndvcmRzLHkubGVuZ3RoLG5yd3MsTik7dGhpcy50cmFuc2Zvcm0ocndzLF8scndzdCxpd3N0LE4scmJ0KTt0aGlzLnRyYW5zZm9ybShucndzLF8sbnJ3c3Qsbml3c3QsTixyYnQpO2Zvcih2YXIgaT0wO2k8TjtpKyspe3ZhciByeD1yd3N0W2ldKm5yd3N0W2ldLWl3c3RbaV0qbml3c3RbaV07aXdzdFtpXT1yd3N0W2ldKm5pd3N0W2ldK2l3c3RbaV0qbnJ3c3RbaV07cndzdFtpXT1yeH10aGlzLmNvbmp1Z2F0ZShyd3N0LGl3c3QsTik7dGhpcy50cmFuc2Zvcm0ocndzdCxpd3N0LHJtd3MsXyxOLHJidCk7dGhpcy5jb25qdWdhdGUocm13cyxfLE4pO3RoaXMubm9ybWFsaXplMTNiKHJtd3MsTik7b3V0Lm5lZ2F0aXZlPXgubmVnYXRpdmVeeS5uZWdhdGl2ZTtvdXQubGVuZ3RoPXgubGVuZ3RoK3kubGVuZ3RoO3JldHVybiBvdXQuc3RyaXAoKX07Qk4ucHJvdG90eXBlLm11bD1mdW5jdGlvbiBtdWwobnVtKXt2YXIgb3V0PW5ldyBCTihudWxsKTtvdXQud29yZHM9bmV3IEFycmF5KHRoaXMubGVuZ3RoK251bS5sZW5ndGgpO3JldHVybiB0aGlzLm11bFRvKG51bSxvdXQpfTtCTi5wcm90b3R5cGUubXVsZj1mdW5jdGlvbiBtdWxmKG51bSl7dmFyIG91dD1uZXcgQk4obnVsbCk7b3V0LndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCtudW0ubGVuZ3RoKTtyZXR1cm4ganVtYm9NdWxUbyh0aGlzLG51bSxvdXQpfTtCTi5wcm90b3R5cGUuaW11bD1mdW5jdGlvbiBpbXVsKG51bSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sdGhpcyl9O0JOLnByb3RvdHlwZS5pbXVsbj1mdW5jdGlvbiBpbXVsbihudW0pe2Fzc2VydCh0eXBlb2YgbnVtPT09XCJudW1iZXJcIik7YXNzZXJ0KG51bTw2NzEwODg2NCk7dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3ZhciB3PSh0aGlzLndvcmRzW2ldfDApKm51bTt2YXIgbG89KHcmNjcxMDg4NjMpKyhjYXJyeSY2NzEwODg2Myk7Y2Fycnk+Pj0yNjtjYXJyeSs9dy82NzEwODg2NHwwO2NhcnJ5Kz1sbz4+PjI2O3RoaXMud29yZHNbaV09bG8mNjcxMDg4NjN9aWYoY2FycnkhPT0wKXt0aGlzLndvcmRzW2ldPWNhcnJ5O3RoaXMubGVuZ3RoKyt9cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5tdWxuPWZ1bmN0aW9uIG11bG4obnVtKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSl9O0JOLnByb3RvdHlwZS5zcXI9ZnVuY3Rpb24gc3FyKCl7cmV0dXJuIHRoaXMubXVsKHRoaXMpfTtCTi5wcm90b3R5cGUuaXNxcj1mdW5jdGlvbiBpc3FyKCl7cmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpfTtCTi5wcm90b3R5cGUucG93PWZ1bmN0aW9uIHBvdyhudW0pe3ZhciB3PXRvQml0QXJyYXkobnVtKTtpZih3Lmxlbmd0aD09PTApcmV0dXJuIG5ldyBCTigxKTt2YXIgcmVzPXRoaXM7Zm9yKHZhciBpPTA7aTx3Lmxlbmd0aDtpKysscmVzPXJlcy5zcXIoKSl7aWYod1tpXSE9PTApYnJlYWt9aWYoKytpPHcubGVuZ3RoKXtmb3IodmFyIHE9cmVzLnNxcigpO2k8dy5sZW5ndGg7aSsrLHE9cS5zcXIoKSl7aWYod1tpXT09PTApY29udGludWU7cmVzPXJlcy5tdWwocSl9fXJldHVybiByZXN9O0JOLnByb3RvdHlwZS5pdXNobG49ZnVuY3Rpb24gaXVzaGxuKGJpdHMpe2Fzc2VydCh0eXBlb2YgYml0cz09PVwibnVtYmVyXCImJmJpdHM+PTApO3ZhciByPWJpdHMlMjY7dmFyIHM9KGJpdHMtcikvMjY7dmFyIGNhcnJ5TWFzaz02NzEwODg2Mz4+PjI2LXI8PDI2LXI7dmFyIGk7aWYociE9PTApe3ZhciBjYXJyeT0wO2ZvcihpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3ZhciBuZXdDYXJyeT10aGlzLndvcmRzW2ldJmNhcnJ5TWFzazt2YXIgYz0odGhpcy53b3Jkc1tpXXwwKS1uZXdDYXJyeTw8cjt0aGlzLndvcmRzW2ldPWN8Y2Fycnk7Y2Fycnk9bmV3Q2Fycnk+Pj4yNi1yfWlmKGNhcnJ5KXt0aGlzLndvcmRzW2ldPWNhcnJ5O3RoaXMubGVuZ3RoKyt9fWlmKHMhPT0wKXtmb3IoaT10aGlzLmxlbmd0aC0xO2k+PTA7aS0tKXt0aGlzLndvcmRzW2krc109dGhpcy53b3Jkc1tpXX1mb3IoaT0wO2k8cztpKyspe3RoaXMud29yZHNbaV09MH10aGlzLmxlbmd0aCs9c31yZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuaXNobG49ZnVuY3Rpb24gaXNobG4oYml0cyl7YXNzZXJ0KHRoaXMubmVnYXRpdmU9PT0wKTtyZXR1cm4gdGhpcy5pdXNobG4oYml0cyl9O0JOLnByb3RvdHlwZS5pdXNocm49ZnVuY3Rpb24gaXVzaHJuKGJpdHMsaGludCxleHRlbmRlZCl7YXNzZXJ0KHR5cGVvZiBiaXRzPT09XCJudW1iZXJcIiYmYml0cz49MCk7dmFyIGg7aWYoaGludCl7aD0oaGludC1oaW50JTI2KS8yNn1lbHNle2g9MH12YXIgcj1iaXRzJTI2O3ZhciBzPU1hdGgubWluKChiaXRzLXIpLzI2LHRoaXMubGVuZ3RoKTt2YXIgbWFzaz02NzEwODg2M142NzEwODg2Mz4+PnI8PHI7dmFyIG1hc2tlZFdvcmRzPWV4dGVuZGVkO2gtPXM7aD1NYXRoLm1heCgwLGgpO2lmKG1hc2tlZFdvcmRzKXtmb3IodmFyIGk9MDtpPHM7aSsrKXttYXNrZWRXb3Jkcy53b3Jkc1tpXT10aGlzLndvcmRzW2ldfW1hc2tlZFdvcmRzLmxlbmd0aD1zfWlmKHM9PT0wKXt9ZWxzZSBpZih0aGlzLmxlbmd0aD5zKXt0aGlzLmxlbmd0aC09cztmb3IoaT0wO2k8dGhpcy5sZW5ndGg7aSsrKXt0aGlzLndvcmRzW2ldPXRoaXMud29yZHNbaStzXX19ZWxzZXt0aGlzLndvcmRzWzBdPTA7dGhpcy5sZW5ndGg9MX12YXIgY2Fycnk9MDtmb3IoaT10aGlzLmxlbmd0aC0xO2k+PTAmJihjYXJyeSE9PTB8fGk+PWgpO2ktLSl7dmFyIHdvcmQ9dGhpcy53b3Jkc1tpXXwwO3RoaXMud29yZHNbaV09Y2Fycnk8PDI2LXJ8d29yZD4+PnI7Y2Fycnk9d29yZCZtYXNrfWlmKG1hc2tlZFdvcmRzJiZjYXJyeSE9PTApe21hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXT1jYXJyeX1pZih0aGlzLmxlbmd0aD09PTApe3RoaXMud29yZHNbMF09MDt0aGlzLmxlbmd0aD0xfXJldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5pc2hybj1mdW5jdGlvbiBpc2hybihiaXRzLGhpbnQsZXh0ZW5kZWQpe2Fzc2VydCh0aGlzLm5lZ2F0aXZlPT09MCk7cmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsaGludCxleHRlbmRlZCl9O0JOLnByb3RvdHlwZS5zaGxuPWZ1bmN0aW9uIHNobG4oYml0cyl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKX07Qk4ucHJvdG90eXBlLnVzaGxuPWZ1bmN0aW9uIHVzaGxuKGJpdHMpe3JldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpfTtCTi5wcm90b3R5cGUuc2hybj1mdW5jdGlvbiBzaHJuKGJpdHMpe3JldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyl9O0JOLnByb3RvdHlwZS51c2hybj1mdW5jdGlvbiB1c2hybihiaXRzKXtyZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKX07Qk4ucHJvdG90eXBlLnRlc3RuPWZ1bmN0aW9uIHRlc3RuKGJpdCl7YXNzZXJ0KHR5cGVvZiBiaXQ9PT1cIm51bWJlclwiJiZiaXQ+PTApO3ZhciByPWJpdCUyNjt2YXIgcz0oYml0LXIpLzI2O3ZhciBxPTE8PHI7aWYodGhpcy5sZW5ndGg8PXMpcmV0dXJuIGZhbHNlO3ZhciB3PXRoaXMud29yZHNbc107cmV0dXJuISEodyZxKX07Qk4ucHJvdG90eXBlLmltYXNrbj1mdW5jdGlvbiBpbWFza24oYml0cyl7YXNzZXJ0KHR5cGVvZiBiaXRzPT09XCJudW1iZXJcIiYmYml0cz49MCk7dmFyIHI9Yml0cyUyNjt2YXIgcz0oYml0cy1yKS8yNjthc3NlcnQodGhpcy5uZWdhdGl2ZT09PTAsXCJpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnNcIik7aWYodGhpcy5sZW5ndGg8PXMpe3JldHVybiB0aGlzfWlmKHIhPT0wKXtzKyt9dGhpcy5sZW5ndGg9TWF0aC5taW4ocyx0aGlzLmxlbmd0aCk7aWYociE9PTApe3ZhciBtYXNrPTY3MTA4ODYzXjY3MTA4ODYzPj4+cjw8cjt0aGlzLndvcmRzW3RoaXMubGVuZ3RoLTFdJj1tYXNrfXJldHVybiB0aGlzLnN0cmlwKCl9O0JOLnByb3RvdHlwZS5tYXNrbj1mdW5jdGlvbiBtYXNrbihiaXRzKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKX07Qk4ucHJvdG90eXBlLmlhZGRuPWZ1bmN0aW9uIGlhZGRuKG51bSl7YXNzZXJ0KHR5cGVvZiBudW09PT1cIm51bWJlclwiKTthc3NlcnQobnVtPDY3MTA4ODY0KTtpZihudW08MClyZXR1cm4gdGhpcy5pc3VibigtbnVtKTtpZih0aGlzLm5lZ2F0aXZlIT09MCl7aWYodGhpcy5sZW5ndGg9PT0xJiYodGhpcy53b3Jkc1swXXwwKTxudW0pe3RoaXMud29yZHNbMF09bnVtLSh0aGlzLndvcmRzWzBdfDApO3RoaXMubmVnYXRpdmU9MDtyZXR1cm4gdGhpc310aGlzLm5lZ2F0aXZlPTA7dGhpcy5pc3VibihudW0pO3RoaXMubmVnYXRpdmU9MTtyZXR1cm4gdGhpc31yZXR1cm4gdGhpcy5faWFkZG4obnVtKX07Qk4ucHJvdG90eXBlLl9pYWRkbj1mdW5jdGlvbiBfaWFkZG4obnVtKXt0aGlzLndvcmRzWzBdKz1udW07Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aCYmdGhpcy53b3Jkc1tpXT49NjcxMDg4NjQ7aSsrKXt0aGlzLndvcmRzW2ldLT02NzEwODg2NDtpZihpPT09dGhpcy5sZW5ndGgtMSl7dGhpcy53b3Jkc1tpKzFdPTF9ZWxzZXt0aGlzLndvcmRzW2krMV0rK319dGhpcy5sZW5ndGg9TWF0aC5tYXgodGhpcy5sZW5ndGgsaSsxKTtyZXR1cm4gdGhpc307Qk4ucHJvdG90eXBlLmlzdWJuPWZ1bmN0aW9uIGlzdWJuKG51bSl7YXNzZXJ0KHR5cGVvZiBudW09PT1cIm51bWJlclwiKTthc3NlcnQobnVtPDY3MTA4ODY0KTtpZihudW08MClyZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtpZih0aGlzLm5lZ2F0aXZlIT09MCl7dGhpcy5uZWdhdGl2ZT0wO3RoaXMuaWFkZG4obnVtKTt0aGlzLm5lZ2F0aXZlPTE7cmV0dXJuIHRoaXN9dGhpcy53b3Jkc1swXS09bnVtO2lmKHRoaXMubGVuZ3RoPT09MSYmdGhpcy53b3Jkc1swXTwwKXt0aGlzLndvcmRzWzBdPS10aGlzLndvcmRzWzBdO3RoaXMubmVnYXRpdmU9MX1lbHNle2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGgmJnRoaXMud29yZHNbaV08MDtpKyspe3RoaXMud29yZHNbaV0rPTY3MTA4ODY0O3RoaXMud29yZHNbaSsxXS09MX19cmV0dXJuIHRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLmFkZG49ZnVuY3Rpb24gYWRkbihudW0pe3JldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKX07Qk4ucHJvdG90eXBlLnN1Ym49ZnVuY3Rpb24gc3VibihudW0pe3JldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKX07Qk4ucHJvdG90eXBlLmlhYnM9ZnVuY3Rpb24gaWFicygpe3RoaXMubmVnYXRpdmU9MDtyZXR1cm4gdGhpc307Qk4ucHJvdG90eXBlLmFicz1mdW5jdGlvbiBhYnMoKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKX07Qk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bD1mdW5jdGlvbiBfaXNobG5zdWJtdWwobnVtLG11bCxzaGlmdCl7dmFyIGxlbj1udW0ubGVuZ3RoK3NoaWZ0O3ZhciBpO3RoaXMuX2V4cGFuZChsZW4pO3ZhciB3O3ZhciBjYXJyeT0wO2ZvcihpPTA7aTxudW0ubGVuZ3RoO2krKyl7dz0odGhpcy53b3Jkc1tpK3NoaWZ0XXwwKStjYXJyeTt2YXIgcmlnaHQ9KG51bS53b3Jkc1tpXXwwKSptdWw7dy09cmlnaHQmNjcxMDg4NjM7Y2Fycnk9KHc+PjI2KS0ocmlnaHQvNjcxMDg4NjR8MCk7dGhpcy53b3Jkc1tpK3NoaWZ0XT13JjY3MTA4ODYzfWZvcig7aTx0aGlzLmxlbmd0aC1zaGlmdDtpKyspe3c9KHRoaXMud29yZHNbaStzaGlmdF18MCkrY2Fycnk7Y2Fycnk9dz4+MjY7dGhpcy53b3Jkc1tpK3NoaWZ0XT13JjY3MTA4ODYzfWlmKGNhcnJ5PT09MClyZXR1cm4gdGhpcy5zdHJpcCgpO2Fzc2VydChjYXJyeT09PS0xKTtjYXJyeT0wO2ZvcihpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3c9LSh0aGlzLndvcmRzW2ldfDApK2NhcnJ5O2NhcnJ5PXc+PjI2O3RoaXMud29yZHNbaV09dyY2NzEwODg2M310aGlzLm5lZ2F0aXZlPTE7cmV0dXJuIHRoaXMuc3RyaXAoKX07Qk4ucHJvdG90eXBlLl93b3JkRGl2PWZ1bmN0aW9uIF93b3JkRGl2KG51bSxtb2RlKXt2YXIgc2hpZnQ9dGhpcy5sZW5ndGgtbnVtLmxlbmd0aDt2YXIgYT10aGlzLmNsb25lKCk7dmFyIGI9bnVtO3ZhciBiaGk9Yi53b3Jkc1tiLmxlbmd0aC0xXXwwO3ZhciBiaGlCaXRzPXRoaXMuX2NvdW50Qml0cyhiaGkpO3NoaWZ0PTI2LWJoaUJpdHM7aWYoc2hpZnQhPT0wKXtiPWIudXNobG4oc2hpZnQpO2EuaXVzaGxuKHNoaWZ0KTtiaGk9Yi53b3Jkc1tiLmxlbmd0aC0xXXwwfXZhciBtPWEubGVuZ3RoLWIubGVuZ3RoO3ZhciBxO2lmKG1vZGUhPT1cIm1vZFwiKXtxPW5ldyBCTihudWxsKTtxLmxlbmd0aD1tKzE7cS53b3Jkcz1uZXcgQXJyYXkocS5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8cS5sZW5ndGg7aSsrKXtxLndvcmRzW2ldPTB9fXZhciBkaWZmPWEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwxLG0pO2lmKGRpZmYubmVnYXRpdmU9PT0wKXthPWRpZmY7aWYocSl7cS53b3Jkc1ttXT0xfX1mb3IodmFyIGo9bS0xO2o+PTA7ai0tKXt2YXIgcWo9KGEud29yZHNbYi5sZW5ndGgral18MCkqNjcxMDg4NjQrKGEud29yZHNbYi5sZW5ndGgrai0xXXwwKTtxaj1NYXRoLm1pbihxai9iaGl8MCw2NzEwODg2Myk7YS5faXNobG5zdWJtdWwoYixxaixqKTt3aGlsZShhLm5lZ2F0aXZlIT09MCl7cWotLTthLm5lZ2F0aXZlPTA7YS5faXNobG5zdWJtdWwoYiwxLGopO2lmKCFhLmlzWmVybygpKXthLm5lZ2F0aXZlXj0xfX1pZihxKXtxLndvcmRzW2pdPXFqfX1pZihxKXtxLnN0cmlwKCl9YS5zdHJpcCgpO2lmKG1vZGUhPT1cImRpdlwiJiZzaGlmdCE9PTApe2EuaXVzaHJuKHNoaWZ0KX1yZXR1cm57ZGl2OnF8fG51bGwsbW9kOmF9fTtCTi5wcm90b3R5cGUuZGl2bW9kPWZ1bmN0aW9uIGRpdm1vZChudW0sbW9kZSxwb3NpdGl2ZSl7YXNzZXJ0KCFudW0uaXNaZXJvKCkpO2lmKHRoaXMuaXNaZXJvKCkpe3JldHVybntkaXY6bmV3IEJOKDApLG1vZDpuZXcgQk4oMCl9fXZhciBkaXYsbW9kLHJlcztpZih0aGlzLm5lZ2F0aXZlIT09MCYmbnVtLm5lZ2F0aXZlPT09MCl7cmVzPXRoaXMubmVnKCkuZGl2bW9kKG51bSxtb2RlKTtpZihtb2RlIT09XCJtb2RcIil7ZGl2PXJlcy5kaXYubmVnKCl9aWYobW9kZSE9PVwiZGl2XCIpe21vZD1yZXMubW9kLm5lZygpO2lmKHBvc2l0aXZlJiZtb2QubmVnYXRpdmUhPT0wKXttb2QuaWFkZChudW0pfX1yZXR1cm57ZGl2OmRpdixtb2Q6bW9kfX1pZih0aGlzLm5lZ2F0aXZlPT09MCYmbnVtLm5lZ2F0aXZlIT09MCl7cmVzPXRoaXMuZGl2bW9kKG51bS5uZWcoKSxtb2RlKTtpZihtb2RlIT09XCJtb2RcIil7ZGl2PXJlcy5kaXYubmVnKCl9cmV0dXJue2RpdjpkaXYsbW9kOnJlcy5tb2R9fWlmKCh0aGlzLm5lZ2F0aXZlJm51bS5uZWdhdGl2ZSkhPT0wKXtyZXM9dGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLG1vZGUpO2lmKG1vZGUhPT1cImRpdlwiKXttb2Q9cmVzLm1vZC5uZWcoKTtpZihwb3NpdGl2ZSYmbW9kLm5lZ2F0aXZlIT09MCl7bW9kLmlzdWIobnVtKX19cmV0dXJue2RpdjpyZXMuZGl2LG1vZDptb2R9fWlmKG51bS5sZW5ndGg+dGhpcy5sZW5ndGh8fHRoaXMuY21wKG51bSk8MCl7cmV0dXJue2RpdjpuZXcgQk4oMCksbW9kOnRoaXN9fWlmKG51bS5sZW5ndGg9PT0xKXtpZihtb2RlPT09XCJkaXZcIil7cmV0dXJue2Rpdjp0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxtb2Q6bnVsbH19aWYobW9kZT09PVwibW9kXCIpe3JldHVybntkaXY6bnVsbCxtb2Q6bmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKX19cmV0dXJue2Rpdjp0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxtb2Q6bmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKX19cmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLG1vZGUpfTtCTi5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uIGRpdihudW0pe3JldHVybiB0aGlzLmRpdm1vZChudW0sXCJkaXZcIixmYWxzZSkuZGl2fTtCTi5wcm90b3R5cGUubW9kPWZ1bmN0aW9uIG1vZChudW0pe3JldHVybiB0aGlzLmRpdm1vZChudW0sXCJtb2RcIixmYWxzZSkubW9kfTtCTi5wcm90b3R5cGUudW1vZD1mdW5jdGlvbiB1bW9kKG51bSl7cmV0dXJuIHRoaXMuZGl2bW9kKG51bSxcIm1vZFwiLHRydWUpLm1vZH07Qk4ucHJvdG90eXBlLmRpdlJvdW5kPWZ1bmN0aW9uIGRpdlJvdW5kKG51bSl7dmFyIGRtPXRoaXMuZGl2bW9kKG51bSk7aWYoZG0ubW9kLmlzWmVybygpKXJldHVybiBkbS5kaXY7dmFyIG1vZD1kbS5kaXYubmVnYXRpdmUhPT0wP2RtLm1vZC5pc3ViKG51bSk6ZG0ubW9kO3ZhciBoYWxmPW51bS51c2hybigxKTt2YXIgcjI9bnVtLmFuZGxuKDEpO3ZhciBjbXA9bW9kLmNtcChoYWxmKTtpZihjbXA8MHx8cjI9PT0xJiZjbXA9PT0wKXJldHVybiBkbS5kaXY7cmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSE9PTA/ZG0uZGl2LmlzdWJuKDEpOmRtLmRpdi5pYWRkbigxKX07Qk4ucHJvdG90eXBlLm1vZG49ZnVuY3Rpb24gbW9kbihudW0pe2Fzc2VydChudW08PTY3MTA4ODYzKTt2YXIgcD0oMTw8MjYpJW51bTt2YXIgYWNjPTA7Zm9yKHZhciBpPXRoaXMubGVuZ3RoLTE7aT49MDtpLS0pe2FjYz0ocCphY2MrKHRoaXMud29yZHNbaV18MCkpJW51bX1yZXR1cm4gYWNjfTtCTi5wcm90b3R5cGUuaWRpdm49ZnVuY3Rpb24gaWRpdm4obnVtKXthc3NlcnQobnVtPD02NzEwODg2Myk7dmFyIGNhcnJ5PTA7Zm9yKHZhciBpPXRoaXMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciB3PSh0aGlzLndvcmRzW2ldfDApK2NhcnJ5KjY3MTA4ODY0O3RoaXMud29yZHNbaV09dy9udW18MDtjYXJyeT13JW51bX1yZXR1cm4gdGhpcy5zdHJpcCgpfTtCTi5wcm90b3R5cGUuZGl2bj1mdW5jdGlvbiBkaXZuKG51bSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pfTtCTi5wcm90b3R5cGUuZWdjZD1mdW5jdGlvbiBlZ2NkKHApe2Fzc2VydChwLm5lZ2F0aXZlPT09MCk7YXNzZXJ0KCFwLmlzWmVybygpKTt2YXIgeD10aGlzO3ZhciB5PXAuY2xvbmUoKTtpZih4Lm5lZ2F0aXZlIT09MCl7eD14LnVtb2QocCl9ZWxzZXt4PXguY2xvbmUoKX12YXIgQT1uZXcgQk4oMSk7dmFyIEI9bmV3IEJOKDApO3ZhciBDPW5ldyBCTigwKTt2YXIgRD1uZXcgQk4oMSk7dmFyIGc9MDt3aGlsZSh4LmlzRXZlbigpJiZ5LmlzRXZlbigpKXt4Lml1c2hybigxKTt5Lml1c2hybigxKTsrK2d9dmFyIHlwPXkuY2xvbmUoKTt2YXIgeHA9eC5jbG9uZSgpO3doaWxlKCF4LmlzWmVybygpKXtmb3IodmFyIGk9MCxpbT0xOyh4LndvcmRzWzBdJmltKT09PTAmJmk8MjY7KytpLGltPDw9MSk7aWYoaT4wKXt4Lml1c2hybihpKTt3aGlsZShpLS0gPjApe2lmKEEuaXNPZGQoKXx8Qi5pc09kZCgpKXtBLmlhZGQoeXApO0IuaXN1Yih4cCl9QS5pdXNocm4oMSk7Qi5pdXNocm4oMSl9fWZvcih2YXIgaj0wLGptPTE7KHkud29yZHNbMF0mam0pPT09MCYmajwyNjsrK2osam08PD0xKTtpZihqPjApe3kuaXVzaHJuKGopO3doaWxlKGotLSA+MCl7aWYoQy5pc09kZCgpfHxELmlzT2RkKCkpe0MuaWFkZCh5cCk7RC5pc3ViKHhwKX1DLml1c2hybigxKTtELml1c2hybigxKX19aWYoeC5jbXAoeSk+PTApe3guaXN1Yih5KTtBLmlzdWIoQyk7Qi5pc3ViKEQpfWVsc2V7eS5pc3ViKHgpO0MuaXN1YihBKTtELmlzdWIoQil9fXJldHVybnthOkMsYjpELGdjZDp5Lml1c2hsbihnKX19O0JOLnByb3RvdHlwZS5faW52bXA9ZnVuY3Rpb24gX2ludm1wKHApe2Fzc2VydChwLm5lZ2F0aXZlPT09MCk7YXNzZXJ0KCFwLmlzWmVybygpKTt2YXIgYT10aGlzO3ZhciBiPXAuY2xvbmUoKTtpZihhLm5lZ2F0aXZlIT09MCl7YT1hLnVtb2QocCl9ZWxzZXthPWEuY2xvbmUoKX12YXIgeDE9bmV3IEJOKDEpO3ZhciB4Mj1uZXcgQk4oMCk7dmFyIGRlbHRhPWIuY2xvbmUoKTt3aGlsZShhLmNtcG4oMSk+MCYmYi5jbXBuKDEpPjApe2Zvcih2YXIgaT0wLGltPTE7KGEud29yZHNbMF0maW0pPT09MCYmaTwyNjsrK2ksaW08PD0xKTtpZihpPjApe2EuaXVzaHJuKGkpO3doaWxlKGktLSA+MCl7aWYoeDEuaXNPZGQoKSl7eDEuaWFkZChkZWx0YSl9eDEuaXVzaHJuKDEpfX1mb3IodmFyIGo9MCxqbT0xOyhiLndvcmRzWzBdJmptKT09PTAmJmo8MjY7KytqLGptPDw9MSk7aWYoaj4wKXtiLml1c2hybihqKTt3aGlsZShqLS0gPjApe2lmKHgyLmlzT2RkKCkpe3gyLmlhZGQoZGVsdGEpfXgyLml1c2hybigxKX19aWYoYS5jbXAoYik+PTApe2EuaXN1YihiKTt4MS5pc3ViKHgyKX1lbHNle2IuaXN1YihhKTt4Mi5pc3ViKHgxKX19dmFyIHJlcztpZihhLmNtcG4oMSk9PT0wKXtyZXM9eDF9ZWxzZXtyZXM9eDJ9aWYocmVzLmNtcG4oMCk8MCl7cmVzLmlhZGQocCl9cmV0dXJuIHJlc307Qk4ucHJvdG90eXBlLmdjZD1mdW5jdGlvbiBnY2QobnVtKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBudW0uYWJzKCk7aWYobnVtLmlzWmVybygpKXJldHVybiB0aGlzLmFicygpO3ZhciBhPXRoaXMuY2xvbmUoKTt2YXIgYj1udW0uY2xvbmUoKTthLm5lZ2F0aXZlPTA7Yi5uZWdhdGl2ZT0wO2Zvcih2YXIgc2hpZnQ9MDthLmlzRXZlbigpJiZiLmlzRXZlbigpO3NoaWZ0Kyspe2EuaXVzaHJuKDEpO2IuaXVzaHJuKDEpfWRve3doaWxlKGEuaXNFdmVuKCkpe2EuaXVzaHJuKDEpfXdoaWxlKGIuaXNFdmVuKCkpe2IuaXVzaHJuKDEpfXZhciByPWEuY21wKGIpO2lmKHI8MCl7dmFyIHQ9YTthPWI7Yj10fWVsc2UgaWYocj09PTB8fGIuY21wbigxKT09PTApe2JyZWFrfWEuaXN1YihiKX13aGlsZSh0cnVlKTtyZXR1cm4gYi5pdXNobG4oc2hpZnQpfTtCTi5wcm90b3R5cGUuaW52bT1mdW5jdGlvbiBpbnZtKG51bSl7cmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pfTtCTi5wcm90b3R5cGUuaXNFdmVuPWZ1bmN0aW9uIGlzRXZlbigpe3JldHVybih0aGlzLndvcmRzWzBdJjEpPT09MH07Qk4ucHJvdG90eXBlLmlzT2RkPWZ1bmN0aW9uIGlzT2RkKCl7cmV0dXJuKHRoaXMud29yZHNbMF0mMSk9PT0xfTtCTi5wcm90b3R5cGUuYW5kbG49ZnVuY3Rpb24gYW5kbG4obnVtKXtyZXR1cm4gdGhpcy53b3Jkc1swXSZudW19O0JOLnByb3RvdHlwZS5iaW5jbj1mdW5jdGlvbiBiaW5jbihiaXQpe2Fzc2VydCh0eXBlb2YgYml0PT09XCJudW1iZXJcIik7dmFyIHI9Yml0JTI2O3ZhciBzPShiaXQtcikvMjY7dmFyIHE9MTw8cjtpZih0aGlzLmxlbmd0aDw9cyl7dGhpcy5fZXhwYW5kKHMrMSk7dGhpcy53b3Jkc1tzXXw9cTtyZXR1cm4gdGhpc312YXIgY2Fycnk9cTtmb3IodmFyIGk9cztjYXJyeSE9PTAmJmk8dGhpcy5sZW5ndGg7aSsrKXt2YXIgdz10aGlzLndvcmRzW2ldfDA7dys9Y2Fycnk7Y2Fycnk9dz4+PjI2O3cmPTY3MTA4ODYzO3RoaXMud29yZHNbaV09d31pZihjYXJyeSE9PTApe3RoaXMud29yZHNbaV09Y2Fycnk7dGhpcy5sZW5ndGgrK31yZXR1cm4gdGhpc307Qk4ucHJvdG90eXBlLmlzWmVybz1mdW5jdGlvbiBpc1plcm8oKXtyZXR1cm4gdGhpcy5sZW5ndGg9PT0xJiZ0aGlzLndvcmRzWzBdPT09MH07Qk4ucHJvdG90eXBlLmNtcG49ZnVuY3Rpb24gY21wbihudW0pe3ZhciBuZWdhdGl2ZT1udW08MDtpZih0aGlzLm5lZ2F0aXZlIT09MCYmIW5lZ2F0aXZlKXJldHVybi0xO2lmKHRoaXMubmVnYXRpdmU9PT0wJiZuZWdhdGl2ZSlyZXR1cm4gMTt0aGlzLnN0cmlwKCk7dmFyIHJlcztpZih0aGlzLmxlbmd0aD4xKXtyZXM9MX1lbHNle2lmKG5lZ2F0aXZlKXtudW09LW51bX1hc3NlcnQobnVtPD02NzEwODg2MyxcIk51bWJlciBpcyB0b28gYmlnXCIpO3ZhciB3PXRoaXMud29yZHNbMF18MDtyZXM9dz09PW51bT8wOnc8bnVtPy0xOjF9aWYodGhpcy5uZWdhdGl2ZSE9PTApcmV0dXJuLXJlc3wwO3JldHVybiByZXN9O0JOLnByb3RvdHlwZS5jbXA9ZnVuY3Rpb24gY21wKG51bSl7aWYodGhpcy5uZWdhdGl2ZSE9PTAmJm51bS5uZWdhdGl2ZT09PTApcmV0dXJuLTE7aWYodGhpcy5uZWdhdGl2ZT09PTAmJm51bS5uZWdhdGl2ZSE9PTApcmV0dXJuIDE7dmFyIHJlcz10aGlzLnVjbXAobnVtKTtpZih0aGlzLm5lZ2F0aXZlIT09MClyZXR1cm4tcmVzfDA7cmV0dXJuIHJlc307Qk4ucHJvdG90eXBlLnVjbXA9ZnVuY3Rpb24gdWNtcChudW0pe2lmKHRoaXMubGVuZ3RoPm51bS5sZW5ndGgpcmV0dXJuIDE7aWYodGhpcy5sZW5ndGg8bnVtLmxlbmd0aClyZXR1cm4tMTt2YXIgcmVzPTA7Zm9yKHZhciBpPXRoaXMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBhPXRoaXMud29yZHNbaV18MDt2YXIgYj1udW0ud29yZHNbaV18MDtpZihhPT09Yiljb250aW51ZTtpZihhPGIpe3Jlcz0tMX1lbHNlIGlmKGE+Yil7cmVzPTF9YnJlYWt9cmV0dXJuIHJlc307Qk4ucHJvdG90eXBlLmd0bj1mdW5jdGlvbiBndG4obnVtKXtyZXR1cm4gdGhpcy5jbXBuKG51bSk9PT0xfTtCTi5wcm90b3R5cGUuZ3Q9ZnVuY3Rpb24gZ3QobnVtKXtyZXR1cm4gdGhpcy5jbXAobnVtKT09PTF9O0JOLnByb3RvdHlwZS5ndGVuPWZ1bmN0aW9uIGd0ZW4obnVtKXtyZXR1cm4gdGhpcy5jbXBuKG51bSk+PTB9O0JOLnByb3RvdHlwZS5ndGU9ZnVuY3Rpb24gZ3RlKG51bSl7cmV0dXJuIHRoaXMuY21wKG51bSk+PTB9O0JOLnByb3RvdHlwZS5sdG49ZnVuY3Rpb24gbHRuKG51bSl7cmV0dXJuIHRoaXMuY21wbihudW0pPT09LTF9O0JOLnByb3RvdHlwZS5sdD1mdW5jdGlvbiBsdChudW0pe3JldHVybiB0aGlzLmNtcChudW0pPT09LTF9O0JOLnByb3RvdHlwZS5sdGVuPWZ1bmN0aW9uIGx0ZW4obnVtKXtyZXR1cm4gdGhpcy5jbXBuKG51bSk8PTB9O0JOLnByb3RvdHlwZS5sdGU9ZnVuY3Rpb24gbHRlKG51bSl7cmV0dXJuIHRoaXMuY21wKG51bSk8PTB9O0JOLnByb3RvdHlwZS5lcW49ZnVuY3Rpb24gZXFuKG51bSl7cmV0dXJuIHRoaXMuY21wbihudW0pPT09MH07Qk4ucHJvdG90eXBlLmVxPWZ1bmN0aW9uIGVxKG51bSl7cmV0dXJuIHRoaXMuY21wKG51bSk9PT0wfTtCTi5yZWQ9ZnVuY3Rpb24gcmVkKG51bSl7cmV0dXJuIG5ldyBSZWQobnVtKX07Qk4ucHJvdG90eXBlLnRvUmVkPWZ1bmN0aW9uIHRvUmVkKGN0eCl7YXNzZXJ0KCF0aGlzLnJlZCxcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIik7YXNzZXJ0KHRoaXMubmVnYXRpdmU9PT0wLFwicmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXNcIik7cmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCl9O0JOLnByb3RvdHlwZS5mcm9tUmVkPWZ1bmN0aW9uIGZyb21SZWQoKXthc3NlcnQodGhpcy5yZWQsXCJmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpO3JldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKX07Qk4ucHJvdG90eXBlLl9mb3JjZVJlZD1mdW5jdGlvbiBfZm9yY2VSZWQoY3R4KXt0aGlzLnJlZD1jdHg7cmV0dXJuIHRoaXN9O0JOLnByb3RvdHlwZS5mb3JjZVJlZD1mdW5jdGlvbiBmb3JjZVJlZChjdHgpe2Fzc2VydCghdGhpcy5yZWQsXCJBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpO3JldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpfTtCTi5wcm90b3R5cGUucmVkQWRkPWZ1bmN0aW9uIHJlZEFkZChudW0pe2Fzc2VydCh0aGlzLnJlZCxcInJlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7cmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLG51bSl9O0JOLnByb3RvdHlwZS5yZWRJQWRkPWZ1bmN0aW9uIHJlZElBZGQobnVtKXthc3NlcnQodGhpcy5yZWQsXCJyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtyZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLG51bSl9O0JOLnByb3RvdHlwZS5yZWRTdWI9ZnVuY3Rpb24gcmVkU3ViKG51bSl7YXNzZXJ0KHRoaXMucmVkLFwicmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTtyZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsbnVtKX07Qk4ucHJvdG90eXBlLnJlZElTdWI9ZnVuY3Rpb24gcmVkSVN1YihudW0pe2Fzc2VydCh0aGlzLnJlZCxcInJlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3JldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsbnVtKX07Qk4ucHJvdG90eXBlLnJlZFNobD1mdW5jdGlvbiByZWRTaGwobnVtKXthc3NlcnQodGhpcy5yZWQsXCJyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3JldHVybiB0aGlzLnJlZC5zaGwodGhpcyxudW0pfTtCTi5wcm90b3R5cGUucmVkTXVsPWZ1bmN0aW9uIHJlZE11bChudW0pe2Fzc2VydCh0aGlzLnJlZCxcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7dGhpcy5yZWQuX3ZlcmlmeTIodGhpcyxudW0pO3JldHVybiB0aGlzLnJlZC5tdWwodGhpcyxudW0pfTtCTi5wcm90b3R5cGUucmVkSU11bD1mdW5jdGlvbiByZWRJTXVsKG51bSl7YXNzZXJ0KHRoaXMucmVkLFwicmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTt0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLG51bSk7cmV0dXJuIHRoaXMucmVkLmltdWwodGhpcyxudW0pfTtCTi5wcm90b3R5cGUucmVkU3FyPWZ1bmN0aW9uIHJlZFNxcigpe2Fzc2VydCh0aGlzLnJlZCxcInJlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7dGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7cmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKX07Qk4ucHJvdG90eXBlLnJlZElTcXI9ZnVuY3Rpb24gcmVkSVNxcigpe2Fzc2VydCh0aGlzLnJlZCxcInJlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3RoaXMucmVkLl92ZXJpZnkxKHRoaXMpO3JldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpfTtCTi5wcm90b3R5cGUucmVkU3FydD1mdW5jdGlvbiByZWRTcXJ0KCl7YXNzZXJ0KHRoaXMucmVkLFwicmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7dGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7cmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyl9O0JOLnByb3RvdHlwZS5yZWRJbnZtPWZ1bmN0aW9uIHJlZEludm0oKXthc3NlcnQodGhpcy5yZWQsXCJyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKTt0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtyZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKX07Qk4ucHJvdG90eXBlLnJlZE5lZz1mdW5jdGlvbiByZWROZWcoKXthc3NlcnQodGhpcy5yZWQsXCJyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO3RoaXMucmVkLl92ZXJpZnkxKHRoaXMpO3JldHVybiB0aGlzLnJlZC5uZWcodGhpcyl9O0JOLnByb3RvdHlwZS5yZWRQb3c9ZnVuY3Rpb24gcmVkUG93KG51bSl7YXNzZXJ0KHRoaXMucmVkJiYhbnVtLnJlZCxcInJlZFBvdyhub3JtYWxOdW0pXCIpO3RoaXMucmVkLl92ZXJpZnkxKHRoaXMpO3JldHVybiB0aGlzLnJlZC5wb3codGhpcyxudW0pfTt2YXIgcHJpbWVzPXtrMjU2Om51bGwscDIyNDpudWxsLHAxOTI6bnVsbCxwMjU1MTk6bnVsbH07ZnVuY3Rpb24gTVByaW1lKG5hbWUscCl7dGhpcy5uYW1lPW5hbWU7dGhpcy5wPW5ldyBCTihwLDE2KTt0aGlzLm49dGhpcy5wLmJpdExlbmd0aCgpO3RoaXMuaz1uZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO3RoaXMudG1wPXRoaXMuX3RtcCgpfU1QcmltZS5wcm90b3R5cGUuX3RtcD1mdW5jdGlvbiBfdG1wKCl7dmFyIHRtcD1uZXcgQk4obnVsbCk7dG1wLndvcmRzPW5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uLzEzKSk7cmV0dXJuIHRtcH07TVByaW1lLnByb3RvdHlwZS5pcmVkdWNlPWZ1bmN0aW9uIGlyZWR1Y2UobnVtKXt2YXIgcj1udW07dmFyIHJsZW47ZG97dGhpcy5zcGxpdChyLHRoaXMudG1wKTtyPXRoaXMuaW11bEsocik7cj1yLmlhZGQodGhpcy50bXApO3JsZW49ci5iaXRMZW5ndGgoKX13aGlsZShybGVuPnRoaXMubik7dmFyIGNtcD1ybGVuPHRoaXMubj8tMTpyLnVjbXAodGhpcy5wKTtpZihjbXA9PT0wKXtyLndvcmRzWzBdPTA7ci5sZW5ndGg9MX1lbHNlIGlmKGNtcD4wKXtyLmlzdWIodGhpcy5wKX1lbHNle2lmKHIuc3RyaXAhPT11bmRlZmluZWQpe3Iuc3RyaXAoKX1lbHNle3IuX3N0cmlwKCl9fXJldHVybiByfTtNUHJpbWUucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uIHNwbGl0KGlucHV0LG91dCl7aW5wdXQuaXVzaHJuKHRoaXMubiwwLG91dCl9O01QcmltZS5wcm90b3R5cGUuaW11bEs9ZnVuY3Rpb24gaW11bEsobnVtKXtyZXR1cm4gbnVtLmltdWwodGhpcy5rKX07ZnVuY3Rpb24gSzI1Nigpe01QcmltZS5jYWxsKHRoaXMsXCJrMjU2XCIsXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiKX1pbmhlcml0cyhLMjU2LE1QcmltZSk7SzI1Ni5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24gc3BsaXQoaW5wdXQsb3V0cHV0KXt2YXIgbWFzaz00MTk0MzAzO3ZhciBvdXRMZW49TWF0aC5taW4oaW5wdXQubGVuZ3RoLDkpO2Zvcih2YXIgaT0wO2k8b3V0TGVuO2krKyl7b3V0cHV0LndvcmRzW2ldPWlucHV0LndvcmRzW2ldfW91dHB1dC5sZW5ndGg9b3V0TGVuO2lmKGlucHV0Lmxlbmd0aDw9OSl7aW5wdXQud29yZHNbMF09MDtpbnB1dC5sZW5ndGg9MTtyZXR1cm59dmFyIHByZXY9aW5wdXQud29yZHNbOV07b3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK109cHJldiZtYXNrO2ZvcihpPTEwO2k8aW5wdXQubGVuZ3RoO2krKyl7dmFyIG5leHQ9aW5wdXQud29yZHNbaV18MDtpbnB1dC53b3Jkc1tpLTEwXT0obmV4dCZtYXNrKTw8NHxwcmV2Pj4+MjI7cHJldj1uZXh0fXByZXY+Pj49MjI7aW5wdXQud29yZHNbaS0xMF09cHJldjtpZihwcmV2PT09MCYmaW5wdXQubGVuZ3RoPjEwKXtpbnB1dC5sZW5ndGgtPTEwfWVsc2V7aW5wdXQubGVuZ3RoLT05fX07SzI1Ni5wcm90b3R5cGUuaW11bEs9ZnVuY3Rpb24gaW11bEsobnVtKXtudW0ud29yZHNbbnVtLmxlbmd0aF09MDtudW0ud29yZHNbbnVtLmxlbmd0aCsxXT0wO251bS5sZW5ndGgrPTI7dmFyIGxvPTA7Zm9yKHZhciBpPTA7aTxudW0ubGVuZ3RoO2krKyl7dmFyIHc9bnVtLndvcmRzW2ldfDA7bG8rPXcqOTc3O251bS53b3Jkc1tpXT1sbyY2NzEwODg2Mztsbz13KjY0Kyhsby82NzEwODg2NHwwKX1pZihudW0ud29yZHNbbnVtLmxlbmd0aC0xXT09PTApe251bS5sZW5ndGgtLTtpZihudW0ud29yZHNbbnVtLmxlbmd0aC0xXT09PTApe251bS5sZW5ndGgtLX19cmV0dXJuIG51bX07ZnVuY3Rpb24gUDIyNCgpe01QcmltZS5jYWxsKHRoaXMsXCJwMjI0XCIsXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiKX1pbmhlcml0cyhQMjI0LE1QcmltZSk7ZnVuY3Rpb24gUDE5Migpe01QcmltZS5jYWxsKHRoaXMsXCJwMTkyXCIsXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiKX1pbmhlcml0cyhQMTkyLE1QcmltZSk7ZnVuY3Rpb24gUDI1NTE5KCl7TVByaW1lLmNhbGwodGhpcyxcIjI1NTE5XCIsXCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCIpfWluaGVyaXRzKFAyNTUxOSxNUHJpbWUpO1AyNTUxOS5wcm90b3R5cGUuaW11bEs9ZnVuY3Rpb24gaW11bEsobnVtKXt2YXIgY2Fycnk9MDtmb3IodmFyIGk9MDtpPG51bS5sZW5ndGg7aSsrKXt2YXIgaGk9KG51bS53b3Jkc1tpXXwwKSoxOStjYXJyeTt2YXIgbG89aGkmNjcxMDg4NjM7aGk+Pj49MjY7bnVtLndvcmRzW2ldPWxvO2NhcnJ5PWhpfWlmKGNhcnJ5IT09MCl7bnVtLndvcmRzW251bS5sZW5ndGgrK109Y2Fycnl9cmV0dXJuIG51bX07Qk4uX3ByaW1lPWZ1bmN0aW9uIHByaW1lKG5hbWUpe2lmKHByaW1lc1tuYW1lXSlyZXR1cm4gcHJpbWVzW25hbWVdO3ZhciBwcmltZTtpZihuYW1lPT09XCJrMjU2XCIpe3ByaW1lPW5ldyBLMjU2fWVsc2UgaWYobmFtZT09PVwicDIyNFwiKXtwcmltZT1uZXcgUDIyNH1lbHNlIGlmKG5hbWU9PT1cInAxOTJcIil7cHJpbWU9bmV3IFAxOTJ9ZWxzZSBpZihuYW1lPT09XCJwMjU1MTlcIil7cHJpbWU9bmV3IFAyNTUxOX1lbHNle3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gcHJpbWUgXCIrbmFtZSl9cHJpbWVzW25hbWVdPXByaW1lO3JldHVybiBwcmltZX07ZnVuY3Rpb24gUmVkKG0pe2lmKHR5cGVvZiBtPT09XCJzdHJpbmdcIil7dmFyIHByaW1lPUJOLl9wcmltZShtKTt0aGlzLm09cHJpbWUucDt0aGlzLnByaW1lPXByaW1lfWVsc2V7YXNzZXJ0KG0uZ3RuKDEpLFwibW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXCIpO3RoaXMubT1tO3RoaXMucHJpbWU9bnVsbH19UmVkLnByb3RvdHlwZS5fdmVyaWZ5MT1mdW5jdGlvbiBfdmVyaWZ5MShhKXthc3NlcnQoYS5uZWdhdGl2ZT09PTAsXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKTthc3NlcnQoYS5yZWQsXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpfTtSZWQucHJvdG90eXBlLl92ZXJpZnkyPWZ1bmN0aW9uIF92ZXJpZnkyKGEsYil7YXNzZXJ0KChhLm5lZ2F0aXZlfGIubmVnYXRpdmUpPT09MCxcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpO2Fzc2VydChhLnJlZCYmYS5yZWQ9PT1iLnJlZCxcInJlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIil9O1JlZC5wcm90b3R5cGUuaW1vZD1mdW5jdGlvbiBpbW9kKGEpe2lmKHRoaXMucHJpbWUpcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7cmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKX07UmVkLnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24gbmVnKGEpe2lmKGEuaXNaZXJvKCkpe3JldHVybiBhLmNsb25lKCl9cmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpfTtSZWQucHJvdG90eXBlLmFkZD1mdW5jdGlvbiBhZGQoYSxiKXt0aGlzLl92ZXJpZnkyKGEsYik7dmFyIHJlcz1hLmFkZChiKTtpZihyZXMuY21wKHRoaXMubSk+PTApe3Jlcy5pc3ViKHRoaXMubSl9cmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyl9O1JlZC5wcm90b3R5cGUuaWFkZD1mdW5jdGlvbiBpYWRkKGEsYil7dGhpcy5fdmVyaWZ5MihhLGIpO3ZhciByZXM9YS5pYWRkKGIpO2lmKHJlcy5jbXAodGhpcy5tKT49MCl7cmVzLmlzdWIodGhpcy5tKX1yZXR1cm4gcmVzfTtSZWQucHJvdG90eXBlLnN1Yj1mdW5jdGlvbiBzdWIoYSxiKXt0aGlzLl92ZXJpZnkyKGEsYik7dmFyIHJlcz1hLnN1YihiKTtpZihyZXMuY21wbigwKTwwKXtyZXMuaWFkZCh0aGlzLm0pfXJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpfTtSZWQucHJvdG90eXBlLmlzdWI9ZnVuY3Rpb24gaXN1YihhLGIpe3RoaXMuX3ZlcmlmeTIoYSxiKTt2YXIgcmVzPWEuaXN1YihiKTtpZihyZXMuY21wbigwKTwwKXtyZXMuaWFkZCh0aGlzLm0pfXJldHVybiByZXN9O1JlZC5wcm90b3R5cGUuc2hsPWZ1bmN0aW9uIHNobChhLG51bSl7dGhpcy5fdmVyaWZ5MShhKTtyZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSl9O1JlZC5wcm90b3R5cGUuaW11bD1mdW5jdGlvbiBpbXVsKGEsYil7dGhpcy5fdmVyaWZ5MihhLGIpO3JldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKX07UmVkLnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24gbXVsKGEsYil7dGhpcy5fdmVyaWZ5MihhLGIpO3JldHVybiB0aGlzLmltb2QoYS5tdWwoYikpfTtSZWQucHJvdG90eXBlLmlzcXI9ZnVuY3Rpb24gaXNxcihhKXtyZXR1cm4gdGhpcy5pbXVsKGEsYS5jbG9uZSgpKX07UmVkLnByb3RvdHlwZS5zcXI9ZnVuY3Rpb24gc3FyKGEpe3JldHVybiB0aGlzLm11bChhLGEpfTtSZWQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24gc3FydChhKXtpZihhLmlzWmVybygpKXJldHVybiBhLmNsb25lKCk7dmFyIG1vZDM9dGhpcy5tLmFuZGxuKDMpO2Fzc2VydChtb2QzJTI9PT0xKTtpZihtb2QzPT09Myl7dmFyIHBvdz10aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO3JldHVybiB0aGlzLnBvdyhhLHBvdyl9dmFyIHE9dGhpcy5tLnN1Ym4oMSk7dmFyIHM9MDt3aGlsZSghcS5pc1plcm8oKSYmcS5hbmRsbigxKT09PTApe3MrKztxLml1c2hybigxKX1hc3NlcnQoIXEuaXNaZXJvKCkpO3ZhciBvbmU9bmV3IEJOKDEpLnRvUmVkKHRoaXMpO3ZhciBuT25lPW9uZS5yZWROZWcoKTt2YXIgbHBvdz10aGlzLm0uc3VibigxKS5pdXNocm4oMSk7dmFyIHo9dGhpcy5tLmJpdExlbmd0aCgpO3o9bmV3IEJOKDIqeip6KS50b1JlZCh0aGlzKTt3aGlsZSh0aGlzLnBvdyh6LGxwb3cpLmNtcChuT25lKSE9PTApe3oucmVkSUFkZChuT25lKX12YXIgYz10aGlzLnBvdyh6LHEpO3ZhciByPXRoaXMucG93KGEscS5hZGRuKDEpLml1c2hybigxKSk7dmFyIHQ9dGhpcy5wb3coYSxxKTt2YXIgbT1zO3doaWxlKHQuY21wKG9uZSkhPT0wKXt2YXIgdG1wPXQ7Zm9yKHZhciBpPTA7dG1wLmNtcChvbmUpIT09MDtpKyspe3RtcD10bXAucmVkU3FyKCl9YXNzZXJ0KGk8bSk7dmFyIGI9dGhpcy5wb3coYyxuZXcgQk4oMSkuaXVzaGxuKG0taS0xKSk7cj1yLnJlZE11bChiKTtjPWIucmVkU3FyKCk7dD10LnJlZE11bChjKTttPWl9cmV0dXJuIHJ9O1JlZC5wcm90b3R5cGUuaW52bT1mdW5jdGlvbiBpbnZtKGEpe3ZhciBpbnY9YS5faW52bXAodGhpcy5tKTtpZihpbnYubmVnYXRpdmUhPT0wKXtpbnYubmVnYXRpdmU9MDtyZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCl9ZWxzZXtyZXR1cm4gdGhpcy5pbW9kKGludil9fTtSZWQucHJvdG90eXBlLnBvdz1mdW5jdGlvbiBwb3coYSxudW0pe2lmKG51bS5pc1plcm8oKSlyZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO2lmKG51bS5jbXBuKDEpPT09MClyZXR1cm4gYS5jbG9uZSgpO3ZhciB3aW5kb3dTaXplPTQ7dmFyIHduZD1uZXcgQXJyYXkoMTw8d2luZG93U2l6ZSk7d25kWzBdPW5ldyBCTigxKS50b1JlZCh0aGlzKTt3bmRbMV09YTtmb3IodmFyIGk9MjtpPHduZC5sZW5ndGg7aSsrKXt3bmRbaV09dGhpcy5tdWwod25kW2ktMV0sYSl9dmFyIHJlcz13bmRbMF07dmFyIGN1cnJlbnQ9MDt2YXIgY3VycmVudExlbj0wO3ZhciBzdGFydD1udW0uYml0TGVuZ3RoKCklMjY7aWYoc3RhcnQ9PT0wKXtzdGFydD0yNn1mb3IoaT1udW0ubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciB3b3JkPW51bS53b3Jkc1tpXTtmb3IodmFyIGo9c3RhcnQtMTtqPj0wO2otLSl7dmFyIGJpdD13b3JkPj5qJjE7aWYocmVzIT09d25kWzBdKXtyZXM9dGhpcy5zcXIocmVzKX1pZihiaXQ9PT0wJiZjdXJyZW50PT09MCl7Y3VycmVudExlbj0wO2NvbnRpbnVlfWN1cnJlbnQ8PD0xO2N1cnJlbnR8PWJpdDtjdXJyZW50TGVuKys7aWYoY3VycmVudExlbiE9PXdpbmRvd1NpemUmJihpIT09MHx8aiE9PTApKWNvbnRpbnVlO3Jlcz10aGlzLm11bChyZXMsd25kW2N1cnJlbnRdKTtjdXJyZW50TGVuPTA7Y3VycmVudD0wfXN0YXJ0PTI2fXJldHVybiByZXN9O1JlZC5wcm90b3R5cGUuY29udmVydFRvPWZ1bmN0aW9uIGNvbnZlcnRUbyhudW0pe3ZhciByPW51bS51bW9kKHRoaXMubSk7cmV0dXJuIHI9PT1udW0/ci5jbG9uZSgpOnJ9O1JlZC5wcm90b3R5cGUuY29udmVydEZyb209ZnVuY3Rpb24gY29udmVydEZyb20obnVtKXt2YXIgcmVzPW51bS5jbG9uZSgpO3Jlcy5yZWQ9bnVsbDtyZXR1cm4gcmVzfTtCTi5tb250PWZ1bmN0aW9uIG1vbnQobnVtKXtyZXR1cm4gbmV3IE1vbnQobnVtKX07ZnVuY3Rpb24gTW9udChtKXtSZWQuY2FsbCh0aGlzLG0pO3RoaXMuc2hpZnQ9dGhpcy5tLmJpdExlbmd0aCgpO2lmKHRoaXMuc2hpZnQlMjYhPT0wKXt0aGlzLnNoaWZ0Kz0yNi10aGlzLnNoaWZ0JTI2fXRoaXMucj1uZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO3RoaXMucjI9dGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7dGhpcy5yaW52PXRoaXMuci5faW52bXAodGhpcy5tKTt0aGlzLm1pbnY9dGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO3RoaXMubWludj10aGlzLm1pbnYudW1vZCh0aGlzLnIpO3RoaXMubWludj10aGlzLnIuc3ViKHRoaXMubWludil9aW5oZXJpdHMoTW9udCxSZWQpO01vbnQucHJvdG90eXBlLmNvbnZlcnRUbz1mdW5jdGlvbiBjb252ZXJ0VG8obnVtKXtyZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSl9O01vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tPWZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSl7dmFyIHI9dGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7ci5yZWQ9bnVsbDtyZXR1cm4gcn07TW9udC5wcm90b3R5cGUuaW11bD1mdW5jdGlvbiBpbXVsKGEsYil7aWYoYS5pc1plcm8oKXx8Yi5pc1plcm8oKSl7YS53b3Jkc1swXT0wO2EubGVuZ3RoPTE7cmV0dXJuIGF9dmFyIHQ9YS5pbXVsKGIpO3ZhciBjPXQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO3ZhciB1PXQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7dmFyIHJlcz11O2lmKHUuY21wKHRoaXMubSk+PTApe3Jlcz11LmlzdWIodGhpcy5tKX1lbHNlIGlmKHUuY21wbigwKTwwKXtyZXM9dS5pYWRkKHRoaXMubSl9cmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyl9O01vbnQucHJvdG90eXBlLm11bD1mdW5jdGlvbiBtdWwoYSxiKXtpZihhLmlzWmVybygpfHxiLmlzWmVybygpKXJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO3ZhciB0PWEubXVsKGIpO3ZhciBjPXQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO3ZhciB1PXQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7dmFyIHJlcz11O2lmKHUuY21wKHRoaXMubSk+PTApe3Jlcz11LmlzdWIodGhpcy5tKX1lbHNlIGlmKHUuY21wbigwKTwwKXtyZXM9dS5pYWRkKHRoaXMubSl9cmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyl9O01vbnQucHJvdG90eXBlLmludm09ZnVuY3Rpb24gaW52bShhKXt2YXIgcmVzPXRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7cmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyl9fSkoXCJvYmplY3RcIj09PVwidW5kZWZpbmVkXCJ8fG1vZHVsZSxjb21tb25qc0dsb2JhbCl9KTtjb25zdCB2ZXJzaW9uPVwibG9nZ2VyLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7bGV0IF9wZXJtYW5lbnRDZW5zb3JFcnJvcnM9ZmFsc2U7bGV0IF9jZW5zb3JFcnJvcnM9ZmFsc2U7Y29uc3QgTG9nTGV2ZWxzPXtkZWJ1ZzoxLGRlZmF1bHQ6MixpbmZvOjIsd2FybmluZzozLGVycm9yOjQsb2ZmOjV9O2xldCBfbG9nTGV2ZWw9TG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtsZXQgX2dsb2JhbExvZ2dlcj1udWxsO2Z1bmN0aW9uIF9jaGVja05vcm1hbGl6ZSgpe3RyeXtjb25zdCBtaXNzaW5nPVtdO1tcIk5GRFwiLFwiTkZDXCIsXCJORktEXCIsXCJORktDXCJdLmZvckVhY2goZm9ybT0+e3RyeXtpZihcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkhPT1cInRlc3RcIil7dGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKX19Y2F0Y2goZXJyb3Ipe21pc3NpbmcucHVzaChmb3JtKX19KTtpZihtaXNzaW5nLmxlbmd0aCl7dGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIittaXNzaW5nLmpvaW4oXCIsIFwiKSl9aWYoU3RyaW5nLmZyb21DaGFyQ29kZSgyMzMpLm5vcm1hbGl6ZShcIk5GRFwiKSE9PVN0cmluZy5mcm9tQ2hhckNvZGUoMTAxLDc2OSkpe3Rocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKX19Y2F0Y2goZXJyb3Ipe3JldHVybiBlcnJvci5tZXNzYWdlfXJldHVybiBudWxsfWNvbnN0IF9ub3JtYWxpemVFcnJvcj1fY2hlY2tOb3JtYWxpemUoKTt2YXIgTG9nTGV2ZWw7KGZ1bmN0aW9uKExvZ0xldmVsKXtMb2dMZXZlbFtcIkRFQlVHXCJdPVwiREVCVUdcIjtMb2dMZXZlbFtcIklORk9cIl09XCJJTkZPXCI7TG9nTGV2ZWxbXCJXQVJOSU5HXCJdPVwiV0FSTklOR1wiO0xvZ0xldmVsW1wiRVJST1JcIl09XCJFUlJPUlwiO0xvZ0xldmVsW1wiT0ZGXCJdPVwiT0ZGXCJ9KShMb2dMZXZlbHx8KExvZ0xldmVsPXt9KSk7dmFyIEVycm9yQ29kZTsoZnVuY3Rpb24oRXJyb3JDb2RlKXtFcnJvckNvZGVbXCJVTktOT1dOX0VSUk9SXCJdPVwiVU5LTk9XTl9FUlJPUlwiO0Vycm9yQ29kZVtcIk5PVF9JTVBMRU1FTlRFRFwiXT1cIk5PVF9JTVBMRU1FTlRFRFwiO0Vycm9yQ29kZVtcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiXT1cIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO0Vycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl09XCJORVRXT1JLX0VSUk9SXCI7RXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdPVwiU0VSVkVSX0VSUk9SXCI7RXJyb3JDb2RlW1wiVElNRU9VVFwiXT1cIlRJTUVPVVRcIjtFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXT1cIkJVRkZFUl9PVkVSUlVOXCI7RXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXT1cIk5VTUVSSUNfRkFVTFRcIjtFcnJvckNvZGVbXCJNSVNTSU5HX05FV1wiXT1cIk1JU1NJTkdfTkVXXCI7RXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXT1cIklOVkFMSURfQVJHVU1FTlRcIjtFcnJvckNvZGVbXCJNSVNTSU5HX0FSR1VNRU5UXCJdPVwiTUlTU0lOR19BUkdVTUVOVFwiO0Vycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl09XCJVTkVYUEVDVEVEX0FSR1VNRU5UXCI7RXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl09XCJDQUxMX0VYQ0VQVElPTlwiO0Vycm9yQ29kZVtcIklOU1VGRklDSUVOVF9GVU5EU1wiXT1cIklOU1VGRklDSUVOVF9GVU5EU1wiO0Vycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl09XCJOT05DRV9FWFBJUkVEXCI7RXJyb3JDb2RlW1wiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIl09XCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO0Vycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdPVwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIn0pKEVycm9yQ29kZXx8KEVycm9yQ29kZT17fSkpO2NsYXNzIExvZ2dlcntjb25zdHJ1Y3Rvcih2ZXJzaW9uKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInZlcnNpb25cIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOnZlcnNpb24sd3JpdGFibGU6ZmFsc2V9KX1fbG9nKGxvZ0xldmVsLGFyZ3Mpe2NvbnN0IGxldmVsPWxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7aWYoTG9nTGV2ZWxzW2xldmVsXT09bnVsbCl7dGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsXCJsb2dMZXZlbFwiLGxvZ0xldmVsKX1pZihfbG9nTGV2ZWw+TG9nTGV2ZWxzW2xldmVsXSl7cmV0dXJufWNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJncyl9ZGVidWcoLi4uYXJncyl7dGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsYXJncyl9aW5mbyguLi5hcmdzKXt0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5JTkZPLGFyZ3MpfXdhcm4oLi4uYXJncyl7dGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuV0FSTklORyxhcmdzKX1tYWtlRXJyb3IobWVzc2FnZSxjb2RlLHBhcmFtcyl7aWYoX2NlbnNvckVycm9ycyl7cmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIixjb2RlLHt9KX1pZighY29kZSl7Y29kZT1Mb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1J9aWYoIXBhcmFtcyl7cGFyYW1zPXt9fWNvbnN0IG1lc3NhZ2VEZXRhaWxzPVtdO09iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChrZXk9Pnt0cnl7bWVzc2FnZURldGFpbHMucHVzaChrZXkrXCI9XCIrSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0pKX1jYXRjaChlcnJvcil7bWVzc2FnZURldGFpbHMucHVzaChrZXkrXCI9XCIrSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0udG9TdHJpbmcoKSkpfX0pO21lc3NhZ2VEZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO21lc3NhZ2VEZXRhaWxzLnB1c2goYHZlcnNpb249JHt0aGlzLnZlcnNpb259YCk7Y29uc3QgcmVhc29uPW1lc3NhZ2U7aWYobWVzc2FnZURldGFpbHMubGVuZ3RoKXttZXNzYWdlKz1cIiAoXCIrbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpK1wiKVwifWNvbnN0IGVycm9yPW5ldyBFcnJvcihtZXNzYWdlKTtlcnJvci5yZWFzb249cmVhc29uO2Vycm9yLmNvZGU9Y29kZTtPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KXtlcnJvcltrZXldPXBhcmFtc1trZXldfSk7cmV0dXJuIGVycm9yfXRocm93RXJyb3IobWVzc2FnZSxjb2RlLHBhcmFtcyl7dGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSxjb2RlLHBhcmFtcyl9dGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsbmFtZSx2YWx1ZSl7cmV0dXJuIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6bmFtZSx2YWx1ZTp2YWx1ZX0pfWFzc2VydChjb25kaXRpb24sbWVzc2FnZSxjb2RlLHBhcmFtcyl7aWYoISFjb25kaXRpb24pe3JldHVybn10aGlzLnRocm93RXJyb3IobWVzc2FnZSxjb2RlLHBhcmFtcyl9YXNzZXJ0QXJndW1lbnQoY29uZGl0aW9uLG1lc3NhZ2UsbmFtZSx2YWx1ZSl7aWYoISFjb25kaXRpb24pe3JldHVybn10aGlzLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLG5hbWUsdmFsdWUpfWNoZWNrTm9ybWFsaXplKG1lc3NhZ2Upe2lmKG1lc3NhZ2U9PW51bGwpe21lc3NhZ2U9XCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCJ9aWYoX25vcm1hbGl6ZUVycm9yKXt0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsZm9ybTpfbm9ybWFsaXplRXJyb3J9KX19Y2hlY2tTYWZlVWludDUzKHZhbHVlLG1lc3NhZ2Upe2lmKHR5cGVvZiB2YWx1ZSE9PVwibnVtYmVyXCIpe3JldHVybn1pZihtZXNzYWdlPT1udWxsKXttZXNzYWdlPVwidmFsdWUgbm90IHNhZmVcIn1pZih2YWx1ZTwwfHx2YWx1ZT49OTAwNzE5OTI1NDc0MDk5MSl7dGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULHtvcGVyYXRpb246XCJjaGVja1NhZmVJbnRlZ2VyXCIsZmF1bHQ6XCJvdXQtb2Ytc2FmZS1yYW5nZVwiLHZhbHVlOnZhbHVlfSl9aWYodmFsdWUlMSl7dGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULHtvcGVyYXRpb246XCJjaGVja1NhZmVJbnRlZ2VyXCIsZmF1bHQ6XCJub24taW50ZWdlclwiLHZhbHVlOnZhbHVlfSl9fWNoZWNrQXJndW1lbnRDb3VudChjb3VudCxleHBlY3RlZENvdW50LG1lc3NhZ2Upe2lmKG1lc3NhZ2Upe21lc3NhZ2U9XCI6IFwiK21lc3NhZ2V9ZWxzZXttZXNzYWdlPVwiXCJ9aWYoY291bnQ8ZXhwZWN0ZWRDb3VudCl7dGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiK21lc3NhZ2UsTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULHtjb3VudDpjb3VudCxleHBlY3RlZENvdW50OmV4cGVjdGVkQ291bnR9KX1pZihjb3VudD5leHBlY3RlZENvdW50KXt0aGlzLnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIittZXNzYWdlLExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCx7Y291bnQ6Y291bnQsZXhwZWN0ZWRDb3VudDpleHBlY3RlZENvdW50fSl9fWNoZWNrTmV3KHRhcmdldCxraW5kKXtpZih0YXJnZXQ9PT1PYmplY3R8fHRhcmdldD09bnVsbCl7dGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIixMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLHtuYW1lOmtpbmQubmFtZX0pfX1jaGVja0Fic3RyYWN0KHRhcmdldCxraW5kKXtpZih0YXJnZXQ9PT1raW5kKXt0aGlzLnRocm93RXJyb3IoXCJjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MgXCIrSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKStcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se25hbWU6dGFyZ2V0Lm5hbWUsb3BlcmF0aW9uOlwibmV3XCJ9KX1lbHNlIGlmKHRhcmdldD09PU9iamVjdHx8dGFyZ2V0PT1udWxsKXt0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcse25hbWU6a2luZC5uYW1lfSl9fXN0YXRpYyBnbG9iYWxMb2dnZXIoKXtpZighX2dsb2JhbExvZ2dlcil7X2dsb2JhbExvZ2dlcj1uZXcgTG9nZ2VyKHZlcnNpb24pfXJldHVybiBfZ2xvYmFsTG9nZ2VyfXN0YXRpYyBzZXRDZW5zb3JzaGlwKGNlbnNvcnNoaXAscGVybWFuZW50KXtpZighY2Vuc29yc2hpcCYmcGVybWFuZW50KXt0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJjYW5ub3QgcGVybWFuZW50bHkgZGlzYWJsZSBjZW5zb3JzaGlwXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInNldENlbnNvcnNoaXBcIn0pfWlmKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpe2lmKCFjZW5zb3JzaGlwKXtyZXR1cm59dGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2V0Q2Vuc29yc2hpcFwifSl9X2NlbnNvckVycm9ycz0hIWNlbnNvcnNoaXA7X3Blcm1hbmVudENlbnNvckVycm9ycz0hIXBlcm1hbmVudH1zdGF0aWMgc2V0TG9nTGV2ZWwobG9nTGV2ZWwpe2NvbnN0IGxldmVsPUxvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtpZihsZXZlbD09bnVsbCl7TG9nZ2VyLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiK2xvZ0xldmVsKTtyZXR1cm59X2xvZ0xldmVsPWxldmVsfXN0YXRpYyBmcm9tKHZlcnNpb24pe3JldHVybiBuZXcgTG9nZ2VyKHZlcnNpb24pfX1Mb2dnZXIuZXJyb3JzPUVycm9yQ29kZTtMb2dnZXIubGV2ZWxzPUxvZ0xldmVsO2NvbnN0IHZlcnNpb24kMT1cImJ5dGVzLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyPW5ldyBMb2dnZXIodmVyc2lvbiQxKTtmdW5jdGlvbiBpc0hleGFibGUodmFsdWUpe3JldHVybiEhdmFsdWUudG9IZXhTdHJpbmd9ZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpe2lmKGFycmF5LnNsaWNlKXtyZXR1cm4gYXJyYXl9YXJyYXkuc2xpY2U9ZnVuY3Rpb24oKXtjb25zdCBhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7cmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheSxhcmdzKSkpfTtyZXR1cm4gYXJyYXl9ZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpe3JldHVybiBpc0hleFN0cmluZyh2YWx1ZSkmJiEodmFsdWUubGVuZ3RoJTIpfHxpc0J5dGVzKHZhbHVlKX1mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKXtpZih2YWx1ZT09bnVsbCl7cmV0dXJuIGZhbHNlfWlmKHZhbHVlLmNvbnN0cnVjdG9yPT09VWludDhBcnJheSl7cmV0dXJuIHRydWV9aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZhbHNlfWlmKHZhbHVlLmxlbmd0aD09bnVsbCl7cmV0dXJuIGZhbHNlfWZvcihsZXQgaT0wO2k8dmFsdWUubGVuZ3RoO2krKyl7Y29uc3Qgdj12YWx1ZVtpXTtpZih0eXBlb2YgdiE9PVwibnVtYmVyXCJ8fHY8MHx8dj49MjU2fHx2JTEpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9ZnVuY3Rpb24gYXJyYXlpZnkodmFsdWUsb3B0aW9ucyl7aWYoIW9wdGlvbnMpe29wdGlvbnM9e319aWYodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIil7bG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSxcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIik7Y29uc3QgcmVzdWx0PVtdO3doaWxlKHZhbHVlKXtyZXN1bHQudW5zaGlmdCh2YWx1ZSYyNTUpO3ZhbHVlPXBhcnNlSW50KFN0cmluZyh2YWx1ZS8yNTYpKX1pZihyZXN1bHQubGVuZ3RoPT09MCl7cmVzdWx0LnB1c2goMCl9cmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpfWlmKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4JiZ0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiJiZ2YWx1ZS5zdWJzdHJpbmcoMCwyKSE9PVwiMHhcIil7dmFsdWU9XCIweFwiK3ZhbHVlfWlmKGlzSGV4YWJsZSh2YWx1ZSkpe3ZhbHVlPXZhbHVlLnRvSGV4U3RyaW5nKCl9aWYoaXNIZXhTdHJpbmcodmFsdWUpKXtsZXQgaGV4PXZhbHVlLnN1YnN0cmluZygyKTtpZihoZXgubGVuZ3RoJTIpe2lmKG9wdGlvbnMuaGV4UGFkPT09XCJsZWZ0XCIpe2hleD1cIjB4MFwiK2hleC5zdWJzdHJpbmcoMil9ZWxzZSBpZihvcHRpb25zLmhleFBhZD09PVwicmlnaHRcIil7aGV4Kz1cIjBcIn1lbHNle2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsXCJ2YWx1ZVwiLHZhbHVlKX19Y29uc3QgcmVzdWx0PVtdO2ZvcihsZXQgaT0wO2k8aGV4Lmxlbmd0aDtpKz0yKXtyZXN1bHQucHVzaChwYXJzZUludChoZXguc3Vic3RyaW5nKGksaSsyKSwxNikpfXJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKX1pZihpc0J5dGVzKHZhbHVlKSl7cmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHZhbHVlKSl9cmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsXCJ2YWx1ZVwiLHZhbHVlKX1mdW5jdGlvbiBjb25jYXQoaXRlbXMpe2NvbnN0IG9iamVjdHM9aXRlbXMubWFwKGl0ZW09PmFycmF5aWZ5KGl0ZW0pKTtjb25zdCBsZW5ndGg9b2JqZWN0cy5yZWR1Y2UoKGFjY3VtLGl0ZW0pPT5hY2N1bStpdGVtLmxlbmd0aCwwKTtjb25zdCByZXN1bHQ9bmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtvYmplY3RzLnJlZHVjZSgob2Zmc2V0LG9iamVjdCk9PntyZXN1bHQuc2V0KG9iamVjdCxvZmZzZXQpO3JldHVybiBvZmZzZXQrb2JqZWN0Lmxlbmd0aH0sMCk7cmV0dXJuIGFkZFNsaWNlKHJlc3VsdCl9ZnVuY3Rpb24gc3RyaXBaZXJvcyh2YWx1ZSl7bGV0IHJlc3VsdD1hcnJheWlmeSh2YWx1ZSk7aWYocmVzdWx0Lmxlbmd0aD09PTApe3JldHVybiByZXN1bHR9bGV0IHN0YXJ0PTA7d2hpbGUoc3RhcnQ8cmVzdWx0Lmxlbmd0aCYmcmVzdWx0W3N0YXJ0XT09PTApe3N0YXJ0Kyt9aWYoc3RhcnQpe3Jlc3VsdD1yZXN1bHQuc2xpY2Uoc3RhcnQpfXJldHVybiByZXN1bHR9ZnVuY3Rpb24gemVyb1BhZCh2YWx1ZSxsZW5ndGgpe3ZhbHVlPWFycmF5aWZ5KHZhbHVlKTtpZih2YWx1ZS5sZW5ndGg+bGVuZ3RoKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsXCJ2YWx1ZVwiLGFyZ3VtZW50c1swXSl9Y29uc3QgcmVzdWx0PW5ldyBVaW50OEFycmF5KGxlbmd0aCk7cmVzdWx0LnNldCh2YWx1ZSxsZW5ndGgtdmFsdWUubGVuZ3RoKTtyZXR1cm4gYWRkU2xpY2UocmVzdWx0KX1mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSxsZW5ndGgpe2lmKHR5cGVvZiB2YWx1ZSE9PVwic3RyaW5nXCJ8fCF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKXtyZXR1cm4gZmFsc2V9aWYobGVuZ3RoJiZ2YWx1ZS5sZW5ndGghPT0yKzIqbGVuZ3RoKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9Y29uc3QgSGV4Q2hhcmFjdGVycz1cIjAxMjM0NTY3ODlhYmNkZWZcIjtmdW5jdGlvbiBoZXhsaWZ5KHZhbHVlLG9wdGlvbnMpe2lmKCFvcHRpb25zKXtvcHRpb25zPXt9fWlmKHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCIpe2xvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIik7bGV0IGhleD1cIlwiO3doaWxlKHZhbHVlKXtoZXg9SGV4Q2hhcmFjdGVyc1t2YWx1ZSYxNV0raGV4O3ZhbHVlPU1hdGguZmxvb3IodmFsdWUvMTYpfWlmKGhleC5sZW5ndGgpe2lmKGhleC5sZW5ndGglMil7aGV4PVwiMFwiK2hleH1yZXR1cm5cIjB4XCIraGV4fXJldHVyblwiMHgwMFwifWlmKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4JiZ0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiJiZ2YWx1ZS5zdWJzdHJpbmcoMCwyKSE9PVwiMHhcIil7dmFsdWU9XCIweFwiK3ZhbHVlfWlmKGlzSGV4YWJsZSh2YWx1ZSkpe3JldHVybiB2YWx1ZS50b0hleFN0cmluZygpfWlmKGlzSGV4U3RyaW5nKHZhbHVlKSl7aWYodmFsdWUubGVuZ3RoJTIpe2lmKG9wdGlvbnMuaGV4UGFkPT09XCJsZWZ0XCIpe3ZhbHVlPVwiMHgwXCIrdmFsdWUuc3Vic3RyaW5nKDIpfWVsc2UgaWYob3B0aW9ucy5oZXhQYWQ9PT1cInJpZ2h0XCIpe3ZhbHVlKz1cIjBcIn1lbHNle2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsXCJ2YWx1ZVwiLHZhbHVlKX19cmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCl9aWYoaXNCeXRlcyh2YWx1ZSkpe2xldCByZXN1bHQ9XCIweFwiO2ZvcihsZXQgaT0wO2k8dmFsdWUubGVuZ3RoO2krKyl7bGV0IHY9dmFsdWVbaV07cmVzdWx0Kz1IZXhDaGFyYWN0ZXJzWyh2JjI0MCk+PjRdK0hleENoYXJhY3RlcnNbdiYxNV19cmV0dXJuIHJlc3VsdH1yZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiLFwidmFsdWVcIix2YWx1ZSl9ZnVuY3Rpb24gaGV4RGF0YUxlbmd0aChkYXRhKXtpZih0eXBlb2YgZGF0YSE9PVwic3RyaW5nXCIpe2RhdGE9aGV4bGlmeShkYXRhKX1lbHNlIGlmKCFpc0hleFN0cmluZyhkYXRhKXx8ZGF0YS5sZW5ndGglMil7cmV0dXJuIG51bGx9cmV0dXJuKGRhdGEubGVuZ3RoLTIpLzJ9ZnVuY3Rpb24gaGV4RGF0YVNsaWNlKGRhdGEsb2Zmc2V0LGVuZE9mZnNldCl7aWYodHlwZW9mIGRhdGEhPT1cInN0cmluZ1wiKXtkYXRhPWhleGxpZnkoZGF0YSl9ZWxzZSBpZighaXNIZXhTdHJpbmcoZGF0YSl8fGRhdGEubGVuZ3RoJTIpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIixcInZhbHVlXCIsZGF0YSl9b2Zmc2V0PTIrMipvZmZzZXQ7aWYoZW5kT2Zmc2V0IT1udWxsKXtyZXR1cm5cIjB4XCIrZGF0YS5zdWJzdHJpbmcob2Zmc2V0LDIrMiplbmRPZmZzZXQpfXJldHVyblwiMHhcIitkYXRhLnN1YnN0cmluZyhvZmZzZXQpfWZ1bmN0aW9uIGhleENvbmNhdChpdGVtcyl7bGV0IHJlc3VsdD1cIjB4XCI7aXRlbXMuZm9yRWFjaChpdGVtPT57cmVzdWx0Kz1oZXhsaWZ5KGl0ZW0pLnN1YnN0cmluZygyKX0pO3JldHVybiByZXN1bHR9ZnVuY3Rpb24gaGV4VmFsdWUodmFsdWUpe2NvbnN0IHRyaW1tZWQ9aGV4U3RyaXBaZXJvcyhoZXhsaWZ5KHZhbHVlLHtoZXhQYWQ6XCJsZWZ0XCJ9KSk7aWYodHJpbW1lZD09PVwiMHhcIil7cmV0dXJuXCIweDBcIn1yZXR1cm4gdHJpbW1lZH1mdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKXtpZih0eXBlb2YgdmFsdWUhPT1cInN0cmluZ1wiKXt2YWx1ZT1oZXhsaWZ5KHZhbHVlKX1pZighaXNIZXhTdHJpbmcodmFsdWUpKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsXCJ2YWx1ZVwiLHZhbHVlKX12YWx1ZT12YWx1ZS5zdWJzdHJpbmcoMik7bGV0IG9mZnNldD0wO3doaWxlKG9mZnNldDx2YWx1ZS5sZW5ndGgmJnZhbHVlW29mZnNldF09PT1cIjBcIil7b2Zmc2V0Kyt9cmV0dXJuXCIweFwiK3ZhbHVlLnN1YnN0cmluZyhvZmZzZXQpfWZ1bmN0aW9uIGhleFplcm9QYWQodmFsdWUsbGVuZ3RoKXtpZih0eXBlb2YgdmFsdWUhPT1cInN0cmluZ1wiKXt2YWx1ZT1oZXhsaWZ5KHZhbHVlKX1lbHNlIGlmKCFpc0hleFN0cmluZyh2YWx1ZSkpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIixcInZhbHVlXCIsdmFsdWUpfWlmKHZhbHVlLmxlbmd0aD4yKmxlbmd0aCsyKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsXCJ2YWx1ZVwiLGFyZ3VtZW50c1sxXSl9d2hpbGUodmFsdWUubGVuZ3RoPDIqbGVuZ3RoKzIpe3ZhbHVlPVwiMHgwXCIrdmFsdWUuc3Vic3RyaW5nKDIpfXJldHVybiB2YWx1ZX1mdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpe2NvbnN0IHJlc3VsdD17cjpcIjB4XCIsczpcIjB4XCIsX3ZzOlwiMHhcIixyZWNvdmVyeVBhcmFtOjAsdjowfTtpZihpc0J5dGVzTGlrZShzaWduYXR1cmUpKXtjb25zdCBieXRlcz1hcnJheWlmeShzaWduYXR1cmUpO2lmKGJ5dGVzLmxlbmd0aCE9PTY1KXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nOyBtdXN0IGJlIDY1IGJ5dGVzXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfXJlc3VsdC5yPWhleGxpZnkoYnl0ZXMuc2xpY2UoMCwzMikpO3Jlc3VsdC5zPWhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsNjQpKTtyZXN1bHQudj1ieXRlc1s2NF07aWYocmVzdWx0LnY8Mjcpe2lmKHJlc3VsdC52PT09MHx8cmVzdWx0LnY9PT0xKXtyZXN1bHQudis9Mjd9ZWxzZXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgdiBieXRlXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfX1yZXN1bHQucmVjb3ZlcnlQYXJhbT0xLXJlc3VsdC52JTI7aWYocmVzdWx0LnJlY292ZXJ5UGFyYW0pe2J5dGVzWzMyXXw9MTI4fXJlc3VsdC5fdnM9aGV4bGlmeShieXRlcy5zbGljZSgzMiw2NCkpfWVsc2V7cmVzdWx0LnI9c2lnbmF0dXJlLnI7cmVzdWx0LnM9c2lnbmF0dXJlLnM7cmVzdWx0LnY9c2lnbmF0dXJlLnY7cmVzdWx0LnJlY292ZXJ5UGFyYW09c2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07cmVzdWx0Ll92cz1zaWduYXR1cmUuX3ZzO2lmKHJlc3VsdC5fdnMhPW51bGwpe2NvbnN0IHZzPXplcm9QYWQoYXJyYXlpZnkocmVzdWx0Ll92cyksMzIpO3Jlc3VsdC5fdnM9aGV4bGlmeSh2cyk7Y29uc3QgcmVjb3ZlcnlQYXJhbT12c1swXT49MTI4PzE6MDtpZihyZXN1bHQucmVjb3ZlcnlQYXJhbT09bnVsbCl7cmVzdWx0LnJlY292ZXJ5UGFyYW09cmVjb3ZlcnlQYXJhbX1lbHNlIGlmKHJlc3VsdC5yZWNvdmVyeVBhcmFtIT09cmVjb3ZlcnlQYXJhbSl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSByZWNvdmVyeVBhcmFtIG1pc21hdGNoIF92c1wiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX12c1swXSY9MTI3O2NvbnN0IHM9aGV4bGlmeSh2cyk7aWYocmVzdWx0LnM9PW51bGwpe3Jlc3VsdC5zPXN9ZWxzZSBpZihyZXN1bHQucyE9PXMpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgdiBtaXNtYXRjaCBfdnNcIixcInNpZ25hdHVyZVwiLHNpZ25hdHVyZSl9fWlmKHJlc3VsdC5yZWNvdmVyeVBhcmFtPT1udWxsKXtpZihyZXN1bHQudj09bnVsbCl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIixcInNpZ25hdHVyZVwiLHNpZ25hdHVyZSl9ZWxzZSBpZihyZXN1bHQudj09PTB8fHJlc3VsdC52PT09MSl7cmVzdWx0LnJlY292ZXJ5UGFyYW09cmVzdWx0LnZ9ZWxzZXtyZXN1bHQucmVjb3ZlcnlQYXJhbT0xLXJlc3VsdC52JTJ9fWVsc2V7aWYocmVzdWx0LnY9PW51bGwpe3Jlc3VsdC52PTI3K3Jlc3VsdC5yZWNvdmVyeVBhcmFtfWVsc2UgaWYocmVzdWx0LnJlY292ZXJ5UGFyYW0hPT0xLXJlc3VsdC52JTIpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfX1pZihyZXN1bHQucj09bnVsbHx8IWlzSGV4U3RyaW5nKHJlc3VsdC5yKSl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX1lbHNle3Jlc3VsdC5yPWhleFplcm9QYWQocmVzdWx0LnIsMzIpfWlmKHJlc3VsdC5zPT1udWxsfHwhaXNIZXhTdHJpbmcocmVzdWx0LnMpKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIG1pc3Npbmcgb3IgaW52YWxpZCBzXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfWVsc2V7cmVzdWx0LnM9aGV4WmVyb1BhZChyZXN1bHQucywzMil9Y29uc3QgdnM9YXJyYXlpZnkocmVzdWx0LnMpO2lmKHZzWzBdPj0xMjgpe2xvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcyBvdXQgb2YgcmFuZ2VcIixcInNpZ25hdHVyZVwiLHNpZ25hdHVyZSl9aWYocmVzdWx0LnJlY292ZXJ5UGFyYW0pe3ZzWzBdfD0xMjh9Y29uc3QgX3ZzPWhleGxpZnkodnMpO2lmKHJlc3VsdC5fdnMpe2lmKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSl7bG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX1yZXN1bHQuX3ZzPWhleFplcm9QYWQocmVzdWx0Ll92cywzMil9aWYocmVzdWx0Ll92cz09bnVsbCl7cmVzdWx0Ll92cz1fdnN9ZWxzZSBpZihyZXN1bHQuX3ZzIT09X3ZzKXtsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKXtzaWduYXR1cmU9c3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtyZXR1cm4gaGV4bGlmeShjb25jYXQoW3NpZ25hdHVyZS5yLHNpZ25hdHVyZS5zLHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtP1wiMHgxY1wiOlwiMHgxYlwiXSkpfWNvbnN0IHZlcnNpb24kMj1cImJpZ251bWJlci81LjEuMVwiO1widXNlIHN0cmljdFwiO3ZhciBCTj1ibi5CTjtjb25zdCBsb2dnZXIkMT1uZXcgTG9nZ2VyKHZlcnNpb24kMik7Y29uc3QgX2NvbnN0cnVjdG9yR3VhcmQ9e307Y29uc3QgTUFYX1NBRkU9OTAwNzE5OTI1NDc0MDk5MTtmdW5jdGlvbiBpc0JpZ051bWJlcmlzaCh2YWx1ZSl7cmV0dXJuIHZhbHVlIT1udWxsJiYoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKXx8dHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIiYmdmFsdWUlMT09PTB8fHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCImJiEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKXx8aXNIZXhTdHJpbmcodmFsdWUpfHx0eXBlb2YgdmFsdWU9PT1cImJpZ2ludFwifHxpc0J5dGVzKHZhbHVlKSl9bGV0IF93YXJuZWRUb1N0cmluZ1JhZGl4PWZhbHNlO2NsYXNzIEJpZ051bWJlcntjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLGhleCl7bG9nZ2VyJDEuY2hlY2tOZXcobmV3LnRhcmdldCxCaWdOdW1iZXIpO2lmKGNvbnN0cnVjdG9yR3VhcmQhPT1fY29uc3RydWN0b3JHdWFyZCl7bG9nZ2VyJDEudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwibmV3IChCaWdOdW1iZXIpXCJ9KX10aGlzLl9oZXg9aGV4O3RoaXMuX2lzQmlnTnVtYmVyPXRydWU7T2JqZWN0LmZyZWV6ZSh0aGlzKX1mcm9tVHdvcyh2YWx1ZSl7cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZnJvbVR3b3ModmFsdWUpKX10b1R3b3ModmFsdWUpe3JldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnRvVHdvcyh2YWx1ZSkpfWFicygpe2lmKHRoaXMuX2hleFswXT09PVwiLVwiKXtyZXR1cm4gQmlnTnVtYmVyLmZyb20odGhpcy5faGV4LnN1YnN0cmluZygxKSl9cmV0dXJuIHRoaXN9YWRkKG90aGVyKXtyZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5hZGQodG9CTihvdGhlcikpKX1zdWIob3RoZXIpe3JldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnN1Yih0b0JOKG90aGVyKSkpfWRpdihvdGhlcil7Y29uc3Qgbz1CaWdOdW1iZXIuZnJvbShvdGhlcik7aWYoby5pc1plcm8oKSl7dGhyb3dGYXVsdChcImRpdmlzaW9uIGJ5IHplcm9cIixcImRpdlwiKX1yZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5kaXYodG9CTihvdGhlcikpKX1tdWwob3RoZXIpe3JldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm11bCh0b0JOKG90aGVyKSkpfW1vZChvdGhlcil7Y29uc3QgdmFsdWU9dG9CTihvdGhlcik7aWYodmFsdWUuaXNOZWcoKSl7dGhyb3dGYXVsdChcImNhbm5vdCBtb2R1bG8gbmVnYXRpdmUgdmFsdWVzXCIsXCJtb2RcIil9cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudW1vZCh2YWx1ZSkpfXBvdyhvdGhlcil7Y29uc3QgdmFsdWU9dG9CTihvdGhlcik7aWYodmFsdWUuaXNOZWcoKSl7dGhyb3dGYXVsdChcImNhbm5vdCByYWlzZSB0byBuZWdhdGl2ZSB2YWx1ZXNcIixcInBvd1wiKX1yZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5wb3codmFsdWUpKX1hbmQob3RoZXIpe2NvbnN0IHZhbHVlPXRvQk4ob3RoZXIpO2lmKHRoaXMuaXNOZWdhdGl2ZSgpfHx2YWx1ZS5pc05lZygpKXt0aHJvd0ZhdWx0KFwiY2Fubm90ICdhbmQnIG5lZ2F0aXZlIHZhbHVlc1wiLFwiYW5kXCIpfXJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFuZCh2YWx1ZSkpfW9yKG90aGVyKXtjb25zdCB2YWx1ZT10b0JOKG90aGVyKTtpZih0aGlzLmlzTmVnYXRpdmUoKXx8dmFsdWUuaXNOZWcoKSl7dGhyb3dGYXVsdChcImNhbm5vdCAnb3InIG5lZ2F0aXZlIHZhbHVlc1wiLFwib3JcIil9cmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykub3IodmFsdWUpKX14b3Iob3RoZXIpe2NvbnN0IHZhbHVlPXRvQk4ob3RoZXIpO2lmKHRoaXMuaXNOZWdhdGl2ZSgpfHx2YWx1ZS5pc05lZygpKXt0aHJvd0ZhdWx0KFwiY2Fubm90ICd4b3InIG5lZ2F0aXZlIHZhbHVlc1wiLFwieG9yXCIpfXJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnhvcih2YWx1ZSkpfW1hc2sodmFsdWUpe2lmKHRoaXMuaXNOZWdhdGl2ZSgpfHx2YWx1ZTwwKXt0aHJvd0ZhdWx0KFwiY2Fubm90IG1hc2sgbmVnYXRpdmUgdmFsdWVzXCIsXCJtYXNrXCIpfXJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm1hc2tuKHZhbHVlKSl9c2hsKHZhbHVlKXtpZih0aGlzLmlzTmVnYXRpdmUoKXx8dmFsdWU8MCl7dGhyb3dGYXVsdChcImNhbm5vdCBzaGlmdCBuZWdhdGl2ZSB2YWx1ZXNcIixcInNobFwiKX1yZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaGxuKHZhbHVlKSl9c2hyKHZhbHVlKXtpZih0aGlzLmlzTmVnYXRpdmUoKXx8dmFsdWU8MCl7dGhyb3dGYXVsdChcImNhbm5vdCBzaGlmdCBuZWdhdGl2ZSB2YWx1ZXNcIixcInNoclwiKX1yZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaHJuKHZhbHVlKSl9ZXEob3RoZXIpe3JldHVybiB0b0JOKHRoaXMpLmVxKHRvQk4ob3RoZXIpKX1sdChvdGhlcil7cmV0dXJuIHRvQk4odGhpcykubHQodG9CTihvdGhlcikpfWx0ZShvdGhlcil7cmV0dXJuIHRvQk4odGhpcykubHRlKHRvQk4ob3RoZXIpKX1ndChvdGhlcil7cmV0dXJuIHRvQk4odGhpcykuZ3QodG9CTihvdGhlcikpfWd0ZShvdGhlcil7cmV0dXJuIHRvQk4odGhpcykuZ3RlKHRvQk4ob3RoZXIpKX1pc05lZ2F0aXZlKCl7cmV0dXJuIHRoaXMuX2hleFswXT09PVwiLVwifWlzWmVybygpe3JldHVybiB0b0JOKHRoaXMpLmlzWmVybygpfXRvTnVtYmVyKCl7dHJ5e3JldHVybiB0b0JOKHRoaXMpLnRvTnVtYmVyKCl9Y2F0Y2goZXJyb3Ipe3Rocm93RmF1bHQoXCJvdmVyZmxvd1wiLFwidG9OdW1iZXJcIix0aGlzLnRvU3RyaW5nKCkpfXJldHVybiBudWxsfXRvQmlnSW50KCl7dHJ5e3JldHVybiBCaWdJbnQodGhpcy50b1N0cmluZygpKX1jYXRjaChlKXt9cmV0dXJuIGxvZ2dlciQxLnRocm93RXJyb3IoXCJ0aGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se3ZhbHVlOnRoaXMudG9TdHJpbmcoKX0pfXRvU3RyaW5nKCl7aWYoYXJndW1lbnRzLmxlbmd0aD4wKXtpZihhcmd1bWVudHNbMF09PT0xMCl7aWYoIV93YXJuZWRUb1N0cmluZ1JhZGl4KXtfd2FybmVkVG9TdHJpbmdSYWRpeD10cnVlO2xvZ2dlciQxLndhcm4oXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzOyBiYXNlLTEwIGlzIGFzc3VtZWRcIil9fWVsc2UgaWYoYXJndW1lbnRzWzBdPT09MTYpe2xvZ2dlciQxLnRocm93RXJyb3IoXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzOyB1c2UgYmlnTnVtYmVyLnRvSGV4U3RyaW5nKClcIixMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQse30pfWVsc2V7bG9nZ2VyJDEudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyc1wiLExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCx7fSl9fXJldHVybiB0b0JOKHRoaXMpLnRvU3RyaW5nKDEwKX10b0hleFN0cmluZygpe3JldHVybiB0aGlzLl9oZXh9dG9KU09OKGtleSl7cmV0dXJue3R5cGU6XCJCaWdOdW1iZXJcIixoZXg6dGhpcy50b0hleFN0cmluZygpfX1zdGF0aWMgZnJvbSh2YWx1ZSl7aWYodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpe3JldHVybiB2YWx1ZX1pZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtpZih2YWx1ZS5tYXRjaCgvXi0/MHhbMC05YS1mXSskL2kpKXtyZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCx0b0hleCh2YWx1ZSkpfWlmKHZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpe3JldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLHRvSGV4KG5ldyBCTih2YWx1ZSkpKX1yZXR1cm4gbG9nZ2VyJDEudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgc3RyaW5nXCIsXCJ2YWx1ZVwiLHZhbHVlKX1pZih0eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiKXtpZih2YWx1ZSUxKXt0aHJvd0ZhdWx0KFwidW5kZXJmbG93XCIsXCJCaWdOdW1iZXIuZnJvbVwiLHZhbHVlKX1pZih2YWx1ZT49TUFYX1NBRkV8fHZhbHVlPD0tTUFYX1NBRkUpe3Rocm93RmF1bHQoXCJvdmVyZmxvd1wiLFwiQmlnTnVtYmVyLmZyb21cIix2YWx1ZSl9cmV0dXJuIEJpZ051bWJlci5mcm9tKFN0cmluZyh2YWx1ZSkpfWNvbnN0IGFueVZhbHVlPXZhbHVlO2lmKHR5cGVvZiBhbnlWYWx1ZT09PVwiYmlnaW50XCIpe3JldHVybiBCaWdOdW1iZXIuZnJvbShhbnlWYWx1ZS50b1N0cmluZygpKX1pZihpc0J5dGVzKGFueVZhbHVlKSl7cmV0dXJuIEJpZ051bWJlci5mcm9tKGhleGxpZnkoYW55VmFsdWUpKX1pZihhbnlWYWx1ZSl7aWYoYW55VmFsdWUudG9IZXhTdHJpbmcpe2NvbnN0IGhleD1hbnlWYWx1ZS50b0hleFN0cmluZygpO2lmKHR5cGVvZiBoZXg9PT1cInN0cmluZ1wiKXtyZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KX19ZWxzZXtsZXQgaGV4PWFueVZhbHVlLl9oZXg7aWYoaGV4PT1udWxsJiZhbnlWYWx1ZS50eXBlPT09XCJCaWdOdW1iZXJcIil7aGV4PWFueVZhbHVlLmhleH1pZih0eXBlb2YgaGV4PT09XCJzdHJpbmdcIil7aWYoaXNIZXhTdHJpbmcoaGV4KXx8aGV4WzBdPT09XCItXCImJmlzSGV4U3RyaW5nKGhleC5zdWJzdHJpbmcoMSkpKXtyZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KX19fX1yZXR1cm4gbG9nZ2VyJDEudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgdmFsdWVcIixcInZhbHVlXCIsdmFsdWUpfXN0YXRpYyBpc0JpZ051bWJlcih2YWx1ZSl7cmV0dXJuISEodmFsdWUmJnZhbHVlLl9pc0JpZ051bWJlcil9fWZ1bmN0aW9uIHRvSGV4KHZhbHVlKXtpZih0eXBlb2YgdmFsdWUhPT1cInN0cmluZ1wiKXtyZXR1cm4gdG9IZXgodmFsdWUudG9TdHJpbmcoMTYpKX1pZih2YWx1ZVswXT09PVwiLVwiKXt2YWx1ZT12YWx1ZS5zdWJzdHJpbmcoMSk7aWYodmFsdWVbMF09PT1cIi1cIil7bG9nZ2VyJDEudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIixcInZhbHVlXCIsdmFsdWUpfXZhbHVlPXRvSGV4KHZhbHVlKTtpZih2YWx1ZT09PVwiMHgwMFwiKXtyZXR1cm4gdmFsdWV9cmV0dXJuXCItXCIrdmFsdWV9aWYodmFsdWUuc3Vic3RyaW5nKDAsMikhPT1cIjB4XCIpe3ZhbHVlPVwiMHhcIit2YWx1ZX1pZih2YWx1ZT09PVwiMHhcIil7cmV0dXJuXCIweDAwXCJ9aWYodmFsdWUubGVuZ3RoJTIpe3ZhbHVlPVwiMHgwXCIrdmFsdWUuc3Vic3RyaW5nKDIpfXdoaWxlKHZhbHVlLmxlbmd0aD40JiZ2YWx1ZS5zdWJzdHJpbmcoMCw0KT09PVwiMHgwMFwiKXt2YWx1ZT1cIjB4XCIrdmFsdWUuc3Vic3RyaW5nKDQpfXJldHVybiB2YWx1ZX1mdW5jdGlvbiB0b0JpZ051bWJlcih2YWx1ZSl7cmV0dXJuIEJpZ051bWJlci5mcm9tKHRvSGV4KHZhbHVlKSl9ZnVuY3Rpb24gdG9CTih2YWx1ZSl7Y29uc3QgaGV4PUJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpO2lmKGhleFswXT09PVwiLVwiKXtyZXR1cm4gbmV3IEJOKFwiLVwiK2hleC5zdWJzdHJpbmcoMyksMTYpfXJldHVybiBuZXcgQk4oaGV4LnN1YnN0cmluZygyKSwxNil9ZnVuY3Rpb24gdGhyb3dGYXVsdChmYXVsdCxvcGVyYXRpb24sdmFsdWUpe2NvbnN0IHBhcmFtcz17ZmF1bHQ6ZmF1bHQsb3BlcmF0aW9uOm9wZXJhdGlvbn07aWYodmFsdWUhPW51bGwpe3BhcmFtcy52YWx1ZT12YWx1ZX1yZXR1cm4gbG9nZ2VyJDEudGhyb3dFcnJvcihmYXVsdCxMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQscGFyYW1zKX1mdW5jdGlvbiBfYmFzZTM2VG8xNih2YWx1ZSl7cmV0dXJuIG5ldyBCTih2YWx1ZSwzNikudG9TdHJpbmcoMTYpfWZ1bmN0aW9uIF9iYXNlMTZUbzM2KHZhbHVlKXtyZXR1cm4gbmV3IEJOKHZhbHVlLDE2KS50b1N0cmluZygzNil9XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJDI9bmV3IExvZ2dlcih2ZXJzaW9uJDIpO2NvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkJDE9e307Y29uc3QgWmVybz1CaWdOdW1iZXIuZnJvbSgwKTtjb25zdCBOZWdhdGl2ZU9uZT1CaWdOdW1iZXIuZnJvbSgtMSk7ZnVuY3Rpb24gdGhyb3dGYXVsdCQxKG1lc3NhZ2UsZmF1bHQsb3BlcmF0aW9uLHZhbHVlKXtjb25zdCBwYXJhbXM9e2ZhdWx0OmZhdWx0LG9wZXJhdGlvbjpvcGVyYXRpb259O2lmKHZhbHVlIT09dW5kZWZpbmVkKXtwYXJhbXMudmFsdWU9dmFsdWV9cmV0dXJuIGxvZ2dlciQyLnRocm93RXJyb3IobWVzc2FnZSxMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQscGFyYW1zKX1sZXQgemVyb3M9XCIwXCI7d2hpbGUoemVyb3MubGVuZ3RoPDI1Nil7emVyb3MrPXplcm9zfWZ1bmN0aW9uIGdldE11bHRpcGxpZXIoZGVjaW1hbHMpe2lmKHR5cGVvZiBkZWNpbWFscyE9PVwibnVtYmVyXCIpe3RyeXtkZWNpbWFscz1CaWdOdW1iZXIuZnJvbShkZWNpbWFscykudG9OdW1iZXIoKX1jYXRjaChlKXt9fWlmKHR5cGVvZiBkZWNpbWFscz09PVwibnVtYmVyXCImJmRlY2ltYWxzPj0wJiZkZWNpbWFsczw9MjU2JiYhKGRlY2ltYWxzJTEpKXtyZXR1cm5cIjFcIit6ZXJvcy5zdWJzdHJpbmcoMCxkZWNpbWFscyl9cmV0dXJuIGxvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBzaXplXCIsXCJkZWNpbWFsc1wiLGRlY2ltYWxzKX1mdW5jdGlvbiBmb3JtYXRGaXhlZCh2YWx1ZSxkZWNpbWFscyl7aWYoZGVjaW1hbHM9PW51bGwpe2RlY2ltYWxzPTB9Y29uc3QgbXVsdGlwbGllcj1nZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTt2YWx1ZT1CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7Y29uc3QgbmVnYXRpdmU9dmFsdWUubHQoWmVybyk7aWYobmVnYXRpdmUpe3ZhbHVlPXZhbHVlLm11bChOZWdhdGl2ZU9uZSl9bGV0IGZyYWN0aW9uPXZhbHVlLm1vZChtdWx0aXBsaWVyKS50b1N0cmluZygpO3doaWxlKGZyYWN0aW9uLmxlbmd0aDxtdWx0aXBsaWVyLmxlbmd0aC0xKXtmcmFjdGlvbj1cIjBcIitmcmFjdGlvbn1mcmFjdGlvbj1mcmFjdGlvbi5tYXRjaCgvXihbMC05XSpbMS05XXwwKSgwKikvKVsxXTtjb25zdCB3aG9sZT12YWx1ZS5kaXYobXVsdGlwbGllcikudG9TdHJpbmcoKTt2YWx1ZT13aG9sZStcIi5cIitmcmFjdGlvbjtpZihuZWdhdGl2ZSl7dmFsdWU9XCItXCIrdmFsdWV9cmV0dXJuIHZhbHVlfWZ1bmN0aW9uIHBhcnNlRml4ZWQodmFsdWUsZGVjaW1hbHMpe2lmKGRlY2ltYWxzPT1udWxsKXtkZWNpbWFscz0wfWNvbnN0IG11bHRpcGxpZXI9Z2V0TXVsdGlwbGllcihkZWNpbWFscyk7aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcInx8IXZhbHVlLm1hdGNoKC9eLT9bMC05LixdKyQvKSl7bG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHZhbHVlXCIsXCJ2YWx1ZVwiLHZhbHVlKX1pZihtdWx0aXBsaWVyLmxlbmd0aC0xPT09MCl7cmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKX1jb25zdCBuZWdhdGl2ZT12YWx1ZS5zdWJzdHJpbmcoMCwxKT09PVwiLVwiO2lmKG5lZ2F0aXZlKXt2YWx1ZT12YWx1ZS5zdWJzdHJpbmcoMSl9aWYodmFsdWU9PT1cIi5cIil7bG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyB2YWx1ZVwiLFwidmFsdWVcIix2YWx1ZSl9Y29uc3QgY29tcHM9dmFsdWUuc3BsaXQoXCIuXCIpO2lmKGNvbXBzLmxlbmd0aD4yKXtsb2dnZXIkMi50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0b28gbWFueSBkZWNpbWFsIHBvaW50c1wiLFwidmFsdWVcIix2YWx1ZSl9bGV0IHdob2xlPWNvbXBzWzBdLGZyYWN0aW9uPWNvbXBzWzFdO2lmKCF3aG9sZSl7d2hvbGU9XCIwXCJ9aWYoIWZyYWN0aW9uKXtmcmFjdGlvbj1cIjBcIn1pZihmcmFjdGlvbi5sZW5ndGg+bXVsdGlwbGllci5sZW5ndGgtMSl7dGhyb3dGYXVsdCQxKFwiZnJhY3Rpb25hbCBjb21wb25lbnQgZXhjZWVkcyBkZWNpbWFsc1wiLFwidW5kZXJmbG93XCIsXCJwYXJzZUZpeGVkXCIpfXdoaWxlKGZyYWN0aW9uLmxlbmd0aDxtdWx0aXBsaWVyLmxlbmd0aC0xKXtmcmFjdGlvbis9XCIwXCJ9Y29uc3Qgd2hvbGVWYWx1ZT1CaWdOdW1iZXIuZnJvbSh3aG9sZSk7Y29uc3QgZnJhY3Rpb25WYWx1ZT1CaWdOdW1iZXIuZnJvbShmcmFjdGlvbik7bGV0IHdlaT13aG9sZVZhbHVlLm11bChtdWx0aXBsaWVyKS5hZGQoZnJhY3Rpb25WYWx1ZSk7aWYobmVnYXRpdmUpe3dlaT13ZWkubXVsKE5lZ2F0aXZlT25lKX1yZXR1cm4gd2VpfWNsYXNzIEZpeGVkRm9ybWF0e2NvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsc2lnbmVkLHdpZHRoLGRlY2ltYWxzKXtpZihjb25zdHJ1Y3Rvckd1YXJkIT09X2NvbnN0cnVjdG9yR3VhcmQkMSl7bG9nZ2VyJDIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWRGb3JtYXQgY29uc3RydWN0b3I7IHVzZSBGaXhlZEZvcm1hdC5mcm9tXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm5ldyBGaXhlZEZvcm1hdFwifSl9dGhpcy5zaWduZWQ9c2lnbmVkO3RoaXMud2lkdGg9d2lkdGg7dGhpcy5kZWNpbWFscz1kZWNpbWFsczt0aGlzLm5hbWU9KHNpZ25lZD9cIlwiOlwidVwiKStcImZpeGVkXCIrU3RyaW5nKHdpZHRoKStcInhcIitTdHJpbmcoZGVjaW1hbHMpO3RoaXMuX211bHRpcGxpZXI9Z2V0TXVsdGlwbGllcihkZWNpbWFscyk7T2JqZWN0LmZyZWV6ZSh0aGlzKX1zdGF0aWMgZnJvbSh2YWx1ZSl7aWYodmFsdWUgaW5zdGFuY2VvZiBGaXhlZEZvcm1hdCl7cmV0dXJuIHZhbHVlfWxldCBzaWduZWQ9dHJ1ZTtsZXQgd2lkdGg9MTI4O2xldCBkZWNpbWFscz0xODtpZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtpZih2YWx1ZT09PVwiZml4ZWRcIil7fWVsc2UgaWYodmFsdWU9PT1cInVmaXhlZFwiKXtzaWduZWQ9ZmFsc2V9ZWxzZSBpZih2YWx1ZSE9bnVsbCl7Y29uc3QgbWF0Y2g9dmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtpZighbWF0Y2gpe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsXCJmb3JtYXRcIix2YWx1ZSl9c2lnbmVkPW1hdGNoWzFdIT09XCJ1XCI7d2lkdGg9cGFyc2VJbnQobWF0Y2hbMl0pO2RlY2ltYWxzPXBhcnNlSW50KG1hdGNoWzNdKX19ZWxzZSBpZih2YWx1ZSl7Y29uc3QgY2hlY2s9KGtleSx0eXBlLGRlZmF1bHRWYWx1ZSk9PntpZih2YWx1ZVtrZXldPT1udWxsKXtyZXR1cm4gZGVmYXVsdFZhbHVlfWlmKHR5cGVvZiB2YWx1ZVtrZXldIT09dHlwZSl7bG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiK2tleStcIiBub3QgXCIrdHlwZStcIilcIixcImZvcm1hdC5cIitrZXksdmFsdWVba2V5XSl9cmV0dXJuIHZhbHVlW2tleV19O3NpZ25lZD1jaGVjayhcInNpZ25lZFwiLFwiYm9vbGVhblwiLHNpZ25lZCk7d2lkdGg9Y2hlY2soXCJ3aWR0aFwiLFwibnVtYmVyXCIsd2lkdGgpO2RlY2ltYWxzPWNoZWNrKFwiZGVjaW1hbHNcIixcIm51bWJlclwiLGRlY2ltYWxzKX1pZih3aWR0aCU4KXtsb2dnZXIkMi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIixcImZvcm1hdC53aWR0aFwiLHdpZHRoKX1pZihkZWNpbWFscz44MCl7bG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKGRlY2ltYWxzIHRvbyBsYXJnZSlcIixcImZvcm1hdC5kZWNpbWFsc1wiLGRlY2ltYWxzKX1yZXR1cm4gbmV3IEZpeGVkRm9ybWF0KF9jb25zdHJ1Y3Rvckd1YXJkJDEsc2lnbmVkLHdpZHRoLGRlY2ltYWxzKX19Y2xhc3MgRml4ZWROdW1iZXJ7Y29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCxoZXgsdmFsdWUsZm9ybWF0KXtsb2dnZXIkMi5jaGVja05ldyhuZXcudGFyZ2V0LEZpeGVkTnVtYmVyKTtpZihjb25zdHJ1Y3Rvckd1YXJkIT09X2NvbnN0cnVjdG9yR3VhcmQkMSl7bG9nZ2VyJDIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWROdW1iZXIgY29uc3RydWN0b3I7IHVzZSBGaXhlZE51bWJlci5mcm9tXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm5ldyBGaXhlZEZvcm1hdFwifSl9dGhpcy5mb3JtYXQ9Zm9ybWF0O3RoaXMuX2hleD1oZXg7dGhpcy5fdmFsdWU9dmFsdWU7dGhpcy5faXNGaXhlZE51bWJlcj10cnVlO09iamVjdC5mcmVlemUodGhpcyl9X2NoZWNrRm9ybWF0KG90aGVyKXtpZih0aGlzLmZvcm1hdC5uYW1lIT09b3RoZXIuZm9ybWF0Lm5hbWUpe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImluY29tcGF0aWJsZSBmb3JtYXQ7IHVzZSBmaXhlZE51bWJlci50b0Zvcm1hdFwiLFwib3RoZXJcIixvdGhlcil9fWFkZFVuc2FmZShvdGhlcil7dGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO2NvbnN0IGE9cGFyc2VGaXhlZCh0aGlzLl92YWx1ZSx0aGlzLmZvcm1hdC5kZWNpbWFscyk7Y29uc3QgYj1wYXJzZUZpeGVkKG90aGVyLl92YWx1ZSxvdGhlci5mb3JtYXQuZGVjaW1hbHMpO3JldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5hZGQoYiksdGhpcy5mb3JtYXQuZGVjaW1hbHMsdGhpcy5mb3JtYXQpfXN1YlVuc2FmZShvdGhlcil7dGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO2NvbnN0IGE9cGFyc2VGaXhlZCh0aGlzLl92YWx1ZSx0aGlzLmZvcm1hdC5kZWNpbWFscyk7Y29uc3QgYj1wYXJzZUZpeGVkKG90aGVyLl92YWx1ZSxvdGhlci5mb3JtYXQuZGVjaW1hbHMpO3JldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5zdWIoYiksdGhpcy5mb3JtYXQuZGVjaW1hbHMsdGhpcy5mb3JtYXQpfW11bFVuc2FmZShvdGhlcil7dGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO2NvbnN0IGE9cGFyc2VGaXhlZCh0aGlzLl92YWx1ZSx0aGlzLmZvcm1hdC5kZWNpbWFscyk7Y29uc3QgYj1wYXJzZUZpeGVkKG90aGVyLl92YWx1ZSxvdGhlci5mb3JtYXQuZGVjaW1hbHMpO3JldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwoYikuZGl2KHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKSx0aGlzLmZvcm1hdC5kZWNpbWFscyx0aGlzLmZvcm1hdCl9ZGl2VW5zYWZlKG90aGVyKXt0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7Y29uc3QgYT1wYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtjb25zdCBiPXBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLG90aGVyLmZvcm1hdC5kZWNpbWFscyk7cmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bCh0aGlzLmZvcm1hdC5fbXVsdGlwbGllcikuZGl2KGIpLHRoaXMuZm9ybWF0LmRlY2ltYWxzLHRoaXMuZm9ybWF0KX1mbG9vcigpe2xldCBjb21wcz10aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO2xldCByZXN1bHQ9Rml4ZWROdW1iZXIuZnJvbShjb21wc1swXSx0aGlzLmZvcm1hdCk7Y29uc3QgaGFzRnJhY3Rpb249IWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtpZih0aGlzLmlzTmVnYXRpdmUoKSYmaGFzRnJhY3Rpb24pe3Jlc3VsdD1yZXN1bHQuc3ViVW5zYWZlKE9ORSl9cmV0dXJuIHJlc3VsdH1jZWlsaW5nKCl7bGV0IGNvbXBzPXRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7bGV0IHJlc3VsdD1GaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLHRoaXMuZm9ybWF0KTtjb25zdCBoYXNGcmFjdGlvbj0hY29tcHNbMV0ubWF0Y2goL14oMCopJC8pO2lmKCF0aGlzLmlzTmVnYXRpdmUoKSYmaGFzRnJhY3Rpb24pe3Jlc3VsdD1yZXN1bHQuYWRkVW5zYWZlKE9ORSl9cmV0dXJuIHJlc3VsdH1yb3VuZChkZWNpbWFscyl7aWYoZGVjaW1hbHM9PW51bGwpe2RlY2ltYWxzPTB9bGV0IGNvbXBzPXRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7aWYoZGVjaW1hbHM8MHx8ZGVjaW1hbHM+ODB8fGRlY2ltYWxzJTEpe2xvZ2dlciQyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBjb3VudFwiLFwiZGVjaW1hbHNcIixkZWNpbWFscyl9aWYoY29tcHNbMV0ubGVuZ3RoPD1kZWNpbWFscyl7cmV0dXJuIHRoaXN9Y29uc3QgZmFjdG9yPUZpeGVkTnVtYmVyLmZyb20oXCIxXCIremVyb3Muc3Vic3RyaW5nKDAsZGVjaW1hbHMpKTtyZXR1cm4gdGhpcy5tdWxVbnNhZmUoZmFjdG9yKS5hZGRVbnNhZmUoQlVNUCkuZmxvb3IoKS5kaXZVbnNhZmUoZmFjdG9yKX1pc1plcm8oKXtyZXR1cm4gdGhpcy5fdmFsdWU9PT1cIjAuMFwifWlzTmVnYXRpdmUoKXtyZXR1cm4gdGhpcy5fdmFsdWVbMF09PT1cIi1cIn10b1N0cmluZygpe3JldHVybiB0aGlzLl92YWx1ZX10b0hleFN0cmluZyh3aWR0aCl7aWYod2lkdGg9PW51bGwpe3JldHVybiB0aGlzLl9oZXh9aWYod2lkdGglOCl7bG9nZ2VyJDIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlIHdpZHRoXCIsXCJ3aWR0aFwiLHdpZHRoKX1jb25zdCBoZXg9QmlnTnVtYmVyLmZyb20odGhpcy5faGV4KS5mcm9tVHdvcyh0aGlzLmZvcm1hdC53aWR0aCkudG9Ud29zKHdpZHRoKS50b0hleFN0cmluZygpO3JldHVybiBoZXhaZXJvUGFkKGhleCx3aWR0aC84KX10b1Vuc2FmZUZsb2F0KCl7cmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKX10b0Zvcm1hdChmb3JtYXQpe3JldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMuX3ZhbHVlLGZvcm1hdCl9c3RhdGljIGZyb21WYWx1ZSh2YWx1ZSxkZWNpbWFscyxmb3JtYXQpe2lmKGZvcm1hdD09bnVsbCYmZGVjaW1hbHMhPW51bGwmJiFpc0JpZ051bWJlcmlzaChkZWNpbWFscykpe2Zvcm1hdD1kZWNpbWFscztkZWNpbWFscz1udWxsfWlmKGRlY2ltYWxzPT1udWxsKXtkZWNpbWFscz0wfWlmKGZvcm1hdD09bnVsbCl7Zm9ybWF0PVwiZml4ZWRcIn1yZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhmb3JtYXRGaXhlZCh2YWx1ZSxkZWNpbWFscyksRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpKX1zdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSxmb3JtYXQpe2lmKGZvcm1hdD09bnVsbCl7Zm9ybWF0PVwiZml4ZWRcIn1jb25zdCBmaXhlZEZvcm1hdD1GaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCk7Y29uc3QgbnVtZXJpYz1wYXJzZUZpeGVkKHZhbHVlLGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtpZighZml4ZWRGb3JtYXQuc2lnbmVkJiZudW1lcmljLmx0KFplcm8pKXt0aHJvd0ZhdWx0JDEoXCJ1bnNpZ25lZCB2YWx1ZSBjYW5ub3QgYmUgbmVnYXRpdmVcIixcIm92ZXJmbG93XCIsXCJ2YWx1ZVwiLHZhbHVlKX1sZXQgaGV4PW51bGw7aWYoZml4ZWRGb3JtYXQuc2lnbmVkKXtoZXg9bnVtZXJpYy50b1R3b3MoZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCl9ZWxzZXtoZXg9bnVtZXJpYy50b0hleFN0cmluZygpO2hleD1oZXhaZXJvUGFkKGhleCxmaXhlZEZvcm1hdC53aWR0aC84KX1jb25zdCBkZWNpbWFsPWZvcm1hdEZpeGVkKG51bWVyaWMsZml4ZWRGb3JtYXQuZGVjaW1hbHMpO3JldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQkMSxoZXgsZGVjaW1hbCxmaXhlZEZvcm1hdCl9c3RhdGljIGZyb21CeXRlcyh2YWx1ZSxmb3JtYXQpe2lmKGZvcm1hdD09bnVsbCl7Zm9ybWF0PVwiZml4ZWRcIn1jb25zdCBmaXhlZEZvcm1hdD1GaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCk7aWYoYXJyYXlpZnkodmFsdWUpLmxlbmd0aD5maXhlZEZvcm1hdC53aWR0aC84KXt0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvd1wiKX1sZXQgbnVtZXJpYz1CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7aWYoZml4ZWRGb3JtYXQuc2lnbmVkKXtudW1lcmljPW51bWVyaWMuZnJvbVR3b3MoZml4ZWRGb3JtYXQud2lkdGgpfWNvbnN0IGhleD1udW1lcmljLnRvVHdvcygoZml4ZWRGb3JtYXQuc2lnbmVkPzA6MSkrZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7Y29uc3QgZGVjaW1hbD1mb3JtYXRGaXhlZChudW1lcmljLGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtyZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkJDEsaGV4LGRlY2ltYWwsZml4ZWRGb3JtYXQpfXN0YXRpYyBmcm9tKHZhbHVlLGZvcm1hdCl7aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7cmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsZm9ybWF0KX1pZihpc0J5dGVzKHZhbHVlKSl7cmV0dXJuIEZpeGVkTnVtYmVyLmZyb21CeXRlcyh2YWx1ZSxmb3JtYXQpfXRyeXtyZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLDAsZm9ybWF0KX1jYXRjaChlcnJvcil7aWYoZXJyb3IuY29kZSE9PUxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCl7dGhyb3cgZXJyb3J9fXJldHVybiBsb2dnZXIkMi50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHZhbHVlXCIsXCJ2YWx1ZVwiLHZhbHVlKX1zdGF0aWMgaXNGaXhlZE51bWJlcih2YWx1ZSl7cmV0dXJuISEodmFsdWUmJnZhbHVlLl9pc0ZpeGVkTnVtYmVyKX19Y29uc3QgT05FPUZpeGVkTnVtYmVyLmZyb20oMSk7Y29uc3QgQlVNUD1GaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO2NvbnN0IHZlcnNpb24kMz1cInByb3BlcnRpZXMvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkMz1uZXcgTG9nZ2VyKHZlcnNpb24kMyk7ZnVuY3Rpb24gZGVmaW5lUmVhZE9ubHkob2JqZWN0LG5hbWUsdmFsdWUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsbmFtZSx7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOnZhbHVlLHdyaXRhYmxlOmZhbHNlfSl9ZnVuY3Rpb24gZ2V0U3RhdGljKGN0b3Isa2V5KXtmb3IobGV0IGk9MDtpPDMyO2krKyl7aWYoY3RvcltrZXldKXtyZXR1cm4gY3RvcltrZXldfWlmKCFjdG9yLnByb3RvdHlwZXx8dHlwZW9mIGN0b3IucHJvdG90eXBlIT09XCJvYmplY3RcIil7YnJlYWt9Y3Rvcj1PYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUpLmNvbnN0cnVjdG9yfXJldHVybiBudWxsfWZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgcHJvbWlzZXM9T2JqZWN0LmtleXMob2JqZWN0KS5tYXAoa2V5PT57Y29uc3QgdmFsdWU9b2JqZWN0W2tleV07cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbih2PT4oe2tleTprZXksdmFsdWU6dn0pKX0pO2NvbnN0IHJlc3VsdHM9eWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO3JldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0scmVzdWx0KT0+e2FjY3VtW3Jlc3VsdC5rZXldPXJlc3VsdC52YWx1ZTtyZXR1cm4gYWNjdW19LHt9KX0pfWZ1bmN0aW9uIGNoZWNrUHJvcGVydGllcyhvYmplY3QscHJvcGVydGllcyl7aWYoIW9iamVjdHx8dHlwZW9mIG9iamVjdCE9PVwib2JqZWN0XCIpe2xvZ2dlciQzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0XCIsXCJvYmplY3RcIixvYmplY3QpfU9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChrZXk9PntpZighcHJvcGVydGllc1trZXldKXtsb2dnZXIkMy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdCBrZXkgLSBcIitrZXksXCJ0cmFuc2FjdGlvbjpcIitrZXksb2JqZWN0KX19KX1mdW5jdGlvbiBzaGFsbG93Q29weShvYmplY3Qpe2NvbnN0IHJlc3VsdD17fTtmb3IoY29uc3Qga2V5IGluIG9iamVjdCl7cmVzdWx0W2tleV09b2JqZWN0W2tleV19cmV0dXJuIHJlc3VsdH1jb25zdCBvcGFxdWU9e2JpZ2ludDp0cnVlLGJvb2xlYW46dHJ1ZSxmdW5jdGlvbjp0cnVlLG51bWJlcjp0cnVlLHN0cmluZzp0cnVlfTtmdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KXtpZihvYmplY3Q9PT11bmRlZmluZWR8fG9iamVjdD09PW51bGx8fG9wYXF1ZVt0eXBlb2Ygb2JqZWN0XSl7cmV0dXJuIHRydWV9aWYoQXJyYXkuaXNBcnJheShvYmplY3QpfHx0eXBlb2Ygb2JqZWN0PT09XCJvYmplY3RcIil7aWYoIU9iamVjdC5pc0Zyb3plbihvYmplY3QpKXtyZXR1cm4gZmFsc2V9Y29uc3Qga2V5cz1PYmplY3Qua2V5cyhvYmplY3QpO2ZvcihsZXQgaT0wO2k8a2V5cy5sZW5ndGg7aSsrKXtpZighX2lzRnJvemVuKG9iamVjdFtrZXlzW2ldXSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9cmV0dXJuIGxvZ2dlciQzLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIG9iamVjdH1gLFwib2JqZWN0XCIsb2JqZWN0KX1mdW5jdGlvbiBfZGVlcENvcHkob2JqZWN0KXtpZihfaXNGcm96ZW4ob2JqZWN0KSl7cmV0dXJuIG9iamVjdH1pZihBcnJheS5pc0FycmF5KG9iamVjdCkpe3JldHVybiBPYmplY3QuZnJlZXplKG9iamVjdC5tYXAoaXRlbT0+ZGVlcENvcHkoaXRlbSkpKX1pZih0eXBlb2Ygb2JqZWN0PT09XCJvYmplY3RcIil7Y29uc3QgcmVzdWx0PXt9O2Zvcihjb25zdCBrZXkgaW4gb2JqZWN0KXtjb25zdCB2YWx1ZT1vYmplY3Rba2V5XTtpZih2YWx1ZT09PXVuZGVmaW5lZCl7Y29udGludWV9ZGVmaW5lUmVhZE9ubHkocmVzdWx0LGtleSxkZWVwQ29weSh2YWx1ZSkpfXJldHVybiByZXN1bHR9cmV0dXJuIGxvZ2dlciQzLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIG9iamVjdH1gLFwib2JqZWN0XCIsb2JqZWN0KX1mdW5jdGlvbiBkZWVwQ29weShvYmplY3Qpe3JldHVybiBfZGVlcENvcHkob2JqZWN0KX1jbGFzcyBEZXNjcmlwdGlvbntjb25zdHJ1Y3RvcihpbmZvKXtmb3IoY29uc3Qga2V5IGluIGluZm8pe3RoaXNba2V5XT1kZWVwQ29weShpbmZvW2tleV0pfX19Y29uc3QgdmVyc2lvbiQ0PVwiYWJpLzUuMS4yXCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJDQ9bmV3IExvZ2dlcih2ZXJzaW9uJDQpO2NvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkJDI9e307bGV0IE1vZGlmaWVyc0J5dGVzPXtjYWxsZGF0YTp0cnVlLG1lbW9yeTp0cnVlLHN0b3JhZ2U6dHJ1ZX07bGV0IE1vZGlmaWVyc05lc3Q9e2NhbGxkYXRhOnRydWUsbWVtb3J5OnRydWV9O2Z1bmN0aW9uIGNoZWNrTW9kaWZpZXIodHlwZSxuYW1lKXtpZih0eXBlPT09XCJieXRlc1wifHx0eXBlPT09XCJzdHJpbmdcIil7aWYoTW9kaWZpZXJzQnl0ZXNbbmFtZV0pe3JldHVybiB0cnVlfX1lbHNlIGlmKHR5cGU9PT1cImFkZHJlc3NcIil7aWYobmFtZT09PVwicGF5YWJsZVwiKXtyZXR1cm4gdHJ1ZX19ZWxzZSBpZih0eXBlLmluZGV4T2YoXCJbXCIpPj0wfHx0eXBlPT09XCJ0dXBsZVwiKXtpZihNb2RpZmllcnNOZXN0W25hbWVdKXtyZXR1cm4gdHJ1ZX19aWYoTW9kaWZpZXJzQnl0ZXNbbmFtZV18fG5hbWU9PT1cInBheWFibGVcIil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBtb2RpZmllclwiLFwibmFtZVwiLG5hbWUpfXJldHVybiBmYWxzZX1mdW5jdGlvbiBwYXJzZVBhcmFtVHlwZShwYXJhbSxhbGxvd0luZGV4ZWQpe2xldCBvcmlnaW5hbFBhcmFtPXBhcmFtO2Z1bmN0aW9uIHRocm93RXJyb3IoaSl7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBwb3NpdGlvbiAke2l9YCxcInBhcmFtXCIscGFyYW0pfXBhcmFtPXBhcmFtLnJlcGxhY2UoL1xccy9nLFwiIFwiKTtmdW5jdGlvbiBuZXdOb2RlKHBhcmVudCl7bGV0IG5vZGU9e3R5cGU6XCJcIixuYW1lOlwiXCIscGFyZW50OnBhcmVudCxzdGF0ZTp7YWxsb3dUeXBlOnRydWV9fTtpZihhbGxvd0luZGV4ZWQpe25vZGUuaW5kZXhlZD1mYWxzZX1yZXR1cm4gbm9kZX1sZXQgcGFyZW50PXt0eXBlOlwiXCIsbmFtZTpcIlwiLHN0YXRlOnthbGxvd1R5cGU6dHJ1ZX19O2xldCBub2RlPXBhcmVudDtmb3IobGV0IGk9MDtpPHBhcmFtLmxlbmd0aDtpKyspe2xldCBjPXBhcmFtW2ldO3N3aXRjaChjKXtjYXNlXCIoXCI6aWYobm9kZS5zdGF0ZS5hbGxvd1R5cGUmJm5vZGUudHlwZT09PVwiXCIpe25vZGUudHlwZT1cInR1cGxlXCJ9ZWxzZSBpZighbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcyl7dGhyb3dFcnJvcihpKX1ub2RlLnN0YXRlLmFsbG93VHlwZT1mYWxzZTtub2RlLnR5cGU9dmVyaWZ5VHlwZShub2RlLnR5cGUpO25vZGUuY29tcG9uZW50cz1bbmV3Tm9kZShub2RlKV07bm9kZT1ub2RlLmNvbXBvbmVudHNbMF07YnJlYWs7Y2FzZVwiKVwiOmRlbGV0ZSBub2RlLnN0YXRlO2lmKG5vZGUubmFtZT09PVwiaW5kZXhlZFwiKXtpZighYWxsb3dJbmRleGVkKXt0aHJvd0Vycm9yKGkpfW5vZGUuaW5kZXhlZD10cnVlO25vZGUubmFtZT1cIlwifWlmKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLG5vZGUubmFtZSkpe25vZGUubmFtZT1cIlwifW5vZGUudHlwZT12ZXJpZnlUeXBlKG5vZGUudHlwZSk7bGV0IGNoaWxkPW5vZGU7bm9kZT1ub2RlLnBhcmVudDtpZighbm9kZSl7dGhyb3dFcnJvcihpKX1kZWxldGUgY2hpbGQucGFyZW50O25vZGUuc3RhdGUuYWxsb3dQYXJhbXM9ZmFsc2U7bm9kZS5zdGF0ZS5hbGxvd05hbWU9dHJ1ZTtub2RlLnN0YXRlLmFsbG93QXJyYXk9dHJ1ZTticmVhaztjYXNlXCIsXCI6ZGVsZXRlIG5vZGUuc3RhdGU7aWYobm9kZS5uYW1lPT09XCJpbmRleGVkXCIpe2lmKCFhbGxvd0luZGV4ZWQpe3Rocm93RXJyb3IoaSl9bm9kZS5pbmRleGVkPXRydWU7bm9kZS5uYW1lPVwiXCJ9aWYoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsbm9kZS5uYW1lKSl7bm9kZS5uYW1lPVwiXCJ9bm9kZS50eXBlPXZlcmlmeVR5cGUobm9kZS50eXBlKTtsZXQgc2libGluZz1uZXdOb2RlKG5vZGUucGFyZW50KTtub2RlLnBhcmVudC5jb21wb25lbnRzLnB1c2goc2libGluZyk7ZGVsZXRlIG5vZGUucGFyZW50O25vZGU9c2libGluZzticmVhaztjYXNlXCIgXCI6aWYobm9kZS5zdGF0ZS5hbGxvd1R5cGUpe2lmKG5vZGUudHlwZSE9PVwiXCIpe25vZGUudHlwZT12ZXJpZnlUeXBlKG5vZGUudHlwZSk7ZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dUeXBlO25vZGUuc3RhdGUuYWxsb3dOYW1lPXRydWU7bm9kZS5zdGF0ZS5hbGxvd1BhcmFtcz10cnVlfX1pZihub2RlLnN0YXRlLmFsbG93TmFtZSl7aWYobm9kZS5uYW1lIT09XCJcIil7aWYobm9kZS5uYW1lPT09XCJpbmRleGVkXCIpe2lmKCFhbGxvd0luZGV4ZWQpe3Rocm93RXJyb3IoaSl9aWYobm9kZS5pbmRleGVkKXt0aHJvd0Vycm9yKGkpfW5vZGUuaW5kZXhlZD10cnVlO25vZGUubmFtZT1cIlwifWVsc2UgaWYoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsbm9kZS5uYW1lKSl7bm9kZS5uYW1lPVwiXCJ9ZWxzZXtub2RlLnN0YXRlLmFsbG93TmFtZT1mYWxzZX19fWJyZWFrO2Nhc2VcIltcIjppZighbm9kZS5zdGF0ZS5hbGxvd0FycmF5KXt0aHJvd0Vycm9yKGkpfW5vZGUudHlwZSs9Yztub2RlLnN0YXRlLmFsbG93QXJyYXk9ZmFsc2U7bm9kZS5zdGF0ZS5hbGxvd05hbWU9ZmFsc2U7bm9kZS5zdGF0ZS5yZWFkQXJyYXk9dHJ1ZTticmVhaztjYXNlXCJdXCI6aWYoIW5vZGUuc3RhdGUucmVhZEFycmF5KXt0aHJvd0Vycm9yKGkpfW5vZGUudHlwZSs9Yztub2RlLnN0YXRlLnJlYWRBcnJheT1mYWxzZTtub2RlLnN0YXRlLmFsbG93QXJyYXk9dHJ1ZTtub2RlLnN0YXRlLmFsbG93TmFtZT10cnVlO2JyZWFrO2RlZmF1bHQ6aWYobm9kZS5zdGF0ZS5hbGxvd1R5cGUpe25vZGUudHlwZSs9Yztub2RlLnN0YXRlLmFsbG93UGFyYW1zPXRydWU7bm9kZS5zdGF0ZS5hbGxvd0FycmF5PXRydWV9ZWxzZSBpZihub2RlLnN0YXRlLmFsbG93TmFtZSl7bm9kZS5uYW1lKz1jO2RlbGV0ZSBub2RlLnN0YXRlLmFsbG93QXJyYXl9ZWxzZSBpZihub2RlLnN0YXRlLnJlYWRBcnJheSl7bm9kZS50eXBlKz1jfWVsc2V7dGhyb3dFcnJvcihpKX19fWlmKG5vZGUucGFyZW50KXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIGVvZlwiLFwicGFyYW1cIixwYXJhbSl9ZGVsZXRlIHBhcmVudC5zdGF0ZTtpZihub2RlLm5hbWU9PT1cImluZGV4ZWRcIil7aWYoIWFsbG93SW5kZXhlZCl7dGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aC03KX1pZihub2RlLmluZGV4ZWQpe3Rocm93RXJyb3Iob3JpZ2luYWxQYXJhbS5sZW5ndGgtNyl9bm9kZS5pbmRleGVkPXRydWU7bm9kZS5uYW1lPVwiXCJ9ZWxzZSBpZihjaGVja01vZGlmaWVyKG5vZGUudHlwZSxub2RlLm5hbWUpKXtub2RlLm5hbWU9XCJcIn1wYXJlbnQudHlwZT12ZXJpZnlUeXBlKHBhcmVudC50eXBlKTtyZXR1cm4gcGFyZW50fWZ1bmN0aW9uIHBvcHVsYXRlKG9iamVjdCxwYXJhbXMpe2ZvcihsZXQga2V5IGluIHBhcmFtcyl7ZGVmaW5lUmVhZE9ubHkob2JqZWN0LGtleSxwYXJhbXNba2V5XSl9fWNvbnN0IEZvcm1hdFR5cGVzPU9iamVjdC5mcmVlemUoe3NpZ2hhc2g6XCJzaWdoYXNoXCIsbWluaW1hbDpcIm1pbmltYWxcIixmdWxsOlwiZnVsbFwiLGpzb246XCJqc29uXCJ9KTtjb25zdCBwYXJhbVR5cGVBcnJheT1uZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO2NsYXNzIFBhcmFtVHlwZXtjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLHBhcmFtcyl7aWYoY29uc3RydWN0b3JHdWFyZCE9PV9jb25zdHJ1Y3Rvckd1YXJkJDIpe2xvZ2dlciQ0LnRocm93RXJyb3IoXCJ1c2UgZnJvbVN0cmluZ1wiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJuZXcgUGFyYW1UeXBlKClcIn0pfXBvcHVsYXRlKHRoaXMscGFyYW1zKTtsZXQgbWF0Y2g9dGhpcy50eXBlLm1hdGNoKHBhcmFtVHlwZUFycmF5KTtpZihtYXRjaCl7cG9wdWxhdGUodGhpcyx7YXJyYXlMZW5ndGg6cGFyc2VJbnQobWF0Y2hbMl18fFwiLTFcIiksYXJyYXlDaGlsZHJlbjpQYXJhbVR5cGUuZnJvbU9iamVjdCh7dHlwZTptYXRjaFsxXSxjb21wb25lbnRzOnRoaXMuY29tcG9uZW50c30pLGJhc2VUeXBlOlwiYXJyYXlcIn0pfWVsc2V7cG9wdWxhdGUodGhpcyx7YXJyYXlMZW5ndGg6bnVsbCxhcnJheUNoaWxkcmVuOm51bGwsYmFzZVR5cGU6dGhpcy5jb21wb25lbnRzIT1udWxsP1widHVwbGVcIjp0aGlzLnR5cGV9KX10aGlzLl9pc1BhcmFtVHlwZT10cnVlO09iamVjdC5mcmVlemUodGhpcyl9Zm9ybWF0KGZvcm1hdCl7aWYoIWZvcm1hdCl7Zm9ybWF0PUZvcm1hdFR5cGVzLnNpZ2hhc2h9aWYoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIixcImZvcm1hdFwiLGZvcm1hdCl9aWYoZm9ybWF0PT09Rm9ybWF0VHlwZXMuanNvbil7bGV0IHJlc3VsdD17dHlwZTp0aGlzLmJhc2VUeXBlPT09XCJ0dXBsZVwiP1widHVwbGVcIjp0aGlzLnR5cGUsbmFtZTp0aGlzLm5hbWV8fHVuZGVmaW5lZH07aWYodHlwZW9mIHRoaXMuaW5kZXhlZD09PVwiYm9vbGVhblwiKXtyZXN1bHQuaW5kZXhlZD10aGlzLmluZGV4ZWR9aWYodGhpcy5jb21wb25lbnRzKXtyZXN1bHQuY29tcG9uZW50cz10aGlzLmNvbXBvbmVudHMubWFwKGNvbXA9PkpTT04ucGFyc2UoY29tcC5mb3JtYXQoZm9ybWF0KSkpfXJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpfWxldCByZXN1bHQ9XCJcIjtpZih0aGlzLmJhc2VUeXBlPT09XCJhcnJheVwiKXtyZXN1bHQrPXRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtyZXN1bHQrPVwiW1wiKyh0aGlzLmFycmF5TGVuZ3RoPDA/XCJcIjpTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpK1wiXVwifWVsc2V7aWYodGhpcy5iYXNlVHlwZT09PVwidHVwbGVcIil7aWYoZm9ybWF0IT09Rm9ybWF0VHlwZXMuc2lnaGFzaCl7cmVzdWx0Kz10aGlzLnR5cGV9cmVzdWx0Kz1cIihcIit0aGlzLmNvbXBvbmVudHMubWFwKGNvbXA9PmNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oZm9ybWF0PT09Rm9ybWF0VHlwZXMuZnVsbD9cIiwgXCI6XCIsXCIpK1wiKVwifWVsc2V7cmVzdWx0Kz10aGlzLnR5cGV9fWlmKGZvcm1hdCE9PUZvcm1hdFR5cGVzLnNpZ2hhc2gpe2lmKHRoaXMuaW5kZXhlZD09PXRydWUpe3Jlc3VsdCs9XCIgaW5kZXhlZFwifWlmKGZvcm1hdD09PUZvcm1hdFR5cGVzLmZ1bGwmJnRoaXMubmFtZSl7cmVzdWx0Kz1cIiBcIit0aGlzLm5hbWV9fXJldHVybiByZXN1bHR9c3RhdGljIGZyb20odmFsdWUsYWxsb3dJbmRleGVkKXtpZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtyZXR1cm4gUGFyYW1UeXBlLmZyb21TdHJpbmcodmFsdWUsYWxsb3dJbmRleGVkKX1yZXR1cm4gUGFyYW1UeXBlLmZyb21PYmplY3QodmFsdWUpfXN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKXtpZihQYXJhbVR5cGUuaXNQYXJhbVR5cGUodmFsdWUpKXtyZXR1cm4gdmFsdWV9cmV0dXJuIG5ldyBQYXJhbVR5cGUoX2NvbnN0cnVjdG9yR3VhcmQkMix7bmFtZTp2YWx1ZS5uYW1lfHxudWxsLHR5cGU6dmVyaWZ5VHlwZSh2YWx1ZS50eXBlKSxpbmRleGVkOnZhbHVlLmluZGV4ZWQ9PW51bGw/bnVsbDohIXZhbHVlLmluZGV4ZWQsY29tcG9uZW50czp2YWx1ZS5jb21wb25lbnRzP3ZhbHVlLmNvbXBvbmVudHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KTpudWxsfSl9c3RhdGljIGZyb21TdHJpbmcodmFsdWUsYWxsb3dJbmRleGVkKXtmdW5jdGlvbiBQYXJhbVR5cGlmeShub2RlKXtyZXR1cm4gUGFyYW1UeXBlLmZyb21PYmplY3Qoe25hbWU6bm9kZS5uYW1lLHR5cGU6bm9kZS50eXBlLGluZGV4ZWQ6bm9kZS5pbmRleGVkLGNvbXBvbmVudHM6bm9kZS5jb21wb25lbnRzfSl9cmV0dXJuIFBhcmFtVHlwaWZ5KHBhcnNlUGFyYW1UeXBlKHZhbHVlLCEhYWxsb3dJbmRleGVkKSl9c3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKXtyZXR1cm4hISh2YWx1ZSE9bnVsbCYmdmFsdWUuX2lzUGFyYW1UeXBlKX19ZnVuY3Rpb24gcGFyc2VQYXJhbXModmFsdWUsYWxsb3dJbmRleCl7cmV0dXJuIHNwbGl0TmVzdGluZyh2YWx1ZSkubWFwKHBhcmFtPT5QYXJhbVR5cGUuZnJvbVN0cmluZyhwYXJhbSxhbGxvd0luZGV4KSl9Y2xhc3MgRnJhZ21lbnR7Y29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCxwYXJhbXMpe2lmKGNvbnN0cnVjdG9yR3VhcmQhPT1fY29uc3RydWN0b3JHdWFyZCQyKXtsb2dnZXIkNC50aHJvd0Vycm9yKFwidXNlIGEgc3RhdGljIGZyb20gbWV0aG9kXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm5ldyBGcmFnbWVudCgpXCJ9KX1wb3B1bGF0ZSh0aGlzLHBhcmFtcyk7dGhpcy5faXNGcmFnbWVudD10cnVlO09iamVjdC5mcmVlemUodGhpcyl9c3RhdGljIGZyb20odmFsdWUpe2lmKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKXtyZXR1cm4gdmFsdWV9aWYodHlwZW9mIHZhbHVlPT09XCJzdHJpbmdcIil7cmV0dXJuIEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpfXJldHVybiBGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKX1zdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSl7aWYoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpe3JldHVybiB2YWx1ZX1zd2l0Y2godmFsdWUudHlwZSl7Y2FzZVwiZnVuY3Rpb25cIjpyZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtjYXNlXCJldmVudFwiOnJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO2Nhc2VcImNvbnN0cnVjdG9yXCI6cmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7Y2FzZVwiZXJyb3JcIjpjYXNlXCJmYWxsYmFja1wiOmNhc2VcInJlY2VpdmVcIjpyZXR1cm4gbnVsbH1yZXR1cm4gbG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmcmFnbWVudCBvYmplY3RcIixcInZhbHVlXCIsdmFsdWUpfXN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKXt2YWx1ZT12YWx1ZS5yZXBsYWNlKC9cXHMvZyxcIiBcIik7dmFsdWU9dmFsdWUucmVwbGFjZSgvXFwoL2csXCIgKFwiKS5yZXBsYWNlKC9cXCkvZyxcIikgXCIpLnJlcGxhY2UoL1xccysvZyxcIiBcIik7dmFsdWU9dmFsdWUudHJpbSgpO2lmKHZhbHVlLnNwbGl0KFwiIFwiKVswXT09PVwiZXZlbnRcIil7cmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoNSkudHJpbSgpKX1lbHNlIGlmKHZhbHVlLnNwbGl0KFwiIFwiKVswXT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS5zdWJzdHJpbmcoOCkudHJpbSgpKX1lbHNlIGlmKHZhbHVlLnNwbGl0KFwiKFwiKVswXS50cmltKCk9PT1cImNvbnN0cnVjdG9yXCIpe3JldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUudHJpbSgpKX1yZXR1cm4gbG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgZnJhZ21lbnRcIixcInZhbHVlXCIsdmFsdWUpfXN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKXtyZXR1cm4hISh2YWx1ZSYmdmFsdWUuX2lzRnJhZ21lbnQpfX1jbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnR7Zm9ybWF0KGZvcm1hdCl7aWYoIWZvcm1hdCl7Zm9ybWF0PUZvcm1hdFR5cGVzLnNpZ2hhc2h9aWYoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIixcImZvcm1hdFwiLGZvcm1hdCl9aWYoZm9ybWF0PT09Rm9ybWF0VHlwZXMuanNvbil7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt0eXBlOlwiZXZlbnRcIixhbm9ueW1vdXM6dGhpcy5hbm9ueW1vdXMsbmFtZTp0aGlzLm5hbWUsaW5wdXRzOnRoaXMuaW5wdXRzLm1hcChpbnB1dD0+SlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpfSl9bGV0IHJlc3VsdD1cIlwiO2lmKGZvcm1hdCE9PUZvcm1hdFR5cGVzLnNpZ2hhc2gpe3Jlc3VsdCs9XCJldmVudCBcIn1yZXN1bHQrPXRoaXMubmFtZStcIihcIit0aGlzLmlucHV0cy5tYXAoaW5wdXQ9PmlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKGZvcm1hdD09PUZvcm1hdFR5cGVzLmZ1bGw/XCIsIFwiOlwiLFwiKStcIikgXCI7aWYoZm9ybWF0IT09Rm9ybWF0VHlwZXMuc2lnaGFzaCl7aWYodGhpcy5hbm9ueW1vdXMpe3Jlc3VsdCs9XCJhbm9ueW1vdXMgXCJ9fXJldHVybiByZXN1bHQudHJpbSgpfXN0YXRpYyBmcm9tKHZhbHVlKXtpZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtyZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKX1yZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKX1zdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSl7aWYoRXZlbnRGcmFnbWVudC5pc0V2ZW50RnJhZ21lbnQodmFsdWUpKXtyZXR1cm4gdmFsdWV9aWYodmFsdWUudHlwZSE9PVwiZXZlbnRcIil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBvYmplY3RcIixcInZhbHVlXCIsdmFsdWUpfWNvbnN0IHBhcmFtcz17bmFtZTp2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLGFub255bW91czp2YWx1ZS5hbm9ueW1vdXMsaW5wdXRzOnZhbHVlLmlucHV0cz92YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KTpbXSx0eXBlOlwiZXZlbnRcIn07cmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkJDIscGFyYW1zKX1zdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSl7bGV0IG1hdGNoPXZhbHVlLm1hdGNoKHJlZ2V4UGFyZW4pO2lmKCFtYXRjaCl7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBzdHJpbmdcIixcInZhbHVlXCIsdmFsdWUpfWxldCBhbm9ueW1vdXM9ZmFsc2U7bWF0Y2hbM10uc3BsaXQoXCIgXCIpLmZvckVhY2gobW9kaWZpZXI9Pntzd2l0Y2gobW9kaWZpZXIudHJpbSgpKXtjYXNlXCJhbm9ueW1vdXNcIjphbm9ueW1vdXM9dHJ1ZTticmVhaztjYXNlXCJcIjpicmVhaztkZWZhdWx0OmxvZ2dlciQ0Lndhcm4oXCJ1bmtub3duIG1vZGlmaWVyOiBcIittb2RpZmllcil9fSk7cmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh7bmFtZTptYXRjaFsxXS50cmltKCksYW5vbnltb3VzOmFub255bW91cyxpbnB1dHM6cGFyc2VQYXJhbXMobWF0Y2hbMl0sdHJ1ZSksdHlwZTpcImV2ZW50XCJ9KX1zdGF0aWMgaXNFdmVudEZyYWdtZW50KHZhbHVlKXtyZXR1cm4gdmFsdWUmJnZhbHVlLl9pc0ZyYWdtZW50JiZ2YWx1ZS50eXBlPT09XCJldmVudFwifX1mdW5jdGlvbiBwYXJzZUdhcyh2YWx1ZSxwYXJhbXMpe3BhcmFtcy5nYXM9bnVsbDtsZXQgY29tcHM9dmFsdWUuc3BsaXQoXCJAXCIpO2lmKGNvbXBzLmxlbmd0aCE9PTEpe2lmKGNvbXBzLmxlbmd0aD4yKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmVcIixcInZhbHVlXCIsdmFsdWUpfWlmKCFjb21wc1sxXS5tYXRjaCgvXlswLTldKyQvKSl7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBodW1hbi1yZWFkYWJsZSBBQkkgc2lnbmF0dXJlIGdhc1wiLFwidmFsdWVcIix2YWx1ZSl9cGFyYW1zLmdhcz1CaWdOdW1iZXIuZnJvbShjb21wc1sxXSk7cmV0dXJuIGNvbXBzWzBdfXJldHVybiB2YWx1ZX1mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyh2YWx1ZSxwYXJhbXMpe3BhcmFtcy5jb25zdGFudD1mYWxzZTtwYXJhbXMucGF5YWJsZT1mYWxzZTtwYXJhbXMuc3RhdGVNdXRhYmlsaXR5PVwibm9ucGF5YWJsZVwiO3ZhbHVlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKG1vZGlmaWVyPT57c3dpdGNoKG1vZGlmaWVyLnRyaW0oKSl7Y2FzZVwiY29uc3RhbnRcIjpwYXJhbXMuY29uc3RhbnQ9dHJ1ZTticmVhaztjYXNlXCJwYXlhYmxlXCI6cGFyYW1zLnBheWFibGU9dHJ1ZTtwYXJhbXMuc3RhdGVNdXRhYmlsaXR5PVwicGF5YWJsZVwiO2JyZWFrO2Nhc2VcIm5vbnBheWFibGVcIjpwYXJhbXMucGF5YWJsZT1mYWxzZTtwYXJhbXMuc3RhdGVNdXRhYmlsaXR5PVwibm9ucGF5YWJsZVwiO2JyZWFrO2Nhc2VcInB1cmVcIjpwYXJhbXMuY29uc3RhbnQ9dHJ1ZTtwYXJhbXMuc3RhdGVNdXRhYmlsaXR5PVwicHVyZVwiO2JyZWFrO2Nhc2VcInZpZXdcIjpwYXJhbXMuY29uc3RhbnQ9dHJ1ZTtwYXJhbXMuc3RhdGVNdXRhYmlsaXR5PVwidmlld1wiO2JyZWFrO2Nhc2VcImV4dGVybmFsXCI6Y2FzZVwicHVibGljXCI6Y2FzZVwiXCI6YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmxvZyhcInVua25vd24gbW9kaWZpZXI6IFwiK21vZGlmaWVyKX19KX1mdW5jdGlvbiB2ZXJpZnlTdGF0ZSh2YWx1ZSl7bGV0IHJlc3VsdD17Y29uc3RhbnQ6ZmFsc2UscGF5YWJsZTp0cnVlLHN0YXRlTXV0YWJpbGl0eTpcInBheWFibGVcIn07aWYodmFsdWUuc3RhdGVNdXRhYmlsaXR5IT1udWxsKXtyZXN1bHQuc3RhdGVNdXRhYmlsaXR5PXZhbHVlLnN0YXRlTXV0YWJpbGl0eTtyZXN1bHQuY29uc3RhbnQ9cmVzdWx0LnN0YXRlTXV0YWJpbGl0eT09PVwidmlld1wifHxyZXN1bHQuc3RhdGVNdXRhYmlsaXR5PT09XCJwdXJlXCI7aWYodmFsdWUuY29uc3RhbnQhPW51bGwpe2lmKCEhdmFsdWUuY29uc3RhbnQhPT1yZXN1bHQuY29uc3RhbnQpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBoYXZlIGNvbnN0YW50IGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIityZXN1bHQuc3RhdGVNdXRhYmlsaXR5LFwidmFsdWVcIix2YWx1ZSl9fXJlc3VsdC5wYXlhYmxlPXJlc3VsdC5zdGF0ZU11dGFiaWxpdHk9PT1cInBheWFibGVcIjtpZih2YWx1ZS5wYXlhYmxlIT1udWxsKXtpZighIXZhbHVlLnBheWFibGUhPT1yZXN1bHQucGF5YWJsZSl7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgcGF5YWJsZSBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIrcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSxcInZhbHVlXCIsdmFsdWUpfX19ZWxzZSBpZih2YWx1ZS5wYXlhYmxlIT1udWxsKXtyZXN1bHQucGF5YWJsZT0hIXZhbHVlLnBheWFibGU7aWYodmFsdWUuY29uc3RhbnQ9PW51bGwmJiFyZXN1bHQucGF5YWJsZSYmdmFsdWUudHlwZSE9PVwiY29uc3RydWN0b3JcIil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwidW5hYmxlIHRvIGRldGVybWluZSBzdGF0ZU11dGFiaWxpdHlcIixcInZhbHVlXCIsdmFsdWUpfXJlc3VsdC5jb25zdGFudD0hIXZhbHVlLmNvbnN0YW50O2lmKHJlc3VsdC5jb25zdGFudCl7cmVzdWx0LnN0YXRlTXV0YWJpbGl0eT1cInZpZXdcIn1lbHNle3Jlc3VsdC5zdGF0ZU11dGFiaWxpdHk9cmVzdWx0LnBheWFibGU/XCJwYXlhYmxlXCI6XCJub25wYXlhYmxlXCJ9aWYocmVzdWx0LnBheWFibGUmJnJlc3VsdC5jb25zdGFudCl7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgY29uc3RhbnQgcGF5YWJsZSBmdW5jdGlvblwiLFwidmFsdWVcIix2YWx1ZSl9fWVsc2UgaWYodmFsdWUuY29uc3RhbnQhPW51bGwpe3Jlc3VsdC5jb25zdGFudD0hIXZhbHVlLmNvbnN0YW50O3Jlc3VsdC5wYXlhYmxlPSFyZXN1bHQuY29uc3RhbnQ7cmVzdWx0LnN0YXRlTXV0YWJpbGl0eT1yZXN1bHQuY29uc3RhbnQ/XCJ2aWV3XCI6XCJwYXlhYmxlXCJ9ZWxzZSBpZih2YWx1ZS50eXBlIT09XCJjb25zdHJ1Y3RvclwiKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLFwidmFsdWVcIix2YWx1ZSl9cmV0dXJuIHJlc3VsdH1jbGFzcyBDb25zdHJ1Y3RvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnR7Zm9ybWF0KGZvcm1hdCl7aWYoIWZvcm1hdCl7Zm9ybWF0PUZvcm1hdFR5cGVzLnNpZ2hhc2h9aWYoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIixcImZvcm1hdFwiLGZvcm1hdCl9aWYoZm9ybWF0PT09Rm9ybWF0VHlwZXMuanNvbil7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt0eXBlOlwiY29uc3RydWN0b3JcIixzdGF0ZU11dGFiaWxpdHk6dGhpcy5zdGF0ZU11dGFiaWxpdHkhPT1cIm5vbnBheWFibGVcIj90aGlzLnN0YXRlTXV0YWJpbGl0eTp1bmRlZmluZWQscGF5YWJsZTp0aGlzLnBheWFibGUsZ2FzOnRoaXMuZ2FzP3RoaXMuZ2FzLnRvTnVtYmVyKCk6dW5kZWZpbmVkLGlucHV0czp0aGlzLmlucHV0cy5tYXAoaW5wdXQ9PkpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKX0pfWlmKGZvcm1hdD09PUZvcm1hdFR5cGVzLnNpZ2hhc2gpe2xvZ2dlciQ0LnRocm93RXJyb3IoXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiZm9ybWF0KHNpZ2hhc2gpXCJ9KX1sZXQgcmVzdWx0PVwiY29uc3RydWN0b3IoXCIrdGhpcy5pbnB1dHMubWFwKGlucHV0PT5pbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5mdWxsP1wiLCBcIjpcIixcIikrXCIpIFwiO2lmKHRoaXMuc3RhdGVNdXRhYmlsaXR5JiZ0aGlzLnN0YXRlTXV0YWJpbGl0eSE9PVwibm9ucGF5YWJsZVwiKXtyZXN1bHQrPXRoaXMuc3RhdGVNdXRhYmlsaXR5K1wiIFwifXJldHVybiByZXN1bHQudHJpbSgpfXN0YXRpYyBmcm9tKHZhbHVlKXtpZih0eXBlb2YgdmFsdWU9PT1cInN0cmluZ1wiKXtyZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKX1yZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKX1zdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSl7aWYoQ29uc3RydWN0b3JGcmFnbWVudC5pc0NvbnN0cnVjdG9yRnJhZ21lbnQodmFsdWUpKXtyZXR1cm4gdmFsdWV9aWYodmFsdWUudHlwZSE9PVwiY29uc3RydWN0b3JcIil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBvYmplY3RcIixcInZhbHVlXCIsdmFsdWUpfWxldCBzdGF0ZT12ZXJpZnlTdGF0ZSh2YWx1ZSk7aWYoc3RhdGUuY29uc3RhbnQpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjb25zdGFudFwiLFwidmFsdWVcIix2YWx1ZSl9Y29uc3QgcGFyYW1zPXtuYW1lOm51bGwsdHlwZTp2YWx1ZS50eXBlLGlucHV0czp2YWx1ZS5pbnB1dHM/dmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCk6W10scGF5YWJsZTpzdGF0ZS5wYXlhYmxlLHN0YXRlTXV0YWJpbGl0eTpzdGF0ZS5zdGF0ZU11dGFiaWxpdHksZ2FzOnZhbHVlLmdhcz9CaWdOdW1iZXIuZnJvbSh2YWx1ZS5nYXMpOm51bGx9O3JldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCQyLHBhcmFtcyl9c3RhdGljIGZyb21TdHJpbmcodmFsdWUpe2xldCBwYXJhbXM9e3R5cGU6XCJjb25zdHJ1Y3RvclwifTt2YWx1ZT1wYXJzZUdhcyh2YWx1ZSxwYXJhbXMpO2xldCBwYXJlbnM9dmFsdWUubWF0Y2gocmVnZXhQYXJlbik7aWYoIXBhcmVuc3x8cGFyZW5zWzFdLnRyaW0oKSE9PVwiY29uc3RydWN0b3JcIil7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBzdHJpbmdcIixcInZhbHVlXCIsdmFsdWUpfXBhcmFtcy5pbnB1dHM9cGFyc2VQYXJhbXMocGFyZW5zWzJdLnRyaW0oKSxmYWxzZSk7cGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSxwYXJhbXMpO3JldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKX1zdGF0aWMgaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKXtyZXR1cm4gdmFsdWUmJnZhbHVlLl9pc0ZyYWdtZW50JiZ2YWx1ZS50eXBlPT09XCJjb25zdHJ1Y3RvclwifX1jbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgQ29uc3RydWN0b3JGcmFnbWVudHtmb3JtYXQoZm9ybWF0KXtpZighZm9ybWF0KXtmb3JtYXQ9Rm9ybWF0VHlwZXMuc2lnaGFzaH1pZighRm9ybWF0VHlwZXNbZm9ybWF0XSl7bG9nZ2VyJDQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLFwiZm9ybWF0XCIsZm9ybWF0KX1pZihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5qc29uKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoe3R5cGU6XCJmdW5jdGlvblwiLG5hbWU6dGhpcy5uYW1lLGNvbnN0YW50OnRoaXMuY29uc3RhbnQsc3RhdGVNdXRhYmlsaXR5OnRoaXMuc3RhdGVNdXRhYmlsaXR5IT09XCJub25wYXlhYmxlXCI/dGhpcy5zdGF0ZU11dGFiaWxpdHk6dW5kZWZpbmVkLHBheWFibGU6dGhpcy5wYXlhYmxlLGdhczp0aGlzLmdhcz90aGlzLmdhcy50b051bWJlcigpOnVuZGVmaW5lZCxpbnB1dHM6dGhpcy5pbnB1dHMubWFwKGlucHV0PT5KU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksb3V0cHV0czp0aGlzLm91dHB1dHMubWFwKG91dHB1dD0+SlNPTi5wYXJzZShvdXRwdXQuZm9ybWF0KGZvcm1hdCkpKX0pfWxldCByZXN1bHQ9XCJcIjtpZihmb3JtYXQhPT1Gb3JtYXRUeXBlcy5zaWdoYXNoKXtyZXN1bHQrPVwiZnVuY3Rpb24gXCJ9cmVzdWx0Kz10aGlzLm5hbWUrXCIoXCIrdGhpcy5pbnB1dHMubWFwKGlucHV0PT5pbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5mdWxsP1wiLCBcIjpcIixcIikrXCIpIFwiO2lmKGZvcm1hdCE9PUZvcm1hdFR5cGVzLnNpZ2hhc2gpe2lmKHRoaXMuc3RhdGVNdXRhYmlsaXR5KXtpZih0aGlzLnN0YXRlTXV0YWJpbGl0eSE9PVwibm9ucGF5YWJsZVwiKXtyZXN1bHQrPXRoaXMuc3RhdGVNdXRhYmlsaXR5K1wiIFwifX1lbHNlIGlmKHRoaXMuY29uc3RhbnQpe3Jlc3VsdCs9XCJ2aWV3IFwifWlmKHRoaXMub3V0cHV0cyYmdGhpcy5vdXRwdXRzLmxlbmd0aCl7cmVzdWx0Kz1cInJldHVybnMgKFwiK3RoaXMub3V0cHV0cy5tYXAob3V0cHV0PT5vdXRwdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oXCIsIFwiKStcIikgXCJ9aWYodGhpcy5nYXMhPW51bGwpe3Jlc3VsdCs9XCJAXCIrdGhpcy5nYXMudG9TdHJpbmcoKStcIiBcIn19cmV0dXJuIHJlc3VsdC50cmltKCl9c3RhdGljIGZyb20odmFsdWUpe2lmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe3JldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpfXJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpfXN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKXtpZihGdW5jdGlvbkZyYWdtZW50LmlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkpe3JldHVybiB2YWx1ZX1pZih2YWx1ZS50eXBlIT09XCJmdW5jdGlvblwiKXtsb2dnZXIkNC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIG9iamVjdFwiLFwidmFsdWVcIix2YWx1ZSl9bGV0IHN0YXRlPXZlcmlmeVN0YXRlKHZhbHVlKTtjb25zdCBwYXJhbXM9e3R5cGU6dmFsdWUudHlwZSxuYW1lOnZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksY29uc3RhbnQ6c3RhdGUuY29uc3RhbnQsaW5wdXRzOnZhbHVlLmlucHV0cz92YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KTpbXSxvdXRwdXRzOnZhbHVlLm91dHB1dHM/dmFsdWUub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpOltdLHBheWFibGU6c3RhdGUucGF5YWJsZSxzdGF0ZU11dGFiaWxpdHk6c3RhdGUuc3RhdGVNdXRhYmlsaXR5LGdhczp2YWx1ZS5nYXM/QmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKTpudWxsfTtyZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQkMixwYXJhbXMpfXN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKXtsZXQgcGFyYW1zPXt0eXBlOlwiZnVuY3Rpb25cIn07dmFsdWU9cGFyc2VHYXModmFsdWUscGFyYW1zKTtsZXQgY29tcHM9dmFsdWUuc3BsaXQoXCIgcmV0dXJucyBcIik7aWYoY29tcHMubGVuZ3RoPjIpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc3RyaW5nXCIsXCJ2YWx1ZVwiLHZhbHVlKX1sZXQgcGFyZW5zPWNvbXBzWzBdLm1hdGNoKHJlZ2V4UGFyZW4pO2lmKCFwYXJlbnMpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc2lnbmF0dXJlXCIsXCJ2YWx1ZVwiLHZhbHVlKX1wYXJhbXMubmFtZT1wYXJlbnNbMV0udHJpbSgpO2lmKHBhcmFtcy5uYW1lKXt2ZXJpZnlJZGVudGlmaWVyKHBhcmFtcy5uYW1lKX1wYXJhbXMuaW5wdXRzPXBhcnNlUGFyYW1zKHBhcmVuc1syXSxmYWxzZSk7cGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSxwYXJhbXMpO2lmKGNvbXBzLmxlbmd0aD4xKXtsZXQgcmV0dXJucz1jb21wc1sxXS5tYXRjaChyZWdleFBhcmVuKTtpZihyZXR1cm5zWzFdLnRyaW0oKSE9XCJcInx8cmV0dXJuc1szXS50cmltKCkhPVwiXCIpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5zXCIsXCJ2YWx1ZVwiLHZhbHVlKX1wYXJhbXMub3V0cHV0cz1wYXJzZVBhcmFtcyhyZXR1cm5zWzJdLGZhbHNlKX1lbHNle3BhcmFtcy5vdXRwdXRzPVtdfXJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKX1zdGF0aWMgaXNGdW5jdGlvbkZyYWdtZW50KHZhbHVlKXtyZXR1cm4gdmFsdWUmJnZhbHVlLl9pc0ZyYWdtZW50JiZ2YWx1ZS50eXBlPT09XCJmdW5jdGlvblwifX1mdW5jdGlvbiB2ZXJpZnlUeXBlKHR5cGUpe2lmKHR5cGUubWF0Y2goL151aW50KCR8W14xLTldKS8pKXt0eXBlPVwidWludDI1NlwiK3R5cGUuc3Vic3RyaW5nKDQpfWVsc2UgaWYodHlwZS5tYXRjaCgvXmludCgkfFteMS05XSkvKSl7dHlwZT1cImludDI1NlwiK3R5cGUuc3Vic3RyaW5nKDMpfXJldHVybiB0eXBlfWNvbnN0IHJlZ2V4SWRlbnRpZmllcj1uZXcgUmVnRXhwKFwiXltBLVphLXpfXVtBLVphLXowLTlfXSokXCIpO2Z1bmN0aW9uIHZlcmlmeUlkZW50aWZpZXIodmFsdWUpe2lmKCF2YWx1ZXx8IXZhbHVlLm1hdGNoKHJlZ2V4SWRlbnRpZmllcikpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBpZGVudGlmaWVyIFwiJHt2YWx1ZX1cImAsXCJ2YWx1ZVwiLHZhbHVlKX1yZXR1cm4gdmFsdWV9Y29uc3QgcmVnZXhQYXJlbj1uZXcgUmVnRXhwKFwiXihbXikoXSopXFxcXCgoLiopXFxcXCkoW14pKF0qKSRcIik7ZnVuY3Rpb24gc3BsaXROZXN0aW5nKHZhbHVlKXt2YWx1ZT12YWx1ZS50cmltKCk7bGV0IHJlc3VsdD1bXTtsZXQgYWNjdW09XCJcIjtsZXQgZGVwdGg9MDtmb3IobGV0IG9mZnNldD0wO29mZnNldDx2YWx1ZS5sZW5ndGg7b2Zmc2V0Kyspe2xldCBjPXZhbHVlW29mZnNldF07aWYoYz09PVwiLFwiJiZkZXB0aD09PTApe3Jlc3VsdC5wdXNoKGFjY3VtKTthY2N1bT1cIlwifWVsc2V7YWNjdW0rPWM7aWYoYz09PVwiKFwiKXtkZXB0aCsrfWVsc2UgaWYoYz09PVwiKVwiKXtkZXB0aC0tO2lmKGRlcHRoPT09LTEpe2xvZ2dlciQ0LnRocm93QXJndW1lbnRFcnJvcihcInVuYmFsYW5jZWQgcGFyZW50aGVzaXNcIixcInZhbHVlXCIsdmFsdWUpfX19fWlmKGFjY3VtKXtyZXN1bHQucHVzaChhY2N1bSl9cmV0dXJuIHJlc3VsdH1cInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkNT1uZXcgTG9nZ2VyKHZlcnNpb24kNCk7ZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KXtjb25zdCBlcnJvcnM9W107Y29uc3QgY2hlY2tFcnJvcnM9ZnVuY3Rpb24ocGF0aCxvYmplY3Qpe2lmKCFBcnJheS5pc0FycmF5KG9iamVjdCkpe3JldHVybn1mb3IobGV0IGtleSBpbiBvYmplY3Qpe2NvbnN0IGNoaWxkUGF0aD1wYXRoLnNsaWNlKCk7Y2hpbGRQYXRoLnB1c2goa2V5KTt0cnl7Y2hlY2tFcnJvcnMoY2hpbGRQYXRoLG9iamVjdFtrZXldKX1jYXRjaChlcnJvcil7ZXJyb3JzLnB1c2goe3BhdGg6Y2hpbGRQYXRoLGVycm9yOmVycm9yfSl9fX07Y2hlY2tFcnJvcnMoW10scmVzdWx0KTtyZXR1cm4gZXJyb3JzfWNsYXNzIENvZGVye2NvbnN0cnVjdG9yKG5hbWUsdHlwZSxsb2NhbE5hbWUsZHluYW1pYyl7dGhpcy5uYW1lPW5hbWU7dGhpcy50eXBlPXR5cGU7dGhpcy5sb2NhbE5hbWU9bG9jYWxOYW1lO3RoaXMuZHluYW1pYz1keW5hbWljfV90aHJvd0Vycm9yKG1lc3NhZ2UsdmFsdWUpe2xvZ2dlciQ1LnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLHRoaXMubG9jYWxOYW1lLHZhbHVlKX19Y2xhc3MgV3JpdGVye2NvbnN0cnVjdG9yKHdvcmRTaXplKXtkZWZpbmVSZWFkT25seSh0aGlzLFwid29yZFNpemVcIix3b3JkU2l6ZXx8MzIpO3RoaXMuX2RhdGE9W107dGhpcy5fZGF0YUxlbmd0aD0wO3RoaXMuX3BhZGRpbmc9bmV3IFVpbnQ4QXJyYXkod29yZFNpemUpfWdldCBkYXRhKCl7cmV0dXJuIGhleENvbmNhdCh0aGlzLl9kYXRhKX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2RhdGFMZW5ndGh9X3dyaXRlRGF0YShkYXRhKXt0aGlzLl9kYXRhLnB1c2goZGF0YSk7dGhpcy5fZGF0YUxlbmd0aCs9ZGF0YS5sZW5ndGg7cmV0dXJuIGRhdGEubGVuZ3RofWFwcGVuZFdyaXRlcih3cml0ZXIpe3JldHVybiB0aGlzLl93cml0ZURhdGEoY29uY2F0KHdyaXRlci5fZGF0YSkpfXdyaXRlQnl0ZXModmFsdWUpe2xldCBieXRlcz1hcnJheWlmeSh2YWx1ZSk7Y29uc3QgcGFkZGluZ09mZnNldD1ieXRlcy5sZW5ndGgldGhpcy53b3JkU2l6ZTtpZihwYWRkaW5nT2Zmc2V0KXtieXRlcz1jb25jYXQoW2J5dGVzLHRoaXMuX3BhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKX1yZXR1cm4gdGhpcy5fd3JpdGVEYXRhKGJ5dGVzKX1fZ2V0VmFsdWUodmFsdWUpe2xldCBieXRlcz1hcnJheWlmeShCaWdOdW1iZXIuZnJvbSh2YWx1ZSkpO2lmKGJ5dGVzLmxlbmd0aD50aGlzLndvcmRTaXplKXtsb2dnZXIkNS50aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4se2xlbmd0aDp0aGlzLndvcmRTaXplLG9mZnNldDpieXRlcy5sZW5ndGh9KX1pZihieXRlcy5sZW5ndGgldGhpcy53b3JkU2l6ZSl7Ynl0ZXM9Y29uY2F0KFt0aGlzLl9wYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCV0aGlzLndvcmRTaXplKSxieXRlc10pfXJldHVybiBieXRlc313cml0ZVZhbHVlKHZhbHVlKXtyZXR1cm4gdGhpcy5fd3JpdGVEYXRhKHRoaXMuX2dldFZhbHVlKHZhbHVlKSl9d3JpdGVVcGRhdGFibGVWYWx1ZSgpe2NvbnN0IG9mZnNldD10aGlzLl9kYXRhLmxlbmd0aDt0aGlzLl9kYXRhLnB1c2godGhpcy5fcGFkZGluZyk7dGhpcy5fZGF0YUxlbmd0aCs9dGhpcy53b3JkU2l6ZTtyZXR1cm4gdmFsdWU9Pnt0aGlzLl9kYXRhW29mZnNldF09dGhpcy5fZ2V0VmFsdWUodmFsdWUpfX19Y2xhc3MgUmVhZGVye2NvbnN0cnVjdG9yKGRhdGEsd29yZFNpemUsY29lcmNlRnVuYyxhbGxvd0xvb3NlKXtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2RhdGFcIixhcnJheWlmeShkYXRhKSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIndvcmRTaXplXCIsd29yZFNpemV8fDMyKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2NvZXJjZUZ1bmNcIixjb2VyY2VGdW5jKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYWxsb3dMb29zZVwiLGFsbG93TG9vc2UpO3RoaXMuX29mZnNldD0wfWdldCBkYXRhKCl7cmV0dXJuIGhleGxpZnkodGhpcy5fZGF0YSl9Z2V0IGNvbnN1bWVkKCl7cmV0dXJuIHRoaXMuX29mZnNldH1zdGF0aWMgY29lcmNlKG5hbWUsdmFsdWUpe2xldCBtYXRjaD1uYW1lLm1hdGNoKFwiXnU/aW50KFswLTldKykkXCIpO2lmKG1hdGNoJiZwYXJzZUludChtYXRjaFsxXSk8PTQ4KXt2YWx1ZT12YWx1ZS50b051bWJlcigpfXJldHVybiB2YWx1ZX1jb2VyY2UobmFtZSx2YWx1ZSl7aWYodGhpcy5fY29lcmNlRnVuYyl7cmV0dXJuIHRoaXMuX2NvZXJjZUZ1bmMobmFtZSx2YWx1ZSl9cmV0dXJuIFJlYWRlci5jb2VyY2UobmFtZSx2YWx1ZSl9X3BlZWtCeXRlcyhvZmZzZXQsbGVuZ3RoLGxvb3NlKXtsZXQgYWxpZ25lZExlbmd0aD1NYXRoLmNlaWwobGVuZ3RoL3RoaXMud29yZFNpemUpKnRoaXMud29yZFNpemU7aWYodGhpcy5fb2Zmc2V0K2FsaWduZWRMZW5ndGg+dGhpcy5fZGF0YS5sZW5ndGgpe2lmKHRoaXMuYWxsb3dMb29zZSYmbG9vc2UmJnRoaXMuX29mZnNldCtsZW5ndGg8PXRoaXMuX2RhdGEubGVuZ3RoKXthbGlnbmVkTGVuZ3RoPWxlbmd0aH1lbHNle2xvZ2dlciQ1LnRocm93RXJyb3IoXCJkYXRhIG91dC1vZi1ib3VuZHNcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHtsZW5ndGg6dGhpcy5fZGF0YS5sZW5ndGgsb2Zmc2V0OnRoaXMuX29mZnNldCthbGlnbmVkTGVuZ3RofSl9fXJldHVybiB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX29mZnNldCx0aGlzLl9vZmZzZXQrYWxpZ25lZExlbmd0aCl9c3ViUmVhZGVyKG9mZnNldCl7cmV0dXJuIG5ldyBSZWFkZXIodGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQrb2Zmc2V0KSx0aGlzLndvcmRTaXplLHRoaXMuX2NvZXJjZUZ1bmMsdGhpcy5hbGxvd0xvb3NlKX1yZWFkQnl0ZXMobGVuZ3RoLGxvb3NlKXtsZXQgYnl0ZXM9dGhpcy5fcGVla0J5dGVzKDAsbGVuZ3RoLCEhbG9vc2UpO3RoaXMuX29mZnNldCs9Ynl0ZXMubGVuZ3RoO3JldHVybiBieXRlcy5zbGljZSgwLGxlbmd0aCl9cmVhZFZhbHVlKCl7cmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMucmVhZEJ5dGVzKHRoaXMud29yZFNpemUpKX19dmFyIHNoYTM9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24obW9kdWxlKXsoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgcm9vdD10eXBlb2Ygd2luZG93PT09XCJvYmplY3RcIj93aW5kb3c6e307dmFyIE5PREVfSlM9IXJvb3QuSlNfU0hBM19OT19OT0RFX0pTJiZ0eXBlb2YgcHJvY2Vzcz09PVwib2JqZWN0XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZTtpZihOT0RFX0pTKXtyb290PWNvbW1vbmpzR2xvYmFsfXZhciBDT01NT05fSlM9IXJvb3QuSlNfU0hBM19OT19DT01NT05fSlMmJlwib2JqZWN0XCI9PT1cIm9iamVjdFwiJiZtb2R1bGUuZXhwb3J0czt2YXIgSEVYX0NIQVJTPVwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpO3ZhciBTSEFLRV9QQURESU5HPVszMSw3OTM2LDIwMzE2MTYsNTIwMDkzNjk2XTt2YXIgS0VDQ0FLX1BBRERJTkc9WzEsMjU2LDY1NTM2LDE2Nzc3MjE2XTt2YXIgUEFERElORz1bNiwxNTM2LDM5MzIxNiwxMDA2NjMyOTZdO3ZhciBTSElGVD1bMCw4LDE2LDI0XTt2YXIgUkM9WzEsMCwzMjg5OCwwLDMyOTA2LDIxNDc0ODM2NDgsMjE0NzUxNjQxNiwyMTQ3NDgzNjQ4LDMyOTA3LDAsMjE0NzQ4MzY0OSwwLDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjc3NywyMTQ3NDgzNjQ4LDEzOCwwLDEzNiwwLDIxNDc1MTY0MjUsMCwyMTQ3NDgzNjU4LDAsMjE0NzUxNjU1NSwwLDEzOSwyMTQ3NDgzNjQ4LDMyOTA1LDIxNDc0ODM2NDgsMzI3NzEsMjE0NzQ4MzY0OCwzMjc3MCwyMTQ3NDgzNjQ4LDEyOCwyMTQ3NDgzNjQ4LDMyNzc4LDAsMjE0NzQ4MzY1OCwyMTQ3NDgzNjQ4LDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjg5NiwyMTQ3NDgzNjQ4LDIxNDc0ODM2NDksMCwyMTQ3NTE2NDI0LDIxNDc0ODM2NDhdO3ZhciBCSVRTPVsyMjQsMjU2LDM4NCw1MTJdO3ZhciBTSEFLRV9CSVRTPVsxMjgsMjU2XTt2YXIgT1VUUFVUX1RZUEVTPVtcImhleFwiLFwiYnVmZmVyXCIsXCJhcnJheUJ1ZmZlclwiLFwiYXJyYXlcIl07dmFyIGNyZWF0ZU91dHB1dE1ldGhvZD1mdW5jdGlvbihiaXRzLHBhZGRpbmcsb3V0cHV0VHlwZSl7cmV0dXJuIGZ1bmN0aW9uKG1lc3NhZ2Upe3JldHVybiBuZXcgS2VjY2FrKGJpdHMscGFkZGluZyxiaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKX19O3ZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZD1mdW5jdGlvbihiaXRzLHBhZGRpbmcsb3V0cHV0VHlwZSl7cmV0dXJuIGZ1bmN0aW9uKG1lc3NhZ2Usb3V0cHV0Qml0cyl7cmV0dXJuIG5ldyBLZWNjYWsoYml0cyxwYWRkaW5nLG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpfX07dmFyIGNyZWF0ZU1ldGhvZD1mdW5jdGlvbihiaXRzLHBhZGRpbmcpe3ZhciBtZXRob2Q9Y3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMscGFkZGluZyxcImhleFwiKTttZXRob2QuY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBLZWNjYWsoYml0cyxwYWRkaW5nLGJpdHMpfTttZXRob2QudXBkYXRlPWZ1bmN0aW9uKG1lc3NhZ2Upe3JldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpfTtmb3IodmFyIGk9MDtpPE9VVFBVVF9UWVBFUy5sZW5ndGg7KytpKXt2YXIgdHlwZT1PVVRQVVRfVFlQRVNbaV07bWV0aG9kW3R5cGVdPWNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLHBhZGRpbmcsdHlwZSl9cmV0dXJuIG1ldGhvZH07dmFyIGNyZWF0ZVNoYWtlTWV0aG9kPWZ1bmN0aW9uKGJpdHMscGFkZGluZyl7dmFyIG1ldGhvZD1jcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLHBhZGRpbmcsXCJoZXhcIik7bWV0aG9kLmNyZWF0ZT1mdW5jdGlvbihvdXRwdXRCaXRzKXtyZXR1cm4gbmV3IEtlY2NhayhiaXRzLHBhZGRpbmcsb3V0cHV0Qml0cyl9O21ldGhvZC51cGRhdGU9ZnVuY3Rpb24obWVzc2FnZSxvdXRwdXRCaXRzKXtyZXR1cm4gbWV0aG9kLmNyZWF0ZShvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSl9O2Zvcih2YXIgaT0wO2k8T1VUUFVUX1RZUEVTLmxlbmd0aDsrK2kpe3ZhciB0eXBlPU9VVFBVVF9UWVBFU1tpXTttZXRob2RbdHlwZV09Y3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cyxwYWRkaW5nLHR5cGUpfXJldHVybiBtZXRob2R9O3ZhciBhbGdvcml0aG1zPVt7bmFtZTpcImtlY2Nha1wiLHBhZGRpbmc6S0VDQ0FLX1BBRERJTkcsYml0czpCSVRTLGNyZWF0ZU1ldGhvZDpjcmVhdGVNZXRob2R9LHtuYW1lOlwic2hhM1wiLHBhZGRpbmc6UEFERElORyxiaXRzOkJJVFMsY3JlYXRlTWV0aG9kOmNyZWF0ZU1ldGhvZH0se25hbWU6XCJzaGFrZVwiLHBhZGRpbmc6U0hBS0VfUEFERElORyxiaXRzOlNIQUtFX0JJVFMsY3JlYXRlTWV0aG9kOmNyZWF0ZVNoYWtlTWV0aG9kfV07dmFyIG1ldGhvZHM9e30sbWV0aG9kTmFtZXM9W107Zm9yKHZhciBpPTA7aTxhbGdvcml0aG1zLmxlbmd0aDsrK2kpe3ZhciBhbGdvcml0aG09YWxnb3JpdGhtc1tpXTt2YXIgYml0cz1hbGdvcml0aG0uYml0cztmb3IodmFyIGo9MDtqPGJpdHMubGVuZ3RoOysrail7dmFyIG1ldGhvZE5hbWU9YWxnb3JpdGhtLm5hbWUrXCJfXCIrYml0c1tqXTttZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO21ldGhvZHNbbWV0aG9kTmFtZV09YWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLGFsZ29yaXRobS5wYWRkaW5nKX19ZnVuY3Rpb24gS2VjY2FrKGJpdHMscGFkZGluZyxvdXRwdXRCaXRzKXt0aGlzLmJsb2Nrcz1bXTt0aGlzLnM9W107dGhpcy5wYWRkaW5nPXBhZGRpbmc7dGhpcy5vdXRwdXRCaXRzPW91dHB1dEJpdHM7dGhpcy5yZXNldD10cnVlO3RoaXMuYmxvY2s9MDt0aGlzLnN0YXJ0PTA7dGhpcy5ibG9ja0NvdW50PTE2MDAtKGJpdHM8PDEpPj41O3RoaXMuYnl0ZUNvdW50PXRoaXMuYmxvY2tDb3VudDw8Mjt0aGlzLm91dHB1dEJsb2Nrcz1vdXRwdXRCaXRzPj41O3RoaXMuZXh0cmFCeXRlcz0ob3V0cHV0Qml0cyYzMSk+PjM7Zm9yKHZhciBpPTA7aTw1MDsrK2kpe3RoaXMuc1tpXT0wfX1LZWNjYWsucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihtZXNzYWdlKXt2YXIgbm90U3RyaW5nPXR5cGVvZiBtZXNzYWdlIT09XCJzdHJpbmdcIjtpZihub3RTdHJpbmcmJm1lc3NhZ2UuY29uc3RydWN0b3I9PT1BcnJheUJ1ZmZlcil7bWVzc2FnZT1uZXcgVWludDhBcnJheShtZXNzYWdlKX12YXIgbGVuZ3RoPW1lc3NhZ2UubGVuZ3RoLGJsb2Nrcz10aGlzLmJsb2NrcyxieXRlQ291bnQ9dGhpcy5ieXRlQ291bnQsYmxvY2tDb3VudD10aGlzLmJsb2NrQ291bnQsaW5kZXg9MCxzPXRoaXMucyxpLGNvZGU7d2hpbGUoaW5kZXg8bGVuZ3RoKXtpZih0aGlzLnJlc2V0KXt0aGlzLnJlc2V0PWZhbHNlO2Jsb2Nrc1swXT10aGlzLmJsb2NrO2ZvcihpPTE7aTxibG9ja0NvdW50KzE7KytpKXtibG9ja3NbaV09MH19aWYobm90U3RyaW5nKXtmb3IoaT10aGlzLnN0YXJ0O2luZGV4PGxlbmd0aCYmaTxieXRlQ291bnQ7KytpbmRleCl7YmxvY2tzW2k+PjJdfD1tZXNzYWdlW2luZGV4XTw8U0hJRlRbaSsrJjNdfX1lbHNle2ZvcihpPXRoaXMuc3RhcnQ7aW5kZXg8bGVuZ3RoJiZpPGJ5dGVDb3VudDsrK2luZGV4KXtjb2RlPW1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7aWYoY29kZTwxMjgpe2Jsb2Nrc1tpPj4yXXw9Y29kZTw8U0hJRlRbaSsrJjNdfWVsc2UgaWYoY29kZTwyMDQ4KXtibG9ja3NbaT4+Ml18PSgxOTJ8Y29kZT4+Nik8PFNISUZUW2krKyYzXTtibG9ja3NbaT4+Ml18PSgxMjh8Y29kZSY2Myk8PFNISUZUW2krKyYzXX1lbHNlIGlmKGNvZGU8NTUyOTZ8fGNvZGU+PTU3MzQ0KXtibG9ja3NbaT4+Ml18PSgyMjR8Y29kZT4+MTIpPDxTSElGVFtpKysmM107YmxvY2tzW2k+PjJdfD0oMTI4fGNvZGU+PjYmNjMpPDxTSElGVFtpKysmM107YmxvY2tzW2k+PjJdfD0oMTI4fGNvZGUmNjMpPDxTSElGVFtpKysmM119ZWxzZXtjb2RlPTY1NTM2KygoY29kZSYxMDIzKTw8MTB8bWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpJjEwMjMpO2Jsb2Nrc1tpPj4yXXw9KDI0MHxjb2RlPj4xOCk8PFNISUZUW2krKyYzXTtibG9ja3NbaT4+Ml18PSgxMjh8Y29kZT4+MTImNjMpPDxTSElGVFtpKysmM107YmxvY2tzW2k+PjJdfD0oMTI4fGNvZGU+PjYmNjMpPDxTSElGVFtpKysmM107YmxvY2tzW2k+PjJdfD0oMTI4fGNvZGUmNjMpPDxTSElGVFtpKysmM119fX10aGlzLmxhc3RCeXRlSW5kZXg9aTtpZihpPj1ieXRlQ291bnQpe3RoaXMuc3RhcnQ9aS1ieXRlQ291bnQ7dGhpcy5ibG9jaz1ibG9ja3NbYmxvY2tDb3VudF07Zm9yKGk9MDtpPGJsb2NrQ291bnQ7KytpKXtzW2ldXj1ibG9ja3NbaV19ZihzKTt0aGlzLnJlc2V0PXRydWV9ZWxzZXt0aGlzLnN0YXJ0PWl9fXJldHVybiB0aGlzfTtLZWNjYWsucHJvdG90eXBlLmZpbmFsaXplPWZ1bmN0aW9uKCl7dmFyIGJsb2Nrcz10aGlzLmJsb2NrcyxpPXRoaXMubGFzdEJ5dGVJbmRleCxibG9ja0NvdW50PXRoaXMuYmxvY2tDb3VudCxzPXRoaXMucztibG9ja3NbaT4+Ml18PXRoaXMucGFkZGluZ1tpJjNdO2lmKHRoaXMubGFzdEJ5dGVJbmRleD09PXRoaXMuYnl0ZUNvdW50KXtibG9ja3NbMF09YmxvY2tzW2Jsb2NrQ291bnRdO2ZvcihpPTE7aTxibG9ja0NvdW50KzE7KytpKXtibG9ja3NbaV09MH19YmxvY2tzW2Jsb2NrQ291bnQtMV18PTIxNDc0ODM2NDg7Zm9yKGk9MDtpPGJsb2NrQ291bnQ7KytpKXtzW2ldXj1ibG9ja3NbaV19ZihzKX07S2VjY2FrLnByb3RvdHlwZS50b1N0cmluZz1LZWNjYWsucHJvdG90eXBlLmhleD1mdW5jdGlvbigpe3RoaXMuZmluYWxpemUoKTt2YXIgYmxvY2tDb3VudD10aGlzLmJsb2NrQ291bnQscz10aGlzLnMsb3V0cHV0QmxvY2tzPXRoaXMub3V0cHV0QmxvY2tzLGV4dHJhQnl0ZXM9dGhpcy5leHRyYUJ5dGVzLGk9MCxqPTA7dmFyIGhleD1cIlwiLGJsb2NrO3doaWxlKGo8b3V0cHV0QmxvY2tzKXtmb3IoaT0wO2k8YmxvY2tDb3VudCYmajxvdXRwdXRCbG9ja3M7KytpLCsrail7YmxvY2s9c1tpXTtoZXgrPUhFWF9DSEFSU1tibG9jaz4+NCYxNV0rSEVYX0NIQVJTW2Jsb2NrJjE1XStIRVhfQ0hBUlNbYmxvY2s+PjEyJjE1XStIRVhfQ0hBUlNbYmxvY2s+PjgmMTVdK0hFWF9DSEFSU1tibG9jaz4+MjAmMTVdK0hFWF9DSEFSU1tibG9jaz4+MTYmMTVdK0hFWF9DSEFSU1tibG9jaz4+MjgmMTVdK0hFWF9DSEFSU1tibG9jaz4+MjQmMTVdfWlmKGolYmxvY2tDb3VudD09PTApe2Yocyk7aT0wfX1pZihleHRyYUJ5dGVzKXtibG9jaz1zW2ldO2lmKGV4dHJhQnl0ZXM+MCl7aGV4Kz1IRVhfQ0hBUlNbYmxvY2s+PjQmMTVdK0hFWF9DSEFSU1tibG9jayYxNV19aWYoZXh0cmFCeXRlcz4xKXtoZXgrPUhFWF9DSEFSU1tibG9jaz4+MTImMTVdK0hFWF9DSEFSU1tibG9jaz4+OCYxNV19aWYoZXh0cmFCeXRlcz4yKXtoZXgrPUhFWF9DSEFSU1tibG9jaz4+MjAmMTVdK0hFWF9DSEFSU1tibG9jaz4+MTYmMTVdfX1yZXR1cm4gaGV4fTtLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyPWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO3ZhciBibG9ja0NvdW50PXRoaXMuYmxvY2tDb3VudCxzPXRoaXMucyxvdXRwdXRCbG9ja3M9dGhpcy5vdXRwdXRCbG9ja3MsZXh0cmFCeXRlcz10aGlzLmV4dHJhQnl0ZXMsaT0wLGo9MDt2YXIgYnl0ZXM9dGhpcy5vdXRwdXRCaXRzPj4zO3ZhciBidWZmZXI7aWYoZXh0cmFCeXRlcyl7YnVmZmVyPW5ldyBBcnJheUJ1ZmZlcihvdXRwdXRCbG9ja3MrMTw8Mil9ZWxzZXtidWZmZXI9bmV3IEFycmF5QnVmZmVyKGJ5dGVzKX12YXIgYXJyYXk9bmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7d2hpbGUoajxvdXRwdXRCbG9ja3Mpe2ZvcihpPTA7aTxibG9ja0NvdW50JiZqPG91dHB1dEJsb2NrczsrK2ksKytqKXthcnJheVtqXT1zW2ldfWlmKGolYmxvY2tDb3VudD09PTApe2Yocyl9fWlmKGV4dHJhQnl0ZXMpe2FycmF5W2ldPXNbaV07YnVmZmVyPWJ1ZmZlci5zbGljZSgwLGJ5dGVzKX1yZXR1cm4gYnVmZmVyfTtLZWNjYWsucHJvdG90eXBlLmJ1ZmZlcj1LZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyO0tlY2Nhay5wcm90b3R5cGUuZGlnZXN0PUtlY2Nhay5wcm90b3R5cGUuYXJyYXk9ZnVuY3Rpb24oKXt0aGlzLmZpbmFsaXplKCk7dmFyIGJsb2NrQ291bnQ9dGhpcy5ibG9ja0NvdW50LHM9dGhpcy5zLG91dHB1dEJsb2Nrcz10aGlzLm91dHB1dEJsb2NrcyxleHRyYUJ5dGVzPXRoaXMuZXh0cmFCeXRlcyxpPTAsaj0wO3ZhciBhcnJheT1bXSxvZmZzZXQsYmxvY2s7d2hpbGUoajxvdXRwdXRCbG9ja3Mpe2ZvcihpPTA7aTxibG9ja0NvdW50JiZqPG91dHB1dEJsb2NrczsrK2ksKytqKXtvZmZzZXQ9ajw8MjtibG9jaz1zW2ldO2FycmF5W29mZnNldF09YmxvY2smMjU1O2FycmF5W29mZnNldCsxXT1ibG9jaz4+OCYyNTU7YXJyYXlbb2Zmc2V0KzJdPWJsb2NrPj4xNiYyNTU7YXJyYXlbb2Zmc2V0KzNdPWJsb2NrPj4yNCYyNTV9aWYoaiVibG9ja0NvdW50PT09MCl7ZihzKX19aWYoZXh0cmFCeXRlcyl7b2Zmc2V0PWo8PDI7YmxvY2s9c1tpXTtpZihleHRyYUJ5dGVzPjApe2FycmF5W29mZnNldF09YmxvY2smMjU1fWlmKGV4dHJhQnl0ZXM+MSl7YXJyYXlbb2Zmc2V0KzFdPWJsb2NrPj44JjI1NX1pZihleHRyYUJ5dGVzPjIpe2FycmF5W29mZnNldCsyXT1ibG9jaz4+MTYmMjU1fX1yZXR1cm4gYXJyYXl9O3ZhciBmPWZ1bmN0aW9uKHMpe3ZhciBoLGwsbixjMCxjMSxjMixjMyxjNCxjNSxjNixjNyxjOCxjOSxiMCxiMSxiMixiMyxiNCxiNSxiNixiNyxiOCxiOSxiMTAsYjExLGIxMixiMTMsYjE0LGIxNSxiMTYsYjE3LGIxOCxiMTksYjIwLGIyMSxiMjIsYjIzLGIyNCxiMjUsYjI2LGIyNyxiMjgsYjI5LGIzMCxiMzEsYjMyLGIzMyxiMzQsYjM1LGIzNixiMzcsYjM4LGIzOSxiNDAsYjQxLGI0MixiNDMsYjQ0LGI0NSxiNDYsYjQ3LGI0OCxiNDk7Zm9yKG49MDtuPDQ4O24rPTIpe2MwPXNbMF1ec1sxMF1ec1syMF1ec1szMF1ec1s0MF07YzE9c1sxXV5zWzExXV5zWzIxXV5zWzMxXV5zWzQxXTtjMj1zWzJdXnNbMTJdXnNbMjJdXnNbMzJdXnNbNDJdO2MzPXNbM11ec1sxM11ec1syM11ec1szM11ec1s0M107YzQ9c1s0XV5zWzE0XV5zWzI0XV5zWzM0XV5zWzQ0XTtjNT1zWzVdXnNbMTVdXnNbMjVdXnNbMzVdXnNbNDVdO2M2PXNbNl1ec1sxNl1ec1syNl1ec1szNl1ec1s0Nl07Yzc9c1s3XV5zWzE3XV5zWzI3XV5zWzM3XV5zWzQ3XTtjOD1zWzhdXnNbMThdXnNbMjhdXnNbMzhdXnNbNDhdO2M5PXNbOV1ec1sxOV1ec1syOV1ec1szOV1ec1s0OV07aD1jOF4oYzI8PDF8YzM+Pj4zMSk7bD1jOV4oYzM8PDF8YzI+Pj4zMSk7c1swXV49aDtzWzFdXj1sO3NbMTBdXj1oO3NbMTFdXj1sO3NbMjBdXj1oO3NbMjFdXj1sO3NbMzBdXj1oO3NbMzFdXj1sO3NbNDBdXj1oO3NbNDFdXj1sO2g9YzBeKGM0PDwxfGM1Pj4+MzEpO2w9YzFeKGM1PDwxfGM0Pj4+MzEpO3NbMl1ePWg7c1szXV49bDtzWzEyXV49aDtzWzEzXV49bDtzWzIyXV49aDtzWzIzXV49bDtzWzMyXV49aDtzWzMzXV49bDtzWzQyXV49aDtzWzQzXV49bDtoPWMyXihjNjw8MXxjNz4+PjMxKTtsPWMzXihjNzw8MXxjNj4+PjMxKTtzWzRdXj1oO3NbNV1ePWw7c1sxNF1ePWg7c1sxNV1ePWw7c1syNF1ePWg7c1syNV1ePWw7c1szNF1ePWg7c1szNV1ePWw7c1s0NF1ePWg7c1s0NV1ePWw7aD1jNF4oYzg8PDF8Yzk+Pj4zMSk7bD1jNV4oYzk8PDF8Yzg+Pj4zMSk7c1s2XV49aDtzWzddXj1sO3NbMTZdXj1oO3NbMTddXj1sO3NbMjZdXj1oO3NbMjddXj1sO3NbMzZdXj1oO3NbMzddXj1sO3NbNDZdXj1oO3NbNDddXj1sO2g9YzZeKGMwPDwxfGMxPj4+MzEpO2w9YzdeKGMxPDwxfGMwPj4+MzEpO3NbOF1ePWg7c1s5XV49bDtzWzE4XV49aDtzWzE5XV49bDtzWzI4XV49aDtzWzI5XV49bDtzWzM4XV49aDtzWzM5XV49bDtzWzQ4XV49aDtzWzQ5XV49bDtiMD1zWzBdO2IxPXNbMV07YjMyPXNbMTFdPDw0fHNbMTBdPj4+Mjg7YjMzPXNbMTBdPDw0fHNbMTFdPj4+Mjg7YjE0PXNbMjBdPDwzfHNbMjFdPj4+Mjk7YjE1PXNbMjFdPDwzfHNbMjBdPj4+Mjk7YjQ2PXNbMzFdPDw5fHNbMzBdPj4+MjM7YjQ3PXNbMzBdPDw5fHNbMzFdPj4+MjM7YjI4PXNbNDBdPDwxOHxzWzQxXT4+PjE0O2IyOT1zWzQxXTw8MTh8c1s0MF0+Pj4xNDtiMjA9c1syXTw8MXxzWzNdPj4+MzE7YjIxPXNbM108PDF8c1syXT4+PjMxO2IyPXNbMTNdPDwxMnxzWzEyXT4+PjIwO2IzPXNbMTJdPDwxMnxzWzEzXT4+PjIwO2IzND1zWzIyXTw8MTB8c1syM10+Pj4yMjtiMzU9c1syM108PDEwfHNbMjJdPj4+MjI7YjE2PXNbMzNdPDwxM3xzWzMyXT4+PjE5O2IxNz1zWzMyXTw8MTN8c1szM10+Pj4xOTtiNDg9c1s0Ml08PDJ8c1s0M10+Pj4zMDtiNDk9c1s0M108PDJ8c1s0Ml0+Pj4zMDtiNDA9c1s1XTw8MzB8c1s0XT4+PjI7YjQxPXNbNF08PDMwfHNbNV0+Pj4yO2IyMj1zWzE0XTw8NnxzWzE1XT4+PjI2O2IyMz1zWzE1XTw8NnxzWzE0XT4+PjI2O2I0PXNbMjVdPDwxMXxzWzI0XT4+PjIxO2I1PXNbMjRdPDwxMXxzWzI1XT4+PjIxO2IzNj1zWzM0XTw8MTV8c1szNV0+Pj4xNztiMzc9c1szNV08PDE1fHNbMzRdPj4+MTc7YjE4PXNbNDVdPDwyOXxzWzQ0XT4+PjM7YjE5PXNbNDRdPDwyOXxzWzQ1XT4+PjM7YjEwPXNbNl08PDI4fHNbN10+Pj40O2IxMT1zWzddPDwyOHxzWzZdPj4+NDtiNDI9c1sxN108PDIzfHNbMTZdPj4+OTtiNDM9c1sxNl08PDIzfHNbMTddPj4+OTtiMjQ9c1syNl08PDI1fHNbMjddPj4+NztiMjU9c1syN108PDI1fHNbMjZdPj4+NztiNj1zWzM2XTw8MjF8c1szN10+Pj4xMTtiNz1zWzM3XTw8MjF8c1szNl0+Pj4xMTtiMzg9c1s0N108PDI0fHNbNDZdPj4+ODtiMzk9c1s0Nl08PDI0fHNbNDddPj4+ODtiMzA9c1s4XTw8Mjd8c1s5XT4+PjU7YjMxPXNbOV08PDI3fHNbOF0+Pj41O2IxMj1zWzE4XTw8MjB8c1sxOV0+Pj4xMjtiMTM9c1sxOV08PDIwfHNbMThdPj4+MTI7YjQ0PXNbMjldPDw3fHNbMjhdPj4+MjU7YjQ1PXNbMjhdPDw3fHNbMjldPj4+MjU7YjI2PXNbMzhdPDw4fHNbMzldPj4+MjQ7YjI3PXNbMzldPDw4fHNbMzhdPj4+MjQ7Yjg9c1s0OF08PDE0fHNbNDldPj4+MTg7Yjk9c1s0OV08PDE0fHNbNDhdPj4+MTg7c1swXT1iMF5+YjImYjQ7c1sxXT1iMV5+YjMmYjU7c1sxMF09YjEwXn5iMTImYjE0O3NbMTFdPWIxMV5+YjEzJmIxNTtzWzIwXT1iMjBefmIyMiZiMjQ7c1syMV09YjIxXn5iMjMmYjI1O3NbMzBdPWIzMF5+YjMyJmIzNDtzWzMxXT1iMzFefmIzMyZiMzU7c1s0MF09YjQwXn5iNDImYjQ0O3NbNDFdPWI0MV5+YjQzJmI0NTtzWzJdPWIyXn5iNCZiNjtzWzNdPWIzXn5iNSZiNztzWzEyXT1iMTJefmIxNCZiMTY7c1sxM109YjEzXn5iMTUmYjE3O3NbMjJdPWIyMl5+YjI0JmIyNjtzWzIzXT1iMjNefmIyNSZiMjc7c1szMl09YjMyXn5iMzQmYjM2O3NbMzNdPWIzM15+YjM1JmIzNztzWzQyXT1iNDJefmI0NCZiNDY7c1s0M109YjQzXn5iNDUmYjQ3O3NbNF09YjRefmI2JmI4O3NbNV09YjVefmI3JmI5O3NbMTRdPWIxNF5+YjE2JmIxODtzWzE1XT1iMTVefmIxNyZiMTk7c1syNF09YjI0Xn5iMjYmYjI4O3NbMjVdPWIyNV5+YjI3JmIyOTtzWzM0XT1iMzRefmIzNiZiMzg7c1szNV09YjM1Xn5iMzcmYjM5O3NbNDRdPWI0NF5+YjQ2JmI0ODtzWzQ1XT1iNDVefmI0NyZiNDk7c1s2XT1iNl5+YjgmYjA7c1s3XT1iN15+YjkmYjE7c1sxNl09YjE2Xn5iMTgmYjEwO3NbMTddPWIxN15+YjE5JmIxMTtzWzI2XT1iMjZefmIyOCZiMjA7c1syN109YjI3Xn5iMjkmYjIxO3NbMzZdPWIzNl5+YjM4JmIzMDtzWzM3XT1iMzdefmIzOSZiMzE7c1s0Nl09YjQ2Xn5iNDgmYjQwO3NbNDddPWI0N15+YjQ5JmI0MTtzWzhdPWI4Xn5iMCZiMjtzWzldPWI5Xn5iMSZiMztzWzE4XT1iMThefmIxMCZiMTI7c1sxOV09YjE5Xn5iMTEmYjEzO3NbMjhdPWIyOF5+YjIwJmIyMjtzWzI5XT1iMjlefmIyMSZiMjM7c1szOF09YjM4Xn5iMzAmYjMyO3NbMzldPWIzOV5+YjMxJmIzMztzWzQ4XT1iNDhefmI0MCZiNDI7c1s0OV09YjQ5Xn5iNDEmYjQzO3NbMF1ePVJDW25dO3NbMV1ePVJDW24rMV19fTtpZihDT01NT05fSlMpe21vZHVsZS5leHBvcnRzPW1ldGhvZHN9ZWxzZXtmb3IodmFyIGk9MDtpPG1ldGhvZE5hbWVzLmxlbmd0aDsrK2kpe3Jvb3RbbWV0aG9kTmFtZXNbaV1dPW1ldGhvZHNbbWV0aG9kTmFtZXNbaV1dfX19KSgpfSk7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24ga2VjY2FrMjU2KGRhdGEpe3JldHVyblwiMHhcIitzaGEzLmtlY2Nha18yNTYoYXJyYXlpZnkoZGF0YSkpfWNvbnN0IHZlcnNpb24kNT1cInJscC81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciQ2PW5ldyBMb2dnZXIodmVyc2lvbiQ1KTtmdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpe2NvbnN0IHJlc3VsdD1bXTt3aGlsZSh2YWx1ZSl7cmVzdWx0LnVuc2hpZnQodmFsdWUmMjU1KTt2YWx1ZT4+PTh9cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLG9mZnNldCxsZW5ndGgpe2xldCByZXN1bHQ9MDtmb3IobGV0IGk9MDtpPGxlbmd0aDtpKyspe3Jlc3VsdD1yZXN1bHQqMjU2K2RhdGFbb2Zmc2V0K2ldfXJldHVybiByZXN1bHR9ZnVuY3Rpb24gX2VuY29kZShvYmplY3Qpe2lmKEFycmF5LmlzQXJyYXkob2JqZWN0KSl7bGV0IHBheWxvYWQ9W107b2JqZWN0LmZvckVhY2goZnVuY3Rpb24oY2hpbGQpe3BheWxvYWQ9cGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpfSk7aWYocGF5bG9hZC5sZW5ndGg8PTU1KXtwYXlsb2FkLnVuc2hpZnQoMTkyK3BheWxvYWQubGVuZ3RoKTtyZXR1cm4gcGF5bG9hZH1jb25zdCBsZW5ndGg9YXJyYXlpZnlJbnRlZ2VyKHBheWxvYWQubGVuZ3RoKTtsZW5ndGgudW5zaGlmdCgyNDcrbGVuZ3RoLmxlbmd0aCk7cmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCl9aWYoIWlzQnl0ZXNMaWtlKG9iamVjdCkpe2xvZ2dlciQ2LnRocm93QXJndW1lbnRFcnJvcihcIlJMUCBvYmplY3QgbXVzdCBiZSBCeXRlc0xpa2VcIixcIm9iamVjdFwiLG9iamVjdCl9Y29uc3QgZGF0YT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheWlmeShvYmplY3QpKTtpZihkYXRhLmxlbmd0aD09PTEmJmRhdGFbMF08PTEyNyl7cmV0dXJuIGRhdGF9ZWxzZSBpZihkYXRhLmxlbmd0aDw9NTUpe2RhdGEudW5zaGlmdCgxMjgrZGF0YS5sZW5ndGgpO3JldHVybiBkYXRhfWNvbnN0IGxlbmd0aD1hcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO2xlbmd0aC51bnNoaWZ0KDE4MytsZW5ndGgubGVuZ3RoKTtyZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKX1mdW5jdGlvbiBlbmNvZGUob2JqZWN0KXtyZXR1cm4gaGV4bGlmeShfZW5jb2RlKG9iamVjdCkpfWZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLG9mZnNldCxjaGlsZE9mZnNldCxsZW5ndGgpe2NvbnN0IHJlc3VsdD1bXTt3aGlsZShjaGlsZE9mZnNldDxvZmZzZXQrMStsZW5ndGgpe2NvbnN0IGRlY29kZWQ9X2RlY29kZShkYXRhLGNoaWxkT2Zmc2V0KTtyZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7Y2hpbGRPZmZzZXQrPWRlY29kZWQuY29uc3VtZWQ7aWYoY2hpbGRPZmZzZXQ+b2Zmc2V0KzErbGVuZ3RoKXtsb2dnZXIkNi50aHJvd0Vycm9yKFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHt9KX19cmV0dXJue2NvbnN1bWVkOjErbGVuZ3RoLHJlc3VsdDpyZXN1bHR9fWZ1bmN0aW9uIF9kZWNvZGUoZGF0YSxvZmZzZXQpe2lmKGRhdGEubGVuZ3RoPT09MCl7bG9nZ2VyJDYudGhyb3dFcnJvcihcImRhdGEgdG9vIHNob3J0XCIsTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTix7fSl9aWYoZGF0YVtvZmZzZXRdPj0yNDgpe2NvbnN0IGxlbmd0aExlbmd0aD1kYXRhW29mZnNldF0tMjQ3O2lmKG9mZnNldCsxK2xlbmd0aExlbmd0aD5kYXRhLmxlbmd0aCl7bG9nZ2VyJDYudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHt9KX1jb25zdCBsZW5ndGg9dW5hcnJheWlmeUludGVnZXIoZGF0YSxvZmZzZXQrMSxsZW5ndGhMZW5ndGgpO2lmKG9mZnNldCsxK2xlbmd0aExlbmd0aCtsZW5ndGg+ZGF0YS5sZW5ndGgpe2xvZ2dlciQ2LnRocm93RXJyb3IoXCJkYXRhIGxvbmcgc2VnbWVudCB0b28gc2hvcnRcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHt9KX1yZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsb2Zmc2V0LG9mZnNldCsxK2xlbmd0aExlbmd0aCxsZW5ndGhMZW5ndGgrbGVuZ3RoKX1lbHNlIGlmKGRhdGFbb2Zmc2V0XT49MTkyKXtjb25zdCBsZW5ndGg9ZGF0YVtvZmZzZXRdLTE5MjtpZihvZmZzZXQrMStsZW5ndGg+ZGF0YS5sZW5ndGgpe2xvZ2dlciQ2LnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4se30pfXJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSxvZmZzZXQsb2Zmc2V0KzEsbGVuZ3RoKX1lbHNlIGlmKGRhdGFbb2Zmc2V0XT49MTg0KXtjb25zdCBsZW5ndGhMZW5ndGg9ZGF0YVtvZmZzZXRdLTE4MztpZihvZmZzZXQrMStsZW5ndGhMZW5ndGg+ZGF0YS5sZW5ndGgpe2xvZ2dlciQ2LnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4se30pfWNvbnN0IGxlbmd0aD11bmFycmF5aWZ5SW50ZWdlcihkYXRhLG9mZnNldCsxLGxlbmd0aExlbmd0aCk7aWYob2Zmc2V0KzErbGVuZ3RoTGVuZ3RoK2xlbmd0aD5kYXRhLmxlbmd0aCl7bG9nZ2VyJDYudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTix7fSl9Y29uc3QgcmVzdWx0PWhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQrMStsZW5ndGhMZW5ndGgsb2Zmc2V0KzErbGVuZ3RoTGVuZ3RoK2xlbmd0aCkpO3JldHVybntjb25zdW1lZDoxK2xlbmd0aExlbmd0aCtsZW5ndGgscmVzdWx0OnJlc3VsdH19ZWxzZSBpZihkYXRhW29mZnNldF0+PTEyOCl7Y29uc3QgbGVuZ3RoPWRhdGFbb2Zmc2V0XS0xMjg7aWYob2Zmc2V0KzErbGVuZ3RoPmRhdGEubGVuZ3RoKXtsb2dnZXIkNi50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIixMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLHt9KX1jb25zdCByZXN1bHQ9aGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCsxLG9mZnNldCsxK2xlbmd0aCkpO3JldHVybntjb25zdW1lZDoxK2xlbmd0aCxyZXN1bHQ6cmVzdWx0fX1yZXR1cm57Y29uc3VtZWQ6MSxyZXN1bHQ6aGV4bGlmeShkYXRhW29mZnNldF0pfX1mdW5jdGlvbiBkZWNvZGUoZGF0YSl7Y29uc3QgYnl0ZXM9YXJyYXlpZnkoZGF0YSk7Y29uc3QgZGVjb2RlZD1fZGVjb2RlKGJ5dGVzLDApO2lmKGRlY29kZWQuY29uc3VtZWQhPT1ieXRlcy5sZW5ndGgpe2xvZ2dlciQ2LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmxwIGRhdGFcIixcImRhdGFcIixkYXRhKX1yZXR1cm4gZGVjb2RlZC5yZXN1bHR9dmFyIGluZGV4PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGVuY29kZTplbmNvZGUsZGVjb2RlOmRlY29kZX0pO2NvbnN0IHZlcnNpb24kNj1cImFkZHJlc3MvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkNz1uZXcgTG9nZ2VyKHZlcnNpb24kNik7ZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3Mpe2lmKCFpc0hleFN0cmluZyhhZGRyZXNzLDIwKSl7bG9nZ2VyJDcudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsXCJhZGRyZXNzXCIsYWRkcmVzcyl9YWRkcmVzcz1hZGRyZXNzLnRvTG93ZXJDYXNlKCk7Y29uc3QgY2hhcnM9YWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7Y29uc3QgZXhwYW5kZWQ9bmV3IFVpbnQ4QXJyYXkoNDApO2ZvcihsZXQgaT0wO2k8NDA7aSsrKXtleHBhbmRlZFtpXT1jaGFyc1tpXS5jaGFyQ29kZUF0KDApfWNvbnN0IGhhc2hlZD1hcnJheWlmeShrZWNjYWsyNTYoZXhwYW5kZWQpKTtmb3IobGV0IGk9MDtpPDQwO2krPTIpe2lmKGhhc2hlZFtpPj4xXT4+ND49OCl7Y2hhcnNbaV09Y2hhcnNbaV0udG9VcHBlckNhc2UoKX1pZigoaGFzaGVkW2k+PjFdJjE1KT49OCl7Y2hhcnNbaSsxXT1jaGFyc1tpKzFdLnRvVXBwZXJDYXNlKCl9fXJldHVyblwiMHhcIitjaGFycy5qb2luKFwiXCIpfWNvbnN0IE1BWF9TQUZFX0lOVEVHRVI9OTAwNzE5OTI1NDc0MDk5MTtmdW5jdGlvbiBsb2cxMCh4KXtpZihNYXRoLmxvZzEwKXtyZXR1cm4gTWF0aC5sb2cxMCh4KX1yZXR1cm4gTWF0aC5sb2coeCkvTWF0aC5MTjEwfWNvbnN0IGliYW5Mb29rdXA9e307Zm9yKGxldCBpPTA7aTwxMDtpKyspe2liYW5Mb29rdXBbU3RyaW5nKGkpXT1TdHJpbmcoaSl9Zm9yKGxldCBpPTA7aTwyNjtpKyspe2liYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NStpKV09U3RyaW5nKDEwK2kpfWNvbnN0IHNhZmVEaWdpdHM9TWF0aC5mbG9vcihsb2cxMChNQVhfU0FGRV9JTlRFR0VSKSk7ZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3Mpe2FkZHJlc3M9YWRkcmVzcy50b1VwcGVyQ2FzZSgpO2FkZHJlc3M9YWRkcmVzcy5zdWJzdHJpbmcoNCkrYWRkcmVzcy5zdWJzdHJpbmcoMCwyKStcIjAwXCI7bGV0IGV4cGFuZGVkPWFkZHJlc3Muc3BsaXQoXCJcIikubWFwKGM9PntyZXR1cm4gaWJhbkxvb2t1cFtjXX0pLmpvaW4oXCJcIik7d2hpbGUoZXhwYW5kZWQubGVuZ3RoPj1zYWZlRGlnaXRzKXtsZXQgYmxvY2s9ZXhwYW5kZWQuc3Vic3RyaW5nKDAsc2FmZURpZ2l0cyk7ZXhwYW5kZWQ9cGFyc2VJbnQoYmxvY2ssMTApJTk3K2V4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpfWxldCBjaGVja3N1bT1TdHJpbmcoOTgtcGFyc2VJbnQoZXhwYW5kZWQsMTApJTk3KTt3aGlsZShjaGVja3N1bS5sZW5ndGg8Mil7Y2hlY2tzdW09XCIwXCIrY2hlY2tzdW19cmV0dXJuIGNoZWNrc3VtfWZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcyl7bGV0IHJlc3VsdD1udWxsO2lmKHR5cGVvZiBhZGRyZXNzIT09XCJzdHJpbmdcIil7bG9nZ2VyJDcudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsXCJhZGRyZXNzXCIsYWRkcmVzcyl9aWYoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKXtpZihhZGRyZXNzLnN1YnN0cmluZygwLDIpIT09XCIweFwiKXthZGRyZXNzPVwiMHhcIithZGRyZXNzfXJlc3VsdD1nZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7aWYoYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSYmcmVzdWx0IT09YWRkcmVzcyl7bG9nZ2VyJDcudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIixcImFkZHJlc3NcIixhZGRyZXNzKX19ZWxzZSBpZihhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSl7aWYoYWRkcmVzcy5zdWJzdHJpbmcoMiw0KSE9PWliYW5DaGVja3N1bShhZGRyZXNzKSl7bG9nZ2VyJDcudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIixcImFkZHJlc3NcIixhZGRyZXNzKX1yZXN1bHQ9X2Jhc2UzNlRvMTYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpO3doaWxlKHJlc3VsdC5sZW5ndGg8NDApe3Jlc3VsdD1cIjBcIityZXN1bHR9cmVzdWx0PWdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIrcmVzdWx0KX1lbHNle2xvZ2dlciQ3LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLFwiYWRkcmVzc1wiLGFkZHJlc3MpfXJldHVybiByZXN1bHR9ZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3Mpe3RyeXtnZXRBZGRyZXNzKGFkZHJlc3MpO3JldHVybiB0cnVlfWNhdGNoKGVycm9yKXt9cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3Mpe2xldCBiYXNlMzY9X2Jhc2UxNlRvMzYoZ2V0QWRkcmVzcyhhZGRyZXNzKS5zdWJzdHJpbmcoMikpLnRvVXBwZXJDYXNlKCk7d2hpbGUoYmFzZTM2Lmxlbmd0aDwzMCl7YmFzZTM2PVwiMFwiK2Jhc2UzNn1yZXR1cm5cIlhFXCIraWJhbkNoZWNrc3VtKFwiWEUwMFwiK2Jhc2UzNikrYmFzZTM2fWZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbil7bGV0IGZyb209bnVsbDt0cnl7ZnJvbT1nZXRBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pfWNhdGNoKGVycm9yKXtsb2dnZXIkNy50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiLFwidHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvbil9Y29uc3Qgbm9uY2U9c3RyaXBaZXJvcyhhcnJheWlmeShCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5ub25jZSkudG9IZXhTdHJpbmcoKSkpO3JldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoZW5jb2RlKFtmcm9tLG5vbmNlXSkpLDEyKSl9ZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSxzYWx0LGluaXRDb2RlSGFzaCl7aWYoaGV4RGF0YUxlbmd0aChzYWx0KSE9PTMyKXtsb2dnZXIkNy50aHJvd0FyZ3VtZW50RXJyb3IoXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIixcInNhbHRcIixzYWx0KX1pZihoZXhEYXRhTGVuZ3RoKGluaXRDb2RlSGFzaCkhPT0zMil7bG9nZ2VyJDcudGhyb3dBcmd1bWVudEVycm9yKFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIixcImluaXRDb2RlSGFzaFwiLGluaXRDb2RlSGFzaCl9cmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLGdldEFkZHJlc3MoZnJvbSksc2FsdCxpbml0Q29kZUhhc2hdKSksMTIpKX1cInVzZSBzdHJpY3RcIjtjbGFzcyBBZGRyZXNzQ29kZXIgZXh0ZW5kcyBDb2Rlcntjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpe3N1cGVyKFwiYWRkcmVzc1wiLFwiYWRkcmVzc1wiLGxvY2FsTmFtZSxmYWxzZSl9ZGVmYXVsdFZhbHVlKCl7cmV0dXJuXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIn1lbmNvZGUod3JpdGVyLHZhbHVlKXt0cnl7Z2V0QWRkcmVzcyh2YWx1ZSl9Y2F0Y2goZXJyb3Ipe3RoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSx2YWx1ZSl9cmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKX1kZWNvZGUocmVhZGVyKXtyZXR1cm4gZ2V0QWRkcmVzcyhoZXhaZXJvUGFkKHJlYWRlci5yZWFkVmFsdWUoKS50b0hleFN0cmluZygpLDIwKSl9fVwidXNlIHN0cmljdFwiO2NsYXNzIEFub255bW91c0NvZGVyIGV4dGVuZHMgQ29kZXJ7Y29uc3RydWN0b3IoY29kZXIpe3N1cGVyKGNvZGVyLm5hbWUsY29kZXIudHlwZSx1bmRlZmluZWQsY29kZXIuZHluYW1pYyk7dGhpcy5jb2Rlcj1jb2Rlcn1kZWZhdWx0VmFsdWUoKXtyZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKX1lbmNvZGUod3JpdGVyLHZhbHVlKXtyZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUod3JpdGVyLHZhbHVlKX1kZWNvZGUocmVhZGVyKXtyZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKX19XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJDg9bmV3IExvZ2dlcih2ZXJzaW9uJDQpO2Z1bmN0aW9uIHBhY2sod3JpdGVyLGNvZGVycyx2YWx1ZXMpe2xldCBhcnJheVZhbHVlcz1udWxsO2lmKEFycmF5LmlzQXJyYXkodmFsdWVzKSl7YXJyYXlWYWx1ZXM9dmFsdWVzfWVsc2UgaWYodmFsdWVzJiZ0eXBlb2YgdmFsdWVzPT09XCJvYmplY3RcIil7bGV0IHVuaXF1ZT17fTthcnJheVZhbHVlcz1jb2RlcnMubWFwKGNvZGVyPT57Y29uc3QgbmFtZT1jb2Rlci5sb2NhbE5hbWU7aWYoIW5hbWUpe2xvZ2dlciQ4LnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJ2YWx1ZXNcIixjb2Rlcjpjb2Rlcix2YWx1ZTp2YWx1ZXN9KX1pZih1bmlxdWVbbmFtZV0pe2xvZ2dlciQ4LnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInZhbHVlc1wiLGNvZGVyOmNvZGVyLHZhbHVlOnZhbHVlc30pfXVuaXF1ZVtuYW1lXT10cnVlO3JldHVybiB2YWx1ZXNbbmFtZV19KX1lbHNle2xvZ2dlciQ4LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIixcInR1cGxlXCIsdmFsdWVzKX1pZihjb2RlcnMubGVuZ3RoIT09YXJyYXlWYWx1ZXMubGVuZ3RoKXtsb2dnZXIkOC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIixcInR1cGxlXCIsdmFsdWVzKX1sZXQgc3RhdGljV3JpdGVyPW5ldyBXcml0ZXIod3JpdGVyLndvcmRTaXplKTtsZXQgZHluYW1pY1dyaXRlcj1uZXcgV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7bGV0IHVwZGF0ZUZ1bmNzPVtdO2NvZGVycy5mb3JFYWNoKChjb2RlcixpbmRleCk9PntsZXQgdmFsdWU9YXJyYXlWYWx1ZXNbaW5kZXhdO2lmKGNvZGVyLmR5bmFtaWMpe2xldCBkeW5hbWljT2Zmc2V0PWR5bmFtaWNXcml0ZXIubGVuZ3RoO2NvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLHZhbHVlKTtsZXQgdXBkYXRlRnVuYz1zdGF0aWNXcml0ZXIud3JpdGVVcGRhdGFibGVWYWx1ZSgpO3VwZGF0ZUZ1bmNzLnB1c2goYmFzZU9mZnNldD0+e3VwZGF0ZUZ1bmMoYmFzZU9mZnNldCtkeW5hbWljT2Zmc2V0KX0pfWVsc2V7Y29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlcix2YWx1ZSl9fSk7dXBkYXRlRnVuY3MuZm9yRWFjaChmdW5jPT57ZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKX0pO2xldCBsZW5ndGg9d3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO2xlbmd0aCs9d3JpdGVyLmFwcGVuZFdyaXRlcihkeW5hbWljV3JpdGVyKTtyZXR1cm4gbGVuZ3RofWZ1bmN0aW9uIHVucGFjayhyZWFkZXIsY29kZXJzKXtsZXQgdmFsdWVzPVtdO2xldCBiYXNlUmVhZGVyPXJlYWRlci5zdWJSZWFkZXIoMCk7Y29kZXJzLmZvckVhY2goY29kZXI9PntsZXQgdmFsdWU9bnVsbDtpZihjb2Rlci5keW5hbWljKXtsZXQgb2Zmc2V0PXJlYWRlci5yZWFkVmFsdWUoKTtsZXQgb2Zmc2V0UmVhZGVyPWJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldC50b051bWJlcigpKTt0cnl7dmFsdWU9Y29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcil9Y2F0Y2goZXJyb3Ipe2lmKGVycm9yLmNvZGU9PT1Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKXt0aHJvdyBlcnJvcn12YWx1ZT1lcnJvcjt2YWx1ZS5iYXNlVHlwZT1jb2Rlci5uYW1lO3ZhbHVlLm5hbWU9Y29kZXIubG9jYWxOYW1lO3ZhbHVlLnR5cGU9Y29kZXIudHlwZX19ZWxzZXt0cnl7dmFsdWU9Y29kZXIuZGVjb2RlKHJlYWRlcil9Y2F0Y2goZXJyb3Ipe2lmKGVycm9yLmNvZGU9PT1Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKXt0aHJvdyBlcnJvcn12YWx1ZT1lcnJvcjt2YWx1ZS5iYXNlVHlwZT1jb2Rlci5uYW1lO3ZhbHVlLm5hbWU9Y29kZXIubG9jYWxOYW1lO3ZhbHVlLnR5cGU9Y29kZXIudHlwZX19aWYodmFsdWUhPXVuZGVmaW5lZCl7dmFsdWVzLnB1c2godmFsdWUpfX0pO2NvbnN0IHVuaXF1ZU5hbWVzPWNvZGVycy5yZWR1Y2UoKGFjY3VtLGNvZGVyKT0+e2NvbnN0IG5hbWU9Y29kZXIubG9jYWxOYW1lO2lmKG5hbWUpe2lmKCFhY2N1bVtuYW1lXSl7YWNjdW1bbmFtZV09MH1hY2N1bVtuYW1lXSsrfXJldHVybiBhY2N1bX0se30pO2NvZGVycy5mb3JFYWNoKChjb2RlcixpbmRleCk9PntsZXQgbmFtZT1jb2Rlci5sb2NhbE5hbWU7aWYoIW5hbWV8fHVuaXF1ZU5hbWVzW25hbWVdIT09MSl7cmV0dXJufWlmKG5hbWU9PT1cImxlbmd0aFwiKXtuYW1lPVwiX2xlbmd0aFwifWlmKHZhbHVlc1tuYW1lXSE9bnVsbCl7cmV0dXJufWNvbnN0IHZhbHVlPXZhbHVlc1tpbmRleF07aWYodmFsdWUgaW5zdGFuY2VvZiBFcnJvcil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcyxuYW1lLHtnZXQ6KCk9Pnt0aHJvdyB2YWx1ZX19KX1lbHNle3ZhbHVlc1tuYW1lXT12YWx1ZX19KTtmb3IobGV0IGk9MDtpPHZhbHVlcy5sZW5ndGg7aSsrKXtjb25zdCB2YWx1ZT12YWx1ZXNbaV07aWYodmFsdWUgaW5zdGFuY2VvZiBFcnJvcil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcyxpLHtnZXQ6KCk9Pnt0aHJvdyB2YWx1ZX19KX19cmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKX1jbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXJ7Y29uc3RydWN0b3IoY29kZXIsbGVuZ3RoLGxvY2FsTmFtZSl7Y29uc3QgdHlwZT1jb2Rlci50eXBlK1wiW1wiKyhsZW5ndGg+PTA/bGVuZ3RoOlwiXCIpK1wiXVwiO2NvbnN0IGR5bmFtaWM9bGVuZ3RoPT09LTF8fGNvZGVyLmR5bmFtaWM7c3VwZXIoXCJhcnJheVwiLHR5cGUsbG9jYWxOYW1lLGR5bmFtaWMpO3RoaXMuY29kZXI9Y29kZXI7dGhpcy5sZW5ndGg9bGVuZ3RofWRlZmF1bHRWYWx1ZSgpe2NvbnN0IGRlZmF1bHRDaGlsZD10aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO2NvbnN0IHJlc3VsdD1bXTtmb3IobGV0IGk9MDtpPHRoaXMubGVuZ3RoO2krKyl7cmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKX1yZXR1cm4gcmVzdWx0fWVuY29kZSh3cml0ZXIsdmFsdWUpe2lmKCFBcnJheS5pc0FycmF5KHZhbHVlKSl7dGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsdmFsdWUpfWxldCBjb3VudD10aGlzLmxlbmd0aDtpZihjb3VudD09PS0xKXtjb3VudD12YWx1ZS5sZW5ndGg7d3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKX1sb2dnZXIkOC5jaGVja0FyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLGNvdW50LFwiY29kZXIgYXJyYXlcIisodGhpcy5sb2NhbE5hbWU/XCIgXCIrdGhpcy5sb2NhbE5hbWU6XCJcIikpO2xldCBjb2RlcnM9W107Zm9yKGxldCBpPTA7aTx2YWx1ZS5sZW5ndGg7aSsrKXtjb2RlcnMucHVzaCh0aGlzLmNvZGVyKX1yZXR1cm4gcGFjayh3cml0ZXIsY29kZXJzLHZhbHVlKX1kZWNvZGUocmVhZGVyKXtsZXQgY291bnQ9dGhpcy5sZW5ndGg7aWYoY291bnQ9PT0tMSl7Y291bnQ9cmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCk7aWYoY291bnQqMzI+cmVhZGVyLl9kYXRhLmxlbmd0aCl7bG9nZ2VyJDgudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4se2xlbmd0aDpyZWFkZXIuX2RhdGEubGVuZ3RoLGNvdW50OmNvdW50fSl9fWxldCBjb2RlcnM9W107Zm9yKGxldCBpPTA7aTxjb3VudDtpKyspe2NvZGVycy5wdXNoKG5ldyBBbm9ueW1vdXNDb2Rlcih0aGlzLmNvZGVyKSl9cmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLHVucGFjayhyZWFkZXIsY29kZXJzKSl9fVwidXNlIHN0cmljdFwiO2NsYXNzIEJvb2xlYW5Db2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKGxvY2FsTmFtZSl7c3VwZXIoXCJib29sXCIsXCJib29sXCIsbG9jYWxOYW1lLGZhbHNlKX1kZWZhdWx0VmFsdWUoKXtyZXR1cm4gZmFsc2V9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7cmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlPzE6MCl9ZGVjb2RlKHJlYWRlcil7cmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy50eXBlLCFyZWFkZXIucmVhZFZhbHVlKCkuaXNaZXJvKCkpfX1cInVzZSBzdHJpY3RcIjtjbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKHR5cGUsbG9jYWxOYW1lKXtzdXBlcih0eXBlLHR5cGUsbG9jYWxOYW1lLHRydWUpfWRlZmF1bHRWYWx1ZSgpe3JldHVyblwiMHhcIn1lbmNvZGUod3JpdGVyLHZhbHVlKXt2YWx1ZT1hcnJheWlmeSh2YWx1ZSk7bGV0IGxlbmd0aD13cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO2xlbmd0aCs9d3JpdGVyLndyaXRlQnl0ZXModmFsdWUpO3JldHVybiBsZW5ndGh9ZGVjb2RlKHJlYWRlcil7cmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksdHJ1ZSl9fWNsYXNzIEJ5dGVzQ29kZXIgZXh0ZW5kcyBEeW5hbWljQnl0ZXNDb2Rlcntjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpe3N1cGVyKFwiYnl0ZXNcIixsb2NhbE5hbWUpfWRlY29kZShyZWFkZXIpe3JldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSxoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKSl9fVwidXNlIHN0cmljdFwiO2NsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKHNpemUsbG9jYWxOYW1lKXtsZXQgbmFtZT1cImJ5dGVzXCIrU3RyaW5nKHNpemUpO3N1cGVyKG5hbWUsbmFtZSxsb2NhbE5hbWUsZmFsc2UpO3RoaXMuc2l6ZT1zaXplfWRlZmF1bHRWYWx1ZSgpe3JldHVyblwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIuc3Vic3RyaW5nKDAsMit0aGlzLnNpemUqMil9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7bGV0IGRhdGE9YXJyYXlpZnkodmFsdWUpO2lmKGRhdGEubGVuZ3RoIT09dGhpcy5zaXplKXt0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsdmFsdWUpfXJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKX1kZWNvZGUocmVhZGVyKXtyZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpKX19XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXJ7Y29uc3RydWN0b3IobG9jYWxOYW1lKXtzdXBlcihcIm51bGxcIixcIlwiLGxvY2FsTmFtZSxmYWxzZSl9ZGVmYXVsdFZhbHVlKCl7cmV0dXJuIG51bGx9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7aWYodmFsdWUhPW51bGwpe3RoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLHZhbHVlKX1yZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoW10pfWRlY29kZShyZWFkZXIpe3JlYWRlci5yZWFkQnl0ZXMoMCk7cmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLG51bGwpfX1jb25zdCBBZGRyZXNzWmVybz1cIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO2NvbnN0IE5lZ2F0aXZlT25lJDE9QmlnTnVtYmVyLmZyb20oLTEpO2NvbnN0IFplcm8kMT1CaWdOdW1iZXIuZnJvbSgwKTtjb25zdCBPbmU9QmlnTnVtYmVyLmZyb20oMSk7Y29uc3QgVHdvPUJpZ051bWJlci5mcm9tKDIpO2NvbnN0IFdlaVBlckV0aGVyPUJpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKTtjb25zdCBNYXhVaW50MjU2PUJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO2NvbnN0IEhhc2haZXJvPVwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7Y29uc3QgRXRoZXJTeW1ib2w9XCLOnlwiO1widXNlIHN0cmljdFwiO3ZhciBpbmRleCQxPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFkZHJlc3NaZXJvOkFkZHJlc3NaZXJvLE5lZ2F0aXZlT25lOk5lZ2F0aXZlT25lJDEsWmVybzpaZXJvJDEsT25lOk9uZSxUd286VHdvLFdlaVBlckV0aGVyOldlaVBlckV0aGVyLE1heFVpbnQyNTY6TWF4VWludDI1NixIYXNoWmVybzpIYXNoWmVybyxFdGhlclN5bWJvbDpFdGhlclN5bWJvbH0pO1widXNlIHN0cmljdFwiO2NsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXJ7Y29uc3RydWN0b3Ioc2l6ZSxzaWduZWQsbG9jYWxOYW1lKXtjb25zdCBuYW1lPShzaWduZWQ/XCJpbnRcIjpcInVpbnRcIikrc2l6ZSo4O3N1cGVyKG5hbWUsbmFtZSxsb2NhbE5hbWUsZmFsc2UpO3RoaXMuc2l6ZT1zaXplO3RoaXMuc2lnbmVkPXNpZ25lZH1kZWZhdWx0VmFsdWUoKXtyZXR1cm4gMH1lbmNvZGUod3JpdGVyLHZhbHVlKXtsZXQgdj1CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7bGV0IG1heFVpbnRWYWx1ZT1NYXhVaW50MjU2Lm1hc2sod3JpdGVyLndvcmRTaXplKjgpO2lmKHRoaXMuc2lnbmVkKXtsZXQgYm91bmRzPW1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSo4LTEpO2lmKHYuZ3QoYm91bmRzKXx8di5sdChib3VuZHMuYWRkKE9uZSkubXVsKE5lZ2F0aXZlT25lJDEpKSl7dGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIix2YWx1ZSl9fWVsc2UgaWYodi5sdChaZXJvJDEpfHx2Lmd0KG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSo4KSkpe3RoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsdmFsdWUpfXY9di50b1R3b3ModGhpcy5zaXplKjgpLm1hc2sodGhpcy5zaXplKjgpO2lmKHRoaXMuc2lnbmVkKXt2PXYuZnJvbVR3b3ModGhpcy5zaXplKjgpLnRvVHdvcyg4KndyaXRlci53b3JkU2l6ZSl9cmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHYpfWRlY29kZShyZWFkZXIpe2xldCB2YWx1ZT1yZWFkZXIucmVhZFZhbHVlKCkubWFzayh0aGlzLnNpemUqOCk7aWYodGhpcy5zaWduZWQpe3ZhbHVlPXZhbHVlLmZyb21Ud29zKHRoaXMuc2l6ZSo4KX1yZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsdmFsdWUpfX1jb25zdCB2ZXJzaW9uJDc9XCJzdHJpbmdzLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJDk9bmV3IExvZ2dlcih2ZXJzaW9uJDcpO3ZhciBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm07KGZ1bmN0aW9uKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSl7VW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiY3VycmVudFwiXT1cIlwiO1VuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GQ1wiXT1cIk5GQ1wiO1VuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GRFwiXT1cIk5GRFwiO1VuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0NcIl09XCJORktDXCI7VW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLRFwiXT1cIk5GS0RcIn0pKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybXx8KFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybT17fSkpO3ZhciBVdGY4RXJyb3JSZWFzb247KGZ1bmN0aW9uKFV0ZjhFcnJvclJlYXNvbil7VXRmOEVycm9yUmVhc29uW1wiVU5FWFBFQ1RFRF9DT05USU5VRVwiXT1cInVuZXhwZWN0ZWQgY29udGludWF0aW9uIGJ5dGVcIjtVdGY4RXJyb3JSZWFzb25bXCJCQURfUFJFRklYXCJdPVwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtVdGY4RXJyb3JSZWFzb25bXCJPVkVSUlVOXCJdPVwic3RyaW5nIG92ZXJydW5cIjtVdGY4RXJyb3JSZWFzb25bXCJNSVNTSU5HX0NPTlRJTlVFXCJdPVwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1V0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXT1cIm91dCBvZiBVVEYtOCByYW5nZVwiO1V0ZjhFcnJvclJlYXNvbltcIlVURjE2X1NVUlJPR0FURVwiXT1cIlVURi0xNiBzdXJyb2dhdGVcIjtVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXT1cIm92ZXJsb25nIHJlcHJlc2VudGF0aW9uXCJ9KShVdGY4RXJyb3JSZWFzb258fChVdGY4RXJyb3JSZWFzb249e30pKTtmdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLG9mZnNldCxieXRlcyxvdXRwdXQsYmFkQ29kZXBvaW50KXtyZXR1cm4gbG9nZ2VyJDkudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLFwiYnl0ZXNcIixieXRlcyl9ZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sb2Zmc2V0LGJ5dGVzLG91dHB1dCxiYWRDb2RlcG9pbnQpe2lmKHJlYXNvbj09PVV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYfHxyZWFzb249PT1VdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSl7bGV0IGk9MDtmb3IobGV0IG89b2Zmc2V0KzE7bzxieXRlcy5sZW5ndGg7bysrKXtpZihieXRlc1tvXT4+NiE9PTIpe2JyZWFrfWkrK31yZXR1cm4gaX1pZihyZWFzb249PT1VdGY4RXJyb3JSZWFzb24uT1ZFUlJVTil7cmV0dXJuIGJ5dGVzLmxlbmd0aC1vZmZzZXQtMX1yZXR1cm4gMH1mdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sb2Zmc2V0LGJ5dGVzLG91dHB1dCxiYWRDb2RlcG9pbnQpe2lmKHJlYXNvbj09PVV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORyl7b3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtyZXR1cm4gMH1vdXRwdXQucHVzaCg2NTUzMyk7cmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLG9mZnNldCxieXRlcyxvdXRwdXQsYmFkQ29kZXBvaW50KX1jb25zdCBVdGY4RXJyb3JGdW5jcz1PYmplY3QuZnJlZXplKHtlcnJvcjplcnJvckZ1bmMsaWdub3JlOmlnbm9yZUZ1bmMscmVwbGFjZTpyZXBsYWNlRnVuY30pO2Z1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLG9uRXJyb3Ipe2lmKG9uRXJyb3I9PW51bGwpe29uRXJyb3I9VXRmOEVycm9yRnVuY3MuZXJyb3J9Ynl0ZXM9YXJyYXlpZnkoYnl0ZXMpO2NvbnN0IHJlc3VsdD1bXTtsZXQgaT0wO3doaWxlKGk8Ynl0ZXMubGVuZ3RoKXtjb25zdCBjPWJ5dGVzW2krK107aWYoYz4+Nz09PTApe3Jlc3VsdC5wdXNoKGMpO2NvbnRpbnVlfWxldCBleHRyYUxlbmd0aD1udWxsO2xldCBvdmVybG9uZ01hc2s9bnVsbDtpZigoYyYyMjQpPT09MTkyKXtleHRyYUxlbmd0aD0xO292ZXJsb25nTWFzaz0xMjd9ZWxzZSBpZigoYyYyNDApPT09MjI0KXtleHRyYUxlbmd0aD0yO292ZXJsb25nTWFzaz0yMDQ3fWVsc2UgaWYoKGMmMjQ4KT09PTI0MCl7ZXh0cmFMZW5ndGg9MztvdmVybG9uZ01hc2s9NjU1MzV9ZWxzZXtpZigoYyYxOTIpPT09MTI4KXtpKz1vbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFLGktMSxieXRlcyxyZXN1bHQpfWVsc2V7aSs9b25FcnJvcihVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCxpLTEsYnl0ZXMscmVzdWx0KX1jb250aW51ZX1pZihpLTErZXh0cmFMZW5ndGg+PWJ5dGVzLmxlbmd0aCl7aSs9b25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTixpLTEsYnl0ZXMscmVzdWx0KTtjb250aW51ZX1sZXQgcmVzPWMmKDE8PDgtZXh0cmFMZW5ndGgtMSktMTtmb3IobGV0IGo9MDtqPGV4dHJhTGVuZ3RoO2orKyl7bGV0IG5leHRDaGFyPWJ5dGVzW2ldO2lmKChuZXh0Q2hhciYxOTIpIT0xMjgpe2krPW9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk1JU1NJTkdfQ09OVElOVUUsaSxieXRlcyxyZXN1bHQpO3Jlcz1udWxsO2JyZWFrfXJlcz1yZXM8PDZ8bmV4dENoYXImNjM7aSsrfWlmKHJlcz09PW51bGwpe2NvbnRpbnVlfWlmKHJlcz4xMTE0MTExKXtpKz1vbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVVRfT0ZfUkFOR0UsaS0xLWV4dHJhTGVuZ3RoLGJ5dGVzLHJlc3VsdCxyZXMpO2NvbnRpbnVlfWlmKHJlcz49NTUyOTYmJnJlczw9NTczNDMpe2krPW9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVURjE2X1NVUlJPR0FURSxpLTEtZXh0cmFMZW5ndGgsYnl0ZXMscmVzdWx0LHJlcyk7Y29udGludWV9aWYocmVzPD1vdmVybG9uZ01hc2spe2krPW9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJMT05HLGktMS1leHRyYUxlbmd0aCxieXRlcyxyZXN1bHQscmVzKTtjb250aW51ZX1yZXN1bHQucHVzaChyZXMpfXJldHVybiByZXN1bHR9ZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLGZvcm09VW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpe2lmKGZvcm0hPVVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KXtsb2dnZXIkOS5jaGVja05vcm1hbGl6ZSgpO3N0cj1zdHIubm9ybWFsaXplKGZvcm0pfWxldCByZXN1bHQ9W107Zm9yKGxldCBpPTA7aTxzdHIubGVuZ3RoO2krKyl7Y29uc3QgYz1zdHIuY2hhckNvZGVBdChpKTtpZihjPDEyOCl7cmVzdWx0LnB1c2goYyl9ZWxzZSBpZihjPDIwNDgpe3Jlc3VsdC5wdXNoKGM+PjZ8MTkyKTtyZXN1bHQucHVzaChjJjYzfDEyOCl9ZWxzZSBpZigoYyY2NDUxMik9PTU1Mjk2KXtpKys7Y29uc3QgYzI9c3RyLmNoYXJDb2RlQXQoaSk7aWYoaT49c3RyLmxlbmd0aHx8KGMyJjY0NTEyKSE9PTU2MzIwKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0Zi04IHN0cmluZ1wiKX1jb25zdCBwYWlyPTY1NTM2KygoYyYxMDIzKTw8MTApKyhjMiYxMDIzKTtyZXN1bHQucHVzaChwYWlyPj4xOHwyNDApO3Jlc3VsdC5wdXNoKHBhaXI+PjEyJjYzfDEyOCk7cmVzdWx0LnB1c2gocGFpcj4+NiY2M3wxMjgpO3Jlc3VsdC5wdXNoKHBhaXImNjN8MTI4KX1lbHNle3Jlc3VsdC5wdXNoKGM+PjEyfDIyNCk7cmVzdWx0LnB1c2goYz4+NiY2M3wxMjgpO3Jlc3VsdC5wdXNoKGMmNjN8MTI4KX19cmV0dXJuIGFycmF5aWZ5KHJlc3VsdCl9ZnVuY3Rpb24gZXNjYXBlQ2hhcih2YWx1ZSl7Y29uc3QgaGV4PVwiMDAwMFwiK3ZhbHVlLnRvU3RyaW5nKDE2KTtyZXR1cm5cIlxcXFx1XCIraGV4LnN1YnN0cmluZyhoZXgubGVuZ3RoLTQpfWZ1bmN0aW9uIF90b0VzY2FwZWRVdGY4U3RyaW5nKGJ5dGVzLG9uRXJyb3Ipe3JldHVybidcIicrZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsb25FcnJvcikubWFwKGNvZGVQb2ludD0+e2lmKGNvZGVQb2ludDwyNTYpe3N3aXRjaChjb2RlUG9pbnQpe2Nhc2UgODpyZXR1cm5cIlxcXFxiXCI7Y2FzZSA5OnJldHVyblwiXFxcXHRcIjtjYXNlIDEwOnJldHVyblwiXFxcXG5cIjtjYXNlIDEzOnJldHVyblwiXFxcXHJcIjtjYXNlIDM0OnJldHVybidcXFxcXCInO2Nhc2UgOTI6cmV0dXJuXCJcXFxcXFxcXFwifWlmKGNvZGVQb2ludD49MzImJmNvZGVQb2ludDwxMjcpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCl9fWlmKGNvZGVQb2ludDw9NjU1MzUpe3JldHVybiBlc2NhcGVDaGFyKGNvZGVQb2ludCl9Y29kZVBvaW50LT02NTUzNjtyZXR1cm4gZXNjYXBlQ2hhcigoY29kZVBvaW50Pj4xMCYxMDIzKSs1NTI5NikrZXNjYXBlQ2hhcigoY29kZVBvaW50JjEwMjMpKzU2MzIwKX0pLmpvaW4oXCJcIikrJ1wiJ31mdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpe3JldHVybiBjb2RlUG9pbnRzLm1hcChjb2RlUG9pbnQ9PntpZihjb2RlUG9pbnQ8PTY1NTM1KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpfWNvZGVQb2ludC09NjU1MzY7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludD4+MTAmMTAyMykrNTUyOTYsKGNvZGVQb2ludCYxMDIzKSs1NjMyMCl9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcyxvbkVycm9yKXtyZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcyxvbkVycm9yKSl9ZnVuY3Rpb24gdG9VdGY4Q29kZVBvaW50cyhzdHIsZm9ybT1Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCl7cmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0cixmb3JtKSl9XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZm9ybWF0Qnl0ZXMzMlN0cmluZyh0ZXh0KXtjb25zdCBieXRlcz10b1V0ZjhCeXRlcyh0ZXh0KTtpZihieXRlcy5sZW5ndGg+MzEpe3Rocm93IG5ldyBFcnJvcihcImJ5dGVzMzIgc3RyaW5nIG11c3QgYmUgbGVzcyB0aGFuIDMyIGJ5dGVzXCIpfXJldHVybiBoZXhsaWZ5KGNvbmNhdChbYnl0ZXMsSGFzaFplcm9dKS5zbGljZSgwLDMyKSl9ZnVuY3Rpb24gcGFyc2VCeXRlczMyU3RyaW5nKGJ5dGVzKXtjb25zdCBkYXRhPWFycmF5aWZ5KGJ5dGVzKTtpZihkYXRhLmxlbmd0aCE9PTMyKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgLSBub3QgMzIgYnl0ZXMgbG9uZ1wiKX1pZihkYXRhWzMxXSE9PTApe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMzMiBzdHJpbmcgLSBubyBudWxsIHRlcm1pbmF0b3JcIil9bGV0IGxlbmd0aD0zMTt3aGlsZShkYXRhW2xlbmd0aC0xXT09PTApe2xlbmd0aC0tfXJldHVybiB0b1V0ZjhTdHJpbmcoZGF0YS5zbGljZSgwLGxlbmd0aCkpfVwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGJ5dGVzMihkYXRhKXtpZihkYXRhLmxlbmd0aCU0IT09MCl7dGhyb3cgbmV3IEVycm9yKFwiYmFkIGRhdGFcIil9bGV0IHJlc3VsdD1bXTtmb3IobGV0IGk9MDtpPGRhdGEubGVuZ3RoO2krPTQpe3Jlc3VsdC5wdXNoKHBhcnNlSW50KGRhdGEuc3Vic3RyaW5nKGksaSs0KSwxNikpfXJldHVybiByZXN1bHR9ZnVuY3Rpb24gY3JlYXRlVGFibGUoZGF0YSxmdW5jKXtpZighZnVuYyl7ZnVuYz1mdW5jdGlvbih2YWx1ZSl7cmV0dXJuW3BhcnNlSW50KHZhbHVlLDE2KV19fWxldCBsbz0wO2xldCByZXN1bHQ9e307ZGF0YS5zcGxpdChcIixcIikuZm9yRWFjaChwYWlyPT57bGV0IGNvbXBzPXBhaXIuc3BsaXQoXCI6XCIpO2xvKz1wYXJzZUludChjb21wc1swXSwxNik7cmVzdWx0W2xvXT1mdW5jKGNvbXBzWzFdKX0pO3JldHVybiByZXN1bHR9ZnVuY3Rpb24gY3JlYXRlUmFuZ2VUYWJsZShkYXRhKXtsZXQgaGk9MDtyZXR1cm4gZGF0YS5zcGxpdChcIixcIikubWFwKHY9PntsZXQgY29tcHM9di5zcGxpdChcIi1cIik7aWYoY29tcHMubGVuZ3RoPT09MSl7Y29tcHNbMV09XCIwXCJ9ZWxzZSBpZihjb21wc1sxXT09PVwiXCIpe2NvbXBzWzFdPVwiMVwifWxldCBsbz1oaStwYXJzZUludChjb21wc1swXSwxNik7aGk9cGFyc2VJbnQoY29tcHNbMV0sMTYpO3JldHVybntsOmxvLGg6aGl9fSl9ZnVuY3Rpb24gbWF0Y2hNYXAodmFsdWUscmFuZ2VzKXtsZXQgbG89MDtmb3IobGV0IGk9MDtpPHJhbmdlcy5sZW5ndGg7aSsrKXtsZXQgcmFuZ2U9cmFuZ2VzW2ldO2xvKz1yYW5nZS5sO2lmKHZhbHVlPj1sbyYmdmFsdWU8PWxvK3JhbmdlLmgmJih2YWx1ZS1sbyklKHJhbmdlLmR8fDEpPT09MCl7aWYocmFuZ2UuZSYmcmFuZ2UuZS5pbmRleE9mKHZhbHVlLWxvKSE9PS0xKXtjb250aW51ZX1yZXR1cm4gcmFuZ2V9fXJldHVybiBudWxsfWNvbnN0IFRhYmxlX0FfMV9yYW5nZXM9Y3JlYXRlUmFuZ2VUYWJsZShcIjIyMSwxMy0xYiw1Zi0sNDAtMTAsNTEtZiwxMS0zLDMtMywyLTIsMi00LDgsMiwxNSwyZCwyOC04LDg4LDQ4LDI3LSwzLTUsMTEtMjAsMjctLDgsMjgsMy01LDEyLDE4LGItYSwxYy00LDYtMTYsMi1kLDItMiwyLDFiLTQsMTctOSw4Zi0sMTAsZiwxZi0yLDFjLTM0LDMzLTE0ZSw0LDM2LSwxMy0sNi0yLDFhLWYsNCw5LSwzLSwxNyw4LDItMiw1LSwyLDgtLDMtLDQtOCwyLTMsMyw2LSwxNi02LDItLDctMywzLSwxNyw4LDMsMywzLSwyLDYtMywzLSw0LWEsNSwyLTYsMTAtYiw0LDgsMiw0LDE3LDgsMyw2LSxiLDQsNC0sMi1lLDItNCxiLTEwLDQsOS0sMy0sMTcsOCwzLSw1LSw5LTIsMy0sNC03LDMtMywzLDQtMyxjLTEwLDMsNy0yLDQsNS0yLDMsMiwzLTIsMy0yLDQtMiw5LDQtMyw2LTIsNCw1LTgsMi1lLGQtZCw0LDksNCwxOCxiLDYtMyw4LDQsNS02LDMtOCwzLTMsYi0xMSwzLDksNCwxOCxiLDYtMyw4LDQsNS02LDMtNiwyLDMtMyxiLTExLDMsOSw0LDE4LDExLTMsNy0sNCw1LTgsMi03LDMtMyxiLTExLDMsMTMtMiwxOSxhLDItLDgtMiwyLTMsNywyLDktMTEsNC1iLDNiLTMsMWUtMjQsMywyLSwzLDItLDItNSw1LDgsNCwyLDItLDMsZSw0LSw2LDIsNy0sYi0sMy0yMSw0OSwyMy01LDFjLTMsOSwyNSwxMC0sMi0yZiwyMyw2LDMsOC0yLDUtNSwxYi00NSwyNy05LDJhLSwyLTMsNWItNCw0NS00LDUzLTUsOCw0MCwyLDUtLDgsMiw1LSwyOCwyLDUtLDIwLDIsNS0sOCwyLDUtLDgsOCwxOCwyMCwyLDUtLDgsMjgsMTQtNSwxZC0yMiw1Ni1iLDI3Ny04LDFlLTIsNTItZSxlLDgtYSwxOC04LDE1LWIsZSw0LDMtYiw1ZS0yLGItMTUsMTAsYi01LDU5LTcsMmItNTU1LDlkLTMsNWItNSwxNy0sNy0sMjctLDctLDksMiwyLDIsMjAtLDM2LDEwLGYtLDcsMTQtLDQsYSw1NC0zLDItNiw2LTUsOS0sMWMtMTAsMTMtMWQsMWMtMTQsM2MtLDEwLTYsMzItYiwyNDAtMzAsMjgtMTgsYy0xNCxhMCwxMTUtLDMsNjYtLGItNzYsNSw1LSwxZCwyNCwyLDUtMiwyLDgtLDM1LTIsMTksZi0xMCwxZC0zLDMxMS0zN2YsMWIsNWEtYixkNy0xOSxkLTMsNDEsNTctLDY4LTQsMjktMyw1ZiwyOS0zNywyZS0yLDI1LWMsMmMtMiw0ZS0zLDMwLDc4LTMsNjQtLDIwLDE5YjctNDksNTFhNy01OSw0OGUtMiwzOC03MzgsMmJhNS01YiwyMjJmLSwzYy05NCw4LWIsNi00LDFiLDYsMiwzLDMsNmQtMjAsMTZlLWYsNDEtLDM3LTcsMmUtMiwxMS1mLDUtYiwxOC0sYiwxNCw1LTMsNiw4OC0sMixiZi0yLDctLDctLDctLDQtMiw4LDgtOSw4LTJmZiwyMCw1LWIsMWMtYjQsMjctLDI3LWNiYjEsZjctOSwyOC0yLGI1LTIyMSw1Niw0OCwzLSwyLSwzLSw1LGQsMiw1LDMsNDIsNS0sOSw4LDFkLDUsNiwyLTIsOCwxNTMtMywxMjMtMywzMy0yN2ZkLGE2ZGEtNTEyOCwyMWYtNWRmLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMywyLTFkLDYxLWZmN2RcIik7Y29uc3QgVGFibGVfQl8xX2ZsYWdzPVwiYWQsMzRmLDE4MDYsMTgwYiwxODBjLDE4MGQsMjAwYiwyMDBjLDIwMGQsMjA2MCxmZWZmXCIuc3BsaXQoXCIsXCIpLm1hcCh2PT5wYXJzZUludCh2LDE2KSk7Y29uc3QgVGFibGVfQl8yX3Jhbmdlcz1be2g6MjUsczozMixsOjY1fSx7aDozMCxzOjMyLGU6WzIzXSxsOjEyN30se2g6NTQsczoxLGU6WzQ4XSxsOjY0LGQ6Mn0se2g6MTQsczoxLGw6NTcsZDoyfSx7aDo0NCxzOjEsbDoxNyxkOjJ9LHtoOjEwLHM6MSxlOlsyLDYsOF0sbDo2MSxkOjJ9LHtoOjE2LHM6MSxsOjY4LGQ6Mn0se2g6ODQsczoxLGU6WzE4LDI0LDY2XSxsOjE5LGQ6Mn0se2g6MjYsczozMixlOlsxN10sbDo0MzV9LHtoOjIyLHM6MSxsOjcxLGQ6Mn0se2g6MTUsczo4MCxsOjQwfSx7aDozMSxzOjMyLGw6MTZ9LHtoOjMyLHM6MSxsOjgwLGQ6Mn0se2g6NTIsczoxLGw6NDIsZDoyfSx7aDoxMixzOjEsbDo1NSxkOjJ9LHtoOjQwLHM6MSxlOlszOF0sbDoxNSxkOjJ9LHtoOjE0LHM6MSxsOjQ4LGQ6Mn0se2g6Mzcsczo0OCxsOjQ5fSx7aDoxNDgsczoxLGw6NjM1MSxkOjJ9LHtoOjg4LHM6MSxsOjE2MCxkOjJ9LHtoOjE1LHM6MTYsbDo3MDR9LHtoOjI1LHM6MjYsbDo4NTR9LHtoOjI1LHM6MzIsbDo1NTkxNX0se2g6Mzcsczo0MCxsOjEyNDd9LHtoOjI1LHM6LTExOTcxMSxsOjUzMjQ4fSx7aDoyNSxzOi0xMTk3NjMsbDo1Mn0se2g6MjUsczotMTE5ODE1LGw6NTJ9LHtoOjI1LHM6LTExOTg2NyxlOlsxLDQsNSw3LDgsMTEsMTIsMTddLGw6NTJ9LHtoOjI1LHM6LTExOTkxOSxsOjUyfSx7aDoyNCxzOi0xMTk5NzEsZTpbMiw3LDgsMTddLGw6NTJ9LHtoOjI0LHM6LTEyMDAyMyxlOlsyLDcsMTMsMTUsMTYsMTddLGw6NTJ9LHtoOjI1LHM6LTEyMDA3NSxsOjUyfSx7aDoyNSxzOi0xMjAxMjcsbDo1Mn0se2g6MjUsczotMTIwMTc5LGw6NTJ9LHtoOjI1LHM6LTEyMDIzMSxsOjUyfSx7aDoyNSxzOi0xMjAyODMsbDo1Mn0se2g6MjUsczotMTIwMzM1LGw6NTJ9LHtoOjI0LHM6LTExOTU0MyxlOlsxN10sbDo1Nn0se2g6MjQsczotMTE5NjAxLGU6WzE3XSxsOjU4fSx7aDoyNCxzOi0xMTk2NTksZTpbMTddLGw6NTh9LHtoOjI0LHM6LTExOTcxNyxlOlsxN10sbDo1OH0se2g6MjQsczotMTE5Nzc1LGU6WzE3XSxsOjU4fV07Y29uc3QgVGFibGVfQl8yX2x1dF9hYnM9Y3JlYXRlVGFibGUoXCJiNTozYmMsYzM6ZmYsNzo3MywyOjI1Myw1OjI1NCwzOjI1NiwxOjI1Nyw1OjI1OSwxOjI1YiwzOjI2MCwxOjI2MywyOjI2OSwxOjI2OCw1OjI2ZiwxOjI3MiwyOjI3NSw3OjI4MCwzOjI4Myw1OjI4OCwzOjI4YSwxOjI4Yiw1OjI5MiwzZjoxOTUsMToxYmYsMjk6MTllLDEyNTozYjksOGI6M2IyLDE6M2I4LDE6M2M1LDM6M2M2LDE6M2MwLDFhOjNiYSwxOjNjMSwxOjNjMywyOjNiOCwxOjNiNSwxYmM5OjNiOSwxYzoxZjc2LDE6MWY3NyxmOjFmN2EsMToxZjdiLGQ6MWY3OCwxOjFmNzksMToxZjdjLDE6MWY3ZCwxMDc6NjMsNToyNWIsNDo2OCwxOjY4LDE6NjgsMzo2OSwxOjY5LDE6NmMsMzo2ZSw0OjcwLDE6NzEsMTo3MiwxOjcyLDE6NzIsNzo3YSwyOjNjOSwyOjdhLDI6NmIsMTplNSwxOjYyLDE6NjMsMzo2NSwxOjY2LDI6NmQsYjozYjMsMTozYzAsNjo2NCwxYjU3NDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzNcIik7Y29uc3QgVGFibGVfQl8yX2x1dF9yZWw9Y3JlYXRlVGFibGUoXCIxNzk6MSwyOjEsMjoxLDU6MSwyOjEsYTo0ZixhOjEsODoxLDI6MSwyOjEsMzoxLDU6MSwzOjEsNDoxLDI6MSwzOjEsNDoxLDg6MiwxOjEsMjoyLDE6MSwyOjIsMjc6MiwxOTU6MjYsMjoyNSwxOjI1LDE6MjUsMjo0MCwyOjNmLDE6M2YsMzM6MSwxMTotNiwxOi05LDFhYzc6LTNhLDZkOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYjotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxjOi04LDI6LTgsMjotOCwyOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw0OTotOCwxOi04LDE6LTRhLDE6LTRhLGQ6LTU2LDE6LTU2LDE6LTU2LDE6LTU2LGQ6LTgsMTotOCxmOi04LDE6LTgsMzotN1wiKTtjb25zdCBUYWJsZV9CXzJfY29tcGxleD1jcmVhdGVUYWJsZShcImRmOjAwNzMwMDczLDUxOjAwNjkwMzA3LDE5OjAyQkMwMDZFLGE3OjAwNkEwMzBDLDE4YTowMDIwMDNCOSwxNjowM0I5MDMwODAzMDEsMjA6MDNDNTAzMDgwMzAxLDFkNzowNTY1MDU4MiwxOTBmOjAwNjgwMzMxLDE6MDA3NDAzMDgsMTowMDc3MDMwQSwxOjAwNzkwMzBBLDE6MDA2MTAyQkUsYjY6MDNDNTAzMTMsMjowM0M1MDMxMzAzMDAsMjowM0M1MDMxMzAzMDEsMjowM0M1MDMxMzAzNDIsMmE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDM6MUY3MDAzQjksMTowM0IxMDNCOSwxOjAzQUMwM0I5LDI6MDNCMTAzNDIsMTowM0IxMDM0MjAzQjksNTowM0IxMDNCOSw2OjFGNzQwM0I5LDE6MDNCNzAzQjksMTowM0FFMDNCOSwyOjAzQjcwMzQyLDE6MDNCNzAzNDIwM0I5LDU6MDNCNzAzQjksNjowM0I5MDMwODAzMDAsMTowM0I5MDMwODAzMDEsMzowM0I5MDM0MiwxOjAzQjkwMzA4MDM0MixiOjAzQzUwMzA4MDMwMCwxOjAzQzUwMzA4MDMwMSwxOjAzQzEwMzEzLDI6MDNDNTAzNDIsMTowM0M1MDMwODAzNDIsYjoxRjdDMDNCOSwxOjAzQzkwM0I5LDE6MDNDRTAzQjksMjowM0M5MDM0MiwxOjAzQzkwMzQyMDNCOSw1OjAzQzkwM0I5LGFjOjAwNzIwMDczLDViOjAwQjAwMDYzLDY6MDBCMDAwNjYsZDowMDZFMDA2RixhOjAwNzMwMDZELDE6MDA3NDAwNjUwMDZDLDE6MDA3NDAwNkQsMTI0ZjowMDY4MDA3MDAwNjEsMjowMDYxMDA3NSwyOjAwNkYwMDc2LGI6MDA3MDAwNjEsMTowMDZFMDA2MSwxOjAzQkMwMDYxLDE6MDA2RDAwNjEsMTowMDZCMDA2MSwxOjAwNkIwMDYyLDE6MDA2RDAwNjIsMTowMDY3MDA2MiwzOjAwNzAwMDY2LDE6MDA2RTAwNjYsMTowM0JDMDA2Niw0OjAwNjgwMDdBLDE6MDA2QjAwNjgwMDdBLDE6MDA2RDAwNjgwMDdBLDE6MDA2NzAwNjgwMDdBLDE6MDA3NDAwNjgwMDdBLDE1OjAwNzAwMDYxLDE6MDA2QjAwNzAwMDYxLDE6MDA2RDAwNzAwMDYxLDE6MDA2NzAwNzAwMDYxLDg6MDA3MDAwNzYsMTowMDZFMDA3NiwxOjAzQkMwMDc2LDE6MDA2RDAwNzYsMTowMDZCMDA3NiwxOjAwNkQwMDc2LDE6MDA3MDAwNzcsMTowMDZFMDA3NywxOjAzQkMwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAzQzksMTowMDZEMDNDOSwyOjAwNjIwMDcxLDM6MDA2MzIyMTUwMDZCMDA2NywxOjAwNjMwMDZGMDAyRSwxOjAwNjQwMDYyLDE6MDA2NzAwNzksMjowMDY4MDA3MCwyOjAwNkIwMDZCLDE6MDA2QjAwNkQsOTowMDcwMDA2OCwyOjAwNzAwMDcwMDA2RCwxOjAwNzAwMDcyLDI6MDA3MzAwNzYsMTowMDc3MDA2MixjNzIzOjAwNjYwMDY2LDE6MDA2NjAwNjksMTowMDY2MDA2QywxOjAwNjYwMDY2MDA2OSwxOjAwNjYwMDY2MDA2QywxOjAwNzMwMDc0LDE6MDA3MzAwNzQsZDowNTc0MDU3NiwxOjA1NzQwNTY1LDE6MDU3NDA1NkIsMTowNTdFMDU3NiwxOjA1NzQwNTZEXCIsYnl0ZXMyKTtjb25zdCBUYWJsZV9DX3Jhbmdlcz1jcmVhdGVSYW5nZVRhYmxlKFwiODAtMjAsMmEwLSwzOWMsMzIsZjcxLDE4ZSw3ZjItZiwxOS03LDMwLTQsNy01LGY4MS1iLDUsYTgwMC0yMGZmLDRkMS0xZiwxMTAsZmEtNixkMTc0LTcsMmU4NC0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sMiwxZi01ZixmZjdmLTIwMDAxXCIpO2Z1bmN0aW9uIGZsYXR0ZW4odmFsdWVzKXtyZXR1cm4gdmFsdWVzLnJlZHVjZSgoYWNjdW0sdmFsdWUpPT57dmFsdWUuZm9yRWFjaCh2YWx1ZT0+e2FjY3VtLnB1c2godmFsdWUpfSk7cmV0dXJuIGFjY3VtfSxbXSl9ZnVuY3Rpb24gX25hbWVwcmVwVGFibGVBMShjb2RlcG9pbnQpe3JldHVybiEhbWF0Y2hNYXAoY29kZXBvaW50LFRhYmxlX0FfMV9yYW5nZXMpfWZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQjIoY29kZXBvaW50KXtsZXQgcmFuZ2U9bWF0Y2hNYXAoY29kZXBvaW50LFRhYmxlX0JfMl9yYW5nZXMpO2lmKHJhbmdlKXtyZXR1cm5bY29kZXBvaW50K3JhbmdlLnNdfWxldCBjb2Rlcz1UYWJsZV9CXzJfbHV0X2Fic1tjb2RlcG9pbnRdO2lmKGNvZGVzKXtyZXR1cm4gY29kZXN9bGV0IHNoaWZ0PVRhYmxlX0JfMl9sdXRfcmVsW2NvZGVwb2ludF07aWYoc2hpZnQpe3JldHVybltjb2RlcG9pbnQrc2hpZnRbMF1dfWxldCBjb21wbGV4PVRhYmxlX0JfMl9jb21wbGV4W2NvZGVwb2ludF07aWYoY29tcGxleCl7cmV0dXJuIGNvbXBsZXh9cmV0dXJuIG51bGx9ZnVuY3Rpb24gX25hbWVwcmVwVGFibGVDKGNvZGVwb2ludCl7cmV0dXJuISFtYXRjaE1hcChjb2RlcG9pbnQsVGFibGVfQ19yYW5nZXMpfWZ1bmN0aW9uIG5hbWVwcmVwKHZhbHVlKXtpZih2YWx1ZS5tYXRjaCgvXlthLXowLTktXSokL2kpJiZ2YWx1ZS5sZW5ndGg8PTU5KXtyZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKX1sZXQgY29kZXM9dG9VdGY4Q29kZVBvaW50cyh2YWx1ZSk7Y29kZXM9ZmxhdHRlbihjb2Rlcy5tYXAoY29kZT0+e2lmKFRhYmxlX0JfMV9mbGFncy5pbmRleE9mKGNvZGUpPj0wKXtyZXR1cm5bXX1pZihjb2RlPj02NTAyNCYmY29kZTw9NjUwMzkpe3JldHVybltdfWxldCBjb2Rlc1RhYmxlQjI9X25hbWVwcmVwVGFibGVCMihjb2RlKTtpZihjb2Rlc1RhYmxlQjIpe3JldHVybiBjb2Rlc1RhYmxlQjJ9cmV0dXJuW2NvZGVdfSkpO2NvZGVzPXRvVXRmOENvZGVQb2ludHMoX3RvVXRmOFN0cmluZyhjb2RlcyksVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO2NvZGVzLmZvckVhY2goY29kZT0+e2lmKF9uYW1lcHJlcFRhYmxlQyhjb2RlKSl7dGhyb3cgbmV3IEVycm9yKFwiU1RSSU5HUFJFUF9DT05UQUlOU19QUk9ISUJJVEVEXCIpfX0pO2NvZGVzLmZvckVhY2goY29kZT0+e2lmKF9uYW1lcHJlcFRhYmxlQTEoY29kZSkpe3Rocm93IG5ldyBFcnJvcihcIlNUUklOR1BSRVBfQ09OVEFJTlNfVU5BU1NJR05FRFwiKX19KTtsZXQgbmFtZT1fdG9VdGY4U3RyaW5nKGNvZGVzKTtpZihuYW1lLnN1YnN0cmluZygwLDEpPT09XCItXCJ8fG5hbWUuc3Vic3RyaW5nKDIsNCk9PT1cIi0tXCJ8fG5hbWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoLTEpPT09XCItXCIpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgaHlwaGVuXCIpfWlmKG5hbWUubGVuZ3RoPjYzKXt0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbG9uZ1wiKX1yZXR1cm4gbmFtZX1cInVzZSBzdHJpY3RcIjtcInVzZSBzdHJpY3RcIjtjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVye2NvbnN0cnVjdG9yKGxvY2FsTmFtZSl7c3VwZXIoXCJzdHJpbmdcIixsb2NhbE5hbWUpfWRlZmF1bHRWYWx1ZSgpe3JldHVyblwiXCJ9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7cmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsdG9VdGY4Qnl0ZXModmFsdWUpKX1kZWNvZGUocmVhZGVyKXtyZXR1cm4gdG9VdGY4U3RyaW5nKHN1cGVyLmRlY29kZShyZWFkZXIpKX19XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIENvZGVye2NvbnN0cnVjdG9yKGNvZGVycyxsb2NhbE5hbWUpe2xldCBkeW5hbWljPWZhbHNlO2NvbnN0IHR5cGVzPVtdO2NvZGVycy5mb3JFYWNoKGNvZGVyPT57aWYoY29kZXIuZHluYW1pYyl7ZHluYW1pYz10cnVlfXR5cGVzLnB1c2goY29kZXIudHlwZSl9KTtjb25zdCB0eXBlPVwidHVwbGUoXCIrdHlwZXMuam9pbihcIixcIikrXCIpXCI7c3VwZXIoXCJ0dXBsZVwiLHR5cGUsbG9jYWxOYW1lLGR5bmFtaWMpO3RoaXMuY29kZXJzPWNvZGVyc31kZWZhdWx0VmFsdWUoKXtjb25zdCB2YWx1ZXM9W107dGhpcy5jb2RlcnMuZm9yRWFjaChjb2Rlcj0+e3ZhbHVlcy5wdXNoKGNvZGVyLmRlZmF1bHRWYWx1ZSgpKX0pO2NvbnN0IHVuaXF1ZU5hbWVzPXRoaXMuY29kZXJzLnJlZHVjZSgoYWNjdW0sY29kZXIpPT57Y29uc3QgbmFtZT1jb2Rlci5sb2NhbE5hbWU7aWYobmFtZSl7aWYoIWFjY3VtW25hbWVdKXthY2N1bVtuYW1lXT0wfWFjY3VtW25hbWVdKyt9cmV0dXJuIGFjY3VtfSx7fSk7dGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIsaW5kZXgpPT57bGV0IG5hbWU9Y29kZXIubG9jYWxOYW1lO2lmKCFuYW1lfHx1bmlxdWVOYW1lc1tuYW1lXSE9PTEpe3JldHVybn1pZihuYW1lPT09XCJsZW5ndGhcIil7bmFtZT1cIl9sZW5ndGhcIn1pZih2YWx1ZXNbbmFtZV0hPW51bGwpe3JldHVybn12YWx1ZXNbbmFtZV09dmFsdWVzW2luZGV4XX0pO3JldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyl9ZW5jb2RlKHdyaXRlcix2YWx1ZSl7cmV0dXJuIHBhY2sod3JpdGVyLHRoaXMuY29kZXJzLHZhbHVlKX1kZWNvZGUocmVhZGVyKXtyZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsdW5wYWNrKHJlYWRlcix0aGlzLmNvZGVycykpfX1cInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkYT1uZXcgTG9nZ2VyKHZlcnNpb24kNCk7Y29uc3QgcGFyYW1UeXBlQnl0ZXM9bmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7Y29uc3QgcGFyYW1UeXBlTnVtYmVyPW5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7Y2xhc3MgQWJpQ29kZXJ7Y29uc3RydWN0b3IoY29lcmNlRnVuYyl7bG9nZ2VyJGEuY2hlY2tOZXcobmV3LnRhcmdldCxBYmlDb2Rlcik7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImNvZXJjZUZ1bmNcIixjb2VyY2VGdW5jfHxudWxsKX1fZ2V0Q29kZXIocGFyYW0pe3N3aXRjaChwYXJhbS5iYXNlVHlwZSl7Y2FzZVwiYWRkcmVzc1wiOnJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO2Nhc2VcImJvb2xcIjpyZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gbmV3IFN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO2Nhc2VcImJ5dGVzXCI6cmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO2Nhc2VcImFycmF5XCI6cmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuX2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLHBhcmFtLmFycmF5TGVuZ3RoLHBhcmFtLm5hbWUpO2Nhc2VcInR1cGxlXCI6cmV0dXJuIG5ldyBUdXBsZUNvZGVyKChwYXJhbS5jb21wb25lbnRzfHxbXSkubWFwKGNvbXBvbmVudD0+e3JldHVybiB0aGlzLl9nZXRDb2Rlcihjb21wb25lbnQpfSkscGFyYW0ubmFtZSk7Y2FzZVwiXCI6cmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSl9bGV0IG1hdGNoPXBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtpZihtYXRjaCl7bGV0IHNpemU9cGFyc2VJbnQobWF0Y2hbMl18fFwiMjU2XCIpO2lmKHNpemU9PT0wfHxzaXplPjI1Nnx8c2l6ZSU4IT09MCl7bG9nZ2VyJGEudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBcIittYXRjaFsxXStcIiBiaXQgbGVuZ3RoXCIsXCJwYXJhbVwiLHBhcmFtKX1yZXR1cm4gbmV3IE51bWJlckNvZGVyKHNpemUvOCxtYXRjaFsxXT09PVwiaW50XCIscGFyYW0ubmFtZSl9bWF0Y2g9cGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7aWYobWF0Y2gpe2xldCBzaXplPXBhcnNlSW50KG1hdGNoWzFdKTtpZihzaXplPT09MHx8c2l6ZT4zMil7bG9nZ2VyJGEudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIixcInBhcmFtXCIscGFyYW0pfXJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUscGFyYW0ubmFtZSl9cmV0dXJuIGxvZ2dlciRhLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHlwZVwiLFwidHlwZVwiLHBhcmFtLnR5cGUpfV9nZXRXb3JkU2l6ZSgpe3JldHVybiAzMn1fZ2V0UmVhZGVyKGRhdGEsYWxsb3dMb29zZSl7cmV0dXJuIG5ldyBSZWFkZXIoZGF0YSx0aGlzLl9nZXRXb3JkU2l6ZSgpLHRoaXMuY29lcmNlRnVuYyxhbGxvd0xvb3NlKX1fZ2V0V3JpdGVyKCl7cmV0dXJuIG5ldyBXcml0ZXIodGhpcy5fZ2V0V29yZFNpemUoKSl9Z2V0RGVmYXVsdFZhbHVlKHR5cGVzKXtjb25zdCBjb2RlcnM9dHlwZXMubWFwKHR5cGU9PnRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7Y29uc3QgY29kZXI9bmV3IFR1cGxlQ29kZXIoY29kZXJzLFwiX1wiKTtyZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCl9ZW5jb2RlKHR5cGVzLHZhbHVlcyl7aWYodHlwZXMubGVuZ3RoIT09dmFsdWVzLmxlbmd0aCl7bG9nZ2VyJGEudGhyb3dFcnJvcihcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIixMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQse2NvdW50Ont0eXBlczp0eXBlcy5sZW5ndGgsdmFsdWVzOnZhbHVlcy5sZW5ndGh9LHZhbHVlOnt0eXBlczp0eXBlcyx2YWx1ZXM6dmFsdWVzfX0pfWNvbnN0IGNvZGVycz10eXBlcy5tYXAodHlwZT0+dGhpcy5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtjb25zdCBjb2Rlcj1uZXcgVHVwbGVDb2Rlcihjb2RlcnMsXCJfXCIpO2NvbnN0IHdyaXRlcj10aGlzLl9nZXRXcml0ZXIoKTtjb2Rlci5lbmNvZGUod3JpdGVyLHZhbHVlcyk7cmV0dXJuIHdyaXRlci5kYXRhfWRlY29kZSh0eXBlcyxkYXRhLGxvb3NlKXtjb25zdCBjb2RlcnM9dHlwZXMubWFwKHR5cGU9PnRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7Y29uc3QgY29kZXI9bmV3IFR1cGxlQ29kZXIoY29kZXJzLFwiX1wiKTtyZXR1cm4gY29kZXIuZGVjb2RlKHRoaXMuX2dldFJlYWRlcihhcnJheWlmeShkYXRhKSxsb29zZSkpfX1jb25zdCBkZWZhdWx0QWJpQ29kZXI9bmV3IEFiaUNvZGVyO2Z1bmN0aW9uIGlkKHRleHQpe3JldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModGV4dCkpfWNvbnN0IHZlcnNpb24kOD1cImhhc2gvNS4xLjBcIjtjb25zdCBsb2dnZXIkYj1uZXcgTG9nZ2VyKHZlcnNpb24kOCk7Y29uc3QgWmVyb3M9bmV3IFVpbnQ4QXJyYXkoMzIpO1plcm9zLmZpbGwoMCk7Y29uc3QgUGFydGl0aW9uPW5ldyBSZWdFeHAoXCJeKCguKilcXFxcLik/KFteLl0rKSRcIik7ZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSl7dHJ5e2NvbnN0IGNvbXBzPW5hbWUuc3BsaXQoXCIuXCIpO2ZvcihsZXQgaT0wO2k8Y29tcHMubGVuZ3RoO2krKyl7aWYobmFtZXByZXAoY29tcHNbaV0pLmxlbmd0aD09PTApe3Rocm93IG5ldyBFcnJvcihcImVtcHR5XCIpfX1yZXR1cm4gdHJ1ZX1jYXRjaChlcnJvcil7fXJldHVybiBmYWxzZX1mdW5jdGlvbiBuYW1laGFzaChuYW1lKXtpZih0eXBlb2YgbmFtZSE9PVwic3RyaW5nXCIpe2xvZ2dlciRiLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyAtIFwiK1N0cmluZyhuYW1lKSxcIm5hbWVcIixuYW1lKX1sZXQgcmVzdWx0PVplcm9zO3doaWxlKG5hbWUubGVuZ3RoKXtjb25zdCBwYXJ0aXRpb249bmFtZS5tYXRjaChQYXJ0aXRpb24pO2NvbnN0IGxhYmVsPXRvVXRmOEJ5dGVzKG5hbWVwcmVwKHBhcnRpdGlvblszXSkpO3Jlc3VsdD1rZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsa2VjY2FrMjU2KGxhYmVsKV0pKTtuYW1lPXBhcnRpdGlvblsyXXx8XCJcIn1yZXR1cm4gaGV4bGlmeShyZXN1bHQpfWNvbnN0IG1lc3NhZ2VQcmVmaXg9XCJcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIjtmdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlKXtpZih0eXBlb2YgbWVzc2FnZT09PVwic3RyaW5nXCIpe21lc3NhZ2U9dG9VdGY4Qnl0ZXMobWVzc2FnZSl9cmV0dXJuIGtlY2NhazI1Nihjb25jYXQoW3RvVXRmOEJ5dGVzKG1lc3NhZ2VQcmVmaXgpLHRvVXRmOEJ5dGVzKFN0cmluZyhtZXNzYWdlLmxlbmd0aCkpLG1lc3NhZ2VdKSl9dmFyIF9fYXdhaXRlciQxPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkYz1uZXcgTG9nZ2VyKHZlcnNpb24kOCk7Y29uc3QgcGFkZGluZz1uZXcgVWludDhBcnJheSgzMik7cGFkZGluZy5maWxsKDApO2NvbnN0IE5lZ2F0aXZlT25lJDI9QmlnTnVtYmVyLmZyb20oLTEpO2NvbnN0IFplcm8kMj1CaWdOdW1iZXIuZnJvbSgwKTtjb25zdCBPbmUkMT1CaWdOdW1iZXIuZnJvbSgxKTtjb25zdCBNYXhVaW50MjU2JDE9QmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7ZnVuY3Rpb24gaGV4UGFkUmlnaHQodmFsdWUpe2NvbnN0IGJ5dGVzPWFycmF5aWZ5KHZhbHVlKTtjb25zdCBwYWRPZmZzZXQ9Ynl0ZXMubGVuZ3RoJTMyO2lmKHBhZE9mZnNldCl7cmV0dXJuIGhleENvbmNhdChbYnl0ZXMscGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSl9cmV0dXJuIGhleGxpZnkoYnl0ZXMpfWNvbnN0IGhleFRydWU9aGV4WmVyb1BhZChPbmUkMS50b0hleFN0cmluZygpLDMyKTtjb25zdCBoZXhGYWxzZT1oZXhaZXJvUGFkKFplcm8kMi50b0hleFN0cmluZygpLDMyKTtjb25zdCBkb21haW5GaWVsZFR5cGVzPXtuYW1lOlwic3RyaW5nXCIsdmVyc2lvbjpcInN0cmluZ1wiLGNoYWluSWQ6XCJ1aW50MjU2XCIsdmVyaWZ5aW5nQ29udHJhY3Q6XCJhZGRyZXNzXCIsc2FsdDpcImJ5dGVzMzJcIn07Y29uc3QgZG9tYWluRmllbGROYW1lcz1bXCJuYW1lXCIsXCJ2ZXJzaW9uXCIsXCJjaGFpbklkXCIsXCJ2ZXJpZnlpbmdDb250cmFjdFwiLFwic2FsdFwiXTtmdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpe3JldHVybiBmdW5jdGlvbih2YWx1ZSl7aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcIil7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgJHtKU09OLnN0cmluZ2lmeShrZXkpfWAsYGRvbWFpbi4ke2tleX1gLHZhbHVlKX1yZXR1cm4gdmFsdWV9fWNvbnN0IGRvbWFpbkNoZWNrcz17bmFtZTpjaGVja1N0cmluZyhcIm5hbWVcIiksdmVyc2lvbjpjaGVja1N0cmluZyhcInZlcnNpb25cIiksY2hhaW5JZDpmdW5jdGlvbih2YWx1ZSl7dHJ5e3JldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoKX1jYXRjaChlcnJvcil7fXJldHVybiBsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciBcImNoYWluSWRcImAsXCJkb21haW4uY2hhaW5JZFwiLHZhbHVlKX0sdmVyaWZ5aW5nQ29udHJhY3Q6ZnVuY3Rpb24odmFsdWUpe3RyeXtyZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSkudG9Mb3dlckNhc2UoKX1jYXRjaChlcnJvcil7fXJldHVybiBsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsXCJkb21haW4udmVyaWZ5aW5nQ29udHJhY3RcIix2YWx1ZSl9LHNhbHQ6ZnVuY3Rpb24odmFsdWUpe3RyeXtjb25zdCBieXRlcz1hcnJheWlmeSh2YWx1ZSk7aWYoYnl0ZXMubGVuZ3RoIT09MzIpe3Rocm93IG5ldyBFcnJvcihcImJhZCBsZW5ndGhcIil9cmV0dXJuIGhleGxpZnkoYnl0ZXMpfWNhdGNoKGVycm9yKXt9cmV0dXJuIGxvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgXCJzYWx0XCJgLFwiZG9tYWluLnNhbHRcIix2YWx1ZSl9fTtmdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKXt7Y29uc3QgbWF0Y2g9dHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKikkLyk7aWYobWF0Y2gpe2NvbnN0IHNpZ25lZD1tYXRjaFsxXT09PVwiXCI7Y29uc3Qgd2lkdGg9cGFyc2VJbnQobWF0Y2hbMl18fFwiMjU2XCIpO2lmKHdpZHRoJTghPT0wfHx3aWR0aD4yNTZ8fG1hdGNoWzJdJiZtYXRjaFsyXSE9PVN0cmluZyh3aWR0aCkpe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLFwidHlwZVwiLHR5cGUpfWNvbnN0IGJvdW5kc1VwcGVyPU1heFVpbnQyNTYkMS5tYXNrKHNpZ25lZD93aWR0aC0xOndpZHRoKTtjb25zdCBib3VuZHNMb3dlcj1zaWduZWQ/Ym91bmRzVXBwZXIuYWRkKE9uZSQxKS5tdWwoTmVnYXRpdmVPbmUkMik6WmVybyQyO3JldHVybiBmdW5jdGlvbih2YWx1ZSl7Y29uc3Qgdj1CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7aWYodi5sdChib3VuZHNMb3dlcil8fHYuZ3QoYm91bmRzVXBwZXIpKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLFwidmFsdWVcIix2YWx1ZSl9cmV0dXJuIGhleFplcm9QYWQodi50b1R3b3MoMjU2KS50b0hleFN0cmluZygpLDMyKX19fXtjb25zdCBtYXRjaD10eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7aWYobWF0Y2gpe2NvbnN0IHdpZHRoPXBhcnNlSW50KG1hdGNoWzFdKTtpZih3aWR0aD09PTB8fHdpZHRoPjMyfHxtYXRjaFsxXSE9PVN0cmluZyh3aWR0aCkpe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZXMgd2lkdGhcIixcInR5cGVcIix0eXBlKX1yZXR1cm4gZnVuY3Rpb24odmFsdWUpe2NvbnN0IGJ5dGVzPWFycmF5aWZ5KHZhbHVlKTtpZihieXRlcy5sZW5ndGghPT13aWR0aCl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGxlbmd0aCBmb3IgJHt0eXBlfWAsXCJ2YWx1ZVwiLHZhbHVlKX1yZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpfX19c3dpdGNoKHR5cGUpe2Nhc2VcImFkZHJlc3NcIjpyZXR1cm4gZnVuY3Rpb24odmFsdWUpe3JldHVybiBoZXhaZXJvUGFkKGdldEFkZHJlc3ModmFsdWUpLDMyKX07Y2FzZVwiYm9vbFwiOnJldHVybiBmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIXZhbHVlP2hleEZhbHNlOmhleFRydWV9O2Nhc2VcImJ5dGVzXCI6cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4ga2VjY2FrMjU2KHZhbHVlKX07Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gaWQodmFsdWUpfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsZmllbGRzKXtyZXR1cm5gJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHtuYW1lOm5hbWUsdHlwZTp0eXBlfSk9PnR5cGUrXCIgXCIrbmFtZSkuam9pbihcIixcIil9KWB9Y2xhc3MgVHlwZWREYXRhRW5jb2Rlcntjb25zdHJ1Y3Rvcih0eXBlcyl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInR5cGVzXCIsT2JqZWN0LmZyZWV6ZShkZWVwQ29weSh0eXBlcykpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2VuY29kZXJDYWNoZVwiLHt9KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX3R5cGVzXCIse30pO2NvbnN0IGxpbmtzPXt9O2NvbnN0IHBhcmVudHM9e307Y29uc3Qgc3VidHlwZXM9e307T2JqZWN0LmtleXModHlwZXMpLmZvckVhY2godHlwZT0+e2xpbmtzW3R5cGVdPXt9O3BhcmVudHNbdHlwZV09W107c3VidHlwZXNbdHlwZV09e319KTtmb3IoY29uc3QgbmFtZSBpbiB0eXBlcyl7Y29uc3QgdW5pcXVlTmFtZXM9e307dHlwZXNbbmFtZV0uZm9yRWFjaChmaWVsZD0+e2lmKHVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lICR7SlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSl9IGluICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCxcInR5cGVzXCIsdHlwZXMpfXVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdPXRydWU7Y29uc3QgYmFzZVR5cGU9ZmllbGQudHlwZS5tYXRjaCgvXihbXlxceDViXSopKFxceDVifCQpLylbMV07aWYoYmFzZVR5cGU9PT1uYW1lKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsXCJ0eXBlc1wiLHR5cGVzKX1jb25zdCBlbmNvZGVyPWdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtpZihlbmNvZGVyKXtyZXR1cm59aWYoIXBhcmVudHNbYmFzZVR5cGVdKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLFwidHlwZXNcIix0eXBlcyl9cGFyZW50c1tiYXNlVHlwZV0ucHVzaChuYW1lKTtsaW5rc1tuYW1lXVtiYXNlVHlwZV09dHJ1ZX0pfWNvbnN0IHByaW1hcnlUeXBlcz1PYmplY3Qua2V5cyhwYXJlbnRzKS5maWx0ZXIobj0+cGFyZW50c1tuXS5sZW5ndGg9PT0wKTtpZihwcmltYXJ5VHlwZXMubGVuZ3RoPT09MCl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIixcInR5cGVzXCIsdHlwZXMpfWVsc2UgaWYocHJpbWFyeVR5cGVzLmxlbmd0aD4xKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYGFtYmlndW91cyBwcmltYXJ5IHR5cGVzIG9yIHVudXNlZCB0eXBlczogJHtwcmltYXJ5VHlwZXMubWFwKHQ9PkpTT04uc3RyaW5naWZ5KHQpKS5qb2luKFwiLCBcIil9YCxcInR5cGVzXCIsdHlwZXMpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcmltYXJ5VHlwZVwiLHByaW1hcnlUeXBlc1swXSk7ZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLGZvdW5kKXtpZihmb3VuZFt0eXBlXSl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KHR5cGUpfWAsXCJ0eXBlc1wiLHR5cGVzKX1mb3VuZFt0eXBlXT10cnVlO09iamVjdC5rZXlzKGxpbmtzW3R5cGVdKS5mb3JFYWNoKGNoaWxkPT57aWYoIXBhcmVudHNbY2hpbGRdKXtyZXR1cm59Y2hlY2tDaXJjdWxhcihjaGlsZCxmb3VuZCk7T2JqZWN0LmtleXMoZm91bmQpLmZvckVhY2goc3VidHlwZT0+e3N1YnR5cGVzW3N1YnR5cGVdW2NoaWxkXT10cnVlfSl9KTtkZWxldGUgZm91bmRbdHlwZV19Y2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLHt9KTtmb3IoY29uc3QgbmFtZSBpbiBzdWJ0eXBlcyl7Y29uc3Qgc3Q9T2JqZWN0LmtleXMoc3VidHlwZXNbbmFtZV0pO3N0LnNvcnQoKTt0aGlzLl90eXBlc1tuYW1lXT1lbmNvZGVUeXBlKG5hbWUsdHlwZXNbbmFtZV0pK3N0Lm1hcCh0PT5lbmNvZGVUeXBlKHQsdHlwZXNbdF0pKS5qb2luKFwiXCIpfX1nZXRFbmNvZGVyKHR5cGUpe2xldCBlbmNvZGVyPXRoaXMuX2VuY29kZXJDYWNoZVt0eXBlXTtpZighZW5jb2Rlcil7ZW5jb2Rlcj10aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV09dGhpcy5fZ2V0RW5jb2Rlcih0eXBlKX1yZXR1cm4gZW5jb2Rlcn1fZ2V0RW5jb2Rlcih0eXBlKXt7Y29uc3QgZW5jb2Rlcj1nZXRCYXNlRW5jb2Rlcih0eXBlKTtpZihlbmNvZGVyKXtyZXR1cm4gZW5jb2Rlcn19Y29uc3QgbWF0Y2g9dHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7aWYobWF0Y2gpe2NvbnN0IHN1YnR5cGU9bWF0Y2hbMV07Y29uc3Qgc3ViRW5jb2Rlcj10aGlzLmdldEVuY29kZXIoc3VidHlwZSk7Y29uc3QgbGVuZ3RoPXBhcnNlSW50KG1hdGNoWzNdKTtyZXR1cm4gdmFsdWU9PntpZihsZW5ndGg+PTAmJnZhbHVlLmxlbmd0aCE9PWxlbmd0aCl7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHsgYXJyYXlMZW5ndGggfVwiLFwidmFsdWVcIix2YWx1ZSl9bGV0IHJlc3VsdD12YWx1ZS5tYXAoc3ViRW5jb2Rlcik7aWYodGhpcy5fdHlwZXNbc3VidHlwZV0pe3Jlc3VsdD1yZXN1bHQubWFwKGtlY2NhazI1Nil9cmV0dXJuIGtlY2NhazI1NihoZXhDb25jYXQocmVzdWx0KSl9fWNvbnN0IGZpZWxkcz10aGlzLnR5cGVzW3R5cGVdO2lmKGZpZWxkcyl7Y29uc3QgZW5jb2RlZFR5cGU9aWQodGhpcy5fdHlwZXNbdHlwZV0pO3JldHVybiB2YWx1ZT0+e2NvbnN0IHZhbHVlcz1maWVsZHMubWFwKCh7bmFtZTpuYW1lLHR5cGU6dHlwZX0pPT57Y29uc3QgcmVzdWx0PXRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7aWYodGhpcy5fdHlwZXNbdHlwZV0pe3JldHVybiBrZWNjYWsyNTYocmVzdWx0KX1yZXR1cm4gcmVzdWx0fSk7dmFsdWVzLnVuc2hpZnQoZW5jb2RlZFR5cGUpO3JldHVybiBoZXhDb25jYXQodmFsdWVzKX19cmV0dXJuIGxvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke3R5cGV9YCxcInR5cGVcIix0eXBlKX1lbmNvZGVUeXBlKG5hbWUpe2NvbnN0IHJlc3VsdD10aGlzLl90eXBlc1tuYW1lXTtpZighcmVzdWx0KXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLFwibmFtZVwiLG5hbWUpfXJldHVybiByZXN1bHR9ZW5jb2RlRGF0YSh0eXBlLHZhbHVlKXtyZXR1cm4gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlKX1oYXNoU3RydWN0KG5hbWUsdmFsdWUpe3JldHVybiBrZWNjYWsyNTYodGhpcy5lbmNvZGVEYXRhKG5hbWUsdmFsdWUpKX1lbmNvZGUodmFsdWUpe3JldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSx2YWx1ZSl9aGFzaCh2YWx1ZSl7cmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLHZhbHVlKX1fdmlzaXQodHlwZSx2YWx1ZSxjYWxsYmFjayl7e2NvbnN0IGVuY29kZXI9Z2V0QmFzZUVuY29kZXIodHlwZSk7aWYoZW5jb2Rlcil7cmV0dXJuIGNhbGxiYWNrKHR5cGUsdmFsdWUpfX1jb25zdCBtYXRjaD10eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtpZihtYXRjaCl7Y29uc3Qgc3VidHlwZT1tYXRjaFsxXTtjb25zdCBsZW5ndGg9cGFyc2VJbnQobWF0Y2hbM10pO2lmKGxlbmd0aD49MCYmdmFsdWUubGVuZ3RoIT09bGVuZ3RoKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAkeyBhcnJheUxlbmd0aCB9XCIsXCJ2YWx1ZVwiLHZhbHVlKX1yZXR1cm4gdmFsdWUubWFwKHY9PnRoaXMuX3Zpc2l0KHN1YnR5cGUsdixjYWxsYmFjaykpfWNvbnN0IGZpZWxkcz10aGlzLnR5cGVzW3R5cGVdO2lmKGZpZWxkcyl7cmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLHtuYW1lOm5hbWUsdHlwZTp0eXBlfSk9PnthY2N1bVtuYW1lXT10aGlzLl92aXNpdCh0eXBlLHZhbHVlW25hbWVdLGNhbGxiYWNrKTtyZXR1cm4gYWNjdW19LHt9KX1yZXR1cm4gbG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLFwidHlwZVwiLHR5cGUpfXZpc2l0KHZhbHVlLGNhbGxiYWNrKXtyZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSx2YWx1ZSxjYWxsYmFjayl9c3RhdGljIGZyb20odHlwZXMpe3JldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyl9c3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKXtyZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZX1zdGF0aWMgaGFzaFN0cnVjdChuYW1lLHR5cGVzLHZhbHVlKXtyZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoU3RydWN0KG5hbWUsdmFsdWUpfXN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbil7Y29uc3QgZG9tYWluRmllbGRzPVtdO2Zvcihjb25zdCBuYW1lIGluIGRvbWFpbil7Y29uc3QgdHlwZT1kb21haW5GaWVsZFR5cGVzW25hbWVdO2lmKCF0eXBlKXtsb2dnZXIkYy50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgdHlwZWQtZGF0YSBkb21haW4ga2V5OiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsXCJkb21haW5cIixkb21haW4pfWRvbWFpbkZpZWxkcy5wdXNoKHtuYW1lOm5hbWUsdHlwZTp0eXBlfSl9ZG9tYWluRmllbGRzLnNvcnQoKGEsYik9PntyZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSktZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSl9KTtyZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIse0VJUDcxMkRvbWFpbjpkb21haW5GaWVsZHN9LGRvbWFpbil9c3RhdGljIGVuY29kZShkb21haW4sdHlwZXMsdmFsdWUpe3JldHVybiBoZXhDb25jYXQoW1wiMHgxOTAxXCIsVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKV0pfXN0YXRpYyBoYXNoKGRvbWFpbix0eXBlcyx2YWx1ZSl7cmV0dXJuIGtlY2NhazI1NihUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sdHlwZXMsdmFsdWUpKX1zdGF0aWMgcmVzb2x2ZU5hbWVzKGRvbWFpbix0eXBlcyx2YWx1ZSxyZXNvbHZlTmFtZSl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtkb21haW49c2hhbGxvd0NvcHkoZG9tYWluKTtjb25zdCBlbnNDYWNoZT17fTtpZihkb21haW4udmVyaWZ5aW5nQ29udHJhY3QmJiFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsMjApKXtlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdPVwiMHhcIn1jb25zdCBlbmNvZGVyPVR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7ZW5jb2Rlci52aXNpdCh2YWx1ZSwodHlwZSx2YWx1ZSk9PntpZih0eXBlPT09XCJhZGRyZXNzXCImJiFpc0hleFN0cmluZyh2YWx1ZSwyMCkpe2Vuc0NhY2hlW3ZhbHVlXT1cIjB4XCJ9cmV0dXJuIHZhbHVlfSk7Zm9yKGNvbnN0IG5hbWUgaW4gZW5zQ2FjaGUpe2Vuc0NhY2hlW25hbWVdPXlpZWxkIHJlc29sdmVOYW1lKG5hbWUpfWlmKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCYmZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSl7ZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0PWVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF19dmFsdWU9ZW5jb2Rlci52aXNpdCh2YWx1ZSwodHlwZSx2YWx1ZSk9PntpZih0eXBlPT09XCJhZGRyZXNzXCImJmVuc0NhY2hlW3ZhbHVlXSl7cmV0dXJuIGVuc0NhY2hlW3ZhbHVlXX1yZXR1cm4gdmFsdWV9KTtyZXR1cm57ZG9tYWluOmRvbWFpbix2YWx1ZTp2YWx1ZX19KX1zdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sdHlwZXMsdmFsdWUpe1R5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO2NvbnN0IGRvbWFpblZhbHVlcz17fTtjb25zdCBkb21haW5UeXBlcz1bXTtkb21haW5GaWVsZE5hbWVzLmZvckVhY2gobmFtZT0+e2NvbnN0IHZhbHVlPWRvbWFpbltuYW1lXTtpZih2YWx1ZT09bnVsbCl7cmV0dXJufWRvbWFpblZhbHVlc1tuYW1lXT1kb21haW5DaGVja3NbbmFtZV0odmFsdWUpO2RvbWFpblR5cGVzLnB1c2goe25hbWU6bmFtZSx0eXBlOmRvbWFpbkZpZWxkVHlwZXNbbmFtZV19KX0pO2NvbnN0IGVuY29kZXI9VHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtjb25zdCB0eXBlc1dpdGhEb21haW49c2hhbGxvd0NvcHkodHlwZXMpO2lmKHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4pe2xvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIixcInR5cGVzLkVJUDcxMkRvbWFpblwiLHR5cGVzKX1lbHNle3R5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW49ZG9tYWluVHlwZXN9ZW5jb2Rlci5lbmNvZGUodmFsdWUpO3JldHVybnt0eXBlczp0eXBlc1dpdGhEb21haW4sZG9tYWluOmRvbWFpblZhbHVlcyxwcmltYXJ5VHlwZTplbmNvZGVyLnByaW1hcnlUeXBlLG1lc3NhZ2U6ZW5jb2Rlci52aXNpdCh2YWx1ZSwodHlwZSx2YWx1ZSk9PntpZih0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSl7cmV0dXJuIGhleGxpZnkoYXJyYXlpZnkodmFsdWUpKX1pZih0eXBlLm1hdGNoKC9edT9pbnQvKSl7cmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpfXN3aXRjaCh0eXBlKXtjYXNlXCJhZGRyZXNzXCI6cmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7Y2FzZVwiYm9vbFwiOnJldHVybiEhdmFsdWU7Y2FzZVwic3RyaW5nXCI6aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcIil7bG9nZ2VyJGMudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIHN0cmluZ2AsXCJ2YWx1ZVwiLHZhbHVlKX1yZXR1cm4gdmFsdWV9cmV0dXJuIGxvZ2dlciRjLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIHR5cGVcIixcInR5cGVcIix0eXBlKX0pfX19XCJ1c2Ugc3RyaWN0XCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJGQ9bmV3IExvZ2dlcih2ZXJzaW9uJDQpO2NsYXNzIExvZ0Rlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb257fWNsYXNzIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24gZXh0ZW5kcyBEZXNjcmlwdGlvbnt9Y2xhc3MgSW5kZXhlZCBleHRlbmRzIERlc2NyaXB0aW9ue3N0YXRpYyBpc0luZGV4ZWQodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNJbmRleGVkKX19ZnVuY3Rpb24gd3JhcEFjY2Vzc0Vycm9yKHByb3BlcnR5LGVycm9yKXtjb25zdCB3cmFwPW5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7cHJvcGVydHl9YCk7d3JhcC5lcnJvcj1lcnJvcjtyZXR1cm4gd3JhcH1jbGFzcyBJbnRlcmZhY2V7Y29uc3RydWN0b3IoZnJhZ21lbnRzKXtsb2dnZXIkZC5jaGVja05ldyhuZXcudGFyZ2V0LEludGVyZmFjZSk7bGV0IGFiaT1bXTtpZih0eXBlb2YgZnJhZ21lbnRzPT09XCJzdHJpbmdcIil7YWJpPUpTT04ucGFyc2UoZnJhZ21lbnRzKX1lbHNle2FiaT1mcmFnbWVudHN9ZGVmaW5lUmVhZE9ubHkodGhpcyxcImZyYWdtZW50c1wiLGFiaS5tYXAoZnJhZ21lbnQ9PntyZXR1cm4gRnJhZ21lbnQuZnJvbShmcmFnbWVudCl9KS5maWx0ZXIoZnJhZ21lbnQ9PmZyYWdtZW50IT1udWxsKSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9hYmlDb2RlclwiLGdldFN0YXRpYyhuZXcudGFyZ2V0LFwiZ2V0QWJpQ29kZXJcIikoKSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImZ1bmN0aW9uc1wiLHt9KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiZXJyb3JzXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJldmVudHNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInN0cnVjdHNcIix7fSk7dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudD0+e2xldCBidWNrZXQ9bnVsbDtzd2l0Y2goZnJhZ21lbnQudHlwZSl7Y2FzZVwiY29uc3RydWN0b3JcIjppZih0aGlzLmRlcGxveSl7bG9nZ2VyJGQud2FybihcImR1cGxpY2F0ZSBkZWZpbml0aW9uIC0gY29uc3RydWN0b3JcIik7cmV0dXJufWRlZmluZVJlYWRPbmx5KHRoaXMsXCJkZXBsb3lcIixmcmFnbWVudCk7cmV0dXJuO2Nhc2VcImZ1bmN0aW9uXCI6YnVja2V0PXRoaXMuZnVuY3Rpb25zO2JyZWFrO2Nhc2VcImV2ZW50XCI6YnVja2V0PXRoaXMuZXZlbnRzO2JyZWFrO2RlZmF1bHQ6cmV0dXJufWxldCBzaWduYXR1cmU9ZnJhZ21lbnQuZm9ybWF0KCk7aWYoYnVja2V0W3NpZ25hdHVyZV0pe2xvZ2dlciRkLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIFwiK3NpZ25hdHVyZSk7cmV0dXJufWJ1Y2tldFtzaWduYXR1cmVdPWZyYWdtZW50fSk7aWYoIXRoaXMuZGVwbG95KXtkZWZpbmVSZWFkT25seSh0aGlzLFwiZGVwbG95XCIsQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKHtwYXlhYmxlOmZhbHNlLHR5cGU6XCJjb25zdHJ1Y3RvclwifSkpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJfaXNJbnRlcmZhY2VcIix0cnVlKX1mb3JtYXQoZm9ybWF0KXtpZighZm9ybWF0KXtmb3JtYXQ9Rm9ybWF0VHlwZXMuZnVsbH1pZihmb3JtYXQ9PT1Gb3JtYXRUeXBlcy5zaWdoYXNoKXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnRlcmZhY2UgZG9lcyBub3Qgc3VwcG9ydCBmb3JtYXR0aW5nIHNpZ2hhc2hcIixcImZvcm1hdFwiLGZvcm1hdCl9Y29uc3QgYWJpPXRoaXMuZnJhZ21lbnRzLm1hcChmcmFnbWVudD0+ZnJhZ21lbnQuZm9ybWF0KGZvcm1hdCkpO2lmKGZvcm1hdD09PUZvcm1hdFR5cGVzLmpzb24pe3JldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKGo9PkpTT04ucGFyc2UoaikpKX1yZXR1cm4gYWJpfXN0YXRpYyBnZXRBYmlDb2Rlcigpe3JldHVybiBkZWZhdWx0QWJpQ29kZXJ9c3RhdGljIGdldEFkZHJlc3MoYWRkcmVzcyl7cmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyl9c3RhdGljIGdldFNpZ2hhc2goZnVuY3Rpb25GcmFnbWVudCl7cmV0dXJuIGhleERhdGFTbGljZShpZChmdW5jdGlvbkZyYWdtZW50LmZvcm1hdCgpKSwwLDQpfXN0YXRpYyBnZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpe3JldHVybiBpZChldmVudEZyYWdtZW50LmZvcm1hdCgpKX1nZXRGdW5jdGlvbihuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpe2lmKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkpe2Zvcihjb25zdCBuYW1lIGluIHRoaXMuZnVuY3Rpb25zKXtpZihuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2g9PT10aGlzLmdldFNpZ2hhc2gobmFtZSkpe3JldHVybiB0aGlzLmZ1bmN0aW9uc1tuYW1lXX19bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIixcInNpZ2hhc2hcIixuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpfWlmKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC5pbmRleE9mKFwiKFwiKT09PS0xKXtjb25zdCBuYW1lPW5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7Y29uc3QgbWF0Y2hpbmc9T2JqZWN0LmtleXModGhpcy5mdW5jdGlvbnMpLmZpbHRlcihmPT5mLnNwbGl0KFwiKFwiKVswXT09PW5hbWUpO2lmKG1hdGNoaW5nLmxlbmd0aD09PTApe2xvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsXCJuYW1lXCIsbmFtZSl9ZWxzZSBpZihtYXRjaGluZy5sZW5ndGg+MSl7bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZnVuY3Rpb25zXCIsXCJuYW1lXCIsbmFtZSl9cmV0dXJuIHRoaXMuZnVuY3Rpb25zW21hdGNoaW5nWzBdXX1jb25zdCByZXN1bHQ9dGhpcy5mdW5jdGlvbnNbRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkuZm9ybWF0KCldO2lmKCFyZXN1bHQpe2xvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsXCJzaWduYXR1cmVcIixuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpfXJldHVybiByZXN1bHR9Z2V0RXZlbnQobmFtZU9yU2lnbmF0dXJlT3JUb3BpYyl7aWYoaXNIZXhTdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykpe2NvbnN0IHRvcGljaGFzaD1uYW1lT3JTaWduYXR1cmVPclRvcGljLnRvTG93ZXJDYXNlKCk7Zm9yKGNvbnN0IG5hbWUgaW4gdGhpcy5ldmVudHMpe2lmKHRvcGljaGFzaD09PXRoaXMuZ2V0RXZlbnRUb3BpYyhuYW1lKSl7cmV0dXJuIHRoaXMuZXZlbnRzW25hbWVdfX1sb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLFwidG9waWNoYXNoXCIsdG9waWNoYXNoKX1pZihuYW1lT3JTaWduYXR1cmVPclRvcGljLmluZGV4T2YoXCIoXCIpPT09LTEpe2NvbnN0IG5hbWU9bmFtZU9yU2lnbmF0dXJlT3JUb3BpYy50cmltKCk7Y29uc3QgbWF0Y2hpbmc9T2JqZWN0LmtleXModGhpcy5ldmVudHMpLmZpbHRlcihmPT5mLnNwbGl0KFwiKFwiKVswXT09PW5hbWUpO2lmKG1hdGNoaW5nLmxlbmd0aD09PTApe2xvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsXCJuYW1lXCIsbmFtZSl9ZWxzZSBpZihtYXRjaGluZy5sZW5ndGg+MSl7bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZXZlbnRzXCIsXCJuYW1lXCIsbmFtZSl9cmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXX1jb25zdCByZXN1bHQ9dGhpcy5ldmVudHNbRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpLmZvcm1hdCgpXTtpZighcmVzdWx0KXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLFwic2lnbmF0dXJlXCIsbmFtZU9yU2lnbmF0dXJlT3JUb3BpYyl9cmV0dXJuIHJlc3VsdH1nZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpe2lmKHR5cGVvZiBmdW5jdGlvbkZyYWdtZW50PT09XCJzdHJpbmdcIil7ZnVuY3Rpb25GcmFnbWVudD10aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpfXJldHVybiBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvcixcImdldFNpZ2hhc2hcIikoZnVuY3Rpb25GcmFnbWVudCl9Z2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KXtpZih0eXBlb2YgZXZlbnRGcmFnbWVudD09PVwic3RyaW5nXCIpe2V2ZW50RnJhZ21lbnQ9dGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KX1yZXR1cm4gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsXCJnZXRFdmVudFRvcGljXCIpKGV2ZW50RnJhZ21lbnQpfV9kZWNvZGVQYXJhbXMocGFyYW1zLGRhdGEpe3JldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUocGFyYW1zLGRhdGEpfV9lbmNvZGVQYXJhbXMocGFyYW1zLHZhbHVlcyl7cmV0dXJuIHRoaXMuX2FiaUNvZGVyLmVuY29kZShwYXJhbXMsdmFsdWVzKX1lbmNvZGVEZXBsb3kodmFsdWVzKXtyZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cyx2YWx1ZXN8fFtdKX1kZWNvZGVGdW5jdGlvbkRhdGEoZnVuY3Rpb25GcmFnbWVudCxkYXRhKXtpZih0eXBlb2YgZnVuY3Rpb25GcmFnbWVudD09PVwic3RyaW5nXCIpe2Z1bmN0aW9uRnJhZ21lbnQ9dGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KX1jb25zdCBieXRlcz1hcnJheWlmeShkYXRhKTtpZihoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsNCkpIT09dGhpcy5nZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpKXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uICR7ZnVuY3Rpb25GcmFnbWVudC5uYW1lfS5gLFwiZGF0YVwiLGhleGxpZnkoYnl0ZXMpKX1yZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZ1bmN0aW9uRnJhZ21lbnQuaW5wdXRzLGJ5dGVzLnNsaWNlKDQpKX1lbmNvZGVGdW5jdGlvbkRhdGEoZnVuY3Rpb25GcmFnbWVudCx2YWx1ZXMpe2lmKHR5cGVvZiBmdW5jdGlvbkZyYWdtZW50PT09XCJzdHJpbmdcIil7ZnVuY3Rpb25GcmFnbWVudD10aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpfXJldHVybiBoZXhsaWZ5KGNvbmNhdChbdGhpcy5nZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpLHRoaXMuX2VuY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cyx2YWx1ZXN8fFtdKV0pKX1kZWNvZGVGdW5jdGlvblJlc3VsdChmdW5jdGlvbkZyYWdtZW50LGRhdGEpe2lmKHR5cGVvZiBmdW5jdGlvbkZyYWdtZW50PT09XCJzdHJpbmdcIil7ZnVuY3Rpb25GcmFnbWVudD10aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpfWxldCBieXRlcz1hcnJheWlmeShkYXRhKTtsZXQgcmVhc29uPW51bGw7bGV0IGVycm9yU2lnbmF0dXJlPW51bGw7c3dpdGNoKGJ5dGVzLmxlbmd0aCV0aGlzLl9hYmlDb2Rlci5fZ2V0V29yZFNpemUoKSl7Y2FzZSAwOnRyeXtyZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cyxieXRlcyl9Y2F0Y2goZXJyb3Ipe31icmVhaztjYXNlIDQ6aWYoaGV4bGlmeShieXRlcy5zbGljZSgwLDQpKT09PVwiMHgwOGMzNzlhMFwiKXtlcnJvclNpZ25hdHVyZT1cIkVycm9yKHN0cmluZylcIjtyZWFzb249dGhpcy5fYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSxieXRlcy5zbGljZSg0KSlbMF19YnJlYWt9cmV0dXJuIGxvZ2dlciRkLnRocm93RXJyb3IoXCJjYWxsIHJldmVydCBleGNlcHRpb25cIixMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLHttZXRob2Q6ZnVuY3Rpb25GcmFnbWVudC5mb3JtYXQoKSxlcnJvclNpZ25hdHVyZTplcnJvclNpZ25hdHVyZSxlcnJvckFyZ3M6W3JlYXNvbl0scmVhc29uOnJlYXNvbn0pfWVuY29kZUZ1bmN0aW9uUmVzdWx0KGZ1bmN0aW9uRnJhZ21lbnQsdmFsdWVzKXtpZih0eXBlb2YgZnVuY3Rpb25GcmFnbWVudD09PVwic3RyaW5nXCIpe2Z1bmN0aW9uRnJhZ21lbnQ9dGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KX1yZXR1cm4gaGV4bGlmeSh0aGlzLl9hYmlDb2Rlci5lbmNvZGUoZnVuY3Rpb25GcmFnbWVudC5vdXRwdXRzLHZhbHVlc3x8W10pKX1lbmNvZGVGaWx0ZXJUb3BpY3MoZXZlbnRGcmFnbWVudCx2YWx1ZXMpe2lmKHR5cGVvZiBldmVudEZyYWdtZW50PT09XCJzdHJpbmdcIil7ZXZlbnRGcmFnbWVudD10aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpfWlmKHZhbHVlcy5sZW5ndGg+ZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKXtsb2dnZXIkZC50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzIGZvciBcIitldmVudEZyYWdtZW50LmZvcm1hdCgpLExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJ2YWx1ZXNcIix2YWx1ZTp2YWx1ZXN9KX1sZXQgdG9waWNzPVtdO2lmKCFldmVudEZyYWdtZW50LmFub255bW91cyl7dG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKX1jb25zdCBlbmNvZGVUb3BpYz0ocGFyYW0sdmFsdWUpPT57aWYocGFyYW0udHlwZT09PVwic3RyaW5nXCIpe3JldHVybiBpZCh2YWx1ZSl9ZWxzZSBpZihwYXJhbS50eXBlPT09XCJieXRlc1wiKXtyZXR1cm4ga2VjY2FrMjU2KGhleGxpZnkodmFsdWUpKX1pZihwYXJhbS50eXBlPT09XCJhZGRyZXNzXCIpe3RoaXMuX2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLFt2YWx1ZV0pfXJldHVybiBoZXhaZXJvUGFkKGhleGxpZnkodmFsdWUpLDMyKX07dmFsdWVzLmZvckVhY2goKHZhbHVlLGluZGV4KT0+e2xldCBwYXJhbT1ldmVudEZyYWdtZW50LmlucHV0c1tpbmRleF07aWYoIXBhcmFtLmluZGV4ZWQpe2lmKHZhbHVlIT1udWxsKXtsb2dnZXIkZC50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLFwiY29udHJhY3QuXCIrcGFyYW0ubmFtZSx2YWx1ZSl9cmV0dXJufWlmKHZhbHVlPT1udWxsKXt0b3BpY3MucHVzaChudWxsKX1lbHNlIGlmKHBhcmFtLmJhc2VUeXBlPT09XCJhcnJheVwifHxwYXJhbS5iYXNlVHlwZT09PVwidHVwbGVcIil7bG9nZ2VyJGQudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsXCJjb250cmFjdC5cIitwYXJhbS5uYW1lLHZhbHVlKX1lbHNlIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKXt0b3BpY3MucHVzaCh2YWx1ZS5tYXAodmFsdWU9PmVuY29kZVRvcGljKHBhcmFtLHZhbHVlKSkpfWVsc2V7dG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sdmFsdWUpKX19KTt3aGlsZSh0b3BpY3MubGVuZ3RoJiZ0b3BpY3NbdG9waWNzLmxlbmd0aC0xXT09PW51bGwpe3RvcGljcy5wb3AoKX1yZXR1cm4gdG9waWNzfWVuY29kZUV2ZW50TG9nKGV2ZW50RnJhZ21lbnQsdmFsdWVzKXtpZih0eXBlb2YgZXZlbnRGcmFnbWVudD09PVwic3RyaW5nXCIpe2V2ZW50RnJhZ21lbnQ9dGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KX1jb25zdCB0b3BpY3M9W107Y29uc3QgZGF0YVR5cGVzPVtdO2NvbnN0IGRhdGFWYWx1ZXM9W107aWYoIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKXt0b3BpY3MucHVzaCh0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkpfWlmKHZhbHVlcy5sZW5ndGghPT1ldmVudEZyYWdtZW50LmlucHV0cy5sZW5ndGgpe2xvZ2dlciRkLnRocm93QXJndW1lbnRFcnJvcihcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIixcInZhbHVlc1wiLHZhbHVlcyl9ZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0saW5kZXgpPT57Y29uc3QgdmFsdWU9dmFsdWVzW2luZGV4XTtpZihwYXJhbS5pbmRleGVkKXtpZihwYXJhbS50eXBlPT09XCJzdHJpbmdcIil7dG9waWNzLnB1c2goaWQodmFsdWUpKX1lbHNlIGlmKHBhcmFtLnR5cGU9PT1cImJ5dGVzXCIpe3RvcGljcy5wdXNoKGtlY2NhazI1Nih2YWx1ZSkpfWVsc2UgaWYocGFyYW0uYmFzZVR5cGU9PT1cInR1cGxlXCJ8fHBhcmFtLmJhc2VUeXBlPT09XCJhcnJheVwiKXt0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIil9ZWxzZXt0b3BpY3MucHVzaCh0aGlzLl9hYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLFt2YWx1ZV0pKX19ZWxzZXtkYXRhVHlwZXMucHVzaChwYXJhbSk7ZGF0YVZhbHVlcy5wdXNoKHZhbHVlKX19KTtyZXR1cm57ZGF0YTp0aGlzLl9hYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLGRhdGFWYWx1ZXMpLHRvcGljczp0b3BpY3N9fWRlY29kZUV2ZW50TG9nKGV2ZW50RnJhZ21lbnQsZGF0YSx0b3BpY3Mpe2lmKHR5cGVvZiBldmVudEZyYWdtZW50PT09XCJzdHJpbmdcIil7ZXZlbnRGcmFnbWVudD10aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpfWlmKHRvcGljcyE9bnVsbCYmIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKXtsZXQgdG9waWNIYXNoPXRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KTtpZighaXNIZXhTdHJpbmcodG9waWNzWzBdLDMyKXx8dG9waWNzWzBdLnRvTG93ZXJDYXNlKCkhPT10b3BpY0hhc2gpe2xvZ2dlciRkLnRocm93RXJyb3IoXCJmcmFnbWVudC90b3BpYyBtaXNtYXRjaFwiLExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJ0b3BpY3NbMF1cIixleHBlY3RlZDp0b3BpY0hhc2gsdmFsdWU6dG9waWNzWzBdfSl9dG9waWNzPXRvcGljcy5zbGljZSgxKX1sZXQgaW5kZXhlZD1bXTtsZXQgbm9uSW5kZXhlZD1bXTtsZXQgZHluYW1pYz1bXTtldmVudEZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSxpbmRleCk9PntpZihwYXJhbS5pbmRleGVkKXtpZihwYXJhbS50eXBlPT09XCJzdHJpbmdcInx8cGFyYW0udHlwZT09PVwiYnl0ZXNcInx8cGFyYW0uYmFzZVR5cGU9PT1cInR1cGxlXCJ8fHBhcmFtLmJhc2VUeXBlPT09XCJhcnJheVwiKXtpbmRleGVkLnB1c2goUGFyYW1UeXBlLmZyb21PYmplY3Qoe3R5cGU6XCJieXRlczMyXCIsbmFtZTpwYXJhbS5uYW1lfSkpO2R5bmFtaWMucHVzaCh0cnVlKX1lbHNle2luZGV4ZWQucHVzaChwYXJhbSk7ZHluYW1pYy5wdXNoKGZhbHNlKX19ZWxzZXtub25JbmRleGVkLnB1c2gocGFyYW0pO2R5bmFtaWMucHVzaChmYWxzZSl9fSk7bGV0IHJlc3VsdEluZGV4ZWQ9dG9waWNzIT1udWxsP3RoaXMuX2FiaUNvZGVyLmRlY29kZShpbmRleGVkLGNvbmNhdCh0b3BpY3MpKTpudWxsO2xldCByZXN1bHROb25JbmRleGVkPXRoaXMuX2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLGRhdGEsdHJ1ZSk7bGV0IHJlc3VsdD1bXTtsZXQgbm9uSW5kZXhlZEluZGV4PTAsaW5kZXhlZEluZGV4PTA7ZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0saW5kZXgpPT57aWYocGFyYW0uaW5kZXhlZCl7aWYocmVzdWx0SW5kZXhlZD09bnVsbCl7cmVzdWx0W2luZGV4XT1uZXcgSW5kZXhlZCh7X2lzSW5kZXhlZDp0cnVlLGhhc2g6bnVsbH0pfWVsc2UgaWYoZHluYW1pY1tpbmRleF0pe3Jlc3VsdFtpbmRleF09bmV3IEluZGV4ZWQoe19pc0luZGV4ZWQ6dHJ1ZSxoYXNoOnJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdfSl9ZWxzZXt0cnl7cmVzdWx0W2luZGV4XT1yZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXX1jYXRjaChlcnJvcil7cmVzdWx0W2luZGV4XT1lcnJvcn19fWVsc2V7dHJ5e3Jlc3VsdFtpbmRleF09cmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK119Y2F0Y2goZXJyb3Ipe3Jlc3VsdFtpbmRleF09ZXJyb3J9fWlmKHBhcmFtLm5hbWUmJnJlc3VsdFtwYXJhbS5uYW1lXT09bnVsbCl7Y29uc3QgdmFsdWU9cmVzdWx0W2luZGV4XTtpZih2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKXtPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LHBhcmFtLm5hbWUse2dldDooKT0+e3Rocm93IHdyYXBBY2Nlc3NFcnJvcihgcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShwYXJhbS5uYW1lKX1gLHZhbHVlKX19KX1lbHNle3Jlc3VsdFtwYXJhbS5uYW1lXT12YWx1ZX19fSk7Zm9yKGxldCBpPTA7aTxyZXN1bHQubGVuZ3RoO2krKyl7Y29uc3QgdmFsdWU9cmVzdWx0W2ldO2lmKHZhbHVlIGluc3RhbmNlb2YgRXJyb3Ipe09iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsaSx7Z2V0OigpPT57dGhyb3cgd3JhcEFjY2Vzc0Vycm9yKGBpbmRleCAke2l9YCx2YWx1ZSl9fSl9fXJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCl9cGFyc2VUcmFuc2FjdGlvbih0eCl7bGV0IGZyYWdtZW50PXRoaXMuZ2V0RnVuY3Rpb24odHguZGF0YS5zdWJzdHJpbmcoMCwxMCkudG9Mb3dlckNhc2UoKSk7aWYoIWZyYWdtZW50KXtyZXR1cm4gbnVsbH1yZXR1cm4gbmV3IFRyYW5zYWN0aW9uRGVzY3JpcHRpb24oe2FyZ3M6dGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cyxcIjB4XCIrdHguZGF0YS5zdWJzdHJpbmcoMTApKSxmdW5jdGlvbkZyYWdtZW50OmZyYWdtZW50LG5hbWU6ZnJhZ21lbnQubmFtZSxzaWduYXR1cmU6ZnJhZ21lbnQuZm9ybWF0KCksc2lnaGFzaDp0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLHZhbHVlOkJpZ051bWJlci5mcm9tKHR4LnZhbHVlfHxcIjBcIil9KX1wYXJzZUxvZyhsb2cpe2xldCBmcmFnbWVudD10aGlzLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO2lmKCFmcmFnbWVudHx8ZnJhZ21lbnQuYW5vbnltb3VzKXtyZXR1cm4gbnVsbH1yZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKHtldmVudEZyYWdtZW50OmZyYWdtZW50LG5hbWU6ZnJhZ21lbnQubmFtZSxzaWduYXR1cmU6ZnJhZ21lbnQuZm9ybWF0KCksdG9waWM6dGhpcy5nZXRFdmVudFRvcGljKGZyYWdtZW50KSxhcmdzOnRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsbG9nLmRhdGEsbG9nLnRvcGljcyl9KX1zdGF0aWMgaXNJbnRlcmZhY2UodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNJbnRlcmZhY2UpfX1cInVzZSBzdHJpY3RcIjtjb25zdCB2ZXJzaW9uJDk9XCJhYnN0cmFjdC1wcm92aWRlci81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRlPW5ldyBMb2dnZXIodmVyc2lvbiQ5KTtjbGFzcyBGb3JrRXZlbnQgZXh0ZW5kcyBEZXNjcmlwdGlvbntzdGF0aWMgaXNGb3JrRXZlbnQodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNGb3JrRXZlbnQpfX1jbGFzcyBCbG9ja0ZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudHtjb25zdHJ1Y3RvcihibG9ja0hhc2gsZXhwaXJ5KXtpZighaXNIZXhTdHJpbmcoYmxvY2tIYXNoLDMyKSl7bG9nZ2VyJGUudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIixcImJsb2NrSGFzaFwiLGJsb2NrSGFzaCl9c3VwZXIoe19pc0ZvcmtFdmVudDp0cnVlLF9pc0Jsb2NrRm9ya0V2ZW50OnRydWUsZXhwaXJ5OmV4cGlyeXx8MCxibG9ja0hhc2g6YmxvY2tIYXNofSl9fWNsYXNzIFRyYW5zYWN0aW9uRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50e2NvbnN0cnVjdG9yKGhhc2gsZXhwaXJ5KXtpZighaXNIZXhTdHJpbmcoaGFzaCwzMikpe2xvZ2dlciRlLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24gaGFzaFwiLFwiaGFzaFwiLGhhc2gpfXN1cGVyKHtfaXNGb3JrRXZlbnQ6dHJ1ZSxfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDp0cnVlLGV4cGlyeTpleHBpcnl8fDAsaGFzaDpoYXNofSl9fWNsYXNzIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnR7Y29uc3RydWN0b3IoYmVmb3JlSGFzaCxhZnRlckhhc2gsZXhwaXJ5KXtpZighaXNIZXhTdHJpbmcoYmVmb3JlSGFzaCwzMikpe2xvZ2dlciRlLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24gaGFzaFwiLFwiYmVmb3JlSGFzaFwiLGJlZm9yZUhhc2gpfWlmKCFpc0hleFN0cmluZyhhZnRlckhhc2gsMzIpKXtsb2dnZXIkZS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIixcImFmdGVySGFzaFwiLGFmdGVySGFzaCl9c3VwZXIoe19pc0ZvcmtFdmVudDp0cnVlLF9pc1RyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ6dHJ1ZSxleHBpcnk6ZXhwaXJ5fHwwLGJlZm9yZUhhc2g6YmVmb3JlSGFzaCxhZnRlckhhc2g6YWZ0ZXJIYXNofSl9fWNsYXNzIFByb3ZpZGVye2NvbnN0cnVjdG9yKCl7bG9nZ2VyJGUuY2hlY2tBYnN0cmFjdChuZXcudGFyZ2V0LFByb3ZpZGVyKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2lzUHJvdmlkZXJcIix0cnVlKX1hZGRMaXN0ZW5lcihldmVudE5hbWUsbGlzdGVuZXIpe3JldHVybiB0aGlzLm9uKGV2ZW50TmFtZSxsaXN0ZW5lcil9cmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLGxpc3RlbmVyKXtyZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLGxpc3RlbmVyKX1zdGF0aWMgaXNQcm92aWRlcih2YWx1ZSl7cmV0dXJuISEodmFsdWUmJnZhbHVlLl9pc1Byb3ZpZGVyKX19Y29uc3QgdmVyc2lvbiRhPVwiYWJzdHJhY3Qtc2lnbmVyLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciQyPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkZj1uZXcgTG9nZ2VyKHZlcnNpb24kYSk7Y29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cz1bXCJhY2Nlc3NMaXN0XCIsXCJjaGFpbklkXCIsXCJkYXRhXCIsXCJmcm9tXCIsXCJnYXNMaW1pdFwiLFwiZ2FzUHJpY2VcIixcIm5vbmNlXCIsXCJ0b1wiLFwidHlwZVwiLFwidmFsdWVcIl07Y29uc3QgZm9yd2FyZEVycm9ycz1bTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRURdO2NsYXNzIFNpZ25lcntjb25zdHJ1Y3Rvcigpe2xvZ2dlciRmLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCxTaWduZXIpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfaXNTaWduZXJcIix0cnVlKX1nZXRCYWxhbmNlKGJsb2NrVGFnKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3RoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO3JldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodGhpcy5nZXRBZGRyZXNzKCksYmxvY2tUYWcpfSl9Z2V0VHJhbnNhY3Rpb25Db3VudChibG9ja1RhZyl7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZ2V0QWRkcmVzcygpLGJsb2NrVGFnKX0pfWVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3RoaXMuX2NoZWNrUHJvdmlkZXIoXCJlc3RpbWF0ZUdhc1wiKTtjb25zdCB0eD15aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh0eCl9KX1jYWxsKHRyYW5zYWN0aW9uLGJsb2NrVGFnKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3RoaXMuX2NoZWNrUHJvdmlkZXIoXCJjYWxsXCIpO2NvbnN0IHR4PXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO3JldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgsYmxvY2tUYWcpfSl9c2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKXt0aGlzLl9jaGVja1Byb3ZpZGVyKFwic2VuZFRyYW5zYWN0aW9uXCIpO3JldHVybiB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4odHg9PntyZXR1cm4gdGhpcy5zaWduVHJhbnNhY3Rpb24odHgpLnRoZW4oc2lnbmVkVHg9PntyZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHgpfSl9KX1nZXRDaGFpbklkKCl7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0Q2hhaW5JZFwiKTtjb25zdCBuZXR3b3JrPXlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0TmV0d29yaygpO3JldHVybiBuZXR3b3JrLmNoYWluSWR9KX1nZXRHYXNQcmljZSgpe3JldHVybiBfX2F3YWl0ZXIkMih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7dGhpcy5fY2hlY2tQcm92aWRlcihcImdldEdhc1ByaWNlXCIpO3JldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldEdhc1ByaWNlKCl9KX1yZXNvbHZlTmFtZShuYW1lKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3RoaXMuX2NoZWNrUHJvdmlkZXIoXCJyZXNvbHZlTmFtZVwiKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKX0pfWNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pe2Zvcihjb25zdCBrZXkgaW4gdHJhbnNhY3Rpb24pe2lmKGFsbG93ZWRUcmFuc2FjdGlvbktleXMuaW5kZXhPZihrZXkpPT09LTEpe2xvZ2dlciRmLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24ga2V5OiBcIitrZXksXCJ0cmFuc2FjdGlvblwiLHRyYW5zYWN0aW9uKX19Y29uc3QgdHg9c2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO2lmKHR4LmZyb209PW51bGwpe3R4LmZyb209dGhpcy5nZXRBZGRyZXNzKCl9ZWxzZXt0eC5mcm9tPVByb21pc2UuYWxsKFtQcm9taXNlLnJlc29sdmUodHguZnJvbSksdGhpcy5nZXRBZGRyZXNzKCldKS50aGVuKHJlc3VsdD0+e2lmKHJlc3VsdFswXS50b0xvd2VyQ2FzZSgpIT09cmVzdWx0WzFdLnRvTG93ZXJDYXNlKCkpe2xvZ2dlciRmLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLFwidHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvbil9cmV0dXJuIHJlc3VsdFswXX0pfXJldHVybiB0eH1wb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHR4PXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO2lmKHR4LnRvIT1udWxsKXt0eC50bz1Qcm9taXNlLnJlc29sdmUodHgudG8pLnRoZW4odG89Pl9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZih0bz09bnVsbCl7cmV0dXJuIG51bGx9Y29uc3QgYWRkcmVzcz15aWVsZCB0aGlzLnJlc29sdmVOYW1lKHRvKTtpZihhZGRyZXNzPT1udWxsKXtsb2dnZXIkZi50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsXCJ0eC50b1wiLHRvKX1yZXR1cm4gYWRkcmVzc30pKX1pZih0eC5nYXNQcmljZT09bnVsbCl7dHguZ2FzUHJpY2U9dGhpcy5nZXRHYXNQcmljZSgpfWlmKHR4Lm5vbmNlPT1udWxsKXt0eC5ub25jZT10aGlzLmdldFRyYW5zYWN0aW9uQ291bnQoXCJwZW5kaW5nXCIpfWlmKHR4Lmdhc0xpbWl0PT1udWxsKXt0eC5nYXNMaW1pdD10aGlzLmVzdGltYXRlR2FzKHR4KS5jYXRjaChlcnJvcj0+e2lmKGZvcndhcmRFcnJvcnMuaW5kZXhPZihlcnJvci5jb2RlKT49MCl7dGhyb3cgZXJyb3J9cmV0dXJuIGxvZ2dlciRmLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCx7ZXJyb3I6ZXJyb3IsdHg6dHh9KX0pfWlmKHR4LmNoYWluSWQ9PW51bGwpe3R4LmNoYWluSWQ9dGhpcy5nZXRDaGFpbklkKCl9ZWxzZXt0eC5jaGFpbklkPVByb21pc2UuYWxsKFtQcm9taXNlLnJlc29sdmUodHguY2hhaW5JZCksdGhpcy5nZXRDaGFpbklkKCldKS50aGVuKHJlc3VsdHM9PntpZihyZXN1bHRzWzFdIT09MCYmcmVzdWx0c1swXSE9PXJlc3VsdHNbMV0pe2xvZ2dlciRmLnRocm93QXJndW1lbnRFcnJvcihcImNoYWluSWQgYWRkcmVzcyBtaXNtYXRjaFwiLFwidHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvbil9cmV0dXJuIHJlc3VsdHNbMF19KX1yZXR1cm4geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpfSl9X2NoZWNrUHJvdmlkZXIob3BlcmF0aW9uKXtpZighdGhpcy5wcm92aWRlcil7bG9nZ2VyJGYudGhyb3dFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOm9wZXJhdGlvbnx8XCJfY2hlY2tQcm92aWRlclwifSl9fXN0YXRpYyBpc1NpZ25lcih2YWx1ZSl7cmV0dXJuISEodmFsdWUmJnZhbHVlLl9pc1NpZ25lcil9fWNsYXNzIFZvaWRTaWduZXIgZXh0ZW5kcyBTaWduZXJ7Y29uc3RydWN0b3IoYWRkcmVzcyxwcm92aWRlcil7bG9nZ2VyJGYuY2hlY2tOZXcobmV3LnRhcmdldCxWb2lkU2lnbmVyKTtzdXBlcigpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhZGRyZXNzXCIsYWRkcmVzcyk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb3ZpZGVyXCIscHJvdmlkZXJ8fG51bGwpfWdldEFkZHJlc3MoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyl9X2ZhaWwobWVzc2FnZSxvcGVyYXRpb24pe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57bG9nZ2VyJGYudGhyb3dFcnJvcihtZXNzYWdlLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246b3BlcmF0aW9ufSl9KX1zaWduTWVzc2FnZShtZXNzYWdlKXtyZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gbWVzc2FnZXNcIixcInNpZ25NZXNzYWdlXCIpfXNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbil7cmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIHRyYW5zYWN0aW9uc1wiLFwic2lnblRyYW5zYWN0aW9uXCIpfV9zaWduVHlwZWREYXRhKGRvbWFpbix0eXBlcyx2YWx1ZSl7cmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIHR5cGVkIGRhdGFcIixcInNpZ25UeXBlZERhdGFcIil9Y29ubmVjdChwcm92aWRlcil7cmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcyxwcm92aWRlcil9fXZhciBtaW5pbWFsaXN0aWNBc3NlcnQ9YXNzZXJ0O2Z1bmN0aW9uIGFzc2VydCh2YWwsbXNnKXtpZighdmFsKXRocm93IG5ldyBFcnJvcihtc2d8fFwiQXNzZXJ0aW9uIGZhaWxlZFwiKX1hc3NlcnQuZXF1YWw9ZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCxyLG1zZyl7aWYobCE9cil0aHJvdyBuZXcgRXJyb3IobXNnfHxcIkFzc2VydGlvbiBmYWlsZWQ6IFwiK2wrXCIgIT0gXCIrcil9O3ZhciBpbmhlcml0c19icm93c2VyPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKG1vZHVsZSl7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PT1cImZ1bmN0aW9uXCIpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKGN0b3Isc3VwZXJDdG9yKXtpZihzdXBlckN0b3Ipe2N0b3Iuc3VwZXJfPXN1cGVyQ3RvcjtjdG9yLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpjdG9yLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KX19fWVsc2V7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMoY3RvcixzdXBlckN0b3Ipe2lmKHN1cGVyQ3Rvcil7Y3Rvci5zdXBlcl89c3VwZXJDdG9yO3ZhciBUZW1wQ3Rvcj1mdW5jdGlvbigpe307VGVtcEN0b3IucHJvdG90eXBlPXN1cGVyQ3Rvci5wcm90b3R5cGU7Y3Rvci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO2N0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPWN0b3J9fX19KTt2YXIgaW5oZXJpdHM9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24obW9kdWxlKXt0cnl7dmFyIHV0aWw9bnVsbDtpZih0eXBlb2YgdXRpbC5pbmhlcml0cyE9PVwiZnVuY3Rpb25cIil0aHJvd1wiXCI7bW9kdWxlLmV4cG9ydHM9dXRpbC5pbmhlcml0c31jYXRjaChlKXttb2R1bGUuZXhwb3J0cz1pbmhlcml0c19icm93c2VyfX0pO1widXNlIHN0cmljdFwiO3ZhciBpbmhlcml0c18xPWluaGVyaXRzO2Z1bmN0aW9uIHRvQXJyYXkobXNnLGVuYyl7aWYoQXJyYXkuaXNBcnJheShtc2cpKXJldHVybiBtc2cuc2xpY2UoKTtpZighbXNnKXJldHVybltdO3ZhciByZXM9W107aWYodHlwZW9mIG1zZz09PVwic3RyaW5nXCIpe2lmKCFlbmMpe2Zvcih2YXIgaT0wO2k8bXNnLmxlbmd0aDtpKyspe3ZhciBjPW1zZy5jaGFyQ29kZUF0KGkpO3ZhciBoaT1jPj44O3ZhciBsbz1jJjI1NTtpZihoaSlyZXMucHVzaChoaSxsbyk7ZWxzZSByZXMucHVzaChsbyl9fWVsc2UgaWYoZW5jPT09XCJoZXhcIil7bXNnPW1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2dpLFwiXCIpO2lmKG1zZy5sZW5ndGglMiE9PTApbXNnPVwiMFwiK21zZztmb3IoaT0wO2k8bXNnLmxlbmd0aDtpKz0yKXJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSttc2dbaSsxXSwxNikpfX1lbHNle2ZvcihpPTA7aTxtc2cubGVuZ3RoO2krKylyZXNbaV09bXNnW2ldfDB9cmV0dXJuIHJlc312YXIgdG9BcnJheV8xPXRvQXJyYXk7ZnVuY3Rpb24gdG9IZXgkMShtc2cpe3ZhciByZXM9XCJcIjtmb3IodmFyIGk9MDtpPG1zZy5sZW5ndGg7aSsrKXJlcys9emVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7cmV0dXJuIHJlc312YXIgdG9IZXhfMT10b0hleCQxO2Z1bmN0aW9uIGh0b25sKHcpe3ZhciByZXM9dz4+PjI0fHc+Pj44JjY1MjgwfHc8PDgmMTY3MTE2ODB8KHcmMjU1KTw8MjQ7cmV0dXJuIHJlcz4+PjB9dmFyIGh0b25sXzE9aHRvbmw7ZnVuY3Rpb24gdG9IZXgzMihtc2csZW5kaWFuKXt2YXIgcmVzPVwiXCI7Zm9yKHZhciBpPTA7aTxtc2cubGVuZ3RoO2krKyl7dmFyIHc9bXNnW2ldO2lmKGVuZGlhbj09PVwibGl0dGxlXCIpdz1odG9ubCh3KTtyZXMrPXplcm84KHcudG9TdHJpbmcoMTYpKX1yZXR1cm4gcmVzfXZhciB0b0hleDMyXzE9dG9IZXgzMjtmdW5jdGlvbiB6ZXJvMih3b3JkKXtpZih3b3JkLmxlbmd0aD09PTEpcmV0dXJuXCIwXCIrd29yZDtlbHNlIHJldHVybiB3b3JkfXZhciB6ZXJvMl8xPXplcm8yO2Z1bmN0aW9uIHplcm84KHdvcmQpe2lmKHdvcmQubGVuZ3RoPT09NylyZXR1cm5cIjBcIit3b3JkO2Vsc2UgaWYod29yZC5sZW5ndGg9PT02KXJldHVyblwiMDBcIit3b3JkO2Vsc2UgaWYod29yZC5sZW5ndGg9PT01KXJldHVyblwiMDAwXCIrd29yZDtlbHNlIGlmKHdvcmQubGVuZ3RoPT09NClyZXR1cm5cIjAwMDBcIit3b3JkO2Vsc2UgaWYod29yZC5sZW5ndGg9PT0zKXJldHVyblwiMDAwMDBcIit3b3JkO2Vsc2UgaWYod29yZC5sZW5ndGg9PT0yKXJldHVyblwiMDAwMDAwXCIrd29yZDtlbHNlIGlmKHdvcmQubGVuZ3RoPT09MSlyZXR1cm5cIjAwMDAwMDBcIit3b3JkO2Vsc2UgcmV0dXJuIHdvcmR9dmFyIHplcm84XzE9emVybzg7ZnVuY3Rpb24gam9pbjMyKG1zZyxzdGFydCxlbmQsZW5kaWFuKXt2YXIgbGVuPWVuZC1zdGFydDttaW5pbWFsaXN0aWNBc3NlcnQobGVuJTQ9PT0wKTt2YXIgcmVzPW5ldyBBcnJheShsZW4vNCk7Zm9yKHZhciBpPTAsaz1zdGFydDtpPHJlcy5sZW5ndGg7aSsrLGsrPTQpe3ZhciB3O2lmKGVuZGlhbj09PVwiYmlnXCIpdz1tc2dba108PDI0fG1zZ1trKzFdPDwxNnxtc2dbaysyXTw8OHxtc2dbayszXTtlbHNlIHc9bXNnW2srM108PDI0fG1zZ1trKzJdPDwxNnxtc2dbaysxXTw8OHxtc2dba107cmVzW2ldPXc+Pj4wfXJldHVybiByZXN9dmFyIGpvaW4zMl8xPWpvaW4zMjtmdW5jdGlvbiBzcGxpdDMyKG1zZyxlbmRpYW4pe3ZhciByZXM9bmV3IEFycmF5KG1zZy5sZW5ndGgqNCk7Zm9yKHZhciBpPTAsaz0wO2k8bXNnLmxlbmd0aDtpKyssays9NCl7dmFyIG09bXNnW2ldO2lmKGVuZGlhbj09PVwiYmlnXCIpe3Jlc1trXT1tPj4+MjQ7cmVzW2srMV09bT4+PjE2JjI1NTtyZXNbaysyXT1tPj4+OCYyNTU7cmVzW2srM109bSYyNTV9ZWxzZXtyZXNbayszXT1tPj4+MjQ7cmVzW2srMl09bT4+PjE2JjI1NTtyZXNbaysxXT1tPj4+OCYyNTU7cmVzW2tdPW0mMjU1fX1yZXR1cm4gcmVzfXZhciBzcGxpdDMyXzE9c3BsaXQzMjtmdW5jdGlvbiByb3RyMzIodyxiKXtyZXR1cm4gdz4+PmJ8dzw8MzItYn12YXIgcm90cjMyXzE9cm90cjMyO2Z1bmN0aW9uIHJvdGwzMih3LGIpe3JldHVybiB3PDxifHc+Pj4zMi1ifXZhciByb3RsMzJfMT1yb3RsMzI7ZnVuY3Rpb24gc3VtMzIoYSxiKXtyZXR1cm4gYStiPj4+MH12YXIgc3VtMzJfMT1zdW0zMjtmdW5jdGlvbiBzdW0zMl8zKGEsYixjKXtyZXR1cm4gYStiK2M+Pj4wfXZhciBzdW0zMl8zXzE9c3VtMzJfMztmdW5jdGlvbiBzdW0zMl80KGEsYixjLGQpe3JldHVybiBhK2IrYytkPj4+MH12YXIgc3VtMzJfNF8xPXN1bTMyXzQ7ZnVuY3Rpb24gc3VtMzJfNShhLGIsYyxkLGUpe3JldHVybiBhK2IrYytkK2U+Pj4wfXZhciBzdW0zMl81XzE9c3VtMzJfNTtmdW5jdGlvbiBzdW02NChidWYscG9zLGFoLGFsKXt2YXIgYmg9YnVmW3Bvc107dmFyIGJsPWJ1Zltwb3MrMV07dmFyIGxvPWFsK2JsPj4+MDt2YXIgaGk9KGxvPGFsPzE6MCkrYWgrYmg7YnVmW3Bvc109aGk+Pj4wO2J1Zltwb3MrMV09bG99dmFyIHN1bTY0XzE9c3VtNjQ7ZnVuY3Rpb24gc3VtNjRfaGkoYWgsYWwsYmgsYmwpe3ZhciBsbz1hbCtibD4+PjA7dmFyIGhpPShsbzxhbD8xOjApK2FoK2JoO3JldHVybiBoaT4+PjB9dmFyIHN1bTY0X2hpXzE9c3VtNjRfaGk7ZnVuY3Rpb24gc3VtNjRfbG8oYWgsYWwsYmgsYmwpe3ZhciBsbz1hbCtibDtyZXR1cm4gbG8+Pj4wfXZhciBzdW02NF9sb18xPXN1bTY0X2xvO2Z1bmN0aW9uIHN1bTY0XzRfaGkoYWgsYWwsYmgsYmwsY2gsY2wsZGgsZGwpe3ZhciBjYXJyeT0wO3ZhciBsbz1hbDtsbz1sbytibD4+PjA7Y2FycnkrPWxvPGFsPzE6MDtsbz1sbytjbD4+PjA7Y2FycnkrPWxvPGNsPzE6MDtsbz1sbytkbD4+PjA7Y2FycnkrPWxvPGRsPzE6MDt2YXIgaGk9YWgrYmgrY2grZGgrY2Fycnk7cmV0dXJuIGhpPj4+MH12YXIgc3VtNjRfNF9oaV8xPXN1bTY0XzRfaGk7ZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCxhbCxiaCxibCxjaCxjbCxkaCxkbCl7dmFyIGxvPWFsK2JsK2NsK2RsO3JldHVybiBsbz4+PjB9dmFyIHN1bTY0XzRfbG9fMT1zdW02NF80X2xvO2Z1bmN0aW9uIHN1bTY0XzVfaGkoYWgsYWwsYmgsYmwsY2gsY2wsZGgsZGwsZWgsZWwpe3ZhciBjYXJyeT0wO3ZhciBsbz1hbDtsbz1sbytibD4+PjA7Y2FycnkrPWxvPGFsPzE6MDtsbz1sbytjbD4+PjA7Y2FycnkrPWxvPGNsPzE6MDtsbz1sbytkbD4+PjA7Y2FycnkrPWxvPGRsPzE6MDtsbz1sbytlbD4+PjA7Y2FycnkrPWxvPGVsPzE6MDt2YXIgaGk9YWgrYmgrY2grZGgrZWgrY2Fycnk7cmV0dXJuIGhpPj4+MH12YXIgc3VtNjRfNV9oaV8xPXN1bTY0XzVfaGk7ZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCxhbCxiaCxibCxjaCxjbCxkaCxkbCxlaCxlbCl7dmFyIGxvPWFsK2JsK2NsK2RsK2VsO3JldHVybiBsbz4+PjB9dmFyIHN1bTY0XzVfbG9fMT1zdW02NF81X2xvO2Z1bmN0aW9uIHJvdHI2NF9oaShhaCxhbCxudW0pe3ZhciByPWFsPDwzMi1udW18YWg+Pj5udW07cmV0dXJuIHI+Pj4wfXZhciByb3RyNjRfaGlfMT1yb3RyNjRfaGk7ZnVuY3Rpb24gcm90cjY0X2xvKGFoLGFsLG51bSl7dmFyIHI9YWg8PDMyLW51bXxhbD4+Pm51bTtyZXR1cm4gcj4+PjB9dmFyIHJvdHI2NF9sb18xPXJvdHI2NF9sbztmdW5jdGlvbiBzaHI2NF9oaShhaCxhbCxudW0pe3JldHVybiBhaD4+Pm51bX12YXIgc2hyNjRfaGlfMT1zaHI2NF9oaTtmdW5jdGlvbiBzaHI2NF9sbyhhaCxhbCxudW0pe3ZhciByPWFoPDwzMi1udW18YWw+Pj5udW07cmV0dXJuIHI+Pj4wfXZhciBzaHI2NF9sb18xPXNocjY0X2xvO3ZhciB1dGlscz17aW5oZXJpdHM6aW5oZXJpdHNfMSx0b0FycmF5OnRvQXJyYXlfMSx0b0hleDp0b0hleF8xLGh0b25sOmh0b25sXzEsdG9IZXgzMjp0b0hleDMyXzEsemVybzI6emVybzJfMSx6ZXJvODp6ZXJvOF8xLGpvaW4zMjpqb2luMzJfMSxzcGxpdDMyOnNwbGl0MzJfMSxyb3RyMzI6cm90cjMyXzEscm90bDMyOnJvdGwzMl8xLHN1bTMyOnN1bTMyXzEsc3VtMzJfMzpzdW0zMl8zXzEsc3VtMzJfNDpzdW0zMl80XzEsc3VtMzJfNTpzdW0zMl81XzEsc3VtNjQ6c3VtNjRfMSxzdW02NF9oaTpzdW02NF9oaV8xLHN1bTY0X2xvOnN1bTY0X2xvXzEsc3VtNjRfNF9oaTpzdW02NF80X2hpXzEsc3VtNjRfNF9sbzpzdW02NF80X2xvXzEsc3VtNjRfNV9oaTpzdW02NF81X2hpXzEsc3VtNjRfNV9sbzpzdW02NF81X2xvXzEscm90cjY0X2hpOnJvdHI2NF9oaV8xLHJvdHI2NF9sbzpyb3RyNjRfbG9fMSxzaHI2NF9oaTpzaHI2NF9oaV8xLHNocjY0X2xvOnNocjY0X2xvXzF9O1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIEJsb2NrSGFzaCgpe3RoaXMucGVuZGluZz1udWxsO3RoaXMucGVuZGluZ1RvdGFsPTA7dGhpcy5ibG9ja1NpemU9dGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7dGhpcy5vdXRTaXplPXRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTt0aGlzLmhtYWNTdHJlbmd0aD10aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDt0aGlzLnBhZExlbmd0aD10aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aC84O3RoaXMuZW5kaWFuPVwiYmlnXCI7dGhpcy5fZGVsdGE4PXRoaXMuYmxvY2tTaXplLzg7dGhpcy5fZGVsdGEzMj10aGlzLmJsb2NrU2l6ZS8zMn12YXIgQmxvY2tIYXNoXzE9QmxvY2tIYXNoO0Jsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uIHVwZGF0ZShtc2csZW5jKXttc2c9dXRpbHMudG9BcnJheShtc2csZW5jKTtpZighdGhpcy5wZW5kaW5nKXRoaXMucGVuZGluZz1tc2c7ZWxzZSB0aGlzLnBlbmRpbmc9dGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO3RoaXMucGVuZGluZ1RvdGFsKz1tc2cubGVuZ3RoO2lmKHRoaXMucGVuZGluZy5sZW5ndGg+PXRoaXMuX2RlbHRhOCl7bXNnPXRoaXMucGVuZGluZzt2YXIgcj1tc2cubGVuZ3RoJXRoaXMuX2RlbHRhODt0aGlzLnBlbmRpbmc9bXNnLnNsaWNlKG1zZy5sZW5ndGgtcixtc2cubGVuZ3RoKTtpZih0aGlzLnBlbmRpbmcubGVuZ3RoPT09MCl0aGlzLnBlbmRpbmc9bnVsbDttc2c9dXRpbHMuam9pbjMyKG1zZywwLG1zZy5sZW5ndGgtcix0aGlzLmVuZGlhbik7Zm9yKHZhciBpPTA7aTxtc2cubGVuZ3RoO2krPXRoaXMuX2RlbHRhMzIpdGhpcy5fdXBkYXRlKG1zZyxpLGkrdGhpcy5fZGVsdGEzMil9cmV0dXJuIHRoaXN9O0Jsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0PWZ1bmN0aW9uIGRpZ2VzdChlbmMpe3RoaXMudXBkYXRlKHRoaXMuX3BhZCgpKTttaW5pbWFsaXN0aWNBc3NlcnQodGhpcy5wZW5kaW5nPT09bnVsbCk7cmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpfTtCbG9ja0hhc2gucHJvdG90eXBlLl9wYWQ9ZnVuY3Rpb24gcGFkKCl7dmFyIGxlbj10aGlzLnBlbmRpbmdUb3RhbDt2YXIgYnl0ZXM9dGhpcy5fZGVsdGE4O3ZhciBrPWJ5dGVzLShsZW4rdGhpcy5wYWRMZW5ndGgpJWJ5dGVzO3ZhciByZXM9bmV3IEFycmF5KGsrdGhpcy5wYWRMZW5ndGgpO3Jlc1swXT0xMjg7Zm9yKHZhciBpPTE7aTxrO2krKylyZXNbaV09MDtsZW48PD0zO2lmKHRoaXMuZW5kaWFuPT09XCJiaWdcIil7Zm9yKHZhciB0PTg7dDx0aGlzLnBhZExlbmd0aDt0KyspcmVzW2krK109MDtyZXNbaSsrXT0wO3Jlc1tpKytdPTA7cmVzW2krK109MDtyZXNbaSsrXT0wO3Jlc1tpKytdPWxlbj4+PjI0JjI1NTtyZXNbaSsrXT1sZW4+Pj4xNiYyNTU7cmVzW2krK109bGVuPj4+OCYyNTU7cmVzW2krK109bGVuJjI1NX1lbHNle3Jlc1tpKytdPWxlbiYyNTU7cmVzW2krK109bGVuPj4+OCYyNTU7cmVzW2krK109bGVuPj4+MTYmMjU1O3Jlc1tpKytdPWxlbj4+PjI0JjI1NTtyZXNbaSsrXT0wO3Jlc1tpKytdPTA7cmVzW2krK109MDtyZXNbaSsrXT0wO2Zvcih0PTg7dDx0aGlzLnBhZExlbmd0aDt0KyspcmVzW2krK109MH1yZXR1cm4gcmVzfTt2YXIgY29tbW9uPXtCbG9ja0hhc2g6QmxvY2tIYXNoXzF9O1widXNlIHN0cmljdFwiO3ZhciByb3RyMzIkMT11dGlscy5yb3RyMzI7ZnVuY3Rpb24gZnRfMShzLHgseSx6KXtpZihzPT09MClyZXR1cm4gY2gzMih4LHkseik7aWYocz09PTF8fHM9PT0zKXJldHVybiBwMzIoeCx5LHopO2lmKHM9PT0yKXJldHVybiBtYWozMih4LHkseil9dmFyIGZ0XzFfMT1mdF8xO2Z1bmN0aW9uIGNoMzIoeCx5LHope3JldHVybiB4Jnlefngmen12YXIgY2gzMl8xPWNoMzI7ZnVuY3Rpb24gbWFqMzIoeCx5LHope3JldHVybiB4JnleeCZ6Xnkmen12YXIgbWFqMzJfMT1tYWozMjtmdW5jdGlvbiBwMzIoeCx5LHope3JldHVybiB4Xnleen12YXIgcDMyXzE9cDMyO2Z1bmN0aW9uIHMwXzI1Nih4KXtyZXR1cm4gcm90cjMyJDEoeCwyKV5yb3RyMzIkMSh4LDEzKV5yb3RyMzIkMSh4LDIyKX12YXIgczBfMjU2XzE9czBfMjU2O2Z1bmN0aW9uIHMxXzI1Nih4KXtyZXR1cm4gcm90cjMyJDEoeCw2KV5yb3RyMzIkMSh4LDExKV5yb3RyMzIkMSh4LDI1KX12YXIgczFfMjU2XzE9czFfMjU2O2Z1bmN0aW9uIGcwXzI1Nih4KXtyZXR1cm4gcm90cjMyJDEoeCw3KV5yb3RyMzIkMSh4LDE4KV54Pj4+M312YXIgZzBfMjU2XzE9ZzBfMjU2O2Z1bmN0aW9uIGcxXzI1Nih4KXtyZXR1cm4gcm90cjMyJDEoeCwxNylecm90cjMyJDEoeCwxOSleeD4+PjEwfXZhciBnMV8yNTZfMT1nMV8yNTY7dmFyIGNvbW1vbiQxPXtmdF8xOmZ0XzFfMSxjaDMyOmNoMzJfMSxtYWozMjptYWozMl8xLHAzMjpwMzJfMSxzMF8yNTY6czBfMjU2XzEsczFfMjU2OnMxXzI1Nl8xLGcwXzI1NjpnMF8yNTZfMSxnMV8yNTY6ZzFfMjU2XzF9O1widXNlIHN0cmljdFwiO3ZhciByb3RsMzIkMT11dGlscy5yb3RsMzI7dmFyIHN1bTMyJDE9dXRpbHMuc3VtMzI7dmFyIHN1bTMyXzUkMT11dGlscy5zdW0zMl81O3ZhciBmdF8xJDE9Y29tbW9uJDEuZnRfMTt2YXIgQmxvY2tIYXNoJDE9Y29tbW9uLkJsb2NrSGFzaDt2YXIgc2hhMV9LPVsxNTE4NTAwMjQ5LDE4NTk3NzUzOTMsMjQwMDk1OTcwOCwzMzk1NDY5NzgyXTtmdW5jdGlvbiBTSEExKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgU0hBMSkpcmV0dXJuIG5ldyBTSEExO0Jsb2NrSGFzaCQxLmNhbGwodGhpcyk7dGhpcy5oPVsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzgsMzI4NTM3NzUyMF07dGhpcy5XPW5ldyBBcnJheSg4MCl9dXRpbHMuaW5oZXJpdHMoU0hBMSxCbG9ja0hhc2gkMSk7dmFyIF8xPVNIQTE7U0hBMS5ibG9ja1NpemU9NTEyO1NIQTEub3V0U2l6ZT0xNjA7U0hBMS5obWFjU3RyZW5ndGg9ODA7U0hBMS5wYWRMZW5ndGg9NjQ7U0hBMS5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbiBfdXBkYXRlKG1zZyxzdGFydCl7dmFyIFc9dGhpcy5XO2Zvcih2YXIgaT0wO2k8MTY7aSsrKVdbaV09bXNnW3N0YXJ0K2ldO2Zvcig7aTxXLmxlbmd0aDtpKyspV1tpXT1yb3RsMzIkMShXW2ktM11eV1tpLThdXldbaS0xNF1eV1tpLTE2XSwxKTt2YXIgYT10aGlzLmhbMF07dmFyIGI9dGhpcy5oWzFdO3ZhciBjPXRoaXMuaFsyXTt2YXIgZD10aGlzLmhbM107dmFyIGU9dGhpcy5oWzRdO2ZvcihpPTA7aTxXLmxlbmd0aDtpKyspe3ZhciBzPX5+KGkvMjApO3ZhciB0PXN1bTMyXzUkMShyb3RsMzIkMShhLDUpLGZ0XzEkMShzLGIsYyxkKSxlLFdbaV0sc2hhMV9LW3NdKTtlPWQ7ZD1jO2M9cm90bDMyJDEoYiwzMCk7Yj1hO2E9dH10aGlzLmhbMF09c3VtMzIkMSh0aGlzLmhbMF0sYSk7dGhpcy5oWzFdPXN1bTMyJDEodGhpcy5oWzFdLGIpO3RoaXMuaFsyXT1zdW0zMiQxKHRoaXMuaFsyXSxjKTt0aGlzLmhbM109c3VtMzIkMSh0aGlzLmhbM10sZCk7dGhpcy5oWzRdPXN1bTMyJDEodGhpcy5oWzRdLGUpfTtTSEExLnByb3RvdHlwZS5fZGlnZXN0PWZ1bmN0aW9uIGRpZ2VzdChlbmMpe2lmKGVuYz09PVwiaGV4XCIpcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLFwiYmlnXCIpO2Vsc2UgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLFwiYmlnXCIpfTtcInVzZSBzdHJpY3RcIjt2YXIgc3VtMzIkMj11dGlscy5zdW0zMjt2YXIgc3VtMzJfNCQxPXV0aWxzLnN1bTMyXzQ7dmFyIHN1bTMyXzUkMj11dGlscy5zdW0zMl81O3ZhciBjaDMyJDE9Y29tbW9uJDEuY2gzMjt2YXIgbWFqMzIkMT1jb21tb24kMS5tYWozMjt2YXIgczBfMjU2JDE9Y29tbW9uJDEuczBfMjU2O3ZhciBzMV8yNTYkMT1jb21tb24kMS5zMV8yNTY7dmFyIGcwXzI1NiQxPWNvbW1vbiQxLmcwXzI1Njt2YXIgZzFfMjU2JDE9Y29tbW9uJDEuZzFfMjU2O3ZhciBCbG9ja0hhc2gkMj1jb21tb24uQmxvY2tIYXNoO3ZhciBzaGEyNTZfSz1bMTExNjM1MjQwOCwxODk5NDQ3NDQxLDMwNDkzMjM0NzEsMzkyMTAwOTU3Myw5NjE5ODcxNjMsMTUwODk3MDk5MywyNDUzNjM1NzQ4LDI4NzA3NjMyMjEsMzYyNDM4MTA4MCwzMTA1OTg0MDEsNjA3MjI1Mjc4LDE0MjY4ODE5ODcsMTkyNTA3ODM4OCwyMTYyMDc4MjA2LDI2MTQ4ODgxMDMsMzI0ODIyMjU4MCwzODM1MzkwNDAxLDQwMjIyMjQ3NzQsMjY0MzQ3MDc4LDYwNDgwNzYyOCw3NzAyNTU5ODMsMTI0OTE1MDEyMiwxNTU1MDgxNjkyLDE5OTYwNjQ5ODYsMjU1NDIyMDg4MiwyODIxODM0MzQ5LDI5NTI5OTY4MDgsMzIxMDMxMzY3MSwzMzM2NTcxODkxLDM1ODQ1Mjg3MTEsMTEzOTI2OTkzLDMzODI0MTg5NSw2NjYzMDcyMDUsNzczNTI5OTEyLDEyOTQ3NTczNzIsMTM5NjE4MjI5MSwxNjk1MTgzNzAwLDE5ODY2NjEwNTEsMjE3NzAyNjM1MCwyNDU2OTU2MDM3LDI3MzA0ODU5MjEsMjgyMDMwMjQxMSwzMjU5NzMwODAwLDMzNDU3NjQ3NzEsMzUxNjA2NTgxNywzNjAwMzUyODA0LDQwOTQ1NzE5MDksMjc1NDIzMzQ0LDQzMDIyNzczNCw1MDY5NDg2MTYsNjU5MDYwNTU2LDg4Mzk5Nzg3Nyw5NTgxMzk1NzEsMTMyMjgyMjIxOCwxNTM3MDAyMDYzLDE3NDc4NzM3NzksMTk1NTU2MjIyMiwyMDI0MTA0ODE1LDIyMjc3MzA0NTIsMjM2MTg1MjQyNCwyNDI4NDM2NDc0LDI3NTY3MzQxODcsMzIwNDAzMTQ3OSwzMzI5MzI1Mjk4XTtmdW5jdGlvbiBTSEEyNTYoKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTSEEyNTYpKXJldHVybiBuZXcgU0hBMjU2O0Jsb2NrSGFzaCQyLmNhbGwodGhpcyk7dGhpcy5oPVsxNzc5MDMzNzAzLDMxNDQxMzQyNzcsMTAxMzkwNDI0MiwyNzczNDgwNzYyLDEzNTk4OTMxMTksMjYwMDgyMjkyNCw1Mjg3MzQ2MzUsMTU0MTQ1OTIyNV07dGhpcy5rPXNoYTI1Nl9LO3RoaXMuVz1uZXcgQXJyYXkoNjQpfXV0aWxzLmluaGVyaXRzKFNIQTI1NixCbG9ja0hhc2gkMik7dmFyIF8yNTY9U0hBMjU2O1NIQTI1Ni5ibG9ja1NpemU9NTEyO1NIQTI1Ni5vdXRTaXplPTI1NjtTSEEyNTYuaG1hY1N0cmVuZ3RoPTE5MjtTSEEyNTYucGFkTGVuZ3RoPTY0O1NIQTI1Ni5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbiBfdXBkYXRlKG1zZyxzdGFydCl7dmFyIFc9dGhpcy5XO2Zvcih2YXIgaT0wO2k8MTY7aSsrKVdbaV09bXNnW3N0YXJ0K2ldO2Zvcig7aTxXLmxlbmd0aDtpKyspV1tpXT1zdW0zMl80JDEoZzFfMjU2JDEoV1tpLTJdKSxXW2ktN10sZzBfMjU2JDEoV1tpLTE1XSksV1tpLTE2XSk7dmFyIGE9dGhpcy5oWzBdO3ZhciBiPXRoaXMuaFsxXTt2YXIgYz10aGlzLmhbMl07dmFyIGQ9dGhpcy5oWzNdO3ZhciBlPXRoaXMuaFs0XTt2YXIgZj10aGlzLmhbNV07dmFyIGc9dGhpcy5oWzZdO3ZhciBoPXRoaXMuaFs3XTttaW5pbWFsaXN0aWNBc3NlcnQodGhpcy5rLmxlbmd0aD09PVcubGVuZ3RoKTtmb3IoaT0wO2k8Vy5sZW5ndGg7aSsrKXt2YXIgVDE9c3VtMzJfNSQyKGgsczFfMjU2JDEoZSksY2gzMiQxKGUsZixnKSx0aGlzLmtbaV0sV1tpXSk7dmFyIFQyPXN1bTMyJDIoczBfMjU2JDEoYSksbWFqMzIkMShhLGIsYykpO2g9ZztnPWY7Zj1lO2U9c3VtMzIkMihkLFQxKTtkPWM7Yz1iO2I9YTthPXN1bTMyJDIoVDEsVDIpfXRoaXMuaFswXT1zdW0zMiQyKHRoaXMuaFswXSxhKTt0aGlzLmhbMV09c3VtMzIkMih0aGlzLmhbMV0sYik7dGhpcy5oWzJdPXN1bTMyJDIodGhpcy5oWzJdLGMpO3RoaXMuaFszXT1zdW0zMiQyKHRoaXMuaFszXSxkKTt0aGlzLmhbNF09c3VtMzIkMih0aGlzLmhbNF0sZSk7dGhpcy5oWzVdPXN1bTMyJDIodGhpcy5oWzVdLGYpO3RoaXMuaFs2XT1zdW0zMiQyKHRoaXMuaFs2XSxnKTt0aGlzLmhbN109c3VtMzIkMih0aGlzLmhbN10saCl9O1NIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCxcImJpZ1wiKTtlbHNlIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCxcImJpZ1wiKX07XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gU0hBMjI0KCl7aWYoISh0aGlzIGluc3RhbmNlb2YgU0hBMjI0KSlyZXR1cm4gbmV3IFNIQTIyNDtfMjU2LmNhbGwodGhpcyk7dGhpcy5oPVszMjM4MzcxMDMyLDkxNDE1MDY2Myw4MTI3MDI5OTksNDE0NDkxMjY5Nyw0MjkwNzc1ODU3LDE3NTA2MDMwMjUsMTY5NDA3NjgzOSwzMjA0MDc1NDI4XX11dGlscy5pbmhlcml0cyhTSEEyMjQsXzI1Nik7dmFyIF8yMjQ9U0hBMjI0O1NIQTIyNC5ibG9ja1NpemU9NTEyO1NIQTIyNC5vdXRTaXplPTIyNDtTSEEyMjQuaG1hY1N0cmVuZ3RoPTE5MjtTSEEyMjQucGFkTGVuZ3RoPTY0O1NIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLDcpLFwiYmlnXCIpO2Vsc2UgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsNyksXCJiaWdcIil9O1widXNlIHN0cmljdFwiO3ZhciByb3RyNjRfaGkkMT11dGlscy5yb3RyNjRfaGk7dmFyIHJvdHI2NF9sbyQxPXV0aWxzLnJvdHI2NF9sbzt2YXIgc2hyNjRfaGkkMT11dGlscy5zaHI2NF9oaTt2YXIgc2hyNjRfbG8kMT11dGlscy5zaHI2NF9sbzt2YXIgc3VtNjQkMT11dGlscy5zdW02NDt2YXIgc3VtNjRfaGkkMT11dGlscy5zdW02NF9oaTt2YXIgc3VtNjRfbG8kMT11dGlscy5zdW02NF9sbzt2YXIgc3VtNjRfNF9oaSQxPXV0aWxzLnN1bTY0XzRfaGk7dmFyIHN1bTY0XzRfbG8kMT11dGlscy5zdW02NF80X2xvO3ZhciBzdW02NF81X2hpJDE9dXRpbHMuc3VtNjRfNV9oaTt2YXIgc3VtNjRfNV9sbyQxPXV0aWxzLnN1bTY0XzVfbG87dmFyIEJsb2NrSGFzaCQzPWNvbW1vbi5CbG9ja0hhc2g7dmFyIHNoYTUxMl9LPVsxMTE2MzUyNDA4LDM2MDk3Njc0NTgsMTg5OTQ0NzQ0MSw2MDI4OTE3MjUsMzA0OTMyMzQ3MSwzOTY0NDg0Mzk5LDM5MjEwMDk1NzMsMjE3MzI5NTU0OCw5NjE5ODcxNjMsNDA4MTYyODQ3MiwxNTA4OTcwOTkzLDMwNTM4MzQyNjUsMjQ1MzYzNTc0OCwyOTM3NjcxNTc5LDI4NzA3NjMyMjEsMzY2NDYwOTU2MCwzNjI0MzgxMDgwLDI3MzQ4ODMzOTQsMzEwNTk4NDAxLDExNjQ5OTY1NDIsNjA3MjI1Mjc4LDEzMjM2MTA3NjQsMTQyNjg4MTk4NywzNTkwMzA0OTk0LDE5MjUwNzgzODgsNDA2ODE4MjM4MywyMTYyMDc4MjA2LDk5MTMzNjExMywyNjE0ODg4MTAzLDYzMzgwMzMxNywzMjQ4MjIyNTgwLDM0Nzk3NzQ4NjgsMzgzNTM5MDQwMSwyNjY2NjEzNDU4LDQwMjIyMjQ3NzQsOTQ0NzExMTM5LDI2NDM0NzA3OCwyMzQxMjYyNzczLDYwNDgwNzYyOCwyMDA3ODAwOTMzLDc3MDI1NTk4MywxNDk1OTkwOTAxLDEyNDkxNTAxMjIsMTg1NjQzMTIzNSwxNTU1MDgxNjkyLDMxNzUyMTgxMzIsMTk5NjA2NDk4NiwyMTk4OTUwODM3LDI1NTQyMjA4ODIsMzk5OTcxOTMzOSwyODIxODM0MzQ5LDc2Njc4NDAxNiwyOTUyOTk2ODA4LDI1NjY1OTQ4NzksMzIxMDMxMzY3MSwzMjAzMzM3OTU2LDMzMzY1NzE4OTEsMTAzNDQ1NzAyNiwzNTg0NTI4NzExLDI0NjY5NDg5MDEsMTEzOTI2OTkzLDM3NTgzMjYzODMsMzM4MjQxODk1LDE2ODcxNzkzNiw2NjYzMDcyMDUsMTE4ODE3OTk2NCw3NzM1Mjk5MTIsMTU0NjA0NTczNCwxMjk0NzU3MzcyLDE1MjI4MDU0ODUsMTM5NjE4MjI5MSwyNjQzODMzODIzLDE2OTUxODM3MDAsMjM0MzUyNzM5MCwxOTg2NjYxMDUxLDEwMTQ0Nzc0ODAsMjE3NzAyNjM1MCwxMjA2NzU5MTQyLDI0NTY5NTYwMzcsMzQ0MDc3NjI3LDI3MzA0ODU5MjEsMTI5MDg2MzQ2MCwyODIwMzAyNDExLDMxNTg0NTQyNzMsMzI1OTczMDgwMCwzNTA1OTUyNjU3LDMzNDU3NjQ3NzEsMTA2MjE3MDA4LDM1MTYwNjU4MTcsMzYwNjAwODM0NCwzNjAwMzUyODA0LDE0MzI3MjU3NzYsNDA5NDU3MTkwOSwxNDY3MDMxNTk0LDI3NTQyMzM0NCw4NTExNjk3MjAsNDMwMjI3NzM0LDMxMDA4MjM3NTIsNTA2OTQ4NjE2LDEzNjMyNTgxOTUsNjU5MDYwNTU2LDM3NTA2ODU1OTMsODgzOTk3ODc3LDM3ODUwNTAyODAsOTU4MTM5NTcxLDMzMTgzMDc0MjcsMTMyMjgyMjIxOCwzODEyNzIzNDAzLDE1MzcwMDIwNjMsMjAwMzAzNDk5NSwxNzQ3ODczNzc5LDM2MDIwMzY4OTksMTk1NTU2MjIyMiwxNTc1OTkwMDEyLDIwMjQxMDQ4MTUsMTEyNTU5MjkyOCwyMjI3NzMwNDUyLDI3MTY5MDQzMDYsMjM2MTg1MjQyNCw0NDI3NzYwNDQsMjQyODQzNjQ3NCw1OTM2OTgzNDQsMjc1NjczNDE4NywzNzMzMTEwMjQ5LDMyMDQwMzE0NzksMjk5OTM1MTU3MywzMzI5MzI1Mjk4LDM4MTU5MjA0MjcsMzM5MTU2OTYxNCwzOTI4MzgzOTAwLDM1MTUyNjcyNzEsNTY2MjgwNzExLDM5NDAxODc2MDYsMzQ1NDA2OTUzNCw0MTE4NjMwMjcxLDQwMDAyMzk5OTIsMTE2NDE4NDc0LDE5MTQxMzg1NTQsMTc0MjkyNDIxLDI3MzEwNTUyNzAsMjg5MzgwMzU2LDMyMDM5OTMwMDYsNDYwMzkzMjY5LDMyMDYyMDMxNSw2ODU0NzE3MzMsNTg3NDk2ODM2LDg1MjE0Mjk3MSwxMDg2NzkyODUxLDEwMTcwMzYyOTgsMzY1NTQzMTAwLDExMjYwMDA1ODAsMjYxODI5NzY3NiwxMjg4MDMzNDcwLDM0MDk4NTUxNTgsMTUwMTUwNTk0OCw0MjM0NTA5ODY2LDE2MDcxNjc5MTUsOTg3MTY3NDY4LDE4MTY0MDIzMTYsMTI0NjE4OTU5MV07ZnVuY3Rpb24gU0hBNTEyKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlyZXR1cm4gbmV3IFNIQTUxMjtCbG9ja0hhc2gkMy5jYWxsKHRoaXMpO3RoaXMuaD1bMTc3OTAzMzcwMyw0MDg5MjM1NzIwLDMxNDQxMzQyNzcsMjIyNzg3MzU5NSwxMDEzOTA0MjQyLDQyNzExNzU3MjMsMjc3MzQ4MDc2MiwxNTk1NzUwMTI5LDEzNTk4OTMxMTksMjkxNzU2NTEzNywyNjAwODIyOTI0LDcyNTUxMTE5OSw1Mjg3MzQ2MzUsNDIxNTM4OTU0NywxNTQxNDU5MjI1LDMyNzAzMzIwOV07dGhpcy5rPXNoYTUxMl9LO3RoaXMuVz1uZXcgQXJyYXkoMTYwKX11dGlscy5pbmhlcml0cyhTSEE1MTIsQmxvY2tIYXNoJDMpO3ZhciBfNTEyPVNIQTUxMjtTSEE1MTIuYmxvY2tTaXplPTEwMjQ7U0hBNTEyLm91dFNpemU9NTEyO1NIQTUxMi5obWFjU3RyZW5ndGg9MTkyO1NIQTUxMi5wYWRMZW5ndGg9MTI4O1NIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jaz1mdW5jdGlvbiBfcHJlcGFyZUJsb2NrKG1zZyxzdGFydCl7dmFyIFc9dGhpcy5XO2Zvcih2YXIgaT0wO2k8MzI7aSsrKVdbaV09bXNnW3N0YXJ0K2ldO2Zvcig7aTxXLmxlbmd0aDtpKz0yKXt2YXIgYzBfaGk9ZzFfNTEyX2hpKFdbaS00XSxXW2ktM10pO3ZhciBjMF9sbz1nMV81MTJfbG8oV1tpLTRdLFdbaS0zXSk7dmFyIGMxX2hpPVdbaS0xNF07dmFyIGMxX2xvPVdbaS0xM107dmFyIGMyX2hpPWcwXzUxMl9oaShXW2ktMzBdLFdbaS0yOV0pO3ZhciBjMl9sbz1nMF81MTJfbG8oV1tpLTMwXSxXW2ktMjldKTt2YXIgYzNfaGk9V1tpLTMyXTt2YXIgYzNfbG89V1tpLTMxXTtXW2ldPXN1bTY0XzRfaGkkMShjMF9oaSxjMF9sbyxjMV9oaSxjMV9sbyxjMl9oaSxjMl9sbyxjM19oaSxjM19sbyk7V1tpKzFdPXN1bTY0XzRfbG8kMShjMF9oaSxjMF9sbyxjMV9oaSxjMV9sbyxjMl9oaSxjMl9sbyxjM19oaSxjM19sbyl9fTtTSEE1MTIucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24gX3VwZGF0ZShtc2csc3RhcnQpe3RoaXMuX3ByZXBhcmVCbG9jayhtc2csc3RhcnQpO3ZhciBXPXRoaXMuVzt2YXIgYWg9dGhpcy5oWzBdO3ZhciBhbD10aGlzLmhbMV07dmFyIGJoPXRoaXMuaFsyXTt2YXIgYmw9dGhpcy5oWzNdO3ZhciBjaD10aGlzLmhbNF07dmFyIGNsPXRoaXMuaFs1XTt2YXIgZGg9dGhpcy5oWzZdO3ZhciBkbD10aGlzLmhbN107dmFyIGVoPXRoaXMuaFs4XTt2YXIgZWw9dGhpcy5oWzldO3ZhciBmaD10aGlzLmhbMTBdO3ZhciBmbD10aGlzLmhbMTFdO3ZhciBnaD10aGlzLmhbMTJdO3ZhciBnbD10aGlzLmhbMTNdO3ZhciBoaD10aGlzLmhbMTRdO3ZhciBobD10aGlzLmhbMTVdO21pbmltYWxpc3RpY0Fzc2VydCh0aGlzLmsubGVuZ3RoPT09Vy5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8Vy5sZW5ndGg7aSs9Mil7dmFyIGMwX2hpPWhoO3ZhciBjMF9sbz1obDt2YXIgYzFfaGk9czFfNTEyX2hpKGVoLGVsKTt2YXIgYzFfbG89czFfNTEyX2xvKGVoLGVsKTt2YXIgYzJfaGk9Y2g2NF9oaShlaCxlbCxmaCxmbCxnaCxnbCk7dmFyIGMyX2xvPWNoNjRfbG8oZWgsZWwsZmgsZmwsZ2gsZ2wpO3ZhciBjM19oaT10aGlzLmtbaV07dmFyIGMzX2xvPXRoaXMua1tpKzFdO3ZhciBjNF9oaT1XW2ldO3ZhciBjNF9sbz1XW2krMV07dmFyIFQxX2hpPXN1bTY0XzVfaGkkMShjMF9oaSxjMF9sbyxjMV9oaSxjMV9sbyxjMl9oaSxjMl9sbyxjM19oaSxjM19sbyxjNF9oaSxjNF9sbyk7dmFyIFQxX2xvPXN1bTY0XzVfbG8kMShjMF9oaSxjMF9sbyxjMV9oaSxjMV9sbyxjMl9oaSxjMl9sbyxjM19oaSxjM19sbyxjNF9oaSxjNF9sbyk7YzBfaGk9czBfNTEyX2hpKGFoLGFsKTtjMF9sbz1zMF81MTJfbG8oYWgsYWwpO2MxX2hpPW1hajY0X2hpKGFoLGFsLGJoLGJsLGNoLGNsKTtjMV9sbz1tYWo2NF9sbyhhaCxhbCxiaCxibCxjaCxjbCk7dmFyIFQyX2hpPXN1bTY0X2hpJDEoYzBfaGksYzBfbG8sYzFfaGksYzFfbG8pO3ZhciBUMl9sbz1zdW02NF9sbyQxKGMwX2hpLGMwX2xvLGMxX2hpLGMxX2xvKTtoaD1naDtobD1nbDtnaD1maDtnbD1mbDtmaD1laDtmbD1lbDtlaD1zdW02NF9oaSQxKGRoLGRsLFQxX2hpLFQxX2xvKTtlbD1zdW02NF9sbyQxKGRsLGRsLFQxX2hpLFQxX2xvKTtkaD1jaDtkbD1jbDtjaD1iaDtjbD1ibDtiaD1haDtibD1hbDthaD1zdW02NF9oaSQxKFQxX2hpLFQxX2xvLFQyX2hpLFQyX2xvKTthbD1zdW02NF9sbyQxKFQxX2hpLFQxX2xvLFQyX2hpLFQyX2xvKX1zdW02NCQxKHRoaXMuaCwwLGFoLGFsKTtzdW02NCQxKHRoaXMuaCwyLGJoLGJsKTtzdW02NCQxKHRoaXMuaCw0LGNoLGNsKTtzdW02NCQxKHRoaXMuaCw2LGRoLGRsKTtzdW02NCQxKHRoaXMuaCw4LGVoLGVsKTtzdW02NCQxKHRoaXMuaCwxMCxmaCxmbCk7c3VtNjQkMSh0aGlzLmgsMTIsZ2gsZ2wpO3N1bTY0JDEodGhpcy5oLDE0LGhoLGhsKX07U0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0PWZ1bmN0aW9uIGRpZ2VzdChlbmMpe2lmKGVuYz09PVwiaGV4XCIpcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLFwiYmlnXCIpO2Vsc2UgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLFwiYmlnXCIpfTtmdW5jdGlvbiBjaDY0X2hpKHhoLHhsLHloLHlsLHpoKXt2YXIgcj14aCZ5aF5+eGgmemg7aWYocjwwKXIrPTQyOTQ5NjcyOTY7cmV0dXJuIHJ9ZnVuY3Rpb24gY2g2NF9sbyh4aCx4bCx5aCx5bCx6aCx6bCl7dmFyIHI9eGwmeWxefnhsJnpsO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIG1hajY0X2hpKHhoLHhsLHloLHlsLHpoKXt2YXIgcj14aCZ5aF54aCZ6aF55aCZ6aDtpZihyPDApcis9NDI5NDk2NzI5NjtyZXR1cm4gcn1mdW5jdGlvbiBtYWo2NF9sbyh4aCx4bCx5aCx5bCx6aCx6bCl7dmFyIHI9eGwmeWxeeGwmemxeeWwmemw7aWYocjwwKXIrPTQyOTQ5NjcyOTY7cmV0dXJuIHJ9ZnVuY3Rpb24gczBfNTEyX2hpKHhoLHhsKXt2YXIgYzBfaGk9cm90cjY0X2hpJDEoeGgseGwsMjgpO3ZhciBjMV9oaT1yb3RyNjRfaGkkMSh4bCx4aCwyKTt2YXIgYzJfaGk9cm90cjY0X2hpJDEoeGwseGgsNyk7dmFyIHI9YzBfaGleYzFfaGleYzJfaGk7aWYocjwwKXIrPTQyOTQ5NjcyOTY7cmV0dXJuIHJ9ZnVuY3Rpb24gczBfNTEyX2xvKHhoLHhsKXt2YXIgYzBfbG89cm90cjY0X2xvJDEoeGgseGwsMjgpO3ZhciBjMV9sbz1yb3RyNjRfbG8kMSh4bCx4aCwyKTt2YXIgYzJfbG89cm90cjY0X2xvJDEoeGwseGgsNyk7dmFyIHI9YzBfbG9eYzFfbG9eYzJfbG87aWYocjwwKXIrPTQyOTQ5NjcyOTY7cmV0dXJuIHJ9ZnVuY3Rpb24gczFfNTEyX2hpKHhoLHhsKXt2YXIgYzBfaGk9cm90cjY0X2hpJDEoeGgseGwsMTQpO3ZhciBjMV9oaT1yb3RyNjRfaGkkMSh4aCx4bCwxOCk7dmFyIGMyX2hpPXJvdHI2NF9oaSQxKHhsLHhoLDkpO3ZhciByPWMwX2hpXmMxX2hpXmMyX2hpO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIHMxXzUxMl9sbyh4aCx4bCl7dmFyIGMwX2xvPXJvdHI2NF9sbyQxKHhoLHhsLDE0KTt2YXIgYzFfbG89cm90cjY0X2xvJDEoeGgseGwsMTgpO3ZhciBjMl9sbz1yb3RyNjRfbG8kMSh4bCx4aCw5KTt2YXIgcj1jMF9sb15jMV9sb15jMl9sbztpZihyPDApcis9NDI5NDk2NzI5NjtyZXR1cm4gcn1mdW5jdGlvbiBnMF81MTJfaGkoeGgseGwpe3ZhciBjMF9oaT1yb3RyNjRfaGkkMSh4aCx4bCwxKTt2YXIgYzFfaGk9cm90cjY0X2hpJDEoeGgseGwsOCk7dmFyIGMyX2hpPXNocjY0X2hpJDEoeGgseGwsNyk7dmFyIHI9YzBfaGleYzFfaGleYzJfaGk7aWYocjwwKXIrPTQyOTQ5NjcyOTY7cmV0dXJuIHJ9ZnVuY3Rpb24gZzBfNTEyX2xvKHhoLHhsKXt2YXIgYzBfbG89cm90cjY0X2xvJDEoeGgseGwsMSk7dmFyIGMxX2xvPXJvdHI2NF9sbyQxKHhoLHhsLDgpO3ZhciBjMl9sbz1zaHI2NF9sbyQxKHhoLHhsLDcpO3ZhciByPWMwX2xvXmMxX2xvXmMyX2xvO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIGcxXzUxMl9oaSh4aCx4bCl7dmFyIGMwX2hpPXJvdHI2NF9oaSQxKHhoLHhsLDE5KTt2YXIgYzFfaGk9cm90cjY0X2hpJDEoeGwseGgsMjkpO3ZhciBjMl9oaT1zaHI2NF9oaSQxKHhoLHhsLDYpO3ZhciByPWMwX2hpXmMxX2hpXmMyX2hpO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfWZ1bmN0aW9uIGcxXzUxMl9sbyh4aCx4bCl7dmFyIGMwX2xvPXJvdHI2NF9sbyQxKHhoLHhsLDE5KTt2YXIgYzFfbG89cm90cjY0X2xvJDEoeGwseGgsMjkpO3ZhciBjMl9sbz1zaHI2NF9sbyQxKHhoLHhsLDYpO3ZhciByPWMwX2xvXmMxX2xvXmMyX2xvO2lmKHI8MClyKz00Mjk0OTY3Mjk2O3JldHVybiByfVwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIFNIQTM4NCgpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNIQTM4NCkpcmV0dXJuIG5ldyBTSEEzODQ7XzUxMi5jYWxsKHRoaXMpO3RoaXMuaD1bMzQxODA3MDM2NSwzMjM4MzcxMDMyLDE2NTQyNzAyNTAsOTE0MTUwNjYzLDI0Mzg1MjkzNzAsODEyNzAyOTk5LDM1NTQ2MjM2MCw0MTQ0OTEyNjk3LDE3MzE0MDU0MTUsNDI5MDc3NTg1NywyMzk0MTgwMjMxLDE3NTA2MDMwMjUsMzY3NTAwODUyNSwxNjk0MDc2ODM5LDEyMDMwNjI4MTMsMzIwNDA3NTQyOF19dXRpbHMuaW5oZXJpdHMoU0hBMzg0LF81MTIpO3ZhciBfMzg0PVNIQTM4NDtTSEEzODQuYmxvY2tTaXplPTEwMjQ7U0hBMzg0Lm91dFNpemU9Mzg0O1NIQTM4NC5obWFjU3RyZW5ndGg9MTkyO1NIQTM4NC5wYWRMZW5ndGg9MTI4O1NIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLDEyKSxcImJpZ1wiKTtlbHNlIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLDEyKSxcImJpZ1wiKX07XCJ1c2Ugc3RyaWN0XCI7dmFyIHNoYTE9XzE7dmFyIHNoYTIyND1fMjI0O3ZhciBzaGEyNTY9XzI1Njt2YXIgc2hhMzg0PV8zODQ7dmFyIHNoYTUxMj1fNTEyO3ZhciBzaGE9e3NoYTE6c2hhMSxzaGEyMjQ6c2hhMjI0LHNoYTI1NjpzaGEyNTYsc2hhMzg0OnNoYTM4NCxzaGE1MTI6c2hhNTEyfTtcInVzZSBzdHJpY3RcIjt2YXIgcm90bDMyJDI9dXRpbHMucm90bDMyO3ZhciBzdW0zMiQzPXV0aWxzLnN1bTMyO3ZhciBzdW0zMl8zJDE9dXRpbHMuc3VtMzJfMzt2YXIgc3VtMzJfNCQyPXV0aWxzLnN1bTMyXzQ7dmFyIEJsb2NrSGFzaCQ0PWNvbW1vbi5CbG9ja0hhc2g7ZnVuY3Rpb24gUklQRU1EMTYwKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlyZXR1cm4gbmV3IFJJUEVNRDE2MDtCbG9ja0hhc2gkNC5jYWxsKHRoaXMpO3RoaXMuaD1bMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdO3RoaXMuZW5kaWFuPVwibGl0dGxlXCJ9dXRpbHMuaW5oZXJpdHMoUklQRU1EMTYwLEJsb2NrSGFzaCQ0KTt2YXIgcmlwZW1kMTYwPVJJUEVNRDE2MDtSSVBFTUQxNjAuYmxvY2tTaXplPTUxMjtSSVBFTUQxNjAub3V0U2l6ZT0xNjA7UklQRU1EMTYwLmhtYWNTdHJlbmd0aD0xOTI7UklQRU1EMTYwLnBhZExlbmd0aD02NDtSSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24gdXBkYXRlKG1zZyxzdGFydCl7dmFyIEE9dGhpcy5oWzBdO3ZhciBCPXRoaXMuaFsxXTt2YXIgQz10aGlzLmhbMl07dmFyIEQ9dGhpcy5oWzNdO3ZhciBFPXRoaXMuaFs0XTt2YXIgQWg9QTt2YXIgQmg9Qjt2YXIgQ2g9Qzt2YXIgRGg9RDt2YXIgRWg9RTtmb3IodmFyIGo9MDtqPDgwO2orKyl7dmFyIFQ9c3VtMzIkMyhyb3RsMzIkMihzdW0zMl80JDIoQSxmKGosQixDLEQpLG1zZ1tyW2pdK3N0YXJ0XSxLKGopKSxzW2pdKSxFKTtBPUU7RT1EO0Q9cm90bDMyJDIoQywxMCk7Qz1CO0I9VDtUPXN1bTMyJDMocm90bDMyJDIoc3VtMzJfNCQyKEFoLGYoNzktaixCaCxDaCxEaCksbXNnW3JoW2pdK3N0YXJ0XSxLaChqKSksc2hbal0pLEVoKTtBaD1FaDtFaD1EaDtEaD1yb3RsMzIkMihDaCwxMCk7Q2g9Qmg7Qmg9VH1UPXN1bTMyXzMkMSh0aGlzLmhbMV0sQyxEaCk7dGhpcy5oWzFdPXN1bTMyXzMkMSh0aGlzLmhbMl0sRCxFaCk7dGhpcy5oWzJdPXN1bTMyXzMkMSh0aGlzLmhbM10sRSxBaCk7dGhpcy5oWzNdPXN1bTMyXzMkMSh0aGlzLmhbNF0sQSxCaCk7dGhpcy5oWzRdPXN1bTMyXzMkMSh0aGlzLmhbMF0sQixDaCk7dGhpcy5oWzBdPVR9O1JJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCxcImxpdHRsZVwiKTtlbHNlIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCxcImxpdHRsZVwiKX07ZnVuY3Rpb24gZihqLHgseSx6KXtpZihqPD0xNSlyZXR1cm4geF55Xno7ZWxzZSBpZihqPD0zMSlyZXR1cm4geCZ5fH54Jno7ZWxzZSBpZihqPD00NylyZXR1cm4oeHx+eSleejtlbHNlIGlmKGo8PTYzKXJldHVybiB4Jnp8eSZ+ejtlbHNlIHJldHVybiB4Xih5fH56KX1mdW5jdGlvbiBLKGope2lmKGo8PTE1KXJldHVybiAwO2Vsc2UgaWYoajw9MzEpcmV0dXJuIDE1MTg1MDAyNDk7ZWxzZSBpZihqPD00NylyZXR1cm4gMTg1OTc3NTM5MztlbHNlIGlmKGo8PTYzKXJldHVybiAyNDAwOTU5NzA4O2Vsc2UgcmV0dXJuIDI4NDA4NTM4Mzh9ZnVuY3Rpb24gS2goail7aWYoajw9MTUpcmV0dXJuIDEzNTI4Mjk5MjY7ZWxzZSBpZihqPD0zMSlyZXR1cm4gMTU0ODYwMzY4NDtlbHNlIGlmKGo8PTQ3KXJldHVybiAxODM2MDcyNjkxO2Vsc2UgaWYoajw9NjMpcmV0dXJuIDIwNTM5OTQyMTc7ZWxzZSByZXR1cm4gMH12YXIgcj1bMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSw3LDQsMTMsMSwxMCw2LDE1LDMsMTIsMCw5LDUsMiwxNCwxMSw4LDMsMTAsMTQsNCw5LDE1LDgsMSwyLDcsMCw2LDEzLDExLDUsMTIsMSw5LDExLDEwLDAsOCwxMiw0LDEzLDMsNywxNSwxNCw1LDYsMiw0LDAsNSw5LDcsMTIsMiwxMCwxNCwxLDMsOCwxMSw2LDE1LDEzXTt2YXIgcmg9WzUsMTQsNywwLDksMiwxMSw0LDEzLDYsMTUsOCwxLDEwLDMsMTIsNiwxMSwzLDcsMCwxMyw1LDEwLDE0LDE1LDgsMTIsNCw5LDEsMiwxNSw1LDEsMyw3LDE0LDYsOSwxMSw4LDEyLDIsMTAsMCw0LDEzLDgsNiw0LDEsMywxMSwxNSwwLDUsMTIsMiwxMyw5LDcsMTAsMTQsMTIsMTUsMTAsNCwxLDUsOCw3LDYsMiwxMywxNCwwLDMsOSwxMV07dmFyIHM9WzExLDE0LDE1LDEyLDUsOCw3LDksMTEsMTMsMTQsMTUsNiw3LDksOCw3LDYsOCwxMywxMSw5LDcsMTUsNywxMiwxNSw5LDExLDcsMTMsMTIsMTEsMTMsNiw3LDE0LDksMTMsMTUsMTQsOCwxMyw2LDUsMTIsNyw1LDExLDEyLDE0LDE1LDE0LDE1LDksOCw5LDE0LDUsNiw4LDYsNSwxMiw5LDE1LDUsMTEsNiw4LDEzLDEyLDUsMTIsMTMsMTQsMTEsOCw1LDZdO3ZhciBzaD1bOCw5LDksMTEsMTMsMTUsMTUsNSw3LDcsOCwxMSwxNCwxNCwxMiw2LDksMTMsMTUsNywxMiw4LDksMTEsNyw3LDEyLDcsNiwxNSwxMywxMSw5LDcsMTUsMTEsOCw2LDYsMTQsMTIsMTMsNSwxNCwxMywxMyw3LDUsMTUsNSw4LDExLDE0LDE0LDYsMTQsNiw5LDEyLDksMTIsNSwxNSw4LDgsNSwxMiw5LDEyLDUsMTQsNiw4LDEzLDYsNSwxNSwxMywxMSwxMV07dmFyIHJpcGVtZD17cmlwZW1kMTYwOnJpcGVtZDE2MH07XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gSG1hYyhoYXNoLGtleSxlbmMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEhtYWMpKXJldHVybiBuZXcgSG1hYyhoYXNoLGtleSxlbmMpO3RoaXMuSGFzaD1oYXNoO3RoaXMuYmxvY2tTaXplPWhhc2guYmxvY2tTaXplLzg7dGhpcy5vdXRTaXplPWhhc2gub3V0U2l6ZS84O3RoaXMuaW5uZXI9bnVsbDt0aGlzLm91dGVyPW51bGw7dGhpcy5faW5pdCh1dGlscy50b0FycmF5KGtleSxlbmMpKX12YXIgaG1hYz1IbWFjO0htYWMucHJvdG90eXBlLl9pbml0PWZ1bmN0aW9uIGluaXQoa2V5KXtpZihrZXkubGVuZ3RoPnRoaXMuYmxvY2tTaXplKWtleT0obmV3IHRoaXMuSGFzaCkudXBkYXRlKGtleSkuZGlnZXN0KCk7bWluaW1hbGlzdGljQXNzZXJ0KGtleS5sZW5ndGg8PXRoaXMuYmxvY2tTaXplKTtmb3IodmFyIGk9a2V5Lmxlbmd0aDtpPHRoaXMuYmxvY2tTaXplO2krKylrZXkucHVzaCgwKTtmb3IoaT0wO2k8a2V5Lmxlbmd0aDtpKyspa2V5W2ldXj01NDt0aGlzLmlubmVyPShuZXcgdGhpcy5IYXNoKS51cGRhdGUoa2V5KTtmb3IoaT0wO2k8a2V5Lmxlbmd0aDtpKyspa2V5W2ldXj0xMDY7dGhpcy5vdXRlcj0obmV3IHRoaXMuSGFzaCkudXBkYXRlKGtleSl9O0htYWMucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbiB1cGRhdGUobXNnLGVuYyl7dGhpcy5pbm5lci51cGRhdGUobXNnLGVuYyk7cmV0dXJuIHRoaXN9O0htYWMucHJvdG90eXBlLmRpZ2VzdD1mdW5jdGlvbiBkaWdlc3QoZW5jKXt0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtyZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKX07dmFyIGhhc2hfMT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7dmFyIGhhc2g9ZXhwb3J0cztoYXNoLnV0aWxzPXV0aWxzO2hhc2guY29tbW9uPWNvbW1vbjtoYXNoLnNoYT1zaGE7aGFzaC5yaXBlbWQ9cmlwZW1kO2hhc2guaG1hYz1obWFjO2hhc2guc2hhMT1oYXNoLnNoYS5zaGExO2hhc2guc2hhMjU2PWhhc2guc2hhLnNoYTI1NjtoYXNoLnNoYTIyND1oYXNoLnNoYS5zaGEyMjQ7aGFzaC5zaGEzODQ9aGFzaC5zaGEuc2hhMzg0O2hhc2guc2hhNTEyPWhhc2guc2hhLnNoYTUxMjtoYXNoLnJpcGVtZDE2MD1oYXNoLnJpcGVtZC5yaXBlbWQxNjB9KTt2YXIgY29tbW9uanNHbG9iYWwkMT10eXBlb2YgZ2xvYmFsVGhpcyE9PVwidW5kZWZpbmVkXCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6dHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnt9O2Z1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEoeCl7cmV0dXJuIHgmJnguX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsXCJkZWZhdWx0XCIpP3hbXCJkZWZhdWx0XCJdOnh9ZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUkMShmbixiYXNlZGlyLG1vZHVsZSl7cmV0dXJuIG1vZHVsZT17cGF0aDpiYXNlZGlyLGV4cG9ydHM6e30scmVxdWlyZTpmdW5jdGlvbihwYXRoLGJhc2Upe3JldHVybiBjb21tb25qc1JlcXVpcmUkMShwYXRoLGJhc2U9PT11bmRlZmluZWR8fGJhc2U9PT1udWxsP21vZHVsZS5wYXRoOmJhc2UpfX0sZm4obW9kdWxlLG1vZHVsZS5leHBvcnRzKSxtb2R1bGUuZXhwb3J0c31mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmUHJlc2VudCQxKG4pe3JldHVybiBuJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixcImRlZmF1bHRcIik/bltcImRlZmF1bHRcIl06bn1mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmTm90TmFtZWQkMShuKXtyZXR1cm4gbiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJkZWZhdWx0XCIpJiZPYmplY3Qua2V5cyhuKS5sZW5ndGg9PT0xP25bXCJkZWZhdWx0XCJdOm59ZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlJDEobil7aWYobi5fX2VzTW9kdWxlKXJldHVybiBuO3ZhciBhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO09iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24oayl7dmFyIGQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLGspO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGssZC5nZXQ/ZDp7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2tdfX0pfSk7cmV0dXJuIGF9ZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlJDEoKXt0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qc1wiKX12YXIgbWluaW1hbGlzdGljQXNzZXJ0JDE9YXNzZXJ0JDE7ZnVuY3Rpb24gYXNzZXJ0JDEodmFsLG1zZyl7aWYoIXZhbCl0aHJvdyBuZXcgRXJyb3IobXNnfHxcIkFzc2VydGlvbiBmYWlsZWRcIil9YXNzZXJ0JDEuZXF1YWw9ZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCxyLG1zZyl7aWYobCE9cil0aHJvdyBuZXcgRXJyb3IobXNnfHxcIkFzc2VydGlvbiBmYWlsZWQ6IFwiK2wrXCIgIT0gXCIrcil9O3ZhciB1dGlsc18xPWNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciB1dGlscz1leHBvcnRzO2Z1bmN0aW9uIHRvQXJyYXkobXNnLGVuYyl7aWYoQXJyYXkuaXNBcnJheShtc2cpKXJldHVybiBtc2cuc2xpY2UoKTtpZighbXNnKXJldHVybltdO3ZhciByZXM9W107aWYodHlwZW9mIG1zZyE9PVwic3RyaW5nXCIpe2Zvcih2YXIgaT0wO2k8bXNnLmxlbmd0aDtpKyspcmVzW2ldPW1zZ1tpXXwwO3JldHVybiByZXN9aWYoZW5jPT09XCJoZXhcIil7bXNnPW1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2dpLFwiXCIpO2lmKG1zZy5sZW5ndGglMiE9PTApbXNnPVwiMFwiK21zZztmb3IodmFyIGk9MDtpPG1zZy5sZW5ndGg7aSs9MilyZXMucHVzaChwYXJzZUludChtc2dbaV0rbXNnW2krMV0sMTYpKX1lbHNle2Zvcih2YXIgaT0wO2k8bXNnLmxlbmd0aDtpKyspe3ZhciBjPW1zZy5jaGFyQ29kZUF0KGkpO3ZhciBoaT1jPj44O3ZhciBsbz1jJjI1NTtpZihoaSlyZXMucHVzaChoaSxsbyk7ZWxzZSByZXMucHVzaChsbyl9fXJldHVybiByZXN9dXRpbHMudG9BcnJheT10b0FycmF5O2Z1bmN0aW9uIHplcm8yKHdvcmQpe2lmKHdvcmQubGVuZ3RoPT09MSlyZXR1cm5cIjBcIit3b3JkO2Vsc2UgcmV0dXJuIHdvcmR9dXRpbHMuemVybzI9emVybzI7ZnVuY3Rpb24gdG9IZXgobXNnKXt2YXIgcmVzPVwiXCI7Zm9yKHZhciBpPTA7aTxtc2cubGVuZ3RoO2krKylyZXMrPXplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO3JldHVybiByZXN9dXRpbHMudG9IZXg9dG9IZXg7dXRpbHMuZW5jb2RlPWZ1bmN0aW9uIGVuY29kZShhcnIsZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB0b0hleChhcnIpO2Vsc2UgcmV0dXJuIGFycn19KTt2YXIgdXRpbHNfMSQxPWNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciB1dGlscz1leHBvcnRzO3V0aWxzLmFzc2VydD1taW5pbWFsaXN0aWNBc3NlcnQkMTt1dGlscy50b0FycmF5PXV0aWxzXzEudG9BcnJheTt1dGlscy56ZXJvMj11dGlsc18xLnplcm8yO3V0aWxzLnRvSGV4PXV0aWxzXzEudG9IZXg7dXRpbHMuZW5jb2RlPXV0aWxzXzEuZW5jb2RlO2Z1bmN0aW9uIGdldE5BRihudW0sdyxiaXRzKXt2YXIgbmFmPW5ldyBBcnJheShNYXRoLm1heChudW0uYml0TGVuZ3RoKCksYml0cykrMSk7bmFmLmZpbGwoMCk7dmFyIHdzPTE8PHcrMTt2YXIgaz1udW0uY2xvbmUoKTtmb3IodmFyIGk9MDtpPG5hZi5sZW5ndGg7aSsrKXt2YXIgejt2YXIgbW9kPWsuYW5kbG4od3MtMSk7aWYoay5pc09kZCgpKXtpZihtb2Q+KHdzPj4xKS0xKXo9KHdzPj4xKS1tb2Q7ZWxzZSB6PW1vZDtrLmlzdWJuKHopfWVsc2V7ej0wfW5hZltpXT16O2suaXVzaHJuKDEpfXJldHVybiBuYWZ9dXRpbHMuZ2V0TkFGPWdldE5BRjtmdW5jdGlvbiBnZXRKU0YoazEsazIpe3ZhciBqc2Y9W1tdLFtdXTtrMT1rMS5jbG9uZSgpO2syPWsyLmNsb25lKCk7dmFyIGQxPTA7dmFyIGQyPTA7dmFyIG04O3doaWxlKGsxLmNtcG4oLWQxKT4wfHxrMi5jbXBuKC1kMik+MCl7dmFyIG0xND1rMS5hbmRsbigzKStkMSYzO3ZhciBtMjQ9azIuYW5kbG4oMykrZDImMztpZihtMTQ9PT0zKW0xND0tMTtpZihtMjQ9PT0zKW0yND0tMTt2YXIgdTE7aWYoKG0xNCYxKT09PTApe3UxPTB9ZWxzZXttOD1rMS5hbmRsbig3KStkMSY3O2lmKChtOD09PTN8fG04PT09NSkmJm0yND09PTIpdTE9LW0xNDtlbHNlIHUxPW0xNH1qc2ZbMF0ucHVzaCh1MSk7dmFyIHUyO2lmKChtMjQmMSk9PT0wKXt1Mj0wfWVsc2V7bTg9azIuYW5kbG4oNykrZDImNztpZigobTg9PT0zfHxtOD09PTUpJiZtMTQ9PT0yKXUyPS1tMjQ7ZWxzZSB1Mj1tMjR9anNmWzFdLnB1c2godTIpO2lmKDIqZDE9PT11MSsxKWQxPTEtZDE7aWYoMipkMj09PXUyKzEpZDI9MS1kMjtrMS5pdXNocm4oMSk7azIuaXVzaHJuKDEpfXJldHVybiBqc2Z9dXRpbHMuZ2V0SlNGPWdldEpTRjtmdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosbmFtZSxjb21wdXRlcil7dmFyIGtleT1cIl9cIituYW1lO29iai5wcm90b3R5cGVbbmFtZV09ZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKXtyZXR1cm4gdGhpc1trZXldIT09dW5kZWZpbmVkP3RoaXNba2V5XTp0aGlzW2tleV09Y29tcHV0ZXIuY2FsbCh0aGlzKX19dXRpbHMuY2FjaGVkUHJvcGVydHk9Y2FjaGVkUHJvcGVydHk7ZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcyl7cmV0dXJuIHR5cGVvZiBieXRlcz09PVwic3RyaW5nXCI/dXRpbHMudG9BcnJheShieXRlcyxcImhleFwiKTpieXRlc311dGlscy5wYXJzZUJ5dGVzPXBhcnNlQnl0ZXM7ZnVuY3Rpb24gaW50RnJvbUxFKGJ5dGVzKXtyZXR1cm4gbmV3IGJuKGJ5dGVzLFwiaGV4XCIsXCJsZVwiKX11dGlscy5pbnRGcm9tTEU9aW50RnJvbUxFfSk7XCJ1c2Ugc3RyaWN0XCI7dmFyIGdldE5BRj11dGlsc18xJDEuZ2V0TkFGO3ZhciBnZXRKU0Y9dXRpbHNfMSQxLmdldEpTRjt2YXIgYXNzZXJ0JDEkMT11dGlsc18xJDEuYXNzZXJ0O2Z1bmN0aW9uIEJhc2VDdXJ2ZSh0eXBlLGNvbmYpe3RoaXMudHlwZT10eXBlO3RoaXMucD1uZXcgYm4oY29uZi5wLDE2KTt0aGlzLnJlZD1jb25mLnByaW1lP2JuLnJlZChjb25mLnByaW1lKTpibi5tb250KHRoaXMucCk7dGhpcy56ZXJvPW5ldyBibigwKS50b1JlZCh0aGlzLnJlZCk7dGhpcy5vbmU9bmV3IGJuKDEpLnRvUmVkKHRoaXMucmVkKTt0aGlzLnR3bz1uZXcgYm4oMikudG9SZWQodGhpcy5yZWQpO3RoaXMubj1jb25mLm4mJm5ldyBibihjb25mLm4sMTYpO3RoaXMuZz1jb25mLmcmJnRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsY29uZi5nUmVkKTt0aGlzLl93bmFmVDE9bmV3IEFycmF5KDQpO3RoaXMuX3duYWZUMj1uZXcgQXJyYXkoNCk7dGhpcy5fd25hZlQzPW5ldyBBcnJheSg0KTt0aGlzLl93bmFmVDQ9bmV3IEFycmF5KDQpO3RoaXMuX2JpdExlbmd0aD10aGlzLm4/dGhpcy5uLmJpdExlbmd0aCgpOjA7dmFyIGFkanVzdENvdW50PXRoaXMubiYmdGhpcy5wLmRpdih0aGlzLm4pO2lmKCFhZGp1c3RDb3VudHx8YWRqdXN0Q291bnQuY21wbigxMDApPjApe3RoaXMucmVkTj1udWxsfWVsc2V7dGhpcy5fbWF4d2VsbFRyaWNrPXRydWU7dGhpcy5yZWROPXRoaXMubi50b1JlZCh0aGlzLnJlZCl9fXZhciBiYXNlPUJhc2VDdXJ2ZTtCYXNlQ3VydmUucHJvdG90eXBlLnBvaW50PWZ1bmN0aW9uIHBvaW50KCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpfTtCYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uIHZhbGlkYXRlKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpfTtCYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bD1mdW5jdGlvbiBfZml4ZWROYWZNdWwocCxrKXthc3NlcnQkMSQxKHAucHJlY29tcHV0ZWQpO3ZhciBkb3VibGVzPXAuX2dldERvdWJsZXMoKTt2YXIgbmFmPWdldE5BRihrLDEsdGhpcy5fYml0TGVuZ3RoKTt2YXIgST0oMTw8ZG91Ymxlcy5zdGVwKzEpLShkb3VibGVzLnN0ZXAlMj09PTA/MjoxKTtJLz0zO3ZhciByZXByPVtdO3ZhciBqO3ZhciBuYWZXO2ZvcihqPTA7ajxuYWYubGVuZ3RoO2orPWRvdWJsZXMuc3RlcCl7bmFmVz0wO2Zvcih2YXIgbD1qK2RvdWJsZXMuc3RlcC0xO2w+PWo7bC0tKW5hZlc9KG5hZlc8PDEpK25hZltsXTtyZXByLnB1c2gobmFmVyl9dmFyIGE9dGhpcy5qcG9pbnQobnVsbCxudWxsLG51bGwpO3ZhciBiPXRoaXMuanBvaW50KG51bGwsbnVsbCxudWxsKTtmb3IodmFyIGk9STtpPjA7aS0tKXtmb3Ioaj0wO2o8cmVwci5sZW5ndGg7aisrKXtuYWZXPXJlcHJbal07aWYobmFmVz09PWkpYj1iLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtlbHNlIGlmKG5hZlc9PT0taSliPWIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpfWE9YS5hZGQoYil9cmV0dXJuIGEudG9QKCl9O0Jhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWw9ZnVuY3Rpb24gX3duYWZNdWwocCxrKXt2YXIgdz00O3ZhciBuYWZQb2ludHM9cC5fZ2V0TkFGUG9pbnRzKHcpO3c9bmFmUG9pbnRzLnduZDt2YXIgd25kPW5hZlBvaW50cy5wb2ludHM7dmFyIG5hZj1nZXROQUYoayx3LHRoaXMuX2JpdExlbmd0aCk7dmFyIGFjYz10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCk7Zm9yKHZhciBpPW5hZi5sZW5ndGgtMTtpPj0wO2ktLSl7Zm9yKHZhciBsPTA7aT49MCYmbmFmW2ldPT09MDtpLS0pbCsrO2lmKGk+PTApbCsrO2FjYz1hY2MuZGJscChsKTtpZihpPDApYnJlYWs7dmFyIHo9bmFmW2ldO2Fzc2VydCQxJDEoeiE9PTApO2lmKHAudHlwZT09PVwiYWZmaW5lXCIpe2lmKHo+MClhY2M9YWNjLm1peGVkQWRkKHduZFt6LTE+PjFdKTtlbHNlIGFjYz1hY2MubWl4ZWRBZGQod25kWy16LTE+PjFdLm5lZygpKX1lbHNle2lmKHo+MClhY2M9YWNjLmFkZCh3bmRbei0xPj4xXSk7ZWxzZSBhY2M9YWNjLmFkZCh3bmRbLXotMT4+MV0ubmVnKCkpfX1yZXR1cm4gcC50eXBlPT09XCJhZmZpbmVcIj9hY2MudG9QKCk6YWNjfTtCYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkPWZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcscG9pbnRzLGNvZWZmcyxsZW4samFjb2JpYW5SZXN1bHQpe3ZhciB3bmRXaWR0aD10aGlzLl93bmFmVDE7dmFyIHduZD10aGlzLl93bmFmVDI7dmFyIG5hZj10aGlzLl93bmFmVDM7dmFyIG1heD0wO3ZhciBpO3ZhciBqO3ZhciBwO2ZvcihpPTA7aTxsZW47aSsrKXtwPXBvaW50c1tpXTt2YXIgbmFmUG9pbnRzPXAuX2dldE5BRlBvaW50cyhkZWZXKTt3bmRXaWR0aFtpXT1uYWZQb2ludHMud25kO3duZFtpXT1uYWZQb2ludHMucG9pbnRzfWZvcihpPWxlbi0xO2k+PTE7aS09Mil7dmFyIGE9aS0xO3ZhciBiPWk7aWYod25kV2lkdGhbYV0hPT0xfHx3bmRXaWR0aFtiXSE9PTEpe25hZlthXT1nZXROQUYoY29lZmZzW2FdLHduZFdpZHRoW2FdLHRoaXMuX2JpdExlbmd0aCk7bmFmW2JdPWdldE5BRihjb2VmZnNbYl0sd25kV2lkdGhbYl0sdGhpcy5fYml0TGVuZ3RoKTttYXg9TWF0aC5tYXgobmFmW2FdLmxlbmd0aCxtYXgpO21heD1NYXRoLm1heChuYWZbYl0ubGVuZ3RoLG1heCk7Y29udGludWV9dmFyIGNvbWI9W3BvaW50c1thXSxudWxsLG51bGwscG9pbnRzW2JdXTtpZihwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpPT09MCl7Y29tYlsxXT1wb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7Y29tYlsyXT1wb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKX1lbHNlIGlmKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSk9PT0wKXtjb21iWzFdPXBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO2NvbWJbMl09cG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpfWVsc2V7Y29tYlsxXT1wb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtjb21iWzJdPXBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpfXZhciBpbmRleD1bLTMsLTEsLTUsLTcsMCw3LDUsMSwzXTt2YXIganNmPWdldEpTRihjb2VmZnNbYV0sY29lZmZzW2JdKTttYXg9TWF0aC5tYXgoanNmWzBdLmxlbmd0aCxtYXgpO25hZlthXT1uZXcgQXJyYXkobWF4KTtuYWZbYl09bmV3IEFycmF5KG1heCk7Zm9yKGo9MDtqPG1heDtqKyspe3ZhciBqYT1qc2ZbMF1bal18MDt2YXIgamI9anNmWzFdW2pdfDA7bmFmW2FdW2pdPWluZGV4WyhqYSsxKSozKyhqYisxKV07bmFmW2JdW2pdPTA7d25kW2FdPWNvbWJ9fXZhciBhY2M9dGhpcy5qcG9pbnQobnVsbCxudWxsLG51bGwpO3ZhciB0bXA9dGhpcy5fd25hZlQ0O2ZvcihpPW1heDtpPj0wO2ktLSl7dmFyIGs9MDt3aGlsZShpPj0wKXt2YXIgemVybz10cnVlO2ZvcihqPTA7ajxsZW47aisrKXt0bXBbal09bmFmW2pdW2ldfDA7aWYodG1wW2pdIT09MCl6ZXJvPWZhbHNlfWlmKCF6ZXJvKWJyZWFrO2srKztpLS19aWYoaT49MClrKys7YWNjPWFjYy5kYmxwKGspO2lmKGk8MClicmVhaztmb3Ioaj0wO2o8bGVuO2orKyl7dmFyIHo9dG1wW2pdO3A7aWYoej09PTApY29udGludWU7ZWxzZSBpZih6PjApcD13bmRbal1bei0xPj4xXTtlbHNlIGlmKHo8MClwPXduZFtqXVstei0xPj4xXS5uZWcoKTtpZihwLnR5cGU9PT1cImFmZmluZVwiKWFjYz1hY2MubWl4ZWRBZGQocCk7ZWxzZSBhY2M9YWNjLmFkZChwKX19Zm9yKGk9MDtpPGxlbjtpKyspd25kW2ldPW51bGw7aWYoamFjb2JpYW5SZXN1bHQpcmV0dXJuIGFjYztlbHNlIHJldHVybiBhY2MudG9QKCl9O2Z1bmN0aW9uIEJhc2VQb2ludChjdXJ2ZSx0eXBlKXt0aGlzLmN1cnZlPWN1cnZlO3RoaXMudHlwZT10eXBlO3RoaXMucHJlY29tcHV0ZWQ9bnVsbH1CYXNlQ3VydmUuQmFzZVBvaW50PUJhc2VQb2ludDtCYXNlUG9pbnQucHJvdG90eXBlLmVxPWZ1bmN0aW9uIGVxKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpfTtCYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uIHZhbGlkYXRlKCl7cmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyl9O0Jhc2VDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQ9ZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsZW5jKXtieXRlcz11dGlsc18xJDEudG9BcnJheShieXRlcyxlbmMpO3ZhciBsZW49dGhpcy5wLmJ5dGVMZW5ndGgoKTtpZigoYnl0ZXNbMF09PT00fHxieXRlc1swXT09PTZ8fGJ5dGVzWzBdPT09NykmJmJ5dGVzLmxlbmd0aC0xPT09MipsZW4pe2lmKGJ5dGVzWzBdPT09Nilhc3NlcnQkMSQxKGJ5dGVzW2J5dGVzLmxlbmd0aC0xXSUyPT09MCk7ZWxzZSBpZihieXRlc1swXT09PTcpYXNzZXJ0JDEkMShieXRlc1tieXRlcy5sZW5ndGgtMV0lMj09PTEpO3ZhciByZXM9dGhpcy5wb2ludChieXRlcy5zbGljZSgxLDErbGVuKSxieXRlcy5zbGljZSgxK2xlbiwxKzIqbGVuKSk7cmV0dXJuIHJlc31lbHNlIGlmKChieXRlc1swXT09PTJ8fGJ5dGVzWzBdPT09MykmJmJ5dGVzLmxlbmd0aC0xPT09bGVuKXtyZXR1cm4gdGhpcy5wb2ludEZyb21YKGJ5dGVzLnNsaWNlKDEsMStsZW4pLGJ5dGVzWzBdPT09Myl9dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb2ludCBmb3JtYXRcIil9O0Jhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZD1mdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYyl7cmV0dXJuIHRoaXMuZW5jb2RlKGVuYyx0cnVlKX07QmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlPWZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCl7dmFyIGxlbj10aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO3ZhciB4PXRoaXMuZ2V0WCgpLnRvQXJyYXkoXCJiZVwiLGxlbik7aWYoY29tcGFjdClyZXR1cm5bdGhpcy5nZXRZKCkuaXNFdmVuKCk/MjozXS5jb25jYXQoeCk7cmV0dXJuWzRdLmNvbmNhdCh4LHRoaXMuZ2V0WSgpLnRvQXJyYXkoXCJiZVwiLGxlbikpfTtCYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbiBlbmNvZGUoZW5jLGNvbXBhY3Qpe3JldHVybiB1dGlsc18xJDEuZW5jb2RlKHRoaXMuX2VuY29kZShjb21wYWN0KSxlbmMpfTtCYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGU9ZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcil7aWYodGhpcy5wcmVjb21wdXRlZClyZXR1cm4gdGhpczt2YXIgcHJlY29tcHV0ZWQ9e2RvdWJsZXM6bnVsbCxuYWY6bnVsbCxiZXRhOm51bGx9O3ByZWNvbXB1dGVkLm5hZj10aGlzLl9nZXROQUZQb2ludHMoOCk7cHJlY29tcHV0ZWQuZG91Ymxlcz10aGlzLl9nZXREb3VibGVzKDQscG93ZXIpO3ByZWNvbXB1dGVkLmJldGE9dGhpcy5fZ2V0QmV0YSgpO3RoaXMucHJlY29tcHV0ZWQ9cHJlY29tcHV0ZWQ7cmV0dXJuIHRoaXN9O0Jhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXM9ZnVuY3Rpb24gX2hhc0RvdWJsZXMoayl7aWYoIXRoaXMucHJlY29tcHV0ZWQpcmV0dXJuIGZhbHNlO3ZhciBkb3VibGVzPXRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztpZighZG91YmxlcylyZXR1cm4gZmFsc2U7cmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aD49TWF0aC5jZWlsKChrLmJpdExlbmd0aCgpKzEpL2RvdWJsZXMuc3RlcCl9O0Jhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXM9ZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCxwb3dlcil7aWYodGhpcy5wcmVjb21wdXRlZCYmdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKXJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7dmFyIGRvdWJsZXM9W3RoaXNdO3ZhciBhY2M9dGhpcztmb3IodmFyIGk9MDtpPHBvd2VyO2krPXN0ZXApe2Zvcih2YXIgaj0wO2o8c3RlcDtqKyspYWNjPWFjYy5kYmwoKTtkb3VibGVzLnB1c2goYWNjKX1yZXR1cm57c3RlcDpzdGVwLHBvaW50czpkb3VibGVzfX07QmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzPWZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKXtpZih0aGlzLnByZWNvbXB1dGVkJiZ0aGlzLnByZWNvbXB1dGVkLm5hZilyZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7dmFyIHJlcz1bdGhpc107dmFyIG1heD0oMTw8d25kKS0xO3ZhciBkYmw9bWF4PT09MT9udWxsOnRoaXMuZGJsKCk7Zm9yKHZhciBpPTE7aTxtYXg7aSsrKXJlc1tpXT1yZXNbaS0xXS5hZGQoZGJsKTtyZXR1cm57d25kOnduZCxwb2ludHM6cmVzfX07QmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YT1mdW5jdGlvbiBfZ2V0QmV0YSgpe3JldHVybiBudWxsfTtCYXNlUG9pbnQucHJvdG90eXBlLmRibHA9ZnVuY3Rpb24gZGJscChrKXt2YXIgcj10aGlzO2Zvcih2YXIgaT0wO2k8aztpKyspcj1yLmRibCgpO3JldHVybiByfTt2YXIgaW5oZXJpdHNfYnJvd3NlciQxPWNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24obW9kdWxlKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMoY3RvcixzdXBlckN0b3Ipe2lmKHN1cGVyQ3Rvcil7Y3Rvci5zdXBlcl89c3VwZXJDdG9yO2N0b3IucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmN0b3IsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfX0pfX19ZWxzZXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhjdG9yLHN1cGVyQ3Rvcil7aWYoc3VwZXJDdG9yKXtjdG9yLnN1cGVyXz1zdXBlckN0b3I7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9c3VwZXJDdG9yLnByb3RvdHlwZTtjdG9yLnByb3RvdHlwZT1uZXcgVGVtcEN0b3I7Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3I9Y3Rvcn19fX0pO1widXNlIHN0cmljdFwiO3ZhciBhc3NlcnQkMj11dGlsc18xJDEuYXNzZXJ0O2Z1bmN0aW9uIFNob3J0Q3VydmUoY29uZil7YmFzZS5jYWxsKHRoaXMsXCJzaG9ydFwiLGNvbmYpO3RoaXMuYT1uZXcgYm4oY29uZi5hLDE2KS50b1JlZCh0aGlzLnJlZCk7dGhpcy5iPW5ldyBibihjb25mLmIsMTYpLnRvUmVkKHRoaXMucmVkKTt0aGlzLnRpbnY9dGhpcy50d28ucmVkSW52bSgpO3RoaXMuemVyb0E9dGhpcy5hLmZyb21SZWQoKS5jbXBuKDApPT09MDt0aGlzLnRocmVlQT10aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpPT09MDt0aGlzLmVuZG89dGhpcy5fZ2V0RW5kb21vcnBoaXNtKGNvbmYpO3RoaXMuX2VuZG9XbmFmVDE9bmV3IEFycmF5KDQpO3RoaXMuX2VuZG9XbmFmVDI9bmV3IEFycmF5KDQpfWluaGVyaXRzX2Jyb3dzZXIkMShTaG9ydEN1cnZlLGJhc2UpO3ZhciBzaG9ydF8xPVNob3J0Q3VydmU7U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9tb3JwaGlzbT1mdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpe2lmKCF0aGlzLnplcm9BfHwhdGhpcy5nfHwhdGhpcy5ufHx0aGlzLnAubW9kbigzKSE9PTEpcmV0dXJuO3ZhciBiZXRhO3ZhciBsYW1iZGE7aWYoY29uZi5iZXRhKXtiZXRhPW5ldyBibihjb25mLmJldGEsMTYpLnRvUmVkKHRoaXMucmVkKX1lbHNle3ZhciBiZXRhcz10aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtiZXRhPWJldGFzWzBdLmNtcChiZXRhc1sxXSk8MD9iZXRhc1swXTpiZXRhc1sxXTtiZXRhPWJldGEudG9SZWQodGhpcy5yZWQpfWlmKGNvbmYubGFtYmRhKXtsYW1iZGE9bmV3IGJuKGNvbmYubGFtYmRhLDE2KX1lbHNle3ZhciBsYW1iZGFzPXRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO2lmKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKT09PTApe2xhbWJkYT1sYW1iZGFzWzBdfWVsc2V7bGFtYmRhPWxhbWJkYXNbMV07YXNzZXJ0JDIodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSk9PT0wKX19dmFyIGJhc2lzO2lmKGNvbmYuYmFzaXMpe2Jhc2lzPWNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYyl7cmV0dXJue2E6bmV3IGJuKHZlYy5hLDE2KSxiOm5ldyBibih2ZWMuYiwxNil9fSl9ZWxzZXtiYXNpcz10aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKX1yZXR1cm57YmV0YTpiZXRhLGxhbWJkYTpsYW1iZGEsYmFzaXM6YmFzaXN9fTtTaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzPWZ1bmN0aW9uIF9nZXRFbmRvUm9vdHMobnVtKXt2YXIgcmVkPW51bT09PXRoaXMucD90aGlzLnJlZDpibi5tb250KG51bSk7dmFyIHRpbnY9bmV3IGJuKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO3ZhciBudGludj10aW52LnJlZE5lZygpO3ZhciBzPW5ldyBibigzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7dmFyIGwxPW50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7dmFyIGwyPW50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7cmV0dXJuW2wxLGwyXX07U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcz1mdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSl7dmFyIGFwcnhTcXJ0PXRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKS8yKSk7dmFyIHU9bGFtYmRhO3ZhciB2PXRoaXMubi5jbG9uZSgpO3ZhciB4MT1uZXcgYm4oMSk7dmFyIHkxPW5ldyBibigwKTt2YXIgeDI9bmV3IGJuKDApO3ZhciB5Mj1uZXcgYm4oMSk7dmFyIGEwO3ZhciBiMDt2YXIgYTE7dmFyIGIxO3ZhciBhMjt2YXIgYjI7dmFyIHByZXZSO3ZhciBpPTA7dmFyIHI7dmFyIHg7d2hpbGUodS5jbXBuKDApIT09MCl7dmFyIHE9di5kaXYodSk7cj12LnN1YihxLm11bCh1KSk7eD14Mi5zdWIocS5tdWwoeDEpKTt2YXIgeT15Mi5zdWIocS5tdWwoeTEpKTtpZighYTEmJnIuY21wKGFwcnhTcXJ0KTwwKXthMD1wcmV2Ui5uZWcoKTtiMD14MTthMT1yLm5lZygpO2IxPXh9ZWxzZSBpZihhMSYmKytpPT09Mil7YnJlYWt9cHJldlI9cjt2PXU7dT1yO3gyPXgxO3gxPXg7eTI9eTE7eTE9eX1hMj1yLm5lZygpO2IyPXg7dmFyIGxlbjE9YTEuc3FyKCkuYWRkKGIxLnNxcigpKTt2YXIgbGVuMj1hMi5zcXIoKS5hZGQoYjIuc3FyKCkpO2lmKGxlbjIuY21wKGxlbjEpPj0wKXthMj1hMDtiMj1iMH1pZihhMS5uZWdhdGl2ZSl7YTE9YTEubmVnKCk7YjE9YjEubmVnKCl9aWYoYTIubmVnYXRpdmUpe2EyPWEyLm5lZygpO2IyPWIyLm5lZygpfXJldHVyblt7YTphMSxiOmIxfSx7YTphMixiOmIyfV19O1Nob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvU3BsaXQ9ZnVuY3Rpb24gX2VuZG9TcGxpdChrKXt2YXIgYmFzaXM9dGhpcy5lbmRvLmJhc2lzO3ZhciB2MT1iYXNpc1swXTt2YXIgdjI9YmFzaXNbMV07dmFyIGMxPXYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7dmFyIGMyPXYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7dmFyIHAxPWMxLm11bCh2MS5hKTt2YXIgcDI9YzIubXVsKHYyLmEpO3ZhciBxMT1jMS5tdWwodjEuYik7dmFyIHEyPWMyLm11bCh2Mi5iKTt2YXIgazE9ay5zdWIocDEpLnN1YihwMik7dmFyIGsyPXExLmFkZChxMikubmVnKCk7cmV0dXJue2sxOmsxLGsyOmsyfX07U2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWD1mdW5jdGlvbiBwb2ludEZyb21YKHgsb2RkKXt4PW5ldyBibih4LDE2KTtpZigheC5yZWQpeD14LnRvUmVkKHRoaXMucmVkKTt2YXIgeTI9eC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7dmFyIHk9eTIucmVkU3FydCgpO2lmKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSE9PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludFwiKTt2YXIgaXNPZGQ9eS5mcm9tUmVkKCkuaXNPZGQoKTtpZihvZGQmJiFpc09kZHx8IW9kZCYmaXNPZGQpeT15LnJlZE5lZygpO3JldHVybiB0aGlzLnBvaW50KHgseSl9O1Nob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KXtpZihwb2ludC5pbmYpcmV0dXJuIHRydWU7dmFyIHg9cG9pbnQueDt2YXIgeT1wb2ludC55O3ZhciBheD10aGlzLmEucmVkTXVsKHgpO3ZhciByaHM9eC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO3JldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApPT09MH07U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkPWZ1bmN0aW9uIF9lbmRvV25hZk11bEFkZChwb2ludHMsY29lZmZzLGphY29iaWFuUmVzdWx0KXt2YXIgbnBvaW50cz10aGlzLl9lbmRvV25hZlQxO3ZhciBuY29lZmZzPXRoaXMuX2VuZG9XbmFmVDI7Zm9yKHZhciBpPTA7aTxwb2ludHMubGVuZ3RoO2krKyl7dmFyIHNwbGl0PXRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO3ZhciBwPXBvaW50c1tpXTt2YXIgYmV0YT1wLl9nZXRCZXRhKCk7aWYoc3BsaXQuazEubmVnYXRpdmUpe3NwbGl0LmsxLmluZWcoKTtwPXAubmVnKHRydWUpfWlmKHNwbGl0LmsyLm5lZ2F0aXZlKXtzcGxpdC5rMi5pbmVnKCk7YmV0YT1iZXRhLm5lZyh0cnVlKX1ucG9pbnRzW2kqMl09cDtucG9pbnRzW2kqMisxXT1iZXRhO25jb2VmZnNbaSoyXT1zcGxpdC5rMTtuY29lZmZzW2kqMisxXT1zcGxpdC5rMn12YXIgcmVzPXRoaXMuX3duYWZNdWxBZGQoMSxucG9pbnRzLG5jb2VmZnMsaSoyLGphY29iaWFuUmVzdWx0KTtmb3IodmFyIGo9MDtqPGkqMjtqKyspe25wb2ludHNbal09bnVsbDtuY29lZmZzW2pdPW51bGx9cmV0dXJuIHJlc307ZnVuY3Rpb24gUG9pbnQoY3VydmUseCx5LGlzUmVkKXtiYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsY3VydmUsXCJhZmZpbmVcIik7aWYoeD09PW51bGwmJnk9PT1udWxsKXt0aGlzLng9bnVsbDt0aGlzLnk9bnVsbDt0aGlzLmluZj10cnVlfWVsc2V7dGhpcy54PW5ldyBibih4LDE2KTt0aGlzLnk9bmV3IGJuKHksMTYpO2lmKGlzUmVkKXt0aGlzLnguZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO3RoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCl9aWYoIXRoaXMueC5yZWQpdGhpcy54PXRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7aWYoIXRoaXMueS5yZWQpdGhpcy55PXRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7dGhpcy5pbmY9ZmFsc2V9fWluaGVyaXRzX2Jyb3dzZXIkMShQb2ludCxiYXNlLkJhc2VQb2ludCk7U2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQ9ZnVuY3Rpb24gcG9pbnQoeCx5LGlzUmVkKXtyZXR1cm4gbmV3IFBvaW50KHRoaXMseCx5LGlzUmVkKX07U2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTj1mdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaixyZWQpe3JldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLG9iaixyZWQpfTtQb2ludC5wcm90b3R5cGUuX2dldEJldGE9ZnVuY3Rpb24gX2dldEJldGEoKXtpZighdGhpcy5jdXJ2ZS5lbmRvKXJldHVybjt2YXIgcHJlPXRoaXMucHJlY29tcHV0ZWQ7aWYocHJlJiZwcmUuYmV0YSlyZXR1cm4gcHJlLmJldGE7dmFyIGJldGE9dGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSx0aGlzLnkpO2lmKHByZSl7dmFyIGN1cnZlPXRoaXMuY3VydmU7dmFyIGVuZG9NdWw9ZnVuY3Rpb24ocCl7cmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSxwLnkpfTtwcmUuYmV0YT1iZXRhO2JldGEucHJlY29tcHV0ZWQ9e2JldGE6bnVsbCxuYWY6cHJlLm5hZiYme3duZDpwcmUubmFmLnduZCxwb2ludHM6cHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpfSxkb3VibGVzOnByZS5kb3VibGVzJiZ7c3RlcDpwcmUuZG91Ymxlcy5zdGVwLHBvaW50czpwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpfX19cmV0dXJuIGJldGF9O1BvaW50LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7aWYoIXRoaXMucHJlY29tcHV0ZWQpcmV0dXJuW3RoaXMueCx0aGlzLnldO3JldHVyblt0aGlzLngsdGhpcy55LHRoaXMucHJlY29tcHV0ZWQmJntkb3VibGVzOnRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyYme3N0ZXA6dGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnN0ZXAscG9pbnRzOnRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSl9LG5hZjp0aGlzLnByZWNvbXB1dGVkLm5hZiYme3duZDp0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQscG9pbnRzOnRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKX19XX07UG9pbnQuZnJvbUpTT049ZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsb2JqLHJlZCl7aWYodHlwZW9mIG9iaj09PVwic3RyaW5nXCIpb2JqPUpTT04ucGFyc2Uob2JqKTt2YXIgcmVzPWN1cnZlLnBvaW50KG9ialswXSxvYmpbMV0scmVkKTtpZighb2JqWzJdKXJldHVybiByZXM7ZnVuY3Rpb24gb2JqMnBvaW50KG9iail7cmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSxvYmpbMV0scmVkKX12YXIgcHJlPW9ialsyXTtyZXMucHJlY29tcHV0ZWQ9e2JldGE6bnVsbCxkb3VibGVzOnByZS5kb3VibGVzJiZ7c3RlcDpwcmUuZG91Ymxlcy5zdGVwLHBvaW50czpbcmVzXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKX0sbmFmOnByZS5uYWYmJnt3bmQ6cHJlLm5hZi53bmQscG9pbnRzOltyZXNdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSl9fTtyZXR1cm4gcmVzfTtQb2ludC5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuXCI8RUMgUG9pbnQgSW5maW5pdHk+XCI7cmV0dXJuXCI8RUMgUG9pbnQgeDogXCIrdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwyKStcIiB5OiBcIit0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LDIpK1wiPlwifTtQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eT1mdW5jdGlvbiBpc0luZmluaXR5KCl7cmV0dXJuIHRoaXMuaW5mfTtQb2ludC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uIGFkZChwKXtpZih0aGlzLmluZilyZXR1cm4gcDtpZihwLmluZilyZXR1cm4gdGhpcztpZih0aGlzLmVxKHApKXJldHVybiB0aGlzLmRibCgpO2lmKHRoaXMubmVnKCkuZXEocCkpcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCxudWxsKTtpZih0aGlzLnguY21wKHAueCk9PT0wKXJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsbnVsbCk7dmFyIGM9dGhpcy55LnJlZFN1YihwLnkpO2lmKGMuY21wbigwKSE9PTApYz1jLnJlZE11bCh0aGlzLngucmVkU3ViKHAueCkucmVkSW52bSgpKTt2YXIgbng9Yy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueCkucmVkSVN1YihwLngpO3ZhciBueT1jLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO3JldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LG55KX07UG9pbnQucHJvdG90eXBlLmRibD1mdW5jdGlvbiBkYmwoKXtpZih0aGlzLmluZilyZXR1cm4gdGhpczt2YXIgeXMxPXRoaXMueS5yZWRBZGQodGhpcy55KTtpZih5czEuY21wbigwKT09PTApcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCxudWxsKTt2YXIgYT10aGlzLmN1cnZlLmE7dmFyIHgyPXRoaXMueC5yZWRTcXIoKTt2YXIgZHlpbnY9eXMxLnJlZEludm0oKTt2YXIgYz14Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTt2YXIgbng9Yy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7dmFyIG55PWMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7cmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsbnkpfTtQb2ludC5wcm90b3R5cGUuZ2V0WD1mdW5jdGlvbiBnZXRYKCl7cmV0dXJuIHRoaXMueC5mcm9tUmVkKCl9O1BvaW50LnByb3RvdHlwZS5nZXRZPWZ1bmN0aW9uIGdldFkoKXtyZXR1cm4gdGhpcy55LmZyb21SZWQoKX07UG9pbnQucHJvdG90eXBlLm11bD1mdW5jdGlvbiBtdWwoayl7az1uZXcgYm4oaywxNik7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7ZWxzZSBpZih0aGlzLl9oYXNEb3VibGVzKGspKXJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLGspO2Vsc2UgaWYodGhpcy5jdXJ2ZS5lbmRvKXJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbdGhpc10sW2tdKTtlbHNlIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsayl9O1BvaW50LnByb3RvdHlwZS5tdWxBZGQ9ZnVuY3Rpb24gbXVsQWRkKGsxLHAyLGsyKXt2YXIgcG9pbnRzPVt0aGlzLHAyXTt2YXIgY29lZmZzPVtrMSxrMl07aWYodGhpcy5jdXJ2ZS5lbmRvKXJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsY29lZmZzKTtlbHNlIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEscG9pbnRzLGNvZWZmcywyKX07UG9pbnQucHJvdG90eXBlLmptdWxBZGQ9ZnVuY3Rpb24gam11bEFkZChrMSxwMixrMil7dmFyIHBvaW50cz1bdGhpcyxwMl07dmFyIGNvZWZmcz1bazEsazJdO2lmKHRoaXMuY3VydmUuZW5kbylyZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLGNvZWZmcyx0cnVlKTtlbHNlIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEscG9pbnRzLGNvZWZmcywyLHRydWUpfTtQb2ludC5wcm90b3R5cGUuZXE9ZnVuY3Rpb24gZXEocCl7cmV0dXJuIHRoaXM9PT1wfHx0aGlzLmluZj09PXAuaW5mJiYodGhpcy5pbmZ8fHRoaXMueC5jbXAocC54KT09PTAmJnRoaXMueS5jbXAocC55KT09PTApfTtQb2ludC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSl7aWYodGhpcy5pbmYpcmV0dXJuIHRoaXM7dmFyIHJlcz10aGlzLmN1cnZlLnBvaW50KHRoaXMueCx0aGlzLnkucmVkTmVnKCkpO2lmKF9wcmVjb21wdXRlJiZ0aGlzLnByZWNvbXB1dGVkKXt2YXIgcHJlPXRoaXMucHJlY29tcHV0ZWQ7dmFyIG5lZ2F0ZT1mdW5jdGlvbihwKXtyZXR1cm4gcC5uZWcoKX07cmVzLnByZWNvbXB1dGVkPXtuYWY6cHJlLm5hZiYme3duZDpwcmUubmFmLnduZCxwb2ludHM6cHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSl9LGRvdWJsZXM6cHJlLmRvdWJsZXMmJntzdGVwOnByZS5kb3VibGVzLnN0ZXAscG9pbnRzOnByZS5kb3VibGVzLnBvaW50cy5tYXAobmVnYXRlKX19fXJldHVybiByZXN9O1BvaW50LnByb3RvdHlwZS50b0o9ZnVuY3Rpb24gdG9KKCl7aWYodGhpcy5pbmYpcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsbnVsbCxudWxsKTt2YXIgcmVzPXRoaXMuY3VydmUuanBvaW50KHRoaXMueCx0aGlzLnksdGhpcy5jdXJ2ZS5vbmUpO3JldHVybiByZXN9O2Z1bmN0aW9uIEpQb2ludChjdXJ2ZSx4LHkseil7YmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLGN1cnZlLFwiamFjb2JpYW5cIik7aWYoeD09PW51bGwmJnk9PT1udWxsJiZ6PT09bnVsbCl7dGhpcy54PXRoaXMuY3VydmUub25lO3RoaXMueT10aGlzLmN1cnZlLm9uZTt0aGlzLno9bmV3IGJuKDApfWVsc2V7dGhpcy54PW5ldyBibih4LDE2KTt0aGlzLnk9bmV3IGJuKHksMTYpO3RoaXMuej1uZXcgYm4oeiwxNil9aWYoIXRoaXMueC5yZWQpdGhpcy54PXRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7aWYoIXRoaXMueS5yZWQpdGhpcy55PXRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7aWYoIXRoaXMuei5yZWQpdGhpcy56PXRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7dGhpcy56T25lPXRoaXMuej09PXRoaXMuY3VydmUub25lfWluaGVyaXRzX2Jyb3dzZXIkMShKUG9pbnQsYmFzZS5CYXNlUG9pbnQpO1Nob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludD1mdW5jdGlvbiBqcG9pbnQoeCx5LHope3JldHVybiBuZXcgSlBvaW50KHRoaXMseCx5LHopfTtKUG9pbnQucHJvdG90eXBlLnRvUD1mdW5jdGlvbiB0b1AoKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLG51bGwpO3ZhciB6aW52PXRoaXMuei5yZWRJbnZtKCk7dmFyIHppbnYyPXppbnYucmVkU3FyKCk7dmFyIGF4PXRoaXMueC5yZWRNdWwoemludjIpO3ZhciBheT10aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7cmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsYXkpfTtKUG9pbnQucHJvdG90eXBlLm5lZz1mdW5jdGlvbiBuZWcoKXtyZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LHRoaXMueS5yZWROZWcoKSx0aGlzLnopfTtKUG9pbnQucHJvdG90eXBlLmFkZD1mdW5jdGlvbiBhZGQocCl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHA7aWYocC5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7dmFyIHB6Mj1wLnoucmVkU3FyKCk7dmFyIHoyPXRoaXMuei5yZWRTcXIoKTt2YXIgdTE9dGhpcy54LnJlZE11bChwejIpO3ZhciB1Mj1wLngucmVkTXVsKHoyKTt2YXIgczE9dGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO3ZhciBzMj1wLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTt2YXIgaD11MS5yZWRTdWIodTIpO3ZhciByPXMxLnJlZFN1YihzMik7aWYoaC5jbXBuKDApPT09MCl7aWYoci5jbXBuKDApIT09MClyZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCxudWxsLG51bGwpO2Vsc2UgcmV0dXJuIHRoaXMuZGJsKCl9dmFyIGgyPWgucmVkU3FyKCk7dmFyIGgzPWgyLnJlZE11bChoKTt2YXIgdj11MS5yZWRNdWwoaDIpO3ZhciBueD1yLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTt2YXIgbnk9ci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTt2YXIgbno9dGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtyZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsbnksbnopfTtKUG9pbnQucHJvdG90eXBlLm1peGVkQWRkPWZ1bmN0aW9uIG1peGVkQWRkKHApe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiBwLnRvSigpO2lmKHAuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO3ZhciB6Mj10aGlzLnoucmVkU3FyKCk7dmFyIHUxPXRoaXMueDt2YXIgdTI9cC54LnJlZE11bCh6Mik7dmFyIHMxPXRoaXMueTt2YXIgczI9cC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7dmFyIGg9dTEucmVkU3ViKHUyKTt2YXIgcj1zMS5yZWRTdWIoczIpO2lmKGguY21wbigwKT09PTApe2lmKHIuY21wbigwKSE9PTApcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsbnVsbCxudWxsKTtlbHNlIHJldHVybiB0aGlzLmRibCgpfXZhciBoMj1oLnJlZFNxcigpO3ZhciBoMz1oMi5yZWRNdWwoaCk7dmFyIHY9dTEucmVkTXVsKGgyKTt2YXIgbng9ci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7dmFyIG55PXIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7dmFyIG56PXRoaXMuei5yZWRNdWwoaCk7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LG55LG56KX07SlBvaW50LnByb3RvdHlwZS5kYmxwPWZ1bmN0aW9uIGRibHAocG93KXtpZihwb3c9PT0wKXJldHVybiB0aGlzO2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2lmKCFwb3cpcmV0dXJuIHRoaXMuZGJsKCk7dmFyIGk7aWYodGhpcy5jdXJ2ZS56ZXJvQXx8dGhpcy5jdXJ2ZS50aHJlZUEpe3ZhciByPXRoaXM7Zm9yKGk9MDtpPHBvdztpKyspcj1yLmRibCgpO3JldHVybiByfXZhciBhPXRoaXMuY3VydmUuYTt2YXIgdGludj10aGlzLmN1cnZlLnRpbnY7dmFyIGp4PXRoaXMueDt2YXIgank9dGhpcy55O3ZhciBqej10aGlzLno7dmFyIGp6ND1qei5yZWRTcXIoKS5yZWRTcXIoKTt2YXIganlkPWp5LnJlZEFkZChqeSk7Zm9yKGk9MDtpPHBvdztpKyspe3ZhciBqeDI9angucmVkU3FyKCk7dmFyIGp5ZDI9anlkLnJlZFNxcigpO3ZhciBqeWQ0PWp5ZDIucmVkU3FyKCk7dmFyIGM9angyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO3ZhciB0MT1qeC5yZWRNdWwoanlkMik7dmFyIG54PWMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTt2YXIgdDI9dDEucmVkSVN1YihueCk7dmFyIGRueT1jLnJlZE11bCh0Mik7ZG55PWRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTt2YXIgbno9anlkLnJlZE11bChqeik7aWYoaSsxPHBvdylqejQ9ano0LnJlZE11bChqeWQ0KTtqeD1ueDtqej1uejtqeWQ9ZG55fXJldHVybiB0aGlzLmN1cnZlLmpwb2ludChqeCxqeWQucmVkTXVsKHRpbnYpLGp6KX07SlBvaW50LnByb3RvdHlwZS5kYmw9ZnVuY3Rpb24gZGJsKCl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7aWYodGhpcy5jdXJ2ZS56ZXJvQSlyZXR1cm4gdGhpcy5femVyb0RibCgpO2Vsc2UgaWYodGhpcy5jdXJ2ZS50aHJlZUEpcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7ZWxzZSByZXR1cm4gdGhpcy5fZGJsKCl9O0pQb2ludC5wcm90b3R5cGUuX3plcm9EYmw9ZnVuY3Rpb24gX3plcm9EYmwoKXt2YXIgbng7dmFyIG55O3ZhciBuejtpZih0aGlzLnpPbmUpe3ZhciB4eD10aGlzLngucmVkU3FyKCk7dmFyIHl5PXRoaXMueS5yZWRTcXIoKTt2YXIgeXl5eT15eS5yZWRTcXIoKTt2YXIgcz10aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO3M9cy5yZWRJQWRkKHMpO3ZhciBtPXh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7dmFyIHQ9bS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7dmFyIHl5eXk4PXl5eXkucmVkSUFkZCh5eXl5KTt5eXl5OD15eXl5OC5yZWRJQWRkKHl5eXk4KTt5eXl5OD15eXl5OC5yZWRJQWRkKHl5eXk4KTtueD10O255PW0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7bno9dGhpcy55LnJlZEFkZCh0aGlzLnkpfWVsc2V7dmFyIGE9dGhpcy54LnJlZFNxcigpO3ZhciBiPXRoaXMueS5yZWRTcXIoKTt2YXIgYz1iLnJlZFNxcigpO3ZhciBkPXRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO2Q9ZC5yZWRJQWRkKGQpO3ZhciBlPWEucmVkQWRkKGEpLnJlZElBZGQoYSk7dmFyIGY9ZS5yZWRTcXIoKTt2YXIgYzg9Yy5yZWRJQWRkKGMpO2M4PWM4LnJlZElBZGQoYzgpO2M4PWM4LnJlZElBZGQoYzgpO254PWYucmVkSVN1YihkKS5yZWRJU3ViKGQpO255PWUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO256PXRoaXMueS5yZWRNdWwodGhpcy56KTtuej1uei5yZWRJQWRkKG56KX1yZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsbnksbnopfTtKUG9pbnQucHJvdG90eXBlLl90aHJlZURibD1mdW5jdGlvbiBfdGhyZWVEYmwoKXt2YXIgbng7dmFyIG55O3ZhciBuejtpZih0aGlzLnpPbmUpe3ZhciB4eD10aGlzLngucmVkU3FyKCk7dmFyIHl5PXRoaXMueS5yZWRTcXIoKTt2YXIgeXl5eT15eS5yZWRTcXIoKTt2YXIgcz10aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO3M9cy5yZWRJQWRkKHMpO3ZhciBtPXh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCkucmVkSUFkZCh0aGlzLmN1cnZlLmEpO3ZhciB0PW0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO254PXQ7dmFyIHl5eXk4PXl5eXkucmVkSUFkZCh5eXl5KTt5eXl5OD15eXl5OC5yZWRJQWRkKHl5eXk4KTt5eXl5OD15eXl5OC5yZWRJQWRkKHl5eXk4KTtueT1tLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO256PXRoaXMueS5yZWRBZGQodGhpcy55KX1lbHNle3ZhciBkZWx0YT10aGlzLnoucmVkU3FyKCk7dmFyIGdhbW1hPXRoaXMueS5yZWRTcXIoKTt2YXIgYmV0YT10aGlzLngucmVkTXVsKGdhbW1hKTt2YXIgYWxwaGE9dGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTthbHBoYT1hbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO3ZhciBiZXRhND1iZXRhLnJlZElBZGQoYmV0YSk7YmV0YTQ9YmV0YTQucmVkSUFkZChiZXRhNCk7dmFyIGJldGE4PWJldGE0LnJlZEFkZChiZXRhNCk7bng9YWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7bno9dGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO3ZhciBnZ2FtbWE4PWdhbW1hLnJlZFNxcigpO2dnYW1tYTg9Z2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO2dnYW1tYTg9Z2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO2dnYW1tYTg9Z2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO255PWFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KX1yZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsbnksbnopfTtKUG9pbnQucHJvdG90eXBlLl9kYmw9ZnVuY3Rpb24gX2RibCgpe3ZhciBhPXRoaXMuY3VydmUuYTt2YXIgang9dGhpcy54O3ZhciBqeT10aGlzLnk7dmFyIGp6PXRoaXMuejt2YXIgano0PWp6LnJlZFNxcigpLnJlZFNxcigpO3ZhciBqeDI9angucmVkU3FyKCk7dmFyIGp5Mj1qeS5yZWRTcXIoKTt2YXIgYz1qeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7dmFyIGp4ZDQ9angucmVkQWRkKGp4KTtqeGQ0PWp4ZDQucmVkSUFkZChqeGQ0KTt2YXIgdDE9anhkNC5yZWRNdWwoankyKTt2YXIgbng9Yy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO3ZhciB0Mj10MS5yZWRJU3ViKG54KTt2YXIganlkOD1qeTIucmVkU3FyKCk7anlkOD1qeWQ4LnJlZElBZGQoanlkOCk7anlkOD1qeWQ4LnJlZElBZGQoanlkOCk7anlkOD1qeWQ4LnJlZElBZGQoanlkOCk7dmFyIG55PWMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO3ZhciBuej1qeS5yZWRBZGQoankpLnJlZE11bChqeik7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LG55LG56KX07SlBvaW50LnByb3RvdHlwZS50cnBsPWZ1bmN0aW9uIHRycGwoKXtpZighdGhpcy5jdXJ2ZS56ZXJvQSlyZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7dmFyIHh4PXRoaXMueC5yZWRTcXIoKTt2YXIgeXk9dGhpcy55LnJlZFNxcigpO3ZhciB6ej10aGlzLnoucmVkU3FyKCk7dmFyIHl5eXk9eXkucmVkU3FyKCk7dmFyIG09eHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTt2YXIgbW09bS5yZWRTcXIoKTt2YXIgZT10aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO2U9ZS5yZWRJQWRkKGUpO2U9ZS5yZWRBZGQoZSkucmVkSUFkZChlKTtlPWUucmVkSVN1YihtbSk7dmFyIGVlPWUucmVkU3FyKCk7dmFyIHQ9eXl5eS5yZWRJQWRkKHl5eXkpO3Q9dC5yZWRJQWRkKHQpO3Q9dC5yZWRJQWRkKHQpO3Q9dC5yZWRJQWRkKHQpO3ZhciB1PW0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO3ZhciB5eXU0PXl5LnJlZE11bCh1KTt5eXU0PXl5dTQucmVkSUFkZCh5eXU0KTt5eXU0PXl5dTQucmVkSUFkZCh5eXU0KTt2YXIgbng9dGhpcy54LnJlZE11bChlZSkucmVkSVN1Yih5eXU0KTtueD1ueC5yZWRJQWRkKG54KTtueD1ueC5yZWRJQWRkKG54KTt2YXIgbnk9dGhpcy55LnJlZE11bCh1LnJlZE11bCh0LnJlZElTdWIodSkpLnJlZElTdWIoZS5yZWRNdWwoZWUpKSk7bnk9bnkucmVkSUFkZChueSk7bnk9bnkucmVkSUFkZChueSk7bnk9bnkucmVkSUFkZChueSk7dmFyIG56PXRoaXMuei5yZWRBZGQoZSkucmVkU3FyKCkucmVkSVN1Yih6eikucmVkSVN1YihlZSk7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LG55LG56KX07SlBvaW50LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24gbXVsKGssa2Jhc2Upe2s9bmV3IGJuKGssa2Jhc2UpO3JldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsayl9O0pQb2ludC5wcm90b3R5cGUuZXE9ZnVuY3Rpb24gZXEocCl7aWYocC50eXBlPT09XCJhZmZpbmVcIilyZXR1cm4gdGhpcy5lcShwLnRvSigpKTtpZih0aGlzPT09cClyZXR1cm4gdHJ1ZTt2YXIgejI9dGhpcy56LnJlZFNxcigpO3ZhciBwejI9cC56LnJlZFNxcigpO2lmKHRoaXMueC5yZWRNdWwocHoyKS5yZWRJU3ViKHAueC5yZWRNdWwoejIpKS5jbXBuKDApIT09MClyZXR1cm4gZmFsc2U7dmFyIHozPXoyLnJlZE11bCh0aGlzLnopO3ZhciBwejM9cHoyLnJlZE11bChwLnopO3JldHVybiB0aGlzLnkucmVkTXVsKHB6MykucmVkSVN1YihwLnkucmVkTXVsKHozKSkuY21wbigwKT09PTB9O0pQb2ludC5wcm90b3R5cGUuZXFYVG9QPWZ1bmN0aW9uIGVxWFRvUCh4KXt2YXIgenM9dGhpcy56LnJlZFNxcigpO3ZhciByeD14LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO2lmKHRoaXMueC5jbXAocngpPT09MClyZXR1cm4gdHJ1ZTt2YXIgeGM9eC5jbG9uZSgpO3ZhciB0PXRoaXMuY3VydmUucmVkTi5yZWRNdWwoenMpO2Zvcig7Oyl7eGMuaWFkZCh0aGlzLmN1cnZlLm4pO2lmKHhjLmNtcCh0aGlzLmN1cnZlLnApPj0wKXJldHVybiBmYWxzZTtyeC5yZWRJQWRkKHQpO2lmKHRoaXMueC5jbXAocngpPT09MClyZXR1cm4gdHJ1ZX19O0pQb2ludC5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuXCI8RUMgSlBvaW50IEluZmluaXR5PlwiO3JldHVyblwiPEVDIEpQb2ludCB4OiBcIit0aGlzLngudG9TdHJpbmcoMTYsMikrXCIgeTogXCIrdGhpcy55LnRvU3RyaW5nKDE2LDIpK1wiIHo6IFwiK3RoaXMuei50b1N0cmluZygxNiwyKStcIj5cIn07SlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5PWZ1bmN0aW9uIGlzSW5maW5pdHkoKXtyZXR1cm4gdGhpcy56LmNtcG4oMCk9PT0wfTt2YXIgY3VydmVfMT1jcmVhdGVDb21tb25qc01vZHVsZSQxKGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgY3VydmU9ZXhwb3J0cztjdXJ2ZS5iYXNlPWJhc2U7Y3VydmUuc2hvcnQ9c2hvcnRfMTtjdXJ2ZS5tb250PW51bGw7Y3VydmUuZWR3YXJkcz1udWxsfSk7dmFyIGN1cnZlc18xPWNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBjdXJ2ZXM9ZXhwb3J0czt2YXIgYXNzZXJ0PXV0aWxzXzEkMS5hc3NlcnQ7ZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucyl7aWYob3B0aW9ucy50eXBlPT09XCJzaG9ydFwiKXRoaXMuY3VydmU9bmV3IGN1cnZlXzEuc2hvcnQob3B0aW9ucyk7ZWxzZSBpZihvcHRpb25zLnR5cGU9PT1cImVkd2FyZHNcIil0aGlzLmN1cnZlPW5ldyBjdXJ2ZV8xLmVkd2FyZHMob3B0aW9ucyk7ZWxzZSB0aGlzLmN1cnZlPW5ldyBjdXJ2ZV8xLm1vbnQob3B0aW9ucyk7dGhpcy5nPXRoaXMuY3VydmUuZzt0aGlzLm49dGhpcy5jdXJ2ZS5uO3RoaXMuaGFzaD1vcHRpb25zLmhhc2g7YXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLFwiSW52YWxpZCBjdXJ2ZVwiKTthc3NlcnQodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSxcIkludmFsaWQgY3VydmUsIEcqTiAhPSBPXCIpfWN1cnZlcy5QcmVzZXRDdXJ2ZT1QcmVzZXRDdXJ2ZTtmdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLG9wdGlvbnMpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsbmFtZSx7Y29uZmlndXJhYmxlOnRydWUsZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3ZhciBjdXJ2ZT1uZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcyxuYW1lLHtjb25maWd1cmFibGU6dHJ1ZSxlbnVtZXJhYmxlOnRydWUsdmFsdWU6Y3VydmV9KTtyZXR1cm4gY3VydmV9fSl9ZGVmaW5lQ3VydmUoXCJwMTkyXCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwicDE5MlwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiLGE6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmY1wiLGI6XCI2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMVwiLG46XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMVwiLGhhc2g6aGFzaF8xLnNoYTI1NixnUmVkOmZhbHNlLGc6W1wiMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTJcIixcIjA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExXCJdfSk7ZGVmaW5lQ3VydmUoXCJwMjI0XCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwicDIyNFwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiLGE6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZVwiLGI6XCJiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNFwiLG46XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZFwiLGhhc2g6aGFzaF8xLnNoYTI1NixnUmVkOmZhbHNlLGc6W1wiYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjFcIixcImJkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0XCJdfSk7ZGVmaW5lQ3VydmUoXCJwMjU2XCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOm51bGwscDpcImZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmXCIsYTpcImZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjXCIsYjpcIjVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiXCIsbjpcImZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxXCIsaGFzaDpoYXNoXzEuc2hhMjU2LGdSZWQ6ZmFsc2UsZzpbXCI2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NlwiLFwiNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjVcIl19KTtkZWZpbmVDdXJ2ZShcInAzODRcIix7dHlwZTpcInNob3J0XCIscHJpbWU6bnVsbCxwOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgXCIrXCJmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZlwiLGE6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBcIitcImZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjXCIsYjpcImIzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmIFwiK1wiNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWZcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgXCIrXCJmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3M1wiLGhhc2g6aGFzaF8xLnNoYTM4NCxnUmVkOmZhbHNlLGc6W1wiYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggXCIrXCI1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiN1wiLFwiMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgXCIrXCIwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZlwiXX0pO2RlZmluZUN1cnZlKFwicDUyMVwiLHt0eXBlOlwic2hvcnRcIixwcmltZTpudWxsLHA6XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBcIitcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIFwiK1wiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmZcIixhOlwiMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgXCIrXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBcIitcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjXCIsYjpcIjAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViIFwiK1wiOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgXCIrXCIzYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMFwiLG46XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBcIitcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4IFwiK1wiZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDlcIixoYXNoOmhhc2hfMS5zaGE1MTIsZ1JlZDpmYWxzZSxnOltcIjAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5IFwiK1wiMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgXCIrXCJhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NlwiLFwiMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgXCIrXCI1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSBcIitcIjNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwXCJdfSk7ZGVmaW5lQ3VydmUoXCJjdXJ2ZTI1NTE5XCIse3R5cGU6XCJtb250XCIscHJpbWU6XCJwMjU1MTlcIixwOlwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiLGE6XCI3NmQwNlwiLGI6XCIxXCIsbjpcIjEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWRcIixoYXNoOmhhc2hfMS5zaGEyNTYsZ1JlZDpmYWxzZSxnOltcIjlcIl19KTtkZWZpbmVDdXJ2ZShcImVkMjU1MTlcIix7dHlwZTpcImVkd2FyZHNcIixwcmltZTpcInAyNTUxOVwiLHA6XCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCIsYTpcIi0xXCIsYzpcIjFcIixkOlwiNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhM1wiLG46XCIxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkXCIsaGFzaDpoYXNoXzEuc2hhMjU2LGdSZWQ6ZmFsc2UsZzpbXCIyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhXCIsXCI2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4XCJdfSk7dmFyIHByZTt0cnl7cHJlPW51bGwuY3Jhc2goKX1jYXRjaChlKXtwcmU9dW5kZWZpbmVkfWRlZmluZUN1cnZlKFwic2VjcDI1NmsxXCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwiazI1NlwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiLGE6XCIwXCIsYjpcIjdcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDFcIixoOlwiMVwiLGhhc2g6aGFzaF8xLnNoYTI1NixiZXRhOlwiN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZVwiLGxhbWJkYTpcIjUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzJcIixiYXNpczpbe2E6XCIzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNVwiLGI6XCItZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzNcIn0se2E6XCIxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDhcIixiOlwiMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIn1dLGdSZWQ6ZmFsc2UsZzpbXCI3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4XCIsXCI0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4XCIscHJlXX0pfSk7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucyl7aWYoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKXJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7dGhpcy5oYXNoPW9wdGlvbnMuaGFzaDt0aGlzLnByZWRSZXNpc3Q9ISFvcHRpb25zLnByZWRSZXNpc3Q7dGhpcy5vdXRMZW49dGhpcy5oYXNoLm91dFNpemU7dGhpcy5taW5FbnRyb3B5PW9wdGlvbnMubWluRW50cm9weXx8dGhpcy5oYXNoLmhtYWNTdHJlbmd0aDt0aGlzLl9yZXNlZWQ9bnVsbDt0aGlzLnJlc2VlZEludGVydmFsPW51bGw7dGhpcy5LPW51bGw7dGhpcy5WPW51bGw7dmFyIGVudHJvcHk9dXRpbHNfMS50b0FycmF5KG9wdGlvbnMuZW50cm9weSxvcHRpb25zLmVudHJvcHlFbmN8fFwiaGV4XCIpO3ZhciBub25jZT11dGlsc18xLnRvQXJyYXkob3B0aW9ucy5ub25jZSxvcHRpb25zLm5vbmNlRW5jfHxcImhleFwiKTt2YXIgcGVycz11dGlsc18xLnRvQXJyYXkob3B0aW9ucy5wZXJzLG9wdGlvbnMucGVyc0VuY3x8XCJoZXhcIik7bWluaW1hbGlzdGljQXNzZXJ0JDEoZW50cm9weS5sZW5ndGg+PXRoaXMubWluRW50cm9weS84LFwiTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiBcIit0aGlzLm1pbkVudHJvcHkrXCIgYml0c1wiKTt0aGlzLl9pbml0KGVudHJvcHksbm9uY2UscGVycyl9dmFyIGhtYWNEcmJnPUhtYWNEUkJHO0htYWNEUkJHLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbiBpbml0KGVudHJvcHksbm9uY2UscGVycyl7dmFyIHNlZWQ9ZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTt0aGlzLks9bmV3IEFycmF5KHRoaXMub3V0TGVuLzgpO3RoaXMuVj1uZXcgQXJyYXkodGhpcy5vdXRMZW4vOCk7Zm9yKHZhciBpPTA7aTx0aGlzLlYubGVuZ3RoO2krKyl7dGhpcy5LW2ldPTA7dGhpcy5WW2ldPTF9dGhpcy5fdXBkYXRlKHNlZWQpO3RoaXMuX3Jlc2VlZD0xO3RoaXMucmVzZWVkSW50ZXJ2YWw9MjgxNDc0OTc2NzEwNjU2fTtIbWFjRFJCRy5wcm90b3R5cGUuX2htYWM9ZnVuY3Rpb24gaG1hYygpe3JldHVybiBuZXcgaGFzaF8xLmhtYWModGhpcy5oYXNoLHRoaXMuSyl9O0htYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uIHVwZGF0ZShzZWVkKXt2YXIga21hYz10aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikudXBkYXRlKFswXSk7aWYoc2VlZClrbWFjPWttYWMudXBkYXRlKHNlZWQpO3RoaXMuSz1rbWFjLmRpZ2VzdCgpO3RoaXMuVj10aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7aWYoIXNlZWQpcmV0dXJuO3RoaXMuSz10aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikudXBkYXRlKFsxXSkudXBkYXRlKHNlZWQpLmRpZ2VzdCgpO3RoaXMuVj10aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCl9O0htYWNEUkJHLnByb3RvdHlwZS5yZXNlZWQ9ZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksZW50cm9weUVuYyxhZGQsYWRkRW5jKXtpZih0eXBlb2YgZW50cm9weUVuYyE9PVwic3RyaW5nXCIpe2FkZEVuYz1hZGQ7YWRkPWVudHJvcHlFbmM7ZW50cm9weUVuYz1udWxsfWVudHJvcHk9dXRpbHNfMS50b0FycmF5KGVudHJvcHksZW50cm9weUVuYyk7YWRkPXV0aWxzXzEudG9BcnJheShhZGQsYWRkRW5jKTttaW5pbWFsaXN0aWNBc3NlcnQkMShlbnRyb3B5Lmxlbmd0aD49dGhpcy5taW5FbnRyb3B5LzgsXCJOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6IFwiK3RoaXMubWluRW50cm9weStcIiBiaXRzXCIpO3RoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGR8fFtdKSk7dGhpcy5fcmVzZWVkPTF9O0htYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZT1mdW5jdGlvbiBnZW5lcmF0ZShsZW4sZW5jLGFkZCxhZGRFbmMpe2lmKHRoaXMuX3Jlc2VlZD50aGlzLnJlc2VlZEludGVydmFsKXRocm93IG5ldyBFcnJvcihcIlJlc2VlZCBpcyByZXF1aXJlZFwiKTtpZih0eXBlb2YgZW5jIT09XCJzdHJpbmdcIil7YWRkRW5jPWFkZDthZGQ9ZW5jO2VuYz1udWxsfWlmKGFkZCl7YWRkPXV0aWxzXzEudG9BcnJheShhZGQsYWRkRW5jfHxcImhleFwiKTt0aGlzLl91cGRhdGUoYWRkKX12YXIgdGVtcD1bXTt3aGlsZSh0ZW1wLmxlbmd0aDxsZW4pe3RoaXMuVj10aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7dGVtcD10ZW1wLmNvbmNhdCh0aGlzLlYpfXZhciByZXM9dGVtcC5zbGljZSgwLGxlbik7dGhpcy5fdXBkYXRlKGFkZCk7dGhpcy5fcmVzZWVkKys7cmV0dXJuIHV0aWxzXzEuZW5jb2RlKHJlcyxlbmMpfTtcInVzZSBzdHJpY3RcIjt2YXIgYXNzZXJ0JDM9dXRpbHNfMSQxLmFzc2VydDtmdW5jdGlvbiBLZXlQYWlyKGVjLG9wdGlvbnMpe3RoaXMuZWM9ZWM7dGhpcy5wcml2PW51bGw7dGhpcy5wdWI9bnVsbDtpZihvcHRpb25zLnByaXYpdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsb3B0aW9ucy5wcml2RW5jKTtpZihvcHRpb25zLnB1Yil0aGlzLl9pbXBvcnRQdWJsaWMob3B0aW9ucy5wdWIsb3B0aW9ucy5wdWJFbmMpfXZhciBrZXk9S2V5UGFpcjtLZXlQYWlyLmZyb21QdWJsaWM9ZnVuY3Rpb24gZnJvbVB1YmxpYyhlYyxwdWIsZW5jKXtpZihwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKXJldHVybiBwdWI7cmV0dXJuIG5ldyBLZXlQYWlyKGVjLHtwdWI6cHViLHB1YkVuYzplbmN9KX07S2V5UGFpci5mcm9tUHJpdmF0ZT1mdW5jdGlvbiBmcm9tUHJpdmF0ZShlYyxwcml2LGVuYyl7aWYocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpcmV0dXJuIHByaXY7cmV0dXJuIG5ldyBLZXlQYWlyKGVjLHtwcml2OnByaXYscHJpdkVuYzplbmN9KX07S2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24gdmFsaWRhdGUoKXt2YXIgcHViPXRoaXMuZ2V0UHVibGljKCk7aWYocHViLmlzSW5maW5pdHkoKSlyZXR1cm57cmVzdWx0OmZhbHNlLHJlYXNvbjpcIkludmFsaWQgcHVibGljIGtleVwifTtpZighcHViLnZhbGlkYXRlKCkpcmV0dXJue3Jlc3VsdDpmYWxzZSxyZWFzb246XCJQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50XCJ9O2lmKCFwdWIubXVsKHRoaXMuZWMuY3VydmUubikuaXNJbmZpbml0eSgpKXJldHVybntyZXN1bHQ6ZmFsc2UscmVhc29uOlwiUHVibGljIGtleSAqIE4gIT0gT1wifTtyZXR1cm57cmVzdWx0OnRydWUscmVhc29uOm51bGx9fTtLZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWM9ZnVuY3Rpb24gZ2V0UHVibGljKGNvbXBhY3QsZW5jKXtpZih0eXBlb2YgY29tcGFjdD09PVwic3RyaW5nXCIpe2VuYz1jb21wYWN0O2NvbXBhY3Q9bnVsbH1pZighdGhpcy5wdWIpdGhpcy5wdWI9dGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO2lmKCFlbmMpcmV0dXJuIHRoaXMucHViO3JldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLGNvbXBhY3QpfTtLZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlPWZ1bmN0aW9uIGdldFByaXZhdGUoZW5jKXtpZihlbmM9PT1cImhleFwiKXJldHVybiB0aGlzLnByaXYudG9TdHJpbmcoMTYsMik7ZWxzZSByZXR1cm4gdGhpcy5wcml2fTtLZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZT1mdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksZW5jKXt0aGlzLnByaXY9bmV3IGJuKGtleSxlbmN8fDE2KTt0aGlzLnByaXY9dGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKX07S2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYz1mdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSxlbmMpe2lmKGtleS54fHxrZXkueSl7aWYodGhpcy5lYy5jdXJ2ZS50eXBlPT09XCJtb250XCIpe2Fzc2VydCQzKGtleS54LFwiTmVlZCB4IGNvb3JkaW5hdGVcIil9ZWxzZSBpZih0aGlzLmVjLmN1cnZlLnR5cGU9PT1cInNob3J0XCJ8fHRoaXMuZWMuY3VydmUudHlwZT09PVwiZWR3YXJkc1wiKXthc3NlcnQkMyhrZXkueCYma2V5LnksXCJOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlXCIpfXRoaXMucHViPXRoaXMuZWMuY3VydmUucG9pbnQoa2V5Lngsa2V5LnkpO3JldHVybn10aGlzLnB1Yj10aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSxlbmMpfTtLZXlQYWlyLnByb3RvdHlwZS5kZXJpdmU9ZnVuY3Rpb24gZGVyaXZlKHB1Yil7aWYoIXB1Yi52YWxpZGF0ZSgpKXthc3NlcnQkMyhwdWIudmFsaWRhdGUoKSxcInB1YmxpYyBwb2ludCBub3QgdmFsaWRhdGVkXCIpfXJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpfTtLZXlQYWlyLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uIHNpZ24obXNnLGVuYyxvcHRpb25zKXtyZXR1cm4gdGhpcy5lYy5zaWduKG1zZyx0aGlzLGVuYyxvcHRpb25zKX07S2V5UGFpci5wcm90b3R5cGUudmVyaWZ5PWZ1bmN0aW9uIHZlcmlmeShtc2csc2lnbmF0dXJlKXtyZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLHNpZ25hdHVyZSx0aGlzKX07S2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7cmV0dXJuXCI8S2V5IHByaXY6IFwiKyh0aGlzLnByaXYmJnRoaXMucHJpdi50b1N0cmluZygxNiwyKSkrXCIgcHViOiBcIisodGhpcy5wdWImJnRoaXMucHViLmluc3BlY3QoKSkrXCIgPlwifTtcInVzZSBzdHJpY3RcIjt2YXIgYXNzZXJ0JDQ9dXRpbHNfMSQxLmFzc2VydDtmdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucyxlbmMpe2lmKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpcmV0dXJuIG9wdGlvbnM7aWYodGhpcy5faW1wb3J0REVSKG9wdGlvbnMsZW5jKSlyZXR1cm47YXNzZXJ0JDQob3B0aW9ucy5yJiZvcHRpb25zLnMsXCJTaWduYXR1cmUgd2l0aG91dCByIG9yIHNcIik7dGhpcy5yPW5ldyBibihvcHRpb25zLnIsMTYpO3RoaXMucz1uZXcgYm4ob3B0aW9ucy5zLDE2KTtpZihvcHRpb25zLnJlY292ZXJ5UGFyYW09PT11bmRlZmluZWQpdGhpcy5yZWNvdmVyeVBhcmFtPW51bGw7ZWxzZSB0aGlzLnJlY292ZXJ5UGFyYW09b3B0aW9ucy5yZWNvdmVyeVBhcmFtfXZhciBzaWduYXR1cmU9U2lnbmF0dXJlO2Z1bmN0aW9uIFBvc2l0aW9uKCl7dGhpcy5wbGFjZT0wfWZ1bmN0aW9uIGdldExlbmd0aChidWYscCl7dmFyIGluaXRpYWw9YnVmW3AucGxhY2UrK107aWYoIShpbml0aWFsJjEyOCkpe3JldHVybiBpbml0aWFsfXZhciBvY3RldExlbj1pbml0aWFsJjE1O2lmKG9jdGV0TGVuPT09MHx8b2N0ZXRMZW4+NCl7cmV0dXJuIGZhbHNlfXZhciB2YWw9MDtmb3IodmFyIGk9MCxvZmY9cC5wbGFjZTtpPG9jdGV0TGVuO2krKyxvZmYrKyl7dmFsPDw9ODt2YWx8PWJ1ZltvZmZdO3ZhbD4+Pj0wfWlmKHZhbDw9MTI3KXtyZXR1cm4gZmFsc2V9cC5wbGFjZT1vZmY7cmV0dXJuIHZhbH1mdW5jdGlvbiBybVBhZGRpbmcoYnVmKXt2YXIgaT0wO3ZhciBsZW49YnVmLmxlbmd0aC0xO3doaWxlKCFidWZbaV0mJiEoYnVmW2krMV0mMTI4KSYmaTxsZW4pe2krK31pZihpPT09MCl7cmV0dXJuIGJ1Zn1yZXR1cm4gYnVmLnNsaWNlKGkpfVNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUj1mdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsZW5jKXtkYXRhPXV0aWxzXzEkMS50b0FycmF5KGRhdGEsZW5jKTt2YXIgcD1uZXcgUG9zaXRpb247aWYoZGF0YVtwLnBsYWNlKytdIT09NDgpe3JldHVybiBmYWxzZX12YXIgbGVuPWdldExlbmd0aChkYXRhLHApO2lmKGxlbj09PWZhbHNlKXtyZXR1cm4gZmFsc2V9aWYobGVuK3AucGxhY2UhPT1kYXRhLmxlbmd0aCl7cmV0dXJuIGZhbHNlfWlmKGRhdGFbcC5wbGFjZSsrXSE9PTIpe3JldHVybiBmYWxzZX12YXIgcmxlbj1nZXRMZW5ndGgoZGF0YSxwKTtpZihybGVuPT09ZmFsc2Upe3JldHVybiBmYWxzZX12YXIgcj1kYXRhLnNsaWNlKHAucGxhY2UscmxlbitwLnBsYWNlKTtwLnBsYWNlKz1ybGVuO2lmKGRhdGFbcC5wbGFjZSsrXSE9PTIpe3JldHVybiBmYWxzZX12YXIgc2xlbj1nZXRMZW5ndGgoZGF0YSxwKTtpZihzbGVuPT09ZmFsc2Upe3JldHVybiBmYWxzZX1pZihkYXRhLmxlbmd0aCE9PXNsZW4rcC5wbGFjZSl7cmV0dXJuIGZhbHNlfXZhciBzPWRhdGEuc2xpY2UocC5wbGFjZSxzbGVuK3AucGxhY2UpO2lmKHJbMF09PT0wKXtpZihyWzFdJjEyOCl7cj1yLnNsaWNlKDEpfWVsc2V7cmV0dXJuIGZhbHNlfX1pZihzWzBdPT09MCl7aWYoc1sxXSYxMjgpe3M9cy5zbGljZSgxKX1lbHNle3JldHVybiBmYWxzZX19dGhpcy5yPW5ldyBibihyKTt0aGlzLnM9bmV3IGJuKHMpO3RoaXMucmVjb3ZlcnlQYXJhbT1udWxsO3JldHVybiB0cnVlfTtmdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLGxlbil7aWYobGVuPDEyOCl7YXJyLnB1c2gobGVuKTtyZXR1cm59dmFyIG9jdGV0cz0xKyhNYXRoLmxvZyhsZW4pL01hdGguTE4yPj4+Myk7YXJyLnB1c2gob2N0ZXRzfDEyOCk7d2hpbGUoLS1vY3RldHMpe2Fyci5wdXNoKGxlbj4+PihvY3RldHM8PDMpJjI1NSl9YXJyLnB1c2gobGVuKX1TaWduYXR1cmUucHJvdG90eXBlLnRvREVSPWZ1bmN0aW9uIHRvREVSKGVuYyl7dmFyIHI9dGhpcy5yLnRvQXJyYXkoKTt2YXIgcz10aGlzLnMudG9BcnJheSgpO2lmKHJbMF0mMTI4KXI9WzBdLmNvbmNhdChyKTtpZihzWzBdJjEyOClzPVswXS5jb25jYXQocyk7cj1ybVBhZGRpbmcocik7cz1ybVBhZGRpbmcocyk7d2hpbGUoIXNbMF0mJiEoc1sxXSYxMjgpKXtzPXMuc2xpY2UoMSl9dmFyIGFycj1bMl07Y29uc3RydWN0TGVuZ3RoKGFycixyLmxlbmd0aCk7YXJyPWFyci5jb25jYXQocik7YXJyLnB1c2goMik7Y29uc3RydWN0TGVuZ3RoKGFycixzLmxlbmd0aCk7dmFyIGJhY2tIYWxmPWFyci5jb25jYXQocyk7dmFyIHJlcz1bNDhdO2NvbnN0cnVjdExlbmd0aChyZXMsYmFja0hhbGYubGVuZ3RoKTtyZXM9cmVzLmNvbmNhdChiYWNrSGFsZik7cmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUocmVzLGVuYyl9O1widXNlIHN0cmljdFwiO3ZhciByYW5kPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWRcIil9O3ZhciBhc3NlcnQkNT11dGlsc18xJDEuYXNzZXJ0O2Z1bmN0aW9uIEVDKG9wdGlvbnMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlyZXR1cm4gbmV3IEVDKG9wdGlvbnMpO2lmKHR5cGVvZiBvcHRpb25zPT09XCJzdHJpbmdcIil7YXNzZXJ0JDUoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnZlc18xLG9wdGlvbnMpLFwiVW5rbm93biBjdXJ2ZSBcIitvcHRpb25zKTtvcHRpb25zPWN1cnZlc18xW29wdGlvbnNdfWlmKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXNfMS5QcmVzZXRDdXJ2ZSlvcHRpb25zPXtjdXJ2ZTpvcHRpb25zfTt0aGlzLmN1cnZlPW9wdGlvbnMuY3VydmUuY3VydmU7dGhpcy5uPXRoaXMuY3VydmUubjt0aGlzLm5oPXRoaXMubi51c2hybigxKTt0aGlzLmc9dGhpcy5jdXJ2ZS5nO3RoaXMuZz1vcHRpb25zLmN1cnZlLmc7dGhpcy5nLnByZWNvbXB1dGUob3B0aW9ucy5jdXJ2ZS5uLmJpdExlbmd0aCgpKzEpO3RoaXMuaGFzaD1vcHRpb25zLmhhc2h8fG9wdGlvbnMuY3VydmUuaGFzaH12YXIgZWM9RUM7RUMucHJvdG90eXBlLmtleVBhaXI9ZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKXtyZXR1cm4gbmV3IGtleSh0aGlzLG9wdGlvbnMpfTtFQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGU9ZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdixlbmMpe3JldHVybiBrZXkuZnJvbVByaXZhdGUodGhpcyxwcml2LGVuYyl9O0VDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljPWZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLGVuYyl7cmV0dXJuIGtleS5mcm9tUHVibGljKHRoaXMscHViLGVuYyl9O0VDLnByb3RvdHlwZS5nZW5LZXlQYWlyPWZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucyl7aWYoIW9wdGlvbnMpb3B0aW9ucz17fTt2YXIgZHJiZz1uZXcgaG1hY0RyYmcoe2hhc2g6dGhpcy5oYXNoLHBlcnM6b3B0aW9ucy5wZXJzLHBlcnNFbmM6b3B0aW9ucy5wZXJzRW5jfHxcInV0ZjhcIixlbnRyb3B5Om9wdGlvbnMuZW50cm9weXx8cmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxlbnRyb3B5RW5jOm9wdGlvbnMuZW50cm9weSYmb3B0aW9ucy5lbnRyb3B5RW5jfHxcInV0ZjhcIixub25jZTp0aGlzLm4udG9BcnJheSgpfSk7dmFyIGJ5dGVzPXRoaXMubi5ieXRlTGVuZ3RoKCk7dmFyIG5zMj10aGlzLm4uc3ViKG5ldyBibigyKSk7Zm9yKDs7KXt2YXIgcHJpdj1uZXcgYm4oZHJiZy5nZW5lcmF0ZShieXRlcykpO2lmKHByaXYuY21wKG5zMik+MCljb250aW51ZTtwcml2LmlhZGRuKDEpO3JldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpfX07RUMucHJvdG90eXBlLl90cnVuY2F0ZVRvTj1mdW5jdGlvbiBfdHJ1bmNhdGVUb04obXNnLHRydW5jT25seSl7dmFyIGRlbHRhPW1zZy5ieXRlTGVuZ3RoKCkqOC10aGlzLm4uYml0TGVuZ3RoKCk7aWYoZGVsdGE+MCltc2c9bXNnLnVzaHJuKGRlbHRhKTtpZighdHJ1bmNPbmx5JiZtc2cuY21wKHRoaXMubik+PTApcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtlbHNlIHJldHVybiBtc2d9O0VDLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uIHNpZ24obXNnLGtleSxlbmMsb3B0aW9ucyl7aWYodHlwZW9mIGVuYz09PVwib2JqZWN0XCIpe29wdGlvbnM9ZW5jO2VuYz1udWxsfWlmKCFvcHRpb25zKW9wdGlvbnM9e307a2V5PXRoaXMua2V5RnJvbVByaXZhdGUoa2V5LGVuYyk7bXNnPXRoaXMuX3RydW5jYXRlVG9OKG5ldyBibihtc2csMTYpKTt2YXIgYnl0ZXM9dGhpcy5uLmJ5dGVMZW5ndGgoKTt2YXIgYmtleT1rZXkuZ2V0UHJpdmF0ZSgpLnRvQXJyYXkoXCJiZVwiLGJ5dGVzKTt2YXIgbm9uY2U9bXNnLnRvQXJyYXkoXCJiZVwiLGJ5dGVzKTt2YXIgZHJiZz1uZXcgaG1hY0RyYmcoe2hhc2g6dGhpcy5oYXNoLGVudHJvcHk6YmtleSxub25jZTpub25jZSxwZXJzOm9wdGlvbnMucGVycyxwZXJzRW5jOm9wdGlvbnMucGVyc0VuY3x8XCJ1dGY4XCJ9KTt2YXIgbnMxPXRoaXMubi5zdWIobmV3IGJuKDEpKTtmb3IodmFyIGl0ZXI9MDs7aXRlcisrKXt2YXIgaz1vcHRpb25zLms/b3B0aW9ucy5rKGl0ZXIpOm5ldyBibihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtrPXRoaXMuX3RydW5jYXRlVG9OKGssdHJ1ZSk7aWYoay5jbXBuKDEpPD0wfHxrLmNtcChuczEpPj0wKWNvbnRpbnVlO3ZhciBrcD10aGlzLmcubXVsKGspO2lmKGtwLmlzSW5maW5pdHkoKSljb250aW51ZTt2YXIga3BYPWtwLmdldFgoKTt2YXIgcj1rcFgudW1vZCh0aGlzLm4pO2lmKHIuY21wbigwKT09PTApY29udGludWU7dmFyIHM9ay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7cz1zLnVtb2QodGhpcy5uKTtpZihzLmNtcG4oMCk9PT0wKWNvbnRpbnVlO3ZhciByZWNvdmVyeVBhcmFtPShrcC5nZXRZKCkuaXNPZGQoKT8xOjApfChrcFguY21wKHIpIT09MD8yOjApO2lmKG9wdGlvbnMuY2Fub25pY2FsJiZzLmNtcCh0aGlzLm5oKT4wKXtzPXRoaXMubi5zdWIocyk7cmVjb3ZlcnlQYXJhbV49MX1yZXR1cm4gbmV3IHNpZ25hdHVyZSh7cjpyLHM6cyxyZWNvdmVyeVBhcmFtOnJlY292ZXJ5UGFyYW19KX19O0VDLnByb3RvdHlwZS52ZXJpZnk9ZnVuY3Rpb24gdmVyaWZ5KG1zZyxzaWduYXR1cmUkMSxrZXksZW5jKXttc2c9dGhpcy5fdHJ1bmNhdGVUb04obmV3IGJuKG1zZywxNikpO2tleT10aGlzLmtleUZyb21QdWJsaWMoa2V5LGVuYyk7c2lnbmF0dXJlJDE9bmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSxcImhleFwiKTt2YXIgcj1zaWduYXR1cmUkMS5yO3ZhciBzPXNpZ25hdHVyZSQxLnM7aWYoci5jbXBuKDEpPDB8fHIuY21wKHRoaXMubik+PTApcmV0dXJuIGZhbHNlO2lmKHMuY21wbigxKTwwfHxzLmNtcCh0aGlzLm4pPj0wKXJldHVybiBmYWxzZTt2YXIgc2ludj1zLmludm0odGhpcy5uKTt2YXIgdTE9c2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7dmFyIHUyPXNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTt2YXIgcDtpZighdGhpcy5jdXJ2ZS5fbWF4d2VsbFRyaWNrKXtwPXRoaXMuZy5tdWxBZGQodTEsa2V5LmdldFB1YmxpYygpLHUyKTtpZihwLmlzSW5maW5pdHkoKSlyZXR1cm4gZmFsc2U7cmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocik9PT0wfXA9dGhpcy5nLmptdWxBZGQodTEsa2V5LmdldFB1YmxpYygpLHUyKTtpZihwLmlzSW5maW5pdHkoKSlyZXR1cm4gZmFsc2U7cmV0dXJuIHAuZXFYVG9QKHIpfTtFQy5wcm90b3R5cGUucmVjb3ZlclB1YktleT1mdW5jdGlvbihtc2csc2lnbmF0dXJlJDEsaixlbmMpe2Fzc2VydCQ1KCgzJmopPT09aixcIlRoZSByZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHNcIik7c2lnbmF0dXJlJDE9bmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSxlbmMpO3ZhciBuPXRoaXMubjt2YXIgZT1uZXcgYm4obXNnKTt2YXIgcj1zaWduYXR1cmUkMS5yO3ZhciBzPXNpZ25hdHVyZSQxLnM7dmFyIGlzWU9kZD1qJjE7dmFyIGlzU2Vjb25kS2V5PWo+PjE7aWYoci5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSk+PTAmJmlzU2Vjb25kS2V5KXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZVwiKTtpZihpc1NlY29uZEtleSlyPXRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLGlzWU9kZCk7ZWxzZSByPXRoaXMuY3VydmUucG9pbnRGcm9tWChyLGlzWU9kZCk7dmFyIHJJbnY9c2lnbmF0dXJlJDEuci5pbnZtKG4pO3ZhciBzMT1uLnN1YihlKS5tdWwockludikudW1vZChuKTt2YXIgczI9cy5tdWwockludikudW1vZChuKTtyZXR1cm4gdGhpcy5nLm11bEFkZChzMSxyLHMyKX07RUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW09ZnVuY3Rpb24oZSxzaWduYXR1cmUkMSxRLGVuYyl7c2lnbmF0dXJlJDE9bmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSxlbmMpO2lmKHNpZ25hdHVyZSQxLnJlY292ZXJ5UGFyYW0hPT1udWxsKXJldHVybiBzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtO2Zvcih2YXIgaT0wO2k8NDtpKyspe3ZhciBRcHJpbWU7dHJ5e1FwcmltZT10aGlzLnJlY292ZXJQdWJLZXkoZSxzaWduYXR1cmUkMSxpKX1jYXRjaChlKXtjb250aW51ZX1pZihRcHJpbWUuZXEoUSkpcmV0dXJuIGl9dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yXCIpfTt2YXIgZWxsaXB0aWNfMT1jcmVhdGVDb21tb25qc01vZHVsZSQxKGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgZWxsaXB0aWM9ZXhwb3J0cztlbGxpcHRpYy52ZXJzaW9uPXt2ZXJzaW9uOlwiNi41LjRcIn0udmVyc2lvbjtlbGxpcHRpYy51dGlscz11dGlsc18xJDE7ZWxsaXB0aWMucmFuZD1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkXCIpfTtlbGxpcHRpYy5jdXJ2ZT1jdXJ2ZV8xO2VsbGlwdGljLmN1cnZlcz1jdXJ2ZXNfMTtlbGxpcHRpYy5lYz1lYztlbGxpcHRpYy5lZGRzYT1udWxsfSk7dmFyIEVDJDE9ZWxsaXB0aWNfMS5lYztjb25zdCB2ZXJzaW9uJGI9XCJzaWduaW5nLWtleS81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRnPW5ldyBMb2dnZXIodmVyc2lvbiRiKTtsZXQgX2N1cnZlPW51bGw7ZnVuY3Rpb24gZ2V0Q3VydmUoKXtpZighX2N1cnZlKXtfY3VydmU9bmV3IEVDJDEoXCJzZWNwMjU2azFcIil9cmV0dXJuIF9jdXJ2ZX1jbGFzcyBTaWduaW5nS2V5e2NvbnN0cnVjdG9yKHByaXZhdGVLZXkpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJjdXJ2ZVwiLFwic2VjcDI1NmsxXCIpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcml2YXRlS2V5XCIsaGV4bGlmeShwcml2YXRlS2V5KSk7Y29uc3Qga2V5UGFpcj1nZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIixcIjB4XCIra2V5UGFpci5nZXRQdWJsaWMoZmFsc2UsXCJoZXhcIikpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJjb21wcmVzc2VkUHVibGljS2V5XCIsXCIweFwiK2tleVBhaXIuZ2V0UHVibGljKHRydWUsXCJoZXhcIikpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfaXNTaWduaW5nS2V5XCIsdHJ1ZSl9X2FkZFBvaW50KG90aGVyKXtjb25zdCBwMD1nZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYXJyYXlpZnkodGhpcy5wdWJsaWNLZXkpKTtjb25zdCBwMT1nZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYXJyYXlpZnkob3RoZXIpKTtyZXR1cm5cIjB4XCIrcDAucHViLmFkZChwMS5wdWIpLmVuY29kZUNvbXByZXNzZWQoXCJoZXhcIil9c2lnbkRpZ2VzdChkaWdlc3Qpe2NvbnN0IGtleVBhaXI9Z2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtjb25zdCBkaWdlc3RCeXRlcz1hcnJheWlmeShkaWdlc3QpO2lmKGRpZ2VzdEJ5dGVzLmxlbmd0aCE9PTMyKXtsb2dnZXIkZy50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgZGlnZXN0IGxlbmd0aFwiLFwiZGlnZXN0XCIsZGlnZXN0KX1jb25zdCBzaWduYXR1cmU9a2V5UGFpci5zaWduKGRpZ2VzdEJ5dGVzLHtjYW5vbmljYWw6dHJ1ZX0pO3JldHVybiBzcGxpdFNpZ25hdHVyZSh7cmVjb3ZlcnlQYXJhbTpzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSxyOmhleFplcm9QYWQoXCIweFwiK3NpZ25hdHVyZS5yLnRvU3RyaW5nKDE2KSwzMiksczpoZXhaZXJvUGFkKFwiMHhcIitzaWduYXR1cmUucy50b1N0cmluZygxNiksMzIpfSl9Y29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcktleSl7Y29uc3Qga2V5UGFpcj1nZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO2NvbnN0IG90aGVyS2V5UGFpcj1nZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYXJyYXlpZnkoY29tcHV0ZVB1YmxpY0tleShvdGhlcktleSkpKTtyZXR1cm4gaGV4WmVyb1BhZChcIjB4XCIra2V5UGFpci5kZXJpdmUob3RoZXJLZXlQYWlyLmdldFB1YmxpYygpKS50b1N0cmluZygxNiksMzIpfXN0YXRpYyBpc1NpZ25pbmdLZXkodmFsdWUpe3JldHVybiEhKHZhbHVlJiZ2YWx1ZS5faXNTaWduaW5nS2V5KX19ZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShkaWdlc3Qsc2lnbmF0dXJlKXtjb25zdCBzaWc9c3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtjb25zdCBycz17cjphcnJheWlmeShzaWcuciksczphcnJheWlmeShzaWcucyl9O3JldHVyblwiMHhcIitnZXRDdXJ2ZSgpLnJlY292ZXJQdWJLZXkoYXJyYXlpZnkoZGlnZXN0KSxycyxzaWcucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsZmFsc2UpfWZ1bmN0aW9uIGNvbXB1dGVQdWJsaWNLZXkoa2V5LGNvbXByZXNzZWQpe2NvbnN0IGJ5dGVzPWFycmF5aWZ5KGtleSk7aWYoYnl0ZXMubGVuZ3RoPT09MzIpe2NvbnN0IHNpZ25pbmdLZXk9bmV3IFNpZ25pbmdLZXkoYnl0ZXMpO2lmKGNvbXByZXNzZWQpe3JldHVyblwiMHhcIitnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSxcImhleFwiKX1yZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXl9ZWxzZSBpZihieXRlcy5sZW5ndGg9PT0zMyl7aWYoY29tcHJlc3NlZCl7cmV0dXJuIGhleGxpZnkoYnl0ZXMpfXJldHVyblwiMHhcIitnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyhmYWxzZSxcImhleFwiKX1lbHNlIGlmKGJ5dGVzLmxlbmd0aD09PTY1KXtpZighY29tcHJlc3NlZCl7cmV0dXJuIGhleGxpZnkoYnl0ZXMpfXJldHVyblwiMHhcIitnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLFwiaGV4XCIpfXJldHVybiBsb2dnZXIkZy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHB1YmxpYyBvciBwcml2YXRlIGtleVwiLFwia2V5XCIsXCJbUkVEQUNURURdXCIpfWNvbnN0IHZlcnNpb24kYz1cInRyYW5zYWN0aW9ucy81LjEuMVwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRoPW5ldyBMb2dnZXIodmVyc2lvbiRjKTtmdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKXtpZih2YWx1ZT09PVwiMHhcIil7cmV0dXJuIG51bGx9cmV0dXJuIGdldEFkZHJlc3ModmFsdWUpfWZ1bmN0aW9uIGhhbmRsZU51bWJlcih2YWx1ZSl7aWYodmFsdWU9PT1cIjB4XCIpe3JldHVybiBaZXJvJDF9cmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKX1jb25zdCB0cmFuc2FjdGlvbkZpZWxkcz1be25hbWU6XCJub25jZVwiLG1heExlbmd0aDozMixudW1lcmljOnRydWV9LHtuYW1lOlwiZ2FzUHJpY2VcIixtYXhMZW5ndGg6MzIsbnVtZXJpYzp0cnVlfSx7bmFtZTpcImdhc0xpbWl0XCIsbWF4TGVuZ3RoOjMyLG51bWVyaWM6dHJ1ZX0se25hbWU6XCJ0b1wiLGxlbmd0aDoyMH0se25hbWU6XCJ2YWx1ZVwiLG1heExlbmd0aDozMixudW1lcmljOnRydWV9LHtuYW1lOlwiZGF0YVwifV07Y29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyQxPXtjaGFpbklkOnRydWUsZGF0YTp0cnVlLGdhc0xpbWl0OnRydWUsZ2FzUHJpY2U6dHJ1ZSxub25jZTp0cnVlLHRvOnRydWUsdmFsdWU6dHJ1ZX07ZnVuY3Rpb24gY29tcHV0ZUFkZHJlc3Moa2V5KXtjb25zdCBwdWJsaWNLZXk9Y29tcHV0ZVB1YmxpY0tleShrZXkpO3JldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoaGV4RGF0YVNsaWNlKHB1YmxpY0tleSwxKSksMTIpKX1mdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3Qsc2lnbmF0dXJlKXtyZXR1cm4gY29tcHV0ZUFkZHJlc3MocmVjb3ZlclB1YmxpY0tleShhcnJheWlmeShkaWdlc3QpLHNpZ25hdHVyZSkpfWZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSxuYW1lKXtjb25zdCByZXN1bHQ9c3RyaXBaZXJvcyhCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSk7aWYocmVzdWx0Lmxlbmd0aD4zMil7bG9nZ2VyJGgudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiK25hbWUsXCJ0cmFuc2FjdGlvbjpcIituYW1lLHZhbHVlKX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLHN0b3JhZ2VLZXlzKXtyZXR1cm57YWRkcmVzczpnZXRBZGRyZXNzKGFkZHIpLHN0b3JhZ2VLZXlzOihzdG9yYWdlS2V5c3x8W10pLm1hcCgoc3RvcmFnZUtleSxpbmRleCk9PntpZihoZXhEYXRhTGVuZ3RoKHN0b3JhZ2VLZXkpIT09MzIpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWNjZXNzIGxpc3Qgc3RvcmFnZUtleVwiLGBhY2Nlc3NMaXN0WyR7YWRkcn06JHtpbmRleH1dYCxzdG9yYWdlS2V5KX1yZXR1cm4gc3RvcmFnZUtleS50b0xvd2VyQ2FzZSgpfSl9fWZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpe2lmKEFycmF5LmlzQXJyYXkodmFsdWUpKXtyZXR1cm4gdmFsdWUubWFwKChzZXQsaW5kZXgpPT57aWYoQXJyYXkuaXNBcnJheShzZXQpKXtpZihzZXQubGVuZ3RoPjIpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImFjY2VzcyBsaXN0IGV4cGVjdGVkIHRvIGJlIFsgYWRkcmVzcywgc3RvcmFnZUtleXNbXSBdXCIsYHZhbHVlWyR7aW5kZXh9XWAsc2V0KX1yZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSxzZXRbMV0pfXJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3Msc2V0LnN0b3JhZ2VLZXlzKX0pfWNvbnN0IHJlc3VsdD1PYmplY3Qua2V5cyh2YWx1ZSkubWFwKGFkZHI9Pntjb25zdCBzdG9yYWdlS2V5cz12YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLHN0b3JhZ2VLZXkpPT57YWNjdW1bc3RvcmFnZUtleV09dHJ1ZTtyZXR1cm4gYWNjdW19LHt9KTtyZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSl9KTtyZXN1bHQuc29ydCgoYSxiKT0+YS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSk7cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBmb3JtYXRBY2Nlc3NMaXN0KHZhbHVlKXtyZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKHNldD0+W3NldC5hZGRyZXNzLHNldC5zdG9yYWdlS2V5c10pfWZ1bmN0aW9uIF9zZXJpYWxpemVFaXAyOTMwKHRyYW5zYWN0aW9uLHNpZ25hdHVyZSl7Y29uc3QgZmllbGRzPVtmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZHx8MCxcImNoYWluSWRcIiksZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm5vbmNlfHwwLFwibm9uY2VcIiksZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc1ByaWNlfHwwLFwiZ2FzUHJpY2VcIiksZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0fHwwLFwiZ2FzTGltaXRcIiksdHJhbnNhY3Rpb24udG8hPW51bGw/Z2V0QWRkcmVzcyh0cmFuc2FjdGlvbi50byk6XCIweFwiLGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZXx8MCxcInZhbHVlXCIpLHRyYW5zYWN0aW9uLmRhdGF8fFwiMHhcIixmb3JtYXRBY2Nlc3NMaXN0KHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3R8fFtdKV07aWYoc2lnbmF0dXJlKXtjb25zdCBzaWc9c3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnJlY292ZXJ5UGFyYW0sXCJyZWNvdmVyeVBhcmFtXCIpKTtmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5yKSk7ZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucykpfXJldHVybiBoZXhDb25jYXQoW1wiMHgwMVwiLGVuY29kZShmaWVsZHMpXSl9ZnVuY3Rpb24gX3NlcmlhbGl6ZSh0cmFuc2FjdGlvbixzaWduYXR1cmUpe2NoZWNrUHJvcGVydGllcyh0cmFuc2FjdGlvbixhbGxvd2VkVHJhbnNhY3Rpb25LZXlzJDEpO2NvbnN0IHJhdz1bXTt0cmFuc2FjdGlvbkZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkSW5mbyl7bGV0IHZhbHVlPXRyYW5zYWN0aW9uW2ZpZWxkSW5mby5uYW1lXXx8W107Y29uc3Qgb3B0aW9ucz17fTtpZihmaWVsZEluZm8ubnVtZXJpYyl7b3B0aW9ucy5oZXhQYWQ9XCJsZWZ0XCJ9dmFsdWU9YXJyYXlpZnkoaGV4bGlmeSh2YWx1ZSxvcHRpb25zKSk7aWYoZmllbGRJbmZvLmxlbmd0aCYmdmFsdWUubGVuZ3RoIT09ZmllbGRJbmZvLmxlbmd0aCYmdmFsdWUubGVuZ3RoPjApe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIitmaWVsZEluZm8ubmFtZSxcInRyYW5zYWN0aW9uOlwiK2ZpZWxkSW5mby5uYW1lLHZhbHVlKX1pZihmaWVsZEluZm8ubWF4TGVuZ3RoKXt2YWx1ZT1zdHJpcFplcm9zKHZhbHVlKTtpZih2YWx1ZS5sZW5ndGg+ZmllbGRJbmZvLm1heExlbmd0aCl7bG9nZ2VyJGgudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiK2ZpZWxkSW5mby5uYW1lLFwidHJhbnNhY3Rpb246XCIrZmllbGRJbmZvLm5hbWUsdmFsdWUpfX1yYXcucHVzaChoZXhsaWZ5KHZhbHVlKSl9KTtsZXQgY2hhaW5JZD0wO2lmKHRyYW5zYWN0aW9uLmNoYWluSWQhPW51bGwpe2NoYWluSWQ9dHJhbnNhY3Rpb24uY2hhaW5JZDtpZih0eXBlb2YgY2hhaW5JZCE9PVwibnVtYmVyXCIpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24uY2hhaW5JZFwiLFwidHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvbil9fWVsc2UgaWYoc2lnbmF0dXJlJiYhaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSYmc2lnbmF0dXJlLnY+Mjgpe2NoYWluSWQ9TWF0aC5mbG9vcigoc2lnbmF0dXJlLnYtMzUpLzIpfWlmKGNoYWluSWQhPT0wKXtyYXcucHVzaChoZXhsaWZ5KGNoYWluSWQpKTtyYXcucHVzaChcIjB4XCIpO3Jhdy5wdXNoKFwiMHhcIil9aWYoIXNpZ25hdHVyZSl7cmV0dXJuIGVuY29kZShyYXcpfWNvbnN0IHNpZz1zcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO2xldCB2PTI3K3NpZy5yZWNvdmVyeVBhcmFtO2lmKGNoYWluSWQhPT0wKXtyYXcucG9wKCk7cmF3LnBvcCgpO3Jhdy5wb3AoKTt2Kz1jaGFpbklkKjIrODtpZihzaWcudj4yOCYmc2lnLnYhPT12KXtsb2dnZXIkaC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsXCJzaWduYXR1cmVcIixzaWduYXR1cmUpfX1lbHNlIGlmKHNpZy52IT09dil7bG9nZ2VyJGgudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLFwic2lnbmF0dXJlXCIsc2lnbmF0dXJlKX1yYXcucHVzaChoZXhsaWZ5KHYpKTtyYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5yKSkpO3Jhdy5wdXNoKHN0cmlwWmVyb3MoYXJyYXlpZnkoc2lnLnMpKSk7cmV0dXJuIGVuY29kZShyYXcpfWZ1bmN0aW9uIHNlcmlhbGl6ZSh0cmFuc2FjdGlvbixzaWduYXR1cmUpe2lmKHRyYW5zYWN0aW9uLnR5cGU9PW51bGwpe2lmKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QhPW51bGwpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcInVudHlwZWQgdHJhbnNhY3Rpb25zIGRvIG5vdCBzdXBwb3J0IGFjY2Vzc0xpc3Q7IGluY2x1ZGUgdHlwZTogMVwiLFwidHJhbnNhY3Rpb25cIix0cmFuc2FjdGlvbil9cmV0dXJuIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sc2lnbmF0dXJlKX1zd2l0Y2godHJhbnNhY3Rpb24udHlwZSl7Y2FzZSAxOnJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbixzaWduYXR1cmUpO2RlZmF1bHQ6YnJlYWt9cmV0dXJuIGxvZ2dlciRoLnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHJhbnNhY3Rpb24udHlwZX1gLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzZXJpYWxpemVUcmFuc2FjdGlvblwiLHRyYW5zYWN0aW9uVHlwZTp0cmFuc2FjdGlvbi50eXBlfSl9ZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChwYXlsb2FkKXtjb25zdCB0cmFuc2FjdGlvbj1kZWNvZGUocGF5bG9hZC5zbGljZSgxKSk7aWYodHJhbnNhY3Rpb24ubGVuZ3RoIT09OCYmdHJhbnNhY3Rpb24ubGVuZ3RoIT09MTEpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29tcG9uZW50IGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsXCJwYXlsb2FkXCIsaGV4bGlmeShwYXlsb2FkKSl9Y29uc3QgdHg9e3R5cGU6MSxjaGFpbklkOmhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxub25jZTpoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMV0pLnRvTnVtYmVyKCksZ2FzUHJpY2U6aGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzJdKSxnYXNMaW1pdDpoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pLHRvOmhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bNF0pLHZhbHVlOmhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls1XSksZGF0YTp0cmFuc2FjdGlvbls2XSxhY2Nlc3NMaXN0OmFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb25bN10pfTtpZih0cmFuc2FjdGlvbi5sZW5ndGg9PT04KXtyZXR1cm4gdHh9dHJ5e2NvbnN0IHJlY2lkPWhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls4XSkudG9OdW1iZXIoKTtpZihyZWNpZCE9PTAmJnJlY2lkIT09MSl7dGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlY2lkXCIpfXR4LnY9cmVjaWR9Y2F0Y2goZXJyb3Ipe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdiBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLFwidlwiLHRyYW5zYWN0aW9uWzhdKX10eC5yPWhleFplcm9QYWQodHJhbnNhY3Rpb25bOV0sMzIpO3R4LnM9aGV4WmVyb1BhZCh0cmFuc2FjdGlvblsxMF0sMzIpO3RyeXtjb25zdCBkaWdlc3Q9a2VjY2FrMjU2KF9zZXJpYWxpemVFaXAyOTMwKHR4KSk7dHguZnJvbT1yZWNvdmVyQWRkcmVzcyhkaWdlc3Qse3I6dHgucixzOnR4LnMscmVjb3ZlcnlQYXJhbTp0eC52fSl9Y2F0Y2goZXJyb3Ipe2NvbnNvbGUubG9nKGVycm9yKX10eC5oYXNoPWtlY2NhazI1NihwYXlsb2FkKTtyZXR1cm4gdHh9ZnVuY3Rpb24gX3BhcnNlKHJhd1RyYW5zYWN0aW9uKXtjb25zdCB0cmFuc2FjdGlvbj1kZWNvZGUocmF3VHJhbnNhY3Rpb24pO2lmKHRyYW5zYWN0aW9uLmxlbmd0aCE9PTkmJnRyYW5zYWN0aW9uLmxlbmd0aCE9PTYpe2xvZ2dlciRoLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsXCJyYXdUcmFuc2FjdGlvblwiLHJhd1RyYW5zYWN0aW9uKX1jb25zdCB0eD17bm9uY2U6aGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLGdhc1ByaWNlOmhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksZ2FzTGltaXQ6aGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzJdKSx0bzpoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzNdKSx2YWx1ZTpoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLGRhdGE6dHJhbnNhY3Rpb25bNV0sY2hhaW5JZDowfTtpZih0cmFuc2FjdGlvbi5sZW5ndGg9PT02KXtyZXR1cm4gdHh9dHJ5e3R4LnY9QmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb25bNl0pLnRvTnVtYmVyKCl9Y2F0Y2goZXJyb3Ipe2NvbnNvbGUubG9nKGVycm9yKTtyZXR1cm4gdHh9dHgucj1oZXhaZXJvUGFkKHRyYW5zYWN0aW9uWzddLDMyKTt0eC5zPWhleFplcm9QYWQodHJhbnNhY3Rpb25bOF0sMzIpO2lmKEJpZ051bWJlci5mcm9tKHR4LnIpLmlzWmVybygpJiZCaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSl7dHguY2hhaW5JZD10eC52O3R4LnY9MH1lbHNle3R4LmNoYWluSWQ9TWF0aC5mbG9vcigodHgudi0zNSkvMik7aWYodHguY2hhaW5JZDwwKXt0eC5jaGFpbklkPTB9bGV0IHJlY292ZXJ5UGFyYW09dHgudi0yNztjb25zdCByYXc9dHJhbnNhY3Rpb24uc2xpY2UoMCw2KTtpZih0eC5jaGFpbklkIT09MCl7cmF3LnB1c2goaGV4bGlmeSh0eC5jaGFpbklkKSk7cmF3LnB1c2goXCIweFwiKTtyYXcucHVzaChcIjB4XCIpO3JlY292ZXJ5UGFyYW0tPXR4LmNoYWluSWQqMis4fWNvbnN0IGRpZ2VzdD1rZWNjYWsyNTYoZW5jb2RlKHJhdykpO3RyeXt0eC5mcm9tPXJlY292ZXJBZGRyZXNzKGRpZ2VzdCx7cjpoZXhsaWZ5KHR4LnIpLHM6aGV4bGlmeSh0eC5zKSxyZWNvdmVyeVBhcmFtOnJlY292ZXJ5UGFyYW19KX1jYXRjaChlcnJvcil7Y29uc29sZS5sb2coZXJyb3IpfXR4Lmhhc2g9a2VjY2FrMjU2KHJhd1RyYW5zYWN0aW9uKX10eC50eXBlPW51bGw7cmV0dXJuIHR4fWZ1bmN0aW9uIHBhcnNlKHJhd1RyYW5zYWN0aW9uKXtjb25zdCBwYXlsb2FkPWFycmF5aWZ5KHJhd1RyYW5zYWN0aW9uKTtpZihwYXlsb2FkWzBdPjEyNyl7cmV0dXJuIF9wYXJzZShwYXlsb2FkKX1zd2l0Y2gocGF5bG9hZFswXSl7Y2FzZSAxOnJldHVybiBfcGFyc2VFaXAyOTMwKHBheWxvYWQpO2RlZmF1bHQ6YnJlYWt9cmV0dXJuIGxvZ2dlciRoLnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6ICR7cGF5bG9hZFswXX1gLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJwYXJzZVRyYW5zYWN0aW9uXCIsdHJhbnNhY3Rpb25UeXBlOnBheWxvYWRbMF19KX1jb25zdCB2ZXJzaW9uJGQ9XCJjb250cmFjdHMvNS4xLjFcIjtcInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyJDM9d2luZG93JiZ3aW5kb3cuX19hd2FpdGVyfHxmdW5jdGlvbih0aGlzQXJnLF9hcmd1bWVudHMsUCxnZW5lcmF0b3Ipe2Z1bmN0aW9uIGFkb3B0KHZhbHVlKXtyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQP3ZhbHVlOm5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpe3Jlc29sdmUodmFsdWUpfSl9cmV0dXJuIG5ldyhQfHwoUD1Qcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2Z1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gc3RlcChyZXN1bHQpe3Jlc3VsdC5kb25lP3Jlc29sdmUocmVzdWx0LnZhbHVlKTphZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChnZW5lcmF0b3I9Z2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsX2FyZ3VtZW50c3x8W10pKS5uZXh0KCkpfSl9O2NvbnN0IGxvZ2dlciRpPW5ldyBMb2dnZXIodmVyc2lvbiRkKTtjb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzJDI9e2NoYWluSWQ6dHJ1ZSxkYXRhOnRydWUsZnJvbTp0cnVlLGdhc0xpbWl0OnRydWUsZ2FzUHJpY2U6dHJ1ZSxub25jZTp0cnVlLHRvOnRydWUsdmFsdWU6dHJ1ZSx0eXBlOnRydWUsYWNjZXNzTGlzdDp0cnVlfTtmdW5jdGlvbiByZXNvbHZlTmFtZShyZXNvbHZlcixuYW1lT3JQcm9taXNlKXtyZXR1cm4gX19hd2FpdGVyJDModGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IG5hbWU9eWllbGQgbmFtZU9yUHJvbWlzZTt0cnl7cmV0dXJuIGdldEFkZHJlc3MobmFtZSl9Y2F0Y2goZXJyb3Ipe31pZighcmVzb2x2ZXIpe2xvZ2dlciRpLnRocm93RXJyb3IoXCJhIHByb3ZpZGVyIG9yIHNpZ25lciBpcyBuZWVkZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXNcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwicmVzb2x2ZU5hbWVcIn0pfWNvbnN0IGFkZHJlc3M9eWllbGQgcmVzb2x2ZXIucmVzb2x2ZU5hbWUobmFtZSk7aWYoYWRkcmVzcz09bnVsbCl7bG9nZ2VyJGkudGhyb3dBcmd1bWVudEVycm9yKFwicmVzb2x2ZXIgb3IgYWRkciBpcyBub3QgY29uZmlndXJlZCBmb3IgRU5TIG5hbWVcIixcIm5hbWVcIixuYW1lKX1yZXR1cm4gYWRkcmVzc30pfWZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsdmFsdWUscGFyYW1UeXBlKXtyZXR1cm4gX19hd2FpdGVyJDModGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2lmKEFycmF5LmlzQXJyYXkocGFyYW1UeXBlKSl7cmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKHBhcmFtVHlwZS5tYXAoKHBhcmFtVHlwZSxpbmRleCk9PntyZXR1cm4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlcixBcnJheS5pc0FycmF5KHZhbHVlKT92YWx1ZVtpbmRleF06dmFsdWVbcGFyYW1UeXBlLm5hbWVdLHBhcmFtVHlwZSl9KSl9aWYocGFyYW1UeXBlLnR5cGU9PT1cImFkZHJlc3NcIil7cmV0dXJuIHlpZWxkIHJlc29sdmVOYW1lKHJlc29sdmVyLHZhbHVlKX1pZihwYXJhbVR5cGUudHlwZT09PVwidHVwbGVcIil7cmV0dXJuIHlpZWxkIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsdmFsdWUscGFyYW1UeXBlLmNvbXBvbmVudHMpfWlmKHBhcmFtVHlwZS5iYXNlVHlwZT09PVwiYXJyYXlcIil7aWYoIUFycmF5LmlzQXJyYXkodmFsdWUpKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgYXJyYXlcIikpfXJldHVybiB5aWVsZCBQcm9taXNlLmFsbCh2YWx1ZS5tYXAodj0+cmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlcix2LHBhcmFtVHlwZS5hcnJheUNoaWxkcmVuKSkpfXJldHVybiB2YWx1ZX0pfWZ1bmN0aW9uIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsZnJhZ21lbnQsYXJncyl7cmV0dXJuIF9fYXdhaXRlciQzKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtsZXQgb3ZlcnJpZGVzPXt9O2lmKGFyZ3MubGVuZ3RoPT09ZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCsxJiZ0eXBlb2YgYXJnc1thcmdzLmxlbmd0aC0xXT09PVwib2JqZWN0XCIpe292ZXJyaWRlcz1zaGFsbG93Q29weShhcmdzLnBvcCgpKX1sb2dnZXIkaS5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCxcInBhc3NlZCB0byBjb250cmFjdFwiKTtpZihjb250cmFjdC5zaWduZXIpe2lmKG92ZXJyaWRlcy5mcm9tKXtvdmVycmlkZXMuZnJvbT1yZXNvbHZlUHJvcGVydGllcyh7b3ZlcnJpZGU6cmVzb2x2ZU5hbWUoY29udHJhY3Quc2lnbmVyLG92ZXJyaWRlcy5mcm9tKSxzaWduZXI6Y29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKX0pLnRoZW4oY2hlY2s9Pl9fYXdhaXRlciQzKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZihnZXRBZGRyZXNzKGNoZWNrLnNpZ25lcikhPT1jaGVjay5vdmVycmlkZSl7bG9nZ2VyJGkudGhyb3dFcnJvcihcIkNvbnRyYWN0IHdpdGggYSBTaWduZXIgY2Fubm90IG92ZXJyaWRlIGZyb21cIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwib3ZlcnJpZGVzLmZyb21cIn0pfXJldHVybiBjaGVjay5vdmVycmlkZX0pKX1lbHNle292ZXJyaWRlcy5mcm9tPWNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKCl9fWVsc2UgaWYob3ZlcnJpZGVzLmZyb20pe292ZXJyaWRlcy5mcm9tPXJlc29sdmVOYW1lKGNvbnRyYWN0LnByb3ZpZGVyLG92ZXJyaWRlcy5mcm9tKX1jb25zdCByZXNvbHZlZD15aWVsZCByZXNvbHZlUHJvcGVydGllcyh7YXJnczpyZXNvbHZlQWRkcmVzc2VzKGNvbnRyYWN0LnNpZ25lcnx8Y29udHJhY3QucHJvdmlkZXIsYXJncyxmcmFnbWVudC5pbnB1dHMpLGFkZHJlc3M6Y29udHJhY3QucmVzb2x2ZWRBZGRyZXNzLG92ZXJyaWRlczpyZXNvbHZlUHJvcGVydGllcyhvdmVycmlkZXMpfHx7fX0pO2NvbnN0IGRhdGE9Y29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCxyZXNvbHZlZC5hcmdzKTtjb25zdCB0eD17ZGF0YTpkYXRhLHRvOnJlc29sdmVkLmFkZHJlc3N9O2NvbnN0IHJvPXJlc29sdmVkLm92ZXJyaWRlcztpZihyby5ub25jZSE9bnVsbCl7dHgubm9uY2U9QmlnTnVtYmVyLmZyb20ocm8ubm9uY2UpLnRvTnVtYmVyKCl9aWYocm8uZ2FzTGltaXQhPW51bGwpe3R4Lmdhc0xpbWl0PUJpZ051bWJlci5mcm9tKHJvLmdhc0xpbWl0KX1pZihyby5nYXNQcmljZSE9bnVsbCl7dHguZ2FzUHJpY2U9QmlnTnVtYmVyLmZyb20ocm8uZ2FzUHJpY2UpfWlmKHJvLmZyb20hPW51bGwpe3R4LmZyb209cm8uZnJvbX1pZihyby50eXBlIT1udWxsKXt0eC50eXBlPXJvLnR5cGV9aWYocm8uYWNjZXNzTGlzdCE9bnVsbCl7dHguYWNjZXNzTGlzdD1hY2Nlc3NMaXN0aWZ5KHJvLmFjY2Vzc0xpc3QpfWlmKHR4Lmdhc0xpbWl0PT1udWxsJiZmcmFnbWVudC5nYXMhPW51bGwpe2xldCBpbnRyaW5zaWM9MjFlMztjb25zdCBieXRlcz1hcnJheWlmeShkYXRhKTtmb3IobGV0IGk9MDtpPGJ5dGVzLmxlbmd0aDtpKyspe2ludHJpbnNpYys9NDtpZihieXRlc1tpXSl7aW50cmluc2ljKz02NH19dHguZ2FzTGltaXQ9QmlnTnVtYmVyLmZyb20oZnJhZ21lbnQuZ2FzKS5hZGQoaW50cmluc2ljKX1pZihyby52YWx1ZSl7Y29uc3Qgcm9WYWx1ZT1CaWdOdW1iZXIuZnJvbShyby52YWx1ZSk7aWYoIXJvVmFsdWUuaXNaZXJvKCkmJiFmcmFnbWVudC5wYXlhYmxlKXtsb2dnZXIkaS50aHJvd0Vycm9yKFwibm9uLXBheWFibGUgbWV0aG9kIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJvdmVycmlkZXMudmFsdWVcIix2YWx1ZTpvdmVycmlkZXMudmFsdWV9KX10eC52YWx1ZT1yb1ZhbHVlfWRlbGV0ZSBvdmVycmlkZXMubm9uY2U7ZGVsZXRlIG92ZXJyaWRlcy5nYXNMaW1pdDtkZWxldGUgb3ZlcnJpZGVzLmdhc1ByaWNlO2RlbGV0ZSBvdmVycmlkZXMuZnJvbTtkZWxldGUgb3ZlcnJpZGVzLnZhbHVlO2RlbGV0ZSBvdmVycmlkZXMudHlwZTtkZWxldGUgb3ZlcnJpZGVzLmFjY2Vzc0xpc3Q7Y29uc3QgbGVmdG92ZXJzPU9iamVjdC5rZXlzKG92ZXJyaWRlcykuZmlsdGVyKGtleT0+b3ZlcnJpZGVzW2tleV0hPW51bGwpO2lmKGxlZnRvdmVycy5sZW5ndGgpe2xvZ2dlciRpLnRocm93RXJyb3IoYGNhbm5vdCBvdmVycmlkZSAke2xlZnRvdmVycy5tYXAobD0+SlNPTi5zdHJpbmdpZnkobCkpLmpvaW4oXCIsXCIpfWAsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm92ZXJyaWRlc1wiLG92ZXJyaWRlczpsZWZ0b3ZlcnN9KX1yZXR1cm4gdHh9KX1mdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LGZyYWdtZW50KXtyZXR1cm4gZnVuY3Rpb24oLi4uYXJncyl7cmV0dXJuIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsZnJhZ21lbnQsYXJncyl9fWZ1bmN0aW9uIGJ1aWxkRXN0aW1hdGUoY29udHJhY3QsZnJhZ21lbnQpe2NvbnN0IHNpZ25lck9yUHJvdmlkZXI9Y29udHJhY3Quc2lnbmVyfHxjb250cmFjdC5wcm92aWRlcjtyZXR1cm4gZnVuY3Rpb24oLi4uYXJncyl7cmV0dXJuIF9fYXdhaXRlciQzKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZighc2lnbmVyT3JQcm92aWRlcil7bG9nZ2VyJGkudGhyb3dFcnJvcihcImVzdGltYXRlIHJlcXVpcmUgYSBwcm92aWRlciBvciBzaWduZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiZXN0aW1hdGVHYXNcIn0pfWNvbnN0IHR4PXlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsZnJhZ21lbnQsYXJncyk7cmV0dXJuIHlpZWxkIHNpZ25lck9yUHJvdmlkZXIuZXN0aW1hdGVHYXModHgpfSl9fWZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCxmcmFnbWVudCxjb2xsYXBzZVNpbXBsZSl7Y29uc3Qgc2lnbmVyT3JQcm92aWRlcj1jb250cmFjdC5zaWduZXJ8fGNvbnRyYWN0LnByb3ZpZGVyO3JldHVybiBmdW5jdGlvbiguLi5hcmdzKXtyZXR1cm4gX19hd2FpdGVyJDModGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2xldCBibG9ja1RhZz11bmRlZmluZWQ7aWYoYXJncy5sZW5ndGg9PT1mcmFnbWVudC5pbnB1dHMubGVuZ3RoKzEmJnR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoLTFdPT09XCJvYmplY3RcIil7Y29uc3Qgb3ZlcnJpZGVzPXNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO2lmKG92ZXJyaWRlcy5ibG9ja1RhZyE9bnVsbCl7YmxvY2tUYWc9eWllbGQgb3ZlcnJpZGVzLmJsb2NrVGFnfWRlbGV0ZSBvdmVycmlkZXMuYmxvY2tUYWc7YXJncy5wdXNoKG92ZXJyaWRlcyl9aWYoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24hPW51bGwpe3lpZWxkIGNvbnRyYWN0Ll9kZXBsb3llZChibG9ja1RhZyl9Y29uc3QgdHg9eWllbGQgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCxmcmFnbWVudCxhcmdzKTtjb25zdCByZXN1bHQ9eWllbGQgc2lnbmVyT3JQcm92aWRlci5jYWxsKHR4LGJsb2NrVGFnKTt0cnl7bGV0IHZhbHVlPWNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCxyZXN1bHQpO2lmKGNvbGxhcHNlU2ltcGxlJiZmcmFnbWVudC5vdXRwdXRzLmxlbmd0aD09PTEpe3ZhbHVlPXZhbHVlWzBdfXJldHVybiB2YWx1ZX1jYXRjaChlcnJvcil7aWYoZXJyb3IuY29kZT09PUxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pe2Vycm9yLmFkZHJlc3M9Y29udHJhY3QuYWRkcmVzcztlcnJvci5hcmdzPWFyZ3M7ZXJyb3IudHJhbnNhY3Rpb249dHh9dGhyb3cgZXJyb3J9fSl9fWZ1bmN0aW9uIGJ1aWxkU2VuZChjb250cmFjdCxmcmFnbWVudCl7cmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3Mpe3JldHVybiBfX2F3YWl0ZXIkMyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYoIWNvbnRyYWN0LnNpZ25lcil7bG9nZ2VyJGkudGhyb3dFcnJvcihcInNlbmRpbmcgYSB0cmFuc2FjdGlvbiByZXF1aXJlcyBhIHNpZ25lclwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzZW5kVHJhbnNhY3Rpb25cIn0pfWlmKGNvbnRyYWN0LmRlcGxveVRyYW5zYWN0aW9uIT1udWxsKXt5aWVsZCBjb250cmFjdC5fZGVwbG95ZWQoKX1jb25zdCB0eFJlcXVlc3Q9eWllbGQgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCxmcmFnbWVudCxhcmdzKTtjb25zdCB0eD15aWVsZCBjb250cmFjdC5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHR4UmVxdWVzdCk7Y29uc3Qgd2FpdD10eC53YWl0LmJpbmQodHgpO3R4LndhaXQ9KGNvbmZpcm1hdGlvbnM9PntyZXR1cm4gd2FpdChjb25maXJtYXRpb25zKS50aGVuKHJlY2VpcHQ9PntyZWNlaXB0LmV2ZW50cz1yZWNlaXB0LmxvZ3MubWFwKGxvZz0+e2xldCBldmVudD1kZWVwQ29weShsb2cpO2xldCBwYXJzZWQ9bnVsbDt0cnl7cGFyc2VkPWNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpfWNhdGNoKGUpe31pZihwYXJzZWQpe2V2ZW50LmFyZ3M9cGFyc2VkLmFyZ3M7ZXZlbnQuZGVjb2RlPSgoZGF0YSx0b3BpY3MpPT57cmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhwYXJzZWQuZXZlbnRGcmFnbWVudCxkYXRhLHRvcGljcyl9KTtldmVudC5ldmVudD1wYXJzZWQubmFtZTtldmVudC5ldmVudFNpZ25hdHVyZT1wYXJzZWQuc2lnbmF0dXJlfWV2ZW50LnJlbW92ZUxpc3RlbmVyPSgoKT0+e3JldHVybiBjb250cmFjdC5wcm92aWRlcn0pO2V2ZW50LmdldEJsb2NrPSgoKT0+e3JldHVybiBjb250cmFjdC5wcm92aWRlci5nZXRCbG9jayhyZWNlaXB0LmJsb2NrSGFzaCl9KTtldmVudC5nZXRUcmFuc2FjdGlvbj0oKCk9PntyZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVjZWlwdC50cmFuc2FjdGlvbkhhc2gpfSk7ZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0PSgoKT0+e3JldHVybiBQcm9taXNlLnJlc29sdmUocmVjZWlwdCl9KTtyZXR1cm4gZXZlbnR9KTtyZXR1cm4gcmVjZWlwdH0pfSk7cmV0dXJuIHR4fSl9fWZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCxmcmFnbWVudCxjb2xsYXBzZVNpbXBsZSl7aWYoZnJhZ21lbnQuY29uc3RhbnQpe3JldHVybiBidWlsZENhbGwoY29udHJhY3QsZnJhZ21lbnQsY29sbGFwc2VTaW1wbGUpfXJldHVybiBidWlsZFNlbmQoY29udHJhY3QsZnJhZ21lbnQpfWZ1bmN0aW9uIGdldEV2ZW50VGFnKGZpbHRlcil7aWYoZmlsdGVyLmFkZHJlc3MmJihmaWx0ZXIudG9waWNzPT1udWxsfHxmaWx0ZXIudG9waWNzLmxlbmd0aD09PTApKXtyZXR1cm5cIipcIn1yZXR1cm4oZmlsdGVyLmFkZHJlc3N8fFwiKlwiKStcIkBcIisoZmlsdGVyLnRvcGljcz9maWx0ZXIudG9waWNzLm1hcCh0b3BpYz0+e2lmKEFycmF5LmlzQXJyYXkodG9waWMpKXtyZXR1cm4gdG9waWMuam9pbihcInxcIil9cmV0dXJuIHRvcGljfSkuam9pbihcIjpcIik6XCJcIil9Y2xhc3MgUnVubmluZ0V2ZW50e2NvbnN0cnVjdG9yKHRhZyxmaWx0ZXIpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJ0YWdcIix0YWcpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJmaWx0ZXJcIixmaWx0ZXIpO3RoaXMuX2xpc3RlbmVycz1bXX1hZGRMaXN0ZW5lcihsaXN0ZW5lcixvbmNlKXt0aGlzLl9saXN0ZW5lcnMucHVzaCh7bGlzdGVuZXI6bGlzdGVuZXIsb25jZTpvbmNlfSl9cmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpe2xldCBkb25lPWZhbHNlO3RoaXMuX2xpc3RlbmVycz10aGlzLl9saXN0ZW5lcnMuZmlsdGVyKGl0ZW09PntpZihkb25lfHxpdGVtLmxpc3RlbmVyIT09bGlzdGVuZXIpe3JldHVybiB0cnVlfWRvbmU9dHJ1ZTtyZXR1cm4gZmFsc2V9KX1yZW1vdmVBbGxMaXN0ZW5lcnMoKXt0aGlzLl9saXN0ZW5lcnM9W119bGlzdGVuZXJzKCl7cmV0dXJuIHRoaXMuX2xpc3RlbmVycy5tYXAoaT0+aS5saXN0ZW5lcil9bGlzdGVuZXJDb3VudCgpe3JldHVybiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RofXJ1bihhcmdzKXtjb25zdCBsaXN0ZW5lckNvdW50PXRoaXMubGlzdGVuZXJDb3VudCgpO3RoaXMuX2xpc3RlbmVycz10aGlzLl9saXN0ZW5lcnMuZmlsdGVyKGl0ZW09Pntjb25zdCBhcmdzQ29weT1hcmdzLnNsaWNlKCk7c2V0VGltZW91dCgoKT0+e2l0ZW0ubGlzdGVuZXIuYXBwbHkodGhpcyxhcmdzQ29weSl9LDApO3JldHVybiFpdGVtLm9uY2V9KTtyZXR1cm4gbGlzdGVuZXJDb3VudH1wcmVwYXJlRXZlbnQoZXZlbnQpe31nZXRFbWl0KGV2ZW50KXtyZXR1cm5bZXZlbnRdfX1jbGFzcyBFcnJvclJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudHtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiZXJyb3JcIixudWxsKX19Y2xhc3MgRnJhZ21lbnRSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnR7Y29uc3RydWN0b3IoYWRkcmVzcyxjb250cmFjdEludGVyZmFjZSxmcmFnbWVudCx0b3BpY3Mpe2NvbnN0IGZpbHRlcj17YWRkcmVzczphZGRyZXNzfTtsZXQgdG9waWM9Y29udHJhY3RJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCk7aWYodG9waWNzKXtpZih0b3BpYyE9PXRvcGljc1swXSl7bG9nZ2VyJGkudGhyb3dBcmd1bWVudEVycm9yKFwidG9waWMgbWlzbWF0Y2hcIixcInRvcGljc1wiLHRvcGljcyl9ZmlsdGVyLnRvcGljcz10b3BpY3Muc2xpY2UoKX1lbHNle2ZpbHRlci50b3BpY3M9W3RvcGljXX1zdXBlcihnZXRFdmVudFRhZyhmaWx0ZXIpLGZpbHRlcik7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIixhZGRyZXNzKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsY29udHJhY3RJbnRlcmZhY2UpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJmcmFnbWVudFwiLGZyYWdtZW50KX1wcmVwYXJlRXZlbnQoZXZlbnQpe3N1cGVyLnByZXBhcmVFdmVudChldmVudCk7ZXZlbnQuZXZlbnQ9dGhpcy5mcmFnbWVudC5uYW1lO2V2ZW50LmV2ZW50U2lnbmF0dXJlPXRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7ZXZlbnQuZGVjb2RlPSgoZGF0YSx0b3BpY3MpPT57cmV0dXJuIHRoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHRoaXMuZnJhZ21lbnQsZGF0YSx0b3BpY3MpfSk7dHJ5e2V2ZW50LmFyZ3M9dGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2codGhpcy5mcmFnbWVudCxldmVudC5kYXRhLGV2ZW50LnRvcGljcyl9Y2F0Y2goZXJyb3Ipe2V2ZW50LmFyZ3M9bnVsbDtldmVudC5kZWNvZGVFcnJvcj1lcnJvcn19Z2V0RW1pdChldmVudCl7Y29uc3QgZXJyb3JzPWNoZWNrUmVzdWx0RXJyb3JzKGV2ZW50LmFyZ3MpO2lmKGVycm9ycy5sZW5ndGgpe3Rocm93IGVycm9yc1swXS5lcnJvcn1jb25zdCBhcmdzPShldmVudC5hcmdzfHxbXSkuc2xpY2UoKTthcmdzLnB1c2goZXZlbnQpO3JldHVybiBhcmdzfX1jbGFzcyBXaWxkY2FyZFJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudHtjb25zdHJ1Y3RvcihhZGRyZXNzLGNvbnRyYWN0SW50ZXJmYWNlKXtzdXBlcihcIipcIix7YWRkcmVzczphZGRyZXNzfSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIixhZGRyZXNzKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsY29udHJhY3RJbnRlcmZhY2UpfXByZXBhcmVFdmVudChldmVudCl7c3VwZXIucHJlcGFyZUV2ZW50KGV2ZW50KTt0cnl7Y29uc3QgcGFyc2VkPXRoaXMuaW50ZXJmYWNlLnBhcnNlTG9nKGV2ZW50KTtldmVudC5ldmVudD1wYXJzZWQubmFtZTtldmVudC5ldmVudFNpZ25hdHVyZT1wYXJzZWQuc2lnbmF0dXJlO2V2ZW50LmRlY29kZT0oKGRhdGEsdG9waWNzKT0+e3JldHVybiB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhwYXJzZWQuZXZlbnRGcmFnbWVudCxkYXRhLHRvcGljcyl9KTtldmVudC5hcmdzPXBhcnNlZC5hcmdzfWNhdGNoKGVycm9yKXt9fX1jbGFzcyBCYXNlQ29udHJhY3R7Y29uc3RydWN0b3IoYWRkcmVzc09yTmFtZSxjb250cmFjdEludGVyZmFjZSxzaWduZXJPclByb3ZpZGVyKXtsb2dnZXIkaS5jaGVja05ldyhuZXcudGFyZ2V0LENvbnRyYWN0KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsZ2V0U3RhdGljKG5ldy50YXJnZXQsXCJnZXRJbnRlcmZhY2VcIikoY29udHJhY3RJbnRlcmZhY2UpKTtpZihzaWduZXJPclByb3ZpZGVyPT1udWxsKXtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJvdmlkZXJcIixudWxsKTtkZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIsbnVsbCl9ZWxzZSBpZihTaWduZXIuaXNTaWduZXIoc2lnbmVyT3JQcm92aWRlcikpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHNpZ25lck9yUHJvdmlkZXIucHJvdmlkZXJ8fG51bGwpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJzaWduZXJcIixzaWduZXJPclByb3ZpZGVyKX1lbHNlIGlmKFByb3ZpZGVyLmlzUHJvdmlkZXIoc2lnbmVyT3JQcm92aWRlcikpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHNpZ25lck9yUHJvdmlkZXIpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJzaWduZXJcIixudWxsKX1lbHNle2xvZ2dlciRpLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsXCJzaWduZXJPclByb3ZpZGVyXCIsc2lnbmVyT3JQcm92aWRlcil9ZGVmaW5lUmVhZE9ubHkodGhpcyxcImNhbGxTdGF0aWNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImVzdGltYXRlR2FzXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJmdW5jdGlvbnNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInBvcHVsYXRlVHJhbnNhY3Rpb25cIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImZpbHRlcnNcIix7fSk7e2NvbnN0IHVuaXF1ZUZpbHRlcnM9e307T2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZXZlbnRzKS5mb3JFYWNoKGV2ZW50U2lnbmF0dXJlPT57Y29uc3QgZXZlbnQ9dGhpcy5pbnRlcmZhY2UuZXZlbnRzW2V2ZW50U2lnbmF0dXJlXTtkZWZpbmVSZWFkT25seSh0aGlzLmZpbHRlcnMsZXZlbnRTaWduYXR1cmUsKC4uLmFyZ3MpPT57cmV0dXJue2FkZHJlc3M6dGhpcy5hZGRyZXNzLHRvcGljczp0aGlzLmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZXZlbnQsYXJncyl9fSk7aWYoIXVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0pe3VuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV09W119dW5pcXVlRmlsdGVyc1tldmVudC5uYW1lXS5wdXNoKGV2ZW50U2lnbmF0dXJlKX0pO09iamVjdC5rZXlzKHVuaXF1ZUZpbHRlcnMpLmZvckVhY2gobmFtZT0+e2NvbnN0IGZpbHRlcnM9dW5pcXVlRmlsdGVyc1tuYW1lXTtpZihmaWx0ZXJzLmxlbmd0aD09PTEpe2RlZmluZVJlYWRPbmx5KHRoaXMuZmlsdGVycyxuYW1lLHRoaXMuZmlsdGVyc1tmaWx0ZXJzWzBdXSl9ZWxzZXtsb2dnZXIkaS53YXJuKGBEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiAke25hbWV9ICgke2ZpbHRlcnMuam9pbihcIiwgXCIpfSlgKX19KX1kZWZpbmVSZWFkT25seSh0aGlzLFwiX3J1bm5pbmdFdmVudHNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl93cmFwcGVkRW1pdHNcIix7fSk7aWYoYWRkcmVzc09yTmFtZT09bnVsbCl7bG9nZ2VyJGkudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb250cmFjdCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsXCJhZGRyZXNzT3JOYW1lXCIsYWRkcmVzc09yTmFtZSl9ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIixhZGRyZXNzT3JOYW1lKTtpZih0aGlzLnByb3ZpZGVyKXtkZWZpbmVSZWFkT25seSh0aGlzLFwicmVzb2x2ZWRBZGRyZXNzXCIscmVzb2x2ZU5hbWUodGhpcy5wcm92aWRlcixhZGRyZXNzT3JOYW1lKSl9ZWxzZXt0cnl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInJlc29sdmVkQWRkcmVzc1wiLFByb21pc2UucmVzb2x2ZShnZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpKSl9Y2F0Y2goZXJyb3Ipe2xvZ2dlciRpLnRocm93RXJyb3IoXCJwcm92aWRlciBpcyByZXF1aXJlZCB0byB1c2UgRU5TIG5hbWUgYXMgY29udHJhY3QgYWRkcmVzc1wiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJuZXcgQ29udHJhY3RcIn0pfX1jb25zdCB1bmlxdWVOYW1lcz17fTtjb25zdCB1bmlxdWVTaWduYXR1cmVzPXt9O09iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmZ1bmN0aW9ucykuZm9yRWFjaChzaWduYXR1cmU9Pntjb25zdCBmcmFnbWVudD10aGlzLmludGVyZmFjZS5mdW5jdGlvbnNbc2lnbmF0dXJlXTtpZih1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0pe2xvZ2dlciRpLndhcm4oYER1cGxpY2F0ZSBBQkkgZW50cnkgZm9yICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCk7cmV0dXJufXVuaXF1ZVNpZ25hdHVyZXNbc2lnbmF0dXJlXT10cnVlO3tjb25zdCBuYW1lPWZyYWdtZW50Lm5hbWU7aWYoIXVuaXF1ZU5hbWVzW25hbWVdKXt1bmlxdWVOYW1lc1tuYW1lXT1bXX11bmlxdWVOYW1lc1tuYW1lXS5wdXNoKHNpZ25hdHVyZSl9aWYodGhpc1tzaWduYXR1cmVdPT1udWxsKXtkZWZpbmVSZWFkT25seSh0aGlzLHNpZ25hdHVyZSxidWlsZERlZmF1bHQodGhpcyxmcmFnbWVudCx0cnVlKSl9aWYodGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsc2lnbmF0dXJlLGJ1aWxkRGVmYXVsdCh0aGlzLGZyYWdtZW50LGZhbHNlKSl9aWYodGhpcy5jYWxsU3RhdGljW3NpZ25hdHVyZV09PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMuY2FsbFN0YXRpYyxzaWduYXR1cmUsYnVpbGRDYWxsKHRoaXMsZnJhZ21lbnQsdHJ1ZSkpfWlmKHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdPT1udWxsKXtkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sc2lnbmF0dXJlLGJ1aWxkUG9wdWxhdGUodGhpcyxmcmFnbWVudCkpfWlmKHRoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcy5lc3RpbWF0ZUdhcyxzaWduYXR1cmUsYnVpbGRFc3RpbWF0ZSh0aGlzLGZyYWdtZW50KSl9fSk7T2JqZWN0LmtleXModW5pcXVlTmFtZXMpLmZvckVhY2gobmFtZT0+e2NvbnN0IHNpZ25hdHVyZXM9dW5pcXVlTmFtZXNbbmFtZV07aWYoc2lnbmF0dXJlcy5sZW5ndGg+MSl7cmV0dXJufWNvbnN0IHNpZ25hdHVyZT1zaWduYXR1cmVzWzBdO3RyeXtpZih0aGlzW25hbWVdPT1udWxsKXtkZWZpbmVSZWFkT25seSh0aGlzLG5hbWUsdGhpc1tzaWduYXR1cmVdKX19Y2F0Y2goZSl7fWlmKHRoaXMuZnVuY3Rpb25zW25hbWVdPT1udWxsKXtkZWZpbmVSZWFkT25seSh0aGlzLmZ1bmN0aW9ucyxuYW1lLHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pfWlmKHRoaXMuY2FsbFN0YXRpY1tuYW1lXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLG5hbWUsdGhpcy5jYWxsU3RhdGljW3NpZ25hdHVyZV0pfWlmKHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltuYW1lXT09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLG5hbWUsdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pfWlmKHRoaXMuZXN0aW1hdGVHYXNbbmFtZV09PW51bGwpe2RlZmluZVJlYWRPbmx5KHRoaXMuZXN0aW1hdGVHYXMsbmFtZSx0aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV0pfX0pfXN0YXRpYyBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pe3JldHVybiBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pfXN0YXRpYyBnZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2Upe2lmKEludGVyZmFjZS5pc0ludGVyZmFjZShjb250cmFjdEludGVyZmFjZSkpe3JldHVybiBjb250cmFjdEludGVyZmFjZX1yZXR1cm4gbmV3IEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSl9ZGVwbG95ZWQoKXtyZXR1cm4gdGhpcy5fZGVwbG95ZWQoKX1fZGVwbG95ZWQoYmxvY2tUYWcpe2lmKCF0aGlzLl9kZXBsb3llZFByb21pc2Upe2lmKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pe3RoaXMuX2RlcGxveWVkUHJvbWlzZT10aGlzLmRlcGxveVRyYW5zYWN0aW9uLndhaXQoKS50aGVuKCgpPT57cmV0dXJuIHRoaXN9KX1lbHNle3RoaXMuX2RlcGxveWVkUHJvbWlzZT10aGlzLnByb3ZpZGVyLmdldENvZGUodGhpcy5hZGRyZXNzLGJsb2NrVGFnKS50aGVuKGNvZGU9PntpZihjb2RlPT09XCIweFwiKXtsb2dnZXIkaS50aHJvd0Vycm9yKFwiY29udHJhY3Qgbm90IGRlcGxveWVkXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se2NvbnRyYWN0QWRkcmVzczp0aGlzLmFkZHJlc3Msb3BlcmF0aW9uOlwiZ2V0RGVwbG95ZWRcIn0pfXJldHVybiB0aGlzfSl9fXJldHVybiB0aGlzLl9kZXBsb3llZFByb21pc2V9ZmFsbGJhY2sob3ZlcnJpZGVzKXtpZighdGhpcy5zaWduZXIpe2xvZ2dlciRpLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYSBzaWduZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2VuZFRyYW5zYWN0aW9uKGZhbGxiYWNrKVwifSl9Y29uc3QgdHg9c2hhbGxvd0NvcHkob3ZlcnJpZGVzfHx7fSk7W1wiZnJvbVwiLFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbihrZXkpe2lmKHR4W2tleV09PW51bGwpe3JldHVybn1sb2dnZXIkaS50aHJvd0Vycm9yKFwiY2Fubm90IG92ZXJyaWRlIFwiK2tleSxMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOmtleX0pfSk7dHgudG89dGhpcy5yZXNvbHZlZEFkZHJlc3M7cmV0dXJuIHRoaXMuZGVwbG95ZWQoKS50aGVuKCgpPT57cmV0dXJuIHRoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eCl9KX1jb25uZWN0KHNpZ25lck9yUHJvdmlkZXIpe2lmKHR5cGVvZiBzaWduZXJPclByb3ZpZGVyPT09XCJzdHJpbmdcIil7c2lnbmVyT3JQcm92aWRlcj1uZXcgVm9pZFNpZ25lcihzaWduZXJPclByb3ZpZGVyLHRoaXMucHJvdmlkZXIpfWNvbnN0IGNvbnRyYWN0PW5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYWRkcmVzcyx0aGlzLmludGVyZmFjZSxzaWduZXJPclByb3ZpZGVyKTtpZih0aGlzLmRlcGxveVRyYW5zYWN0aW9uKXtkZWZpbmVSZWFkT25seShjb250cmFjdCxcImRlcGxveVRyYW5zYWN0aW9uXCIsdGhpcy5kZXBsb3lUcmFuc2FjdGlvbil9cmV0dXJuIGNvbnRyYWN0fWF0dGFjaChhZGRyZXNzT3JOYW1lKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoYWRkcmVzc09yTmFtZSx0aGlzLmludGVyZmFjZSx0aGlzLnNpZ25lcnx8dGhpcy5wcm92aWRlcil9c3RhdGljIGlzSW5kZXhlZCh2YWx1ZSl7cmV0dXJuIEluZGV4ZWQuaXNJbmRleGVkKHZhbHVlKX1fbm9ybWFsaXplUnVubmluZ0V2ZW50KHJ1bm5pbmdFdmVudCl7aWYodGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSl7cmV0dXJuIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ119cmV0dXJuIHJ1bm5pbmdFdmVudH1fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSl7aWYodHlwZW9mIGV2ZW50TmFtZT09PVwic3RyaW5nXCIpe2lmKGV2ZW50TmFtZT09PVwiZXJyb3JcIil7cmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRXJyb3JSdW5uaW5nRXZlbnQpfWlmKGV2ZW50TmFtZT09PVwiZXZlbnRcIil7cmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KFwiZXZlbnRcIixudWxsKSl9aWYoZXZlbnROYW1lPT09XCIqXCIpe3JldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcyx0aGlzLmludGVyZmFjZSkpfWNvbnN0IGZyYWdtZW50PXRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50TmFtZSk7cmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRnJhZ21lbnRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLHRoaXMuaW50ZXJmYWNlLGZyYWdtZW50KSl9aWYoZXZlbnROYW1lLnRvcGljcyYmZXZlbnROYW1lLnRvcGljcy5sZW5ndGg+MCl7dHJ5e2NvbnN0IHRvcGljPWV2ZW50TmFtZS50b3BpY3NbMF07aWYodHlwZW9mIHRvcGljIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0b3BpY1wiKX1jb25zdCBmcmFnbWVudD10aGlzLmludGVyZmFjZS5nZXRFdmVudCh0b3BpYyk7cmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRnJhZ21lbnRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLHRoaXMuaW50ZXJmYWNlLGZyYWdtZW50LGV2ZW50TmFtZS50b3BpY3MpKX1jYXRjaChlcnJvcil7fWNvbnN0IGZpbHRlcj17YWRkcmVzczp0aGlzLmFkZHJlc3MsdG9waWNzOmV2ZW50TmFtZS50b3BpY3N9O3JldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFJ1bm5pbmdFdmVudChnZXRFdmVudFRhZyhmaWx0ZXIpLGZpbHRlcikpfXJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcyx0aGlzLmludGVyZmFjZSkpfV9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KXtpZihydW5uaW5nRXZlbnQubGlzdGVuZXJDb3VudCgpPT09MCl7ZGVsZXRlIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107Y29uc3QgZW1pdD10aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107aWYoZW1pdCYmcnVubmluZ0V2ZW50LmZpbHRlcil7dGhpcy5wcm92aWRlci5vZmYocnVubmluZ0V2ZW50LmZpbHRlcixlbWl0KTtkZWxldGUgdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddfX19X3dyYXBFdmVudChydW5uaW5nRXZlbnQsbG9nLGxpc3RlbmVyKXtjb25zdCBldmVudD1kZWVwQ29weShsb2cpO2V2ZW50LnJlbW92ZUxpc3RlbmVyPSgoKT0+e2lmKCFsaXN0ZW5lcil7cmV0dXJufXJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7dGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCl9KTtldmVudC5nZXRCbG9jaz0oKCk9PntyZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCbG9jayhsb2cuYmxvY2tIYXNoKX0pO2V2ZW50LmdldFRyYW5zYWN0aW9uPSgoKT0+e3JldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGxvZy50cmFuc2FjdGlvbkhhc2gpfSk7ZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0PSgoKT0+e3JldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChsb2cudHJhbnNhY3Rpb25IYXNoKX0pO3J1bm5pbmdFdmVudC5wcmVwYXJlRXZlbnQoZXZlbnQpO3JldHVybiBldmVudH1fYWRkRXZlbnRMaXN0ZW5lcihydW5uaW5nRXZlbnQsbGlzdGVuZXIsb25jZSl7aWYoIXRoaXMucHJvdmlkZXIpe2xvZ2dlciRpLnRocm93RXJyb3IoXCJldmVudHMgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIGEgc2lnbmVyIHdpdGggYSBwcm92aWRlclwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJvbmNlXCJ9KX1ydW5uaW5nRXZlbnQuYWRkTGlzdGVuZXIobGlzdGVuZXIsb25jZSk7dGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXT1ydW5uaW5nRXZlbnQ7aWYoIXRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSl7Y29uc3Qgd3JhcHBlZEVtaXQ9bG9nPT57bGV0IGV2ZW50PXRoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsbG9nLGxpc3RlbmVyKTtpZihldmVudC5kZWNvZGVFcnJvcj09bnVsbCl7dHJ5e2NvbnN0IGFyZ3M9cnVubmluZ0V2ZW50LmdldEVtaXQoZXZlbnQpO3RoaXMuZW1pdChydW5uaW5nRXZlbnQuZmlsdGVyLC4uLmFyZ3MpfWNhdGNoKGVycm9yKXtldmVudC5kZWNvZGVFcnJvcj1lcnJvci5lcnJvcn19aWYocnVubmluZ0V2ZW50LmZpbHRlciE9bnVsbCl7dGhpcy5lbWl0KFwiZXZlbnRcIixldmVudCl9aWYoZXZlbnQuZGVjb2RlRXJyb3IhPW51bGwpe3RoaXMuZW1pdChcImVycm9yXCIsZXZlbnQuZGVjb2RlRXJyb3IsZXZlbnQpfX07dGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddPXdyYXBwZWRFbWl0O2lmKHJ1bm5pbmdFdmVudC5maWx0ZXIhPW51bGwpe3RoaXMucHJvdmlkZXIub24ocnVubmluZ0V2ZW50LmZpbHRlcix3cmFwcGVkRW1pdCl9fX1xdWVyeUZpbHRlcihldmVudCxmcm9tQmxvY2tPckJsb2NraGFzaCx0b0Jsb2NrKXtjb25zdCBydW5uaW5nRXZlbnQ9dGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KTtjb25zdCBmaWx0ZXI9c2hhbGxvd0NvcHkocnVubmluZ0V2ZW50LmZpbHRlcik7aWYodHlwZW9mIGZyb21CbG9ja09yQmxvY2toYXNoPT09XCJzdHJpbmdcIiYmaXNIZXhTdHJpbmcoZnJvbUJsb2NrT3JCbG9ja2hhc2gsMzIpKXtpZih0b0Jsb2NrIT1udWxsKXtsb2dnZXIkaS50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3Qgc3BlY2lmeSB0b0Jsb2NrIHdpdGggYmxvY2toYXNoXCIsXCJ0b0Jsb2NrXCIsdG9CbG9jayl9ZmlsdGVyLmJsb2NrSGFzaD1mcm9tQmxvY2tPckJsb2NraGFzaH1lbHNle2ZpbHRlci5mcm9tQmxvY2s9ZnJvbUJsb2NrT3JCbG9ja2hhc2ghPW51bGw/ZnJvbUJsb2NrT3JCbG9ja2hhc2g6MDtmaWx0ZXIudG9CbG9jaz10b0Jsb2NrIT1udWxsP3RvQmxvY2s6XCJsYXRlc3RcIn1yZXR1cm4gdGhpcy5wcm92aWRlci5nZXRMb2dzKGZpbHRlcikudGhlbihsb2dzPT57cmV0dXJuIGxvZ3MubWFwKGxvZz0+dGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCxsb2csbnVsbCkpfSl9b24oZXZlbnQsbGlzdGVuZXIpe3RoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSxsaXN0ZW5lcixmYWxzZSk7cmV0dXJuIHRoaXN9b25jZShldmVudCxsaXN0ZW5lcil7dGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLGxpc3RlbmVyLHRydWUpO3JldHVybiB0aGlzfWVtaXQoZXZlbnROYW1lLC4uLmFyZ3Mpe2lmKCF0aGlzLnByb3ZpZGVyKXtyZXR1cm4gZmFsc2V9Y29uc3QgcnVubmluZ0V2ZW50PXRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO2NvbnN0IHJlc3VsdD1ydW5uaW5nRXZlbnQucnVuKGFyZ3MpPjA7dGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7cmV0dXJuIHJlc3VsdH1saXN0ZW5lckNvdW50KGV2ZW50TmFtZSl7aWYoIXRoaXMucHJvdmlkZXIpe3JldHVybiAwfWlmKGV2ZW50TmFtZT09bnVsbCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3J1bm5pbmdFdmVudHMpLnJlZHVjZSgoYWNjdW0sa2V5KT0+e3JldHVybiBhY2N1bSt0aGlzLl9ydW5uaW5nRXZlbnRzW2tleV0ubGlzdGVuZXJDb3VudCgpfSwwKX1yZXR1cm4gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkubGlzdGVuZXJDb3VudCgpfWxpc3RlbmVycyhldmVudE5hbWUpe2lmKCF0aGlzLnByb3ZpZGVyKXtyZXR1cm5bXX1pZihldmVudE5hbWU9PW51bGwpe2NvbnN0IHJlc3VsdD1bXTtmb3IobGV0IHRhZyBpbiB0aGlzLl9ydW5uaW5nRXZlbnRzKXt0aGlzLl9ydW5uaW5nRXZlbnRzW3RhZ10ubGlzdGVuZXJzKCkuZm9yRWFjaChsaXN0ZW5lcj0+e3Jlc3VsdC5wdXNoKGxpc3RlbmVyKX0pfXJldHVybiByZXN1bHR9cmV0dXJuIHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpLmxpc3RlbmVycygpfXJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpe2lmKCF0aGlzLnByb3ZpZGVyKXtyZXR1cm4gdGhpc31pZihldmVudE5hbWU9PW51bGwpe2Zvcihjb25zdCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cyl7Y29uc3QgcnVubmluZ0V2ZW50PXRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXTtydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7dGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCl9cmV0dXJuIHRoaXN9Y29uc3QgcnVubmluZ0V2ZW50PXRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO3J1bm5pbmdFdmVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTt0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtyZXR1cm4gdGhpc31vZmYoZXZlbnROYW1lLGxpc3RlbmVyKXtpZighdGhpcy5wcm92aWRlcil7cmV0dXJuIHRoaXN9Y29uc3QgcnVubmluZ0V2ZW50PXRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO3J1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7dGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7cmV0dXJuIHRoaXN9cmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLGxpc3RlbmVyKXtyZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLGxpc3RlbmVyKX19Y2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3R7fWNsYXNzIENvbnRyYWN0RmFjdG9yeXtjb25zdHJ1Y3Rvcihjb250cmFjdEludGVyZmFjZSxieXRlY29kZSxzaWduZXIpe2xldCBieXRlY29kZUhleD1udWxsO2lmKHR5cGVvZiBieXRlY29kZT09PVwic3RyaW5nXCIpe2J5dGVjb2RlSGV4PWJ5dGVjb2RlfWVsc2UgaWYoaXNCeXRlcyhieXRlY29kZSkpe2J5dGVjb2RlSGV4PWhleGxpZnkoYnl0ZWNvZGUpfWVsc2UgaWYoYnl0ZWNvZGUmJnR5cGVvZiBieXRlY29kZS5vYmplY3Q9PT1cInN0cmluZ1wiKXtieXRlY29kZUhleD1ieXRlY29kZS5vYmplY3R9ZWxzZXtieXRlY29kZUhleD1cIiFcIn1pZihieXRlY29kZUhleC5zdWJzdHJpbmcoMCwyKSE9PVwiMHhcIil7Ynl0ZWNvZGVIZXg9XCIweFwiK2J5dGVjb2RlSGV4fWlmKCFpc0hleFN0cmluZyhieXRlY29kZUhleCl8fGJ5dGVjb2RlSGV4Lmxlbmd0aCUyKXtsb2dnZXIkaS50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVjb2RlXCIsXCJieXRlY29kZVwiLGJ5dGVjb2RlKX1pZihzaWduZXImJiFTaWduZXIuaXNTaWduZXIoc2lnbmVyKSl7bG9nZ2VyJGkudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduZXJcIixcInNpZ25lclwiLHNpZ25lcil9ZGVmaW5lUmVhZE9ubHkodGhpcyxcImJ5dGVjb2RlXCIsYnl0ZWNvZGVIZXgpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJpbnRlcmZhY2VcIixnZXRTdGF0aWMobmV3LnRhcmdldCxcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJzaWduZXJcIixzaWduZXJ8fG51bGwpfWdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3Mpe2xldCB0eD17fTtpZihhcmdzLmxlbmd0aD09PXRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoKzEmJnR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoLTFdPT09XCJvYmplY3RcIil7dHg9c2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7Zm9yKGNvbnN0IGtleSBpbiB0eCl7aWYoIWFsbG93ZWRUcmFuc2FjdGlvbktleXMkMltrZXldKXt0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiK2tleSl9fX1bXCJkYXRhXCIsXCJmcm9tXCIsXCJ0b1wiXS5mb3JFYWNoKGtleT0+e2lmKHR4W2tleV09PW51bGwpe3JldHVybn1sb2dnZXIkaS50aHJvd0Vycm9yKFwiY2Fubm90IG92ZXJyaWRlIFwiK2tleSxMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOmtleX0pfSk7bG9nZ2VyJGkuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO3R4LmRhdGE9aGV4bGlmeShjb25jYXQoW3RoaXMuYnl0ZWNvZGUsdGhpcy5pbnRlcmZhY2UuZW5jb2RlRGVwbG95KGFyZ3MpXSkpO3JldHVybiB0eH1kZXBsb3koLi4uYXJncyl7cmV0dXJuIF9fYXdhaXRlciQzKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtsZXQgb3ZlcnJpZGVzPXt9O2lmKGFyZ3MubGVuZ3RoPT09dGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgrMSl7b3ZlcnJpZGVzPWFyZ3MucG9wKCl9bG9nZ2VyJGkuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO2NvbnN0IHBhcmFtcz15aWVsZCByZXNvbHZlQWRkcmVzc2VzKHRoaXMuc2lnbmVyLGFyZ3MsdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cyk7cGFyYW1zLnB1c2gob3ZlcnJpZGVzKTtjb25zdCB1bnNpZ25lZFR4PXRoaXMuZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4ucGFyYW1zKTtjb25zdCB0eD15aWVsZCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odW5zaWduZWRUeCk7Y29uc3QgYWRkcmVzcz1nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvcixcImdldENvbnRyYWN0QWRkcmVzc1wiKSh0eCk7Y29uc3QgY29udHJhY3Q9Z2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsXCJnZXRDb250cmFjdFwiKShhZGRyZXNzLHRoaXMuaW50ZXJmYWNlLHRoaXMuc2lnbmVyKTtkZWZpbmVSZWFkT25seShjb250cmFjdCxcImRlcGxveVRyYW5zYWN0aW9uXCIsdHgpO3JldHVybiBjb250cmFjdH0pfWF0dGFjaChhZGRyZXNzKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRDb250cmFjdChhZGRyZXNzLHRoaXMuaW50ZXJmYWNlLHRoaXMuc2lnbmVyKX1jb25uZWN0KHNpZ25lcil7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuaW50ZXJmYWNlLHRoaXMuYnl0ZWNvZGUsc2lnbmVyKX1zdGF0aWMgZnJvbVNvbGlkaXR5KGNvbXBpbGVyT3V0cHV0LHNpZ25lcil7aWYoY29tcGlsZXJPdXRwdXQ9PW51bGwpe2xvZ2dlciRpLnRocm93RXJyb3IoXCJtaXNzaW5nIGNvbXBpbGVyIG91dHB1dFwiLExvZ2dlci5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCx7YXJndW1lbnQ6XCJjb21waWxlck91dHB1dFwifSl9aWYodHlwZW9mIGNvbXBpbGVyT3V0cHV0PT09XCJzdHJpbmdcIil7Y29tcGlsZXJPdXRwdXQ9SlNPTi5wYXJzZShjb21waWxlck91dHB1dCl9Y29uc3QgYWJpPWNvbXBpbGVyT3V0cHV0LmFiaTtsZXQgYnl0ZWNvZGU9bnVsbDtpZihjb21waWxlck91dHB1dC5ieXRlY29kZSl7Ynl0ZWNvZGU9Y29tcGlsZXJPdXRwdXQuYnl0ZWNvZGV9ZWxzZSBpZihjb21waWxlck91dHB1dC5ldm0mJmNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZSl7Ynl0ZWNvZGU9Y29tcGlsZXJPdXRwdXQuZXZtLmJ5dGVjb2RlfXJldHVybiBuZXcgdGhpcyhhYmksYnl0ZWNvZGUsc2lnbmVyKX1zdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKXtyZXR1cm4gQ29udHJhY3QuZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKX1zdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHR4KXtyZXR1cm4gZ2V0Q29udHJhY3RBZGRyZXNzKHR4KX1zdGF0aWMgZ2V0Q29udHJhY3QoYWRkcmVzcyxjb250cmFjdEludGVyZmFjZSxzaWduZXIpe3JldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcyxjb250cmFjdEludGVyZmFjZSxzaWduZXIpfX1jbGFzcyBCYXNlWHtjb25zdHJ1Y3RvcihhbHBoYWJldCl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFscGhhYmV0XCIsYWxwaGFiZXQpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJiYXNlXCIsYWxwaGFiZXQubGVuZ3RoKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2FscGhhYmV0TWFwXCIse30pO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfbGVhZGVyXCIsYWxwaGFiZXQuY2hhckF0KDApKTtmb3IobGV0IGk9MDtpPGFscGhhYmV0Lmxlbmd0aDtpKyspe3RoaXMuX2FscGhhYmV0TWFwW2FscGhhYmV0LmNoYXJBdChpKV09aX19ZW5jb2RlKHZhbHVlKXtsZXQgc291cmNlPWFycmF5aWZ5KHZhbHVlKTtpZihzb3VyY2UubGVuZ3RoPT09MCl7cmV0dXJuXCJcIn1sZXQgZGlnaXRzPVswXTtmb3IobGV0IGk9MDtpPHNvdXJjZS5sZW5ndGg7KytpKXtsZXQgY2Fycnk9c291cmNlW2ldO2ZvcihsZXQgaj0wO2o8ZGlnaXRzLmxlbmd0aDsrK2ope2NhcnJ5Kz1kaWdpdHNbal08PDg7ZGlnaXRzW2pdPWNhcnJ5JXRoaXMuYmFzZTtjYXJyeT1jYXJyeS90aGlzLmJhc2V8MH13aGlsZShjYXJyeT4wKXtkaWdpdHMucHVzaChjYXJyeSV0aGlzLmJhc2UpO2NhcnJ5PWNhcnJ5L3RoaXMuYmFzZXwwfX1sZXQgc3RyaW5nPVwiXCI7Zm9yKGxldCBrPTA7c291cmNlW2tdPT09MCYmazxzb3VyY2UubGVuZ3RoLTE7KytrKXtzdHJpbmcrPXRoaXMuX2xlYWRlcn1mb3IobGV0IHE9ZGlnaXRzLmxlbmd0aC0xO3E+PTA7LS1xKXtzdHJpbmcrPXRoaXMuYWxwaGFiZXRbZGlnaXRzW3FdXX1yZXR1cm4gc3RyaW5nfWRlY29kZSh2YWx1ZSl7aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKX1sZXQgYnl0ZXM9W107aWYodmFsdWUubGVuZ3RoPT09MCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKX1ieXRlcy5wdXNoKDApO2ZvcihsZXQgaT0wO2k8dmFsdWUubGVuZ3RoO2krKyl7bGV0IGJ5dGU9dGhpcy5fYWxwaGFiZXRNYXBbdmFsdWVbaV1dO2lmKGJ5dGU9PT11bmRlZmluZWQpe3Rocm93IG5ldyBFcnJvcihcIk5vbi1iYXNlXCIrdGhpcy5iYXNlK1wiIGNoYXJhY3RlclwiKX1sZXQgY2Fycnk9Ynl0ZTtmb3IobGV0IGo9MDtqPGJ5dGVzLmxlbmd0aDsrK2ope2NhcnJ5Kz1ieXRlc1tqXSp0aGlzLmJhc2U7Ynl0ZXNbal09Y2FycnkmMjU1O2NhcnJ5Pj49OH13aGlsZShjYXJyeT4wKXtieXRlcy5wdXNoKGNhcnJ5JjI1NSk7Y2Fycnk+Pj04fX1mb3IobGV0IGs9MDt2YWx1ZVtrXT09PXRoaXMuX2xlYWRlciYmazx2YWx1ZS5sZW5ndGgtMTsrK2spe2J5dGVzLnB1c2goMCl9cmV0dXJuIGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSkpfX1jb25zdCBCYXNlMzI9bmV3IEJhc2VYKFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIik7Y29uc3QgQmFzZTU4PW5ldyBCYXNlWChcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIik7dmFyIFN1cHBvcnRlZEFsZ29yaXRobTsoZnVuY3Rpb24oU3VwcG9ydGVkQWxnb3JpdGhtKXtTdXBwb3J0ZWRBbGdvcml0aG1bXCJzaGEyNTZcIl09XCJzaGEyNTZcIjtTdXBwb3J0ZWRBbGdvcml0aG1bXCJzaGE1MTJcIl09XCJzaGE1MTJcIn0pKFN1cHBvcnRlZEFsZ29yaXRobXx8KFN1cHBvcnRlZEFsZ29yaXRobT17fSkpO2NvbnN0IHZlcnNpb24kZT1cInNoYTIvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkaj1uZXcgTG9nZ2VyKHZlcnNpb24kZSk7ZnVuY3Rpb24gcmlwZW1kMTYwJDEoZGF0YSl7cmV0dXJuXCIweFwiK2hhc2hfMS5yaXBlbWQxNjAoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKX1mdW5jdGlvbiBzaGEyNTYkMShkYXRhKXtyZXR1cm5cIjB4XCIraGFzaF8xLnNoYTI1NigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpfWZ1bmN0aW9uIHNoYTUxMiQxKGRhdGEpe3JldHVyblwiMHhcIitoYXNoXzEuc2hhNTEyKCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIil9ZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLGtleSxkYXRhKXtpZighU3VwcG9ydGVkQWxnb3JpdGhtW2FsZ29yaXRobV0pe2xvZ2dlciRqLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG0gXCIrYWxnb3JpdGhtLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJobWFjXCIsYWxnb3JpdGhtOmFsZ29yaXRobX0pfXJldHVyblwiMHhcIitoYXNoXzEuaG1hYyhoYXNoXzFbYWxnb3JpdGhtXSxhcnJheWlmeShrZXkpKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKX1cInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmQsc2FsdCxpdGVyYXRpb25zLGtleWxlbixoYXNoQWxnb3JpdGhtKXtwYXNzd29yZD1hcnJheWlmeShwYXNzd29yZCk7c2FsdD1hcnJheWlmeShzYWx0KTtsZXQgaExlbjtsZXQgbD0xO2NvbnN0IERLPW5ldyBVaW50OEFycmF5KGtleWxlbik7Y29uc3QgYmxvY2sxPW5ldyBVaW50OEFycmF5KHNhbHQubGVuZ3RoKzQpO2Jsb2NrMS5zZXQoc2FsdCk7bGV0IHI7bGV0IFQ7Zm9yKGxldCBpPTE7aTw9bDtpKyspe2Jsb2NrMVtzYWx0Lmxlbmd0aF09aT4+MjQmMjU1O2Jsb2NrMVtzYWx0Lmxlbmd0aCsxXT1pPj4xNiYyNTU7YmxvY2sxW3NhbHQubGVuZ3RoKzJdPWk+PjgmMjU1O2Jsb2NrMVtzYWx0Lmxlbmd0aCszXT1pJjI1NTtsZXQgVT1hcnJheWlmeShjb21wdXRlSG1hYyhoYXNoQWxnb3JpdGhtLHBhc3N3b3JkLGJsb2NrMSkpO2lmKCFoTGVuKXtoTGVuPVUubGVuZ3RoO1Q9bmV3IFVpbnQ4QXJyYXkoaExlbik7bD1NYXRoLmNlaWwoa2V5bGVuL2hMZW4pO3I9a2V5bGVuLShsLTEpKmhMZW59VC5zZXQoVSk7Zm9yKGxldCBqPTE7ajxpdGVyYXRpb25zO2orKyl7VT1hcnJheWlmeShjb21wdXRlSG1hYyhoYXNoQWxnb3JpdGhtLHBhc3N3b3JkLFUpKTtmb3IobGV0IGs9MDtrPGhMZW47aysrKVRba11ePVVba119Y29uc3QgZGVzdFBvcz0oaS0xKSpoTGVuO2NvbnN0IGxlbj1pPT09bD9yOmhMZW47REsuc2V0KGFycmF5aWZ5KFQpLnNsaWNlKDAsbGVuKSxkZXN0UG9zKX1yZXR1cm4gaGV4bGlmeShESyl9Y29uc3QgdmVyc2lvbiRmPVwid29yZGxpc3RzLzUuMS4wXCI7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgZXhwb3J0V29yZGxpc3Q9ZmFsc2U7Y29uc3QgbG9nZ2VyJGs9bmV3IExvZ2dlcih2ZXJzaW9uJGYpO2NsYXNzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKGxvY2FsZSl7bG9nZ2VyJGsuY2hlY2tBYnN0cmFjdChuZXcudGFyZ2V0LFdvcmRsaXN0KTtkZWZpbmVSZWFkT25seSh0aGlzLFwibG9jYWxlXCIsbG9jYWxlKX1zcGxpdChtbmVtb25pYyl7cmV0dXJuIG1uZW1vbmljLnRvTG93ZXJDYXNlKCkuc3BsaXQoLyArL2cpfWpvaW4od29yZHMpe3JldHVybiB3b3Jkcy5qb2luKFwiIFwiKX1zdGF0aWMgY2hlY2sod29yZGxpc3Qpe2NvbnN0IHdvcmRzPVtdO2ZvcihsZXQgaT0wO2k8MjA0ODtpKyspe2NvbnN0IHdvcmQ9d29yZGxpc3QuZ2V0V29yZChpKTtpZihpIT09d29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmQpKXtyZXR1cm5cIjB4XCJ9d29yZHMucHVzaCh3b3JkKX1yZXR1cm4gaWQod29yZHMuam9pbihcIlxcblwiKStcIlxcblwiKX1zdGF0aWMgcmVnaXN0ZXIobGFuZyxuYW1lKXtpZighbmFtZSl7bmFtZT1sYW5nLmxvY2FsZX1pZihleHBvcnRXb3JkbGlzdCl7dHJ5e2NvbnN0IGFueUdsb2JhbD13aW5kb3c7aWYoYW55R2xvYmFsLl9ldGhlcnMmJmFueUdsb2JhbC5fZXRoZXJzLndvcmRsaXN0cyl7aWYoIWFueUdsb2JhbC5fZXRoZXJzLndvcmRsaXN0c1tuYW1lXSl7ZGVmaW5lUmVhZE9ubHkoYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzLG5hbWUsbGFuZyl9fX1jYXRjaChlcnJvcil7fX19fVwidXNlIHN0cmljdFwiO2NvbnN0IHdvcmRzPVwiQWJkaWthY2VBYmVjZWRhQWRyZXNhQWdyZXNlQWtjZUFrdG92a2FBbGVqQWxrb2hvbEFtcHV0YWNlQW5hbmFzQW5kdWxrYUFuZWtkb3RhQW5rZXRhQW50aWthQW51bG92YXRBcmNoYUFyb2dhbmNlQXNmYWx0QXNpc3RlbnRBc3BpcmFjZUFzdG1hQXN0cm9ub21BdGxhc0F0bGV0aWthQXRvbEF1dG9idXNBenlsQmFia2FCYWNob3JCYWNpbEJhY3Vsa2FCYWRhdGVsQmFnZXRhQmFnckJhaG5vQmFrdGVyaWVCYWxhZGFCYWxldGthQmFsa29uQmFsb25la0JhbHZhbkJhbHphQmFtYnVzQmFua29tYXRCYXJiYXJCYXJldEJhcm1hbkJhcm9rb0JhcnZhQmF0ZXJrYUJhdG9oQmF2bG5hQmF6YWxrYUJhemlsaWthQmF6dWthQmVkbmFCZXJhbkJlc2VkYUJlc3RpZUJldG9uQmV6aW5rYUJlem1vY0JlenRha0JpY3lrbEJpZGxvQmlmdGVrQmlraW55QmlsYW5jZUJpb2dyYWZCaW9sb2dCaXR2YUJpem9uQmxhaG9ieXRCbGF0b3VjaEJsZWNoYUJsZWR1bGVCbGVza0JsaWthdEJsaXpuYUJsb2tvdmF0QmxvdWRpdEJsdWRCb2Jla0JvYnJCb2RsaW5hQm9kbm91dEJvaGF0b3N0Qm9qa290Qm9qb3ZhdEJva29yeXNCb2xlc3RCb3JlY0Jvcm92aWNlQm90YUJvdWJlbEJvdWNoYXRCb3VkYUJvdWxlQm91cmF0Qm94ZXJCcmFkYXZrYUJyYW1ib3JhQnJhbmthQnJhdHJCcmVwdGFCcmlrZXRhQnJrb0JybG9oQnJvbnpCcm9za2V2QnJ1bmV0a2FCcnVzaW5rYUJyemRhQnJ6eUJ1YmxpbmFCdWJub3ZhdEJ1Y2h0YUJ1ZGl0ZWxCdWRrYUJ1ZG92YUJ1ZmV0QnVqYXJvc3RCdWt2aWNlQnVsZG9rQnVsdmFCdW5kYUJ1bmtyQnVyemFCdXRpa0J1dm9sQnV6b2xhQnlkbGV0QnlsaW5hQnl0b3ZrYUJ6dWtvdENhcGFydENhcmV2bmFDZWRyQ2VkdWxlQ2VqY2hDZWpuQ2VsYUNlbGVyQ2Vsa2VtQ2VsbmljZUNlbmluYUNlbm5vc3RDZW5vdmthQ2VudHJ1bUNlbnpvckNlc3RvcGlzQ2V0a2FDaGFsdXBhQ2hhcGFkbG9DaGFyaXRhQ2hhdGFDaGVjaHRhdENoZW1pZUNoaWNob3RDaGlydXJnQ2hsYWRDaGxlYmFDaGx1Yml0Q2htZWxDaG11cmFDaG9ib3RDaG9jaG9sQ2hvZGJhQ2hvbGVyYUNob21vdXRDaG9waXRDaG9yb2JhQ2hvdkNocmFwb3RDaHJsaXRDaHJ0Q2hydXBDaHRpdm9zdENodWRpbmFDaHV0bmF0Q2h2YXRDaHZpbGthQ2h2b3N0Q2h5YmFDaHlzdGF0Q2h5dGl0Q2lidWxlQ2lnYXJldGFDaWhlbG5hQ2lobGFDaW5rb3RDaXJrdXNDaXN0ZXJuYUNpdGFjZUNpdHJ1c0NpemluZWNDaXpvc3RDbG9uYUNva29saXZDb3V2YXRDdGl0ZWxDdG5vc3RDdWRub3N0Q3VrZXRhQ3VrckN1cG90Q3Zha25vdXRDdmFsQ3Zpa0N2cmtvdEN5a2xpc3RhRGFsZWtvRGFyZWJhRGF0ZWxEYXR1bURjZXJhRGViYXRhRGVjaG92a2FEZWNpYmVsRGVmaWNpdERlZmxhY2VEZWtsRGVrcmV0RGVtb2tyYXREZXByZXNlRGVyYnlEZXNrYURldGVrdGl2RGlrb2JyYXpEaWt0b3ZhdERpb2RhRGlwbG9tRGlza0Rpc3BsZWpEaXZhZGxvRGl2b2NoRGxhaGFEbG91aG9EbHVob3Bpc0RuZXNEb2Jyb0RvYnl0ZWtEb2NlbnREb2NodXRpdERvZG5lc0RvaGxlZERvaG9kYURvaHJhRG9qZW1Eb2puaWNlRG9rbGFkRG9rb2xhRG9rdG9yRG9rdW1lbnREb2xhckRvbGV2YURvbGluYURvbWFEb21pbmFudERvbWx1dml0RG9tb3ZEb251dGl0RG9wYWREb3Bpc0RvcGxuaXREb3Bvc3VkRG9wcm92b2REb3B1c3RpdERvcmF6aXREb3Jvc3REb3J0RG9zYWhEb3Nsb3ZEb3N0YXRla0Rvc3VkRG9zeXRhRG90YXpEb3Rla0RvdGtub3V0RG91ZmF0RG91dG5hdERvdm96Y2VEb3phZHVEb3puYXREb3pvcmNlRHJhaG90YURyYWtEcmFtYXRpa0RyYXZlY0RyYXplRHJkb2xEcm9ibm9zdERyb2dlcmllRHJvemREcnNub3N0RHJ0aXREcnpvc3REdWJlbkR1Y2hvdm5vRHVkZWtEdWhhRHVob3ZrYUR1c2l0RHVzbm9EdXRvc3REdm9qaWNlRHZvcmVjRHluYW1pdEVrb2xvZ0Vrb25vbWllRWxla3Ryb25FbGlwc2FFbWFpbEVtaXNlRW1vY2VFbXBhdGllRXBpem9kYUVwb2NoYUVwb3BlakVwb3NFc2VqRXNlbmNlRXNrb3J0YUVza3ltb0V0aWtldGFFdWZvcmllRXZvbHVjZUV4ZWt1Y2VFeGt1cnplRXhwZWRpY2VFeHBsb3plRXhwb3J0RXh0cmFrdEZhY2thRmFqZmthRmFrdWx0YUZhbmF0aWtGYW50YXppZUZhcm1hY2llRmF2b3JpdEZhem9sZUZlZGVyYWNlRmVqZXRvbkZlbmthRmlhbGthRmlndXJhbnRGaWxvem9mRmlsdHJGaW5hbmNlRmludGFGaXhhY2VGam9yZEZsYW5lbEZsaXJ0RmxvdGlsYUZvbmRGb3Nmb3JGb3RiYWxGb3RrYUZvdG9uRnJha2NlRnJlc2thRnJvbnRhRnVrYXJGdW5rY2VGeXppa2FHYWxlamVHYXJhbnRHZW5ldGlrYUdlb2xvZ0dpbG90aW5hR2xhenVyYUdsZWp0R29sZW1Hb2xmaXN0YUdvdGlrYUdyYWZHcmFtb2ZvbkdyYW51bGVHcmVwR3JpbEdyb2dHcm90ZXNrYUd1bWFIYWRpY2VIYWRySGFsYUhhbGVua2FIYW5iYUhhbm9waXNIYXJmYUhhcnB1bmFIYXZyYW5IZWJrb3N0SGVqa2FsSGVqbm9IZWp0bWFuSGVrdGFySGVsbWFIZW1hdG9tSGVyZWNIZXJuYUhlc2xvSGV6a3lIaXN0b3Jpa0hsYWRvdmthSGxhc2l2a3lIbGF2YUhsZWRhdEhsZW5IbG9kYXZlY0hsb2hIbG91cG9zdEhsdGF0SGx1YmluYUhsdWNob3RhSG1hdEhtb3RhSG15ekhuaXNIbm9qaXZvSG5vdXRIb2JsaW5hSG9ib2pIb2NoSG9kaW55SG9kbGF0SG9kbm90YUhvZG92YXRIb2pub3N0SG9rZWpIb2xpbmthSG9sa2FIb2x1YkhvbW9sZUhvbml0YmFIb25vcmFjZUhvcmFsSG9yZGFIb3Jpem9udEhvcmtvSG9ybGl2ZWNIb3Jtb25Ib3JuaW5hSG9yb3Nrb3BIb3JzdHZvSG9zcG9kYUhvc3RpbmFIb3Rvdm9zdEhvdWJhSG91ZkhvdXBhdEhvdXNrYUhvdm9ySHJhZGJhSHJhbmljZUhyYXZvc3RIcmF6ZGFIcmJvbGVrSHJkaW5hSHJkbG9IcmRvc3RIcm5la0hyb2JrYUhyb21hZGFIcm90SHJvdWRhSHJvemVuSHJzdGthSHJ1Ym9zdEhyeXphdEh1YmVub3N0SHVibm91dEh1ZGJhSHVrb3RIdW1ySHVzaXRhSHVzdG90YUh2b3pkSHlibm9zdEh5ZHJhbnRIeWdpZW5hSHltbmFIeXN0ZXJpa0lkeWxrYUlobmVkSWtvbmFJbHV6ZUltdW5pdGFJbmZla2NlSW5mbGFjZUlua2Fzb0lub3ZhY2VJbnNwZWtjZUludGVybmV0SW52YWxpZGFJbnZlc3RvckluemVyY2VJcm9uaWVKYWJsa29KYWNodGFKYWhvZGFKYWttaWxlSmFrb3N0SmFsb3ZlY0phbnRhckphcm1hcmtKYXJvSmFzYW5KYXNub0phdGthSmF2b3JKYXp5a0plZGluZWNKZWRsZUplZG5hdGVsSmVobGFuSmVrb3RKZWxlbkplbGl0b0plbW5vc3RKZW5vbUplcGljZUplc2V0ZXJKZXZpdEplemRlY0plemVyb0ppbmFrSmluZHlKaW5vY2hKaXNrcmFKaXN0b3RhSml0cm5pY2VKaXp2YUptZW5vdmF0Sm9ndXJ0SnVydGFLYWJhcmV0S2FiZWxLYWJpbmV0S2FjaG5hS2FkZXRLYWRpZGxvS2FoYW5LYWpha0thanV0YUtha2FvS2FrdHVzS2FsYW1pdGFLYWxob3R5S2FsaWJyS2Fsbm9zdEthbWVyYUthbWtvbGl2S2FtbmFLYW5pYmFsS2Fub2VLYW50b3JLYXBhbGluYUthcGVsYUthcGl0b2xhS2Fwa2FLYXBsZUthcG90YUthcHJLYXB1c3RhS2FweWJhcmFLYXJhbWVsS2Fyb3RrYUthcnRvbkthc2FLYXRhbG9nS2F0ZWRyYUthdWNlS2F1emFLYXZhbGVjS2F6YWprYUthemV0YUtheml2b3N0S2Rla29saXZLZGVzaUtlZGx1YmVuS2VtcEtlcmFtaWthS2lub0tsYWNla0tsYWRpdm9LbGFtS2xhcG90S2xhc2lrYUtsYXVuS2xlY0tsZW5iYUtsZXBhdEtsZXNub3V0S2xpZEtsaW1hS2xpc25hS2xvYm91a0tsb2thbktsb3BhS2xvdWJLbHVib3ZuYUtsdXNhdEtsdXprb3N0S21lbkttaXRhdEttb3RyS25paGFLbm90S29hbGljZUtvYmVyZWNLb2JrYUtvYmxpaGFLb2J5bGFLb2NvdXJLb2hvdXRLb2plbmVjS29rb3NLb2t0ZWpsS29sYXBzS29sZWRhS29saXplS29sb0tvbWFuZG9Lb21ldGFLb21pa0tvbW5hdGFLb21vcmFLb21wYXNLb211bml0YUtvbmF0S29uY2VwdEtvbmRpY2VLb25lY0tvbmZlc2VLb25ncmVzS29uaW5hS29ua3Vyc0tvbnRha3RLb256ZXJ2YUtvcGFuZWNLb3BpZUtvcG5vdXRLb3Byb3ZrYUtvcmJlbEtvcmVrdG9yS29ybWlkbG9Lb3JvcHRldktvcnB1c0tvcnVuYUtvcnl0b0tvcnpldEtvc2F0ZWNLb3N0a2FLb3RlbEtvdGxldGFLb3RvdWxLb3VrYXRLb3VwZWxuYUtvdXNla0tvdXpsb0tvdmJvaktvemFLb3pvcm9oS3JhYmljZUtyYWNoS3JhamluYUtyYWxvdmF0S3Jhc29waXNLcmF2YXRhS3JlZGl0S3JlamNhcktyZXNiYUtyZXZldGFLcmlrZXRLcml0aWtLcml6ZUtya2F2ZWNLcm1lbGVjS3JtaXZvS3JvY2FuS3Jva0tyb25pa2FLcm9waXRLcm91cGFLcm92a2FLcnRla0tydWhhZGxvS3J1cGljZUtydXRvc3RLcnZpbmthS3J5Y2hsZUtyeXB0YUtyeXN0YWxLcnl0S3VkbGFua2FLdWZyS3Vqbm9zdEt1a2xhS3VsYWpkYUt1bGljaEt1bGthS3Vsb21ldEt1bHR1cmFLdW5hS3Vwb2RpdnVLdXJ0S3Vyem9yS3V0aWxLdmFsaXRhS3Zhc2lua2FLdmVzdG9yS3lub2xvZ0t5c2VsaW5hS3l0YXJhS3l0aWNlS3l0a2FLeXRvdmVjS3l2YWRsb0xhYnJhZG9yTGFjaHRhbkxhZG5vc3RMYWlrTGFrb21lY0xhbWVsYUxhbXBhTGFub3ZrYUxhc2ljZUxhc29MYXN0dXJhTGF0aW5rYUxhdmluYUxlYmthTGVja2R5TGVkZW5MZWRuaWNlTGVkb3ZrYUxlZHZpbmFMZWdlbmRhTGVnaWVMZWdyYWNlTGVoY2VMZWhrb3N0TGVobm91dExla3R2YXJMZW5vY2hvZExlbnRpbGthTGVwZW5rYUxlcGlkbG9MZXRhZGxvTGV0ZWNMZXRtb0xldG9rcnVoTGV2aGFydExldml0YWNlTGV2b2Jva0xpYnJhTGljaG90a2FMaWRvamVkTGlkc2tvc3RMaWhvdmluYUxpamF2ZWNMaWxla0xpbWV0a2FMaW5pZUxpbmthTGlub2xldW1MaXN0b3BhZExpdGluYUxpdG92YXRMb2Jpc3RhTG9kaXZvZExvZ2lrYUxvZ29wZWRMb2thbGl0YUxva2V0TG9tY292YXRMb3BhdGFMb3B1Y2hMb3JkTG9zb3NMb3RyTG91ZGFsTG91aExvdWthTG91c2thdExvdmVjTHN0aXZvc3RMdWNlcm5hTHVjaWZlckx1bXBMdXNrTHVzdHJhY2VMdmljZUx5cmFMeXJpa2FMeXNpbmFNYWRhbU1hZGxvTWFnaXN0ck1haGFnb25NYWpldGVrTWFqaXRlbE1ham9yaXRhTWFrYWtNYWtvdmljZU1ha3JlbGFNYWxiYU1hbGluYU1hbG92YXRNYWx2aWNlTWFtaW5rYU1hbmRsZU1hbmtvTWFybm9zdE1hc2Frck1hc2tvdE1hc29wdXN0TWF0aWNlTWF0cmlrYU1hdHVyaXRhTWF6YW5lY01heml2b01hemxpdE1henVya2FNZGxvYmFNZWNoYW5pa01lZGl0YWNlTWVkb3ZpbmFNZWxhc2FNZWxvdW5NZW50b2xrYU1ldGxhTWV0b2RhTWV0ck1lemVyYU1pZ3JhY2VNaWhub3V0TWlodWxlTWlraW5hTWlrcm9mb25NaWxlbmVjTWlsaW1ldHJNaWxvc3RNaW1pa2FNaW5jb3ZuYU1pbmliYXJNaW5vbWV0TWludWxvc3RNaXNrYU1pc3RyTWl4b3ZhdE1sYWRvc3RNbGhhTWxob3ZpbmFNbG9rTWxzYXRNbHV2aXRNbmljaE1ub2hlbU1vYmlsTW9jbm9zdE1vZGVsa2FNb2RsaXRiYU1vaHlsYU1va3JvTW9sZWt1bGFNb21lbnRrYU1vbmFyY2hhTW9ub2tsTW9uc3RydW1Nb250b3ZhdE1vbnp1bk1vc2F6TW9za3l0TW9zdE1vdGl2YWNlTW90b3JrYU1vdHlrYU1vdWNoYU1vdWRyb3N0TW96YWlrYU1vemVrTW96b2xNcmFtb3JNcmF2ZW5lY01ya2V2TXJ0dm9sYU1yemV0TXJ6dXRvc3RNc3RpdGVsTXVkcmNNdWZsb25NdWxhdE11bWllTXVuaWNlTXVzZXRNdXRhY2VNdXpldW1NdXppa2FudE15c2xpdmVjTXpkYU5hYm91cmF0TmFjaHl0YXROYWRhY2VOYWRieXRla05hZGhvek5hZG9icm9OYWRwaXNOYWhsYXNOYWhuYXROYWhvZGlsZU5haHJhZGl0TmFpdml0YU5hamVkbm91TmFqaXN0b05ham1vdXROYWtsb25pdE5ha29uZWNOYWtybWl0TmFsZXZvTmFtYXphdE5hbWx1dml0TmFub21ldHJOYW9rb05hb3Bha05hb3N0cm9OYXBhZGF0TmFwZXZub05hcGxuaXROYXBub3V0TmFwb3NsZWROYXByb3N0b05hcm9kaXROYXJ1YnlOYXJ5Y2hsb05hc2FkaXROYXNla2F0TmFzbGVwb05hc3RhdE5hdG9saWtOYXZlbmVrTmF2cmNoTmF2emRvcnlOYXp2YXROZWJlTmVjaGF0TmVja3lOZWRhbGVrb05lZGJhdE5lZHVoTmVnYWNlTmVoZXROZWhvZGFOZWplbk5lanBydmVOZWtsaWROZWxpYm9zdE5lbWlsb3N0TmVtb2NOZW9jaG90YU5lb25rYU5lcG9rb2pOZXJvc3ROZXJ2TmVzbXlzbE5lc291bGFkTmV0dm9yTmV1cm9uTmV2aW5hTmV6dnlrbGVOaWNvdGFOaWpha05pa2FtTmlrZHlOaWtsTmlrdGVyYWtOaXRyb05vY2xlaE5vaGF2aWNlTm9taW5hY2VOb3JhTm9yZWtOb3NpdGVsTm9zbm9zdE5vdXplTm92aW55Tm92b3RhTm96ZHJhTnVkYU51ZGxlTnVnZXROdXRpdE51dG5vc3ROdXRyaWVOeW1mYU9iYWxPYmFydml0T2JhdmFPYmRpdk9iZWNPYmVobmF0T2Jlam1vdXRPYmV6aXRhT2JoYWpvYmFPYmlsbmljZU9iamFzbml0T2JqZWt0T2JrbG9waXRPYmxhc3RPYmxla09ibGliYU9ibG9oYU9ibHVkYU9ibm9zT2JvaGF0aXRPYm9qZWtPYm91dE9icmF6ZWNPYnJuYU9icnViYU9icnlzT2JzYWhPYnNsdWhhT2JzdGFyYXRPYnV2T2J2YXpPYnZpbml0T2J2b2RPYnZ5a2xlT2J5dmF0ZWxPYnpvck9jYXNPY2VsT2Nlbml0T2NobGFkaXRPY2hvdGFPY2hyYW5hT2NpdG5vdXRPZGJvak9kYnl0T2RjaG9kT2RjaXppdE9kZWJyYXRPZGVzbGF0T2RldnpkYXRPZGV6dmFPZGhhZGNlT2Rob2RpdE9kamV0T2RqaW51ZE9ka2F6T2Rrb3VwaXRPZGxpdk9kbHVrYU9kbWxrYU9kb2xub3N0T2RwYWRPZHBpc09kcGxvdXRPZHBvck9kcHVzdGl0T2RweWthdE9kcmF6a2FPZHNvdWRpdE9kc3R1cE9kc3VuT2R0b2tPZHR1ZE9kdmFoYU9kdmV0YU9kdm9sYXRPZHZyYWNldE9kem5ha09maW5hT2ZzYWpkT2hsYXNPaG5pc2tvT2hyYWRhT2hyb3ppdE9ocnl6ZWtPa2FwT2tlbmljZU9rbGlrYU9rbm9Pa291emxpdE9rb3Z5T2tyYXNhT2tyZXNPa3JzZWtPa3J1aE9rdXBhbnRPa3Vya2FPa3VzaXRPbGVqbmluYU9saXpvdmF0T21ha09tZWxldGFPbWV6aXRPbWxhZGluYU9tbG91dmF0T21sdXZhT215bE9uZWhkeU9wYWtvdmF0T3Bhc2VrT3BlcmFjZU9waWNlT3BpbG9zdE9waXNvdmF0T3BvcmFPcG96aWNlT3ByYXZkdU9wcm90aU9yYml0YWxPcmNoZXN0ck9yZ2llT3JsaWNlT3Jsb2pPcnRlbE9zYWRhT3NjaG5vdXRPc2lrYU9zaXZvT3NsYXZhT3NsZXBpdE9zbG5pdE9zbG92aXRPc25vdmFPc29iYU9zb2xpdE9zcGFsZWNPc3Rlbk9zdHJhaGFPc3R1ZGFPc3R5Y2hPc3Zvaml0T3RlcGxpdE90aXNrT3RvcE90cmhhdE90cmxvc3RPdHJva090cnVieU90dm9yT3Zhbm91dE92YXJPdmVzT3ZsaXZuaXRPdm9jZU94aWRPemRvYmFQYWNoYXRlbFBhY2llbnRQYWRvdWNoUGFob3Jla1Bha3RQYWxhbmRhUGFsZWNQYWxpdm9QYWx1YmFQYW1mbGV0UGFtbHNla1BhbmVua2FQYW5pa2FQYW5uYVBhbm92YXRQYW5zdHZvUGFudG9mbGVQYXByaWthUGFya2V0YVBhcm9kaWVQYXJ0YVBhcnVrYVBhcnliYVBhc2VrYVBhc2l2aXRhUGFzdGVsa2FQYXRlbnRQYXRyb25hUGF2b3VrUGF6bmVodFBhem91cmVrUGVja2FQZWRhZ29nUGVqc2VrUGVrbG9QZWxvdG9uUGVuYWx0YVBlbmRyZWtQZW56ZVBlcmlza29wUGVyb1Blc3Ryb3N0UGV0YXJkYVBldGljZVBldHJvbGVqUGV2bmluYVBleGVzb1BpYW5pc3RhUGloYVBpamF2aWNlUGlrbGVQaWtuaWtQaWxpbmFQaWxub3N0UGlsdWxrYVBpbnpldGFQaXBldGFQaXNhdGVsUGlzdG9sZVBpdGV2bmFQaXZuaWNlUGl2b3ZhclBsYWNlbnRhUGxha2F0UGxhbWVuUGxhbmV0YVBsYXN0aWthUGxhdGl0UGxhdmlkbG9QbGF6UGxlY2hQbGVtZW5vUGxlbnRhUGxlc1BsZXRpdm9QbGV2ZWxQbGl2YXRQbG5pdFBsbm9QbG9jaGFQbG9kaW5hUGxvbWJhUGxvdXRQbHVrUGx5blBvYmF2aXRQb2J5dFBvY2hvZFBvY2l0UG9jdGl2ZWNQb2RhdFBvZGNlbml0UG9kZXBzYXRQb2RobGVkUG9kaXZpdFBvZGtsYWRQb2RtYW5pdFBvZG5pa1BvZG9iYVBvZHBvcmFQb2RyYXpQb2RzdGF0YVBvZHZvZFBvZHppbVBvZXppZVBvaGFua2FQb2hudXRrYVBvaG92b3JQb2hyb21hUG9oeWJQb2ludGFQb2ppc3RrYVBvam1vdXRQb2theml0UG9rbGVzUG9rb2pQb2tyb2tQb2t1dGFQb2t5blBvbGVkbmVQb2xpYmVrUG9sa25vdXRQb2xvaGFQb2x5bm9tUG9tYWx1UG9taW5vdXRQb21sa2FQb21vY1BvbXN0YVBvbXlzbGV0UG9uZWNoYXRQb25vcmthUG9udXJvc3RQb3BhZGF0UG9wZWxQb3Bpc2VrUG9wbGFjaFBvcHJvc2l0UG9wc2F0UG9wdWRQb3JhZGNlUG9yY2VQb3JvZFBvcnVjaGFQb3J5dlBvc2FkaXRQb3NlZFBvc2lsYVBvc2tva1Bvc2xhbmVjUG9zb3VkaXRQb3Nwb2x1UG9zdGF2YVBvc3VkZWtQb3N5cFBvdGFoUG90a2FuUG90bGVza1BvdG9tZWtQb3RyYXZhUG90dXBhUG90dm9yYVBvdWthelBvdXRvUG91emRyb1BvdmFoYVBvdmlkbGFQb3ZsYWtQb3ZvelBvdnJjaFBvdnN0YXRQb3Z5a1BvdnpkZWNoUG96ZHJhdlBvemVtZWtQb3puYXRla1Bvem9yUG96dmF0UHJhY292YXRQcmFob3J5UHJha3Rpa2FQcmFsZXNQcmFvdGVjUHJhcG9yZWtQcmFzZVByYXZkYVByaW5jaXBQcmtub1Byb2J1ZGl0UHJvY2VudG9Qcm9kZWpQcm9mZXNlUHJvaHJhUHJvamVrdFByb2xvbWl0UHJvbWlsZVByb25pa2F0UHJvcGFkUHJvcm9rUHJvc2JhUHJvdG9uUHJvdXRla1Byb3ZhelByc2thdmthUHJzdGVuUHJ1ZGtvc3RQcnV0UHJ2ZWtQcnZvaG9yeVBzYW5lY1Bzb3ZvZFBzdHJ1aFB0YWN0dm9QdWJlcnRhUHVjaFB1ZGxQdWthdmVjUHVrbGluYVB1a3JsZVB1bHRQdW1wYVB1bmNQdXBlblB1c2FQdXNpbmthUHVzdGluYVB1dG92YXRQdXR5a2FQeXJhbWlkYVB5c2tQeXRlbFJhY2VrUmFjaG90UmFkaWFjZVJhZG5pY2VSYWRvblJhZnRSYWdieVJha2V0YVJha292aW5hUmFtZW5vUmFtcG91Y2hSYW5kZVJhcmFjaFJhcml0YVJhc292bmFSYXN0clJhdG9sZXN0UmF6YW5jZVJhemlkbG9SZWFnb3ZhdFJlYWtjZVJlY2VwdFJlZGFrdG9yUmVmZXJlbnRSZWZsZXhSZWpub2tSZWtsYW1hUmVrb3JkUmVrcnV0UmVrdG9yUmVwdXRhY2VSZXZpemVSZXZtYVJldm9sdmVyUmV6ZXJ2YVJpc2tvdmF0Uml6aWtvUm9ib3Rpa2FSb2Rva21lblJvaG92a2FSb2tsZVJva29rb1JvbWFuZXRvUm9wb3ZvZFJvcHVjaGFSb3JlanNSb3NvbFJvc3RsaW5hUm90bWlzdHJSb3RvcGVkUm90dW5kYVJvdWJlbmthUm91Y2hvUm91cFJvdXJhUm92aW5hUm92bmljZVJvemJvclJvemNob2RSb3pkYXRSb3plem5hdFJvemhvZGNlUm96aW5rYVJvemplemRSb3prYXpSb3psb2hhUm96bWFyUm96cGFkUm96cnVjaFJvenNhaFJvenRva1JvenVtUm96dm9kUnVicmlrYVJ1Y2hhZGxvUnVrYXZpY2VSdWtvcGlzUnliYVJ5Ym9sb3ZSeWNobG9zdFJ5ZGxvUnlwYWRsb1J5dGluYVJ5em9zdFNhZGlzdGFTYWhhdFNha29TYW1lY1NhbWl6ZGF0U2Ftb3RhU2FuaXRrYVNhcmRpbmthU2FzYW5rYVNhdGVsaXRTYXpiYVNhemVuaWNlU2JvclNjaG92YXRTZWJyYW5rYVNlY2VzZVNlZGFkbG9TZWRpbWVudFNlZGxvU2VobmF0U2VqbW91dFNla2VyYVNla3RhU2VrdW5kYVNla3ZvamVTZW1lbm9TZW5vU2VydmlzU2VzYWRpdFNlc2hvcmFTZXNrb2tTZXNsYXRTZXN0cmFTZXN1dlNlc3lwYXRTZXRiYVNldGluYVNldGthdFNldG5vdXRTZXRydmF0U2V2ZXJTZXpuYW1TaG9kYVNocm5vdXRTaWZvblNpbG5pY2VTaXJrYVNpcm90ZWtTaXJ1cFNpdHVhY2VTa2FmYW5kclNrYWxpc2tvU2thbnplblNrYXV0U2tlcHRpa1NraWNhU2tsYWRiYVNrbGVuaWNlU2tsb1NrbHV6U2tvYmFTa29rYW5Ta29yb1NrcmlwdGFTa3J6U2t1cGluYVNrdm9zdFNrdnJuYVNsYWJpa2FTbGFkaWRsb1NsYW5pbmFTbGFzdFNsYXZub3N0U2xlZG92YXRTbGVwZWNTbGV2YVNsZXppbmFTbGliU2xpbmFTbGl6bmljZVNsb25TbG91cGVrU2xvdm9TbHVjaFNsdWhhU2x1bmNlU2x1cGthU2x6YVNtYXJhZ2RTbWV0YW5hU21pbHN0dm9TbWxvdXZhU21vZ1NtcmFkU21ya1NtcnRrYVNtdXRla1NteXNsU25hZFNuYWhhU25vYlNvYm90YVNvY2hhU29kb3ZrYVNva29sU29wa2FTb3R2YVNvdWJvalNvdWNpdFNvdWRjZVNvdWhsYXNTb3VsYWRTb3VtcmFrU291cHJhdmFTb3VzZWRTb3V0b2tTb3V2aXNldFNwYWxvdm5hU3Bhc2l0ZWxTcGlzU3BsYXZTcG9kZWtTcG9qZW5lY1Nwb2x1U3BvbnpvclNwb3Jub3N0U3BvdXN0YVNwcmNoYVNwdXN0aXRTcmFuZGFTcmF6U3JkY2VTcm5hU3JuZWNTcm92bmF0U3JwZW5TcnN0U3J1YlN0YW5pY2VTdGFyb3N0YVN0YXRpa2FTdGF2YmFTdGVobm9TdGV6a2FTdG9kb2xhU3RvbGVrU3RvcGFTdG9ybm9TdG91cGF0U3RyYWNoU3RyZXNTdHJobm91dFN0cm9tU3RydW5hU3R1ZG5hU3R1cG5pY2VTdHZvbFN0eWtTdWJqZWt0U3VidHJvcHlTdWNoYXJTdWRvc3RTdWtub1N1bmRhdFN1bm91dFN1cmlrYXRhU3Vyb3ZpbmFTdmFoU3ZhbHN0dm9TdmV0clN2YXRiYVN2YXpla1N2aXNsZVN2aXRla1N2b2JvZGFTdm9kaWRsb1N2b3JrYVN2cmFiU3lrYXZrYVN5a290U3luZWtTeW5vdmVjU3lwYXRTeXBrb3N0U3lyb3Zvc3RTeXNlbFN5dG9zdFRhYmxldGthVGFidWxlVGFob3VuVGFqZW1ub1RhamZ1blRhamdhVGFqaXRUYWpub3N0VGFrdGlrYVRhbWhsZVRhbXBvblRhbmNvdmF0VGFuZWNUYW5rZXJUYXBldGFUYXZlbmluYVRhemF0ZWxUZWNobmlrYVRlaGR5VGVrdXRpbmFUZWxlZm9uVGVtbm90YVRlbmRlbmNlVGVuaXN0YVRlbm9yVGVwbG90YVRlcG5hVGVwcnZlVGVyYXBpZVRlcm1vc2thVGV4dGlsVGljaG9UaXNrb3Bpc1RpdHVsZWtUa2FkbGVjVGthbmluYVRsYXBrYVRsZXNrYXRUbHVrb3RUbHVwYVRtZWxUb2FsZXRhVG9waW5rYVRvcG9sVG9yem9Ub3VoYVRvdWxlY1RyYWRpY2VUcmFrdG9yVHJhbXBUcmFzYVRyYXZlcnphVHJlZml0VHJlc3RUcmV6b3JUcmhhdmluYVRyaGxpbmFUcm9jaHVUcm9qaWNlVHJvc2thVHJvdWJhVHJwY2VUcnBpdGVsVHJwa29zdFRydWJlY1RydWNobGl0VHJ1aGxpY2VUcnVzVHJ2YXRUdWR5VHVobm91dFR1aG9zdFR1bmRyYVR1cmlzdGFUdXJuYWpUdXplbXNrb1R2YXJvaFR2b3JiYVR2cmRvc3RUdnJ6VHlnclR5a2V2VWJvaG9zdFVib3plVWJyYXRVYnJvdXNla1VicnVzVWJ5dG92bmFVY2hvVWN0aXZvc3RVZGl2aXRVaHJhZGl0VWplZG5hdFVqaXN0aXRVam1vdXRVa2F6YXRlbFVrbGlkbml0VWtsb25pdFVrb3R2aXRVa3Jvaml0VWxpY2VVbGl0YVVsb3ZpdFVteXZhZGxvVW5hdml0VW5pZm9ybWFVbmlrbm91dFVwYWRub3V0VXBsYXRuaXRVcGx5bm91dFVwb3V0YXRVcHJhdml0VXJhblVyYXppdFVzZWRub3V0VXNpbG92YXRVc21ydGl0VXNuYWRuaXRVc25vdXRVc291ZGl0VXN0bGF0VXN0cm5vdXRVdGFob3ZhdFV0a2F0VXRsdW1pdFV0b25vdXRVdG9wZW5lY1V0cm91c2l0VXZhbGl0VXZvbG5pdFV2b3pvdmthVXpkcmF2aXRVemVsVXplbmluYVV6bGluYVV6bmF0VmFnb25WYWxjaGFWYWxvdW5WYW5hVmFuZGFsVmFuaWxrYVZhcmFuVmFyaGFueVZhcm92YXRWY2Vsa3VWY2hvZFZkb3ZhVmVkcm9WZWdldGFjZVZlamNlVmVsYmxvdWRWZWxldHJoVmVsaXRlbFZlbG1vY1ZlbHJ5YmFWZW5rb3ZWZXJhbmRhVmVyemVWZXNlbGthVmVza3J6ZVZlc25pY2VWZXNwb2R1VmVzdGFWZXRlcmluYVZldmVya2FWaWJyYWNlVmljaHJWaWRlb2hyYVZpZGluYVZpZGxlVmlsYVZpbmljZVZpc2V0Vml0YWxpdGFWaXplVml6aXRrYVZqZXpkVmtsYWRWa3VzVmxhamthVmxha1ZsYXNlY1ZsZXZvVmxoa29zdFZsaXZWbG5vdmthVmxvdXBhdFZudWNvdmF0Vm51a1ZvZGFWb2Rpdm9zdFZvZG96bmFrVm9kc3R2b1ZvamVuc2t5Vm9qbmFWb2pza29Wb2xhbnRWb2xiYVZvbGl0Vm9sbm9Wb3Nrb3ZrYVZvemlkbG9Wb3pvdm5hVnByYXZvVnJhYmVjVnJhY2V0VnJhaFZyYXRhVnJiYVZyY2hvbGVrVnJoYXRWcnN0dmFWcnR1bGVWc2FkaXRWc3RvdXBpdFZzdHVwVnRpcFZ5YmF2aXRWeWJyYXRWeWNob3ZhdFZ5ZGF0VnlkcmFWeWZvdGl0VnlobGVkYXRWeWhub3V0Vnlob2RpdFZ5aHJhZGl0VnlodWJpdFZ5amFzbml0VnlqZXRWeWptb3V0VnlrbG9waXRWeWtvbmF0VnlsZWthdFZ5bWF6YXRWeW1leml0VnltaXpldFZ5bXlzbGV0VnluZWNoYXRWeW5pa2F0VnludXRpdFZ5cGFkYXRWeXBsYXRpdFZ5cHJhdml0VnlwdXN0aXRWeXJheml0Vnlyb3ZuYXRWeXJ2YXRWeXNsb3ZpdFZ5c29rb1Z5c3Rhdml0VnlzdW5vdXRWeXN5cGF0Vnl0YXNpdFZ5dGVzYXRWeXRyYXRpdFZ5dmlub3V0Vnl2b2xhdFZ5dnJoZWxWeXpkb2JpdFZ5em5hdFZ6YWR1VnpidWRpdFZ6Y2hvcGl0Vnpkb3JWemR1Y2hWemR5Y2hhdFZ6ZXN0dXBWemhsZWRlbVZ6a2F6VnpseWthdFZ6bmlrVnpvcmVrVnpwb3VyYVZ6dGFoVnp0ZWtYeWxvZm9uWmFicmF0WmFieWRsZXRaYWNob3ZhdFphZGFybW9aYWR1c2l0WmFmb3VrYXRaYWhsdGl0WmFob2RpdFphaHJhZGFaYWh5bm91dFphamF0ZWNaYWpldFphamlzdGl0WmFrbGVwYXRaYWtvdXBpdFphbGVwaXRaYW1leml0WmFtb3RhdFphbXlzbGV0WmFuZWNoYXRaYW5pa2F0WmFwbGF0aXRaYXBvaml0WmFwc2F0WmFyYXppdFphc3Rhdml0WmFzdW5vdXRaYXRhaml0WmF0ZW1uaXRaYXRrbm91dFphdWptb3V0WmF2YWxpdFphdmVsZXRaYXZpbml0WmF2b2xhdFphdnJ0YXRaYXp2b25pdFpiYXZpdFpicnVzdVpidWRvdmF0WmJ5dGVrWmRhbGVrYVpkYXJtYVpkYXRub3N0WmRpdm9aZG9iaXRaZHJvalpkdmloWmR5bWFkbG9aZWxlbmluYVplbWFuWmVtaW5hWmVwdGF0WmV6YWR1WmV6ZG9sYVpoYXRpdFpobHRub3V0WmhsdWJva2FaaG90b3ZpdFpocnViYVppbWFaaW1uaWNlWmplbW5pdFprbGFtYXRaa291bWF0WmtyYXRrYVprdW1hdmthWmxhdG9abGVoa2FabG9iYVpsb21abG9zdFpsb3p2eWtabWFwb3ZhdFptYXJabWF0ZWtabWlqZVptaXpldFptb2NuaXRabW9kcmF0Wm1yemxpbmFabXV0b3ZhdFpuYWtabmFsb3N0Wm5hbWVuYXRabm92dVpvYnJheml0Wm90YXZpdFpvdWJla1pvdWZhbGVacGxvZGl0WnBvbWFsaXRacHJhdmFacHJvc3RpdFpwcnVka2FacHJ2dVpyYWRhWnJhbml0WnJjYWRsb1pybml0b3N0WnJub1pyb3ZuYVpyeWNobGl0WnJ6YXZvc3RadGljaGFadHJhdGl0WnVib3ZpbmFadWJyWnZlZG5vdXRadmVua3VadmVzZWxhWnZvblp2cmF0WnZ1a292b2RadnlrXCI7bGV0IHdvcmRsaXN0PW51bGw7ZnVuY3Rpb24gbG9hZFdvcmRzKGxhbmcpe2lmKHdvcmRsaXN0IT1udWxsKXtyZXR1cm59d29yZGxpc3Q9d29yZHMucmVwbGFjZSgvKFtBLVpdKS9nLFwiICQxXCIpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDEpLnNwbGl0KFwiIFwiKTtpZihXb3JkbGlzdC5jaGVjayhsYW5nKSE9PVwiMHgyNWY0NDU1NWY0YWYyNWI1MWE3MTExMzZlMWM3ZDZlNTBjZTlmODkxN2QzOWQ2YjFmMDc2YjJiYjRkMmZhYzFhXCIpe3dvcmRsaXN0PW51bGw7dGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGVuIChFbmdsaXNoKSBGQUlMRURcIil9fWNsYXNzIExhbmdDeiBleHRlbmRzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJjelwiKX1nZXRXb3JkKGluZGV4KXtsb2FkV29yZHModGhpcyk7cmV0dXJuIHdvcmRsaXN0W2luZGV4XX1nZXRXb3JkSW5kZXgod29yZCl7bG9hZFdvcmRzKHRoaXMpO3JldHVybiB3b3JkbGlzdC5pbmRleE9mKHdvcmQpfX1jb25zdCBsYW5nQ3o9bmV3IExhbmdDejtXb3JkbGlzdC5yZWdpc3RlcihsYW5nQ3opO1widXNlIHN0cmljdFwiO2NvbnN0IHdvcmRzJDE9XCJBYmFuZG9uQWJpbGl0eUFibGVBYm91dEFib3ZlQWJzZW50QWJzb3JiQWJzdHJhY3RBYnN1cmRBYnVzZUFjY2Vzc0FjY2lkZW50QWNjb3VudEFjY3VzZUFjaGlldmVBY2lkQWNvdXN0aWNBY3F1aXJlQWNyb3NzQWN0QWN0aW9uQWN0b3JBY3RyZXNzQWN0dWFsQWRhcHRBZGRBZGRpY3RBZGRyZXNzQWRqdXN0QWRtaXRBZHVsdEFkdmFuY2VBZHZpY2VBZXJvYmljQWZmYWlyQWZmb3JkQWZyYWlkQWdhaW5BZ2VBZ2VudEFncmVlQWhlYWRBaW1BaXJBaXJwb3J0QWlzbGVBbGFybUFsYnVtQWxjb2hvbEFsZXJ0QWxpZW5BbGxBbGxleUFsbG93QWxtb3N0QWxvbmVBbHBoYUFscmVhZHlBbHNvQWx0ZXJBbHdheXNBbWF0ZXVyQW1hemluZ0Ftb25nQW1vdW50QW11c2VkQW5hbHlzdEFuY2hvckFuY2llbnRBbmdlckFuZ2xlQW5ncnlBbmltYWxBbmtsZUFubm91bmNlQW5udWFsQW5vdGhlckFuc3dlckFudGVubmFBbnRpcXVlQW54aWV0eUFueUFwYXJ0QXBvbG9neUFwcGVhckFwcGxlQXBwcm92ZUFwcmlsQXJjaEFyY3RpY0FyZWFBcmVuYUFyZ3VlQXJtQXJtZWRBcm1vckFybXlBcm91bmRBcnJhbmdlQXJyZXN0QXJyaXZlQXJyb3dBcnRBcnRlZmFjdEFydGlzdEFydHdvcmtBc2tBc3BlY3RBc3NhdWx0QXNzZXRBc3Npc3RBc3N1bWVBc3RobWFBdGhsZXRlQXRvbUF0dGFja0F0dGVuZEF0dGl0dWRlQXR0cmFjdEF1Y3Rpb25BdWRpdEF1Z3VzdEF1bnRBdXRob3JBdXRvQXV0dW1uQXZlcmFnZUF2b2NhZG9Bdm9pZEF3YWtlQXdhcmVBd2F5QXdlc29tZUF3ZnVsQXdrd2FyZEF4aXNCYWJ5QmFjaGVsb3JCYWNvbkJhZGdlQmFnQmFsYW5jZUJhbGNvbnlCYWxsQmFtYm9vQmFuYW5hQmFubmVyQmFyQmFyZWx5QmFyZ2FpbkJhcnJlbEJhc2VCYXNpY0Jhc2tldEJhdHRsZUJlYWNoQmVhbkJlYXV0eUJlY2F1c2VCZWNvbWVCZWVmQmVmb3JlQmVnaW5CZWhhdmVCZWhpbmRCZWxpZXZlQmVsb3dCZWx0QmVuY2hCZW5lZml0QmVzdEJldHJheUJldHRlckJldHdlZW5CZXlvbmRCaWN5Y2xlQmlkQmlrZUJpbmRCaW9sb2d5QmlyZEJpcnRoQml0dGVyQmxhY2tCbGFkZUJsYW1lQmxhbmtldEJsYXN0QmxlYWtCbGVzc0JsaW5kQmxvb2RCbG9zc29tQmxvdXNlQmx1ZUJsdXJCbHVzaEJvYXJkQm9hdEJvZHlCb2lsQm9tYkJvbmVCb251c0Jvb2tCb29zdEJvcmRlckJvcmluZ0JvcnJvd0Jvc3NCb3R0b21Cb3VuY2VCb3hCb3lCcmFja2V0QnJhaW5CcmFuZEJyYXNzQnJhdmVCcmVhZEJyZWV6ZUJyaWNrQnJpZGdlQnJpZWZCcmlnaHRCcmluZ0JyaXNrQnJvY2NvbGlCcm9rZW5Ccm9uemVCcm9vbUJyb3RoZXJCcm93bkJydXNoQnViYmxlQnVkZHlCdWRnZXRCdWZmYWxvQnVpbGRCdWxiQnVsa0J1bGxldEJ1bmRsZUJ1bmtlckJ1cmRlbkJ1cmdlckJ1cnN0QnVzQnVzaW5lc3NCdXN5QnV0dGVyQnV5ZXJCdXp6Q2FiYmFnZUNhYmluQ2FibGVDYWN0dXNDYWdlQ2FrZUNhbGxDYWxtQ2FtZXJhQ2FtcENhbkNhbmFsQ2FuY2VsQ2FuZHlDYW5ub25DYW5vZUNhbnZhc0NhbnlvbkNhcGFibGVDYXBpdGFsQ2FwdGFpbkNhckNhcmJvbkNhcmRDYXJnb0NhcnBldENhcnJ5Q2FydENhc2VDYXNoQ2FzaW5vQ2FzdGxlQ2FzdWFsQ2F0Q2F0YWxvZ0NhdGNoQ2F0ZWdvcnlDYXR0bGVDYXVnaHRDYXVzZUNhdXRpb25DYXZlQ2VpbGluZ0NlbGVyeUNlbWVudENlbnN1c0NlbnR1cnlDZXJlYWxDZXJ0YWluQ2hhaXJDaGFsa0NoYW1waW9uQ2hhbmdlQ2hhb3NDaGFwdGVyQ2hhcmdlQ2hhc2VDaGF0Q2hlYXBDaGVja0NoZWVzZUNoZWZDaGVycnlDaGVzdENoaWNrZW5DaGllZkNoaWxkQ2hpbW5leUNob2ljZUNob29zZUNocm9uaWNDaHVja2xlQ2h1bmtDaHVybkNpZ2FyQ2lubmFtb25DaXJjbGVDaXRpemVuQ2l0eUNpdmlsQ2xhaW1DbGFwQ2xhcmlmeUNsYXdDbGF5Q2xlYW5DbGVya0NsZXZlckNsaWNrQ2xpZW50Q2xpZmZDbGltYkNsaW5pY0NsaXBDbG9ja0Nsb2dDbG9zZUNsb3RoQ2xvdWRDbG93bkNsdWJDbHVtcENsdXN0ZXJDbHV0Y2hDb2FjaENvYXN0Q29jb251dENvZGVDb2ZmZWVDb2lsQ29pbkNvbGxlY3RDb2xvckNvbHVtbkNvbWJpbmVDb21lQ29tZm9ydENvbWljQ29tbW9uQ29tcGFueUNvbmNlcnRDb25kdWN0Q29uZmlybUNvbmdyZXNzQ29ubmVjdENvbnNpZGVyQ29udHJvbENvbnZpbmNlQ29va0Nvb2xDb3BwZXJDb3B5Q29yYWxDb3JlQ29ybkNvcnJlY3RDb3N0Q290dG9uQ291Y2hDb3VudHJ5Q291cGxlQ291cnNlQ291c2luQ292ZXJDb3lvdGVDcmFja0NyYWRsZUNyYWZ0Q3JhbUNyYW5lQ3Jhc2hDcmF0ZXJDcmF3bENyYXp5Q3JlYW1DcmVkaXRDcmVla0NyZXdDcmlja2V0Q3JpbWVDcmlzcENyaXRpY0Nyb3BDcm9zc0Nyb3VjaENyb3dkQ3J1Y2lhbENydWVsQ3J1aXNlQ3J1bWJsZUNydW5jaENydXNoQ3J5Q3J5c3RhbEN1YmVDdWx0dXJlQ3VwQ3VwYm9hcmRDdXJpb3VzQ3VycmVudEN1cnRhaW5DdXJ2ZUN1c2hpb25DdXN0b21DdXRlQ3ljbGVEYWREYW1hZ2VEYW1wRGFuY2VEYW5nZXJEYXJpbmdEYXNoRGF1Z2h0ZXJEYXduRGF5RGVhbERlYmF0ZURlYnJpc0RlY2FkZURlY2VtYmVyRGVjaWRlRGVjbGluZURlY29yYXRlRGVjcmVhc2VEZWVyRGVmZW5zZURlZmluZURlZnlEZWdyZWVEZWxheURlbGl2ZXJEZW1hbmREZW1pc2VEZW5pYWxEZW50aXN0RGVueURlcGFydERlcGVuZERlcG9zaXREZXB0aERlcHV0eURlcml2ZURlc2NyaWJlRGVzZXJ0RGVzaWduRGVza0Rlc3BhaXJEZXN0cm95RGV0YWlsRGV0ZWN0RGV2ZWxvcERldmljZURldm90ZURpYWdyYW1EaWFsRGlhbW9uZERpYXJ5RGljZURpZXNlbERpZXREaWZmZXJEaWdpdGFsRGlnbml0eURpbGVtbWFEaW5uZXJEaW5vc2F1ckRpcmVjdERpcnREaXNhZ3JlZURpc2NvdmVyRGlzZWFzZURpc2hEaXNtaXNzRGlzb3JkZXJEaXNwbGF5RGlzdGFuY2VEaXZlcnREaXZpZGVEaXZvcmNlRGl6enlEb2N0b3JEb2N1bWVudERvZ0RvbGxEb2xwaGluRG9tYWluRG9uYXRlRG9ua2V5RG9ub3JEb29yRG9zZURvdWJsZURvdmVEcmFmdERyYWdvbkRyYW1hRHJhc3RpY0RyYXdEcmVhbURyZXNzRHJpZnREcmlsbERyaW5rRHJpcERyaXZlRHJvcERydW1EcnlEdWNrRHVtYkR1bmVEdXJpbmdEdXN0RHV0Y2hEdXR5RHdhcmZEeW5hbWljRWFnZXJFYWdsZUVhcmx5RWFybkVhcnRoRWFzaWx5RWFzdEVhc3lFY2hvRWNvbG9neUVjb25vbXlFZGdlRWRpdEVkdWNhdGVFZmZvcnRFZ2dFaWdodEVpdGhlckVsYm93RWxkZXJFbGVjdHJpY0VsZWdhbnRFbGVtZW50RWxlcGhhbnRFbGV2YXRvckVsaXRlRWxzZUVtYmFya0VtYm9keUVtYnJhY2VFbWVyZ2VFbW90aW9uRW1wbG95RW1wb3dlckVtcHR5RW5hYmxlRW5hY3RFbmRFbmRsZXNzRW5kb3JzZUVuZW15RW5lcmd5RW5mb3JjZUVuZ2FnZUVuZ2luZUVuaGFuY2VFbmpveUVubGlzdEVub3VnaEVucmljaEVucm9sbEVuc3VyZUVudGVyRW50aXJlRW50cnlFbnZlbG9wZUVwaXNvZGVFcXVhbEVxdWlwRXJhRXJhc2VFcm9kZUVyb3Npb25FcnJvckVydXB0RXNjYXBlRXNzYXlFc3NlbmNlRXN0YXRlRXRlcm5hbEV0aGljc0V2aWRlbmNlRXZpbEV2b2tlRXZvbHZlRXhhY3RFeGFtcGxlRXhjZXNzRXhjaGFuZ2VFeGNpdGVFeGNsdWRlRXhjdXNlRXhlY3V0ZUV4ZXJjaXNlRXhoYXVzdEV4aGliaXRFeGlsZUV4aXN0RXhpdEV4b3RpY0V4cGFuZEV4cGVjdEV4cGlyZUV4cGxhaW5FeHBvc2VFeHByZXNzRXh0ZW5kRXh0cmFFeWVFeWVicm93RmFicmljRmFjZUZhY3VsdHlGYWRlRmFpbnRGYWl0aEZhbGxGYWxzZUZhbWVGYW1pbHlGYW1vdXNGYW5GYW5jeUZhbnRhc3lGYXJtRmFzaGlvbkZhdEZhdGFsRmF0aGVyRmF0aWd1ZUZhdWx0RmF2b3JpdGVGZWF0dXJlRmVicnVhcnlGZWRlcmFsRmVlRmVlZEZlZWxGZW1hbGVGZW5jZUZlc3RpdmFsRmV0Y2hGZXZlckZld0ZpYmVyRmljdGlvbkZpZWxkRmlndXJlRmlsZUZpbG1GaWx0ZXJGaW5hbEZpbmRGaW5lRmluZ2VyRmluaXNoRmlyZUZpcm1GaXJzdEZpc2NhbEZpc2hGaXRGaXRuZXNzRml4RmxhZ0ZsYW1lRmxhc2hGbGF0Rmxhdm9yRmxlZUZsaWdodEZsaXBGbG9hdEZsb2NrRmxvb3JGbG93ZXJGbHVpZEZsdXNoRmx5Rm9hbUZvY3VzRm9nRm9pbEZvbGRGb2xsb3dGb29kRm9vdEZvcmNlRm9yZXN0Rm9yZ2V0Rm9ya0ZvcnR1bmVGb3J1bUZvcndhcmRGb3NzaWxGb3N0ZXJGb3VuZEZveEZyYWdpbGVGcmFtZUZyZXF1ZW50RnJlc2hGcmllbmRGcmluZ2VGcm9nRnJvbnRGcm9zdEZyb3duRnJvemVuRnJ1aXRGdWVsRnVuRnVubnlGdXJuYWNlRnVyeUZ1dHVyZUdhZGdldEdhaW5HYWxheHlHYWxsZXJ5R2FtZUdhcEdhcmFnZUdhcmJhZ2VHYXJkZW5HYXJsaWNHYXJtZW50R2FzR2FzcEdhdGVHYXRoZXJHYXVnZUdhemVHZW5lcmFsR2VuaXVzR2VucmVHZW50bGVHZW51aW5lR2VzdHVyZUdob3N0R2lhbnRHaWZ0R2lnZ2xlR2luZ2VyR2lyYWZmZUdpcmxHaXZlR2xhZEdsYW5jZUdsYXJlR2xhc3NHbGlkZUdsaW1wc2VHbG9iZUdsb29tR2xvcnlHbG92ZUdsb3dHbHVlR29hdEdvZGRlc3NHb2xkR29vZEdvb3NlR29yaWxsYUdvc3BlbEdvc3NpcEdvdmVybkdvd25HcmFiR3JhY2VHcmFpbkdyYW50R3JhcGVHcmFzc0dyYXZpdHlHcmVhdEdyZWVuR3JpZEdyaWVmR3JpdEdyb2NlcnlHcm91cEdyb3dHcnVudEd1YXJkR3Vlc3NHdWlkZUd1aWx0R3VpdGFyR3VuR3ltSGFiaXRIYWlySGFsZkhhbW1lckhhbXN0ZXJIYW5kSGFwcHlIYXJib3JIYXJkSGFyc2hIYXJ2ZXN0SGF0SGF2ZUhhd2tIYXphcmRIZWFkSGVhbHRoSGVhcnRIZWF2eUhlZGdlaG9nSGVpZ2h0SGVsbG9IZWxtZXRIZWxwSGVuSGVyb0hpZGRlbkhpZ2hIaWxsSGludEhpcEhpcmVIaXN0b3J5SG9iYnlIb2NrZXlIb2xkSG9sZUhvbGlkYXlIb2xsb3dIb21lSG9uZXlIb29kSG9wZUhvcm5Ib3Jyb3JIb3JzZUhvc3BpdGFsSG9zdEhvdGVsSG91ckhvdmVySHViSHVnZUh1bWFuSHVtYmxlSHVtb3JIdW5kcmVkSHVuZ3J5SHVudEh1cmRsZUh1cnJ5SHVydEh1c2JhbmRIeWJyaWRJY2VJY29uSWRlYUlkZW50aWZ5SWRsZUlnbm9yZUlsbElsbGVnYWxJbGxuZXNzSW1hZ2VJbWl0YXRlSW1tZW5zZUltbXVuZUltcGFjdEltcG9zZUltcHJvdmVJbXB1bHNlSW5jaEluY2x1ZGVJbmNvbWVJbmNyZWFzZUluZGV4SW5kaWNhdGVJbmRvb3JJbmR1c3RyeUluZmFudEluZmxpY3RJbmZvcm1JbmhhbGVJbmhlcml0SW5pdGlhbEluamVjdEluanVyeUlubWF0ZUlubmVySW5ub2NlbnRJbnB1dElucXVpcnlJbnNhbmVJbnNlY3RJbnNpZGVJbnNwaXJlSW5zdGFsbEludGFjdEludGVyZXN0SW50b0ludmVzdEludml0ZUludm9sdmVJcm9uSXNsYW5kSXNvbGF0ZUlzc3VlSXRlbUl2b3J5SmFja2V0SmFndWFySmFySmF6ekplYWxvdXNKZWFuc0plbGx5SmV3ZWxKb2JKb2luSm9rZUpvdXJuZXlKb3lKdWRnZUp1aWNlSnVtcEp1bmdsZUp1bmlvckp1bmtKdXN0S2FuZ2Fyb29LZWVuS2VlcEtldGNodXBLZXlLaWNrS2lkS2lkbmV5S2luZEtpbmdkb21LaXNzS2l0S2l0Y2hlbktpdGVLaXR0ZW5LaXdpS25lZUtuaWZlS25vY2tLbm93TGFiTGFiZWxMYWJvckxhZGRlckxhZHlMYWtlTGFtcExhbmd1YWdlTGFwdG9wTGFyZ2VMYXRlckxhdGluTGF1Z2hMYXVuZHJ5TGF2YUxhd0xhd25MYXdzdWl0TGF5ZXJMYXp5TGVhZGVyTGVhZkxlYXJuTGVhdmVMZWN0dXJlTGVmdExlZ0xlZ2FsTGVnZW5kTGVpc3VyZUxlbW9uTGVuZExlbmd0aExlbnNMZW9wYXJkTGVzc29uTGV0dGVyTGV2ZWxMaWFyTGliZXJ0eUxpYnJhcnlMaWNlbnNlTGlmZUxpZnRMaWdodExpa2VMaW1iTGltaXRMaW5rTGlvbkxpcXVpZExpc3RMaXR0bGVMaXZlTGl6YXJkTG9hZExvYW5Mb2JzdGVyTG9jYWxMb2NrTG9naWNMb25lbHlMb25nTG9vcExvdHRlcnlMb3VkTG91bmdlTG92ZUxveWFsTHVja3lMdWdnYWdlTHVtYmVyTHVuYXJMdW5jaEx1eHVyeUx5cmljc01hY2hpbmVNYWRNYWdpY01hZ25ldE1haWRNYWlsTWFpbk1ham9yTWFrZU1hbW1hbE1hbk1hbmFnZU1hbmRhdGVNYW5nb01hbnNpb25NYW51YWxNYXBsZU1hcmJsZU1hcmNoTWFyZ2luTWFyaW5lTWFya2V0TWFycmlhZ2VNYXNrTWFzc01hc3Rlck1hdGNoTWF0ZXJpYWxNYXRoTWF0cml4TWF0dGVyTWF4aW11bU1hemVNZWFkb3dNZWFuTWVhc3VyZU1lYXRNZWNoYW5pY01lZGFsTWVkaWFNZWxvZHlNZWx0TWVtYmVyTWVtb3J5TWVudGlvbk1lbnVNZXJjeU1lcmdlTWVyaXRNZXJyeU1lc2hNZXNzYWdlTWV0YWxNZXRob2RNaWRkbGVNaWRuaWdodE1pbGtNaWxsaW9uTWltaWNNaW5kTWluaW11bU1pbm9yTWludXRlTWlyYWNsZU1pcnJvck1pc2VyeU1pc3NNaXN0YWtlTWl4TWl4ZWRNaXh0dXJlTW9iaWxlTW9kZWxNb2RpZnlNb21Nb21lbnRNb25pdG9yTW9ua2V5TW9uc3Rlck1vbnRoTW9vbk1vcmFsTW9yZU1vcm5pbmdNb3NxdWl0b01vdGhlck1vdGlvbk1vdG9yTW91bnRhaW5Nb3VzZU1vdmVNb3ZpZU11Y2hNdWZmaW5NdWxlTXVsdGlwbHlNdXNjbGVNdXNldW1NdXNocm9vbU11c2ljTXVzdE11dHVhbE15c2VsZk15c3RlcnlNeXRoTmFpdmVOYW1lTmFwa2luTmFycm93TmFzdHlOYXRpb25OYXR1cmVOZWFyTmVja05lZWROZWdhdGl2ZU5lZ2xlY3ROZWl0aGVyTmVwaGV3TmVydmVOZXN0TmV0TmV0d29ya05ldXRyYWxOZXZlck5ld3NOZXh0TmljZU5pZ2h0Tm9ibGVOb2lzZU5vbWluZWVOb29kbGVOb3JtYWxOb3J0aE5vc2VOb3RhYmxlTm90ZU5vdGhpbmdOb3RpY2VOb3ZlbE5vd051Y2xlYXJOdW1iZXJOdXJzZU51dE9ha09iZXlPYmplY3RPYmxpZ2VPYnNjdXJlT2JzZXJ2ZU9idGFpbk9idmlvdXNPY2N1ck9jZWFuT2N0b2Jlck9kb3JPZmZPZmZlck9mZmljZU9mdGVuT2lsT2theU9sZE9saXZlT2x5bXBpY09taXRPbmNlT25lT25pb25PbmxpbmVPbmx5T3Blbk9wZXJhT3Bpbmlvbk9wcG9zZU9wdGlvbk9yYW5nZU9yYml0T3JjaGFyZE9yZGVyT3JkaW5hcnlPcmdhbk9yaWVudE9yaWdpbmFsT3JwaGFuT3N0cmljaE90aGVyT3V0ZG9vck91dGVyT3V0cHV0T3V0c2lkZU92YWxPdmVuT3Zlck93bk93bmVyT3h5Z2VuT3lzdGVyT3pvbmVQYWN0UGFkZGxlUGFnZVBhaXJQYWxhY2VQYWxtUGFuZGFQYW5lbFBhbmljUGFudGhlclBhcGVyUGFyYWRlUGFyZW50UGFya1BhcnJvdFBhcnR5UGFzc1BhdGNoUGF0aFBhdGllbnRQYXRyb2xQYXR0ZXJuUGF1c2VQYXZlUGF5bWVudFBlYWNlUGVhbnV0UGVhclBlYXNhbnRQZWxpY2FuUGVuUGVuYWx0eVBlbmNpbFBlb3BsZVBlcHBlclBlcmZlY3RQZXJtaXRQZXJzb25QZXRQaG9uZVBob3RvUGhyYXNlUGh5c2ljYWxQaWFub1BpY25pY1BpY3R1cmVQaWVjZVBpZ1BpZ2VvblBpbGxQaWxvdFBpbmtQaW9uZWVyUGlwZVBpc3RvbFBpdGNoUGl6emFQbGFjZVBsYW5ldFBsYXN0aWNQbGF0ZVBsYXlQbGVhc2VQbGVkZ2VQbHVja1BsdWdQbHVuZ2VQb2VtUG9ldFBvaW50UG9sYXJQb2xlUG9saWNlUG9uZFBvbnlQb29sUG9wdWxhclBvcnRpb25Qb3NpdGlvblBvc3NpYmxlUG9zdFBvdGF0b1BvdHRlcnlQb3ZlcnR5UG93ZGVyUG93ZXJQcmFjdGljZVByYWlzZVByZWRpY3RQcmVmZXJQcmVwYXJlUHJlc2VudFByZXR0eVByZXZlbnRQcmljZVByaWRlUHJpbWFyeVByaW50UHJpb3JpdHlQcmlzb25Qcml2YXRlUHJpemVQcm9ibGVtUHJvY2Vzc1Byb2R1Y2VQcm9maXRQcm9ncmFtUHJvamVjdFByb21vdGVQcm9vZlByb3BlcnR5UHJvc3BlclByb3RlY3RQcm91ZFByb3ZpZGVQdWJsaWNQdWRkaW5nUHVsbFB1bHBQdWxzZVB1bXBraW5QdW5jaFB1cGlsUHVwcHlQdXJjaGFzZVB1cml0eVB1cnBvc2VQdXJzZVB1c2hQdXRQdXp6bGVQeXJhbWlkUXVhbGl0eVF1YW50dW1RdWFydGVyUXVlc3Rpb25RdWlja1F1aXRRdWl6UXVvdGVSYWJiaXRSYWNjb29uUmFjZVJhY2tSYWRhclJhZGlvUmFpbFJhaW5SYWlzZVJhbGx5UmFtcFJhbmNoUmFuZG9tUmFuZ2VSYXBpZFJhcmVSYXRlUmF0aGVyUmF2ZW5SYXdSYXpvclJlYWR5UmVhbFJlYXNvblJlYmVsUmVidWlsZFJlY2FsbFJlY2VpdmVSZWNpcGVSZWNvcmRSZWN5Y2xlUmVkdWNlUmVmbGVjdFJlZm9ybVJlZnVzZVJlZ2lvblJlZ3JldFJlZ3VsYXJSZWplY3RSZWxheFJlbGVhc2VSZWxpZWZSZWx5UmVtYWluUmVtZW1iZXJSZW1pbmRSZW1vdmVSZW5kZXJSZW5ld1JlbnRSZW9wZW5SZXBhaXJSZXBlYXRSZXBsYWNlUmVwb3J0UmVxdWlyZVJlc2N1ZVJlc2VtYmxlUmVzaXN0UmVzb3VyY2VSZXNwb25zZVJlc3VsdFJldGlyZVJldHJlYXRSZXR1cm5SZXVuaW9uUmV2ZWFsUmV2aWV3UmV3YXJkUmh5dGhtUmliUmliYm9uUmljZVJpY2hSaWRlUmlkZ2VSaWZsZVJpZ2h0UmlnaWRSaW5nUmlvdFJpcHBsZVJpc2tSaXR1YWxSaXZhbFJpdmVyUm9hZFJvYXN0Um9ib3RSb2J1c3RSb2NrZXRSb21hbmNlUm9vZlJvb2tpZVJvb21Sb3NlUm90YXRlUm91Z2hSb3VuZFJvdXRlUm95YWxSdWJiZXJSdWRlUnVnUnVsZVJ1blJ1bndheVJ1cmFsU2FkU2FkZGxlU2FkbmVzc1NhZmVTYWlsU2FsYWRTYWxtb25TYWxvblNhbHRTYWx1dGVTYW1lU2FtcGxlU2FuZFNhdGlzZnlTYXRvc2hpU2F1Y2VTYXVzYWdlU2F2ZVNheVNjYWxlU2NhblNjYXJlU2NhdHRlclNjZW5lU2NoZW1lU2Nob29sU2NpZW5jZVNjaXNzb3JzU2NvcnBpb25TY291dFNjcmFwU2NyZWVuU2NyaXB0U2NydWJTZWFTZWFyY2hTZWFzb25TZWF0U2Vjb25kU2VjcmV0U2VjdGlvblNlY3VyaXR5U2VlZFNlZWtTZWdtZW50U2VsZWN0U2VsbFNlbWluYXJTZW5pb3JTZW5zZVNlbnRlbmNlU2VyaWVzU2VydmljZVNlc3Npb25TZXR0bGVTZXR1cFNldmVuU2hhZG93U2hhZnRTaGFsbG93U2hhcmVTaGVkU2hlbGxTaGVyaWZmU2hpZWxkU2hpZnRTaGluZVNoaXBTaGl2ZXJTaG9ja1Nob2VTaG9vdFNob3BTaG9ydFNob3VsZGVyU2hvdmVTaHJpbXBTaHJ1Z1NodWZmbGVTaHlTaWJsaW5nU2lja1NpZGVTaWVnZVNpZ2h0U2lnblNpbGVudFNpbGtTaWxseVNpbHZlclNpbWlsYXJTaW1wbGVTaW5jZVNpbmdTaXJlblNpc3RlclNpdHVhdGVTaXhTaXplU2thdGVTa2V0Y2hTa2lTa2lsbFNraW5Ta2lydFNrdWxsU2xhYlNsYW1TbGVlcFNsZW5kZXJTbGljZVNsaWRlU2xpZ2h0U2xpbVNsb2dhblNsb3RTbG93U2x1c2hTbWFsbFNtYXJ0U21pbGVTbW9rZVNtb290aFNuYWNrU25ha2VTbmFwU25pZmZTbm93U29hcFNvY2NlclNvY2lhbFNvY2tTb2RhU29mdFNvbGFyU29sZGllclNvbGlkU29sdXRpb25Tb2x2ZVNvbWVvbmVTb25nU29vblNvcnJ5U29ydFNvdWxTb3VuZFNvdXBTb3VyY2VTb3V0aFNwYWNlU3BhcmVTcGF0aWFsU3Bhd25TcGVha1NwZWNpYWxTcGVlZFNwZWxsU3BlbmRTcGhlcmVTcGljZVNwaWRlclNwaWtlU3BpblNwaXJpdFNwbGl0U3BvaWxTcG9uc29yU3Bvb25TcG9ydFNwb3RTcHJheVNwcmVhZFNwcmluZ1NweVNxdWFyZVNxdWVlemVTcXVpcnJlbFN0YWJsZVN0YWRpdW1TdGFmZlN0YWdlU3RhaXJzU3RhbXBTdGFuZFN0YXJ0U3RhdGVTdGF5U3RlYWtTdGVlbFN0ZW1TdGVwU3RlcmVvU3RpY2tTdGlsbFN0aW5nU3RvY2tTdG9tYWNoU3RvbmVTdG9vbFN0b3J5U3RvdmVTdHJhdGVneVN0cmVldFN0cmlrZVN0cm9uZ1N0cnVnZ2xlU3R1ZGVudFN0dWZmU3R1bWJsZVN0eWxlU3ViamVjdFN1Ym1pdFN1YndheVN1Y2Nlc3NTdWNoU3VkZGVuU3VmZmVyU3VnYXJTdWdnZXN0U3VpdFN1bW1lclN1blN1bm55U3Vuc2V0U3VwZXJTdXBwbHlTdXByZW1lU3VyZVN1cmZhY2VTdXJnZVN1cnByaXNlU3Vycm91bmRTdXJ2ZXlTdXNwZWN0U3VzdGFpblN3YWxsb3dTd2FtcFN3YXBTd2FybVN3ZWFyU3dlZXRTd2lmdFN3aW1Td2luZ1N3aXRjaFN3b3JkU3ltYm9sU3ltcHRvbVN5cnVwU3lzdGVtVGFibGVUYWNrbGVUYWdUYWlsVGFsZW50VGFsa1RhbmtUYXBlVGFyZ2V0VGFza1Rhc3RlVGF0dG9vVGF4aVRlYWNoVGVhbVRlbGxUZW5UZW5hbnRUZW5uaXNUZW50VGVybVRlc3RUZXh0VGhhbmtUaGF0VGhlbWVUaGVuVGhlb3J5VGhlcmVUaGV5VGhpbmdUaGlzVGhvdWdodFRocmVlVGhyaXZlVGhyb3dUaHVtYlRodW5kZXJUaWNrZXRUaWRlVGlnZXJUaWx0VGltYmVyVGltZVRpbnlUaXBUaXJlZFRpc3N1ZVRpdGxlVG9hc3RUb2JhY2NvVG9kYXlUb2RkbGVyVG9lVG9nZXRoZXJUb2lsZXRUb2tlblRvbWF0b1RvbW9ycm93VG9uZVRvbmd1ZVRvbmlnaHRUb29sVG9vdGhUb3BUb3BpY1RvcHBsZVRvcmNoVG9ybmFkb1RvcnRvaXNlVG9zc1RvdGFsVG91cmlzdFRvd2FyZFRvd2VyVG93blRveVRyYWNrVHJhZGVUcmFmZmljVHJhZ2ljVHJhaW5UcmFuc2ZlclRyYXBUcmFzaFRyYXZlbFRyYXlUcmVhdFRyZWVUcmVuZFRyaWFsVHJpYmVUcmlja1RyaWdnZXJUcmltVHJpcFRyb3BoeVRyb3VibGVUcnVja1RydWVUcnVseVRydW1wZXRUcnVzdFRydXRoVHJ5VHViZVR1aXRpb25UdW1ibGVUdW5hVHVubmVsVHVya2V5VHVyblR1cnRsZVR3ZWx2ZVR3ZW50eVR3aWNlVHdpblR3aXN0VHdvVHlwZVR5cGljYWxVZ2x5VW1icmVsbGFVbmFibGVVbmF3YXJlVW5jbGVVbmNvdmVyVW5kZXJVbmRvVW5mYWlyVW5mb2xkVW5oYXBweVVuaWZvcm1VbmlxdWVVbml0VW5pdmVyc2VVbmtub3duVW5sb2NrVW50aWxVbnVzdWFsVW52ZWlsVXBkYXRlVXBncmFkZVVwaG9sZFVwb25VcHBlclVwc2V0VXJiYW5VcmdlVXNhZ2VVc2VVc2VkVXNlZnVsVXNlbGVzc1VzdWFsVXRpbGl0eVZhY2FudFZhY3V1bVZhZ3VlVmFsaWRWYWxsZXlWYWx2ZVZhblZhbmlzaFZhcG9yVmFyaW91c1Zhc3RWYXVsdFZlaGljbGVWZWx2ZXRWZW5kb3JWZW50dXJlVmVudWVWZXJiVmVyaWZ5VmVyc2lvblZlcnlWZXNzZWxWZXRlcmFuVmlhYmxlVmlicmFudFZpY2lvdXNWaWN0b3J5VmlkZW9WaWV3VmlsbGFnZVZpbnRhZ2VWaW9saW5WaXJ0dWFsVmlydXNWaXNhVmlzaXRWaXN1YWxWaXRhbFZpdmlkVm9jYWxWb2ljZVZvaWRWb2xjYW5vVm9sdW1lVm90ZVZveWFnZVdhZ2VXYWdvbldhaXRXYWxrV2FsbFdhbG51dFdhbnRXYXJmYXJlV2FybVdhcnJpb3JXYXNoV2FzcFdhc3RlV2F0ZXJXYXZlV2F5V2VhbHRoV2VhcG9uV2VhcldlYXNlbFdlYXRoZXJXZWJXZWRkaW5nV2Vla2VuZFdlaXJkV2VsY29tZVdlc3RXZXRXaGFsZVdoYXRXaGVhdFdoZWVsV2hlbldoZXJlV2hpcFdoaXNwZXJXaWRlV2lkdGhXaWZlV2lsZFdpbGxXaW5XaW5kb3dXaW5lV2luZ1dpbmtXaW5uZXJXaW50ZXJXaXJlV2lzZG9tV2lzZVdpc2hXaXRuZXNzV29sZldvbWFuV29uZGVyV29vZFdvb2xXb3JkV29ya1dvcmxkV29ycnlXb3J0aFdyYXBXcmVja1dyZXN0bGVXcmlzdFdyaXRlV3JvbmdZYXJkWWVhclllbGxvd1lvdVlvdW5nWW91dGhaZWJyYVplcm9ab25lWm9vXCI7bGV0IHdvcmRsaXN0JDE9bnVsbDtmdW5jdGlvbiBsb2FkV29yZHMkMShsYW5nKXtpZih3b3JkbGlzdCQxIT1udWxsKXtyZXR1cm59d29yZGxpc3QkMT13b3JkcyQxLnJlcGxhY2UoLyhbQS1aXSkvZyxcIiAkMVwiKS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygxKS5zcGxpdChcIiBcIik7aWYoV29yZGxpc3QuY2hlY2sobGFuZykhPT1cIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiKXt3b3JkbGlzdCQxPW51bGw7dGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGVuIChFbmdsaXNoKSBGQUlMRURcIil9fWNsYXNzIExhbmdFbiBleHRlbmRzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJlblwiKX1nZXRXb3JkKGluZGV4KXtsb2FkV29yZHMkMSh0aGlzKTtyZXR1cm4gd29yZGxpc3QkMVtpbmRleF19Z2V0V29yZEluZGV4KHdvcmQpe2xvYWRXb3JkcyQxKHRoaXMpO3JldHVybiB3b3JkbGlzdCQxLmluZGV4T2Yod29yZCl9fWNvbnN0IGxhbmdFbj1uZXcgTGFuZ0VuO1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdFbik7XCJ1c2Ugc3RyaWN0XCI7Y29uc3Qgd29yZHMkMj1cIkEvYmFjb0FiZG9tZW5BYmVqYUFiaWVydG9BYm9nYWRvQWJvbm9BYm9ydG9BYnJhem9BYnJpckFidWVsb0FidXNvQWNhYmFyQWNhZGVtaWFBY2Nlc29BY2Npby9uQWNlaXRlQWNlbGdhQWNlbnRvQWNlcHRhckEvY2lkb0FjbGFyYXJBY25lL0Fjb2dlckFjb3NvQWN0aXZvQWN0b0FjdHJpekFjdHVhckFjdWRpckFjdWVyZG9BY3VzYXJBZGljdG9BZG1pdGlyQWRvcHRhckFkb3Jub0FkdWFuYUFkdWx0b0FlL3Jlb0FmZWN0YXJBZmljaW8vbkFmaW5hckFmaXJtYXJBL2dpbEFnaXRhckFnb25pL2FBZ29zdG9BZ290YXJBZ3JlZ2FyQWdyaW9BZ3VhQWd1ZG9BL2d1aWxhQWd1amFBaG9nb0Fob3Jyb0FpcmVBaXNsYXJBamVkcmV6QWplbm9BanVzdGVBbGFjcmEvbkFsYW1icmVBbGFybWFBbGJhQS9sYnVtQWxjYWxkZUFsZGVhQWxlZ3JlQWxlamFyQWxlcnRhQWxldGFBbGZpbGVyQWxnYUFsZ29kby9uQWxpYWRvQWxpZW50b0FsaXZpb0FsbWFBbG1lamFBbG1pL2JhckFsdGFyQWx0ZXphQWx0aXZvQWx0b0FsdHVyYUFsdW1ub0FsemFyQW1hYmxlQW1hbnRlQW1hcG9sYUFtYXJnb0FtYXNhckEvbWJhckEvbWJpdG9BbWVub0FtaWdvQW1pc3RhZEFtb3JBbXBhcm9BbXBsaW9BbmNob0FuY2lhbm9BbmNsYUFuZGFyQW5kZS9uQW5lbWlhQS9uZ3Vsb0FuaWxsb0Evbmltb0FuaS9zQW5vdGFyQW50ZW5hQW50aWd1b0FudG9qb0FudWFsQW51bGFyQW51bmNpb0F+YWRpckF+ZWpvQX5vQXBhZ2FyQXBhcmF0b0FwZXRpdG9BcGlvQXBsaWNhckFwb2RvQXBvcnRlQXBveW9BcHJlbmRlckFwcm9iYXJBcHVlc3RhQXB1cm9BcmFkb0FyYX5hQXJhckEvcmJpdHJvQS9yYm9sQXJidXN0b0FyY2hpdm9BcmNvQXJkZXJBcmRpbGxhQXJkdW9BL3JlYUEvcmlkb0FyaWVzQXJtb25pL2FBcm5lL3NBcm9tYUFycGFBcnBvL25BcnJlZ2xvQXJyb3pBcnJ1Z2FBcnRlQXJ0aXN0YUFzYUFzYWRvQXNhbHRvQXNjZW5zb0FzZWd1cmFyQXNlb0FzZXNvckFzaWVudG9Bc2lsb0FzaXN0aXJBc25vQXNvbWJyb0Evc3Blcm9Bc3RpbGxhQXN0cm9Bc3R1dG9Bc3VtaXJBc3VudG9BdGFqb0F0YXF1ZUF0YXJBdGVudG9BdGVvQS90aWNvQXRsZXRhQS90b21vQXRyYWVyQXRyb3pBdHUvbkF1ZGF6QXVkaW9BdWdlQXVsYUF1bWVudG9BdXNlbnRlQXV0b3JBdmFsQXZhbmNlQXZhcm9BdmVBdmVsbGFuYUF2ZW5hQXZlc3RydXpBdmlvL25Bdmlzb0F5ZXJBeXVkYUF5dW5vQXphZnJhL25BemFyQXpvdGVBenUvY2FyQXp1ZnJlQXp1bEJhYmFCYWJvckJhY2hlQmFoaS9hQmFpbGVCYWphckJhbGFuemFCYWxjby9uQmFsZGVCYW1idS9CYW5jb0JhbmRhQmF+b0JhcmJhQmFyY29CYXJuaXpCYXJyb0JhL3NjdWxhQmFzdG8vbkJhc3VyYUJhdGFsbGFCYXRlcmkvYUJhdGlyQmF0dXRhQmF1L2xCYXphckJlYmUvQmViaWRhQmVsbG9CZXNhckJlc29CZXN0aWFCaWNob0JpZW5CaW5nb0JsYW5jb0Jsb3F1ZUJsdXNhQm9hQm9iaW5hQm9ib0JvY2FCb2NpbmFCb2RhQm9kZWdhQm9pbmFCb2xhQm9sZXJvQm9sc2FCb21iYUJvbmRhZEJvbml0b0Jvbm9Cb25zYS9pQm9yZGVCb3JyYXJCb3NxdWVCb3RlQm90aS9uQm8vdmVkYUJvemFsQnJhdm9CcmF6b0JyZWNoYUJyZXZlQnJpbGxvQnJpbmNvQnJpc2FCcm9jYUJyb21hQnJvbmNlQnJvdGVCcnVqYUJydXNjb0JydXRvQnVjZW9CdWNsZUJ1ZW5vQnVleUJ1ZmFuZGFCdWZvL25CdS9ob0J1aXRyZUJ1bHRvQnVyYnVqYUJ1cmxhQnVycm9CdXNjYXJCdXRhY2FCdXpvL25DYWJhbGxvQ2FiZXphQ2FiaW5hQ2FicmFDYWNhb0NhZGEvdmVyQ2FkZW5hQ2FlckNhZmUvQ2FpL2RhQ2FpbWEvbkNhamFDYWpvL25DYWxDYWxhbWFyQ2FsY2lvQ2FsZG9DYWxpZGFkQ2FsbGVDYWxtYUNhbG9yQ2Fsdm9DYW1hQ2FtYmlvQ2FtZWxsb0NhbWlub0NhbXBvQ2EvbmNlckNhbmRpbENhbmVsYUNhbmd1cm9DYW5pY2FDYW50b0NhfmFDYX5vL25DYW9iYUNhb3NDYXBhekNhcGl0YS9uQ2Fwb3RlQ2FwdGFyQ2FwdWNoYUNhcmFDYXJiby9uQ2EvcmNlbENhcmV0YUNhcmdhQ2FyaX5vQ2FybmVDYXJwZXRhQ2Fycm9DYXJ0YUNhc2FDYXNjb0Nhc2Vyb0Nhc3BhQ2FzdG9yQ2F0b3JjZUNhdHJlQ2F1ZGFsQ2F1c2FDYXpvQ2Vib2xsYUNlZGVyQ2Vkcm9DZWxkYUNlL2xlYnJlQ2Vsb3NvQ2UvbHVsYUNlbWVudG9DZW5pemFDZW50cm9DZXJjYUNlcmRvQ2VyZXphQ2Vyb0NlcnJhckNlcnRlemFDZS9zcGVkQ2V0cm9DaGFjYWxDaGFsZWNvQ2hhbXB1L0NoYW5jbGFDaGFwYUNoYXJsYUNoaWNvQ2hpc3RlQ2hpdm9DaG9xdWVDaG96YUNodWxldGFDaHVwYXJDaWNsby9uQ2llZ29DaWVsb0NpZW5DaWVydG9DaWZyYUNpZ2Fycm9DaW1hQ2luY29DaW5lQ2ludGFDaXByZS9zQ2lyY29DaXJ1ZWxhQ2lzbmVDaXRhQ2l1ZGFkQ2xhbW9yQ2xhbkNsYXJvQ2xhc2VDbGF2ZUNsaWVudGVDbGltYUNsaS9uaWNhQ29icmVDb2NjaW8vbkNvY2hpbm9Db2NpbmFDb2NvQ28vZGlnb0NvZG9Db2ZyZUNvZ2VyQ29oZXRlQ29qaS9uQ29qb0NvbGFDb2xjaGFDb2xlZ2lvQ29sZ2FyQ29saW5hQ29sbGFyQ29sbW9Db2x1bW5hQ29tYmF0ZUNvbWVyQ29taWRhQ28vbW9kb0NvbXByYUNvbmRlQ29uZWpvQ29uZ2FDb25vY2VyQ29uc2Vqb0NvbnRhckNvcGFDb3BpYUNvcmF6by9uQ29yYmF0YUNvcmNob0NvcmRvL25Db3JvbmFDb3JyZXJDb3NlckNvc21vc0Nvc3RhQ3JhL25lb0NyYS90ZXJDcmVhckNyZWNlckNyZWkvZG9DcmVtYUNyaS9hQ3JpbWVuQ3JpcHRhQ3Jpc2lzQ3JvbW9Dcm8vbmljYUNyb3F1ZXRhQ3J1ZG9DcnV6Q3VhZHJvQ3VhcnRvQ3VhdHJvQ3Vib0N1YnJpckN1Y2hhcmFDdWVsbG9DdWVudG9DdWVyZGFDdWVzdGFDdWV2YUN1aWRhckN1bGVicmFDdWxwYUN1bHRvQ3VtYnJlQ3VtcGxpckN1bmFDdW5ldGFDdW90YUN1cG8vbkN1L3B1bGFDdXJhckN1cmlvc29DdXJzb0N1cnZhQ3V0aXNEYW1hRGFuemFEYXJEYXJkb0RhL3RpbERlYmVyRGUvYmlsRGUvY2FkYURlY2lyRGVkb0RlZmVuc2FEZWZpbmlyRGVqYXJEZWxmaS9uRGVsZ2Fkb0RlbGl0b0RlbW9yYURlbnNvRGVudGFsRGVwb3J0ZURlcmVjaG9EZXJyb3RhRGVzYXl1bm9EZXNlb0Rlc2ZpbGVEZXNudWRvRGVzdGlub0Rlc3ZpL29EZXRhbGxlRGV0ZW5lckRldWRhRGkvYURpYWJsb0RpYWRlbWFEaWFtYW50ZURpYW5hRGlhcmlvRGlidWpvRGljdGFyRGllbnRlRGlldGFEaWV6RGlmaS9jaWxEaWdub0RpbGVtYURpbHVpckRpbmVyb0RpcmVjdG9EaXJpZ2lyRGlzY29EaXNlfm9EaXNmcmF6RGl2YURpdmlub0RvYmxlRG9jZURvbG9yRG9taW5nb0RvbkRvbmFyRG9yYWRvRG9ybWlyRG9yc29Eb3NEb3Npc0RyYWdvL25Ecm9nYUR1Y2hhRHVkYUR1ZWxvRHVlfm9EdWxjZUR1L29EdXF1ZUR1cmFyRHVyZXphRHVyb0UvYmFub0VicmlvRWNoYXJFY29FY3VhZG9yRWRhZEVkaWNpby9uRWRpZmljaW9FZGl0b3JFZHVjYXJFZmVjdG9FZmljYXpFamVFamVtcGxvRWxlZmFudGVFbGVnaXJFbGVtZW50b0VsZXZhckVsaXBzZUUvbGl0ZUVsaXhpckVsb2dpb0VsdWRpckVtYnVkb0VtaXRpckVtb2Npby9uRW1wYXRlRW1wZX5vRW1wbGVvRW1wcmVzYUVuYW5vRW5jYXJnb0VuY2h1ZmVFbmNpL2FFbmVtaWdvRW5lcm9FbmZhZG9FbmZlcm1vRW5nYX5vRW5pZ21hRW5sYWNlRW5vcm1lRW5yZWRvRW5zYXlvRW5zZX5hckVudGVyb0VudHJhckVudmFzZUVudmkvb0UvcG9jYUVxdWlwb0VyaXpvRXNjYWxhRXNjZW5hRXNjb2xhckVzY3JpYmlyRXNjdWRvRXNlbmNpYUVzZmVyYUVzZnVlcnpvRXNwYWRhRXNwZWpvRXNwaS9hRXNwb3NhRXNwdW1hRXNxdWkvRXN0YXJFc3RlRXN0aWxvRXN0dWZhRXRhcGFFdGVybm9FL3RpY2FFdG5pYUV2YWRpckV2YWx1YXJFdmVudG9Fdml0YXJFeGFjdG9FeGFtZW5FeGNlc29FeGN1c2FFeGVudG9FeGlnaXJFeGlsaW9FeGlzdGlyRS94aXRvRXhwZXJ0b0V4cGxpY2FyRXhwb25lckV4dHJlbW9GYS9icmljYUZhL2J1bGFGYWNoYWRhRmEvY2lsRmFjdG9yRmFlbmFGYWphRmFsZGFGYWxsb0ZhbHNvRmFsdGFyRmFtYUZhbWlsaWFGYW1vc29GYXJhby9uRmFybWFjaWFGYXJvbEZhcnNhRmFzZUZhdGlnYUZhdW5hRmF2b3JGYXhGZWJyZXJvRmVjaGFGZWxpekZlb0ZlcmlhRmVyb3pGZS9ydGlsRmVydm9yRmVzdGkvbkZpYWJsZUZpYW56YUZpYXJGaWJyYUZpY2Npby9uRmljaGFGaWRlb0ZpZWJyZUZpZWxGaWVyYUZpZXN0YUZpZ3VyYUZpamFyRmlqb0ZpbGFGaWxldGVGaWxpYWxGaWx0cm9GaW5GaW5jYUZpbmdpckZpbml0b0Zpcm1hRmxhY29GbGF1dGFGbGVjaGFGbG9yRmxvdGFGbHVpckZsdWpvRmx1L29yRm9iaWFGb2NhRm9nYXRhRm9nby9uRm9saW9Gb2xsZXRvRm9uZG9Gb3JtYUZvcnJvRm9ydHVuYUZvcnphckZvc2FGb3RvRnJhY2Fzb0ZyYS9naWxGcmFuamFGcmFzZUZyYXVkZUZyZWkvckZyZW5vRnJlc2FGcmkvb0ZyaXRvRnJ1dGFGdWVnb0Z1ZW50ZUZ1ZXJ6YUZ1Z2FGdW1hckZ1bmNpby9uRnVuZGFGdXJnby9uRnVyaWFGdXNpbEZ1L3Rib2xGdXR1cm9HYWNlbGFHYWZhc0dhaXRhR2Fqb0dhbGFHYWxlcmkvYUdhbGxvR2FtYmFHYW5hckdhbmNob0dhbmdhR2Fuc29HYXJhamVHYXJ6YUdhc29saW5hR2FzdGFyR2F0b0dhdmlsYS9uR2VtZWxvR2VtaXJHZW5HZS9uZXJvR2VuaW9HZW50ZUdlcmFuaW9HZXJlbnRlR2VybWVuR2VzdG9HaWdhbnRlR2ltbmFzaW9HaXJhckdpcm9HbGFjaWFyR2xvYm9HbG9yaWFHb2xHb2xmb0dvbG9zb0dvbHBlR29tYUdvcmRvR29yaWxhR29ycmFHb3RhR290ZW9Hb3phckdyYWRhR3JhL2ZpY29HcmFub0dyYXNhR3JhdGlzR3JhdmVHcmlldGFHcmlsbG9HcmlwZUdyaXNHcml0b0dyb3NvckdydS9hR3J1ZXNvR3J1bW9HcnVwb0d1YW50ZUd1YXBvR3VhcmRpYUd1ZXJyYUd1aS9hR3Vpfm9HdWlvbkd1aXNvR3VpdGFycmFHdXNhbm9HdXN0YXJIYWJlckhhL2JpbEhhYmxhckhhY2VySGFjaGFIYWRhSGFsbGFySGFtYWNhSGFyaW5hSGF6SGF6YX5hSGViaWxsYUhlYnJhSGVjaG9IZWxhZG9IZWxpb0hlbWJyYUhlcmlySGVybWFub0hlL3JvZUhlcnZpckhpZWxvSGllcnJvSGkvZ2Fkb0hpZ2llbmVIaWpvSGltbm9IaXN0b3JpYUhvY2ljb0hvZ2FySG9ndWVyYUhvamFIb21icmVIb25nb0hvbm9ySG9ucmFIb3JhSG9ybWlnYUhvcm5vSG9zdGlsSG95b0h1ZWNvSHVlbGdhSHVlcnRhSHVlc29IdWV2b0h1aWRhSHVpckh1bWFub0h1L21lZG9IdW1pbGRlSHVtb0h1bmRpckh1cmFjYS9uSHVydG9JY29ub0lkZWFsSWRpb21hSS9kb2xvSWdsZXNpYUlnbHUvSWd1YWxJbGVnYWxJbHVzaW8vbkltYWdlbkltYS9uSW1pdGFySW1wYXJJbXBlcmlvSW1wb25lckltcHVsc29JbmNhcGF6SS9uZGljZUluZXJ0ZUluZmllbEluZm9ybWVJbmdlbmlvSW5pY2lvSW5tZW5zb0lubXVuZUlubmF0b0luc2VjdG9JbnN0YW50ZUludGVyZS9zSS9udGltb0ludHVpckludS90aWxJbnZpZXJub0lyYUlyaXNJcm9uaS9hSXNsYUlzbG90ZUphYmFsaS9KYWJvL25KYW1vL25KYXJhYmVKYXJkaS9uSmFycmFKYXVsYUphem1pL25KZWZlSmVyaW5nYUppbmV0ZUpvcm5hZGFKb3JvYmFKb3ZlbkpveWFKdWVyZ2FKdWV2ZXNKdWV6SnVnYWRvckp1Z29KdWd1ZXRlSnVpY2lvSnVuY29KdW5nbGFKdW5pb0p1bnRhckp1L3BpdGVySnVyYXJKdXN0b0p1dmVuaWxKdXpnYXJLaWxvS29hbGFMYWJpb0xhY2lvTGFjcmFMYWRvTGFkcm8vbkxhZ2FydG9MYS9ncmltYUxhZ3VuYUxhaWNvTGFtZXJMYS9taW5hTGEvbXBhcmFMYW5hTGFuY2hhTGFuZ29zdGFMYW56YUxhL3BpekxhcmdvTGFydmFMYS9zdGltYUxhdGFMYS90ZXhMYXRpckxhdXJlbExhdmFyTGF6b0xlYWxMZWNjaW8vbkxlY2hlTGVjdG9yTGVlckxlZ2lvL25MZWd1bWJyZUxlamFub0xlbmd1YUxlbnRvTGV+YUxlby9uTGVvcGFyZG9MZXNpby9uTGV0YWxMZXRyYUxldmVMZXllbmRhTGliZXJ0YWRMaWJyb0xpY29yTGkvZGVyTGlkaWFyTGllbnpvTGlnYUxpZ2Vyb0xpbWFMaS9taXRlTGltby9uTGltcGlvTGluY2VMaW5kb0xpL25lYUxpbmdvdGVMaW5vTGludGVybmFMaS9xdWlkb0xpc29MaXN0YUxpdGVyYUxpdGlvTGl0cm9MbGFnYUxsYW1hTGxhbnRvTGxhdmVMbGVnYXJMbGVuYXJMbGV2YXJMbG9yYXJMbG92ZXJMbHV2aWFMb2JvTG9jaW8vbkxvY29Mb2N1cmFMby9naWNhTG9ncm9Mb21icml6TG9tb0xvbmphTG90ZUx1Y2hhTHVjaXJMdWdhckx1am9MdW5hTHVuZXNMdXBhTHVzdHJvTHV0b0x1ek1hY2V0YU1hY2hvTWFkZXJhTWFkcmVNYWR1cm9NYWVzdHJvTWFmaWFNYWdpYU1hZ29NYWkvek1hbGRhZE1hbGV0YU1hbGxhTWFsb01hbWEvTWFtYm9NYW11dE1hbmNvTWFuZG9NYW5lamFyTWFuZ2FNYW5pcXVpL01hbmphck1hbm9NYW5zb01hbnRhTWF+YW5hTWFwYU1hL3F1aW5hTWFyTWFyY29NYXJlYU1hcmZpbE1hcmdlbk1hcmlkb01hL3Jtb2xNYXJyby9uTWFydGVzTWFyem9NYXNhTWEvc2NhcmFNYXNpdm9NYXRhck1hdGVyaWFNYXRpek1hdHJpek1hL3hpbW9NYXlvck1hem9yY2FNZWNoYU1lZGFsbGFNZWRpb01lL2R1bGFNZWppbGxhTWVqb3JNZWxlbmFNZWxvL25NZW1vcmlhTWVub3JNZW5zYWplTWVudGVNZW51L01lcmNhZG9NZXJlbmd1ZU1lL3JpdG9NZXNNZXNvL25NZXRhTWV0ZXJNZS90b2RvTWV0cm9NZXpjbGFNaWVkb01pZWxNaWVtYnJvTWlnYU1pbE1pbGFncm9NaWxpdGFyTWlsbG8vbk1pbW9NaW5hTWluZXJvTWkvbmltb01pbnV0b01pb3BlTWlyYXJNaXNhTWlzZXJpYU1pc2lsTWlzbW9NaXRhZE1pdG9Nb2NoaWxhTW9jaW8vbk1vZGFNb2RlbG9Nb2hvTW9qYXJNb2xkZU1vbGVyTW9saW5vTW9tZW50b01vbWlhTW9uYXJjYU1vbmVkYU1vbmphTW9udG9Nb35vTW9yYWRhTW9yZGVyTW9yZW5vTW9yaXJNb3Jyb01vcnNhTW9ydGFsTW9zY2FNb3N0cmFyTW90aXZvTW92ZXJNby92aWxNb3pvTXVjaG9NdWRhck11ZWJsZU11ZWxhTXVlcnRlTXVlc3RyYU11Z3JlTXVqZXJNdWxhTXVsZXRhTXVsdGFNdW5kb011fmVjYU11cmFsTXVyb011L3NjdWxvTXVzZW9NdXNnb011L3NpY2FNdXNsb05hL2Nhck5hY2lvL25OYWRhck5haXBlTmFyYW5qYU5hcml6TmFycmFyTmFzYWxOYXRhbE5hdGl2b05hdHVyYWxOYS91c2VhTmF2YWxOYXZlTmF2aWRhZE5lY2lvTmUvY3Rhck5lZ2FyTmVnb2Npb05lZ3JvTmVvL25OZXJ2aW9OZXRvTmV1dHJvTmV2YXJOZXZlcmFOaWNob05pZG9OaWVibGFOaWV0b05pfmV6Tml+b05pL3RpZG9OaXZlbE5vYmxlemFOb2NoZU5vL21pbmFOb3JpYU5vcm1hTm9ydGVOb3RhTm90aWNpYU5vdmF0b05vdmVsYU5vdmlvTnViZU51Y2FOdS9jbGVvTnVkaWxsb051ZG9OdWVyYU51ZXZlTnVlek51bG9OdS9tZXJvTnV0cmlhT2FzaXNPYmVzb09iaXNwb09iamV0b09icmFPYnJlcm9PYnNlcnZhck9idGVuZXJPYnZpb09jYU9jYXNvT2NlL2Fub09jaGVudGFPY2hvT2Npb09jcmVPY3Rhdm9PY3R1YnJlT2N1bHRvT2N1cGFyT2N1cnJpck9kaWFyT2Rpb09kaXNlYU9lc3RlT2ZlbnNhT2ZlcnRhT2ZpY2lvT2ZyZWNlck9ncm9PaS9kb09pL3JPam9PbGFPbGVhZGFPbGZhdG9PbGl2b09sbGFPbG1vT2xvck9sdmlkb09tYmxpZ29PbmRhT256YU9wYWNvT3BjaW8vbk8vcGVyYU9waW5hck9wb25lck9wdGFyTy9wdGljYU9wdWVzdG9PcmFjaW8vbk9yYWRvck9yYWxPL3JiaXRhT3JjYU9yZGVuT3JlamFPL3JnYW5vT3JnaS9hT3JndWxsb09yaWVudGVPcmlnZW5PcmlsbGFPcm9PcnF1ZXN0YU9ydWdhT3NhZGkvYU9zY3Vyb09zZXpub09zb09zdHJhT3Rvfm9PdHJvT3ZlamFPL3Z1bG9PL3hpZG9PeGkvZ2Vub095ZW50ZU96b25vUGFjdG9QYWRyZVBhZWxsYVBhL2dpbmFQYWdvUGFpL3NQYS9qYXJvUGFsYWJyYVBhbGNvUGFsZXRhUGEvbGlkb1BhbG1hUGFsb21hUGFscGFyUGFuUGFuYWxQYS9uaWNvUGFudGVyYVBhfnVlbG9QYXBhL1BhcGVsUGFwaWxsYVBhcXVldGVQYXJhclBhcmNlbGFQYXJlZFBhcmlyUGFyb1BhL3JwYWRvUGFycXVlUGEvcnJhZm9QYXJ0ZVBhc2FyUGFzZW9QYXNpby9uUGFzb1Bhc3RhUGF0YVBhdGlvUGF0cmlhUGF1c2FQYXV0YVBhdm9QYXlhc29QZWF0by9uUGVjYWRvUGVjZXJhUGVjaG9QZWRhbFBlZGlyUGVnYXJQZWluZVBlbGFyUGVsZGF+b1BlbGVhUGVsaWdyb1BlbGxlam9QZWxvUGVsdWNhUGVuYVBlbnNhclBlfm8vblBlby9uUGVvclBlcGlub1BlcXVlfm9QZXJhUGVyY2hhUGVyZGVyUGVyZXphUGVyZmlsUGVyaWNvUGVybGFQZXJtaXNvUGVycm9QZXJzb25hUGVzYVBlc2NhUGUvc2ltb1Blc3RhfmFQZS90YWxvUGV0cm8vbGVvUGV6UGV6dX5hUGljYXJQaWNoby9uUGllUGllZHJhUGllcm5hUGllemFQaWphbWFQaWxhclBpbG90b1BpbWllbnRhUGlub1BpbnRvclBpbnphUGl+YVBpb2pvUGlwYVBpcmF0YVBpc2FyUGlzY2luYVBpc29QaXN0YVBpdG8vblBpemNhUGxhY2FQbGFuUGxhdGFQbGF5YVBsYXphUGxlaXRvUGxlbm9QbG9tb1BsdW1hUGx1cmFsUG9icmVQb2NvUG9kZXJQb2Rpb1BvZW1hUG9lc2kvYVBvZXRhUG9sZW5Qb2xpY2kvYVBvbGxvUG9sdm9Qb21hZGFQb21lbG9Qb21vUG9tcGFQb25lclBvcmNpby9uUG9ydGFsUG9zYWRhUG9zZWVyUG9zaWJsZVBvc3RlUG90ZW5jaWFQb3Ryb1Bvem9QcmFkb1ByZWNvelByZWd1bnRhUHJlbWlvUHJlbnNhUHJlc29QcmV2aW9Qcmltb1ByaS9uY2lwZVByaXNpby9uUHJpdmFyUHJvYVByb2JhclByb2Nlc29Qcm9kdWN0b1Byb2V6YVByb2Zlc29yUHJvZ3JhbWFQcm9sZVByb21lc2FQcm9udG9Qcm9waW9Qcm8veGltb1BydWViYVB1L2JsaWNvUHVjaGVyb1B1ZG9yUHVlYmxvUHVlcnRhUHVlc3RvUHVsZ2FQdWxpclB1bG1vL25QdWxwb1B1bHNvUHVtYVB1bnRvUHV+YWxQdX5vUHVwYVB1cGlsYVB1cmUvUXVlZGFyUXVlamFRdWVtYXJRdWVyZXJRdWVzb1F1aWV0b1F1aS9taWNhUXVpbmNlUXVpdGFyUmEvYmFub1JhYmlhUmFib1JhY2lvL25SYWRpY2FsUmFpL3pSYW1hUmFtcGFSYW5jaG9SYW5nb1JhcGF6UmEvcGlkb1JhcHRvUmFzZ29SYXNwYVJhdG9SYXlvUmF6YVJhem8vblJlYWNjaW8vblJlYWxpZGFkUmViYX5vUmVib3RlUmVjYWVyUmVjZXRhUmVjaGF6b1JlY29nZXJSZWNyZW9SZWN0b1JlY3Vyc29SZWRSZWRvbmRvUmVkdWNpclJlZmxlam9SZWZvcm1hUmVmcmEvblJlZnVnaW9SZWdhbG9SZWdpclJlZ2xhUmVncmVzb1JlaGUvblJlaW5vUmVpL3JSZWphUmVsYXRvUmVsZXZvUmVsaWV2ZVJlbGxlbm9SZWxvalJlbWFyUmVtZWRpb1JlbW9SZW5jb3JSZW5kaXJSZW50YVJlcGFydG9SZXBldGlyUmVwb3NvUmVwdGlsUmVzUmVzY2F0ZVJlc2luYVJlc3BldG9SZXN0b1Jlc3VtZW5SZXRpcm9SZXRvcm5vUmV0cmF0b1JldW5pclJldmUvc1JldmlzdGFSZXlSZXphclJpY29SaWVnb1JpZW5kYVJpZXNnb1JpZmFSaS9naWRvUmlnb3JSaW5jby9uUml+by9uUmkvb1JpcXVlemFSaXNhUml0bW9SaXRvUml6b1JvYmxlUm9jZVJvY2lhclJvZGFyUm9kZW9Sb2RpbGxhUm9lclJvaml6b1Jvam9Sb21lcm9Sb21wZXJSb25Sb25jb1JvbmRhUm9wYVJvcGVyb1Jvc2FSb3NjYVJvc3Ryb1JvdGFyUnViaS9SdWJvclJ1ZG9SdWVkYVJ1Z2lyUnVpZG9SdWluYVJ1bGV0YVJ1bG9SdW1ib1J1bW9yUnVwdHVyYVJ1dGFSdXRpbmFTYS9iYWRvU2FiZXJTYWJpb1NhYmxlU2FjYXJTYWdhelNhZ3JhZG9TYWxhU2FsZG9TYWxlcm9TYWxpclNhbG1vL25TYWxvL25TYWxzYVNhbHRvU2FsdWRTYWx2YXJTYW1iYVNhbmNpby9uU2FuZGkvYVNhbmVhclNhbmdyZVNhbmlkYWRTYW5vU2FudG9TYXBvU2FxdWVTYXJkaW5hU2FydGUvblNhc3RyZVNhdGEvblNhdW5hU2F4b2ZvL25TZWNjaW8vblNlY29TZWNyZXRvU2VjdGFTZWRTZWd1aXJTZWlzU2VsbG9TZWx2YVNlbWFuYVNlbWlsbGFTZW5kYVNlbnNvclNlfmFsU2V+b3JTZXBhcmFyU2VwaWFTZXF1aS9hU2VyU2VyaWVTZXJtby9uU2VydmlyU2VzZW50YVNlc2lvL25TZXRhU2V0ZW50YVNldmVyb1NleG9TZXh0b1NpZHJhU2llc3RhU2lldGVTaWdsb1NpZ25vU2kvbGFiYVNpbGJhclNpbGVuY2lvU2lsbGFTaS9tYm9sb1NpbWlvU2lyZW5hU2lzdGVtYVNpdGlvU2l0dWFyU29icmVTb2Npb1NvZGlvU29sU29sYXBhU29sZGFkb1NvbGVkYWRTby9saWRvU29sdGFyU29sdWNpby9uU29tYnJhU29uZGVvU29uaWRvU29ub3JvU29ucmlzYVNvcGFTb3BsYXJTb3BvcnRlU29yZG9Tb3JwcmVzYVNvcnRlb1Nvc3RlL25Tby90YW5vU3VhdmVTdWJpclN1Y2Vzb1N1ZG9yU3VlZ3JhU3VlbG9TdWV+b1N1ZXJ0ZVN1ZnJpclN1amV0b1N1bHRhL25TdW1hclN1cGVyYXJTdXBsaXJTdXBvbmVyU3VwcmVtb1N1clN1cmNvU3VyZX5vU3VyZ2lyU3VzdG9TdXRpbFRhYmFjb1RhYmlxdWVUYWJsYVRhYnUvVGFjb1RhY3RvVGFqb1RhbGFyVGFsY29UYWxlbnRvVGFsbGFUYWxvL25UYW1hfm9UYW1ib3JUYW5nb1RhbnF1ZVRhcGFUYXBldGVUYXBpYVRhcG8vblRhcXVpbGxhVGFyZGVUYXJlYVRhcmlmYVRhcmpldGFUYXJvdFRhcnJvVGFydGFUYXR1YWplVGF1cm9UYXphVGF6by9uVGVhdHJvVGVjaG9UZWNsYVRlL2NuaWNhVGVqYWRvVGVqZXJUZWppZG9UZWxhVGVsZS9mb25vVGVtYVRlbW9yVGVtcGxvVGVuYXpUZW5kZXJUZW5lclRlbmlzVGVuc29UZW9yaS9hVGVyYXBpYVRlcmNvVGUvcm1pbm9UZXJudXJhVGVycm9yVGVzaXNUZXNvcm9UZXN0aWdvVGV0ZXJhVGV4dG9UZXpUaWJpb1RpYnVyby9uVGllbXBvVGllbmRhVGllcnJhVGllc29UaWdyZVRpamVyYVRpbGRlVGltYnJlVGkvbWlkb1RpbW9UaW50YVRpL29UaS9waWNvVGlwb1RpcmFUaXJvL25UaXRhL25UaS90ZXJlVGkvdHVsb1RpemFUb2FsbGFUb2JpbGxvVG9jYXJUb2Npbm9Ub2RvVG9nYVRvbGRvVG9tYXJUb25vVG9udG9Ub3BhclRvcGVUb3F1ZVRvL3JheFRvcmVyb1Rvcm1lbnRhVG9ybmVvVG9yb1RvcnBlZG9Ub3JyZVRvcnNvVG9ydHVnYVRvc1Rvc2NvVG9zZXJUby94aWNvVHJhYmFqb1RyYWN0b3JUcmFlclRyYS9maWNvVHJhZ29UcmFqZVRyYW1vVHJhbmNlVHJhdG9UcmF1bWFUcmF6YXJUcmUvYm9sVHJlZ3VhVHJlaW50YVRyZW5UcmVwYXJUcmVzVHJpYnVUcmlnb1RyaXBhVHJpc3RlVHJpdW5mb1Ryb2Zlb1Ryb21wYVRyb25jb1Ryb3BhVHJvdGVUcm96b1RydWNvVHJ1ZW5vVHJ1ZmFUdWJlcmkvYVR1Ym9UdWVydG9UdW1iYVR1bW9yVHUvbmVsVHUvbmljYVR1cmJpbmFUdXJpc21vVHVybm9UdXRvclViaWNhclUvbGNlcmFVbWJyYWxVbmlkYWRVbmlyVW5pdmVyc29Vbm9VbnRhclV+YVVyYmFub1VyYmVVcmdlbnRlVXJuYVVzYXJVc3VhcmlvVS90aWxVdG9waS9hVXZhVmFjYVZhY2kvb1ZhY3VuYVZhZ2FyVmFnb1ZhaW5hVmFqaWxsYVZhbGVWYS9saWRvVmFsbGVWYWxvclZhL2x2dWxhVmFtcGlyb1ZhcmFWYXJpYXJWYXJvL25WYXNvVmVjaW5vVmVjdG9yVmVoaS9jdWxvVmVpbnRlVmVqZXpWZWxhVmVsZXJvVmVsb3pWZW5hVmVuY2VyVmVuZGFWZW5lbm9WZW5nYXJWZW5pclZlbnRhVmVudXNWZXJWZXJhbm9WZXJib1ZlcmRlVmVyZWRhVmVyamFWZXJzb1ZlcnRlclZpL2FWaWFqZVZpYnJhclZpY2lvVmkvY3RpbWFWaWRhVmkvZGVvVmlkcmlvVmllam9WaWVybmVzVmlnb3JWaWxWaWxsYVZpbmFncmVWaW5vVml+ZWRvVmlvbGkvblZpcmFsVmlyZ29WaXJ0dWRWaXNvclZpL3NwZXJhVmlzdGFWaXRhbWluYVZpdWRvVml2YXpWaXZlcm9WaXZpclZpdm9Wb2xjYS9uVm9sdW1lblZvbHZlclZvcmF6Vm90YXJWb3RvVm96VnVlbG9WdWxnYXJZYWNlcllhdGVZZWd1YVllbWFZZXJub1llc29Zb2RvWW9nYVlvZ3VyWmFmaXJvWmFuamFaYXBhdG9aYXJ6YVpvbmFab3Jyb1p1bW9adXJkb1wiO2NvbnN0IGxvb2t1cD17fTtsZXQgd29yZGxpc3QkMj1udWxsO2Z1bmN0aW9uIGRyb3BEaWFjcml0aWMod29yZCl7bG9nZ2VyJGsuY2hlY2tOb3JtYWxpemUoKTtyZXR1cm4gdG9VdGY4U3RyaW5nKEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0b1V0ZjhCeXRlcyh3b3JkLm5vcm1hbGl6ZShcIk5GRFwiKS50b0xvd2VyQ2FzZSgpKSxjPT57cmV0dXJuIGM+PTY1JiZjPD05MHx8Yz49OTcmJmM8PTEyM30pKX1mdW5jdGlvbiBleHBhbmQod29yZCl7Y29uc3Qgb3V0cHV0PVtdO0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodG9VdGY4Qnl0ZXMod29yZCksYz0+e2lmKGM9PT00Nyl7b3V0cHV0LnB1c2goMjA0KTtvdXRwdXQucHVzaCgxMjkpfWVsc2UgaWYoYz09PTEyNil7b3V0cHV0LnB1c2goMTEwKTtvdXRwdXQucHVzaCgyMDQpO291dHB1dC5wdXNoKDEzMSl9ZWxzZXtvdXRwdXQucHVzaChjKX19KTtyZXR1cm4gdG9VdGY4U3RyaW5nKG91dHB1dCl9ZnVuY3Rpb24gbG9hZFdvcmRzJDIobGFuZyl7aWYod29yZGxpc3QkMiE9bnVsbCl7cmV0dXJufXdvcmRsaXN0JDI9d29yZHMkMi5yZXBsYWNlKC8oW0EtWl0pL2csXCIgJDFcIikudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkuc3BsaXQoXCIgXCIpLm1hcCh3PT5leHBhbmQodykpO3dvcmRsaXN0JDIuZm9yRWFjaCgod29yZCxpbmRleCk9Pntsb29rdXBbZHJvcERpYWNyaXRpYyh3b3JkKV09aW5kZXh9KTtpZihXb3JkbGlzdC5jaGVjayhsYW5nKSE9PVwiMHhmNzRmYjcwOTJhZWFjZGZiZjg5NTk1NTdkZTIyMDk4ZGE1MTIyMDdmYjlmMTA5Y2I1MjY5OTQ5MzhjZjQwMzAwXCIpe3dvcmRsaXN0JDI9bnVsbDt0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3IgZXMgKFNwYW5pc2gpIEZBSUxFRFwiKX19Y2xhc3MgTGFuZ0VzIGV4dGVuZHMgV29yZGxpc3R7Y29uc3RydWN0b3IoKXtzdXBlcihcImVzXCIpfWdldFdvcmQoaW5kZXgpe2xvYWRXb3JkcyQyKHRoaXMpO3JldHVybiB3b3JkbGlzdCQyW2luZGV4XX1nZXRXb3JkSW5kZXgod29yZCl7bG9hZFdvcmRzJDIodGhpcyk7cmV0dXJuIGxvb2t1cFtkcm9wRGlhY3JpdGljKHdvcmQpXX19Y29uc3QgbGFuZ0VzPW5ldyBMYW5nRXM7V29yZGxpc3QucmVnaXN0ZXIobGFuZ0VzKTtcInVzZSBzdHJpY3RcIjtjb25zdCB3b3JkcyQzPVwiQWJhaXNzZXJBYmFuZG9uQWJkaXF1ZXJBYmVpbGxlQWJvbGlyQWJvcmRlckFib3V0aXJBYm95ZXJBYnJhc2lmQWJyZXV2ZXJBYnJpdGVyQWJyb2dlckFicnVwdEFic2VuY2VBYnNvbHVBYnN1cmRlQWJ1c2lmQWJ5c3NhbEFjYWRlL21pZUFjYWpvdUFjYXJpZW5BY2NhYmxlckFjY2VwdGVyQWNjbGFtZXJBY2NvbGFkZUFjY3JvY2hlQWNjdXNlckFjZXJiZUFjaGF0QWNoZXRlckFjaWR1bGVyQWNpZXJBY29tcHRlQWNxdWUvcmlyQWNyb255bWVBY3RldXJBY3RpZkFjdHVlbEFkZXB0ZUFkZS9xdWF0QWRoZS9zaWZBZGplY3RpZkFkanVnZXJBZG1ldHRyZUFkbWlyZXJBZG9wdGVyQWRvcmVyQWRvdWNpckFkcmVzc2VBZHJvaXRBZHVsdGVBZHZlcmJlQWUvcmVyQWUvcm9uZWZBZmZhaXJlQWZmZWN0ZXJBZmZpY2hlQWZmcmV1eEFmZnVibGVyQWdhY2VyQWdlbmNlckFnaWxlQWdpdGVyQWdyYWZlckFncmUvYWJsZUFncnVtZUFpZGVyQWlndWlsbGVBaWxpZXJBaW1hYmxlQWlzYW5jZUFqb3V0ZXJBanVzdGVyQWxhcm1lckFsY2hpbWllQWxlcnRlQWxnZS1icmVBbGd1ZUFsaWUvbmVyQWxpbWVudEFsbGUvZ2VyQWxsaWFnZUFsbG91ZXJBbGx1bWVyQWxvdXJkaXJBbHBhZ2FBbHRlc3NlQWx2ZS9vbGVBbWF0ZXVyQW1iaWd1QW1icmVBbWUvbmFnZXJBbWVydHVtZUFtaWRvbkFtaXJhbEFtb3JjZXJBbW91ckFtb3ZpYmxlQW1waGliaWVBbXBsZXVyQW11c2FudEFuYWx5c2VBbmFwaG9yZUFuYXJjaGllQW5hdG9taWVBbmNpZW5BbmUvYW50aXJBbmdsZUFuZ29pc3NlQW5ndWxldXhBbmltYWxBbm5leGVyQW5ub25jZUFubnVlbEFub2RpbkFub21hbGllQW5vbnltZUFub3JtYWxBbnRlbm5lQW50aWRvdGVBbnhpZXV4QXBhaXNlckFwZS9yaXRpZkFwbGFuaXJBcG9sb2dpZUFwcGFyZWlsQXBwZWxlckFwcG9ydGVyQXBwdXllckFxdWFyaXVtQXF1ZWR1Y0FyYml0cmVBcmJ1c3RlQXJkZXVyQXJkb2lzZUFyZ2VudEFybGVxdWluQXJtYXR1cmVBcm1lbWVudEFybW9pcmVBcm11cmVBcnBlbnRlckFycmFjaGVyQXJyaXZlckFycm9zZXJBcnNlbmljQXJ0ZS9yaWVsQXJ0aWNsZUFzcGVjdEFzcGhhbHRlQXNwaXJlckFzc2F1dEFzc2VydmlyQXNzaWV0dGVBc3NvY2llckFzc3VyZXJBc3RpY290QXN0cmVBc3R1Y2VBdGVsaWVyQXRvbWVBdHJpdW1BdHJvY2VBdHRhcXVlQXR0ZW50aWZBdHRpcmVyQXR0cmFwZXJBdWJhaW5lQXViZXJnZUF1ZGFjZUF1ZGlibGVBdWd1cmVyQXVyb3JlQXV0b21uZUF1dHJ1Y2hlQXZhbGVyQXZhbmNlckF2YXJpY2VBdmVuaXJBdmVyc2VBdmV1Z2xlQXZpYXRldXJBdmlkZUF2aW9uQXZpc2VyQXZvaW5lQXZvdWVyQXZyaWxBeGlhbEF4aW9tZUJhZGdlQmFmb3VlckJhZ2FnZUJhZ3VldHRlQmFpZ25hZGVCYWxhbmNlckJhbGNvbkJhbGVpbmVCYWxpc2FnZUJhbWJpbkJhbmNhaXJlQmFuZGFnZUJhbmxpZXVlQmFubmllLXJlQmFucXVpZXJCYXJiaWVyQmFyaWxCYXJvbkJhcnF1ZUJhcnJhZ2VCYXNzaW5CYXN0aW9uQmF0YWlsbGVCYXRlYXVCYXR0ZXJpZUJhdWRyaWVyQmF2YXJkZXJCZWxldHRlQmUvbGllckJlbG90ZUJlL25lL2ZpY2VCZXJjZWF1QmVyZ2VyQmVybGluZUJlcm11ZGFCZXNhY2VCZXNvZ25lQmUvdGFpbEJldXJyZUJpYmVyb25CaWN5Y2xlQmlkdWxlQmlqb3VCaWxhbkJpbGluZ3VlQmlsbGFyZEJpbmFpcmVCaW9sb2dpZUJpb3BzaWVCaW90eXBlQmlzY3VpdEJpc29uQmlzdG91cmlCaXR1bWVCaXphcnJlQmxhZmFyZEJsYWd1ZUJsYW5jaGlyQmxlc3NhbnRCbGluZGVyQmxvbmRCbG9xdWVyQmxvdXNvbkJvYmFyZEJvYmluZUJvaXJlQm9pc2VyQm9saWRlQm9uYm9uQm9uZGlyQm9uaGV1ckJvbmlmaWVyQm9udXNCb3JkdXJlQm9ybmVCb3R0ZUJvdWNsZUJvdWV1eEJvdWdpZUJvdWxvbkJvdXF1aW5Cb3Vyc2VCb3Vzc29sZUJvdXRpcXVlQm94ZXVyQnJhbmNoZUJyYXNpZXJCcmF2ZUJyZWJpc0JyZS1jaGVCcmV1dmFnZUJyaWNvbGVyQnJpZ2FkZUJyaWxsYW50QnJpb2NoZUJyaXF1ZUJyb2NodXJlQnJvZGVyQnJvbnplckJyb3Vzc2VCcm95ZXVyQnJ1bWVCcnVzcXVlQnJ1dGFsQnJ1eWFudEJ1ZmZsZUJ1aXNzb25CdWxsZXRpbkJ1cmVhdUJ1cmluQnVzdGllckJ1dGluZXJCdXRvaXJCdXZhYmxlQnV2ZXR0ZUNhYmFub25DYWJpbmVDYWNoZXR0ZUNhZGVhdUNhZHJlQ2FmZS9pbmVDYWlsbG91Q2Fpc3NvbkNhbGN1bGVyQ2FsZXBpbkNhbGlicmVDYWxtZXJDYWxvbW5pZUNhbHZhaXJlQ2FtYXJhZGVDYW1lL3JhQ2FtaW9uQ2FtcGFnbmVDYW5hbENhbmV0b25DYW5vbkNhbnRpbmVDYW51bGFyQ2FwYWJsZUNhcG9yYWxDYXByaWNlQ2Fwc3VsZUNhcHRlckNhcHVjaGVDYXJhYmluZUNhcmJvbmVDYXJlc3NlckNhcmlib3VDYXJuYWdlQ2Fyb3R0ZUNhcnJlYXVDYXJ0b25DYXNjYWRlQ2FzaWVyQ2FzcXVlQ2Fzc3VyZUNhdXNlckNhdXRpb25DYXZhbGllckNhdmVybmVDYXZpYXJDZS9kaWxsZUNlaW50dXJlQ2UvbGVzdGVDZWxsdWxlQ2VuZHJpZXJDZW5zdXJlckNlbnRyYWxDZXJjbGVDZS9yZS9icmFsQ2VyaXNlQ2VybmVyQ2VydmVhdUNlc3NlckNoYWdyaW5DaGFpc2VDaGFsZXVyQ2hhbWJyZUNoYW5jZUNoYXBpdHJlQ2hhcmJvbkNoYXNzZXVyQ2hhdG9uQ2hhdXNzb25DaGF2aXJlckNoZW1pc2VDaGVuaWxsZUNoZS9xdWllckNoZXJjaGVyQ2hldmFsQ2hpZW5DaGlmZnJlQ2hpZ25vbkNoaW1lLXJlQ2hpb3RDaGxvcnVyZUNob2NvbGF0Q2hvaXNpckNob3NlQ2hvdWV0dGVDaHJvbWVDaHV0ZUNpZ2FyZUNpZ29nbmVDaW1lbnRlckNpbmUvbWFDaW50cmVyQ2lyY3VsZXJDaXJlckNpcnF1ZUNpdGVybmVDaXRveWVuQ2l0cm9uQ2l2aWxDbGFpcm9uQ2xhbWV1ckNsYXF1ZXJDbGFzc2VDbGF2aWVyQ2xpZW50Q2xpZ25lckNsaW1hdENsaXZhZ2VDbG9jaGVDbG9uYWdlQ2xvcG9ydGVDb2JhbHRDb2JyYUNvY2Fzc2VDb2NvdGllckNvZGVyQ29kaWZpZXJDb2ZmcmVDb2duZXJDb2hlL3Npb25Db2lmZmVyQ29pbmNlckNvbGUtcmVDb2xpYnJpQ29sbGluZUNvbG1hdGVyQ29sb25lbENvbWJhdENvbWUvZGllQ29tbWFuZGVDb21wYWN0Q29uY2VydENvbmR1aXJlQ29uZmllckNvbmdlbGVyQ29ubm90ZXJDb25zb25uZUNvbnRhY3RDb252ZXhlQ29wYWluQ29waWVDb3JhaWxDb3JiZWF1Q29yZGFnZUNvcm5pY2hlQ29ycHVzQ29ycmVjdENvcnRlLWdlQ29zbWlxdWVDb3N0dW1lQ290b25Db3VkZUNvdXB1cmVDb3VyYWdlQ291dGVhdUNvdXZyaXJDb3lvdGVDcmFiZUNyYWludGVDcmF2YXRlQ3JheW9uQ3JlL2F0dXJlQ3JlL2RpdGVyQ3JlL21ldXhDcmV1c2VyQ3JldmV0dGVDcmlibGVyQ3JpZXJDcmlzdGFsQ3JpdGUtcmVDcm9pcmVDcm9xdWVyQ3JvdGFsZUNydWNpYWxDcnVlbENyeXB0ZXJDdWJpcXVlQ3VlaWxsaXJDdWlsbGUtcmVDdWlzaW5lQ3VpdnJlQ3VsbWluZXJDdWx0aXZlckN1bXVsZXJDdXBpZGVDdXJhdGlmQ3Vyc2V1ckN5YW51cmVDeWNsZUN5bGluZHJlQ3luaXF1ZURhaWduZXJEYW1pZXJEYW5nZXJEYW5zZXVyRGF1cGhpbkRlL2JhdHRyZURlL2JpdGVyRGUvYm9yZGVyRGUvYnJpZGVyRGUvYnV0YW50RGUvY2FsZXJEZS9jZW1icmVEZS9jaGlyZXJEZS9jaWRlckRlL2NsYXJlckRlL2NvcmVyRGUvY3JpcmVEZS9jdXBsZXJEZS9kYWxlRGUvZHVjdGlmRGUvZXNzZURlL2ZlbnNpZkRlL2ZpbGVyRGUvZnJheWVyRGUvZ2FnZXJEZS9naXZyZXJEZS9nbHV0aXJEZS9ncmFmZXJEZS9qZXVuZXJEZS9saWNlRGUvbG9nZXJEZW1hbmRlckRlbWV1cmVyRGUvbW9saXJEZS9uaWNoZXJEZS9ub3VlckRlbnRlbGxlRGUvbnVkZXJEZS9wYXJ0RGUvcGVuc2VyRGUvcGhhc2VyRGUvcGxhY2VyRGUvcG9zZXJEZS9yYW5nZXJEZS9yb2JlckRlL3Nhc3RyZURlc2NlbnRlRGUvc2VydERlL3NpZ25lckRlL3NvYmUvaXJEZXNzaW5lckRlc3RyaWVyRGUvdGFjaGVyRGUvdGVzdGVyRGUvdG91cmVyRGUvdHJlc3NlRGV2YW5jZXJEZXZlbmlyRGV2aW5lckRldm9pckRpYWJsZURpYWxvZ3VlRGlhbWFudERpY3RlckRpZmZlL3JlckRpZ2UvcmVyRGlnaXRhbERpZ25lRGlsdWVyRGltYW5jaGVEaW1pbnVlckRpb3h5ZGVEaXJlY3RpZkRpcmlnZXJEaXNjdXRlckRpc3Bvc2VyRGlzc2lwZXJEaXN0YW5jZURpdmVydGlyRGl2aXNlckRvY2lsZURvY3RldXJEb2dtZURvaWd0RG9tYWluZURvbWljaWxlRG9tcHRlckRvbmF0ZXVyRG9uam9uRG9ubmVyRG9wYW1pbmVEb3J0b2lyRG9ydXJlRG9zYWdlRG9zZXVyRG9zc2llckRvdGF0aW9uRG91YW5pZXJEb3VibGVEb3VjZXVyRG91dGVyRG95ZW5EcmFnb25EcmFwZXJEcmVzc2VyRHJpYmJsZXJEcm9pdHVyZUR1cGVyaWVEdXBsZXhlRHVyYWJsZUR1cmNpckR5bmFzdGllRS9ibG91aXJFL2NhcnRlckUvY2hhcnBlRS9jaGVsbGVFL2NsYWlyZXJFL2NsaXBzZUUvY2xvcmVFL2NsdXNlRS9jb2xlRS9jb25vbWllRS9jb3JjZUUvY291dGVyRS9jcmFzZXJFL2NyZS9tZXJFL2NyaXZhaW5FL2Nyb3VFL2N1bWVFL2N1cmV1aWxFL2RpZmllckUvZHVxdWVyRWZmYWNlckVmZmVjdGlmRWZmaWdpZUVmZm9ydEVmZnJheWVyRWZmdXNpb25FL2dhbGlzZXJFL2dhcmVyRS9qZWN0ZXJFL2xhYm9yZXJFL2xhcmdpckUvbGVjdHJvbkUvbGUvZ2FudEUvbGUvcGhhbnRFL2xlLXZlRS9saWdpYmxlRS9saXRpc21lRS9sb2dlRS9sdWNpZGVyRS9sdWRlckVtYmFsbGVyRW1iZWxsaXJFbWJyeW9uRS9tZXJhdWRlRS9taXNzaW9uRW1tZW5lckUvbW90aW9uRS9tb3V2b2lyRW1wZXJldXJFbXBsb3llckVtcG9ydGVyRW1wcmlzZUUvbXVsc2lvbkVuY2FkcmVyRW5jaGUtcmVFbmNsYXZlRW5jb2NoZUVuZGlndWVyRW5kb3NzZXJFbmRyb2l0RW5kdWlyZUUvbmVyZ2llRW5mYW5jZUVuZmVybWVyRW5mb3VpckVuZ2FnZXJFbmdpbkVuZ2xvYmVyRS9uaWdtZUVuamFtYmVyRW5qZXVFbmxldmVyRW5uZW1pRW5udXlldXhFbnJpY2hpckVucm9iYWdlRW5zZWlnbmVFbnRhc3NlckVudGVuZHJlRW50aWVyRW50b3VyZXJFbnRyYXZlckUvbnVtZS9yZXJFbnZhaGlyRW52aWFibGVFbnZveWVyRW56eW1lRS9vbGllbkUvcGFpc3NpckUvcGFyZ25lRS9wYXRhbnRFL3BhdWxlRS9waWNlcmllRS9waWRlL21pZUUvcGllckUvcGlsb2d1ZUUvcGluZUUvcGlzb2RlRS9waXRhcGhlRS9wb3F1ZUUvcHJldXZlRS9wcm91dmVyRS9wdWlzYW50RS9xdWVycmVFL3F1aXBlRS9yaWdlckUvcm9zaW9uRXJyZXVyRS9ydXB0aW9uRXNjYWxpZXJFc3BhZG9uRXNwZS1jZUVzcGllLWdsZUVzcG9pckVzcHJpdEVzcXVpdmVyRXNzYXllckVzc2VuY2VFc3NpZXVFc3NvcmVyRXN0aW1lRXN0b21hY0VzdHJhZGVFL3RhZ2UtcmVFL3RhbGVyRS90YW5jaGVFL3RhdGlxdWVFL3RlaW5kcmVFL3RlbmRvaXJFL3Rlcm5lbEUvdGhhbm9sRS90aGlxdWVFdGhuaWVFL3RpcmVyRS90b2ZmZXJFL3RvaWxlRS90b25uYW50RS90b3VyZGlyRS90cmFuZ2VFL3Ryb2l0RS90dWRlRXVwaG9yaWVFL3ZhbHVlckUvdmFzaW9uRS92ZW50YWlsRS92aWRlbmNlRS92aXRlckUvdm9sdXRpZkUvdm9xdWVyRXhhY3RFeGFnZS9yZXJFeGF1Y2VyRXhjZWxsZXJFeGNpdGFudEV4Y2x1c2lmRXhjdXNlRXhlL2N1dGVyRXhlbXBsZUV4ZXJjZXJFeGhhbGVyRXhob3J0ZXJFeGlnZW5jZUV4aWxlckV4aXN0ZXJFeG90aXF1ZUV4cGUvZGllckV4cGxvcmVyRXhwb3NlckV4cHJpbWVyRXhxdWlzRXh0ZW5zaWZFeHRyYWlyZUV4dWx0ZXJGYWJsZUZhYnVsZXV4RmFjZXR0ZUZhY2lsZUZhY3R1cmVGYWlibGlyRmFsYWlzZUZhbWV1eEZhbWlsbGVGYXJjZXVyRmFyZmVsdUZhcmluZUZhcm91Y2hlRmFzY2luZXJGYXRhbEZhdGlndWVGYXVjb25GYXV0aWZGYXZldXJGYXZvcmlGZS9icmlsZUZlL2NvbmRlckZlL2RlL3JlckZlL2xpbkZlbW1lRmUvbXVyRmVuZG9pckZlL29kYWxGZXJtZXJGZS9yb2NlRmVydmV1ckZlc3RpdmFsRmV1aWxsZUZldXRyZUZlL3ZyaWVyRmlhc2NvRmljZWxlckZpY3RpZkZpZGUtbGVGaWd1cmVGaWxhdHVyZUZpbGV0YWdlRmlsaWUtcmVGaWxsZXVsRmlsbWVyRmlsb3VGaWx0cmVyRmluYW5jZXJGaW5pckZpb2xlRmlybWVGaXNzdXJlRml4ZXJGbGFpcmVyRmxhbW1lRmxhc3F1ZUZsYXR0ZXVyRmxlL2F1RmxlLWNoZUZsZXVyRmxleGlvbkZsb2NvbkZsb3JlRmx1Y3R1ZXJGbHVpZGVGbHV2aWFsRm9saWVGb25kZXJpZUZvbmdpYmxlRm9udGFpbmVGb3JjZXJGb3JnZXJvbkZvcm11bGVyRm9ydHVuZUZvc3NpbGVGb3VkcmVGb3VnZS1yZUZvdWlsbGVyRm91bHVyZUZvdXJtaUZyYWdpbGVGcmFpc2VGcmFuY2hpckZyYXBwZXJGcmF5ZXVyRnJlL2dhdGVGcmVpbmVyRnJlbG9uRnJlL21pckZyZS9uZS9zaWVGcmUtcmVGcmlhYmxlRnJpY3Rpb25Gcmlzc29uRnJpdm9sZUZyb2lkRnJvbWFnZUZyb250YWxGcm90dGVyRnJ1aXRGdWdpdGlmRnVpdGVGdXJldXJGdXJpZXV4RnVydGlmRnVzaW9uRnV0dXJHYWduZXJHYWxheGllR2FsZXJpZUdhbWJhZGVyR2FyYW50aXJHYXJkaWVuR2FybmlyR2FycmlndWVHYXplbGxlR2F6b25HZS9hbnRHZS9sYXRpbmVHZS9sdWxlR2VuZGFybWVHZS9uZS9yYWxHZS9uaWVHZW5vdUdlbnRpbEdlL29sb2dpZUdlL29tZS10cmVHZS9yYW5pdW1HZXJtZUdlc3R1ZWxHZXlzZXJHaWJpZXJHaWNsZXJHaXJhZmVHaXZyZUdsYWNlR2xhaXZlR2xpc3Nlckdsb2JlR2xvaXJlR2xvcmlldXhHb2xmZXVyR29tbWVHb25mbGVyR29yZ2VHb3JpbGxlR291ZHJvbkdvdWZmcmVHb3Vsb3RHb3VwaWxsZUdvdXJtYW5kR291dHRlR3JhZHVlbEdyYWZmaXRpR3JhaW5lR3JhbmRHcmFwcGluR3JhdHVpdEdyYXZpckdyZW5hdEdyaWZmdXJlR3JpbGxlckdyaW1wZXJHcm9nbmVyR3JvbmRlckdyb3R0ZUdyb3VwZUdydWdlckdydXRpZXJHcnV5ZS1yZUd1ZS9wYXJkR3VlcnJpZXJHdWlkZUd1aW1hdXZlR3VpdGFyZUd1c3RhdGlmR3ltbmFzdGVHeXJvc3RhdEhhYml0dWRlSGFjaG9pckhhbHRlSGFtZWF1SGFuZ2FySGFubmV0b25IYXJpY290SGFybW9uaWVIYXJwb25IYXNhcmRIZS9saXVtSGUvbWF0b21lSGVyYmVIZS9yaXNzb25IZXJtaW5lSGUvcm9uSGUvc2l0ZXJIZXVyZXV4SGliZXJuZXJIaWJvdUhpbGFyYW50SGlzdG9pcmVIaXZlckhvbWFyZEhvbW1hZ2VIb21vZ2UtbmVIb25uZXVySG9ub3JlckhvbnRldXhIb3JkZUhvcml6b25Ib3Jsb2dlSG9ybW9uZUhvcnJpYmxlSG91bGV1eEhvdXNzZUh1YmxvdEh1aWxldXhIdW1haW5IdW1ibGVIdW1pZGVIdW1vdXJIdXJsZXJIeWRyb21lbEh5Z2llLW5lSHltbmVIeXBub3NlSWR5bGxlSWdub3JlcklndWFuZUlsbGljaXRlSWxsdXNpb25JbWFnZUltYmliZXJJbWl0ZXJJbW1lbnNlSW1tb2JpbGVJbW11YWJsZUltcGFjdEltcGUvcmlhbEltcGxvcmVySW1wb3NlckltcHJpbWVySW1wdXRlckluY2FybmVySW5jZW5kaWVJbmNpZGVudEluY2xpbmVySW5jb2xvcmVJbmRleGVySW5kaWNlSW5kdWN0aWZJbmUvZGl0SW5lcHRpZUluZXhhY3RJbmZpbmlJbmZsaWdlckluZm9ybWVySW5mdXNpb25JbmdlL3JlckluaGFsZXJJbmhpYmVySW5qZWN0ZXJJbmp1cmVJbm5vY2VudElub2N1bGVySW5vbmRlckluc2NyaXJlSW5zZWN0ZUluc2lnbmVJbnNvbGl0ZUluc3BpcmVySW5zdGluY3RJbnN1bHRlckludGFjdEludGVuc2VJbnRpbWVJbnRyaWd1ZUludHVpdGlmSW51dGlsZUludmFzaW9uSW52ZW50ZXJJbnZpdGVySW52b3F1ZXJJcm9uaXF1ZUlycmFkaWVySXJyZS9lbElycml0ZXJJc29sZXJJdm9pcmVJdnJlc3NlSmFndWFySmFpbGxpckphbWJlSmFudmllckphcmRpbkphdWdlckphdW5lSmF2ZWxvdEpldGFibGVKZXRvbkpldWRpSmV1bmVzc2VKb2luZHJlSm9uY2hlckpvbmdsZXJKb3VldXJKb3Vpc3NpZkpvdXJuYWxKb3ZpYWxKb3lhdUpveWV1eEp1YmlsZXJKdWdlbWVudEp1bmlvckp1cG9uSnVyaXN0ZUp1c3RpY2VKdXRldXhKdXZlL25pbGVLYXlha0tpbW9ub0tpb3NxdWVMYWJlbExhYmlhbExhYm91cmVyTGFjZS9yZXJMYWN0b3NlTGFndW5lTGFpbmVMYWlzc2VyTGFpdGllckxhbWJlYXVMYW1lbGxlTGFtcGVMYW5jZXVyTGFuZ2FnZUxhbnRlcm5lTGFwaW5MYXJnZXVyTGFybWVMYXVyaWVyTGF2YWJvTGF2b2lyTGVjdHVyZUxlL2dhbExlL2dlckxlL2d1bWVMZXNzaXZlTGV0dHJlTGV2aWVyTGV4aXF1ZUxlL3phcmRMaWFzc2VMaWJlL3JlckxpYnJlTGljZW5jZUxpY29ybmVMaWUtZ2VMaWUtdnJlTGlnYXR1cmVMaWdvdGVyTGlndWVMaW1lckxpbWl0ZUxpbW9uYWRlTGltcGlkZUxpbmUvYWlyZUxpbmdvdExpb25jZWF1TGlxdWlkZUxpc2llLXJlTGlzdGVyTGl0aGl1bUxpdGlnZUxpdHRvcmFsTGl2cmV1ckxvZ2lxdWVMb2ludGFpbkxvaXNpckxvbWJyaWNMb3RlcmllTG91ZXJMb3VyZExvdXRyZUxvdXZlTG95YWxMdWJpZUx1Y2lkZUx1Y3JhdGlmTHVldXJMdWd1YnJlTHVpc2FudEx1bWllLXJlTHVuYWlyZUx1bmRpTHVyb25MdXR0ZXJMdXh1ZXV4TWFjaGluZU1hZ2FzaW5NYWdlbnRhTWFnaXF1ZU1haWdyZU1haWxsb25NYWludGllbk1haXJpZU1haXNvbk1ham9yZXJNYWxheGVyTWFsZS9maWNlTWFsaGV1ck1hbGljZU1hbGxldHRlTWFtbW91dGhNYW5kYXRlck1hbmlhYmxlTWFucXVhbnRNYW50ZWF1TWFudWVsTWFyYXRob25NYXJicmVNYXJjaGFuZE1hcmRpTWFyaXRpbWVNYXJxdWV1ck1hcnJvbk1hcnRlbGVyTWFzY290dGVNYXNzaWZNYXRlL3JpZWxNYXRpZS1yZU1hdHJhcXVlTWF1ZGlyZU1hdXNzYWRlTWF1dmVNYXhpbWFsTWUvY2hhbnRNZS9jb25udU1lL2RhaWxsZU1lL2RlY2luTWUvZGl0ZXJNZS9kdXNlTWVpbGxldXJNZS9sYW5nZU1lL2xvZGllTWVtYnJlTWUvbW9pcmVNZW5hY2VyTWVuZXJNZW5oaXJNZW5zb25nZU1lbnRvck1lcmNyZWRpTWUvcml0ZU1lcmxlTWVzc2FnZXJNZXN1cmVNZS90YWxNZS90ZS9vcmVNZS90aG9kZU1lL3RpZXJNZXVibGVNaWF1bGVyTWljcm9iZU1pZXR0ZU1pZ25vbk1pZ3Jlck1pbGlldU1pbGxpb25NaW1pcXVlTWluY2VNaW5lL3JhbE1pbmltYWxNaW5vcmVyTWludXRlTWlyYWNsZU1pcm9pdGVyTWlzc2lsZU1peHRlTW9iaWxlTW9kZXJuZU1vZWxsZXV4TW9uZGlhbE1vbml0ZXVyTW9ubmFpZU1vbm90b25lTW9uc3RyZU1vbnRhZ25lTW9udW1lbnRNb3F1ZXVyTW9yY2VhdU1vcnN1cmVNb3J0aWVyTW90ZXVyTW90aWZNb3VjaGVNb3VmbGVNb3VsaW5Nb3Vzc29uTW91dG9uTW91dmFudE11bHRpcGxlTXVuaXRpb25NdXJhaWxsZU11cmUtbmVNdXJtdXJlTXVzY2xlTXVzZS91bU11c2ljaWVuTXV0YXRpb25NdXRlck11dHVlbE15cmlhZGVNeXJ0aWxsZU15c3RlLXJlTXl0aGlxdWVOYWdldXJOYXBwZU5hcnF1b2lzTmFycmVyTmF0YXRpb25OYXRpb25OYXR1cmVOYXVmcmFnZU5hdXRpcXVlTmF2aXJlTmUvYnVsZXV4TmVjdGFyTmUvZmFzdGVOZS9nYXRpb25OZS9nbGlnZXJOZS9nb2NpZXJOZWlnZU5lcnZldXhOZXR0b3llck5ldXJvbmVOZXV0cm9uTmV2ZXVOaWNoZU5pY2tlbE5pdHJhdGVOaXZlYXVOb2JsZU5vY2lmTm9jdHVybmVOb2lyY2V1ck5vaXNldHRlTm9tYWRlTm9tYnJldXhOb21tZXJOb3JtYXRpZk5vdGFibGVOb3RpZmllck5vdG9pcmVOb3VycmlyTm91dmVhdU5vdmF0ZXVyTm92ZW1icmVOb3ZpY2VOdWFnZU51YW5jZXJOdWlyZU51aXNpYmxlTnVtZS9yb051cHRpYWxOdXF1ZU51dHJpdGlmT2JlL2lyT2JqZWN0aWZPYmxpZ2VyT2JzY3VyT2JzZXJ2ZXJPYnN0YWNsZU9idGVuaXJPYnR1cmVyT2NjYXNpb25PY2N1cGVyT2NlL2FuT2N0b2JyZU9jdHJveWVyT2N0dXBsZXJPY3VsYWlyZU9kZXVyT2RvcmFudE9mZmVuc2VyT2ZmaWNpZXJPZmZyaXJPZ2l2ZU9pc2VhdU9pc2lsbG9uT2xmYWN0aWZPbGl2aWVyT21icmFnZU9tZXR0cmVPbmN0dWV1eE9uZHVsZXJPbmUvcmV1eE9uaXJpcXVlT3BhbGVPcGFxdWVPcGUvcmVyT3Bpbmlvbk9wcG9ydHVuT3BwcmltZXJPcHRlck9wdGlxdWVPcmFnZXV4T3JhbmdlT3JiaXRlT3Jkb25uZXJPcmVpbGxlT3JnYW5lT3JndWVpbE9yaWZpY2VPcm5lbWVudE9ycXVlT3J0aWVPc2NpbGxlck9zbW9zZU9zc2F0dXJlT3RhcmllT3VyYWdhbk91cnNvbk91dGlsT3V0cmFnZXJPdXZyYWdlT3ZhdGlvbk94eWRlT3h5Z2UtbmVPem9uZVBhaXNpYmxlUGFsYWNlUGFsbWFyZS1zUGFsb3VyZGVQYWxwZXJQYW5hY2hlUGFuZGFQYW5nb2xpblBhbmlxdWVyUGFubmVhdVBhbm9yYW1hUGFudGFsb25QYXBheWVQYXBpZXJQYXBvdGVyUGFweXJ1c1BhcmFkb3hlUGFyY2VsbGVQYXJlc3NlUGFyZnVtZXJQYXJsZXJQYXJvbGVQYXJyYWluUGFyc2VtZXJQYXJ0YWdlclBhcnVyZVBhcnZlbmlyUGFzc2lvblBhc3RlLXF1ZVBhdGVybmVsUGF0aWVuY2VQYXRyb25QYXZpbGxvblBhdm9pc2VyUGF5ZXJQYXlzYWdlUGVpZ25lUGVpbnRyZVBlbGFnZVBlL2xpY2FuUGVsbGVQZWxvdXNlUGVsdWNoZVBlbmR1bGVQZS9uZS90cmVyUGUvbmlibGVQZW5zaWZQZS9udXJpZVBlL3BpdGVQZS9wbHVtUGVyZHJpeFBlcmZvcmVyUGUvcmlvZGVQZXJtdXRlclBlcnBsZXhlUGVyc2lsUGVydGVQZXNlclBlL3RhbGVQZXRpdFBlL3RyaXJQZXVwbGVQaGFyYW9uUGhvYmllUGhvcXVlUGhvdG9uUGhyYXNlUGh5c2lxdWVQaWFub1BpY3R1cmFsUGllLWNlUGllcnJlUGlldXZyZVBpbG90ZVBpbmNlYXVQaXBldHRlUGlxdWVyUGlyb2d1ZVBpc2NpbmVQaXN0b25QaXZvdGVyUGl4ZWxQaXp6YVBsYWNhcmRQbGFmb25kUGxhaXNpclBsYW5lclBsYXF1ZVBsYXN0cm9uUGxhdGVhdVBsZXVyZXJQbGV4dXNQbGlhZ2VQbG9tYlBsb25nZXJQbHVpZVBsdW1hZ2VQb2NoZXR0ZVBvZS9zaWVQb2UtdGVQb2ludGVQb2lyaWVyUG9pc3NvblBvaXZyZVBvbGFpcmVQb2xpY2llclBvbGxlblBvbHlnb25lUG9tbWFkZVBvbXBpZXJQb25jdHVlbFBvbmRlL3JlclBvbmV5UG9ydGlxdWVQb3NpdGlvblBvc3NlL2RlclBvc3R1cmVQb3RhZ2VyUG90ZWF1UG90aW9uUG91Y2VQb3VsYWluUG91bW9uUG91cnByZVBvdXNzaW5Qb3V2b2lyUHJhaXJpZVByYXRpcXVlUHJlL2NpZXV4UHJlL2RpcmVQcmUvZml4ZVByZS9sdWRlUHJlL25vbVByZS9zZW5jZVByZS90ZXh0ZVByZS92b2lyUHJpbWl0aWZQcmluY2VQcmlzb25Qcml2ZXJQcm9ibGUtbWVQcm9jZS9kZXJQcm9kaWdlUHJvZm9uZFByb2dyZS1zUHJvaWVQcm9qZXRlclByb2xvZ3VlUHJvbWVuZXJQcm9wcmVQcm9zcGUtcmVQcm90ZS9nZXJQcm91ZXNzZVByb3ZlcmJlUHJ1ZGVuY2VQcnVuZWF1UHN5Y2hvc2VQdWJsaWNQdWNlcm9uUHVpc2VyUHVscGVQdWxzYXJQdW5haXNlUHVuaXRpZlB1cGl0cmVQdXJpZmllclB1enpsZVB5cmFtaWRlUXVhc2FyUXVlcmVsbGVRdWVzdGlvblF1aWUvdHVkZVF1aXR0ZXJRdW90aWVudFJhY2luZVJhY29udGVyUmFkaWV1eFJhZ29uZGluUmFpZGV1clJhaXNpblJhbGVudGlyUmFsbG9uZ2VSYW1hc3NlclJhcGlkZVJhc2FnZVJhdGlzc2VyUmF2YWdlclJhdmluUmF5b25uZXJSZS9hY3RpZlJlL2FnaXJSZS9hbGlzZXJSZS9hbmltZXJSZWNldm9pclJlL2NpdGVyUmUvY2xhbWVyUmUvY29sdGVyUmVjcnV0ZXJSZWN1bGVyUmVjeWNsZXJSZS9kaWdlclJlZG91dGVyUmVmYWlyZVJlL2ZsZXhlUmUvZm9ybWVyUmVmcmFpblJlZnVnZVJlL2dhbGllblJlL2dpb25SZS9nbGFnZVJlL2d1bGllclJlL2l0ZS9yZXJSZWpldGVyUmVqb3VlclJlbGF0aWZSZWxldmVyUmVsaWVmUmVtYXJxdWVSZW1lLWRlUmVtaXNlUmVtb250ZXJSZW1wbGlyUmVtdWVyUmVuYXJkUmVuZm9ydFJlbmlmbGVyUmVub25jZXJSZW50cmVyUmVudm9pUmVwbGllclJlcG9ydGVyUmVwcmlzZVJlcHRpbGVSZXF1aW5SZS9zZXJ2ZVJlL3NpbmV1eFJlL3NvdWRyZVJlc3BlY3RSZXN0ZXJSZS9zdWx0YXRSZS90YWJsaXJSZXRlbmlyUmUvdGljdWxlUmV0b21iZXJSZXRyYWNlclJlL3VuaW9uUmUvdXNzaXJSZXZhbmNoZVJldml2cmVSZS92b2x0ZVJlL3Z1bHNpZlJpY2hlc3NlUmlkZWF1UmlldXJSaWdpZGVSaWdvbGVyUmluY2VyUmlwb3N0ZXJSaXNpYmxlUmlzcXVlUml0dWVsUml2YWxSaXZpZS1yZVJvY2hldXhSb21hbmNlUm9tcHJlUm9uY2VSb25kaW5Sb3NlYXVSb3NpZXJSb3RhdGlmUm90b3JSb3R1bGVSb3VnZVJvdWlsbGVSb3VsZWF1Um91dGluZVJveWF1bWVSdWJhblJ1YmlzUnVjaGVSdWVsbGVSdWd1ZXV4UnVpbmVyUnVpc3NlYXVSdXNlclJ1c3RpcXVlUnl0aG1lU2FibGVyU2Fib3RlclNhYnJlU2Fjb2NoZVNhZmFyaVNhZ2Vzc2VTYWlzaXJTYWxhZGVTYWxpdmVTYWxvblNhbHVlclNhbWVkaVNhbmN0aW9uU2FuZ2xpZXJTYXJjYXNtZVNhcmRpbmVTYXR1cmVyU2F1Z3JlbnVTYXVtb25TYXV0ZXJTYXV2YWdlU2F2YW50U2F2b25uZXJTY2FscGVsU2NhbmRhbGVTY2UvbGUvcmF0U2NlL25hcmlvU2NlcHRyZVNjaGUvbWFTY2llbmNlU2NpbmRlclNjb3JlU2NydXRpblNjdWxwdGVyU2UvYW5jZVNlL2NhYmxlU2UvY2hlclNlY291ZXJTZS9jcmUvdGVyU2UvZGF0aWZTZS9kdWlyZVNlaWduZXVyU2Uvam91clNlL2xlY3RpZlNlbWFpbmVTZW1ibGVyU2VtZW5jZVNlL21pbmFsU2UvbmF0ZXVyU2Vuc2libGVTZW50ZW5jZVNlL3BhcmVyU2UvcXVlbmNlU2VyZWluU2VyZ2VudFNlL3JpZXV4U2VycnVyZVNlL3J1bVNlcnZpY2VTZS9zYW1lU2UvdmlyU2V2cmFnZVNleHR1cGxlU2lkZS9yYWxTaWUtY2xlU2llL2dlclNpZmZsZXJTaWdsZVNpZ25hbFNpbGVuY2VTaWxpY2l1bVNpbXBsZVNpbmNlLXJlU2luaXN0cmVTaXBob25TaXJvcFNpc21pcXVlU2l0dWVyU2tpZXJTb2NpYWxTb2NsZVNvZGl1bVNvaWduZXV4U29sZGF0U29sZWlsU29saXR1ZGVTb2x1YmxlU29tYnJlU29tbWVpbFNvbW5vbGVyU29uZGVTb25nZXVyU29ubmV0dGVTb25vcmVTb3JjaWVyU29ydGlyU29zaWVTb3R0aXNlU291Y2lldXhTb3VkdXJlU291ZmZsZVNvdWxldmVyU291cGFwZVNvdXJjZVNvdXRpcmVyU291dmVuaXJTcGFjaWV1eFNwYXRpYWxTcGUvY2lhbFNwaGUtcmVTcGlyYWxTdGFibGVTdGF0aW9uU3Rlcm51bVN0aW11bHVzU3RpcHVsZXJTdHJpY3RTdHVkaWV1eFN0dXBldXJTdHlsaXN0ZVN1YmxpbWVTdWJzdHJhdFN1YnRpbFN1YnZlbmlyU3VjY2Utc1N1Y3JlU3VmZml4ZVN1Z2dlL3JlclN1aXZldXJTdWxmYXRlU3VwZXJiZVN1cHBsaWVyU3VyZmFjZVN1cmljYXRlU3VybWVuZXJTdXJwcmlzZVN1cnNhdXRTdXJ2aWVTdXNwZWN0U3lsbGFiZVN5bWJvbGVTeW1lL3RyaWVTeW5hcHNlU3ludGF4ZVN5c3RlLW1lVGFiYWNUYWJsaWVyVGFjdGlsZVRhaWxsZXJUYWxlbnRUYWxpc21hblRhbG9ubmVyVGFtYm91clRhbWlzZXJUYW5naWJsZVRhcGlzVGFxdWluZXJUYXJkZXJUYXJpZlRhcnRpbmVUYXNzZVRhdGFtaVRhdG91YWdlVGF1cGVUYXVyZWF1VGF4ZXJUZS9tb2luVGVtcG9yZWxUZW5haWxsZVRlbmRyZVRlbmV1clRlbmlyVGVuc2lvblRlcm1pbmVyVGVybmVUZXJyaWJsZVRlL3RpbmVUZXh0ZVRoZS1tZVRoZS9vcmllVGhlL3JhcGllVGhvcmF4VGliaWFUaWUtZGVUaW1pZGVUaXJlbGlyZVRpcm9pclRpc3N1VGl0YW5lVGl0cmVUaXR1YmVyVG9ib2dnYW5Ub2xlL3JhbnRUb21hdGVUb25pcXVlVG9ubmVhdVRvcG9ueW1lVG9yY2hlVG9yZHJlVG9ybmFkZVRvcnBpbGxlVG9ycmVudFRvcnNlVG9ydHVlVG90ZW1Ub3VjaGVyVG91cm5hZ2VUb3Vzc2VyVG94aW5lVHJhY3Rpb25UcmFmaWNUcmFnaXF1ZVRyYWhpclRyYWluVHJhbmNoZXJUcmF2YWlsVHJlLWZsZVRyZW1wZXJUcmUvc29yVHJldWlsVHJpYWdlVHJpYnVuYWxUcmljb3RlclRyaWxvZ2llVHJpb21waGVUcmlwbGVyVHJpdHVyZXJUcml2aWFsVHJvbWJvbmVUcm9uY1Ryb3BpY2FsVHJvdXBlYXVUdWlsZVR1bGlwZVR1bXVsdGVUdW5uZWxUdXJiaW5lVHV0ZXVyVHV0b3llclR1eWF1VHltcGFuVHlwaG9uVHlwaXF1ZVR5cmFuVWJ1ZXNxdWVVbHRpbWVVbHRyYXNvblVuYW5pbWVVbmlmaWVyVW5pb25VbmlxdWVVbml0YWlyZVVuaXZlcnNVcmFuaXVtVXJiYWluVXJ0aWNhbnRVc2FnZVVzaW5lVXN1ZWxVc3VyZVV0aWxlVXRvcGllVmFjYXJtZVZhY2NpblZhZ2Fib25kVmFndWVWYWlsbGFudFZhaW5jcmVWYWlzc2VhdVZhbGFibGVWYWxpc2VWYWxsb25WYWx2ZVZhbXBpcmVWYW5pbGxlVmFwZXVyVmFyaWVyVmFzZXV4VmFzc2FsVmFzdGVWZWN0ZXVyVmVkZXR0ZVZlL2dlL3RhbFZlL2hpY3VsZVZlaW5hcmRWZS9sb2NlVmVuZHJlZGlWZS9uZS9yZXJWZW5nZXJWZW5pbWV1eFZlbnRvdXNlVmVyZHVyZVZlL3JpblZlcm5pclZlcnJvdVZlcnNlclZlcnR1VmVzdG9uVmUvdGUvcmFuVmUvdHVzdGVWZXhhbnRWZXhlclZpYWR1Y1ZpYW5kZVZpY3RvaXJlVmlkYW5nZVZpZGUvb1ZpZ25ldHRlVmlndWV1clZpbGFpblZpbGxhZ2VWaW5haWdyZVZpb2xvblZpcGUtcmVWaXJlbWVudFZpcnR1b3NlVmlydXNWaXNhZ2VWaXNldXJWaXNpb25WaXNxdWV1eFZpc3VlbFZpdGFsVml0ZXNzZVZpdGljb2xlVml0cmluZVZpdmFjZVZpdmlwYXJlVm9jYXRpb25Wb2d1ZXJWb2lsZVZvaXNpblZvaXR1cmVWb2xhaWxsZVZvbGNhblZvbHRpZ2VyVm9sdW1lVm9yYWNlVm9ydGV4Vm90ZXJWb3Vsb2lyVm95YWdlVm95ZWxsZVdhZ29uWGUvbm9uWWFjaHRaZS1icmVaZS9uaXRoWmVzdGVab29sb2dpZVwiO2xldCB3b3JkbGlzdCQzPW51bGw7Y29uc3QgbG9va3VwJDE9e307ZnVuY3Rpb24gZHJvcERpYWNyaXRpYyQxKHdvcmQpe2xvZ2dlciRrLmNoZWNrTm9ybWFsaXplKCk7cmV0dXJuIHRvVXRmOFN0cmluZyhBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodG9VdGY4Qnl0ZXMod29yZC5ub3JtYWxpemUoXCJORkRcIikudG9Mb3dlckNhc2UoKSksYz0+e3JldHVybiBjPj02NSYmYzw9OTB8fGM+PTk3JiZjPD0xMjN9KSl9ZnVuY3Rpb24gZXhwYW5kJDEod29yZCl7Y29uc3Qgb3V0cHV0PVtdO0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodG9VdGY4Qnl0ZXMod29yZCksYz0+e2lmKGM9PT00Nyl7b3V0cHV0LnB1c2goMjA0KTtvdXRwdXQucHVzaCgxMjkpfWVsc2UgaWYoYz09PTQ1KXtvdXRwdXQucHVzaCgyMDQpO291dHB1dC5wdXNoKDEyOCl9ZWxzZXtvdXRwdXQucHVzaChjKX19KTtyZXR1cm4gdG9VdGY4U3RyaW5nKG91dHB1dCl9ZnVuY3Rpb24gbG9hZFdvcmRzJDMobGFuZyl7aWYod29yZGxpc3QkMyE9bnVsbCl7cmV0dXJufXdvcmRsaXN0JDM9d29yZHMkMy5yZXBsYWNlKC8oW0EtWl0pL2csXCIgJDFcIikudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkuc3BsaXQoXCIgXCIpLm1hcCh3PT5leHBhbmQkMSh3KSk7d29yZGxpc3QkMy5mb3JFYWNoKCh3b3JkLGluZGV4KT0+e2xvb2t1cCQxW2Ryb3BEaWFjcml0aWMkMSh3b3JkKV09aW5kZXh9KTtpZihXb3JkbGlzdC5jaGVjayhsYW5nKSE9PVwiMHg1MWRlYjdhZTAwOTE0OWRjNjFhNmJkMThhOTE4ZWI3YWM3OGQyNzc1NzI2YzY4ZTU5OGI5MmQwMDI1MTliMDQ1XCIpe3dvcmRsaXN0JDM9bnVsbDt0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3IgZnIgKEZyZW5jaCkgRkFJTEVEXCIpfX1jbGFzcyBMYW5nRnIgZXh0ZW5kcyBXb3JkbGlzdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiZnJcIil9Z2V0V29yZChpbmRleCl7bG9hZFdvcmRzJDModGhpcyk7cmV0dXJuIHdvcmRsaXN0JDNbaW5kZXhdfWdldFdvcmRJbmRleCh3b3JkKXtsb2FkV29yZHMkMyh0aGlzKTtyZXR1cm4gbG9va3VwJDFbZHJvcERpYWNyaXRpYyQxKHdvcmQpXX19Y29uc3QgbGFuZ0ZyPW5ldyBMYW5nRnI7V29yZGxpc3QucmVnaXN0ZXIobGFuZ0ZyKTtcInVzZSBzdHJpY3RcIjtjb25zdCBkYXRhPVtcIkFRUkFTUkFHQkFHVUFJUkFIQkFnaEFVUkFkQkFkY0Fub0FNRUFGQkFGQ0JLRkJRUkJTRkJDWEJDREJDSEJHRkJFUUJwQkJwUUJJa0JITkJlT0JnRkJWQ0JoQkJoTkJtT0JtUkJpSEJpRkJVRkJaREJ2RkJzWEJrRkJsY0JqWUJ3REJNQkJUQkJUUkJXQkJXWFhhUVhhUlhRV1hTUlhDRlhZQlhwSFhPUVhIUlhoUlh1UlhtWFhiUlhsWFh3RFhUUlhyQ1hXUVhXR2FCV2FLY2FZZ2FzRmFkUWFsbWFNQmFjQUthUktLQktLWEtLaktRUktEUktDWUtDUktJREtlVktIY0tsWEtqSEtyWU5BSE5CV05hUk5LY05JQk5JT05tWE5zWE5kWE5uQk5NQk5SQk5yWE5XRE5XTU5GT1FBQlFBSFFCclFYQlFYRlFhUlFLWFFLRFFLT1FLRlFOQlFORFFRZ1FDWFFDRFFHQlFHRFFHZFFZWFFwQlFwUVFwSFFMWFFIdVFnQlFoQlFoQ1F1RlFtWFFpRFFVRlFaRFFzRlFkUlFrSFFiUlFsT1FsbVFQRFFqRFF3WFFNQlFNRFFjRlFUQlFUSFFyRERYUURORkRHQkRHUURHUkRwRkRoRkRtWERaWERiUkRNWURSZERUUkRyWFNBaFNCQ1NCclNHUVNFUVNIQlNWUlNoWVNoa1N5UVN1RlNpQlNkY1NvRVNvY1NsbVNNQlNGQlNGS1NGTlNGZFNGY0NCeUNhUkNLY0NTQkNTUkNDckNHYkNFSENZWENwQkNwUUNJQkNJSENlTkNnQkNnRkNWRUNWY0Nta0Ntd0NaWENaRkNkUkNsT0NsbUNsRkNqRENqZENuWEN3QkN3WENjUkNGUUNGakdYaEdOaEdERUdETUdDREdDSEdJRkdnQkdWWEdWRUdWUkdtWEdzWEdkWUdvU0diUkduWEd3WEd3REdXUkdGTkdGTEdGT0dGZEdGa0VBQkVCREVCRkVYT0VhQkVLU0VOQkVOREVZWEVJZ0VJa0VnQkVnUUVnSEVoRkV1ZEV1RkVpQkVpSEVpRkVaREV2QkVzWEVzRkVkWEVkUkVrRkViQkViUkVsRkVQQ0Vma0VGTllBRVlBaFlCTllRZFlEWFlTUllDRVlZb1lnUVlnUll1UlltQ1laVFlkQlliRVlsWFlqUVlSYllXUnBLWHBRb3BRbnBTRnBDWHBJQnBJU3BoTnBkQnBkUnBiUnBjWnBGQnBGTnBGRHBGb3BGckxBRExCdUxYUUxYY0xhRkxDWExFaExwQkxwRkxIWExlVkxoSUxkSExkUkxvRExiUkxyWElBQklCUUlCQ0lCc0lCb0lCTUlCUklYYUlhUklLWUlLUklOQklOdUlDRElHQklJRElJa0lnUkl4Rkl5UUlpSElkUkliWUliUklsSEl3UklNWUljUklSVklUUklGQklGTklGUU9BQk9BRk9CUU9hRk9OQk9OTU9RRk9TRk9DRE9HQk9FUU9wQk9MWE9JQk9JRk9nUU9nRk95UU95Y09tWE9zWE9kSU9rSE9NRU9Na09XV0hCTkhYTkhYV0hOWEhEdUhEUkhTdUhTUkhIb0hoa0htUkhkUkhrUUhsY0hsUkh3QkhXY2dBRWdBZ2dBa2dCTmdCUWdCRWdYT2dZY2dMWGdIamd5UWdpQmdzRmdkYWdNWWdXU2dGUWdGRVZCVFZYRVZLQlZLTlZLRFZLWVZLUlZOQlZOWVZEQlZEeFZTQlZTUlZDalZHTlZMWFZJRlZoQlZoY1ZzWFZkUlZiUlZsUmhCWWhLWWhEWWhHU2h4V2htTmhkYWhka2hiUmhqb2hNWGhUUnhBWHhYU3hLQnhOQnhFUXhlTnhlUXhoWHhzRnhkYnhsSHhqY3hGQnhGTnhGUXhGT3hGb3lOWXlZb3liY3lNWXVCUXVCUnVCcnVETXVDb3VIQnVkUXVra3VvQnVsVnVNWHVGRW1DWW1DUm1wUm1lRG1pTW1qZG1URm1GUWlBRGlCT2lhUmlLUmlOQmlOUmlTRmlHa2lHRmlFUmlwUmlMRmlJRmloWWliSGlqQmlqRWlNWGlXQmlGQmlGQ1VCUVVYRlVhUlVORFVOY1VOUlVORlVEQlVTSFVDRFVHQlVHRlVFcVVMTlVMb1VJUlVlRVVlWVVnQlVoRlV1UlVpRlVzWFVkRlVrSFViQlVqU1VqWVV3WFVNRFVjSFVSZFVUQlVyQlVyWFVyUVpBRlpYWlphUlpLRlpOQlpRRlpDWFpHQlpZZFpwQlpMRFpJRlpIWFpITlplUVpWUlpWRlptWFppQlp2RlpkRlprRlpiSFpiRlp3WFpjQ1pjUlpSQnZCUXZCR3ZCTHZCV3ZDb3ZNWXNBRnNCRHNhUnNLRnNORnNEcnNTSHNTRnNDWHNDUnNFQnNFSHNFZnNwQnNMQnNMRHNJZ3NJUnNlR3NiUnNGQnNGUXNGU2ROQmRTUmRDVmRHSGRZRGRIY2RWYmR5U2R1RGRzWGRsUmR3WGRXWWRXY2RXUmtCTWtYT2thUmtOSWtORmtTRmtDRmtZQmtwUmtlTmtnQmtoVmttWGtzRmtsVmtNQmtXRGtGTm9CTm9hUW9hRm9OQm9OWG9OYW9ORW9TUm9Fcm9ZWG9ZQ29ZYm9wUm9wRm9tWG9qa293WG9yRmJCRWJFSWJkQmJqWWxhUmxERWxNWGxGRGpLampTUmpHQmpZQmpZa2pwUmpMWGpJQmpPRmplVmpiUmp3Qm5YUW5TSG5wRm5MWG5JTm5NQm5UUndYQndYTndYWXdORndRRndTQndHRndMWHdMRHdlTndnQnd1SHdqRHduWE1CWE1wRk1JQk1lTk1USGNhUWNOQmNESGNTRmNDWGNwQmNMWGNMRGNnRmN1RmNuWGN3WGNjRGNUUWNyRlRRRXJYTnJDSHJwRnJnRnJiRnJUSHJGY1dOWVdOYldFSFdNWFdUUlwiLFwiQUJHSEFCSUpBRUFWQVlKUUFMWkpBSWFSQUhOWEFIZGNBSGJSQVpKTUFaSlJBWlRSQWRWSkFrbG1BYmNOQWpkUkFNblJBTVdZQVdwUkFXZ1JBRmdCQUZoQkFGZGNCTkpCQk5KREJRS0JCUWhjQlFsbUJERUpCWUprQllKVEJwTkJCcEpGQklKQkJJSkRCSWNBQk9LWEJPRUpCT1ZKQk9pSkJPWkpCZXBCQmVMWEJlSUZCZWdCQmdHSkJWSlhCdW9jQmlKUkJVSlFCbFhWQmxJVEJ3TkZCTVlWQmNxWEJUbG1CV05GQldpSkJXblJCRkdIQkZ3WFhLR0pYTkpCWE5aSlhEVFRYU0hTWFNWUlhTbEhYQ0pEWEdRSlhFaFhYWVFKWFliUlhPZlhYZU5jWFZKRlhoUUpYaEVKWGRUUlhqZFhYTWhCWGNRVFhSR0JYVEVCWFRuUVhGQ1hYRk9GWEZnRmFCYUZhQk5KYUJDSmFCcEJhQndYYU5KS2FOSkRhUUlCYURwUmFFUERhSE1GYW1ESmFsRUphTVpKYUZhRmFGTkJhRlFKYUZMRGFGVkhLQkNZS0JFQktCSERLWGFGS1hHZEtYRUpLWHBIS1hJQktYWkRLWHdYS0t3TEtOYWNLTllKS05Kb0tOV2NLREdkS0RUUktDaFhLR2FSS0doQktHYlJLRUJUS0VhUktFUFRLTE1ES0xXUktPSERLVkpjS2RCY0tsSUJLbE9QS0ZTQktGRVBLRnBGTkJOSk5KQlFOQkdITkJFUE5CSFhOQmdGTkJWWE5CWkROQnNYTkJ3WE5OYVJOTkpETk5KRU5OSmtORENKTkRWRE5HSlJOSmlETlpKTk5zQ0pOSkZOTkZTQk5GQ1hORkVQTkZMWE5GSUZRSkJGUUNhUlFKRVFRTEpEUUxKRlFJYVJRT3FYUUhhRlFISFFRVkpYUVZKRFFoTkpRbUVJUVpKRlFzSlhRSnJGUVdiUkRKQUJEQllKRFhORkRYQ1hEWExYRFhaRERYc0pEUXFYRFNKRkRKQ1hERVBrREVxWERZbVFEcFNKRE9Da0RPR1FESEVJRFZKRER1RHVEV0VCREpGZ1NCTkRTQlNGU0JHSFNCSUJTQlRRU0tWWVNKUU5TSlFpU0pDWFNFcVhTSllWU0lpSlNPTVlTSEFIU0hhUVNlQ0ZTZXBRU2VnQlNIZEhTSHJGU2hTSlNKdUhTSlVGU2tOUlNyU3JTV0VCU0ZhSFNKRlFTRkNYU0ZHRFNGWVhTRk9EU0ZnQlNGVlhTRmhCU0Z4RlNGa0ZTRmJCU0ZNRkNBRGRDSlhCQ1hhRkNYS0ZDWE5GQ1hDWENYR0JDWEVKQ1hZQkNYTERDWElCQ1hPUENYSFhDWGdCQ1hoQkNYaUJDWGxEQ1hjSENKTkJDSk5GQ0RDSkNER0JDRFZYQ0RoQkNEaURDREpkQ0NtTkNwSkZDSWFSQ09xWENIQ0hDSFpKQ1ZpSkN1Q3VDbWRkQ0ppRkNkTkJDZEhoQ2xFSkNuVUpDcmVTQ1dsZ0NXVFJDRkJGQ0ZOQkNGWUJDRlZGQ0ZoRkNGZFNDRlRCQ0ZXREdCTkJHQlFGR0pCQ0dCRXFHQnBCR0JnUUdOQkVHTkpZR05rT0dOSlJHRFVGR0pwUUdIYUJHSmVOR0plRUdWQmxHVktqR2lKREd2SkhHc1ZKR2tFQkdNSUpHV2pOR0ZCRkdGQ1hHRkdCR0ZZWEdGcEJHRk1GRUFTSkVBV3BFSk5GRUNKVkVJWFNFSVFKRU9xWEVPY0ZFZU5jRUhFSkVIbEZFSmdGRWhsbUVtREpFbVpKRWlNQkVVcVhFb1NSRVBCRkVQWEZFUEtGRVBTRkVQRUZFUHBGRVBMWEVQSUJFSlBkRVBjRkVQVEJFSm5YRXFsSEVNcFJFRkNYRUZPREVGY0ZZQVNKWUpBRllCYUJZQlZYWVhwRllEaEJZQ0pCWUpHRllZYlJZZU5jWUplVllpSUpZWkpjWXZKZ1l2SlJZSnNYWXNKRllNWU1ZcmVWcEJOSHBCRUpwQndYcFF4RnBZRUpwZU5EcEplRHBlU0ZwZUNIcEhVSnBIYkJwSGNIcG1VSnBpaUpwVUpycHNKdXBsSVRwRmFCcEZRcXBGR0JwRkVmcEZZQnBGcEJwRkxKcEZJRHBGZ0JwRlZYcEZ5UXBGdUZwRmxGcEZqRHBGblhwRndYcEpGTXBGVEJMWENKTFhFRkxYaEZMWFVKTFhiRkxhbG1MTkpCTFNKUUxDTENMR0pCTExESkxIYUZMZU5GTGVTSExlQ1hMZXBGTGhhUkxac0pMc0pETHNKckxvY2FMbExsTE1kYkxGTkJMRlNCTEZFSExGa0ZJQkJGSUJYRklCYVFJQktYSUJTRklCcEhJQkxYSUJnQklCaEJJQnVISUJtWElCaUZJQlpYSUJ2RklCYkZJQmpRSUJ3WElCV0ZJS1RSSVFVSklER0ZJQ2pRSVlTUklJTlhJSmVDSVZhUkltRWtJWkpGSXZKUklzSlhJZENKSUpvUkliQlFJallCSWNxWElURlZJcmVWSUZLRklGU0ZJRkNKSUZHRklGTERJRklCSUpGT0lGZ0JJRlZYSUpGaElGeEZJRm1YSUZkSElGYkJJSkZySUpGV09CR0JPUWZYT09Lak9VcVhPZlhCT3FYRU9jcVhPUlZKT0ZJQk9GbERIQklPSFhpRkhOVFJIQ0pYSElhUkhISkRISEVKSFZiUkhaSllIYklCSFJzSkhSa0RIV2xtZ0JLRmdCU0JnQkNEZ0JHSGdCcEJnQklCZ0JWSmdCdUJnQnZGZ0tEVGdRVlhnRFVKZ0dTSmdPcVhnbVVNZ1pJSmdUVUpnV0lFZ0ZCRmdGTkJnRkRKZ0ZTRmdGR0JnRllYZ0pGT2dGZ1FnRlZYZ0ZoQmdGYkhnSkZXVkpBQlZRS2NWRGdGVk9mWFZlREZWaGFSVm1HZFZpSllWTWFSVkZOSGhCTkRoQkNYaEJFcWhCcEZoQkxYaE5KQmhTSlJoZVZYaGhLRWh4bG1oWklKaGRCUWhrSUpoYk1OaE1VSmhNWkp4TkpneFFVSnhERWt4RGRGeFNKUnhwbG14ZVNCeGVDWHhlR0Z4ZVlYeGVwUXhlZ0J4V1ZjeEZFUXhGTFh4RklCeEZnQnhGeER4Rlp0eEZkY3hGYkJ4RndYeURKWHlEbGN1QVNKdURKcHVESUJ1Q3BKdUdTSnVJSkZ1ZUVGdVpJSnVzSlh1ZFdFdW9JQnVXR0p1RkJjdUZLRXVGTkZ1RlFGdUZESnVGR0p1RlZKdUZVdHVGZEh1RlRCbUJZSm1OSlltUWhrbUxKRG1MSm9tSWRYbWlKWW12SlJtc0pSbWtsbW1NQnltTXVDbWNsbW1jblFpSkFCaUpCTmlKQkRpQlNGaUJDSmlCRUZpQllCaUJwRmlCTFhpQlRIaUpOY2lERWZpQ1pKaUVDSmlKRXFpT2tIaUhLRmllTkRpSEpRaWVRY2llREhpZVNGaWVDWGllR0ZpZUVGaWVJSGllZ0ZpaFVKaXhOb2lvTlhpRmFCaUZLRmlGTkRpRkVQaUZZWGl0Rk9pdEZIaUZnQmlGVkVpRm1YaUZpdGlGYkJpRk1GaUZyRlVDWFFVSW9RVUlKY1VIUUpVZUNFVUh3WFVVSkRVVXFYVWRXY1VjcVhVcm5RVUZORFVGU0hVRkNGVUZFZlVGTFhVdEZPWkJYT1pYU0JaWHBGWlhWWFpFUUpaRUprWnBESlpPcVhaZU5IWmVDRFpVcVhaRkJRWkZFSFpGTFh2QkFGdkJLRnZCQ1h2QkVQdkJwSHZCSUR2QmdGdkJ1SHZRTkp2Rk5GdkZHQnZGSUJ2SkZjc1hDRHNYTFhzWHNYc1hsRnNYY0hzUXFYc0pRRnNFcVhzZUlGc0ZFSHNGakRkQnhPZE5wUmROSlJkRUpiZHBKUmRoWkpkblNKZHJqTmRGTkpkRlFIZEZoTmtOSkRrWWFSa0hOUmtIU1JrVmJSa3VNUmtqU0prY3FEb1NKRm9FaUpvWVpKb09mWG9oRUJvTUdRb2NxWGJCQUZiQlhGYkJhRmJCTkRiQkdCYkJMWGJCVEJiQldEYkdKWWJJSkhiRlFxYkZwUWxEZ1FsT3JGbFZKUmpHRUJqWkpSblh2Sm5YYkJuRWZIbk9QRG5nSlJueGZYblVKV3dYRUp3TnBKd0RwQndFZlh3ckVCTURDSk1ER0hNRElKTUxKRGNRR0RjUXBIY3FYY2NxTkZjcUNYY0ZDSlJCU0JSQkdCUkJFSlJCcFFUQk5GVEJRSlRCcEJUQlZYVEZBQlRGU0JURkNGVEZHQlRGTURyWENKclhMRHJETkpyRWZIckZRSnJGaXRXTmpkV05UUlwiLFwiQUtMSk1BTk9QRkFTTkpJQUVKV1hBWUpOUkFJSWJSQUljZGFBZUVmREFnaWRSQWRqTllBTVlFSkFNSWJSQUZOSkJBRnBKRkJCSUpZQkRaSkZCU2lKaEJHZEVCQkVKZlhCRUpxWEJFSldSQnBhVUpCTFhyWEJJWUpNQk9jZlhCZUVmRkJlc3RYQmpOSlJCY0RKT0JGRXFYWE52SlJYRE1CaFhDSk5ZWE9BV3BYT05KV1hIREVCWGVJYVJYaFlKRFhaSlNKWE1ESk9YY0FTSlhGVkpYYUJRcVhhQlpKRmFzWGRRYUZTSlFhRkVmWGFGcEpIYUZPcVhLQk5TUktYdkpCS1FKaFhLRUpRSktFSkdGS0lOSkJLSUpqTktnSk5TS1ZFbG1LVmhFQktpSkdGS2xCZ0pLam5VSkt3c0pZS01GSUpLRk5KREtGSUpGS0ZPZlhOSkJTRk5KQkNYTkJwSkZOSkJ2UU5KQk1CTkpMSlhOSk9xWE5KZUNYTkplR0ZOZHNKQ05iVEtGTndYVUpRTkZFUFFEaUpjUURNU0pRU0ZwQlFHTVFKUUplT2NReUNKRVFVSkVCUUpGQnJRRkVKcURYREpGREpYcEJESlhJTURHaUpoRElKR1JESmVZY0RIckRKRFZYZ0ZEa0FXcERrSWdSRGpERXFETXZKUkRKRk5GREpGSUJTS2NsbVNKUU9GU0pRVkhTSlFqRFNKR0pCU0pHSkZTRUNKb1NIRUpxU0pIVEJTSlZKRFNWaUpZU1pKTkJTSnNKRFNGU0pGU0ZFZlhTSkZMWENCVUpWQ0pYU0JDSlhwQkNYVkpYQ0pYc1hDSlhkRkNKTkpIQ0xJSmdDSGlKRkNWTkpNQ2hDSmhDVUhFSkNzSlRSQ0pkWWNDb1FKQ0NGRWZYQ0ZJSmdDRlVKeENGc3RGR0pCYVFHSkJJREdRSnFYR1lKTlJHSkhLRkdlUXFER0hFSkZHSmVMWEdISWlKR0hkQmxHVUpFQkdrSUpUR0ZRUERHSkZFcUVBR2VnRUpJSkJFSlZKWEVoUUpURWlKTmNFSlpKRkVKb0VxRWpERXFFUERzWEVQR0pCRVBPcVhFUGVRRkVmRGlERUpmRUZFZmVwUUVmTWlKRXFYTkJFcURJREVxZVNGRXFWSlhFTXZKUllYTkpEWVhFSkhZS1ZKY1lZSkVCWUplRWNZSlVxWFlGcEpGWUZzdFhwQVpKTXBCU0pGcE5CTkZwZVFQRHBITEpEcEhJSkZwSGdKRnBlaXRGcEhaSkZwSkZBRHBGU0pGcEpGQ0pwRk9xWHBGaXRCcEpGWkpMWElKRkxJSmdSTFZOSldMVkhKTUx3TnBKTEZHSkJMRkxKRExGT3FYTEpGVUpJQkRKWElCR0pCSUpCWVFJSkJJQklCT3FYSUJjcURJRUdKRklMTkpUSUlKRUJJT2lKaElKZU5CSUplSUJJaGlKSUlXb1RSSUpGQUhJSkZwQklKRnVISUZVdEZJSkZUSE9TQllKT0VjcVhPSEVKcU92QnBGT2tWSnJPYkJWSk9uY3FET2NOSmtIaE5KUkh1SEp1SGRNaEJnQlVxWGdCc0pYZ09OSkJnSE5KRGdISEpRZ0plaXRnSHNKWGdKeU5hZ3lESkJnWkpEcmdzVkpRZ2tFSk5na2pTSmdKRkFIZ0ZDSkRnRlp0TVZKWE5GVlhRZlhWSlhESlZYb1FKVlFWSlFWREVmWFZEdkpIVkVxTkZWZVFmWFZIcEpGVkh4ZlhWVkpTUlZWbWFSVmxJSk9oQ1hWSmhIallraHhDSlZoV1ZVSmhXaUpjeEJOSkl4ZUVxRHhmWEJGeGNGRVB4RlNKRnhGWUpYeUJEUUp5ZGFVSnlGT1BEdVlDSll1THZKUnVITEpYdVpKTER1Rk9QRHVGWkpIdUZjcVhtS0hKZG1DUUpjbU9zVkppSkFHRml0TENGaWVPZlhpZXN0WGlaSk1FaWtOSlFpclh6RmlGUXFYaUZJSkZpRlpKRmlGdnRGVUhwSkZVdGVJY1V0ZU9jVVZDSmtVaGRIY1ViRUpFVUpxWFFVTU5KaFVSallrVUZpdEZaREdKSFpKSXhEWkpWSlhaSkZESlpKRnBRdkJOSkJ2QlNKRnZKeEJyc2VRcURzVkZWSmRGTEpEa0VKTkJrbU5KWWtGTEpEb1FKT1BvR3NKUm9FQUhCb0VKZkZiQlFxRGJCWkpIYkZWSlhsRklKQmpZSXJYamVpdGNqakNFQmpXTU5Cd1hRZlh3WE9hRndEc0pYd0NKVFJ3ckNaSk1ETkpRY0RESkZjcURPUFJZaUpGVEJzSlhUUUlKQlRGRWZYVEZMSkRyWEVKRnJFSlhNckZaSkZXRUpkRVdZVGxtXCIsXCJBQkNERUZBQ05KVFJBTUJESmRBY05KVlhCTE5KRUJYU0lkV1JYRXJOSmtYWURKTUJYWkpDSmFYTU5KYVlLS1ZKS2NLREVKcVhLRGNOSmhLVkpyTllLYmdKVlhLRlZKU0JOQllCd0ROSmVRZlhOSmVFcVhOaEdKV0VOSkZpSlJRbElKYkVRSmZYeERRcVhjZlhRRk5ERUpRRndYVUpEWWNuVUpESklCZ1FESVVKVFJESkZFcURTSlFTSkZTSlFJSkZTT1BlWnRTSkZaSkhDSlhRZlhDVERFcUZHSkJTSkZHSkJPZlhHSkJjcVhHSkhOSkRHSlJMaUpFSmZYRXFFSkZFSlBFRnBCRUpZSkJaSkZZQndYVUpZaUpNRUJZSlpKeVRZVE9OSlhwUU1GWEZwZUdJRGRwSkZzdFhwSkZjUERMQlZTSlJMSFFKcVhMSkZaSkZJSkJOSkRJSkJVcVhJQmtGREpJSkVKUFRJWUpHV1JJSmVRUERJSmVFZkhJSkZzSlhPcUdEU0ZIWEVKcVhnSkNzSkNnR1FKcVhnZFFZSkVnRk1GTkJnSkZjcURWSndYVUpWSkZaSmNoSWdKQ0N4T0VKcVh4T3dYVUp5REpCVlJ1c2Npc2NpSkJpSkJpZVV0cVhpSkZESmtpRnNKWFFVR0VaSmNVSkZzSlhadFhJclhaRFpKRHJaSkZOSkRaSkZzdFh2SkZRcVh2SkZDSkVzSlhRSnFraGtOR0JiREpkVFJiWUpNRUJsRHdYVUpNRUZpSkZjZlhOSkRSY05KV01UQkxKWENcIixcIkJyYUZVdEhCRlNKRmRiTkJMSlhWSlFvWUpORUJTSkJFSmZIU0pId1hVSkNKZEFaSk1HamFGVkpYRUpQTkpCbEVKZkZpSkZwRmJGRUpxSUpCVkpDcklCZEhpSmhPUEZDaHZKVkpaSk5KV3hHRk5JRkx1ZUlCUUpxVUhFSmZVRnN0T1pKRHJsWEVBU0pSbFhWSlhTRndWSk5KV0RcIixcIlFKRUpOTkpEUUpFSklCU0ZRSkVKeGVnQlFKRUpmSEVQU0pCbVhFSkZTSkNERUpxWExYTkpGUXFYSWNRc0ZOSkZJRkVKcVhVSmdGc0pYSUpCVUpFSmZITkZ2SnhFcVhOSm5YVUpGUXFEXCIsXCJJSkJFSnFYWkpcIl07Y29uc3QgbWFwcGluZz1cIn5+QXpCflh+YX5LTn5RfkR+U35Dfkd+RX5ZfnB+TH5Jfk9+ZUh+Z35Wfmh4eXVtaX5+VX5+Wn5+dn5+c35+ZGtvYmxQamZucXdNY1JUcn5Xfn5+Rn5+fn5+SnRcIjtsZXQgd29yZGxpc3QkND1udWxsO2Z1bmN0aW9uIGhleCh3b3JkKXtyZXR1cm4gaGV4bGlmeSh0b1V0ZjhCeXRlcyh3b3JkKSl9Y29uc3QgS2lZb0t1PVwiMHhlMzgxOGRlMzgyODRlMzgxOGZcIjtjb25zdCBLeW9LdT1cIjB4ZTM4MThkZTM4MjgzZTM4MThmXCI7ZnVuY3Rpb24gbG9hZFdvcmRzJDQobGFuZyl7aWYod29yZGxpc3QkNCE9PW51bGwpe3JldHVybn13b3JkbGlzdCQ0PVtdO2NvbnN0IHRyYW5zZm9ybT17fTt0cmFuc2Zvcm1bdG9VdGY4U3RyaW5nKFsyMjcsMTMwLDE1NF0pXT1mYWxzZTt0cmFuc2Zvcm1bdG9VdGY4U3RyaW5nKFsyMjcsMTMwLDE1M10pXT1mYWxzZTt0cmFuc2Zvcm1bdG9VdGY4U3RyaW5nKFsyMjcsMTMwLDEzM10pXT10b1V0ZjhTdHJpbmcoWzIyNywxMzAsMTM0XSk7dHJhbnNmb3JtW3RvVXRmOFN0cmluZyhbMjI3LDEyOSwxNjNdKV09dG9VdGY4U3RyaW5nKFsyMjcsMTI5LDE2NF0pO3RyYW5zZm9ybVt0b1V0ZjhTdHJpbmcoWzIyNywxMzAsMTMxXSldPXRvVXRmOFN0cmluZyhbMjI3LDEzMCwxMzJdKTt0cmFuc2Zvcm1bdG9VdGY4U3RyaW5nKFsyMjcsMTMwLDEzNV0pXT10b1V0ZjhTdHJpbmcoWzIyNywxMzAsMTM2XSk7ZnVuY3Rpb24gbm9ybWFsaXplKHdvcmQpe2xldCByZXN1bHQ9XCJcIjtmb3IobGV0IGk9MDtpPHdvcmQubGVuZ3RoO2krKyl7bGV0IGthbmE9d29yZFtpXTtjb25zdCB0YXJnZXQ9dHJhbnNmb3JtW2thbmFdO2lmKHRhcmdldD09PWZhbHNlKXtjb250aW51ZX1pZih0YXJnZXQpe2thbmE9dGFyZ2V0fXJlc3VsdCs9a2FuYX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIHNvcnRKYXBhbmVzZShhLGIpe2E9bm9ybWFsaXplKGEpO2I9bm9ybWFsaXplKGIpO2lmKGE8Yil7cmV0dXJuLTF9aWYoYT5iKXtyZXR1cm4gMX1yZXR1cm4gMH1mb3IobGV0IGxlbmd0aD0zO2xlbmd0aDw9OTtsZW5ndGgrKyl7Y29uc3QgZD1kYXRhW2xlbmd0aC0zXTtmb3IobGV0IG9mZnNldD0wO29mZnNldDxkLmxlbmd0aDtvZmZzZXQrPWxlbmd0aCl7Y29uc3Qgd29yZD1bXTtmb3IobGV0IGk9MDtpPGxlbmd0aDtpKyspe2NvbnN0IGs9bWFwcGluZy5pbmRleE9mKGRbb2Zmc2V0K2ldKTt3b3JkLnB1c2goMjI3KTt3b3JkLnB1c2goayY2ND8xMzA6MTI5KTt3b3JkLnB1c2goKGsmNjMpKzEyOCl9d29yZGxpc3QkNC5wdXNoKHRvVXRmOFN0cmluZyh3b3JkKSl9fXdvcmRsaXN0JDQuc29ydChzb3J0SmFwYW5lc2UpO2lmKGhleCh3b3JkbGlzdCQ0WzQ0Ml0pPT09S2lZb0t1JiZoZXgod29yZGxpc3QkNFs0NDNdKT09PUt5b0t1KXtjb25zdCB0bXA9d29yZGxpc3QkNFs0NDJdO3dvcmRsaXN0JDRbNDQyXT13b3JkbGlzdCQ0WzQ0M107d29yZGxpc3QkNFs0NDNdPXRtcH1pZihXb3JkbGlzdC5jaGVjayhsYW5nKSE9PVwiMHhjYjM2YjA5ZTZiYWE5MzU3ODdmZDc2MmNlNjVlODBiMGM2YThkYWJkZmJjM2E3Zjg2YWMwZTJjNGZkMTExNjAwXCIpe3dvcmRsaXN0JDQ9bnVsbDt0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3IgamEgKEphcGFuZXNlKSBGQUlMRURcIil9fWNsYXNzIExhbmdKYSBleHRlbmRzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJqYVwiKX1nZXRXb3JkKGluZGV4KXtsb2FkV29yZHMkNCh0aGlzKTtyZXR1cm4gd29yZGxpc3QkNFtpbmRleF19Z2V0V29yZEluZGV4KHdvcmQpe2xvYWRXb3JkcyQ0KHRoaXMpO3JldHVybiB3b3JkbGlzdCQ0LmluZGV4T2Yod29yZCl9c3BsaXQobW5lbW9uaWMpe2xvZ2dlciRrLmNoZWNrTm9ybWFsaXplKCk7cmV0dXJuIG1uZW1vbmljLnNwbGl0KC8oPzpcXHUzMDAwfCApKy9nKX1qb2luKHdvcmRzKXtyZXR1cm4gd29yZHMuam9pbihcIuOAgFwiKX19Y29uc3QgbGFuZ0phPW5ldyBMYW5nSmE7V29yZGxpc3QucmVnaXN0ZXIobGFuZ0phKTtcInVzZSBzdHJpY3RcIjtjb25zdCBkYXRhJDE9W1wiT1lBYVwiLFwiQVRBWm9BVEJsM0FUQ1RyQVRDbDhBVERsb0FUR2czQVRIVDhBVEpUOEFUSmwzQVRMbHZBVExuNEFUTVQ4QVRNWDhBVE1ib0FUTWdvQVRvTGJBVG9NVEFUckhnQVR2SG5BVDNBbkFUM0piQVQzTVRBVDhEYkFUOEpUQVQ4TG1BVDhNWUFUOE1iQVQjTG5BVUhUOEFVSFp2QVVKWHJBVUpYOEFVTG5yQVhKbnZBWExVb0FYTGd2QVhNbjZBWFJnM0FYck1iQVgzSlRBWDNRYkFZTG4zQVpMZ3ZBWnJTVUFadkFjQVo4QWFBWjhBYkFaOEFuQVo4SG5BWjhMZ0FaOE1ZQVo4TWdBWjhPbkFhQWJvQWFEVHJBYUZUckFhSlRyQWFKYm9BYUxWb0FhTVh2QWFPbDhBYVNlb0FiQVVvQWJBZzhBYkFsNEFiR25yQWJNVDhBYk1YckFiTW40QWJRYjhBYlNWOEFidlJsQWI4QVVBYjhBbkFiOEhnQWI4SlRBYjhOVEFiOFJiQWNHYm9BY0xudkFjTVQ4QWNNWDhBY1NUb0FjckFhQWNyRm5BYzhBYkFjOE1nQWZHZ3JBZkhib0FmSm52QWZMVjhBZkxrb0FmTVQ4QWZNbm9BZlFiOEFmU2NyQWZTZ3JBZ0FaOEFnRmwzQWdHWDhBZ0hadkFnSGdyQWdKWG9BZ0pYOEFnSmJvQWdMWm9BZ0xuNEFnT1g4QWdvQVRBZ29BbkFnb0NVQWdvSmdBZ29MWEFnb01ZQWdvU2VBZ3JEVUFnckpUQWhyRm5BaHJMakFoclFnQWpBZ29BakpuckFrTVg4QWtPbm9BbENUdkFsQ1Y4QWxDbHZBbEZnNEFsRmw2QWxGbjNBbG9TbkFsckFYQWxyQWZBbHJGVUFsckZiQWxyR2dBbHJPWEFsdktuQWx2TVRBbDNBYkFsM01uQW5BVHJBbkFjckFuQ1ozQW5DbDhBbkRnOEFuRmJvQW5GbDNBbkhYNEFuSGJyQW5IZ3JBbklsM0FuSmd2QW5MWG9BbkxYNEFuTGJyQW5MZ3JBbkxockFuTVhvQW5NZ3JBbk9uM0FuU2JyQW5TZW9BbnZMbkFuM09uQ1RHZ3ZDVFNsdkNUdkFVQ1R2S25DVHZOVENUM0NaQ1QzR1VDVDNNVENUOEhuQ1VDWnJDVUxmOENVTG52Q1UzSG5DVTNKVUNZNk5VQ2JEYjhDYkZab0NiTG5yQ2JvT1RDYm9TY0NickZuQ2J2TG5DYjhBZ0NiOEhnQ2IkTG5Da0xmb0NsQm4zQ2xvRFVEVEhUOERUTGwzRFRTVThEVHJBYURUckxYRFRyTGpEVHJPWURUck9nRFR2RlhEVHZGbkRUM0hVRFQzTGZEVUNUOURVRFQ0RFVGVm9EVUZWOERVRmtvRFVHZ3JEVUpuckRVTGw4RFVNVDhEVU1YckRVTVg0RFVNZzhEVU9Vb0RVT2d2RFVPZzhEVVNUb0RVU1o4RGJEWG9EYkRnb0RiR1Q4RGJKbjNEYkxnM0RiTG40RGJNWHJEYk1nOERiT1RvRGJvSlhHVENsdkdURFQ4R1RGWnJHVExWb0dUTGx2R1RMbDNHVE1nOEdUT1R2R1RTbHJHVG9DVUdUckRnR1RySllHVHJTY0dUdExuR1R2QW5HVHZRZ0dVQ1pyR1VEVHZHVUZab0dVSFhyR1VMbnZHVU1UOEdVb01nR1hvTG5HWHJNWEdYck1uR1h2Rm5HWUxudkdaT252R1p2T25HWjhMYUdaOExtR2JBbDNHYkRZdkdiRGxyR2JIWDNHYkpsNEdiTFY4R2JMbjNHYk1uNEdib0pUR2JvUmZHYnZGVUdiM0dVR2I0Sm5HZ0RYM0dnRmwkR2dKbHJHZ0xYNkdnTFpvR2dMZjhHZ09Yb0dnckFnR2dySlhHZ3JNWUdnclNjR2d2QVRHZ3ZPWUduQWdvR25KZ3ZHbkxab0duTGczR25MbnJHblFuOEduU2JyR25yTWdIVENsdkhURFRvSFRGVDNIVFFUOEhUb0pUSFRvSmdIVHJEVUhUck1uSFR2RllIVHZSZkhUOE1uSFQ4U1VIVUFaOEhVQmI0SFVEVHZIVW9NWUhYRmw2SFhKWDZIWFFsckhYckFVSFhyTW5IWHJTYkhYdkZZSFh2S1hIWDNMakhYM01lSFl2UWxIWnJTY0hadkRiSGJBY3JIYkZUM0hiRmwzSGJKVDhIYkxUckhiTVQ4SGJNWHJIYk1ickhiUWI4SGJTWDNIYm9EYkhib0pUSGJyRlVIYnJIZ0hickpUSGI4SlRIYjhNbkhiOFFnSGdBbHJIZ0RUM0hnR2dySGdIZ3JIZ0pUckhnSlQ4SGdMWEBIZ0xuckhnTVQ4SGdNWDhIZ01ib0hnT25ySGdRVG9IZ1JnM0hnb0hnSGdyQ2JIZ3JGbkhnckxWSGd2QWNIZ3ZBZkhuQWxvSG5DVHJIbkNudkhuR1RySG5HWjhIbkdudkhuSlQ4SG5MZjhIbkxrdkhuTWc4SG5SVHJJVHZGVUlUdkZuSlRBWHJKVENWOEpURlQzSlRGVDhKVEZuNEpUR2d2SlRIVDhKVEpUOEpUSlh2SlRKbDNKVEpudkpUTFg0SlRMZjhKVExodkpUTVQ4SlRNWHJKVE1uckpUT2JySlRRVDhKVFNsdkpUOERVSlQ4RmtKVDhNVEpUOE9YSlQ4T2dKVDhRVUpUOFJmSlVIWm9KWEZUNEpYRmxySlhHWjhKWEduckpYTFY4SlhMZ3ZKWE1Yb0pYTVgzSlhOYm9KWFBsdkpYb0pUSlhvTGtKWHJBWEpYckhVSlhySmdKWHZKVEpYdk9uSlg0S25KWUFsM0pZSlQ4SllMaHZKWVFUb0pZclFYSlk2TlVKYkFsM0piQ1pySmJEbG9KYkdUOEpiR2dySmJKWHZKYkpib0piTGY4SmJMaHJKYkxsM0piTW52SmJSZzhKYlNaOEpib0RiSmJyQ1pKYnJTVUpiM0tuSmI4TG5KZlJuOEpnQVhySmdDWnJKZ0RUckpnR1pySmdHWjhKZ0hUb0pnSlQ4SmdKWG9KZ0pndkpnTFg0SmdMWjNKZ0xaOEpnTG40SmdNZ3JKZ01uNEpnT2d2SmdQWDZKZ1JudkpnU1RvSmdvQ1pKZ29KYkpnb01ZSmdySlhKZ3JKZ0pnckxqSmc2TVRKbENuM0psR2d2SmxKbDhKbDRBbkpsOEZuSmw4SGdKbkFUb0puQVRySm5BYnZKbkRVb0puR25ySm5KWHJKbkpYdkpuTGh2Sm5MbnJKbkxudkpuTVRvSm5NVDhKbk1YdkpuTVgzSm5NZzhKbk1sckpuTW40Sm5PWDhKblNUNEpuU1gzSm5vQWdKbm9Bbkpub0pUSm5vT2JKbnJBYkpuckFrSm5ySG5KbnJKVEpuckpZSm5yT1lKbnJTY0pudkNVSm52RmFKbnZKZ0pudkpuSm52T1lKbnZRVUpudlJVSm4zRm5KbjNKVEtuRmwzS25MVDZMVERsdkxUTW5vTFRPbjNMVFJsM0xUU2I0TFRTbHJMVG9BbkxUb0pnTFRyQVVMVHJBY0xUckNVTFRySGdMVHJNZ0xUM0puTFVMbnJMVU1YOExVb0pnTFZBVHJMVkRUckxWTGI4TFZvSmdMVjhNZ0xWOFJUTFhEZzNMWEZsckxYckNuTFhyTFhMWDNHVExYNEdnTFg0T1lMWkFYckxaQWNyTFpBZ3JMWkFockxaRFh5TFpEbHJMWkZickxaRmwzTFpKWDZMWkpYOExaTGM4TFpMbnJMWlNVOExab0pUTFpvSm5MWnJBZ0xackFuTFpySllMWnJMVUxack1nTFpyU2tMWnZBbkxadkdVTFp2SmVMWnZPVExaM0ZaTFo0SlhMWjhTVExaOFNjTGFBVDNMYUFsM0xhSFQ4TGFKVHJMYUpUOExhSlhyTGFKZ3ZMYUpsNExhTFZvTGFNWHJMYU1YdkxhTVg4TGJDbHZMYkZUb0xiSGxyTGJKbjRMYkxaM0xiTGh2TGJNWHJMYk1ub0xidlNVTGNMbnJMYzhIbkxjOE1UTGRyTW5MZUFnb0xlT2d2TGVPbjNMZkFsM0xmTG52TGZNbDNMZk9YOExmOEFuTGY4SlhMZjhMWExnSlRyTGdKWHJMZ0psOExnTVg4TGdSWnJMaENUb0xockFiTGhyRlVMaHJKWExodkpZTGpIVHJMakhYNExqSlg4TGpMaHJMalNYM0xqU1o0TGtGWDRMa0daOExrR2d2TGtKVHJMa01Yb0xrU1RvTGtTVThMa1NaOExrb09ZTGwzRmZMbDNNZ0xtQVpyTG1DYnJMbUdnckxtSGJvTG1Kbm9MbUpuM0xtTGZvTG1MaHJMbVNUb0xuQVg2TG5BYjZMbkNaM0xuQ2IzTG5EVHZMbkRiOExuRmwzTG5HbnJMbkhadkxuSGd2TG5JVHZMbkpUOExuSlg4TG5KbHZMbkxmOExuTGc2TG5MaHZMbkxub0xuTVhyTG5NZzhMblFsdkxuU2JyTG5yQWdMbnJBbkxuckRiTG5yRmtMbnJKZExuck1VTG5yT1lMbnJTVExudkFuTG52RFVMbnZIZ0xudk9ZTG52T25MbjNHZ0xuNERVTG40SlRMbjRKbk1UQVpvTVRBbG9NVERiOE1URlQ4TVRKbm9NVEpuck1UTFpyTVRMaHJNVExrdk1UTVg4TVRSVHJNVG9BVE1UckRuTVRyT25NVDNKbk1UNE1uTVQ4RlVNVDhGYU1UOEZsTVQ4R1RNVDhHYk1UOEduTVQ4SG5NVDhKVE1UOEpiTVQ4T1RNVUNsOE1VSlRyTVVKVThNVU1YOE1VUlRyTVVTVG9NWEFYNk1YQWI2TVhDWm9NWEZYck1YSFhyTVhMZ3ZNWE9nb01YckFVTVhyQW5NWHJIZ01YckpZTVhySm5NWHJNVE1Yck1nTVhyT1lNWHJTWk1YclNnTVh2RFVNWHZPVE1YM0pnTVgzT1RNWDRKbk1YOERiTVg4Rm5NWDhIYk1YOEhnTVg4SG5NWDhMYk1YOE1uTVg4T25NWUFiOE1ZR2JvTVlIVHZNWUhYNE1ZTFRyTVlMbnZNWU1Ub01ZT2d2TVlSZzNNWVNUck1iQVRvTWJBWHJNYkFsM01iQW44TWJHWjhNYkpUOE1iSlhyTWJNWHZNYk1YOE1iTW5vTWJyTVVNYjhBZk1iOEZiTWI4RmtNY0pYb01lTG5yTWdGbDNNZ0dUdk1nR1hvTWdHZ3JNZ0duck1nSFQ4TWdIWnJNZ0pub01nTG5yTWdMbnZNZ01UOE1nUVVvTWdySG5NZ3ZBbk1nOEhnTWc4SllNZzhMZk1sb0puTWw4QVRNbDhBWE1sOEpZTW5BVG9NbkFUNE1uQVo4TW5BbDNNbkFsNE1uQ2w4TW5IVDhNbkhnOE1uSm5vTW5MWm9Nbkxock1uTVhvTW5NWDNNbk1uck1uT2d2TW5yRmJNbnJGZk1uckZuTW5yTlRNbnZKWE5UTWw4T1RDVDNPVEZWOE9URm4zT1RIWnZPVEpYck9UT2wzT1QzQVRPVDNKVU9UM0xaT1QzTGVPVDNNYk9UOEFUT1Q4QWJPVDhBZ09UOE1iT1VDWHZPVU1YM09YSFh2T1hMbDNPWHJNVU9YdkRiT1g2TlVPWDhKYk9ZRlpvT1lMYnJPWUxrb09ZTWc4T1lTWDNPYkhUck9iSFQ0T2JKZ3JPYkxock9iTVgzT2JPWDhPYjhGbk9lQWxyT2VKVDhPZUpYck9lSm5yT2VMVG9PZU1iOE9nSlhvT2dMWG9PZ01uck9nT1hyT2dPbG9PZ29BZ09nb0piT2dvTVlPZ29TVE9nOEFiT2pMWDRPak1ub09qU1Y4T25MVm9PbnJBZ09uM0RVUFhRbHJQWHZGWFBidkZUUGRBVDNQbEZuM1BudkZiUVRMbjRRVG9BZ1FUb01UUVVMVjhRVVJnOFFVb0puUVhDWHZRYkZiclFiOEFhUWI4QWNRYjhGYlFiOE1ZUWI4U2NRZUFsclFlTGhyUWpBbjNRbEZYb1Fsb0pnUWxvU25SVExudlJUckdVUlRySlRSVUpaclJVb0psUlVyUW5SWnJMbVJack1uUlpyU25SWjhBVFJaOEpiUlo4U2NSYk1UOFJiU1QzUmZHWnJSZk1YOFJmTWdyUmZTWnJSbkFiclJuR1Q4Um52SmdSbnZMZlJudk1UUm44QWFTVENsdlNUSmdyU1RPWHJTVFJnM1NUUm52U1RvQWNTVG9BZlNUb0FuU1RvSG5TVG9MalNUb01UU1RyQWFTVHJFVVNUM0JZU1Q4QWdTVDhMbVNVQVp2U1VBZ3JTVURUNFNVRFQ4U1VHZ3ZTVUpYb1NVSlh2U1VMVHJTVThKVFNVOExqU1Y4QW5TVjhKZ1NYRlRvU1hMZjhTWXZBblNackRVU1pyTVVTWnJNblNaOEhnU1o4SlRTWjhKZ1NaOE1ZU1o4UVVTYVFVb1NiQ1QzU2JIVG9TYlFZdlNiU2w0U2JvSm5TYnZGYlNiOEhiU2I4SmdTYjhPVFNjR1pyU2NIZ3JTY0pUdlNjTVQ4U2NTVG9TY29IYlNjck1UU2N2QW5TZUFaclNlQWNyU2VIYm9TZUpVb1NlTGhyU2VNVDhTZU1YclNlNkpnU2dIVHJTa0pub1NrTG52U2s4Q1VTbEZsM1NsclNuU2w4R25TbUFib1NtR1Q4U21KVThcIixcIkFUTG5EbEFUckFab0FUckpYNEFUck1UOEFUck1YNEFUclJUckFUdkRsOEFUdkpVb0FUdk1sOEFUM0FUb0FUM01YOEFUOENUM0FUOERUOEFUOEhackFUOEhnb0FVQWdGbkFVQ1RGbkFYb01YOEFYckFUOEFYckdndkFYckpYdkFYck9nb0FYdkxsM0FadkFnb0FadkZickFadkpYb0FadkpsOEFadkpuM0Fadk1YOEFadlNickFaOEZab0FaOExaOEFaOE1VOEFaOE9UdkFaOFNWOEFaOFNYM0FiQWdGWkFib0pub0Fidkdib0FiOEFUckFiOEFab0FiOEFnckFiOEFsNEFiOERiOEFiOEpub0FiOExYNEFiOExackFiOExockFiOE1UOEFiOE9Vb0FiOFFiOEFiOFNUOEFjckFVb0FjckFjOEFjckNaM0FjckZUM0FjckZackFjckpsNEFjckpuM0Fjck1YM0Fjck9UdkFjOEFaOEFjOE1UOEFmQWNKWEFnb0ZuNEFnb0dndkFnb0duckFnb0xjOEFnb01Yb0FnckxuckFrclNaOEFsRlhDVEFsb0hib0FsckhickFsckxockFsckxrb0FsM0NackFsM0xVb0FsM0xackFuckFsNEFuck1UOEFuM0hUNEJUM0lUb0JYNE1udkJiIUxuJENUR1hNbkNUb0xaNENUckhUOENUM0pUckNUM1JackNUI0dUdkNVNkdndkNVOERiOENVOEdackNVOEhUOENib0xsM0NickdnckNick1VOENiOERUM0NiOEduckNiOExYNENiOE1UOENiOE9ickNnckdndkNncktYNENsOEZab0RUckFidkRUckRib0RUckdUNkRUckpnckRUck1YM0RUclJackRUclJnOERUdkFWdkRUdkZab0RUM0RUOERUM0xuM0RUNEhackRUNE1UOERUOEFsckRUOE1UOERVQWtHYkRVRGJKbkRZTG5RbERiRFVPWURiTVRBbkRiTVhTbkRib0FUM0Rib0ZuNERib0xudkRqNkpUckdUQ2dGVEdUR2dGbkdUSlRNbkdUTG5QbEdUb0pUOEdUckNUM0dUckxWb0dUckxudkdUck1YM0dUck1ib0dUdktsM0daQ2xGbkdackRUM0daOERUckdaOEZaOEdaOE1YdkdaOE9uOEdaOFNUM0diQ25RWEdiTWJGbkdib0Zib0dib0pnM0dib01Yb0diM0pUdkdiM0pib0diM01uNkdiM1FiOEdnRFhMakdnTW5BVUdnckRsb0dnckhYNEdnclNUb0dndkFYckdndkFadkdndkZickdndkxsM0dndk1udkduRG5MWEduckFUckduck1ib0dudUxsM0hUQVRNbkhUQWdDbkhUQ1RDVEhUckdUdkhUckhUdkhUckpYOEhUckxsOEhUck1UOEhUck1nb0hUck9UckhUdU9uM0hUdkFackhUdkRUdkhUdkdib0hUdkpVOEhUdkxsM0hUdk1YckhUdlFiNEhUNEdUNkhUNEpUOEhUNEpiI0hUOEFsM0hUOEdackhUOEdnckhUOEhYNEhUOEpiOEhUOEpub0hUOExUckhUOExndkhUOFNUb0hUOFNWOEhVb0pVb0hVb0pYOEhVb0xuckhYckxab0hYdkFsM0hYM0xuckhYNEZrdkhYNExockhYNE1Yb0hYNE9ub0hackFaOEhackRiOEhackdaOEhackpuckhadkdaOEhadkxudkhaOEpudkhaOExockhiQ1hKbEhiTVRBbkhib0psNEhicExsM0hickpYOEhickxuckhick1udkhidlJZckhnb1NUckhnckZWOEhnckdaOEhnckpYb0hnclJudkhndkJiIUhndkdUckhndkhYNEhndkhuIUhndkxUckhndlNVOEhuRG5MYkhuRmJKYkhudkRuOEhuNkdndkhuIUJUdkpUQ1RMbkpUUWdGbkpUckFudkpUckxYNEpUck9Vb0pUdkZuM0pUdkxuckpUdk5Ub0pUM0Fnb0pUM0puNEpUM0xodkpUM09ickpUOEFjckpUOEFsM0pUOEpUOEpUOEpub0pUOExYNEpUOExuckpUOE1YM0pUOFJnM0pUOFNjOEpVb0JUdkpVOEFUb0pVOEdaOEpVOEdndkpVOEpUckpVOEpYckpVOEpuckpVOExudkpVOFNjdkpYSG5KbEpYckdndkpYckpVOEpYckxockpYck1UOEpYck1YckpYclFVb0pYdkNUdkpYdkdaOEpYdkdnckpYdlFUOEpYOEFiOEpYOERUOEpYOEdaOEpYOEhadkpYOExuckpYOE1UOEpYOE1Yb0pYOE1udkpYOFNUM0pZR25DVEpiQWtHYkpiQ1RBbkpiTFRBY0pib0RUM0pib0xiNkpickFudkpickNuM0pickRsOEpickdib0picklab0pickpudkpick1udkpiclFiNEpiOFJackplQWJBbkpnSm5GYkpnU2NBbkpnckFUckpndkhaOEpndk1uNEpsSmxGYkpsTGlRWEpsTGpPbkpsUmJPbEpsdk5Yb0psdlJsM0psNEFjckpsOEFVb0psOE1uckpuRm5NbEpuSGdHYkpub0RUOEpub0ZWOEpub0dndkpub0lUOEpub1FUb0pub1JnM0puckNaM0puckdnckpuckhUdkpuckxmOEpuck9YOEpudkFUM0pudkZab0pudkdUOEpudkpsNEpudk1UOEpudk1YOEpudk9YckpudlBYNkpudlNYM0pudlNackpuM01UOEpuM01YOEpuM1JUckxUQVRLbkxUSm5MVExUTVhLbkxUUlRRbExUb0diOExUckFaOExUckNaOExUckRiOExUckhUOExUM1BYNkxUNEZab0xUJENUdkxUJEdnckxVdkhYM0xWb0FUckxWb0Fnb0xWb0pib0xWb01YM0xWb1JnM0xWOENaM0xWOEZab0xWOEdUdkxYckRYb0xYckZickxYdkFndkxYdkZsckxYdkxsM0xYdlJuNkxYNE1iOExYOEdUOExZQ1hNbkxZck1uckxab1NUdkxackFadkxackFsb0xackZUb0xackpYdkxackpib0xackpsNExackxuckxack1UOExack9ndkxaclJudkxaclNUNExadk1YOExadlNsdkxaOEFnb0xaOENUM0xaOEpUOExaOExWOExaOExab0xaOExnOExaOFNWOExaOFNickxaJEhUOExaJE1uNExhNkNUdkxiRmJNbkxiUllGVExiU25GWkxib0pUOExickFUOUxickdiM0xiclFiOExjckpYOExjck1YckxlckhUdkxlckpickxlck5ib0xnckRiOExnckdaOExnckhUckxnck1YckxnclNVOExndkpUckxndkxsM0xnNkxsM0xockxuckxock1UOExodkFsNExpTG5RWExrb0Fnckxrb0pUOExrb0puNExsclNVOExsM0Zab0xsM0hUckxsM0pYOExsM0pub0xsM0xUb0xtTGVGYkxuRFVGYkxuTFZBbkxuckFUckxuckFab0xuckFiOExuckFsckxuckdndkxuckpVOExuckxackxuckxockxuck1iOExuck9YckxuclNaOExudkFiNExudkRUckxudkRsOExudkhUckxudkhickxudkpUOExudkpVOExudkpickxudkxodkxudk1YOExudk1iOExudk5ub0xudlNVOExuM0FsM0xuNEZab0xuNEdUNkxuNEpndkxuNExockxuNE1UOExuNFNUb01Ub0Nack1Ub0pYOE1Ub0xYNE1Ub0xmOE1Ub1JnM01UckVsb01UdkdiNk1UM0JUck1UM0xiNk1UOEFjck1UOEFnck1UOEdack1UOEpub01UOExuck1UOE1YM01VT1VBbk1YQWJGbk1Yb0Fsb01Yb0pYOE1Yb0xmOE1Yb0xsOE1YckFiOE1YckRUdk1YckdUOE1Yckdnck1YckhUck1YckxmOE1Yck1VOE1Yck9Ydk1YclFiOE1YdkdUOE1YdkhUck1YdkxWb01YM0FYM01YM0puM01YM0xock1YM01YM01YNEFsck1YNE9ib01YOEdUdk1YOEdack1YOEdnck1YOEpUOE1YOEpYOE1YOExock1YOE1UOE1ZRFVGYk1ZTWdEYk1iR25GZk1idkxYNE1idkxsM01iOE1iOE1iOFNUNE1nR1hDbk1nOEFUck1nOEFnb01nOENack1nOERUck1nOERib01nOEhUck1nOEpnck1nOExUOE1sb0pYb01sOEFock1sOEpUOE1uTGdBVU1ub0pYck1ub0xYNE1ub0xock1ub01UOE1uckFsNE1uckRiOE1uck9Udk1uck9ndk1uclFiOE1uclNVOE1udkdnck1udkhaOE1uM01Ub01uNERUck1uNExUck1uNE1nOE5uQlhBbk9URlRGbk9Ub0FUb09Uckdndk9UckpYOE9UM0pYb09UNk1Uck9UOEdnck9UOEhUcE9UOE1Ub09Vb0hUOE9Vb0pUOE9Vb0xuM09YckFnb09YckRnOE9Yck1UOE9YdlNUb09YNkNUdk9YOENack9YOE9nck9iNkhndk9iOEFUb09iOE1UOE9jdkxaOE9ndkFsck9ndkhUdk9ndkpUck9ndkpuck9ndkxack9ndkxuNE9ndk1UOE9ndlJUck9nOEFab09nOERidk9uck9Yb09udkpuNE9udkxodk9udlJUck9uM0dnb09uM0pudk9uNkpidk9uOE9UclBUR1lGVFBiQm5GblBiR25EblBnRFlRVFBsckFudlBsckVUdlBsckxudlBsck1YdlBsdkZYNFFUTVRBblFUckpVOFFZQ25KbFFZSmxRbFFiR1RRYlFiOEpuclFiOExab1FiOExudlFiOE1UOFFiOE1sOFFiOFNUNFFsb0FsNFFsb0hadlFsb0pYOFFsb01uOFFuSlpPbFJUckFadlJUckRUclJUdkpuNFJUdkxodlJUNEpiOFJackFaclJaOEFrclJaOEpVOFJaOExWOFJaOExudlJiSmxRWFJnM0dib1JnM01udlJnOEFaOFJnOEpib1JnOEpsNFJuTFRDYlJudkZsM1JudlFiOFNUb0FsNFNUb0NaclNUb0Zab1NUb0hYclNUb0pVOFNUb0pndlNUb0psNFNUb0xoclNUb01YM1NUckFsdlNUckNUOVNUckNnclNUckdnclNUckhYclNUckhib1NUckpub1NUck5ib1NUdkxuclNUNEFab1NUOEFiOFNUOEpUOFNVb0puM1NVNkhaI1NVNkpUdlNVOERiOFNVOEhib1NVOExnclNWOEpUOFNackFjclNackFsM1NackpUOFNackpudlNack1UOFNadkxVb1NaNEZab1NaOEpub1NaOFJaclNjb0xuclNjb01UOFNjb01YOFNjckFUNFNjckFaOFNjckxaOFNjckxrdlNjdkRiOFNjdkxmOFNjdk5Ub1NnckZaclNodktuclNsb0hVb1Nsb0xuclNsck1Yb1NsOEhnclNtckpVb1NuM0JYNlwiLFwiQVRGbE9uM0FUTGdyRFlBVDRNVEFuQVQ4TFRNbkFZSm5SVHJBYkdnSm5yQWJMVjhMbkFidk5UQW5BZUZiTGczQWdPWU1Yb0FsUWJGYm9BbkRib0FmQW5KZ29KVEJUb0RnQW5CVUpiQWwzQmJvRFVBbkNURGx2TG5DVEZUclNuQ1lvUVRMbkRUd0FiQW5EVURUclNuRFVIZ0hnckRYOExYRm5EYkpYQWNyRVR2TFRMbkdURlRRYnJHVE1uR1RvR1QzRFVGYkdVSmxQWDNHYlFnOExuR2JvSmJGbkdiM0dnQVlHZ0FnOFNjR2dNYkFYckdndkFiQW5HbkpUTG52R252QVRGZ0hURFQ2QVRIVHJEbEpuSFlMbk1uOEhaclNiSlRIWjhMVEZuSGJGVEpVb0hnU2VNVDhIZ3JMakFuSGd2QWJBbkhsRlVyRGxIbkRndkFuSG5IVEZUM0huUVRHbnJKVEFhTVh2SlRHYkNuM0pUT2dyQW5KWHZBWE1uSmJNZzhTbkpiTW5SZzNKYjhMVE1uSm5BbDNPbkpuR1lyUWxKbkpsUVkzTFREbENuM0xUSmpMZzNMVExndkZYTFRNZzNHVExWOEhVT2dMWEZaTGczTFhOWHJNbkxYOFFYRm5MWDlBbE1ZTFlMWFBYckxaQWJKVThMWkRVSlU4TFpNWHJTbkxaJEFnRm5MYVBYckRVTGJGWXJNbkxiTW44TFhMYm9KZ0pnTGVGYkxnM0xnTFpyU25MZ09ZQWdvTGhyUm5KbExrQ1RyU25Ma09uTGhyTG5GWCVBWUxuRlpvSlhMbkhUdkpiTG5MbG9BYk1UQVRMZjhNVEhnSm4zTVRNWHJBWE1UM01URm5NVUlUdkZuTVhGWCVBWU1YTVh2RmJNWHJGVERiTVlBY01YM01iTGY4U25NYjhKYkZuTWdNWHJNVE1ndkFYRm5NZ3ZHZ0NtTW5BbG9Tbk1uRm5KVHJPWHZNWFNuT1g4SFRNbk9iSlQ4U2NPYkxaRmwzT2JNWENab1BUTGdyUVhQVUZub1FYUFUzUlhKbFBYM1JrUVhQYnJKWFFsUGxySmJGblFVQWhyRGJRWEduQ1h2UVlMbkhsdlFiTGZMbnZSVE9ndkpiUlhKWXJRbFJZTG5yUWxSYkxuclFsUmxGVDhKbFJsRm5yUVhTVENsQ24zU1RIVHJBblNUTFpRbHJTVE1uR1RyU1RvSGdHYlNUckdURG5TVHZHWENuU1QzSGdGYlNVM0hYQVhTYkFuSm4zU2JGVDhMblNjTGZMbnZcIixcIkFUM0pnSlg4QVQ4RlpvU25BVDhKZ0ZWOEFUOExockRiQVo4SlQ4RGJBYjhHZ0xockFiOFNrTG52QWU4TVQ4U25BbE1ZSlhMVkFsM0dZRFR2QWwzTGZMbnZCVURUdkxsM0NUT24zSFRyQ1QzRFVHZ3JDVThNVDhBYkNiRlRySlVvQ2dyRGI4TVREVExWOEpYOERUTG5MWFFsRFQ4TFpyU25EVVFiOEZaOERVU1Q0Sm52RGI4U2NPVW9EajZHYkpsNEdUTGZDWU1sR1RvQVh2Rm5HYm9BWHZMbkdnQWNySm4zR2d2Rm5TVG9HbkxmOEpudkduI0hURFRvSFRMbkZYSmxIVHZBVEZUb0hUdkhURFRvSFR2TVRBZ29IVDNTVENsdkhUNEFsRmw2SFQ4SFREVG9IVW9EZ0pUckhVb1NjTVgzSGJSWnJNWG9IYm9KZzhMVEhnRGI4SlRySGdNVG9MZjhIZ3ZMbkxub0huSG4zSFQ0SG42TWd2QW5KVEpVOFNjdkpUM0FhUVQ4SlQ4SFRyQW5KWHJSZzhBbkpiQWxvTVhvSmJyQVRGVG9KYnZNbm9TbkpnRGI2R2d2SmdEYjhNWG9KZ1NYM0pVOEpndUFURlRvSmxQWUxuUWxKbFFrRG5MYkpsUWxGWUpsSmw4TGY4T1RKbkNURm5MYkpuTFRIWE1uSm5MWEdYQ25Kbm9GZlJnM0puck1ZUmczSm4zSGdGbDNLVDhEZzhMbkxUUmxGblBUTFR2UGJMYnZMVm9TYnJDWkxYTVk2SFQzTFhOVTdEbHJMWE5YRFRBVExYOERYOExuTFpEYjhKVThMWk1ub0xockxaU1RvSlU4TFpyTGFMbnJMWnZKbjNTbkxaOExoclNuTGFKbm9NVDhMYkZsckhUdkxickZUTG5yTGJ2QVRMbHZMYjZPVEZuM0xjTG5KWk9sTGVBVDZNbjRMZUpUM09ickxnNkxYRmxyTGhySmc4TG5MaHZEbFBYNExodkxmTG52TGo2SlRGVDNMbkZick1Yb0xuUWx1Q1R2TG5yUVhDWTZMbnZMZkxudkxudk1nTG52TG52U2VMZjhNVE1ickpuM01UM0pnU1QzTVQ4QW5BVHJNVDhMVUxuck1VTVRvQ1pyTVVTY3ZMZjhNWG9EVDhTbk1YNkFURlRvTVg4QVhNVDhNWDhGa01UOE1YOEhUckRVTVg4U2NvU25NWUpUNkNUdk1nQWNyTVhvTWc4U1RvQWZNbHZBWExnM01uRmwzQW52T1QzQW5GbDNPVW9BVEhUOE9VM1JuTFhyT1hyT1hyU25PYlBidkZuNk9nOEhnclNuT2c4T1g4RGJQVHZBZ29KZ1BVM1JZTG5yUFhyRG5KWnJQYjhDVEdndlBsckxURGx2UGx2RlVKbm9RVXZGWHJRbFFlTW5vQWwzUWxyUWxyU25SVEZUckpVb1NURGxMaUxYU1RGZzZIVDNTVEpnb01uNFNUckZUSlRyU1RyTFpGbDNTVDRGbk1Yb1NVckRsSFVvU2N2SFR2U25TZkxrdk1Yb1wiLFwiQVVvQWNyTVhvQVo4SGJvQWc4QWJPZzZBVEZnQWc4QWxvTVhvQWwzQVQ4SlRyQWw4TVg4TVhvQ1QzU1RvSlU4Q2w4RGI4TVhvRFQ4SGdyQVRyRGJvT1Q4TVhvR1RPVHJBVE1uR1Q4TGhyQVo4R252Rm5HblFYSFRvR2d2QWNySFR2QVh2TGwzSGJyQVpvTVhvSGdCbEZYTGczSGdNbkZYclNuSGdyU2I4SlVvSG42SFQ4TGd2SVR2QVRySlVvSlVvTFpyUm52SlU4SFQ4SmI4Slh2Rlg4UVQ4Slh2TFRvSlRySllyUW5HblFYSmdySm5vQVRySm5vSlU4U2N2Sm52TW52TVhvTFRDVExnckpYTFRKbFJUdlFsTGJSbkpsUVl2TGJyTWI4TG52TGJ2Rm4zUm5vTGRDVlNUR1pyTGVTVHZHWENuTGczTW5vTG4zTVRvTGxyRVR2TVQ4U1RvQWwzTWJyRFU2R1R2TWI4TFg0TGhyUGxyTFhHWENuU1RvTGY4UmczU1RyRGI4TFRyU1R2TFRIWE1uU2IzUllMbk1uU2dPZzZBVEZnXCIsXCJIVURsR25yUVhySlRySGdMbnJBY0pZTWI4RFVMYzhMVHZGZ0duQ2szTWc4SmJBbkxYNFFZdkZZSG5NWHJSVW9KbkdudkZuUmx2RlRKbFFub1NUckJYSFhyTFlTVUpnTGZvTVQ4U2U4RFRySGJEYlwiLFwiQWJEbDhTVG9KVThBbjNSYkFiOFNUOERVU1RyR25yQWdvTGJGVTZEYjhMVHJNZzhBYUhUOEpiOE9iRGw4U1RvSlU4UGIzUmx2RllvSmxcIl07Y29uc3QgY29kZXM9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSFAIyQlXiYqXCI7ZnVuY3Rpb24gZ2V0SGFuZ3VsKGNvZGUpe2lmKGNvZGU+PTQwKXtjb2RlPWNvZGUrMTY4LTQwfWVsc2UgaWYoY29kZT49MTkpe2NvZGU9Y29kZSs5Ny0xOX1yZXR1cm4gdG9VdGY4U3RyaW5nKFsyMjUsKGNvZGU+PjYpKzEzMiwoY29kZSY2MykrMTI4XSl9bGV0IHdvcmRsaXN0JDU9bnVsbDtmdW5jdGlvbiBsb2FkV29yZHMkNShsYW5nKXtpZih3b3JkbGlzdCQ1IT1udWxsKXtyZXR1cm59d29yZGxpc3QkNT1bXTtkYXRhJDEuZm9yRWFjaCgoZGF0YSxsZW5ndGgpPT57bGVuZ3RoKz00O2ZvcihsZXQgaT0wO2k8ZGF0YS5sZW5ndGg7aSs9bGVuZ3RoKXtsZXQgd29yZD1cIlwiO2ZvcihsZXQgaj0wO2o8bGVuZ3RoO2orKyl7d29yZCs9Z2V0SGFuZ3VsKGNvZGVzLmluZGV4T2YoZGF0YVtpK2pdKSl9d29yZGxpc3QkNS5wdXNoKHdvcmQpfX0pO3dvcmRsaXN0JDUuc29ydCgpO2lmKFdvcmRsaXN0LmNoZWNrKGxhbmcpIT09XCIweGY5ZWRkZWFjZTljNWQzZGE5YzkzY2Y3ZDNjZDM4ZjZhMTNlZDNhZmZiOTMzMjU5YWU4NjU3MTRlOGEzYWU3MWFcIil7d29yZGxpc3QkNT1udWxsO3Rocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBrbyAoS29yZWFuKSBGQUlMRURcIil9fWNsYXNzIExhbmdLbyBleHRlbmRzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJrb1wiKX1nZXRXb3JkKGluZGV4KXtsb2FkV29yZHMkNSh0aGlzKTtyZXR1cm4gd29yZGxpc3QkNVtpbmRleF19Z2V0V29yZEluZGV4KHdvcmQpe2xvYWRXb3JkcyQ1KHRoaXMpO3JldHVybiB3b3JkbGlzdCQ1LmluZGV4T2Yod29yZCl9fWNvbnN0IGxhbmdLbz1uZXcgTGFuZ0tvO1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdLbyk7XCJ1c2Ugc3RyaWN0XCI7Y29uc3Qgd29yZHMkND1cIkFiYWNvQWJiYWdsaW9BYmJpbmF0b0FiZXRlQWJpc3NvQWJvbGlyZUFicmFzaXZvQWJyb2dhdG9BY2NhZGVyZUFjY2Vubm9BY2N1c2F0b0FjZXRvbmVBY2hpbGxlQWNpZG9BY3F1YUFjcmVBY3JpbGljb0Fjcm9iYXRhQWN1dG9BZGFnaW9BZGRlYml0b0FkZG9tZUFkZWd1YXRvQWRlcmlyZUFkaXBlQWRvdHRhcmVBZHVsYXJlQWZmYWJpbGVBZmZldHRvQWZmaXNzb0FmZnJhbnRvQWZvcmlzbWFBZm9zb0FmcmljYW5vQWdhdmVBZ2VudGVBZ2V2b2xlQWdnYW5jaW9BZ2lyZUFnaXRhcmVBZ29uaXNtb0Fncmljb2xvQWdydW1ldG9BZ3V6em9BbGFiYXJkYUFsYXRvQWxiYXRyb0FsYmVyYXRvQWxib0FsYnVtZUFsY2VBbGNvbGljb0FsZXR0b25lQWxmYUFsZ2VicmFBbGlhbnRlQWxpYmlBbGltZW50b0FsbGFnYXRvQWxsZWdyb0FsbGlldm9BbGxvZG9sYUFsbHVzaXZvQWxtZW5vQWxvZ2Vub0FscGFjYUFscGVzdHJlQWx0YWxlbmFBbHRlcm5vQWx0aWNjaW9BbHRyb3ZlQWx1bm5vQWx2ZW9sb0FsemFyZUFtYWxnYW1hQW1hbml0YUFtYXJlbmFBbWJpdG9BbWJyYXRvQW1lYmFBbWVyaWNhQW1ldGlzdGFBbWljb0FtbWFzc29BbW1lbmRhQW1taXJhcmVBbW1vbml0b0Ftb3JlQW1waW9BbXBsaWFyZUFtdWxldG9BbmFjYXJkb0FuYWdyYWZlQW5hbGlzdGFBbmFyY2hpYUFuYXRyYUFuY2FBbmNlbGxhQW5jb3JhQW5kYXJlQW5kcmVhQW5lbGxvQW5nZWxvQW5nb2xhcmVBbmd1c3RvQW5pbWFBbm5lZ2FyZUFubmlkYXRvQW5ub0FubnVuY2lvQW5vbmltb0FudGljaXBvQW56aUFwYXRpY29BcGVydHVyYUFwb2RlQXBwYXJpcmVBcHBldGl0b0FwcG9nZ2lvQXBwcm9kb0FwcHVudG9BcHJpbGVBcmFiaWNhQXJhY2hpZGVBcmFnb3N0YUFyYWxkaWNhQXJhbmNpb0FyYXR1cmFBcmF6em9BcmJpdHJvQXJjaGl2aW9BcmRpdG9BcmVuaWxlQXJnZW50b0FyZ2luZUFyZ3V0b0FyaWFBcm1vbmlhQXJuZXNlQXJyZWRhdG9BcnJpbmdhQXJyb3N0b0Fyc2VuaWNvQXJzb0FydGVmaWNlQXJ6aWxsb0FzY2l1dHRvQXNjb2x0b0FzZXBzaUFzZXR0aWNvQXNmYWx0b0FzaW5vQXNvbGFBc3BpcmF0b0FzcHJvQXNzYWdnaW9Bc3NlQXNzb2x1dG9Bc3N1cmRvQXN0YUFzdGVudXRvQXN0aWNlQXN0cmF0dG9BdGF2aWNvQXRlaXNtb0F0b21pY29BdG9ub0F0dGVzYUF0dGl2YXJlQXR0b3Jub0F0dHJpdG9BdHR1YWxlQXVzaWxpb0F1c3RyaWFBdXRpc3RhQXV0b25vbW9BdXR1bm5vQXZhbnphdG9BdmVyZUF2dmVuaXJlQXZ2aXNvQXZ2b2xnZXJlQXppb25lQXpvdG9BenppbW9Benp1cnJvQmFiZWxlQmFjY2Fub0JhY2lub0JhY29CYWRlc3NhQmFkaWxhdGFCYWduYXRvQmFpdGFCYWxjb25lQmFsZG9CYWxlbmFCYWxsYXRhQmFsemFub0JhbWJpbm9CYW5kaXJlQmFyYW9uZGFCYXJiYXJvQmFyY2FCYXJpdG9ub0Jhcmx1bWVCYXJvY2NvQmFzaWxpY29CYXNzb0JhdG9zdGFCYXR0dXRvQmF1bGVCYXZhQmF2b3NhQmVjY29CZWZmYUJlbGdpb0JlbHZhQmVuZGFCZW5ldm9sZUJlbmlnbm9CZW56aW5hQmVyZUJlcmxpbmFCZXRhQmliaXRhQmljaUJpZG9uZUJpZmlkb0JpZ2FCaWxhbmNpYUJpbWJvQmlub2NvbG9CaW9sb2dvQmlwZWRlQmlwb2xhcmVCaXJiYW50ZUJpcnJhQmlzY290dG9CaXNlc3RvQmlzbm9ubm9CaXNvbnRlQmlzdHVyaUJpenphcnJvQmxhbmRvQmxhdHRhQm9sbGl0b0JvbmlmaWNvQm9yZG9Cb3Njb0JvdGFuaWNvQm90dGlub0JvenpvbG9CcmFjY2lvQnJhZGlwb0JyYW1hQnJhbmNhQnJhdnVyYUJyZXRlbGxhQnJldmV0dG9CcmV6emFCcmlnbGlhQnJpbGxhbnRlQnJpbmRhcmVCcm9jY29sb0Jyb2RvQnJvbnppbmFCcnVsbG9CcnVub0J1YmJvbmVCdWNhQnVkaW5vQnVmZm9uZUJ1aW9CdWxib0J1b25vQnVybG9uZUJ1cnJhc2NhQnVzc29sYUJ1c3RhQ2FkZXR0b0NhZHVjb0NhbGFtYXJvQ2FsY29sb0NhbGVzc2VDYWxpYnJvQ2FsbW9DYWxvcmlhQ2FtYnVzYUNhbWVyYXRhQ2FtaWNpYUNhbW1pbm9DYW1vbGFDYW1wYWxlQ2FuYXBhQ2FuZGVsYUNhbmVDYW5pbm9DYW5vdHRvQ2FudGluYUNhcGFjZUNhcGVsbG9DYXBpdG9sb0NhcG9naXJvQ2FwcGVyb0NhcHJhQ2Fwc3VsYUNhcmFwYWNlQ2FyY2Fzc2FDYXJkb0NhcmlzbWFDYXJvdmFuYUNhcnJldHRvQ2FydG9saW5hQ2FzYWNjaW9DYXNjYXRhQ2FzZXJtYUNhc29DYXNzb25lQ2FzdGVsbG9DYXN1YWxlQ2F0YXN0YUNhdGVuYUNhdHJhbWVDYXV0b0NhdmlsbG9DZWRpYmlsZUNlZHJhdGFDZWZhbG9DZWxlYnJlQ2VsbHVsYXJlQ2VuYUNlbm9uZUNlbnRlc2ltb0NlcmFtaWNhQ2VyY2FyZUNlcnRvQ2VydW1lQ2VydmVsbG9DZXNvaWFDZXNwb0NldG9DaGVsYUNoaWFyb0NoaWNjYUNoaWVkZXJlQ2hpbWVyYUNoaW5hQ2hpcnVyZ29DaGl0YXJyYUNpYW9DaWNsaXNtb0NpZnJhcmVDaWdub0NpbGluZHJvQ2lvdHRvbG9DaXJjYUNpcnJvc2lDaXRyaWNvQ2l0dGFkaW5vQ2l1ZmZvQ2l2ZXR0YUNpdmlsZUNsYXNzaWNvQ2xpbmljYUNsb3JvQ29jY29Db2RhcmRvQ29kaWNlQ29lcmVudGVDb2dub21lQ29sbGFyZUNvbG1hdG9Db2xvcmVDb2xwb3NvQ29sdGl2YXRvQ29semFDb21hQ29tZXRhQ29tbWFuZG9Db21vZG9Db21wdXRlckNvbXVuZUNvbmNpc29Db25kdXJyZUNvbmZlcm1hQ29uZ2VsYXJlQ29uaXVnZUNvbm5lc3NvQ29ub3NjZXJlQ29uc3Vtb0NvbnRpbnVvQ29udmVnbm9Db3BlcnRvQ29waW9uZUNvcHBpYUNvcHJpY2Fwb0NvcmF6emFDb3JkYXRhQ29yaWNhdG9Db3JuaWNlQ29yb2xsYUNvcnBvQ29ycmVkb0NvcnNpYUNvcnRlc2VDb3NtaWNvQ29zdGFudGVDb3R0dXJhQ292YXRvQ3JhdGVyZUNyYXZhdHRhQ3JlYXRvQ3JlZGVyZUNyZW1vc29DcmVzY2l0YUNyZXRhQ3JpY2V0b0NyaW5hbGVDcmlzaUNyaXRpY29Dcm9jZUNyb25hY2FDcm9zdGF0YUNydWNpYWxlQ3J1c2NhQ3VjaXJlQ3VjdWxvQ3VnaW5vQ3VsbGF0b0N1cG9sYUN1cmF0b3JlQ3Vyc29yZUN1cnZvQ3VzY2lub0N1c3RvZGVEYWRvRGFpbm9EYWxtYXRhRGFtZXJpbm9EYW5pZWxhRGFubm9zb0RhbnphcmVEYXRhdG9EYXZhbnRpRGF2dmVyb0RlYnV0dG9EZWNlbm5pb0RlY2lzb0RlY2xpbm9EZWNvbGxvRGVjcmV0b0RlZGljYXRvRGVmaW5pdG9EZWZvcm1lRGVnbm9EZWxlZ2FyZURlbGZpbm9EZWxpcmlvRGVsdGFEZW1lbnphRGVub3RhdG9EZW50cm9EZXBvc2l0b0RlcmFwYXRhRGVyaXZhcmVEZXJvZ2FEZXNjcml0dG9EZXNlcnRvRGVzaWRlcmlvRGVzdW1lcmVEZXRlcnNpdm9EZXZvdG9EaWFtZXRyb0RpY2VtYnJlRGllZHJvRGlmZXNvRGlmZnVzb0RpZ2VyaXJlRGlnaXRhbGVEaWx1dmlvRGluYW1pY29EaW5uYW56aURpcGludG9EaXBsb21hRGlwb2xvRGlyYWRhcmVEaXJlRGlyb3R0b0RpcnVwb0Rpc2FnaW9EaXNjcmV0b0Rpc2ZhcmVEaXNnZWxvRGlzcG9zdG9EaXN0YW56YURpc3VtYW5vRGl0b0RpdmFub0RpdmVsdG9EaXZpZGVyZURpdm9yYXRvRG9ibG9uZURvY2VudGVEb2dhbmFsZURvZ21hRG9sY2VEb21hdG9Eb21lbmljYURvbWluYXJlRG9uZG9sb0Rvbm9Eb3JtaXJlRG90ZURvdHRvcmVEb3Z1dG9Eb3p6aW5hRHJhZ29EcnVpZG9EdWJiaW9EdWJpdGFyZUR1Y2FsZUR1bmFEdW9tb0R1cGxpY2VEdXJhdHVyb0ViYW5vRWNjZXNzb0VjY29FY2xpc3NpRWNvbm9taWFFZGVyYUVkaWNvbGFFZGlsZUVkaXRvcmlhRWR1Y2FyZUVnZW1vbmlhRWdsaUVnb2lzbW9FZ3JlZ2lvRWxhYm9yYXRvRWxhcmdpcmVFbGVnYW50ZUVsZW5jYXRvRWxldHRvRWxldmFyZUVsZmljb0VsaWNhRWxtb0Vsc2FFbHVzb0VtYW5hdG9FbWJsZW1hRW1lc3NvRW1pcm9FbW90aXZvRW1vemlvbmVFbXBpcmljb0VtdWxvRW5kZW1pY29FbmR1cm9FbmVyZ2lhRW5mYXNpRW5vdGVjYUVudHJhcmVFbnppbWFFcGF0aXRlRXBpbG9nb0VwaXNvZGlvRXBvY2FsZUVwcHVyZUVxdWF0b3JlRXJhcmlvRXJiYUVyYm9zb0VyZWRlRXJlbWl0YUVyaWdlcmVFcm1ldGljb0Vyb2VFcm9zaXZvRXJyYW50ZUVzYWdvbm9Fc2FtZUVzYW5pbWVFc2F1ZGlyZUVzY2FFc2VtcGlvRXNlcmNpdG9Fc2liaXRvRXNpZ2VudGVFc2lzdGVyZUVzaXRvRXNvZmFnb0Vzb3J0YXRvRXNvc29Fc3BhbnNvRXNwcmVzc29Fc3NlbnphRXNzb0VzdGVzb0VzdGltYXJlRXN0b25pYUVzdHJvc29Fc3VsdGFyZUV0aWxpY29FdG5pY29FdHJ1c2NvRXR0b0V1Y2xpZGVvRXVyb3BhRXZhc29FdmlkZW56YUV2aXRhdG9Fdm9sdXRvRXZ2aXZhRmFiYnJpY2FGYWNjZW5kYUZhY2hpcm9GYWxjb0ZhbWlnbGlhRmFuYWxlRmFuZmFyYUZhbmdvRmFudGFzbWFGYXJlRmFyZmFsbGFGYXJpbm9zb0Zhcm1hY29GYXNjaWFGYXN0b3NvRmFzdWxsb0ZhdGljYXJlRmF0b0Zhdm9sb3NvRmViYnJlRmVjb2xhRmVkZUZlZ2F0b0ZlbHBhRmVsdHJvRmVtbWluYUZlbmRlcmVGZW5vbWVub0Zlcm1lbnRvRmVycm9GZXJ0aWxlRmVzc3VyYUZlc3Rpdm9GZXR0YUZldWRvRmlhYmFGaWR1Y2lhRmlmYUZpZ3VyYXRvRmlsb0ZpbmFuemFGaW5lc3RyYUZpbmlyZUZpb3JlRmlzY2FsZUZpc2ljb0ZpdW1lRmxhY29uZUZsYW1lbmNvRmxlYm9GbGVtbWFGbG9yaWRvRmx1ZW50ZUZsdW9yb0ZvYmljb0ZvY2FjY2lhRm9jb3NvRm9kZXJhdG9Gb2dsaW9Gb2xhdGFGb2xjbG9yZUZvbGdvcmVGb25kZW50ZUZvbmV0aWNvRm9uaWFGb250YW5hRm9yYml0b0ZvcmNoZXR0YUZvcmVzdGFGb3JtaWNhRm9ybmFpb0Zvcm9Gb3J0ZXp6YUZvcnphcmVGb3NmYXRvRm9zc29GcmFjYXNzb0ZyYW5hRnJhc3Npbm9GcmF0ZWxsb0ZyZWNjZXR0YUZyZW5hdGFGcmVzY29Gcmlnb0Zyb2xsaW5vRnJvbmRlRnJ1Z2FsZUZydXR0YUZ1Y2lsYXRhRnVjc2lhRnVnZ2VudGVGdWxtaW5lRnVsdm9GdW1hbnRlRnVtZXR0b0Z1bW9zb0Z1bmVGdW56aW9uZUZ1b2NvRnVyYm9GdXJnb25lRnVyb3JlRnVzb0Z1dGlsZUdhYmJpYW5vR2FmZmVHYWxhdGVvR2FsbGluYUdhbG9wcG9HYW1iZXJvR2FtbWFHYXJhbnppYUdhcmJvR2Fyb2Zhbm9HYXJ6b25lR2FzZG90dG9HYXNvbGlvR2FzdHJpY29HYXR0b0dhdWRpb0dhemVib0dhenplbGxhR2Vjb0dlbGF0aW5hR2Vsc29HZW1lbGxvR2VtbWF0b0dlbmVHZW5pdG9yZUdlbm5haW9HZW5vdGlwb0dlcmdvR2hlcGFyZG9HaGlhY2Npb0doaXNhR2lhbGxvR2lsZGFHaW5lcHJvR2lvY2FyZUdpb2llbGxvR2lvcm5vR2lvdmVHaXJhdG9HaXJvbmVHaXR0YXRhR2l1ZGl6aW9HaXVyYXRvR2l1c3RvR2xvYnVsb0dsdXRpbmVHbm9tb0dvYmJhR29sZkdvbWl0b0dvbW1vbmVHb25maW9Hb25uYUdvdmVybm9HcmFjaWxlR3JhZG9HcmFmaWNvR3JhbW1vR3JhbmRlR3JhdHRhcmVHcmF2b3NvR3JhemlhR3JlY2FHcmVnZ2VHcmlmb25lR3JpZ2lvR3JpbnphR3JvdHRhR3J1cHBvR3VhZGFnbm9HdWFpb0d1YW50b0d1YXJkYXJlR3Vmb0d1aWRhcmVJYmVybmF0b0ljb25hSWRlbnRpY29JZGlsbGlvSWRvbG9JZHJhSWRyaWNvSWRyb2dlbm9JZ2llbmVJZ25hcm9JZ25vcmF0b0lsYXJlSWxsZXNvSWxsb2dpY29JbGx1ZGVyZUltYmFsbG9JbWJldnV0b0ltYm9jY29JbWJ1dG9JbW1hbmVJbW1lcnNvSW1tb2xhdG9JbXBhY2NvSW1wZXRvSW1waWVnb0ltcG9ydG9JbXByb250YUluYWxhcmVJbmFyY2FyZUluYXR0aXZvSW5jYW50b0luY2VuZGlvSW5jaGlub0luY2lzaXZvSW5jbHVzb0luY29udHJvSW5jcm9jaW9JbmN1Ym9JbmRhZ2luZUluZGlhSW5kb2xlSW5lZGl0b0luZmF0dGlJbmZpbGFyZUluZmxpdHRvSW5nYWdnaW9JbmdlZ25vSW5nbGVzZUluZ29yZG9Jbmdyb3Nzb0lubmVzY29Jbm9kb3JlSW5vbHRyYXJlSW5vbmRhdG9JbnNhbm9JbnNldHRvSW5zaWVtZUluc29ubmlhSW5zdWxpbmFJbnRhc2F0b0ludGVyb0ludG9uYWNvSW50dWl0b0ludW1pZGlyZUludmFsaWRvSW52ZWNlSW52aXRvSXBlcmJvbGVJcG5vdGljb0lwb3Rlc2lJcHBpY2FJcmlkZUlybGFuZGFJcm9uaWNvSXJyaWdhdG9JcnJvcmFyZUlzb2xhdG9Jc290b3BvSXN0ZXJpY29Jc3RpdHV0b0lzdHJpY2VJdGFsaWFJdGVyYXJlTGFiYnJvTGFiaXJpbnRvTGFjY2FMYWNlcmF0b0xhY3JpbWFMYWN1bmFMYWRkb3ZlTGFnb0xhbXBvTGFuY2V0dGFMYW50ZXJuYUxhcmRvc29MYXJnYUxhcmluZ2VMYXN0cmFMYXRlbnphTGF0aW5vTGF0dHVnYUxhdmFnbmFMYXZvcm9MZWdhbGVMZWdnZXJvTGVtYm9MZW50ZXp6YUxlbnphTGVvbmVMZXByZUxlc2l2b0xlc3NhdG9MZXN0b0xldHRlcmFsZUxldmFMZXZpZ2F0b0xpYmVyb0xpZG9MaWV2aXRvTGlsbGFMaW1hdHVyYUxpbWl0YXJlTGltcGlkb0xpbmVhcmVMaW5ndWFMaXF1aWRvTGlyYUxpcmljYUxpc2NhTGl0ZUxpdGlnaW9MaXZyZWFMb2NhbmRhTG9kZUxvZ2ljYUxvbWJhcmVMb25kcmFMb25nZXZvTG9xdWFjZUxvcmVuem9Mb3RvTG90dGVyaWFMdWNlTHVjaWRhdG9MdW1hY2FMdW1pbm9zb0x1bmdvTHVwb0x1cHBvbG9MdXNpbmdhTHVzc29MdXR0b01hY2Ficm9NYWNjaGluYU1hY2Vyb01hY2luYXRvTWFkYW1hTWFnaWNvTWFnbGlhTWFnbmV0ZU1hZ3JvTWFpb2xpY2FNYWxhZmVkZU1hbGdyYWRvTWFsaW50ZXNvTWFsc2Fub01hbHRvTWFsdW1vcmVNYW5hTWFuY2lhTWFuZG9ybGFNYW5naWFyZU1hbmlmZXN0b01hbm5hcm9NYW5vdnJhTWFuc2FyZGFNYW50aWRlTWFudWJyaW9NYXBwYU1hcmF0b25hTWFyY2lyZU1hcmV0dGFNYXJtb01hcnN1cGlvTWFzY2hlcmFNYXNzYWlhTWFzdGlub01hdGVyYXNzb01hdHJpY29sYU1hdHRvbmVNYXR1cm9NYXp1cmNhTWVhbmRyb01lY2Nhbmljb01lY2VuYXRlTWVkZXNpbW9NZWRpdGFyZU1lZ2FNZWxhc3NhTWVsaXNNZWxvZGlhTWVuaW5nZU1lbm9NZW5zb2xhTWVyY3VyaW9NZXJlbmRhTWVybG9NZXNjaGlub01lc2VNZXNzZXJlTWVzdG9sb01ldGFsbG9NZXRvZG9NZXR0ZXJlTWlhZ29sYXJlTWljYU1pY2VsaW9NaWNoZWxlTWljcm9ib01pZG9sbG9NaWVsZU1pZ2xpb3JlTWlsYW5vTWlsaXRlTWltb3NhTWluZXJhbGVNaW5pTWlub3JlTWlyaW5vTWlydGlsbG9NaXNjZWxhTWlzc2l2YU1pc3RvTWlzdXJhcmVNaXRlenphTWl0aWdhcmVNaXRyYU1pdHRlbnRlTW5lbW9uaWNvTW9kZWxsb01vZGlmaWNhTW9kdWxvTW9nYW5vTW9naW9Nb2xlTW9sb3Nzb01vbmFzdGVyb01vbmNvTW9uZGluYU1vbmV0YXJpb01vbmlsZU1vbm90b25vTW9uc29uZU1vbnRhdG9Nb252aXNvTW9yYU1vcmRlcmVNb3JzaWNhdG9Nb3N0cm9Nb3RpdmF0b01vdG9zZWdhTW90dG9Nb3ZlbnphTW92aW1lbnRvTW96em9NdWNjYU11Y29zYU11ZmZhTXVnaGV0dG9NdWduYWlvTXVsYXR0b011bGluZWxsb011bHRpcGxvTXVtbWlhTXVudG9NdW92ZXJlTXVyYWxlTXVzYU11c2NvbG9NdXNpY2FNdXRldm9sZU11dG9OYWJhYmJvTmFmdGFOYW5vbWV0cm9OYXJjaXNvTmFyaWNlTmFycmF0b05hc2NlcmVOYXN0cmFyZU5hdHVyYWxlTmF1dGljYU5hdmlnbGlvTmVidWxvc2FOZWNyb3NpTmVnYXRpdm9OZWdvemlvTmVtbWVub05lb2ZpdGFOZXJldHRvTmVydm9OZXNzdW5vTmV0dHVub05ldXRyYWxlTmV2ZU5ldnJvdGljb05pY2NoaWFOaW5mYU5pdGlkb05vYmlsZU5vY2l2b05vZG9Ob21lTm9taW5hTm9yZGljb05vcm1hbGVOb3J2ZWdlc2VOb3N0cmFub05vdGFyZU5vdGl6aWFOb3R0dXJub05vdmVsbGFOdWNsZW9OdWxsYU51bWVyb051b3ZvTnV0cmlyZU51dm9sYU51emlhbGVPYXNpT2JiZWRpcmVPYmJsaWdvT2JlbGlzY29PYmxpb09ib2xvT2Jzb2xldG9PY2Nhc2lvbmVPY2NoaW9PY2NpZGVudGVPY2NvcnJlcmVPY2N1bHRhcmVPY3JhT2N1bGF0b09kaWVybm9PZG9yYXJlT2ZmZXJ0YU9mZnJpcmVPZmZ1c2NhdG9PZ2dldHRvT2dnaU9nbnVub09sYW5kZXNlT2xmYXR0b09saWF0b09saXZhT2xvZ3JhbW1hT2x0cmVPbWFnZ2lvT21iZWxpY29PbWJyYU9tZWdhT21pc3Npb25lT25kb3NvT25lcmVPbmljZU9ubml2b3JvT25vcmV2b2xlT250YU9wZXJhdG9PcGluaW9uZU9wcG9zdG9PcmFjb2xvT3JhZm9PcmRpbmVPcmVjY2hpbm9PcmVmaWNlT3JmYW5vT3JnYW5pY29PcmlnaW5lT3JpenpvbnRlT3JtYU9ybWVnZ2lvT3JuYXRpdm9Pcm9sb2dpb09ycmVuZG9PcnJpYmlsZU9ydGVuc2lhT3J0aWNhT3J6YXRhT3J6b09zYXJlT3NjdXJhcmVPc21vc2lPc3BlZGFsZU9zcGl0ZU9zc2FPc3NpZGFyZU9zdGFjb2xvT3N0ZU90aXRlT3RyZU90dGFnb25vT3R0aW1vT3R0b2JyZU92YWxlT3Zlc3RPdmlub092aXBhcm9Pdm9jaXRvT3Z1bnF1ZU92dmlhcmVPemlvUGFjY2hldHRvUGFjZVBhY2lmaWNvUGFkZWxsYVBhZHJvbmVQYWVzZVBhZ2FQYWdpbmFQYWxhenppbmFQYWxlc2FyZVBhbGxpZG9QYWxvUGFsdWRlUGFuZG9yb1Bhbm5lbGxvUGFvbG9QYW9uYXp6b1BhcHJpY2FQYXJhYm9sYVBhcmNlbGxhUGFyZXJlUGFyZ29sb1BhcmlQYXJsYXRvUGFyb2xhUGFydGlyZVBhcnZlbnphUGFyemlhbGVQYXNzaXZvUGFzdGljY2FQYXRhY2NhUGF0b2xvZ2lhUGF0dHVtZVBhdm9uZVBlY2NhdG9QZWRhbGFyZVBlZG9uYWxlUGVnZ2lvUGVsb3NvUGVuYXJlUGVuZGljZVBlbmlzb2xhUGVubnV0b1Blbm9tYnJhUGVuc2FyZVBlbnRvbGFQZXBlUGVwaXRhUGVyYmVuZVBlcmNvcnNvUGVyZG9uYXRvUGVyZm9yYXJlUGVyZ2FtZW5hUGVyaW9kb1Blcm1lc3NvUGVybm9QZXJwbGVzc29QZXJzdWFzb1BlcnR1Z2lvUGVydmFzb1Blc2F0b3JlUGVzaXN0YVBlc29QZXN0aWZlcm9QZXRhbG9QZXR0aW5lUGV0dWxhbnRlUGV6em9QaWFjZXJlUGlhbnRhUGlhdHRpbm9QaWNjaW5vUGljb3p6YVBpZWdhUGlldHJhUGlmZmVyb1BpZ2lhbWFQaWdvbGlvUGlncm9QaWxhUGlsaWZlcm9QaWxsb2xhUGlsb3RhUGltcGFudGVQaW5ldGFQaW5uYVBpbm9sb1Bpb2dnaWFQaW9tYm9QaXJhbWlkZVBpcmV0aWNvUGlyaXRlUGlyb2xpc2lQaXRvbmVQaXp6aWNvUGxhY2Vib1BsYW5hcmVQbGFzbWFQbGF0YW5vUGxlbmFyaW9Qb2NoZXp6YVBvZGVyb3NvUG9kaXNtb1BvZXNpYVBvZ2dpYXJlUG9sZW50YVBvbGlnb25vUG9sbGljZVBvbG1vbml0ZVBvbHBldHRhUG9sc29Qb2x0cm9uYVBvbHZlcmVQb21pY2VQb21vZG9yb1BvbnRlUG9wb2xvc29Qb3JmaWRvUG9yb3NvUG9ycG9yYVBvcnJlUG9ydGF0YVBvc2FQb3NpdGl2b1Bvc3Nlc3NvUG9zdHVsYXRvUG90YXNzaW9Qb3RlcmVQcmFuem9QcmFzc2lQcmF0aWNhUHJlY2x1c29QcmVkaWNhUHJlZmlzc29QcmVnaWF0b1ByZWxpZXZvUHJlbWVyZVByZW5vdGFyZVByZXBhcmF0b1ByZXNlbnphUHJldGVzdG9QcmV2YWxzb1ByaW1hUHJpbmNpcGVQcml2YXRvUHJvYmxlbWFQcm9jdXJhUHJvZHVycmVQcm9mdW1vUHJvZ2V0dG9Qcm9sdW5nYVByb21lc3NhUHJvbm9tZVByb3Bvc3RhUHJvcm9nYVByb3Rlc29Qcm92YVBydWRlbnRlUHJ1Z25hUHJ1cml0b1BzaWNoZVB1YmJsaWNvUHVkaWNhUHVnaWxhdG9QdWdub1B1bGNlUHVsaXRvUHVsc2FudGVQdW50YXJlUHVwYXp6b1B1cGlsbGFQdXJvUXVhZHJvUXVhbGNvc2FRdWFzaVF1ZXJlbGFRdW90YVJhY2NvbHRvUmFkZG9wcGlvUmFkaWNhbGVSYWR1bmF0b1JhZmZpY2FSYWdhenpvUmFnaW9uZVJhZ25vUmFtYXJyb1JhbWluZ29SYW1vUmFuZGFnaW9SYW50b2xhcmVSYXBhdG9SYXBpbmFSYXBwcmVzb1Jhc2F0dXJhUmFzY2hpYXRvUmFzZW50ZVJhc3NlZ25hUmFzdHJlbGxvUmF0YVJhdnZlZHV0b1JlYWxlUmVjZXBpcmVSZWNpbnRvUmVjbHV0YVJlY29uZGl0b1JlY3VwZXJvUmVkZGl0b1JlZGltZXJlUmVnYWxhdG9SZWdpc3Ryb1JlZ29sYVJlZ3Jlc3NvUmVsYXppb25lUmVtYXJlUmVtb3RvUmVubmFSZXBsaWNhUmVwcmltZXJlUmVwdXRhcmVSZXNhUmVzaWRlbnRlUmVzcG9uc29SZXN0YXVyb1JldGVSZXRpbmFSZXRvcmljYVJldHRpZmljYVJldm9jYXRvUmlhc3N1bnRvUmliYWRpcmVSaWJlbGxlUmlicmV6em9SaWNhcmljYVJpY2NvUmljZXZlcmVSaWNpY2xhdG9SaWNvcmRvUmljcmVkdXRvUmlkaWNvbG9SaWR1cnJlUmlmYXNhcmVSaWZsZXNzb1JpZm9ybWFSaWZ1Z2lvUmlnYXJlUmlnZXR0YXRvUmlnaGVsbG9SaWxhc3NhdG9SaWxldmF0b1JpbWFuZXJlUmltYmFsem9SaW1lZGlvUmltb3JjaGlvUmluYXNjaXRhUmluY2Fyb1JpbmZvcnpvUmlubm92b1Jpbm9tYXRvUmluc2F2aXRvUmludG9jY29SaW51bmNpYVJpbnZlbmlyZVJpcGFyYXRvUmlwZXR1dG9SaXBpZW5vUmlwb3J0YXJlUmlwcmVzYVJpcHVsaXJlUmlzYXRhUmlzY2hpb1Jpc2VydmFSaXNpYmlsZVJpc29SaXNwZXR0b1Jpc3Rvcm9SaXN1bHRhdG9SaXN2b2x0b1JpdGFyZG9SaXRlZ25vUml0bWljb1JpdHJvdm9SaXVuaW9uZVJpdmFSaXZlcnNvUml2aW5jaXRhUml2b2x0b1Jpem9tYVJvYmFSb2JvdGljb1JvYnVzdG9Sb2NjaWFSb2NvUm9kYWdnaW9Sb2RlcmVSb2RpdG9yZVJvZ2l0b1JvbGxpb1JvbWFudGljb1JvbXBlcmVSb256aW9Sb3NvbGFyZVJvc3BvUm90YW50ZVJvdG9uZG9Sb3R1bGFSb3Zlc2Npb1J1Yml6em9SdWJyaWNhUnVnYVJ1bGxpbm9SdW1pbmVSdW1vcm9zb1J1b2xvUnVwZVJ1c3NhcmVSdXN0aWNvU2FiYXRvU2FiYmlhcmVTYWJvdGF0b1NhZ29tYVNhbGFzc29TYWxkYXR1cmFTYWxnZW1tYVNhbGl2YXJlU2FsbW9uZVNhbG9uZVNhbHRhcmVTYWx1dG9TYWx2b1NhcGVyZVNhcGlkb1NhcG9yaXRvU2FyYWNlbm9TYXJjYXNtb1NhcnRvU2Fzc29zb1NhdGVsbGl0ZVNhdGlyYVNhdG9sbG9TYXR1cm5vU2F2YW5hU2F2aW9TYXppYXRvU2JhZGlnbGlvU2JhbHpvU2JhbmNhdG9TYmFycmFTYmF0dGVyZVNiYXZhcmVTYmVuZGFyZVNiaXJjaWFyZVNibG9jY2F0b1Nib2NjaWF0b1NicmluYXJlU2JydWZmb25lU2J1ZmZhcmVTY2Ficm9zb1NjYWRlbnphU2NhbGFTY2FtYmlhcmVTY2FuZGFsb1NjYXBvbGFTY2Fyc29TY2F0ZW5hcmVTY2F2YXRvU2NlbHRvU2Nlbmljb1NjZXR0cm9TY2hlZGFTY2hpZW5hU2NpYXJwYVNjaWVuemFTY2luZGVyZVNjaXBwb1NjaXJvcHBvU2Npdm9sb1NjbGVyYXJlU2NvZGVsbGFTY29scGl0b1Njb21wYXJ0b1Njb25mb3J0b1Njb3ByaXJlU2NvcnRhU2Nvc3NvbmVTY296emVzZVNjcmliYVNjcm9sbGFyZVNjcnV0aW5pb1NjdWRlcmlhU2N1bHRvcmVTY3VvbGFTY3Vyb1NjdXNhcmVTZGViaXRhcmVTZG9nYW5hcmVTZWNjYXR1cmFTZWNvbmRvU2VkYW5vU2VnZ2lvbGFTZWduYWxhdG9TZWdyZWdhdG9TZWd1aXRvU2VsY2lhdG9TZWxldHRpdm9TZWxsYVNlbHZhZ2dpb1NlbWFmb3JvU2VtYnJhcmVTZW1lU2VtaW5hdG9TZW1wcmVTZW5zb1NlbnRpcmVTZXBvbHRvU2VxdWVuemFTZXJhdGFTZXJiYXRvU2VyZW5vU2VyaW9TZXJwZW50ZVNlcnJhZ2xpb1NlcnZpcmVTZXN0aW5hU2V0b2xhU2V0dGltYW5hU2ZhY2Vsb1NmYWxkYXJlU2ZhbWF0b1NmYXJ6b3NvU2ZhdGljYXRvU2ZlcmFTZmlkYVNmaWxhdG9TZmluZ2VTZm9jYXRvU2ZvZGVyYXJlU2ZvZ29TZm9sdGlyZVNmb3J6YXRvU2ZyYXR0b1NmcnV0dGF0b1NmdWdnaXRvU2Z1bWFyZVNmdXNvU2dhYmVsbG9TZ2FyYmF0b1Nnb25maWFyZVNnb3JiaW9TZ3Jhc3NhdG9TZ3VhcmRvU2liaWxvU2ljY29tZVNpZXJyYVNpZ2xhU2lnbm9yZVNpbGVuemlvU2lsbGFiYVNpbWJvbG9TaW1wYXRpY29TaW11bGF0b1NpbmZvbmlhU2luZ29sb1NpbmlzdHJvU2lub1NpbnRlc2lTaW51c29pZGVTaXBhcmlvU2lzbWFTaXN0b2xlU2l0dWF0b1NsaXR0YVNsb2dhdHVyYVNsb3Zlbm9TbWFycml0b1NtZW1vcmF0b1NtZW50aXRvU21lcmFsZG9TbWlsem9TbW9udGFyZVNtb3R0YXRvU211c3NhdG9TbmVsbGlyZVNuZXJ2YXRvU25vZG9Tb2JiYWx6b1NvYnJpb1NvY2NvcnNvU29jaWFsZVNvZGFsZVNvZmZpdHRvU29nbm9Tb2xkYXRvU29sZW5uZVNvbGlkb1NvbGxhenpvU29sb1NvbHViaWxlU29sdmVudGVTb21hdGljb1NvbW1hU29uZGFTb25ldHRvU29ubmlmZXJvU29waXJlU29wcGVzb1NvcHJhU29yZ2VyZVNvcnBhc3NvU29ycmlzb1NvcnNvU29ydGVnZ2lvU29ydm9sYXRvU29zcGlyb1Nvc3RhU290dGlsZVNwYWRhU3BhbGxhU3BhcmdlcmVTcGF0b2xhU3BhdmVudG9TcGF6em9sYVNwZWNpZVNwZWRpcmVTcGVnbmVyZVNwZWxhdHVyYVNwZXJhbnphU3Blc3NvcmVTcGV0dHJhbGVTcGV6emF0b1NwaWFTcGlnb2xvc29TcGlsbGF0b1NwaW5vc29TcGlyYWxlU3BsZW5kaWRvU3BvcnRpdm9TcG9zb1NwcmFuZ2FTcHJlY2FyZVNwcm9uYXRvU3BydXp6b1NwdW50aW5vU3F1aWxsb1NyYWRpY2FyZVNyb3RvbGF0b1N0YWJpbGVTdGFjY29TdGFmZmFTdGFnbmFyZVN0YW1wYXRvU3RhbnRpb1N0YXJudXRvU3Rhc2VyYVN0YXR1dG9TdGVsb1N0ZXBwYVN0ZXJ6b1N0aWxldHRvU3RpbWFTdGlycGVTdGl2YWxlU3Rpenpvc29TdG9uYXRvU3Rvcmljb1N0cmFwcG9TdHJlZ2F0b1N0cmlkdWxvU3Ryb3p6YXJlU3RydXR0b1N0dWNjYXJlU3R1Zm9TdHVwZW5kb1N1YmVudHJvU3VjY29zb1N1ZG9yZVN1Z2dlcml0b1N1Z29TdWx0YW5vU3VvbmFyZVN1cGVyYm9TdXBwb3J0b1N1cmdlbGF0b1N1cnJvZ2F0b1N1c3N1cnJvU3V0dXJhU3ZhZ2FyZVN2ZWRlc2VTdmVnbGlvU3ZlbGFyZVN2ZW51dG9TdmV6aWFTdmlsdXBwb1N2aXN0YVN2aXp6ZXJhU3ZvbHRhU3Z1b3RhcmVUYWJhY2NvVGFidWxhdG9UYWNjaWFyZVRhY2l0dXJub1RhbGVUYWxpc21hbm9UYW1wb25lVGFubmlub1RhcmFUYXJkaXZvVGFyZ2F0b1RhcmlmZmFUYXJwYXJlVGFydGFydWdhVGFzdG9UYXR0aWNvVGF2ZXJuYVRhdm9sYXRhVGF6emFUZWNhVGVjbmljb1RlbGVmb25vVGVtZXJhcmlvVGVtcG9UZW11dG9UZW5kb25lVGVuZXJvVGVuc2lvbmVUZW50YWNvbG9UZW9yZW1hVGVybWVUZXJyYXp6b1RlcnpldHRvVGVzaVRlc3NlcmF0b1Rlc3RhdG9UZXRyb1RldHRvaWFUaWZhcmVUaWdlbGxhVGltYnJvVGludG9UaXBpY29UaXBvZ3JhZm9UaXJhZ2dpb1Rpcm9UaXRhbmlvVGl0b2xvVGl0dWJhbnRlVGl6aW9UaXp6b25lVG9jY2FyZVRvbGxlcmFyZVRvbHRvVG9tYm9sYVRvbW9Ub25mb1RvbnNpbGxhVG9wYXppb1RvcG9sb2dpYVRvcHBhVG9yYmFUb3JuYXJlVG9ycm9uZVRvcnRvcmFUb3NjYW5vVG9zc2lyZVRvc3RhdHVyYVRvdGFub1RyYWJvY2NvVHJhY2hlYVRyYWZpbGFUcmFnZWRpYVRyYWxjaW9UcmFtb250b1RyYW5zaXRvVHJhcGFub1RyYXJyZVRyYXNsb2NvVHJhdHRhdG9UcmF2ZVRyZWNjaWFUcmVtb2xpb1RyZXNwb2xvVHJpYnV0b1RyaWNoZWNvVHJpZm9nbGlvVHJpbGxvVHJpbmNlYVRyaW9UcmlzdGV6emFUcml0dXJhdG9Ucml2ZWxsYVRyb21iYVRyb25vVHJvcHBvVHJvdHRvbGFUcm92YXJlVHJ1Y2NhdG9UdWJhdHVyYVR1ZmZhdG9UdWxpcGFub1R1bXVsdG9UdW5pc2lhVHVyYmFyZVR1cmNoaW5vVHV0YVR1dGVsYVViaWNhdG9VY2NlbGxvVWNjaXNvcmVVZGlyZVVkaXRpdm9VZmZhVWZmaWNpb1VndWFsZVVsaXNzZVVsdGltYXRvVW1hbm9VbWlsZVVtb3Jpc21vVW5jaW5ldHRvVW5nZXJlVW5naGVyZXNlVW5pY29ybm9VbmlmaWNhdG9Vbmlzb25vVW5pdGFyaW9VbnRlVW92b1VwdXBhVXJhZ2Fub1VyZ2VuemFVcmxvVXNhbnphVXNhdG9Vc2NpdG9Vc2lnbm9sb1VzdXJhaW9VdGVuc2lsZVV0aWxpenpvVXRvcGlhVmFjYW50ZVZhY2NpbmF0b1ZhZ2Fib25kb1ZhZ2xpYXRvVmFsYW5nYVZhbGdvVmFsaWNvVmFsbGV0dGFWYWxvcm9zb1ZhbHV0YXJlVmFsdm9sYVZhbXBhdGFWYW5nYXJlVmFuaXRvc29WYW5vVmFudGFnZ2lvVmFudmVyYVZhcG9yZVZhcmFub1ZhcmNhdG9WYXJpYW50ZVZhc2NhVmVkZXR0YVZlZG92YVZlZHV0b1ZlZ2V0YWxlVmVpY29sb1ZlbGNyb1ZlbGluYVZlbGx1dG9WZWxvY2VWZW5hdG9WZW5kZW1taWFWZW50b1ZlcmFjZVZlcmJhbGVWZXJnb2duYVZlcmlmaWNhVmVyb1ZlcnJ1Y2FWZXJ0aWNhbGVWZXNjaWNhVmVzc2lsbG9WZXN0YWxlVmV0ZXJhbm9WZXRyaW5hVmV0dXN0b1ZpYW5kYW50ZVZpYnJhbnRlVmljZW5kYVZpY2hpbmdvVmljaW5hbnphVmlkaW1hcmVWaWdpbGlhVmlnbmV0b1ZpZ29yZVZpbGVWaWxsYW5vVmltaW5pVmluY2l0b3JlVmlvbGFWaXBlcmFWaXJnb2xhVmlyb2xvZ29WaXJ1bGVudG9WaXNjb3NvVmlzaW9uZVZpc3BvVmlzc3V0b1Zpc3VyYVZpdGFWaXRlbGxvVml0dGltYVZpdmFuZGFWaXZpZG9WaXppYXJlVm9jZVZvZ2FWb2xhdGlsZVZvbGVyZVZvbHBlVm9yYWdpbmVWdWxjYW5vWmFtcG9nbmFaYW5uYVphcHBhdG9aYXR0ZXJhWmF2b3JyYVplZmlyb1plbGFudGVaZWxvWmVuemVyb1plcmJpbm9aaWJldHRvWmluY29aaXJjb25lWml0dG9ab2xsYVpvdGljb1p1Y2NoZXJvWnVmb2xvWnVsdVp1cHBhXCI7bGV0IHdvcmRsaXN0JDY9bnVsbDtmdW5jdGlvbiBsb2FkV29yZHMkNihsYW5nKXtpZih3b3JkbGlzdCQ2IT1udWxsKXtyZXR1cm59d29yZGxpc3QkNj13b3JkcyQ0LnJlcGxhY2UoLyhbQS1aXSkvZyxcIiAkMVwiKS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygxKS5zcGxpdChcIiBcIik7aWYoV29yZGxpc3QuY2hlY2sobGFuZykhPT1cIjB4NWMxMzYyZDg4ZmQ0Y2Y2MTRhOTZmMzIzNDk0MWQyOWY3ZDM3YzA4YzUyOTJmZGUwM2JmNjJjMmRiNmZmNzYyMFwiKXt3b3JkbGlzdCQ2PW51bGw7dGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGl0IChJdGFsaWFuKSBGQUlMRURcIil9fWNsYXNzIExhbmdJdCBleHRlbmRzIFdvcmRsaXN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJpdFwiKX1nZXRXb3JkKGluZGV4KXtsb2FkV29yZHMkNih0aGlzKTtyZXR1cm4gd29yZGxpc3QkNltpbmRleF19Z2V0V29yZEluZGV4KHdvcmQpe2xvYWRXb3JkcyQ2KHRoaXMpO3JldHVybiB3b3JkbGlzdCQ2LmluZGV4T2Yod29yZCl9fWNvbnN0IGxhbmdJdD1uZXcgTGFuZ0l0O1dvcmRsaXN0LnJlZ2lzdGVyKGxhbmdJdCk7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgZGF0YSQyPVwifWFFIzRBPVl2JmNvIzROIzZHPWNKJlNNIzY2fC9aIzR0JmtufjQ2IzRLfjRxJWI5PUlSIzdsLG1CIzdXX1gyKmRsfVVvfjdzfVVmJkl3IzljJmN3fjZPJkg2Jnd4JklHJXY1PUlRfjhhJlB2IzQ3JFBSJjUwJUtvJlFNJjNsIzVmLEQ5IzRMfC9IJnRRO3YwfjZuXW5OPGRpLEFNPVc1JVFPJmthJnVhLGhNXnRtPXpWPUpBPXdSJitYXTdQJk5CIzRKIzVMfC9iW2RBfXRKPERvJjZtJnUyW1UxJktiLkhNJm1DPXcwJk1XPHJZLEhxIzZNfVFHLDEzJndQfUpwXU93JXVlJktnPEhQPEQ5fjRrfjlUJkkyX2M2JDlUIzkvW0M1fjdPfjRhPWNzJk83PUtLPUFuJmw5JDZVJDhBJnVEJlFJfC9ZJmJnfVV4JkYyIzZifUUyJkpOJmtXJmtwPVUvJmJiPVhsPENqfWsrfjVKIzZMJjV6JjlpfWI0JkZvLGhvKFgwX2czfjRPJEZ6JlFFPEhOPVd3XTYvJUdGLVZ3PXRqJi9EJlBOIzlnPVlPfWNMJk9mJlBJfjVJJklwPXZVPUlXIzlHOzBvLXdVfXNzJlFSPEJUJlI5PXRrJFBZX2RoJlBxLXloXTdULG5qLlh1PUVQJjc2PWNJJkZzKlhnfXo3JEdiJitJPURGLEFGPWNBfXJMIzdqPUR6JjN5PEFhJDUyPVBRfWIwKGlZJEZhfW9MJnhWIzZVPWVjPVdaLHhoJVJZPGRwIzlOJkZsJjQ0PVdIKkE3PXNoJlRCJjhQPTA3O3UrJlBLfXVofUo1IzcyKVYvPXhDLEFCJGswJmY2OzFFfCs1PTFCLDN2XTZuJndSJWIrJnh4XTdmPU9sfWZsOytEXndHXTdFO25CO3VoXklyJmw1PUpMLG5TPWNmPWc1O3U2fC9RJEdjPU1IJUhnIzVkJU02Xjg2PVUrJEd6LGwvLGlyXjV5JkJhJi9GLUlZJkZJJmJlJUlaIzc3JlBXX051JGtFKFlmJk5YXTdaLEp5JkZKKFhvJk56Iy9kPXk3Jk1YPEFnfVorO25FXUR0KGlHIzREPTEzJlBqfjRjJXY4JlpvJU9MJi9YIzRXPEhSJmllfjZKXzFPKFkyPXk1PUFkKmN2X2VCIzZrJlBYOkJVIzdBO3VrJkZ0JkZ4X2REPVUyO3ZCPVU1PTRGfStPJkdOLkhIOjlzPWIwJU5WKGpPJklIPUpUfVo5PVZaPEFmLEt4XjRtJnVKJWM2LDZyOzltIytMfWNmJUtoJkYzfjRIPXZQfWJ1LEh6fCsrLDF3XW52fWs2O3V1JGp3KktsKldYJnVNW3g3JkZyW203JE5PJlFOXWh1PUpOfW5SXjhnIy9oKHBzfEtDO3ZkfXh6PVYwfXA2JkZEJEcxIzdLPGJHXzRwfjhnJmNmO3U0PXRsfStrJTUvfWZ6O3V3PGNBPXUxfWdVfVZNPUxKPWVYJitMJlByIzRVfXAyOm5DLDJLXTdIOmpGJjl4fXVYIzlPPU1CPGZ6fjhYfjVtJjREJmtOJnU1JUUvKGg3KFpGJlZHPGRlKHFNfC9lLVd0PTN4KGErLC9SXWYvJk5EJFJvJm5VfTBnPUtBJWtIJk5LJEtlPGRTfWNCJklYfjVnJFROXTZtPVV2LElzJlB5PUVmJUt6IysvJWJpJitBPEY0JE9HJjRDJkZMIzlWPFprPTJJX2VFJjZjXW53JmtxJEhHfXkrJkE4JFAzfU9IPVhQXTcwJUlTKEFKX2dIJUdaJnRZJkFaPXZifjZ5Ji9yPVZJPVd2PFppPWZsPXhmJmVMfWM4fU9MPU1KPWc4JEY3PVlUfTl1PTArXnhDfUpIJm5MXk4wfjRUXUsyLEN5JU9DIzZzO3ZHKEFDXnhlXmNHJk1GfUJyIzlQO3dELTdoJE8vJnhBfUZuXlBDXTZpXTdHJjhWJFFzO3ZsKFRCfjczfjRsPG1XJjZWPTJ5JnVZJiszKWFQfVhGO0xQJmt4JHdVPXQ3O3V5PEZOJmx6KTdFPU9vKlkrO3dJfTlxfWxlO0o2JlJpJjR0JlFyIzhCPWNiJnZHPUo1fFFsKGg1PFl5fjQrfVFELEx4PXduJUsvJlJLPWRPJlB3LFE5PWNvJTR1Ozl1fWcwQDZhXjRJJWIwPXpvfC9jJnRYPWRRPU9TIytiPXl6X0FCJndCJlBtPVc5JEhQX2dSPTYyPUFPPXRpPWhJLG9BJmpyJmRIPXRtJmI2JFAyKHg4PXppO25HfjdGOzA1XTBuW0l4JjNtfXJnPVhwPWNkJnV6XTd0Ozk3PWNOO3ZWPGpmJkZGJkYxPTZRJklrKktrJlA0LDJ6PWZRXTdEJjN1LEgwPWQvfVV3PFpOPDdSfUt2OzBmJEg3LE1EXTduJEYwIzg4fjlaJWRhPWJ5OytUIy91PVZGJmZPJmtyXmtmPEFCXXNVLEk1JE5nJlB6OzBpJlFEJnZNPVlsOkJNO25KX3hKXVU3JktmJjMwLDNmfFo5KmRDKWplX2pBJlE0JktwJE5IKFl6IzZTJklkJUliPUtYLEFEPUtWJWRQfXRXJlBrXitFX05pPWNxLDNSfVZaKFNpPWIrfXJ2OzBqfXJaXXVBLC93KFN4Jkp2JHc5JjRkJndFLE5KJEd5PUovXUxzIzdrPFpRPFkvJnVqXU92JFBNO3YzLDJGJit1OnVwPU9uJjNlLEp2OzkwPUorJlFtXTZxfWJLIytkfjhZKGgyXWhBOzk5JkFTPUkvfXFCJmRRfXlKLVZNfVZsJnVpLGlCJkczfERjXTdkPWVRJWRYJUpDXzFMfjRkXk5QO3ZKJi8xKVpJIzdOXTlYW2JRJlBMPTBMKFVaLExtJmtjJklSfW43KGlSPEFRPGRnPTMzPXZOfWZ0fWF1XTdJLEJhPXg5PWRSfjZSJlRxPVhpLDNkJE5yJkJjfURJJmt1JnZmXURuLC9GJmlELExsJk53PTB5Jkk3PUxzPS9BJnRVPVFlfVVhJnVrJitGPWc0PWdoPVZqIysxJlFufVV5KjQ0IzVGLFBjJlJ6KlhuPW9oPTVXOzBuX05mKGlFPFk3PXZyPVp1XW96IzVaJW1JPWtOPUJ2X0pwKFQyO3Z0X01sPEZTJnVJPUwvJjZQXTY0JE03fTg2PGJvJVFYKFNJJUlZJlZLPUFsJlV4O3Z2O3V0KkUvJXVoPFpFfE8zLE0yKHljXXl1PVdrJnRwOkV4fWhyLENsJldFKStaPThVfUkyXzRRLGhBX3NpPWl3PU9NPXRNPXlaJUlhPVU3O3dUfWIrO3VvPVphfXlTITV4fUhEfWZiIzVPX2RBO052JXVCKHlCOzAxKFNmfUZrO3Y3fVB0Izh2PG1aIzdMLC9yJlBsfjR3JmY1PVBoJEZ3X0xGJjhtLGJMPXlKJkJIfXAvKkpufXRVfjVRO3dCKGg2XURmXThwXitCO0U0JldjPWQrO0VhJmJ3JDhDJkZOLERNPVlmfW1QfjV3PWZUIzZWPW1DPUZpPUFWfWpCJkFOfWxXfWFIIy9EKWRaO2hsO3ZFfS83LENKOzMxJnc4LGhqJXU5X0pzPWpKJjRNfjhrPVROJmVDfW5MJnVjLXdpJmxYfWRqPU12PWUyIzZ1PWNyJHVxJDZHXThXfUpiOm5tPVlnPGIzKFVBO3ZYJjZuJnhGPUtULGpDLERlJlI4Jm9ZPVp2Jm9CXTcvPVoyJk9hfWJmLGhoKDRoXnRaJjcyJk54O0QyJnhMfjVofjQwKVpHKWgrPU9KJlJBXUJ2JHlCPU9xPWRmLEFRJUpufU9KOzExLDN6JlRsJnRqO3YrXkh2LERoKGlkPXMrXTdOJk4zKTlRfjhmLFM0PXVXPXc0JnVYLExYJjNkXUNKJnlwJjh4PGIyX2RvJmxQPXkvPGN5X2RHPU9pPTdSKFZIKGx0XzFULElxX0FBOzEyXjZUJWs2IzhLW0Ixe29PPEFVW0J0OzFiJDlTJlBzPDhUPVN0e2JZLGpCKFpwJjYzJlV2JDlWLFBNXTZ2JkFmfXpXW2JXX29xfXNtfW5CJktxJmdDJmZmX2VxXzJtJjVGJlRJfXJmfUdmO1pyX3o5O0VSJmprfWl6X3NuPEJOfituJnZvPVZpJTk3fFpSPVdjLFdFJjZ0XTZ6JTg1KGx5Izg0PUtZKTZtXzUvPWFYLE4zfVRtJmhlJjZLXXRSX0IyLUkzO3UvJmhVJmxIPEFQPWlCJklBPVhMOy81Jk5oPXd2PEJIIzc5PXZTPXpsPEFBPTBYX1JHfUJ3JjlwJE5XLEFYJmtQX0xwJi9aKFRjXU11fWhzIzZJfTVCJmNJPGJxJkg5IzZtPUs5fXZIKFkxKFkwIzRCJnc2LC85JmdHPGJFLC9PPXpifUk0X2w4PEIvO3dMJVFvPEhPW01xPVhYfTB2JkJQJkY0KG1HfTBpfW5tLEVDPTl1e0kzLHhHJi85PUpZKkRLJmhSKUJYPUVJPWN4PWIvezZrfXlYJUErJndhfVhiPWxhO3dpXmxMOzB0fWpvJlFiPXhnPVhCfWlPPHFve2JSPU5WJjhmPWEwJkp5OzB2PXVLKUhLO3ZOIzZoJmpCKGgvJXVkJk5JJXdZLlg3PVB0fUN1LXVMJkdzX2hsJW1ILHRtXTc4PUxiXlEwIzdZPTF1PEJ0JitRPUNvX1JILHczOzFlfXV4PGFVO3VpfVUzJlE1JWJ0XTYzJlVRfDBsJnVMfU83JjNvLEFWJmRtfE5qKFh0KjUrKFV1JkhoKHA3KFVGPVZSPUJwXkpsJkhkW2l4KTkvPUlxXUM4PDY3XTY2fW1CJTZmfWJifUpJXThUJEhBfWRiPVlNJnBhPTJKfXRTJlkwPVBTJnk0PWNYJDZFLGhYLFhQJm5SOzA0LEZRJmwwJlZtX0R2IzVZfjhaPUJpJU1BXTZ4PUpPOitwLEF6JjlxLEhqfjYvfVNEPUsxOkVKfW5BO1FvIy9FXTlSLEllJjZYJVczXTYxJnY0PXhYX01DPTBxOzA2KFhxPWZzfUlHfUR2PTBsfW83JGlaOzl2JkxIJkRQLTdhJk9ZLFNaLEt6LEN2JmRoPWZ4fE5oLEYvfjdxPVhGJncrOzluJkd3OzBofVo3PDdPJkpLKFM3JkxTPEFEPGFjPXdvPER0Jnp3JTRCPTR2IzhQOzlvfjZwKnZWPVRtLE9yJkk2PTFxfW5ZPVAwPWdxJkJsJlV1LENoJXlifVVZPXpofWRofXJsKFQ0X3hrKFlBIzhSKnhILElOfUpuXTdWfUM0JlR5fWozXTdwPWNMPTNoJndXJVF2PFozPWYwJlJJJitTKGljX3pxfW9OJi9ZPXoxO1RkPUxXPTBlPU9JKFZjLCtiXmp1KFVMOzByOlphJTh2PVJwPXp3JjU4JjczJndLfXFYXTZ5JjhFKWEyfVdSPXdQXnVyJm5RPGNIfVJlPUFxJndrfVEwJitxPVBQLEdjfC9kXms1LEZ3XThZfVBnXXAzPWp1PWVkfXI1X3lmJkNzXTd6JC9HPENtJkpwJjU0XzFHX2dQX0xsfUpaOzB1XWs4XzdrKFNnXTY1ezlpPUxOJlN4JldLLGlXJmZEJkxrezlhfUVtLTljIzhOJmlvPXN5XThkJm5UJklLKGx4IzcvJGxXKFRkPHM4fjQ5LDNvPDdZPU1XKFQrX0pyJldkLGlMfUN0PXhoJjVWO3Y0JjhuJUt4PWlGJmwyXzBCe0IrLElmKEowLEx2O3U4PUt4LXZCPUhDJnZTPVo2JmZVJnZFXnhLOzNEPTRoPU1SIzQ1Okp3OzBkfWl3PUxVfUk1PUkwXWdCKmltLEs5fUdVLDFrXzRVJlR0PVZzKGlYJmxVKFRGIzd5LFpPfW9BJm01IzVQfVBOfVV6PWhNPEIxJkZCPGFHLGU2fjdUPHRQKFVRX1pUPXd1JkY4KWFRXWlOLDFyX0xvJi9nOkNEfTg0e0oxX0tpJk5hJjNuJGp6JkZFPWRjO3V2O3ZhfWlufWxsPWZ2KGgxJjNofWZwPUN5fUJNKCtFfjhtfWxvJXY3PWhDKFQ2JGNqPUJRPUJ3KERSLDJqPUtzLE5TfEYrOzAwPWZVPTcwfU1iKFlVOytHJm03JmhyPVNrJUNvXXQrKFg1X0p3fTByfWdDKEFTLUlQJlFLPFoyIzhRJFdDXVdYfVQyJnBHX0thLEhDPVI0Ji9OO1orO2NoKEM3LEQ0JDNwX01rJkIyJDhEPW45JUt5IzV6KENUJlFKIzdCXURDXWdXfW5mfjVNO0l3IzgwfVRjXzFGIzRaLWFDfUhsPXBoPWZ6LC8zPWFXfUpNfW5uO0RHO3ZtfXduLDRQfVQzO3d4JlJHJHUrfXpLPTBiOytKX0Vre3JlPGFaPUFTfXlZIzVEXTdxLENwfXhOPVZQKjJDfUdafWFHfittX0NzPU9ZIzZyXTZnPEdTfUxDKFVCPTNBPUJvfUp5PGM0fUlzOzFQPEFHfU9wPFoxfWxkfW5TPTFaLHlNJjk1Jjk4PUNKKDR0OjJMJEhrPVpvfVZjOytJfW5wJk4xfTl5PWl2fUNPKjdwPWpMKXB4XXRiXnpoJkdTJlZsJXYvO3ZSPTE0PXpKJjQ5fC9mXWhGfVdHOzAzPThQfW8vJkdnJnJwO0RCLEt2fUppJlBiO2FBXmxsKDRqJXl0fStLJEh0IzR5JmhZXTdZPEYxLGVOfWJHKFVoJTZaXXQ1JUc3OytGX1JFO2l0fXRMPUxTJkRhPVh4KFMrKDRmPThHPXlJfWNKfVdQPTM3PWpTfXBYfWhkKWZwPEE4PUp0fitvJEhKPU02fWlYPWc5fUNTPWR2PUNqKG1QJUtkLHhxfCs5JkxEKDQvPVhtJlFQPUxjfUxYJmZMOytLPU9wKGx1PVFzLnFDOitlJkwrPUpqIzh3O1NMXTdTKGIrIzRJPWMxJm5HX0xmJnVIOytSKVpWPGJWJUIvLFRFJjBIJkpxJkFoJU9GJlNzKHAyLFd2JkkzPVdsfVZxOzFMJmxKIzliXzFIPThyPWI4PUpIKFNaPWhEPUoyIzdVLC9VIy9YfjZQLEZVPGVMPWp4LG1HPWhHPUNFJlBVPVNlKHFYJkxZPVg2PXk0JnRrJlFRJnRmPTRnJnhJfVcrJm1aPURjIzd3fUxnO0RBO3dRX0tiKGNKPWhSJXlYJlliLGh3e2JYXzRYO0VQOzFXXzJNfVVjPWI1KFlGLENNJlRwXk9Ke0REXTZzPXZGPVlvfjhxfVhIfUZ1JVA1KFNKPVF0O01PXXM4PEYzJkIzJjhUKFVsLUJTKmR3JmRSPDg3fS84XTYyJFBaXUx4PEF1fTlRXTdjPWphPUtSLEdvLFVzJnY2KHFrfXBHJkcyPWV2XkdNJXc0Jkg0XTdGJmR2XUo2fUV3Ojl3PXNqLVpMfVltJCtoKFV0KFVtfjRuPVhzKFU3JWVFPVFjX0pSPENBIzZ0PEZ2fC9JLElTLEVHPEYyKFh5JC9uPEZhKGg5fSs5XzJvJk40IzdYPFpxfCtmX0RwPWR0Jm5hLENhPU5KKWpZPThDPVlHPXM2JlErPERPfUQzPXhCJlIxKGx3O1FuPGJGKEN1fC9CfUhWPVNTJm43LDEwJnUwXURtJUE2XjRRPVdSKFREPVhvPEdILFJqKGw4KWJQJm4vPUxNJkNGLEY1Jm1sPVBKOzBrPUxHPXRxLFJoLEQ2QDRpPTFwJis5PVlDJWVyX01oO25JOzBxPUZ3XTgwPXhxPUZNJEd2O3Y2Jm5jO3dLJUgyJktqO3ZzLEFBPVlQLDY2fWJJKHFSfjVVPTZxfjRiJE5pPUs1LlgzJFNvJkl1KHArXThHPUNmPVJZKFRTX08zKGlIJjU3PWZFPURnX0RvIzl6IzdIO0ZLe3FkXzJrJUpSfWVuJmdoX3o4O1J4fTlwPGNOX05lLERPO0xOXzdvfi9wPU5GPTVZfWdOPGNlPEMxLFFFXVd2PTN1PEJDfUdLXXlxfURZJnUvX2hqPUlJKHB6JnJDLGpWJitafXV0PU5RO0NnLVNSX1pTLCtvPXUvO095X1JLX1FGKEZ4JnhQfVdyJlRBLFVoJmcxPXlye2F4W1ZGJFBnKFlCO094PVZ5OytXKFNwfVhWJWRkJjMzKGwvXWw0IzRZfU9FPTZjPWJ3KEE3Jjl0JXdkJk4vJm1vLEpIJlFlKWZtPUFvfWZ1PXRIXCI7Y29uc3QgZGVsdGFEYXRhPVwiRkFaREM2QkFMY0xaQ0ErR0JBUkNXOHdOQ2NERFo4TFZGQk9xcURVaW91K000MlRGQXlFUlhGYjdFamhQK3ZtQkZwRnJVcGZEVjJGN2VCK2VDbHRDSEpGV0xGQ0VEK3BXVG9qRUlIRlhjM2FGbjRGNjh6cWpFdUtpZFMxUUJWUERFaEU3TkE0bWhNRjdvVGhENDlvdDNGZ3R6SEZDSzBhY1cxeDhESDFFbUxvSWxyV0ZCTEUreTUrTkEzQ3g2NXdKSFRhRVpWYUsxbVdBbVBHeGdZQ2R4d09qVERJdC9mYU9FaFRsMXZxTnNLdEpDT2hKV3VpbzJnMDdLTFpFUXNGQlVwTnR3RUJ5Qmd4RnNsRmhlRmJpRVB2aTYxbXNEdkFweEN6QjZyQkN6b3g3am9ZQTVVZERjK0NiNEZTZ0lhYnBYRkFqM2Jqa21GQXhDWkUrbUQvU0ZmLzBFTGVjWUN0M25Mb3hDNldFWmYydEtEQjRvWnZyRW1xRmtLazdCd0lMQTdndFlCcHNUcS8vRDRqRDBGMHdFQjlweVExQkQ1QmEwb1lIREkrc2JERmh2ckhYZERIZmdGRUlKTGk1cjhxZXJjTkZCZ0ZMQzRibzVFUkp0YW1XQkRGeTczS0NFYjZNOFZwbUV0MzMweWdDVEs1OEVJSUZrWWdGODRndEdBOVV5aDNtNjhpVnJGYldGYmNicWlDWUhaOUoxamVSUGJMOHlzd2hNaURiaEVoZE5vU3dGYlpyTFQ3NDBBQkVxZ0NrTzhKMUJMZDFWaEtLUjRzRDF5VW8weitGRjU5TXZnNzFDRmJ5RWhiSFNGQktFSUt5b1FOZ1FwcHE5VDBLQXFlUHUwWkZHclhPSGRLSnFrb1RGaFl2cEROeXV1em5yTjg0dGhKYnNDb082Q3U2WGx2bnR2eTBRWXVBRXhRRVl0VFVCZjNDb0Nxd2dHRlo0dTFISkZ6RFZ3RXkzY2pjcFY0UXZzUGFCQzNyQ0d5Q0YyM280SzNwcDJnYmVyR2dGRUpFSG80bkhJQ3R5S0gyWnF5eGhOMDVLQkJKSVFsS2gvT3Vqdi9ESDMyVnJscUZkSUZDN0Z6OUN0NGthcUZNRTBVRVRMcHJuTjlrZnkra0ZtdFFCQjArNUNGdTBOOUlqOGwvVnZKRGgyb3EzaFQ2RXpqVEhLRk43Wmpad29Uc0FaNEV4c2tvNkZwYTZXQytzZHV6OGp5ckxwZWdUdjJoMUVCZVlwTHBtMmN6UVcwS29DY1MwYkNWWENtdVdKREJqTjFuUU5MZEY1OFNGSjBoN2kzcEMzb0VPS3kvRmpCa2xMNzBYdkJFRUlXcDJ5WjA0eE9iekFXRERKRzdmK0RicUJFQTdMeWlSOTVqN01EVmREVml6MlJFNXZXbEJNdjVlNCtWZmhQM2FYTlBodkxTeW5iOU8yeDR1RkJWKzNqcXU2ZDVwQ0cyOC9zRVRCeXZtdS8rSUowTDN3YjRyajlETk9MQkY2WFBJT0RyNEwxOVU5UlJvZkFHNk54eWRpOEJraThCaEdKYkJBSkt6Ykp4a1pTbEY5UTJDdThvS3FnZ0I5aEJBcndMTHFFQldFdEZvd3k4WEs4YkV5dzlzblQrQmV5RmsxWkNTcmRtZ2ZFd0ZlUFRnQ2pFTEJFbkliamFERFBKbTM2ckc5cHp0Y0V6VDhkR2syM1NCaFhCQjFINHorT1d6ZTBvb0Z6ejhwREJZRnZwOWo5dHZGQnlmOXk0RUZkVm56MDI2Q0dSNXFNcjdmeE1ITjhVVWRseUpBemxUQkRSQzI4aytMNEZCODA3OGxqeUQ5MXRVajFvY25Uczh2ZEVmN3puYnptK0dJakVabm9aRTVybkxMNzAwWGM3eUhmejA1bld4eTAzdkJCOVlHSFlPV3hnTVFHQkNSMjRDVllORTFocGZLeE4wektuZkpEbW1NZ01tQldxTmJqZlN5RkNCV1NDR0NnUjh5RlhpSHlFaitWdEQxRkIzRnBDMXpJMGtGYnppZmlLVExtOXlxNXpGbXVyK3E4Rkhxam9PQldzQlBpRGJuQ0MyRXJ1blY2Y0o2VHlnWEZZSFlwN01LTjlSVWxTSVM4L3hCQUdZTHplcVVuQkY0UWJzVHVVa1VxR3M2Q2FpRFdLV2pRSzlFSmtqcGtUbU5DUFlYTFwiO2NvbnN0IHdvcmRsaXN0JDc9e3poX2NuOm51bGwsemhfdHc6bnVsbH07Y29uc3QgQ2hlY2tzPXt6aF9jbjpcIjB4MTdiY2M0ZDg1NDdlNWE3MTM1ZTM2NWQxYWI0NDNhYWFlOTVlNzZkODIzMGMyNzgyYzY3MzA1ZDRmMjE0OTdhMVwiLHpoX3R3OlwiMHg1MWU3MjBlOTBjN2I4N2JlYzFkNzBlYjZlNzRhMjFhNDQ5YmQzZWM5YzAyMGIwMWQzYTQwZWQ5OTFiNjBjZTVkXCJ9O2NvbnN0IGNvZGVzJDE9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7Y29uc3Qgc3R5bGU9XCJ+IUAjJCVeJipfLT1bXXt9fDs6LC4oKTw+P1wiO2Z1bmN0aW9uIGxvYWRXb3JkcyQ3KGxhbmcpe2lmKHdvcmRsaXN0JDdbbGFuZy5sb2NhbGVdIT09bnVsbCl7cmV0dXJufXdvcmRsaXN0JDdbbGFuZy5sb2NhbGVdPVtdO2xldCBkZWx0YU9mZnNldD0wO2ZvcihsZXQgaT0wO2k8MjA0ODtpKyspe2NvbnN0IHM9c3R5bGUuaW5kZXhPZihkYXRhJDJbaSozXSk7Y29uc3QgYnl0ZXM9WzIyOCsocz4+MiksMTI4K2NvZGVzJDEuaW5kZXhPZihkYXRhJDJbaSozKzFdKSwxMjgrY29kZXMkMS5pbmRleE9mKGRhdGEkMltpKjMrMl0pXTtpZihsYW5nLmxvY2FsZT09PVwiemhfdHdcIil7Y29uc3QgY29tbW9uPXMlNDtmb3IobGV0IGk9Y29tbW9uO2k8MztpKyspe2J5dGVzW2ldPWNvZGVzJDEuaW5kZXhPZihkZWx0YURhdGFbZGVsdGFPZmZzZXQrK10pKyhpPT0wPzIyODoxMjgpfX13b3JkbGlzdCQ3W2xhbmcubG9jYWxlXS5wdXNoKHRvVXRmOFN0cmluZyhieXRlcykpfWlmKFdvcmRsaXN0LmNoZWNrKGxhbmcpIT09Q2hlY2tzW2xhbmcubG9jYWxlXSl7d29yZGxpc3QkN1tsYW5nLmxvY2FsZV09bnVsbDt0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3IgXCIrbGFuZy5sb2NhbGUrXCIgKENoaW5lc2UpIEZBSUxFRFwiKX19Y2xhc3MgTGFuZ1poIGV4dGVuZHMgV29yZGxpc3R7Y29uc3RydWN0b3IoY291bnRyeSl7c3VwZXIoXCJ6aF9cIitjb3VudHJ5KX1nZXRXb3JkKGluZGV4KXtsb2FkV29yZHMkNyh0aGlzKTtyZXR1cm4gd29yZGxpc3QkN1t0aGlzLmxvY2FsZV1baW5kZXhdfWdldFdvcmRJbmRleCh3b3JkKXtsb2FkV29yZHMkNyh0aGlzKTtyZXR1cm4gd29yZGxpc3QkN1t0aGlzLmxvY2FsZV0uaW5kZXhPZih3b3JkKX1zcGxpdChtbmVtb25pYyl7bW5lbW9uaWM9bW5lbW9uaWMucmVwbGFjZSgvKD86XFx1MzAwMHwgKSsvZyxcIlwiKTtyZXR1cm4gbW5lbW9uaWMuc3BsaXQoXCJcIil9fWNvbnN0IGxhbmdaaENuPW5ldyBMYW5nWmgoXCJjblwiKTtXb3JkbGlzdC5yZWdpc3RlcihsYW5nWmhDbik7V29yZGxpc3QucmVnaXN0ZXIobGFuZ1poQ24sXCJ6aFwiKTtjb25zdCBsYW5nWmhUdz1uZXcgTGFuZ1poKFwidHdcIik7V29yZGxpc3QucmVnaXN0ZXIobGFuZ1poVHcpO2NvbnN0IHdvcmRsaXN0cz17Y3o6bGFuZ0N6LGVuOmxhbmdFbixlczpsYW5nRXMsZnI6bGFuZ0ZyLGl0OmxhbmdJdCxqYTpsYW5nSmEsa286bGFuZ0tvLHpoOmxhbmdaaENuLHpoX2NuOmxhbmdaaENuLHpoX3R3OmxhbmdaaFR3fTtcInVzZSBzdHJpY3RcIjtjb25zdCB2ZXJzaW9uJGc9XCJoZG5vZGUvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkbD1uZXcgTG9nZ2VyKHZlcnNpb24kZyk7Y29uc3QgTj1CaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKTtjb25zdCBNYXN0ZXJTZWNyZXQ9dG9VdGY4Qnl0ZXMoXCJCaXRjb2luIHNlZWRcIik7Y29uc3QgSGFyZGVuZWRCaXQ9MjE0NzQ4MzY0ODtmdW5jdGlvbiBnZXRVcHBlck1hc2soYml0cyl7cmV0dXJuKDE8PGJpdHMpLTE8PDgtYml0c31mdW5jdGlvbiBnZXRMb3dlck1hc2soYml0cyl7cmV0dXJuKDE8PGJpdHMpLTF9ZnVuY3Rpb24gYnl0ZXMzMih2YWx1ZSl7cmV0dXJuIGhleFplcm9QYWQoaGV4bGlmeSh2YWx1ZSksMzIpfWZ1bmN0aW9uIGJhc2U1OGNoZWNrKGRhdGEpe3JldHVybiBCYXNlNTguZW5jb2RlKGNvbmNhdChbZGF0YSxoZXhEYXRhU2xpY2Uoc2hhMjU2JDEoc2hhMjU2JDEoZGF0YSkpLDAsNCldKSl9ZnVuY3Rpb24gZ2V0V29yZGxpc3Qod29yZGxpc3Qpe2lmKHdvcmRsaXN0PT1udWxsKXtyZXR1cm4gd29yZGxpc3RzW1wiZW5cIl19aWYodHlwZW9mIHdvcmRsaXN0PT09XCJzdHJpbmdcIil7Y29uc3Qgd29yZHM9d29yZGxpc3RzW3dvcmRsaXN0XTtpZih3b3Jkcz09bnVsbCl7bG9nZ2VyJGwudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biBsb2NhbGVcIixcIndvcmRsaXN0XCIsd29yZGxpc3QpfXJldHVybiB3b3Jkc31yZXR1cm4gd29yZGxpc3R9Y29uc3QgX2NvbnN0cnVjdG9yR3VhcmQkMz17fTtjb25zdCBkZWZhdWx0UGF0aD1cIm0vNDQnLzYwJy8wJy8wLzBcIjtjbGFzcyBIRE5vZGV7Y29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCxwcml2YXRlS2V5LHB1YmxpY0tleSxwYXJlbnRGaW5nZXJwcmludCxjaGFpbkNvZGUsaW5kZXgsZGVwdGgsbW5lbW9uaWNPclBhdGgpe2xvZ2dlciRsLmNoZWNrTmV3KG5ldy50YXJnZXQsSEROb2RlKTtpZihjb25zdHJ1Y3Rvckd1YXJkIT09X2NvbnN0cnVjdG9yR3VhcmQkMyl7dGhyb3cgbmV3IEVycm9yKFwiSEROb2RlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHlcIil9aWYocHJpdmF0ZUtleSl7Y29uc3Qgc2lnbmluZ0tleT1uZXcgU2lnbmluZ0tleShwcml2YXRlS2V5KTtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJpdmF0ZUtleVwiLHNpZ25pbmdLZXkucHJpdmF0ZUtleSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInB1YmxpY0tleVwiLHNpZ25pbmdLZXkuY29tcHJlc3NlZFB1YmxpY0tleSl9ZWxzZXtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJpdmF0ZUtleVwiLG51bGwpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIixoZXhsaWZ5KHB1YmxpY0tleSkpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJwYXJlbnRGaW5nZXJwcmludFwiLHBhcmVudEZpbmdlcnByaW50KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiZmluZ2VycHJpbnRcIixoZXhEYXRhU2xpY2UocmlwZW1kMTYwJDEoc2hhMjU2JDEodGhpcy5wdWJsaWNLZXkpKSwwLDQpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYWRkcmVzc1wiLGNvbXB1dGVBZGRyZXNzKHRoaXMucHVibGljS2V5KSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImNoYWluQ29kZVwiLGNoYWluQ29kZSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImluZGV4XCIsaW5kZXgpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJkZXB0aFwiLGRlcHRoKTtpZihtbmVtb25pY09yUGF0aD09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIm1uZW1vbmljXCIsbnVsbCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInBhdGhcIixudWxsKX1lbHNlIGlmKHR5cGVvZiBtbmVtb25pY09yUGF0aD09PVwic3RyaW5nXCIpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJtbmVtb25pY1wiLG51bGwpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwYXRoXCIsbW5lbW9uaWNPclBhdGgpfWVsc2V7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIm1uZW1vbmljXCIsbW5lbW9uaWNPclBhdGgpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwYXRoXCIsbW5lbW9uaWNPclBhdGgucGF0aCl9fWdldCBleHRlbmRlZEtleSgpe2lmKHRoaXMuZGVwdGg+PTI1Nil7dGhyb3cgbmV3IEVycm9yKFwiRGVwdGggdG9vIGxhcmdlIVwiKX1yZXR1cm4gYmFzZTU4Y2hlY2soY29uY2F0KFt0aGlzLnByaXZhdGVLZXkhPW51bGw/XCIweDA0ODhBREU0XCI6XCIweDA0ODhCMjFFXCIsaGV4bGlmeSh0aGlzLmRlcHRoKSx0aGlzLnBhcmVudEZpbmdlcnByaW50LGhleFplcm9QYWQoaGV4bGlmeSh0aGlzLmluZGV4KSw0KSx0aGlzLmNoYWluQ29kZSx0aGlzLnByaXZhdGVLZXkhPW51bGw/Y29uY2F0KFtcIjB4MDBcIix0aGlzLnByaXZhdGVLZXldKTp0aGlzLnB1YmxpY0tleV0pKX1uZXV0ZXIoKXtyZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCQzLG51bGwsdGhpcy5wdWJsaWNLZXksdGhpcy5wYXJlbnRGaW5nZXJwcmludCx0aGlzLmNoYWluQ29kZSx0aGlzLmluZGV4LHRoaXMuZGVwdGgsdGhpcy5wYXRoKX1fZGVyaXZlKGluZGV4KXtpZihpbmRleD40Mjk0OTY3Mjk1KXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluZGV4IC0gXCIrU3RyaW5nKGluZGV4KSl9bGV0IHBhdGg9dGhpcy5wYXRoO2lmKHBhdGgpe3BhdGgrPVwiL1wiKyhpbmRleCZ+SGFyZGVuZWRCaXQpfWNvbnN0IGRhdGE9bmV3IFVpbnQ4QXJyYXkoMzcpO2lmKGluZGV4JkhhcmRlbmVkQml0KXtpZighdGhpcy5wcml2YXRlS2V5KXt0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVyaXZlIGNoaWxkIG9mIG5ldXRlcmVkIG5vZGVcIil9ZGF0YS5zZXQoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSwxKTtpZihwYXRoKXtwYXRoKz1cIidcIn19ZWxzZXtkYXRhLnNldChhcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpfWZvcihsZXQgaT0yNDtpPj0wO2ktPTgpe2RhdGFbMzMrKGk+PjMpXT1pbmRleD4+MjQtaSYyNTV9Y29uc3QgST1hcnJheWlmeShjb21wdXRlSG1hYyhTdXBwb3J0ZWRBbGdvcml0aG0uc2hhNTEyLHRoaXMuY2hhaW5Db2RlLGRhdGEpKTtjb25zdCBJTD1JLnNsaWNlKDAsMzIpO2NvbnN0IElSPUkuc2xpY2UoMzIpO2xldCBraT1udWxsO2xldCBLaT1udWxsO2lmKHRoaXMucHJpdmF0ZUtleSl7a2k9Ynl0ZXMzMihCaWdOdW1iZXIuZnJvbShJTCkuYWRkKHRoaXMucHJpdmF0ZUtleSkubW9kKE4pKX1lbHNle2NvbnN0IGVrPW5ldyBTaWduaW5nS2V5KGhleGxpZnkoSUwpKTtLaT1lay5fYWRkUG9pbnQodGhpcy5wdWJsaWNLZXkpfWxldCBtbmVtb25pY09yUGF0aD1wYXRoO2NvbnN0IHNyY01uZW1vbmljPXRoaXMubW5lbW9uaWM7aWYoc3JjTW5lbW9uaWMpe21uZW1vbmljT3JQYXRoPU9iamVjdC5mcmVlemUoe3BocmFzZTpzcmNNbmVtb25pYy5waHJhc2UscGF0aDpwYXRoLGxvY2FsZTpzcmNNbmVtb25pYy5sb2NhbGV8fFwiZW5cIn0pfXJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkJDMsa2ksS2ksdGhpcy5maW5nZXJwcmludCxieXRlczMyKElSKSxpbmRleCx0aGlzLmRlcHRoKzEsbW5lbW9uaWNPclBhdGgpfWRlcml2ZVBhdGgocGF0aCl7Y29uc3QgY29tcG9uZW50cz1wYXRoLnNwbGl0KFwiL1wiKTtpZihjb21wb25lbnRzLmxlbmd0aD09PTB8fGNvbXBvbmVudHNbMF09PT1cIm1cIiYmdGhpcy5kZXB0aCE9PTApe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCAtIFwiK3BhdGgpfWlmKGNvbXBvbmVudHNbMF09PT1cIm1cIil7Y29tcG9uZW50cy5zaGlmdCgpfWxldCByZXN1bHQ9dGhpcztmb3IobGV0IGk9MDtpPGNvbXBvbmVudHMubGVuZ3RoO2krKyl7Y29uc3QgY29tcG9uZW50PWNvbXBvbmVudHNbaV07aWYoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSl7Y29uc3QgaW5kZXg9cGFyc2VJbnQoY29tcG9uZW50LnN1YnN0cmluZygwLGNvbXBvbmVudC5sZW5ndGgtMSkpO2lmKGluZGV4Pj1IYXJkZW5lZEJpdCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGluZGV4IC0gXCIrY29tcG9uZW50KX1yZXN1bHQ9cmVzdWx0Ll9kZXJpdmUoSGFyZGVuZWRCaXQraW5kZXgpfWVsc2UgaWYoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKXtjb25zdCBpbmRleD1wYXJzZUludChjb21wb25lbnQpO2lmKGluZGV4Pj1IYXJkZW5lZEJpdCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGluZGV4IC0gXCIrY29tcG9uZW50KX1yZXN1bHQ9cmVzdWx0Ll9kZXJpdmUoaW5kZXgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIGNvbXBvbmVudCAtIFwiK2NvbXBvbmVudCl9fXJldHVybiByZXN1bHR9c3RhdGljIF9mcm9tU2VlZChzZWVkLG1uZW1vbmljKXtjb25zdCBzZWVkQXJyYXk9YXJyYXlpZnkoc2VlZCk7aWYoc2VlZEFycmF5Lmxlbmd0aDwxNnx8c2VlZEFycmF5Lmxlbmd0aD42NCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZWVkXCIpfWNvbnN0IEk9YXJyYXlpZnkoY29tcHV0ZUhtYWMoU3VwcG9ydGVkQWxnb3JpdGhtLnNoYTUxMixNYXN0ZXJTZWNyZXQsc2VlZEFycmF5KSk7cmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQkMyxieXRlczMyKEkuc2xpY2UoMCwzMikpLG51bGwsXCIweDAwMDAwMDAwXCIsYnl0ZXMzMihJLnNsaWNlKDMyKSksMCwwLG1uZW1vbmljKX1zdGF0aWMgZnJvbU1uZW1vbmljKG1uZW1vbmljLHBhc3N3b3JkLHdvcmRsaXN0KXt3b3JkbGlzdD1nZXRXb3JkbGlzdCh3b3JkbGlzdCk7bW5lbW9uaWM9ZW50cm9weVRvTW5lbW9uaWMobW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsd29yZGxpc3QpLHdvcmRsaXN0KTtyZXR1cm4gSEROb2RlLl9mcm9tU2VlZChtbmVtb25pY1RvU2VlZChtbmVtb25pYyxwYXNzd29yZCkse3BocmFzZTptbmVtb25pYyxwYXRoOlwibVwiLGxvY2FsZTp3b3JkbGlzdC5sb2NhbGV9KX1zdGF0aWMgZnJvbVNlZWQoc2VlZCl7cmV0dXJuIEhETm9kZS5fZnJvbVNlZWQoc2VlZCxudWxsKX1zdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KXtjb25zdCBieXRlcz1CYXNlNTguZGVjb2RlKGV4dGVuZGVkS2V5KTtpZihieXRlcy5sZW5ndGghPT04Mnx8YmFzZTU4Y2hlY2soYnl0ZXMuc2xpY2UoMCw3OCkpIT09ZXh0ZW5kZWRLZXkpe2xvZ2dlciRsLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXh0ZW5kZWQga2V5XCIsXCJleHRlbmRlZEtleVwiLFwiW1JFREFDVEVEXVwiKX1jb25zdCBkZXB0aD1ieXRlc1s0XTtjb25zdCBwYXJlbnRGaW5nZXJwcmludD1oZXhsaWZ5KGJ5dGVzLnNsaWNlKDUsOSkpO2NvbnN0IGluZGV4PXBhcnNlSW50KGhleGxpZnkoYnl0ZXMuc2xpY2UoOSwxMykpLnN1YnN0cmluZygyKSwxNik7Y29uc3QgY2hhaW5Db2RlPWhleGxpZnkoYnl0ZXMuc2xpY2UoMTMsNDUpKTtjb25zdCBrZXk9Ynl0ZXMuc2xpY2UoNDUsNzgpO3N3aXRjaChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsNCkpKXtjYXNlXCIweDA0ODhiMjFlXCI6Y2FzZVwiMHgwNDM1ODdjZlwiOnJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkJDMsbnVsbCxoZXhsaWZ5KGtleSkscGFyZW50RmluZ2VycHJpbnQsY2hhaW5Db2RlLGluZGV4LGRlcHRoLG51bGwpO2Nhc2VcIjB4MDQ4OGFkZTRcIjpjYXNlXCIweDA0MzU4Mzk0IFwiOmlmKGtleVswXSE9PTApe2JyZWFrfXJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkJDMsaGV4bGlmeShrZXkuc2xpY2UoMSkpLG51bGwscGFyZW50RmluZ2VycHJpbnQsY2hhaW5Db2RlLGluZGV4LGRlcHRoLG51bGwpfXJldHVybiBsb2dnZXIkbC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLFwiZXh0ZW5kZWRLZXlcIixcIltSRURBQ1RFRF1cIil9fWZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkKG1uZW1vbmljLHBhc3N3b3JkKXtpZighcGFzc3dvcmQpe3Bhc3N3b3JkPVwiXCJ9Y29uc3Qgc2FsdD10b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIrcGFzc3dvcmQsVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0QpO3JldHVybiBwYmtkZjIodG9VdGY4Qnl0ZXMobW5lbW9uaWMsVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0QpLHNhbHQsMjA0OCw2NCxcInNoYTUxMlwiKX1mdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYyx3b3JkbGlzdCl7d29yZGxpc3Q9Z2V0V29yZGxpc3Qod29yZGxpc3QpO2xvZ2dlciRsLmNoZWNrTm9ybWFsaXplKCk7Y29uc3Qgd29yZHM9d29yZGxpc3Quc3BsaXQobW5lbW9uaWMpO2lmKHdvcmRzLmxlbmd0aCUzIT09MCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtbmVtb25pY1wiKX1jb25zdCBlbnRyb3B5PWFycmF5aWZ5KG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCgxMSp3b3Jkcy5sZW5ndGgvOCkpKTtsZXQgb2Zmc2V0PTA7Zm9yKGxldCBpPTA7aTx3b3Jkcy5sZW5ndGg7aSsrKXtsZXQgaW5kZXg9d29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO2lmKGluZGV4PT09LTEpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgbW5lbW9uaWNcIil9Zm9yKGxldCBiaXQ9MDtiaXQ8MTE7Yml0Kyspe2lmKGluZGV4JjE8PDEwLWJpdCl7ZW50cm9weVtvZmZzZXQ+PjNdfD0xPDw3LW9mZnNldCU4fW9mZnNldCsrfX1jb25zdCBlbnRyb3B5Qml0cz0zMip3b3Jkcy5sZW5ndGgvMztjb25zdCBjaGVja3N1bUJpdHM9d29yZHMubGVuZ3RoLzM7Y29uc3QgY2hlY2tzdW1NYXNrPWdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO2NvbnN0IGNoZWNrc3VtPWFycmF5aWZ5KHNoYTI1NiQxKGVudHJvcHkuc2xpY2UoMCxlbnRyb3B5Qml0cy84KSkpWzBdJmNoZWNrc3VtTWFzaztpZihjaGVja3N1bSE9PShlbnRyb3B5W2VudHJvcHkubGVuZ3RoLTFdJmNoZWNrc3VtTWFzaykpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgY2hlY2tzdW1cIil9cmV0dXJuIGhleGxpZnkoZW50cm9weS5zbGljZSgwLGVudHJvcHlCaXRzLzgpKX1mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LHdvcmRsaXN0KXt3b3JkbGlzdD1nZXRXb3JkbGlzdCh3b3JkbGlzdCk7ZW50cm9weT1hcnJheWlmeShlbnRyb3B5KTtpZihlbnRyb3B5Lmxlbmd0aCU0IT09MHx8ZW50cm9weS5sZW5ndGg8MTZ8fGVudHJvcHkubGVuZ3RoPjMyKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVudHJvcHlcIil9Y29uc3QgaW5kaWNlcz1bMF07bGV0IHJlbWFpbmluZ0JpdHM9MTE7Zm9yKGxldCBpPTA7aTxlbnRyb3B5Lmxlbmd0aDtpKyspe2lmKHJlbWFpbmluZ0JpdHM+OCl7aW5kaWNlc1tpbmRpY2VzLmxlbmd0aC0xXTw8PTg7aW5kaWNlc1tpbmRpY2VzLmxlbmd0aC0xXXw9ZW50cm9weVtpXTtyZW1haW5pbmdCaXRzLT04fWVsc2V7aW5kaWNlc1tpbmRpY2VzLmxlbmd0aC0xXTw8PXJlbWFpbmluZ0JpdHM7aW5kaWNlc1tpbmRpY2VzLmxlbmd0aC0xXXw9ZW50cm9weVtpXT4+OC1yZW1haW5pbmdCaXRzO2luZGljZXMucHVzaChlbnRyb3B5W2ldJmdldExvd2VyTWFzayg4LXJlbWFpbmluZ0JpdHMpKTtyZW1haW5pbmdCaXRzKz0zfX1jb25zdCBjaGVja3N1bUJpdHM9ZW50cm9weS5sZW5ndGgvNDtjb25zdCBjaGVja3N1bT1hcnJheWlmeShzaGEyNTYkMShlbnRyb3B5KSlbMF0mZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7aW5kaWNlc1tpbmRpY2VzLmxlbmd0aC0xXTw8PWNoZWNrc3VtQml0cztpbmRpY2VzW2luZGljZXMubGVuZ3RoLTFdfD1jaGVja3N1bT4+OC1jaGVja3N1bUJpdHM7cmV0dXJuIHdvcmRsaXN0LmpvaW4oaW5kaWNlcy5tYXAoaW5kZXg9PndvcmRsaXN0LmdldFdvcmQoaW5kZXgpKSl9ZnVuY3Rpb24gaXNWYWxpZE1uZW1vbmljKG1uZW1vbmljLHdvcmRsaXN0KXt0cnl7bW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsd29yZGxpc3QpO3JldHVybiB0cnVlfWNhdGNoKGVycm9yKXt9cmV0dXJuIGZhbHNlfWNvbnN0IHZlcnNpb24kaD1cInJhbmRvbS81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRtPW5ldyBMb2dnZXIodmVyc2lvbiRoKTtsZXQgYW55R2xvYmFsPW51bGw7dHJ5e2FueUdsb2JhbD13aW5kb3c7aWYoYW55R2xvYmFsPT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgbmV4dFwiKX19Y2F0Y2goZXJyb3Ipe3RyeXthbnlHbG9iYWw9Z2xvYmFsO2lmKGFueUdsb2JhbD09bnVsbCl7dGhyb3cgbmV3IEVycm9yKFwidHJ5IG5leHRcIil9fWNhdGNoKGVycm9yKXthbnlHbG9iYWw9e319fWxldCBjcnlwdG89YW55R2xvYmFsLmNyeXB0b3x8YW55R2xvYmFsLm1zQ3J5cHRvO2lmKCFjcnlwdG98fCFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXtsb2dnZXIkbS53YXJuKFwiV0FSTklORzogTWlzc2luZyBzdHJvbmcgcmFuZG9tIG51bWJlciBzb3VyY2VcIik7Y3J5cHRvPXtnZXRSYW5kb21WYWx1ZXM6ZnVuY3Rpb24oYnVmZmVyKXtyZXR1cm4gbG9nZ2VyJG0udGhyb3dFcnJvcihcIm5vIHNlY3VyZSByYW5kb20gc291cmNlIGF2YWlhbGJsZVwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXCJ9KX19fWZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCl7aWYobGVuZ3RoPD0wfHxsZW5ndGg+MTAyNHx8bGVuZ3RoJTEpe2xvZ2dlciRtLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoXCIsXCJsZW5ndGhcIixsZW5ndGgpfWNvbnN0IHJlc3VsdD1uZXcgVWludDhBcnJheShsZW5ndGgpO2NyeXB0by5nZXRSYW5kb21WYWx1ZXMocmVzdWx0KTtyZXR1cm4gYXJyYXlpZnkocmVzdWx0KX1cInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBzaHVmZmxlZChhcnJheSl7YXJyYXk9YXJyYXkuc2xpY2UoKTtmb3IobGV0IGk9YXJyYXkubGVuZ3RoLTE7aT4wO2ktLSl7Y29uc3Qgaj1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKGkrMSkpO2NvbnN0IHRtcD1hcnJheVtpXTthcnJheVtpXT1hcnJheVtqXTthcnJheVtqXT10bXB9cmV0dXJuIGFycmF5fVwidXNlIHN0cmljdFwiO3ZhciBhZXNKcz1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKHJvb3Qpe2Z1bmN0aW9uIGNoZWNrSW50KHZhbHVlKXtyZXR1cm4gcGFyc2VJbnQodmFsdWUpPT09dmFsdWV9ZnVuY3Rpb24gY2hlY2tJbnRzKGFycmF5aXNoKXtpZighY2hlY2tJbnQoYXJyYXlpc2gubGVuZ3RoKSl7cmV0dXJuIGZhbHNlfWZvcih2YXIgaT0wO2k8YXJyYXlpc2gubGVuZ3RoO2krKyl7aWYoIWNoZWNrSW50KGFycmF5aXNoW2ldKXx8YXJyYXlpc2hbaV08MHx8YXJyYXlpc2hbaV0+MjU1KXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfWZ1bmN0aW9uIGNvZXJjZUFycmF5KGFyZyxjb3B5KXtpZihhcmcuYnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKSYmYXJnLm5hbWU9PT1cIlVpbnQ4QXJyYXlcIil7aWYoY29weSl7aWYoYXJnLnNsaWNlKXthcmc9YXJnLnNsaWNlKCl9ZWxzZXthcmc9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJnKX19cmV0dXJuIGFyZ31pZihBcnJheS5pc0FycmF5KGFyZykpe2lmKCFjaGVja0ludHMoYXJnKSl7dGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgY29udGFpbnMgaW52YWxpZCB2YWx1ZTogXCIrYXJnKX1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKX1pZihjaGVja0ludChhcmcubGVuZ3RoKSYmY2hlY2tJbnRzKGFyZykpe3JldHVybiBuZXcgVWludDhBcnJheShhcmcpfXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFycmF5LWxpa2Ugb2JqZWN0XCIpfWZ1bmN0aW9uIGNyZWF0ZUFycmF5KGxlbmd0aCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCl9ZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZUFycmF5LHRhcmdldEFycmF5LHRhcmdldFN0YXJ0LHNvdXJjZVN0YXJ0LHNvdXJjZUVuZCl7aWYoc291cmNlU3RhcnQhPW51bGx8fHNvdXJjZUVuZCE9bnVsbCl7aWYoc291cmNlQXJyYXkuc2xpY2Upe3NvdXJjZUFycmF5PXNvdXJjZUFycmF5LnNsaWNlKHNvdXJjZVN0YXJ0LHNvdXJjZUVuZCl9ZWxzZXtzb3VyY2VBcnJheT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzb3VyY2VBcnJheSxzb3VyY2VTdGFydCxzb3VyY2VFbmQpfX10YXJnZXRBcnJheS5zZXQoc291cmNlQXJyYXksdGFyZ2V0U3RhcnQpfXZhciBjb252ZXJ0VXRmOD1mdW5jdGlvbigpe2Z1bmN0aW9uIHRvQnl0ZXModGV4dCl7dmFyIHJlc3VsdD1bXSxpPTA7dGV4dD1lbmNvZGVVUkkodGV4dCk7d2hpbGUoaTx0ZXh0Lmxlbmd0aCl7dmFyIGM9dGV4dC5jaGFyQ29kZUF0KGkrKyk7aWYoYz09PTM3KXtyZXN1bHQucHVzaChwYXJzZUludCh0ZXh0LnN1YnN0cihpLDIpLDE2KSk7aSs9Mn1lbHNle3Jlc3VsdC5wdXNoKGMpfX1yZXR1cm4gY29lcmNlQXJyYXkocmVzdWx0KX1mdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpe3ZhciByZXN1bHQ9W10saT0wO3doaWxlKGk8Ynl0ZXMubGVuZ3RoKXt2YXIgYz1ieXRlc1tpXTtpZihjPDEyOCl7cmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7aSsrfWVsc2UgaWYoYz4xOTEmJmM8MjI0KXtyZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKChjJjMxKTw8NnxieXRlc1tpKzFdJjYzKSk7aSs9Mn1lbHNle3Jlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKGMmMTUpPDwxMnwoYnl0ZXNbaSsxXSY2Myk8PDZ8Ynl0ZXNbaSsyXSY2MykpO2krPTN9fXJldHVybiByZXN1bHQuam9pbihcIlwiKX1yZXR1cm57dG9CeXRlczp0b0J5dGVzLGZyb21CeXRlczpmcm9tQnl0ZXN9fSgpO3ZhciBjb252ZXJ0SGV4PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdG9CeXRlcyh0ZXh0KXt2YXIgcmVzdWx0PVtdO2Zvcih2YXIgaT0wO2k8dGV4dC5sZW5ndGg7aSs9Mil7cmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwyKSwxNikpfXJldHVybiByZXN1bHR9dmFyIEhleD1cIjAxMjM0NTY3ODlhYmNkZWZcIjtmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpe3ZhciByZXN1bHQ9W107Zm9yKHZhciBpPTA7aTxieXRlcy5sZW5ndGg7aSsrKXt2YXIgdj1ieXRlc1tpXTtyZXN1bHQucHVzaChIZXhbKHYmMjQwKT4+NF0rSGV4W3YmMTVdKX1yZXR1cm4gcmVzdWx0LmpvaW4oXCJcIil9cmV0dXJue3RvQnl0ZXM6dG9CeXRlcyxmcm9tQnl0ZXM6ZnJvbUJ5dGVzfX0oKTt2YXIgbnVtYmVyT2ZSb3VuZHM9ezE2OjEwLDI0OjEyLDMyOjE0fTt2YXIgcmNvbj1bMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDVdO3ZhciBTPVs5OSwxMjQsMTE5LDEyMywyNDIsMTA3LDExMSwxOTcsNDgsMSwxMDMsNDMsMjU0LDIxNSwxNzEsMTE4LDIwMiwxMzAsMjAxLDEyNSwyNTAsODksNzEsMjQwLDE3MywyMTIsMTYyLDE3NSwxNTYsMTY0LDExNCwxOTIsMTgzLDI1MywxNDcsMzgsNTQsNjMsMjQ3LDIwNCw1MiwxNjUsMjI5LDI0MSwxMTMsMjE2LDQ5LDIxLDQsMTk5LDM1LDE5NSwyNCwxNTAsNSwxNTQsNywxOCwxMjgsMjI2LDIzNSwzOSwxNzgsMTE3LDksMTMxLDQ0LDI2LDI3LDExMCw5MCwxNjAsODIsNTksMjE0LDE3OSw0MSwyMjcsNDcsMTMyLDgzLDIwOSwwLDIzNywzMiwyNTIsMTc3LDkxLDEwNiwyMDMsMTkwLDU3LDc0LDc2LDg4LDIwNywyMDgsMjM5LDE3MCwyNTEsNjcsNzcsNTEsMTMzLDY5LDI0OSwyLDEyNyw4MCw2MCwxNTksMTY4LDgxLDE2Myw2NCwxNDMsMTQ2LDE1Nyw1NiwyNDUsMTg4LDE4MiwyMTgsMzMsMTYsMjU1LDI0MywyMTAsMjA1LDEyLDE5LDIzNiw5NSwxNTEsNjgsMjMsMTk2LDE2NywxMjYsNjEsMTAwLDkzLDI1LDExNSw5NiwxMjksNzksMjIwLDM0LDQyLDE0NCwxMzYsNzAsMjM4LDE4NCwyMCwyMjIsOTQsMTEsMjE5LDIyNCw1MCw1OCwxMCw3Myw2LDM2LDkyLDE5NCwyMTEsMTcyLDk4LDE0NSwxNDksMjI4LDEyMSwyMzEsMjAwLDU1LDEwOSwxNDEsMjEzLDc4LDE2OSwxMDgsODYsMjQ0LDIzNCwxMDEsMTIyLDE3NCw4LDE4NiwxMjAsMzcsNDYsMjgsMTY2LDE4MCwxOTgsMjMyLDIyMSwxMTYsMzEsNzUsMTg5LDEzOSwxMzgsMTEyLDYyLDE4MSwxMDIsNzIsMywyNDYsMTQsOTcsNTMsODcsMTg1LDEzNCwxOTMsMjksMTU4LDIyNSwyNDgsMTUyLDE3LDEwNSwyMTcsMTQyLDE0OCwxNTUsMzAsMTM1LDIzMywyMDYsODUsNDAsMjIzLDE0MCwxNjEsMTM3LDEzLDE5MSwyMzAsNjYsMTA0LDY1LDE1Myw0NSwxNSwxNzYsODQsMTg3LDIyXTt2YXIgU2k9WzgyLDksMTA2LDIxMyw0OCw1NCwxNjUsNTYsMTkxLDY0LDE2MywxNTgsMTI5LDI0MywyMTUsMjUxLDEyNCwyMjcsNTcsMTMwLDE1NSw0NywyNTUsMTM1LDUyLDE0Miw2Nyw2OCwxOTYsMjIyLDIzMywyMDMsODQsMTIzLDE0OCw1MCwxNjYsMTk0LDM1LDYxLDIzOCw3NiwxNDksMTEsNjYsMjUwLDE5NSw3OCw4LDQ2LDE2MSwxMDIsNDAsMjE3LDM2LDE3OCwxMTgsOTEsMTYyLDczLDEwOSwxMzksMjA5LDM3LDExNCwyNDgsMjQ2LDEwMCwxMzQsMTA0LDE1MiwyMiwyMTIsMTY0LDkyLDIwNCw5MywxMDEsMTgyLDE0NiwxMDgsMTEyLDcyLDgwLDI1MywyMzcsMTg1LDIxOCw5NCwyMSw3MCw4NywxNjcsMTQxLDE1NywxMzIsMTQ0LDIxNiwxNzEsMCwxNDAsMTg4LDIxMSwxMCwyNDcsMjI4LDg4LDUsMTg0LDE3OSw2OSw2LDIwOCw0NCwzMCwxNDMsMjAyLDYzLDE1LDIsMTkzLDE3NSwxODksMywxLDE5LDEzOCwxMDcsNTgsMTQ1LDE3LDY1LDc5LDEwMywyMjAsMjM0LDE1MSwyNDIsMjA3LDIwNiwyNDAsMTgwLDIzMCwxMTUsMTUwLDE3MiwxMTYsMzQsMjMxLDE3Myw1MywxMzMsMjI2LDI0OSw1NSwyMzIsMjgsMTE3LDIyMywxMTAsNzEsMjQxLDI2LDExMywyOSw0MSwxOTcsMTM3LDExMSwxODMsOTgsMTQsMTcwLDI0LDE5MCwyNywyNTIsODYsNjIsNzUsMTk4LDIxMCwxMjEsMzIsMTU0LDIxOSwxOTIsMjU0LDEyMCwyMDUsOTAsMjQ0LDMxLDIyMSwxNjgsNTEsMTM2LDcsMTk5LDQ5LDE3NywxOCwxNiw4OSwzOSwxMjgsMjM2LDk1LDk2LDgxLDEyNywxNjksMjUsMTgxLDc0LDEzLDQ1LDIyOSwxMjIsMTU5LDE0NywyMDEsMTU2LDIzOSwxNjAsMjI0LDU5LDc3LDE3NCw0MiwyNDUsMTc2LDIwMCwyMzUsMTg3LDYwLDEzMSw4MywxNTMsOTcsMjMsNDMsNCwxMjYsMTg2LDExOSwyMTQsMzgsMjI1LDEwNSwyMCw5OSw4NSwzMywxMiwxMjVdO3ZhciBUMT1bMzMyODQwMjM0MSw0MTY4OTA3OTA4LDQwMDA4MDY4MDksNDEzNTI4NzY5Myw0Mjk0MTExNzU3LDM1OTczNjQxNTcsMzczMTg0NTA0MSwyNDQ1NjU3NDI4LDE2MTM3NzA4MzIsMzM2MjAyMjcsMzQ2Mjg4MzI0MSwxNDQ1NjY5NzU3LDM4OTIyNDgwODksMzA1MDgyMTQ3NCwxMzAzMDk2Mjk0LDM5NjcxODY1ODYsMjQxMjQzMTk0MSw1Mjg2NDY4MTMsMjMxMTcwMjg0OCw0MjAyNTI4MTM1LDQwMjYyMDI2NDUsMjk5MjIwMDE3MSwyMzg3MDM2MTA1LDQyMjY4NzEzMDcsMTEwMTkwMTI5MiwzMDE3MDY5NjcxLDE2MDQ0OTQwNzcsMTE2OTE0MTczOCw1OTc0NjYzMDMsMTQwMzI5OTA2MywzODMyNzA1Njg2LDI2MTMxMDA2MzUsMTk3NDk3NDQwMiwzNzkxNTE5MDA0LDEwMzMwODE3NzQsMTI3NzU2ODYxOCwxODE1NDkyMTg2LDIxMTgwNzQxNzcsNDEyNjY2ODU0NiwyMjExMjM2OTQzLDE3NDgyNTE3NDAsMTM2OTgxMDQyMCwzNTIxNTA0NTY0LDQxOTMzODI2NjQsMzc5OTA4NTQ1OSwyODgzMTE1MTIzLDE2NDczOTEwNTksNzA2MDI0NzY3LDEzNDQ4MDkwOCwyNTEyODk3ODc0LDExNzY3MDc5NDEsMjY0Njg1MjQ0Niw4MDY4ODU0MTYsOTMyNjE1ODQxLDE2ODEwMTEzNSw3OTg2NjEzMDEsMjM1MzQxNTc3LDYwNTE2NDA4Niw0NjE0MDYzNjMsMzc1NjE4ODIyMSwzNDU0NzkwNDM4LDEzMTExODg4NDEsMjE0MjQxNzYxMywzOTMzNTY2MzY3LDMwMjU4MjA0Myw0OTUxNTgxNzQsMTQ3OTI4OTk3Miw4NzQxMjU4NzAsOTA3NzQ2MDkzLDM2OTgyMjQ4MTgsMzAyNTgyMDM5OCwxNTM3MjUzNjI3LDI3NTY4NTg2MTQsMTk4MzU5MzI5MywzMDg0MzEwMTEzLDIxMDg5Mjg5NzQsMTM3ODQyOTMwNywzNzIyNjk5NTgyLDE1ODAxNTA2NDEsMzI3NDUxNzk5LDI3OTA0Nzg4MzcsMzExNzUzNTU5MiwwLDMyNTM1OTU0MzYsMTA3NTg0NzI2NCwzODI1MDA3NjQ3LDIwNDE2ODg1MjAsMzA1OTQ0MDYyMSwzNTYzNzQzOTM0LDIzNzg5NDMzMDIsMTc0MDU1Mzk0NSwxOTE2MzUyODQzLDI0ODc4OTY3OTgsMjU1NTEzNzIzNiwyOTU4NTc5OTQ0LDIyNDQ5ODg3NDYsMzE1MTAyNDIzNSwzMzIwODM1ODgyLDEzMzY1ODQ5MzMsMzk5MjcxNDAwNiwyMjUyNTU1MjA1LDI1ODg3NTc0NjMsMTcxNDYzMTUwOSwyOTM5NjMxNTYsMjMxOTc5NTY2MywzOTI1NDczNTUyLDY3MjQwNDU0LDQyNjk3Njg1NzcsMjY4OTYxODE2MCwyMDE3MjEzNTA4LDYzMTIxODEwNiwxMjY5MzQ0NDgzLDI3MjMyMzgzODcsMTU3MTAwNTQzOCwyMTUxNjk0NTI4LDkzMjk0NDc0LDEwNjY1NzA0MTMsNTYzOTc3NjYwLDE4ODI3MzI2MTYsNDA1OTQyODEwMCwxNjczMzEzNTAzLDIwMDg0NjMwNDEsMjk1MDM1NTU3MywxMTA5NDY3NDkxLDUzNzkyMzYzMiwzODU4NzU5NDUwLDQyNjA2MjMxMTgsMzIxODI2NDY4NSwyMTc3NzQ4MzAwLDQwMzQ0MjcwOCw2Mzg3ODQzMDksMzI4NzA4NDA3OSwzMTkzOTIxNTA1LDg5OTEyNzIwMiwyMjg2MTc1NDM2LDc3MzI2NTIwOSwyNDc5MTQ2MDcxLDE0MzcwNTA4NjYsNDIzNjE0ODM1NCwyMDUwODMzNzM1LDMzNjIwMjI1NzIsMzEyNjY4MTA2Myw4NDA1MDU2NDMsMzg2NjMyNTkwOSwzMjI3NTQxNjY0LDQyNzkxNzcyMCwyNjU1OTk3OTA1LDI3NDkxNjA1NzUsMTE0MzA4NzcxOCwxNDEyMDQ5NTM0LDk5OTMyOTk2MywxOTM0OTcyMTksMjM1MzQxNTg4MiwzMzU0MzI0NTIxLDE4MDcyNjgwNTEsNjcyNDA0NTQwLDI4MTY0MDEwMTcsMzE2MDMwMTI4MiwzNjk4MjI0OTMsMjkxNjg2NjkzNCwzNjg4OTQ3NzcxLDE2ODEwMTEyODYsMTk0OTk3MzA3MCwzMzYyMDIyNzAsMjQ1NDI3NjU3MSwyMDE3MjEzNTQsMTIxMDMyODE3MiwzMDkzMDYwODM2LDI2ODAzNDEwODUsMzE4NDc3NjA0NiwxMTM1Mzg5OTM1LDMyOTQ3ODIxMTgsOTY1ODQxMzIwLDgzMTg4Njc1NiwzNTU0OTkzMjA3LDQwNjgwNDcyNDMsMzU4ODc0NTAxMCwyMzQ1MTkxNDkxLDE4NDkxMTI0MDksMzY2NDYwNDU5OSwyNjA1NDAyOCwyOTgzNTgxMDI4LDI2MjIzNzc2ODIsMTIzNTg1NTg0MCwzNjMwOTg0MzcyLDI4OTEzMzk1MTQsNDA5MjkxNjc0MywzNDg4Mjc5MDc3LDMzOTU2NDI3OTksNDEwMTY2NzQ3MCwxMjAyNjMwMzc3LDI2ODk2MTgxNiwxODc0NTA4NTAxLDQwMzQ0MjcwMTYsMTI0Mzk0ODM5OSwxNTQ2NTMwNDE4LDk0MTM2NjMwOCwxNDcwNTM5NTA1LDE5NDEyMjI1OTksMjU0NjM4NjUxMywzNDIxMDM4NjI3LDI3MTU2NzE5MzIsMzg5OTk0NjE0MCwxMDQyMjI2OTc3LDI1MjE1MTcwMjEsMTYzOTgyNDg2MCwyMjcyNDkwMzAsMjYwNzM3NjY5LDM3NjU0NjUyMzIsMjA4NDQ1Mzk1NCwxOTA3NzMzOTU2LDM0MjkyNjMwMTgsMjQyMDY1NjM0NCwxMDA4NjA2NzcsNDE2MDE1NzE4NSw0NzA2ODMxNTQsMzI2MTE2MTg5MSwxNzgxODcxOTY3LDI5MjQ5NTk3MzcsMTc3Mzc3OTQwOCwzOTQ2OTIyNDEsMjU3OTYxMTk5Miw5NzQ5ODY1MzUsNjY0NzA2NzQ1LDM2NTU0NTkxMjgsMzk1ODk2MjE5NSw3MzE0MjA4NTEsNTcxNTQzODU5LDM1MzAxMjM3MDcsMjg0OTYyNjQ4MCwxMjY3ODMxMTMsODY1Mzc1Mzk5LDc2NTE3MjY2MiwxMDA4NjA2NzU0LDM2MTIwMzYwMiwzMzg3NTQ5OTg0LDIyNzg0NzczODUsMjg1NzcxOTI5NSwxMzQ0ODA5MDgwLDI3ODI5MTIzNzgsNTk1NDI2NzEsMTUwMzc2NDk4NCwxNjAwMDg1NzYsNDM3MDYyOTM1LDE3MDcwNjUzMDYsMzYyMjIzMzY0OSwyMjE4OTM0OTgyLDM0OTY1MDM0ODAsMjE4NTMxNDc1NSw2OTc5MzIyMDgsMTUxMjkxMDE5OSw1MDQzMDMzNzcsMjA3NTE3NzE2MywyODI0MDk5MDY4LDE4NDEwMTk4NjIsNzM5NjQ0OTg2XTt2YXIgVDI9WzI3ODEyNDIyMTEsMjIzMDg3NzMwOCwyNTgyNTQyMTk5LDIzODE3NDA5MjMsMjM0ODc3NjgyLDMxODQ5NDYwMjcsMjk4NDE0NDc1MSwxNDE4ODM5NDkzLDEzNDg0ODEwNzIsNTA0NjI5NzcsMjg0ODg3NjM5MSwyMTAyNzk5MTQ3LDQzNDYzNDQ5NCwxNjU2MDg0NDM5LDM4NjM4NDk4OTksMjU5OTE4ODA4NiwxMTY3MDUxNDY2LDI2MzYwODc5MzgsMTA4Mjc3MTkxMywyMjgxMzQwMjg1LDM2ODA0ODg5MCwzOTU0MzM0MDQxLDMzODE1NDQ3NzUsMjAxMDYwNTkyLDM5NjM3MjcyNzcsMTczOTgzODY3Niw0MjUwOTAzMjAyLDM5MzA0MzU1MDMsMzIwNjc4MjEwOCw0MTQ5NDUzOTg4LDI1MzE1NTM5MDYsMTUzNjkzNDA4MCwzMjYyNDk0NjQ3LDQ4NDU3MjY2OSwyOTIzMjcxMDU5LDE3ODMzNzUzOTgsMTUxNzA0MTIwNiwxMDk4NzkyNzY3LDQ5Njc0MjMxLDEzMzQwMzc3MDgsMTU1MDMzMjk4MCw0MDk4OTkxNTI1LDg4NjE3MTEwOSwxNTA1OTgxMjksMjQ4MTA5MDkyOSwxOTQwNjQyMDA4LDEzOTg5NDQwNDksMTA1OTcyMjUxNywyMDE4NTE5MDgsMTM4NTU0NzcxOSwxNjk5MDk1MzMxLDE1ODczOTc1NzEsNjc0MjQwNTM2LDI3MDQ3NzQ4MDYsMjUyMzE0ODg1LDMwMzk3OTU4NjYsMTUxOTE0MjQ3LDkwODMzMzU4NiwyNjAyMjcwODQ4LDEwMzgwODI3ODYsNjUxMDI5NDgzLDE3NjY3Mjk1MTEsMzQ0NzY5ODA5OCwyNjgyOTQyODM3LDQ1NDE2Njc5MywyNjUyNzM0MzM5LDE5NTE5MzU1MzIsNzc1MTY2NDkwLDc1ODUyMDYwMywzMDAwNzkwNjM4LDQwMDQ3OTcwMTgsNDIxNzA4NjExMiw0MTM3OTY0MTE0LDEyOTk1OTQwNDMsMTYzOTQzODAzOCwzNDY0MzQ0NDk5LDIwNjg5ODIwNTcsMTA1NDcyOTE4NywxOTAxOTk3ODcxLDI1MzQ2Mzg3MjQsNDEyMTMxODIyNywxNzU3MDA4MzM3LDAsNzUwOTA2ODYxLDE2MTQ4MTUyNjQsNTM1MDM1MTMyLDMzNjM0MTg1NDUsMzk4ODE1MTEzMSwzMjAxNTkxOTE0LDExODM2OTc4NjcsMzY0NzQ1NDkxMCwxMjY1Nzc2OTUzLDM3MzQyNjAyOTgsMzU2Njc1MDc5NiwzOTAzODcxMDY0LDEyNTAyODM0NzEsMTgwNzQ3MDgwMCw3MTc2MTUwODcsMzg0NzIwMzQ5OCwzODQ2OTUyOTEsMzMxMzkxMDU5NSwzNjE3MjEzNzczLDE0MzI3NjExMzksMjQ4NDE3NjI2MSwzNDgxOTQ1NDEzLDI4Mzc2OTMzNywxMDA5MjU5NTQsMjE4MDkzOTY0Nyw0MDM3MDM4MTYwLDExNDg3MzA0MjgsMzEyMzAyNzg3MSwzODEzMzg2NDA4LDQwODc1MDExMzcsNDI2NzU0OTYwMywzMjI5NjMwNTI4LDIzMTU2MjAyMzksMjkwNjYyNDY1OCwzMTU2MzE5NjQ1LDEyMTUzMTM5NzYsODI5NjYwMDUsMzc0Nzg1NTU0OCwzMjQ1ODQ4MjQ2LDE5NzQ0NTkwOTgsMTY2NTI3ODI0MSw4MDc0MDc2MzIsNDUxMjgwODk1LDI1MTUyNDA4MywxODQxMjg3ODkwLDEyODM1NzUyNDUsMzM3MTIwMjY4LDg5MTY4NzY5OSw4MDEzNjkzMjQsMzc4NzM0OTg1NSwyNzIxNDIxMjA3LDM0MzE0ODI0MzYsOTU5MzIxODc5LDE0NjkzMDE5NTYsNDA2NTY5OTc1MSwyMTk3NTg1NTM0LDExOTkxOTM0MDUsMjg5ODgxNDA1MiwzODg3NzUwNDkzLDcyNDcwMzUxMywyNTE0OTA4MDE5LDI2OTY5NjIxNDQsMjU1MTgwODM4NSwzNTE2ODEzMTM1LDIxNDE0NDUzNDAsMTcxNTc0MTIxOCwyMTE5NDQ1MDM0LDI4NzI4MDc1NjgsMjE5ODU3MTE0NCwzMzk4MTkwNjYyLDcwMDk2ODY4NiwzNTQ3MDUyMjE2LDEwMDkyNTk1NDAsMjA0MTA0NDcwMiwzODAzOTk1NzQyLDQ4Nzk4Mzg4MywxOTkxMTA1NDk5LDEwMDQyNjU2OTYsMTQ0OTQwNzAyNiwxMzE2MjM5OTMwLDUwNDYyOTc3MCwzNjgzNzk3MzIxLDE2ODU2MDEzNCwxODE2NjY3MTcyLDM4MzcyODc1MTYsMTU3MDc1MTE3MCwxODU3OTM0MjkxLDQwMTQxODk3NDAsMjc5Nzg4ODA5OCwyODIyMzQ1MTA1LDI3NTQ3MTI5ODEsOTM2NjMzNTcyLDIzNDc5MjM4MzMsODUyODc5MzM1LDExMzMyMzQzNzYsMTUwMDM5NTMxOSwzMDg0NTQ1Mzg5LDIzNDg5MTIwMTMsMTY4OTM3NjIxMywzNTMzNDU5MDIyLDM3NjI5MjM5NDUsMzAzNDA4MjQxMiw0MjA1NTk4Mjk0LDEzMzQyODQ2OCw2MzQzODMwODIsMjk0OTI3NzAyOSwyMzk4Mzg2ODEwLDM5MTM3ODkxMDIsNDAzNzAzODE2LDM1ODA4NjkzMDYsMjI5NzQ2MDg1NiwxODY3MTMwMTQ5LDE5MTg2NDM3NTgsNjA3NjU2OTg4LDQwNDkwNTMzNTAsMzM0NjI0ODg4NCwxMzY4OTAxMzE4LDYwMDU2NTk5MiwyMDkwOTgyODc3LDI2MzI0Nzk4NjAsNTU3NzE5MzI3LDM3MTc2MTQ0MTEsMzY5NzM5MzA4NSwyMjQ5MDM0NjM1LDIyMzIzODgyMzQsMjQzMDYyNzk1MiwxMTE1NDM4NjU0LDMyOTU3ODY0MjEsMjg2NTUyMjI3OCwzNjMzMzM0MzQ0LDg0MjgwMDY3LDMzMDI3ODMwLDMwMzgyODQ5NCwyNzQ3NDI1MTIxLDE2MDA3OTU5NTcsNDE4ODk1MjQwNywzNDk2NTg5NzUzLDI0MzQyMzgwODYsMTQ4NjQ3MTYxNyw2NTgxMTk5NjUsMzEwNjM4MTQ3MCw5NTM4MDMyMzMsMzM0MjMxODAwLDMwMDU5Nzg3NzYsODU3ODcwNjA5LDMxNTExMjg5MzcsMTg5MDE3OTU0NSwyMjk4OTczODM4LDI4MDUxNzU0NDQsMzA1NjQ0MjI2Nyw1NzQzNjUyMTQsMjQ1MDg4NDQ4Nyw1NTAxMDM1MjksMTIzMzYzNzA3MCw0Mjg5MzUzMDQ1LDIwMTg1MTkwODAsMjA1NzY5MTEwMywyMzk5Mzc0NDc2LDQxNjY2MjM2NDksMjE0ODEwODY4MSwzODc1ODMyNDUsMzY2NDEwMTMxMSw4MzYyMzI5MzQsMzMzMDU1NjQ4MiwzMTAwNjY1OTYwLDMyODAwOTM1MDUsMjk1NTUxNjMxMywyMDAyMzk4NTA5LDI4NzE4MjYwNywzNDEzODgxMDA4LDQyMzg4OTAwNjgsMzU5NzUxNTcwNyw5NzU5Njc3NjZdO3ZhciBUMz1bMTY3MTgwODYxMSwyMDg5MDg5MTQ4LDIwMDY1NzY3NTksMjA3MjkwMTI0Myw0MDYxMDAzNzYyLDE4MDc2MDMzMDcsMTg3MzkyNzc5MSwzMzEwNjUzODkzLDgxMDU3Mzg3MiwxNjk3NDMzNywxNzM5MTgxNjcxLDcyOTYzNDM0Nyw0MjYzMTEwNjU0LDM2MTM1NzA1MTksMjg4Mzk5NzA5OSwxOTg5ODY0NTY2LDMzOTM1NTY0MjYsMjE5MTMzNTI5OCwzMzc2NDQ5OTkzLDIxMDYwNjM0ODUsNDE5NTc0MTY5MCwxNTA4NjE4ODQxLDEyMDQzOTE0OTUsNDAyNzMxNzIzMiwyOTE3OTQxNjc3LDM1NjM1NjYwMzYsMjczNDUxNDA4MiwyOTUxMzY2MDYzLDI2Mjk3NzIxODgsMjc2NzY3MjIyOCwxOTIyNDkxNTA2LDMyMjcyMjkxMjAsMzA4Mjk3NDY0Nyw0MjQ2NTI4NTA5LDI0Nzc2Njk3NzksNjQ0NTAwNTE4LDkxMTg5NTYwNiwxMDYxMjU2NzY3LDQxNDQxNjYzOTEsMzQyNzc2MzE0OCw4Nzg0NzEyMjAsMjc4NDI1MjMyNSwzODQ1NDQ0MDY5LDQwNDM4OTczMjksMTkwNTUxNzE2OSwzNjMxNDU5Mjg4LDgyNzU0ODIwOSwzNTY0NjEwNzcsNjc4OTczNDgsMzM0NDA3ODI3OSw1OTM4Mzk2NTEsMzI3Nzc1Nzg5MSw0MDUyODY5MzYsMjUyNzE0NzkyNiw4NDg3MTY4NSwyNTk1NTY1NDY2LDExODAzMzkyNywzMDU1MzgwNjYsMjE1NzY0ODc2OCwzNzk1NzA1ODI2LDM5NDUxODg4NDMsNjYxMjEyNzExLDI5OTk4MTIwMTgsMTk3MzQxNDUxNywxNTI3NjkwMzMsMjIwODE3NzUzOSw3NDU4MjIyNTIsNDM5MjM1NjEwLDQ1NTk0NzgwMywxODU3MjE1NTk4LDE1MjU1OTMxNzgsMjcwMDgyNzU1MiwxMzkxODk1NjM0LDk5NDkzMjI4MywzNTk2NzI4Mjc4LDMwMTY2NTQyNTksNjk1OTQ3ODE3LDM4MTI1NDgwNjcsNzk1OTU4ODMxLDIyMjQ0OTM0NDQsMTQwODYwNzgyNywzNTEzMzAxNDU3LDAsMzk3OTEzMzQyMSw1NDMxNzg3ODQsNDIyOTk0ODQxMiwyOTgyNzA1NTg1LDE1NDIzMDUzNzEsMTc5MDg5MTExNCwzNDEwMzk4NjY3LDMyMDE5MTg5MTAsOTYxMjQ1NzUzLDEyNTYxMDA5MzgsMTI4OTAwMTAzNiwxNDkxNjQ0NTA0LDM0Nzc3Njc2MzEsMzQ5NjcyMTM2MCw0MDEyNTU3ODA3LDI4NjcxNTQ4NTgsNDIxMjU4MzkzMSwxMTM3MDE4NDM1LDEzMDU5NzUzNzMsODYxMjM0NzM5LDIyNDEwNzM1NDEsMTE3MTIyOTI1Myw0MTc4NjM1MjU3LDMzOTQ4Njc0LDIxMzkyMjU3MjcsMTM1Nzk0Njk2MCwxMDExMTIwMTg4LDI2Nzk3NzY2NzEsMjgzMzQ2ODMyOCwxMzc0OTIxMjk3LDI3NTEzNTYzMjMsMTA4NjM1NzU2OCwyNDA4MTg3Mjc5LDI0NjA4Mjc1MzgsMjY0NjM1MjI4NSw5NDQyNzE0MTYsNDExMDc0MjAwNSwzMTY4NzU2NjY4LDMwNjYxMzI0MDYsMzY2NTE0NTgxOCw1NjAxNTMxMjEsMjcxNTg5MzkyLDQyNzk5NTI4OTUsNDA3Nzg0NjAwMywzNTMwNDA3ODkwLDM0NDQzNDMyNDUsMjAyNjQzNDY4LDMyMjI1MDI1OSwzOTYyNTUzMzI0LDE2MDg2Mjk4NTUsMjU0Mzk5MDE2NywxMTU0MjU0OTE2LDM4OTYyMzMxOSwzMjk0MDczNzk2LDI4MTc2NzY3MTEsMjEyMjUxMzUzNCwxMDI4MDk0NTI1LDE2ODkwNDUwOTIsMTU3NTQ2NzYxMyw0MjIyNjEyNzMsMTkzOTIwMzY5OSwxNjIxMTQ3NzQ0LDIxNzQyMjg4NjUsMTMzOTEzNzYxNSwzNjk5MzUyNTQwLDU3NzEyNzQ1OCw3MTI5MjIxNTQsMjQyNzE0MTAwOCwyMjkwMjg5NTQ0LDExODc2NzkzMDIsMzk5NTcxNTU2NiwzMTAwODYzNDE2LDMzOTQ4Njc0MCwzNzMyNTE0NzgyLDE1OTE5MTc2NjIsMTg2NDU1NTYzLDM2ODE5ODgwNTksMzc2MjAxOTI5Niw4NDQ1MjI1NDYsOTc4MjIwMDkwLDE2OTc0MzM3MCwxMjM5MTI2NjAxLDEwMTMyMTczNCw2MTEwNzYxMzIsMTU1ODQ5MzI3NiwzMjYwOTE1NjUwLDM1NDcyNTAxMzEsMjkwMTM2MTU4MCwxNjU1MDk2NDE4LDI0NDM3MjExMDUsMjUxMDU2NTc4MSwzODI4ODYzOTcyLDIwMzkyMTQ3MTMsMzg3ODg2ODQ1NSwzMzU5ODY5ODk2LDkyODYwNzc5OSwxODQwNzY1NTQ5LDIzNzQ3NjI4OTMsMzU4MDE0NjEzMywxMzIyNDI1NDIyLDI4NTAwNDg0MjUsMTgyMzc5MTIxMiwxNDU5MjY4Njk0LDQwOTQxNjE5MDgsMzkyODM0NjYwMiwxNzA2MDE5NDI5LDIwNTYxODkwNTAsMjkzNDUyMzgyMiwxMzU3OTQ2OTYsMzEzNDU0OTk0NiwyMDIyMjQwMzc2LDYyODA1MDQ2OSw3NzkyNDY2MzgsNDcyMTM1NzA4LDI4MDA4MzQ0NzAsMzAzMjk3MDE2NCwzMzI3MjM2MDM4LDM4OTQ2NjAwNzIsMzcxNTkzMjYzNywxOTU2NDQwMTgwLDUyMjI3MjI4NywxMjcyODEzMTMxLDMxODUzMzY3NjUsMjM0MDgxODMxNSwyMzIzOTc2MDc0LDE4ODg1NDI4MzIsMTA0NDU0NDU3NCwzMDQ5NTUwMjYxLDE3MjI0Njk0NzgsMTIyMjE1MjI2NCw1MDY2MDg2Nyw0MTI3MzI0MTUwLDIzNjA2Nzg1NCwxNjM4MTIyMDgxLDg5NTQ0NTU1NywxNDc1OTgwODg3LDMxMTc0NDM1MTMsMjI1NzY1NTY4NiwzMjQzODA5MjE3LDQ4OTExMDA0NSwyNjYyOTM0NDMwLDM3Nzg1OTkzOTMsNDE2MjA1NTE2MCwyNTYxODc4OTM2LDI4ODU2MzcyOSwxNzczOTE2Nzc3LDM2NDgwMzkzODUsMjM5MTM0NTAzOCwyNDkzOTg1Njg0LDI2MTI0MDc3MDcsNTA1NTYwMDk0LDIyNzQ0OTc5MjcsMzkxMTI0MDE2OSwzNDYwOTI1MzkwLDE0NDI4MTg2NDUsNjc4OTczNDgwLDM3NDkzNTcwMjMsMjM1ODE4Mjc5NiwyNzE3NDA3NjQ5LDIzMDY4Njk2NDEsMjE5NjE3ODA1LDMyMTg3NjExNTEsMzg2MjAyNjIxNCwxMTIwMzA2MjQyLDE3NTY5NDI0NDAsMTEwMzMzMTkwNSwyNTc4NDU5MDMzLDc2Mjc5NjU4OSwyNTI3ODAwNDcsMjk2NjEyNTQ4OCwxNDI1ODQ0MzA4LDMxNTEzOTIxODcsMzcyOTExMTI2XTt2YXIgVDQ9WzE2Njc0NzQ4ODYsMjA4ODUzNTI4OCwyMDA0MzI2ODk0LDIwNzE2OTQ4MzgsNDA3NTk0OTU2NywxODAyMjIzMDYyLDE4Njk1OTEwMDYsMzMxODA0Mzc5Myw4MDg0NzI2NzIsMTY4NDM1MjIsMTczNDg0NjkyNiw3MjQyNzA0MjIsNDI3ODA2NTYzOSwzNjIxMjE2OTQ5LDI4ODAxNjk1NDksMTk4NzQ4NDM5NiwzNDAyMjUzNzExLDIxODk1OTc5ODMsMzM4NTQwOTY3MywyMTA1Mzc4ODEwLDQyMTA2OTM2MTUsMTQ5OTA2NTI2NiwxMTk1ODg2OTkwLDQwNDIyNjM1NDcsMjkxMzg1NjU3NywzNTcwNjg5OTcxLDI3Mjg1OTA2ODcsMjk0NzU0MTU3MywyNjI3NTE4MjQzLDI3NjIyNzQ2NDMsMTkyMDExMjM1NiwzMjMzODMxODM1LDMwODIyNzMzOTcsNDI2MTIyMzY0OSwyNDc1OTI5MTQ5LDY0MDA1MTc4OCw5MDk1MzE3NTYsMTA2MTExMDE0Miw0MTYwMTYwNTAxLDM0MzU5NDE3NjMsODc1ODQ2NzYwLDI3NzkxMTY2MjUsMzg1NzAwMzcyOSw0MDU5MTA1NTI5LDE5MDMyNjg4MzQsMzYzODA2NDA0Myw4MjUzMTYxOTQsMzUzNzEzOTYyLDY3Mzc0MDg4LDMzNTE3Mjg3ODksNTg5NTIyMjQ2LDMyODQzNjA4NjEsNDA0MjM2MzM2LDI1MjY0NTQwNzEsODQyMTc2MTAsMjU5MzgzMDE5MSwxMTc5MDE1ODIsMzAzMTgzMzk2LDIxNTU5MTE5NjMsMzgwNjQ3Nzc5MSwzOTU4MDU2NjUzLDY1Njg5NDI4NiwyOTk4MDYyNDYzLDE5NzA2NDI5MjIsMTUxNTkxNjk4LDIyMDY0NDA5ODksNzQxMTEwODcyLDQzNzkyMzM4MCw0NTQ3NjU4NzgsMTg1Mjc0ODUwOCwxNTE1OTA4Nzg4LDI2OTQ5MDQ2NjcsMTM4MTE2ODgwNCw5OTM3NDIxOTgsMzYwNDM3Mzk0MywzMDE0OTA1NDY5LDY5MDU4NDQwMiwzODIzMzIwNzk3LDc5MTYzODM2NiwyMjIzMjgxOTM5LDEzOTgwMTEzMDIsMzUyMDE2MTk3NywwLDM5OTE3NDM2ODEsNTM4OTkyNzA0LDQyNDQzODE2NjcsMjk4MTIxODQyNSwxNTMyNzUxMjg2LDE3ODUzODA1NjQsMzQxOTA5NjcxNywzMjAwMTc4NTM1LDk2MDA1NjE3OCwxMjQ2NDIwNjI4LDEyODAxMDM1NzYsMTQ4MjIyMTc0NCwzNDg2NDY4NzQxLDM1MDMzMTk5OTUsNDAyNTQyODY3NywyODYzMzI2NTQzLDQyMjc1MzY2MjEsMTEyODUxNDk1MCwxMjk2OTQ3MDk4LDg1OTAwMjIxNCwyMjQwMTIzOTIxLDExNjIyMDMwMTgsNDE5Mzg0OTU3NywzMzY4NzA0NCwyMTM5MDYyNzgyLDEzNDc0ODE3NjAsMTAxMDU4MjY0OCwyNjc4MDQ1MjIxLDI4Mjk2NDA1MjMsMTM2NDMyNTI4MiwyNzQ1NDMzNjkzLDEwNzc5ODU0MDgsMjQwODU0ODg2OSwyNDU5MDg2MTQzLDI2NDQzNjAyMjUsOTQzMjEyNjU2LDQxMjY0NzU1MDUsMzE2NjQ5NDU2MywzMDY1NDMwMzkxLDM2NzE3NTAwNjMsNTU1ODM2MjI2LDI2OTQ5NjM1Miw0Mjk0OTA4NjQ1LDQwOTI3OTI1NzMsMzUzNzAwNjAxNSwzNDUyNzgzNzQ1LDIwMjExODE2OCwzMjAwMjU4OTQsMzk3NDkwMTY5OSwxNjAwMTE5MjMwLDI1NDMyOTcwNzcsMTE0NTM1OTQ5NiwzODczOTc5MzQsMzMwMTIwMTgxMSwyODEyODAxNjIxLDIxMjIyMjAyODQsMTAyNzQyNjE3MCwxNjg0MzE5NDMyLDE1NjY0MzUyNTgsNDIxMDc5ODU4LDE5MzY5NTQ4NTQsMTYxNjk0NTM0NCwyMTcyNzUzOTQ1LDEzMzA2MzEwNzAsMzcwNTQzODExNSw1NzI2Nzk3NDgsNzA3NDI3OTI0LDI0MjU0MDAxMjMsMjI5MDY0NzgxOSwxMTc5MDQ0NDkyLDQwMDg1ODU2NzEsMzA5OTEyMDQ5MSwzMzY4NzA0NDAsMzczOTEyMjA4NywxNTgzMjc2NzMyLDE4NTI3NzcxOCwzNjg4NTkzMDY5LDM3NzI3OTE3NzEsODQyMTU5NzE2LDk3Njg5OTcwMCwxNjg0MzUyMjAsMTIyOTU3NzEwNiwxMDEwNTkwODQsNjA2MzY2NzkyLDE1NDk1OTE3MzYsMzI2NzUxNzg1NSwzNTUzODQ5MDIxLDI4OTcwMTQ1OTUsMTY1MDYzMjM4OCwyNDQyMjQyMTA1LDI1MDk2MTIwODEsMzg0MDE2MTc0NywyMDM4MDA4ODE4LDM4OTA2ODg3MjUsMzM2ODU2NzY5MSw5MjYzNzQyNTQsMTgzNTkwNzAzNCwyMzc0ODYzODczLDM1ODc1MzE5NTMsMTMxMzc4ODU3MiwyODQ2NDgyNTA1LDE4MTkwNjM1MTIsMTQ0ODU0MDg0NCw0MTA5NjMzNTIzLDM5NDEyMTM2NDcsMTcwMTE2Mjk1NCwyMDU0ODUyMzQwLDI5MzA2OTg1NjcsMTM0NzQ4MTc2LDMxMzI4MDY1MTEsMjAyMTE2NTI5Niw2MjMyMTAzMTQsNzc0Nzk1ODY4LDQ3MTYwNjMyOCwyNzk1OTU4NjE1LDMwMzE3NDY0MTksMzMzNDg4NTc4MywzOTA3NTI3NjI3LDM3MjIyODAwOTcsMTk1Mzc5OTQwMCw1MjIxMzM4MjIsMTI2MzI2MzEyNiwzMTgzMzM2NTQ1LDIzNDExNzY4NDUsMjMyNDMzMzgzOSwxODg2NDI1MzEyLDEwNDQyNjc2NDQsMzA0ODU4ODQwMSwxNzE4MDA0NDI4LDEyMTI3MzM1ODQsNTA1Mjk1NDIsNDE0MzMxNzQ5NSwyMzU4MDMxNjQsMTYzMzc4ODg2Niw4OTI2OTAyODIsMTQ2NTM4MzM0MiwzMTE1OTYyNDczLDIyNTY5NjU5MTEsMzI1MDY3MzgxNyw0ODg0NDk4NTAsMjY2MTIwMjIxNSwzNzg5NjMzNzUzLDQxNzcwMDc1OTUsMjU2MDE0NDE3MSwyODYzMzk4NzQsMTc2ODUzNzA0MiwzNjU0OTA2MDI1LDIzOTE3MDU4NjMsMjQ5Mjc3MDA5OSwyNjEwNjczMTk3LDUwNTI5MTMyNCwyMjczODA4OTE3LDM5MjQzNjk2MDksMzQ2OTYyNTczNSwxNDMxNjk5MzcwLDY3Mzc0MDg4MCwzNzU1OTY1MDkzLDIzNTgwMjE4OTEsMjcxMTc0NjY0OSwyMzA3NDg5ODAxLDIxODk2MTY5MCwzMjE3MDIxNTQxLDM4NzM4NDU3MTksMTExMTY3MjQ1MiwxNzUxNjkzNTIwLDEwOTQ4Mjg5MzAsMjU3Njk4NjE1Myw3NTc5NTQzOTQsMjUyNjQ1NjYyLDI5NjQzNzY0NDMsMTQxNDg1NTg0OCwzMTQ5NjQ5NTE3LDM3MDU1NTQzNl07dmFyIFQ1PVsxMzc0OTg4MTEyLDIxMTgyMTQ5OTUsNDM3NzU3MTIzLDk3NTY1ODY0NiwxMDAxMDg5OTk1LDUzMDQwMDc1MywyOTAyMDg3ODUxLDEyNzMxNjg3ODcsNTQwMDgwNzI1LDI5MTAyMTk3NjYsMjI5NTEwMTA3Myw0MTEwNTY4NDg1LDEzNDA0NjMxMDAsMzMwNzkxNjI0Nyw2NDEwMjUxNTIsMzA0MzE0MDQ5NSwzNzM2MTY0OTM3LDYzMjk1MzcwMywxMTcyOTY3MDY0LDE1NzY5NzY2MDksMzI3NDY2NzI2NiwyMTY5MzAzMDU4LDIzNzAyMTM3OTUsMTgwOTA1NDE1MCw1OTcyNzg0NywzNjE5Mjk4NzcsMzIxMTYyMzE0NywyNTA1MjAyMTM4LDM1NjkyNTUyMTMsMTQ4NDAwNTg0MywxMjM5NDQzNzUzLDIzOTU1ODg2NzYsMTk3NTY4MzQzNCw0MTAyOTc3OTEyLDI1NzI2OTcxOTUsNjY2NDY0NzMzLDMyMDI0MzcwNDYsNDAzNTQ4OTA0NywzMzc0MzYxNzAyLDIxMTA2Njc0NDQsMTY3NTU3Nzg4MCwzODQzNjk5MDc0LDI1Mzg2ODExODQsMTY0OTYzOTIzNywyOTc2MTUxNTIwLDMxNDQzOTY0MjAsNDI2OTkwNzk5Niw0MTc4MDYyMjI4LDE4ODM3OTM0OTYsMjQwMzcyODY2NSwyNDk3NjA0NzQzLDEzODM4NTYzMTEsMjg3NjQ5NDYyNywxOTE3NTE4NTYyLDM4MTA0OTYzNDMsMTcxNjg5MDQxMCwzMDAxNzU1NjU1LDgwMDQ0MDgzNSwyMjYxMDg5MTc4LDM1NDM1OTkyNjksODA3OTYyNjEwLDU5OTc2MjM1NCwzMzc3ODM2MiwzOTc3Njc1MzU2LDIzMjg4Mjg5NzEsMjgwOTc3MTE1NCw0MDc3Mzg0NDMyLDEzMTU1NjIxNDUsMTcwODg0ODMzMywxMDEwMzk4MjksMzUwOTg3MTEzNSwzMjk5Mjc4NDc0LDg3NTQ1MTI5MywyNzMzODU2MTYwLDkyOTg3Njk4LDI3Njc2NDU1NTcsMTkzMTk1MDY1LDEwODAwOTQ2MzQsMTU4NDUwNDU4MiwzMTc4MTA2OTYxLDEwNDIzODU2NTcsMjUzMTA2NzQ1MywzNzExODI5NDIyLDEzMDY5NjczNjYsMjQzODIzNzYyMSwxOTA4Njk0Mjc3LDY3NTU2NDYzLDE2MTU4NjEyNDcsNDI5NDU2MTY0LDM2MDI3NzAzMjcsMjMwMjY5MDI1MiwxNzQyMzE1MTI3LDI5NjgwMTE0NTMsMTI2NDU0NjY0LDM4NzcxOTg2NDgsMjA0MzIxMTQ4MywyNzA5MjYwODcxLDIwODQ3MDQyMzMsNDE2OTQwODIwMSwwLDE1OTQxNzk4Nyw4NDE3Mzk1OTIsNTA0NDU5NDM2LDE4MTc4NjY4MzAsNDI0NTYxODY4MywyNjAzODg5NTAsMTAzNDg2Nzk5OCw5MDg5MzM0MTUsMTY4ODEwODUyLDE3NTA5MDIzMDUsMjYwNjQ1Mzk2OSw2MDc1MzA1NTQsMjAyMDA4NDk3LDI0NzIwMTE1MzUsMzAzNTUzNTA1OCw0NjMxODAxOTAsMjE2MDExNzA3MSwxNjQxODE2MjI2LDE1MTc3Njc1MjksNDcwOTQ4Mzc0LDM4MDEzMzIyMzQsMzIzMTcyMjIxMywxMDA4OTE4NTk1LDMwMzc2NTI3NywyMzU0NzQxODcsNDA2OTI0Njg5Myw3NjY5NDU0NjUsMzM3NTUzODY0LDE0NzU0MTg1MDEsMjk0MzY4MjM4MCw0MDAzMDYxMTc5LDI3NDMwMzQxMDksNDE0NDA0Nzc3NSwxNTUxMDM3ODg0LDExNDc1NTA2NjEsMTU0MzIwODUwMCwyMzM2NDM0NTUwLDM0MDgxMTk1MTYsMzA2OTA0OTk2MCwzMTAyMDExNzQ3LDM2MTAzNjkyMjYsMTExMzgxODM4NCwzMjg2NzE4MDgsMjIyNzU3MzAyNCwyMjM2MjI4NzMzLDM1MzU0ODY0NTYsMjkzNTU2Njg2NSwzMzQxMzk0Mjg1LDQ5NjkwNjA1OSwzNzAyNjY1NDU5LDIyNjkwNjg2MCwyMDA5MTk1NDcyLDczMzE1Njk3MiwyODQyNzM3MDQ5LDI5NDkzMDY4MiwxMjA2NDc3ODU4LDI4MzUxMjMzOTYsMjcwMDA5OTM1NCwxNDUxMDQ0MDU2LDU3MzgwNDc4MywyMjY5NzI4NDU1LDM2NDQzNzk1ODUsMjM2MjA5MDIzOCwyNTY0MDMzMzM0LDI4MDExMDc0MDcsMjc3NjI5MjkwNCwzNjY5NDYyNTY2LDEwNjgzNTEzOTYsNzQyMDM5MDEyLDEzNTAwNzg5ODksMTc4NDY2MzE5NSwxNDE3NTYxNjk4LDQxMzY0NDA3NzAsMjQzMDEyMjIxNiw3NzU1NTA4MTQsMjE5Mzg2MjY0NSwyNjczNzA1MTUwLDE3NzUyNzY5MjQsMTg3NjI0MTgzMywzNDc1MzEzMzMxLDMzNjY3NTQ2MTksMjcwMDQwNDg3LDM5MDI1NjMxODIsMzY3ODEyNDkyMywzNDQxODUwMzc3LDE4NTEzMzI4NTIsMzk2OTU2MjM2OSwyMjAzMDMyMjMyLDM4Njg1NTI4MDUsMjg2ODg5NzQwNiw1NjYwMjE4OTYsNDAxMTE5MDUwMiwzMTM1NzQwODg5LDEyNDg4MDI1MTAsMzkzNjI5MTI4NCw2OTk0MzIxNTAsODMyODc3MjMxLDcwODc4MDg0OSwzMzMyNzQwMTQ0LDg5OTgzNTU4NCwxOTUxMzE3MDQ3LDQyMzY0Mjk5OTAsMzc2NzU4Njk5Miw4NjY2Mzc4NDUsNDA0MzYxMDE4NiwxMTA2MDQxNTkxLDIxNDQxNjE4MDYsMzk1NDQxNzExLDE5ODQ4MTI2ODUsMTEzOTc4MTcwOSwzNDMzNzEyOTgwLDM4MzUwMzY4OTUsMjY2NDU0MzcxNSwxMjgyMDUwMDc1LDMyNDA4OTQzOTIsMTE4MTA0NTExOSwyNjQwMjQzMjA0LDI1OTY1OTE3LDQyMDMxODExNzEsNDIxMTgxODc5OCwzMDA5ODc5Mzg2LDI0NjM4Nzk3NjIsMzkxMDE2MTk3MSwxODQyNzU5NDQzLDI1OTc4MDY0NzYsOTMzMzAxMzcwLDE1MDk0MzA0MTQsMzk0MzkwNjQ0MSwzNDY3MTkyMzAyLDMwNzY2MzkwMjksMzc3Njc2NzQ2OSwyMDUxNTE4NzgwLDI2MzEwNjU0MzMsMTQ0MTk1MjU3NSw0MDQwMTY3NjEsMTk0MjQzNTc3NSwxNDA4NzQ5MDM0LDE2MTA0NTk3MzksMzc0NTM0NTMwMCwyMDE3Nzc4NTY2LDM0MDA1Mjg3NjksMzExMDY1MDk0Miw5NDE4OTY3NDgsMzI2NTQ3ODc1MSwzNzEwNDkzMzAsMzE2ODkzNzIyOCw2NzUwMzk2MjcsNDI3OTA4MDI1Nyw5NjczMTE3MjksMTM1MDUwMjA2LDM2MzU3MzM2NjAsMTY4MzQwNzI0OCwyMDc2OTM1MjY1LDM1NzY4NzA1MTIsMTIxNTA2MTEwOCwzNTAxNzQxODkwXTt2YXIgVDY9WzEzNDc1NDgzMjcsMTQwMDc4MzIwNSwzMjczMjY3MTA4LDI1MjAzOTM1NjYsMzQwOTY4NTM1NSw0MDQ1MzgwOTMzLDI4ODAyNDAyMTYsMjQ3MTIyNDA2NywxNDI4MTczMDUwLDQxMzg1NjMxODEsMjQ0MTY2MTU1OCw2MzY4MTM5MDAsNDIzMzA5NDYxNSwzNjIwMDIyOTg3LDIxNDk5ODc2NTIsMjQxMTAyOTE1NSwxMjM5MzMxMTYyLDE3MzA1MjU3MjMsMjU1NDcxODczNCwzNzgxMDMzNjY0LDQ2MzQ2MTAxLDMxMDQ2MzcyOCwyNzQzOTQ0ODU1LDMzMjg5NTUzODUsMzg3NTc3MDIwNywyNTAxMjE4OTcyLDM5NTUxOTExNjIsMzY2NzIxOTAzMyw3Njg5MTcxMjMsMzU0NTc4OTQ3Myw2OTI3MDc0MzMsMTE1MDIwODQ1NiwxNzg2MTAyNDA5LDIwMjkyOTMxNzcsMTgwNTIxMTcxMCwzNzEwMzY4MTEzLDMwNjU5NjI4MzEsNDAxNjM5NTk3LDE3MjQ0NTcxMzIsMzAyODE0MzY3NCw0MDkxOTg0MTAsMjE5NjA1MjUyOSwxNjIwNTI5NDU5LDExNjQwNzE4MDcsMzc2OTcyMTk3NSwyMjI2ODc1MzEwLDQ4NjQ0MTM3NiwyNDk5MzQ4NTIzLDE0ODM3NTM1NzYsNDI4ODE5OTY1LDIyNzQ2ODA0MjgsMzA3NTYzNjIxNiw1OTg0Mzg4NjcsMzc5OTE0MTEyMiwxNDc0NTAyNTQzLDcxMTM0OTY3NSwxMjkxNjYxMjAsNTM0NTgzNzAsMjU5MjUyMzY0MywyNzgyMDgyODI0LDQwNjMyNDIzNzUsMjk4ODY4NzI2OSwzMTIwNjk0MTIyLDE1NTkwNDE2NjYsNzMwNTE3Mjc2LDI0NjA0NDkyMDQsNDA0MjQ1OTEyMiwyNzA2MjcwNjkwLDM0NDYwMDQ0NjgsMzU3Mzk0MTY5NCw1MzM4MDQxMzAsMjMyODE0MzYxNCwyNjM3NDQyNjQzLDI2OTUwMzM2ODUsODM5MjI0MDMzLDE5NzM3NDUzODcsOTU3MDU1OTgwLDI4NTYzNDU4MzksMTA2ODUyNzY3LDEzNzEzNjg5NzYsNDE4MTU5ODYwMiwxMDMzMjk3MTU4LDI5MzM3MzQ5MTcsMTE3OTUxMDQ2MSwzMDQ2MjAwNDYxLDkxMzQxOTE3LDE4NjI1MzQ4NjgsNDI4NDUwMjAzNyw2MDU2NTczMzksMjU0NzQzMjkzNywzNDMxNTQ2OTQ3LDIwMDMyOTQ2MjIsMzE4MjQ4NzYxOCwyMjgyMTk1MzM5LDk1NDY2OTQwMywzNjgyMTkxNTk4LDEyMDE3NjUzODYsMzkxNzIzNDcwMywzMzg4NTA3MTY2LDAsMjE5ODQzODAyMiwxMjExMjQ3NTk3LDI4ODc2NTE2OTYsMTMxNTcyMzg5MCw0MjI3NjY1NjYzLDE0NDM4NTc3MjAsNTA3MzU4OTMzLDY1Nzg2MTk0NSwxNjc4MzgxMDE3LDU2MDQ4NzU5MCwzNTE2NjE5NjA0LDk3NTQ1MTY5NCwyOTcwMzU2MzI3LDI2MTMxNDUzNSwzNTM1MDcyOTE4LDI2NTI2MDk0MjUsMTMzMzgzODAyMSwyNzI0MzIyMzM2LDE3Njc1MzY0NTksMzcwOTM4Mzk0LDE4MjYyMTExNCwzODU0NjA2Mzc4LDExMjgwMTQ1NjAsNDg3NzI1ODQ3LDE4NTQ2OTE5NywyOTE4MzUzODYzLDMxMDY3ODA4NDAsMzM1Njc2MTc2OSwyMjM3MTMzMDgxLDEyODY1NjcxNzUsMzE1Mjk3NjM0OSw0MjU1MzUwNjI0LDI2ODM3NjUwMzAsMzE2MDE3NTM0OSwzMzA5NTk0MTcxLDg3ODQ0MzM5MCwxOTg4ODM4MTg1LDM3MDQzMDA0ODYsMTc1NjgxODk0MCwxNjczMDYxNjE3LDM0MDMxMDA2MzYsMjcyNzg2MzA5LDEwNzUwMjU2OTgsNTQ1NTcyMzY5LDIxMDU4ODcyNjgsNDE3NDU2MDA2MSwyOTY2Nzk3MzAsMTg0MTc2ODg2NSwxMjYwMjMyMjM5LDQwOTEzMjcwMjQsMzk2MDMwOTMzMCwzNDk3NTA5MzQ3LDE4MTQ4MDMyMjIsMjU3ODAxODQ4OSw0MTk1NDU2MDcyLDU3NTEzODE0OCwzMjk5NDA5MDM2LDQ0Njc1NDg3OSwzNjI5NTQ2Nzk2LDQwMTE5OTYwNDgsMzM0NzUzMjExMCwzMjUyMjM4NTQ1LDQyNzA2Mzk3NzgsOTE1OTg1NDE5LDM0ODM4MjU1MzcsNjgxOTMzNTM0LDY1MTg2ODA0NiwyNzU1NjM2NjcxLDM4MjgxMDM4MzcsMjIzMzc3NTU0LDI2MDc0Mzk4MjAsMTY0OTcwNDUxOCwzMjcwOTM3ODc1LDM5MDE4MDY3NzYsMTU4MDA4Nzc5OSw0MTE4OTg3Njk1LDMxOTgxMTUyMDAsMjA4NzMwOTQ1OSwyODQyNjc4NTczLDMwMTY2OTcxMDYsMTAwMzAwNzEyOSwyODAyODQ5OTE3LDE4NjA3MzgxNDcsMjA3Nzk2NTI0MywxNjQ0Mzk2NzIsNDEwMDg3MjQ3MiwzMjI4MzMxOSwyODI3MTc3ODgyLDE3MDk2MTAzNTAsMjEyNTEzNTg0NiwxMzY0Mjg3NTEsMzg3NDQyODM5MiwzNjUyOTA0ODU5LDM0NjA5ODQ2MzAsMzU3MjE0NTkyOSwzNTkzMDU2MzgwLDI5MzkyNjYyMjYsODI0ODUyMjU5LDgxODMyNDg4NCwzMjI0NzQwNDU0LDkzMDM2OTIxMiwyODAxNTY2NDEwLDI5Njc1MDcxNTIsMzU1NzA2ODQwLDEyNTczMDkzMzYsNDE0ODI5MjgyNiwyNDMyNTY2NTYsNzkwMDczODQ2LDIzNzMzNDA2MzAsMTI5NjI5NzkwNCwxNDIyNjk5MDg1LDM3NTYyOTk3ODAsMzgxODgzNjQwNSw0NTc5OTI4NDAsMzA5OTY2NzQ4NywyMTM1MzE5ODg5LDc3NDIyMzE0LDE1NjAzODI1MTcsMTk0NTc5ODUxNiw3ODgyMDQzNTMsMTUyMTcwNjc4MSwxMzg1MzU2MjQyLDg3MDkxMjA4NiwzMjU5NjUzODMsMjM1ODk1NzkyMSwyMDUwNDY2MDYwLDIzODgyNjA4ODQsMjMxMzg4NDQ3Niw0MDA2NTIxMTI3LDkwMTIxMDU2OSwzOTkwOTUzMTg5LDEwMTQ2NDY3MDUsMTUwMzQ0OTgyMywxMDYyNTk3MjM1LDIwMzE2MjEzMjYsMzIxMjAzNTg5NSwzOTMxMzcxNDY5LDE1MzMwMTc1MTQsMzUwMTc0NTc1LDIyNTYwMjg4OTEsMjE3NzU0NDE3OSwxMDUyMzM4MzcyLDc0MTg3Njc4OCwxNjA2NTkxMjk2LDE5MTQwNTIwMzUsMjEzNzA1MjUzLDIzMzQ2Njk4OTcsMTEwNzIzNDE5NywxODk5NjAzOTY5LDM3MjUwNjk0OTEsMjYzMTQ0Nzc4MCwyNDIyNDk0OTEzLDE2MzU1MDI5ODAsMTg5MzAyMDM0MiwxOTUwOTAzMzg4LDExMjA5NzQ5MzVdO3ZhciBUNz1bMjgwNzA1ODkzMiwxNjk5OTcwNjI1LDI3NjQyNDk2MjMsMTU4NjkwMzU5MSwxODA4NDgxMTk1LDExNzM0MzAxNzMsMTQ4NzY0NTk0Niw1OTk4NDg2Nyw0MTk5ODgyODAwLDE4NDQ4ODI4MDYsMTk4OTI0OTIyOCwxMjc3NTU1OTcwLDM2MjM2MzY5NjUsMzQxOTkxNTU2MiwxMTQ5MjQ5MDc3LDI3NDQxMDQyOTAsMTUxNDc5MDU3Nyw0NTk3NDQ2OTgsMjQ0ODYwMzk0LDMyMzU5OTUxMzQsMTk2MzExNTMxMSw0MDI3NzQ0NTg4LDI1NDQwNzgxNTAsNDE5MDUzMDUxNSwxNjA4OTc1MjQ3LDI2MjcwMTYwODIsMjA2MjI3MDMxNywxNTA3NDk3Mjk4LDIyMDA4MTg4NzgsNTY3NDk4ODY4LDE3NjQzMTM1NjgsMzM1OTkzNjIwMSwyMzA1NDU1NTU0LDIwMzc5NzAwNjIsMTA0NzIzOWUzLDE5MTAzMTkwMzMsMTMzNzM3NjQ4MSwyOTA0MDI3MjcyLDI4OTI0MTczMTIsOTg0OTA3MjE0LDEyNDMxMTI0MTUsODMwNjYxOTE0LDg2MTk2ODIwOSwyMTM1MjUzNTg3LDIwMTEyMTQxODAsMjkyNzkzNDMxNSwyNjg2MjU0NzIxLDczMTE4MzM2OCwxNzUwNjI2Mzc2LDQyNDYzMTA3MjUsMTgyMDgyNDc5OCw0MTcyNzYzNzcxLDM1NDIzMzAyMjcsNDgzOTQ4MjcsMjQwNDkwMTY2MywyODcxNjgyNjQ1LDY3MTU5MzE5NSwzMjU0OTg4NzI1LDIwNzM3MjQ2MTMsMTQ1MDg1MjM5LDIyODA3OTYyMDAsMjc3OTkxNTE5OSwxNzkwNTc1MTA3LDIxODcxMjgwODYsNDcyNjE1NjMxLDMwMjk1MTAwMDksNDA3NTg3NzEyNywzODAyMjIyMTg1LDQxMDcxMDE2NTgsMzIwMTYzMTc0OSwxNjQ2MjUyMzQwLDQyNzA1MDcxNzQsMTQwMjgxMTQzOCwxNDM2NTkwODM1LDM3NzgxNTE4MTgsMzk1MDM1NTcwMiwzOTYzMTYxNDc1LDQwMjA5MTIyMjQsMjY2Nzk5NDczNywyNzM3OTIzNjYsMjMzMTU5MDE3NywxMDQ2OTk2MTMsOTUzNDU5ODIsMzE3NTUwMTI4NiwyMzc3NDg2Njc2LDE1NjA2Mzc4OTIsMzU2NDA0NTMxOCwzNjkwNTc4NzIsNDIxMzQ0NzA2NCwzOTE5MDQyMjM3LDExMzc0Nzc5NTIsMjY1ODYyNTQ5NywxMTE5NzI3ODQ4LDIzNDA5NDc4NDksMTUzMDQ1NTgzMyw0MDA3MzYwOTY4LDE3MjQ2NjU1NiwyNjY5NTk5MzgsNTE2NTUyODM2LDAsMjI1NjczNDU5MiwzOTgwOTMxNjI3LDE4OTAzMjgwODEsMTkxNzc0MjE3MCw0Mjk0NzA0Mzk4LDk0NTE2NDE2NSwzNTc1NTI4ODc4LDk1ODg3MTA4NSwzNjQ3MjEyMDQ3LDI3ODcyMDcyNjAsMTQyMzAyMjkzOSw3NzU1NjIyOTQsMTczOTY1NjIwMiwzODc2NTU3NjU1LDI1MzAzOTEyNzgsMjQ0MzA1ODA3NSwzMzEwMzIxODU2LDU0NzUxMjc5NiwxMjY1MTk1NjM5LDQzNzY1NjU5NCwzMTIxMjc1NTM5LDcxOTcwMDEyOCwzNzYyNTAyNjkwLDM4Nzc4MTE0NywyMTg4MjgyOTcsMzM1MDA2NTgwMywyODMwNzA4MTUwLDI4NDg0NjE4NTQsNDI4MTY5MjAxLDEyMjQ2NjE2NSwzNzIwMDgxMDQ5LDE2MjcyMzUxOTksNjQ4MDE3NjY1LDQxMjI3NjIzNTQsMTAwMjc4Mzg0NiwyMTE3MzYwNjM1LDY5NTYzNDc1NSwzMzM2MzU4NjkxLDQyMzQ3MjEwMDUsNDA0OTg0NDQ1MiwzNzA0MjgwODgxLDIyMzI0MzUyOTksNTc0NjI0NjYzLDI4NzM0MzgxNCw2MTIyMDU4OTgsMTAzOTcxNzA1MSw4NDAwMTk3MDUsMjcwODMyNjE4NSw3OTM0NTE5MzQsODIxMjg4MTE0LDEzOTEyMDE2NzAsMzgyMjA5MDE3NywzNzYxODc4MjcsMzExMzg1NTM0NCwxMjI0MzQ4MDUyLDE2Nzk5NjgyMzMsMjM2MTY5ODU1NiwxMDU4NzA5NzQ0LDc1MjM3NTQyMSwyNDMxNTkwOTYzLDEzMjE2OTkxNDUsMzUxOTE0MjIwMCwyNzM0NTkxMTc4LDE4ODEyNzQ0NCwyMTc3ODY5NTU3LDM3MjcyMDU3NTQsMjM4NDkxMTAzMSwzMjE1MjEyNDYxLDI2NDg5NzY0NDIsMjQ1MDM0NjEwNCwzNDMyNzM3Mzc1LDExODA4NDkyNzgsMzMxNTQ0MjA1LDMxMDIyNDkxNzYsNDE1MDE0NDU2OSwyOTUyMTAyNTk1LDIxNTk5NzYyODUsMjQ3NDQwNDMwNCw3NjYwNzg5MzMsMzEzNzczODYxLDI1NzA4MzIwNDQsMjEwODEwMDYzMiwxNjY4MjEyODkyLDMxNDU0NTY0NDMsMjAxMzkwODI2Miw0MTg2NzIyMTcsMzA3MDM1NjYzNCwyNTk0NzM0OTI3LDE4NTIxNzE5MjUsMzg2NzA2MDk5MSwzNDczNDE2NjM2LDM5MDc0NDg1OTcsMjYxNDczNzYzOSw5MTk0ODkxMzUsMTY0OTQ4NjM5LDIwOTQ0MTAxNjAsMjk5NzgyNTk1Niw1OTA0MjQ2MzksMjQ4NjIyNDU0OSwxNzIzODcyNjc0LDMxNTc3NTA4NjIsMzM5OTk0MTI1MCwzNTAxMjUyNzUyLDM2MjUyNjgxMzUsMjU1NTA0ODE5NiwzNjczNjM3MzU2LDEzNDMxMjc1MDEsNDEzMDI4MTM2MSwzNTk5NTk1MDg1LDI5NTc4NTM2NzksMTI5NzQwMzA1MCw4MTc4MTkxMCwzMDUxNTkzNDI1LDIyODM0OTA0MTAsNTMyMjAxNzcyLDEzNjcyOTU1ODksMzkyNjE3MDk3NCw4OTUyODc2OTIsMTk1Mzc1NzgzMSwxMDkzNTk3OTYzLDQ5MjQ4MzQzMSwzNTI4NjI2OTA3LDE0NDYyNDI1NzYsMTE5MjQ1NTYzOCwxNjM2NjA0NjMxLDIwOTMzNjIyNSwzNDQ4NzM0NjQsMTAxNTY3MTU3MSw2Njk5NjE4OTcsMzM3NTc0MDc2OSwzODU3NTcyMTI0LDI5NzM1MzA2OTUsMzc0NzE5MjAxOCwxOTMzNTMwNjEwLDM0NjQwNDI1MTYsOTM1MjkzODk1LDM0NTQ2ODYxOTksMjg1ODExNTA2OSwxODYzNjM4ODQ1LDM2ODMwMjI5MTYsNDA4NTM2OTUxOSwzMjkyNDQ1MDMyLDg3NTMxMzE4OCwxMDgwMDE3NTcxLDMyNzkwMzM4ODUsNjIxNTkxNzc4LDEyMzM4NTY1NzIsMjUwNDEzMDMxNywyNDE5NzU0NCwzMDE3NjcyNzE2LDM4MzU0ODQzNDAsMzI0NzQ2NTU1OCwyMjIwOTgxMTk1LDMwNjA4NDc5MjIsMTU1MTEyNDU4OCwxNDYzOTk2NjAwXTt2YXIgVDg9WzQxMDQ2MDU3NzcsMTA5NzE1OTU1MCwzOTY2NzM4MTgsNjYwNTEwMjY2LDI4NzU5NjgzMTUsMjYzODYwNjYyMyw0MjAwMTE1MTE2LDM4MDg2NjIzNDcsODIxNzEyMTYwLDE5ODY5MTgwNjEsMzQzMDMyMjU2OCwzODU0NDg4NSwzODU2MTM3Mjk1LDcxODAwMjExNyw4OTM2ODE3MDIsMTY1NDg4NjMyNSwyOTc1NDg0MzgyLDMxMjIzNTgwNTMsMzkyNjgyNTAyOSw0Mjc0MDUzNDY5LDc5NjE5NzU3MSwxMjkwODAxNzkzLDExODQzNDI5MjUsMzU1NjM2MTgzNSwyNDA1NDI2OTQ3LDI0NTk3MzUzMTcsMTgzNjc3MjI4NywxMzgxNjIwMzczLDMxOTYyNjc5ODgsMTk0ODM3Mzg0OCwzNzY0OTg4MjMzLDMzODUzNDUxNjYsMzI2Mzc4NTU4OSwyMzkwMzI1NDkyLDE0ODA0ODU3ODUsMzExMTI0NzE0MywzNzgwMDk3NzI2LDIyOTMwNDUyMzIsNTQ4MTY5NDE3LDM0NTk5NTM3ODksMzc0NjE3NTA3NSw0Mzk0NTIzODksMTM2MjMyMTU1OSwxNDAwODQ5NzYyLDE2ODU1Nzc5MDUsMTgwNjU5OTM1NSwyMTc0NzU0MDQ2LDEzNzA3MzkxMywxMjE0Nzk3OTM2LDExNzQyMTUwNTUsMzczMTY1NDU0OCwyMDc5ODk3NDI2LDE5NDMyMTcwNjcsMTI1ODQ4MDI0Miw1Mjk0ODc4NDMsMTQzNzI4MDg3MCwzOTQ1MjY5MTcwLDMwNDkzOTA4OTUsMzMxMzIxMjAzOCw5MjMzMTM2MTksNjc5OTk4ZTMsMzIxNTMwNzI5OSw1NzMyNjA4MiwzNzc2NDIyMjEsMzQ3NDcyOTg2NiwyMDQxODc3MTU5LDEzMzM2MTkwNywxNzc2NDYwMTEwLDM2NzM0NzY0NTMsOTYzOTI0NTQsODc4ODQ1OTA1LDI4MDE2OTk1MjQsNzc3MjMxNjY4LDQwODI0NzUxNzAsMjMzMDAxNDIxMyw0MTQyNjI2MjEyLDIyMTMyOTYzOTUsMTYyNjMxOTQyNCwxOTA2MjQ3MjYyLDE4NDY1NjMyNjEsNTYyNzU1OTAyLDM3MDgxNzM3MTgsMTA0MDU1OTgzNywzODcxMTYzOTgxLDE0MTg1NzMyMDEsMzI5NDQzMDU3NywxMTQ1ODUzNDgsMTM0MzYxODkxMiwyNTY2NTk1NjA5LDMxODYyMDI1ODIsMTA3ODE4NTA5NywzNjUxMDQxMTI3LDM4OTY2ODgwNDgsMjMwNzYyMjkxOSw0MjU0MDg3NDMsMzM3MTA5Njk1MywyMDgxMDQ4NDgxLDExMDgzMzkwNjgsMjIxNjYxMDI5NiwwLDIxNTYyOTkwMTcsNzM2OTcwODAyLDI5MjU5Njc2NiwxNTE3NDQwNjIwLDI1MTY1NzIxMywyMjM1MDYxNzc1LDI5MzMyMDI0OTMsNzU4NzIwMzEwLDI2NTkwNTE2MiwxNTU0MzkxNDAwLDE1MzIyODUzMzksOTA4OTk5MjA0LDE3NDU2NzY5MiwxNDc0NzYwNTk1LDQwMDI4NjE3NDgsMjYxMDAxMTY3NSwzMjM0MTU2NDE2LDM2OTMxMjYyNDEsMjAwMTQzMDg3NCwzMDM2OTk0ODQsMjQ3ODQ0MzIzNCwyNjg3MTY1ODg4LDU4NTEyMjYyMCw0NTQ0OTk2MDIsMTUxODQ5NzQyLDIzNDUxMTkyMTgsMzA2NDUxMDc2NSw1MTQ0NDMyODQsNDA0NDk4MTU5MSwxOTYzNDEyNjU1LDI1ODE0NDU2MTQsMjEzNzA2MjgxOSwxOTMwODUzNSwxOTI4NzA3MTY0LDE3MTUxOTMxNTYsNDIxOTM1MjE1NSwxMTI2NzkwNzk1LDYwMDIzNTIxMSwzOTkyNzQyMDcwLDM4NDEwMjQ5NTIsODM2NTUzNDMxLDE2Njk2NjQ4MzQsMjUzNTYwNDI0MywzMzIzMDExMjA0LDEyNDM5MDU0MTMsMzE0MTQwMDc4Niw0MTgwODA4MTEwLDY5ODQ0NTI1NSwyNjUzODk5NTQ5LDI5ODk1NTI2MDQsMjI1MzU4MTMyNSwzMjUyOTMyNzI3LDMwMDQ1OTExNDcsMTg5MTIxMTY4OSwyNDg3ODEwNTc3LDM5MTU2NTM3MDMsNDIzNzA4MzgxNiw0MDMwNjY3NDI0LDIxMDAwOTA5NjYsODY1MTM2NDE4LDEyMjk4OTk2NTUsOTUzMjcwNzQ1LDMzOTk2Nzk2MjgsMzU1NzUwNDY2NCw0MTE4OTI1MjIyLDIwNjEzNzk3NDksMzA3OTU0NjU4NiwyOTE1MDE3NzkxLDk4MzQyNjA5MiwyMDIyODM3NTg0LDE2MDcyNDQ2NTAsMjExODU0MTkwOCwyMzY2ODgyNTUwLDM2MzU5OTY4MTYsOTcyNTEyODE0LDMyODMwODg3NzAsMTU2ODcxODQ5NSwzNDk5MzI2NTY5LDM1NzY1Mzk1MDMsNjIxOTgyNjcxLDI4OTU3MjM0NjQsNDEwODg3OTUyLDI2MjM3NjIxNTIsMTAwMjE0MjY4Myw2NDU0MDEwMzcsMTQ5NDgwNzY2MiwyNTk1Njg0ODQ0LDEzMzU1MzU3NDcsMjUwNzA0MDIzMCw0MjkzMjk1Nzg2LDMxNjc2ODQ2NDEsMzY3NTg1MDA3LDM4ODU3NTA3MTQsMTg2NTg2MjczMCwyNjY4MjIxNjc0LDI5NjA5NzEzMDUsMjc2MzE3MzY4MSwxMDU5MjcwOTU0LDI3Nzc5NTI0NTQsMjcyNDY0Mjg2OSwxMzIwOTU3ODEyLDIxOTQzMTkxMDAsMjQyOTU5NTg3MiwyODE1OTU2Mjc1LDc3MDg5NTIxLDM5NzM3NzMxMjEsMzQ0NDU3NTg3MSwyNDQ4ODMwMjMxLDEzMDU5MDY1NTAsNDAyMTMwODczOSwyODU3MTk0NzAwLDI1MTY5MDE4NjAsMzUxODM1ODQzMCwxNzg3MzA0NzgwLDc0MDI3NjQxNywxNjk5ODM5ODE0LDE1OTIzOTQ5MDksMjM1MjMwNzQ1NywyMjcyNTU2MDI2LDE4ODgyMTI0MywxNzI5OTc3MDExLDM2ODc5OTQwMDIsMjc0MDg0ODQxLDM1OTQ5ODIyNTMsMzYxMzQ5NDQyNiwyNzAxOTQ5NDk1LDQxNjIwOTY3MjksMzIyNzM0NTcxLDI4Mzc5NjY1NDIsMTY0MDU3NjQzOSw0ODQ4MzA2ODksMTIwMjc5NzY5MCwzNTM3ODUyODI4LDQwNjc2MzkxMjUsMzQ5MDc1NzM2LDMzNDIzMTk0NzUsNDE1NzQ2NzIxOSw0MjU1ODAwMTU5LDEwMzA2OTAwMTUsMTE1NTIzNzQ5NiwyOTUxOTcxMjc0LDE3NTc2OTE1NzcsNjA3Mzk4OTY4LDI3Mzg5MDUwMjYsNDk5MzQ3OTkwLDM3OTQwNzg5MDgsMTAxMTQ1MjcxMiwyMjc4ODU1NjcsMjgxODY2NjgwOSwyMTMxMTQzNzYsMzAzNDg4MTI0MCwxNDU1NTI1OTg4LDM0MTQ0NTA1NTUsODUwODE3MjM3LDE4MTc5OTg0MDgsMzA5MjcyNjQ4MF07dmFyIFUxPVswLDIzNTQ3NDE4Nyw0NzA5NDgzNzQsMzAzNzY1Mjc3LDk0MTg5Njc0OCw5MDg5MzM0MTUsNjA3NTMwNTU0LDcwODc4MDg0OSwxODgzNzkzNDk2LDIxMTgyMTQ5OTUsMTgxNzg2NjgzMCwxNjQ5NjM5MjM3LDEyMTUwNjExMDgsMTE4MTA0NTExOSwxNDE3NTYxNjk4LDE1MTc3Njc1MjksMzc2NzU4Njk5Miw0MDAzMDYxMTc5LDQyMzY0Mjk5OTAsNDA2OTI0Njg5MywzNjM1NzMzNjYwLDM2MDI3NzAzMjcsMzI5OTI3ODQ3NCwzNDAwNTI4NzY5LDI0MzAxMjIyMTYsMjY2NDU0MzcxNSwyMzYyMDkwMjM4LDIxOTM4NjI2NDUsMjgzNTEyMzM5NiwyODAxMTA3NDA3LDMwMzU1MzUwNTgsMzEzNTc0MDg4OSwzNjc4MTI0OTIzLDM1NzY4NzA1MTIsMzM0MTM5NDI4NSwzMzc0MzYxNzAyLDM4MTA0OTYzNDMsMzk3NzY3NTM1Niw0Mjc5MDgwMjU3LDQwNDM2MTAxODYsMjg3NjQ5NDYyNywyNzc2MjkyOTA0LDMwNzY2MzkwMjksMzExMDY1MDk0MiwyNDcyMDExNTM1LDI2NDAyNDMyMDQsMjQwMzcyODY2NSwyMTY5MzAzMDU4LDEwMDEwODk5OTUsODk5ODM1NTg0LDY2NjQ2NDczMyw2OTk0MzIxNTAsNTk3Mjc4NDcsMjI2OTA2ODYwLDUzMDQwMDc1MywyOTQ5MzA2ODIsMTI3MzE2ODc4NywxMTcyOTY3MDY0LDE0NzU0MTg1MDEsMTUwOTQzMDQxNCwxOTQyNDM1Nzc1LDIxMTA2Njc0NDQsMTg3NjI0MTgzMywxNjQxODE2MjI2LDI5MTAyMTk3NjYsMjc0MzAzNDEwOSwyOTc2MTUxNTIwLDMyMTE2MjMxNDcsMjUwNTIwMjEzOCwyNjA2NDUzOTY5LDIzMDI2OTAyNTIsMjI2OTcyODQ1NSwzNzExODI5NDIyLDM1NDM1OTkyNjksMzI0MDg5NDM5MiwzNDc1MzEzMzMxLDM4NDM2OTkwNzQsMzk0MzkwNjQ0MSw0MTc4MDYyMjI4LDQxNDQwNDc3NzUsMTMwNjk2NzM2NiwxMTM5NzgxNzA5LDEzNzQ5ODgxMTIsMTYxMDQ1OTczOSwxOTc1NjgzNDM0LDIwNzY5MzUyNjUsMTc3NTI3NjkyNCwxNzQyMzE1MTI3LDEwMzQ4Njc5OTgsODY2NjM3ODQ1LDU2NjAyMTg5Niw4MDA0NDA4MzUsOTI5ODc2OTgsMTkzMTk1MDY1LDQyOTQ1NjE2NCwzOTU0NDE3MTEsMTk4NDgxMjY4NSwyMDE3Nzc4NTY2LDE3ODQ2NjMxOTUsMTY4MzQwNzI0OCwxMzE1NTYyMTQ1LDEwODAwOTQ2MzQsMTM4Mzg1NjMxMSwxNTUxMDM3ODg0LDEwMTAzOTgyOSwxMzUwNTAyMDYsNDM3NzU3MTIzLDMzNzU1Mzg2NCwxMDQyMzg1NjU3LDgwNzk2MjYxMCw1NzM4MDQ3ODMsNzQyMDM5MDEyLDI1MzEwNjc0NTMsMjU2NDAzMzMzNCwyMzI4ODI4OTcxLDIyMjc1NzMwMjQsMjkzNTU2Njg2NSwyNzAwMDk5MzU0LDMwMDE3NTU2NTUsMzE2ODkzNzIyOCwzODY4NTUyODA1LDM5MDI1NjMxODIsNDIwMzE4MTE3MSw0MTAyOTc3OTEyLDM3MzYxNjQ5MzcsMzUwMTc0MTg5MCwzMjY1NDc4NzUxLDM0MzM3MTI5ODAsMTEwNjA0MTU5MSwxMzQwNDYzMTAwLDE1NzY5NzY2MDksMTQwODc0OTAzNCwyMDQzMjExNDgzLDIwMDkxOTU0NzIsMTcwODg0ODMzMywxODA5MDU0MTUwLDgzMjg3NzIzMSwxMDY4MzUxMzk2LDc2Njk0NTQ2NSw1OTk3NjIzNTQsMTU5NDE3OTg3LDEyNjQ1NDY2NCwzNjE5Mjk4NzcsNDYzMTgwMTkwLDI3MDkyNjA4NzEsMjk0MzY4MjM4MCwzMTc4MTA2OTYxLDMwMDk4NzkzODYsMjU3MjY5NzE5NSwyNTM4NjgxMTg0LDIyMzYyMjg3MzMsMjMzNjQzNDU1MCwzNTA5ODcxMTM1LDM3NDUzNDUzMDAsMzQ0MTg1MDM3NywzMjc0NjY3MjY2LDM5MTAxNjE5NzEsMzg3NzE5ODY0OCw0MTEwNTY4NDg1LDQyMTE4MTg3OTgsMjU5NzgwNjQ3NiwyNDk3NjA0NzQzLDIyNjEwODkxNzgsMjI5NTEwMTA3MywyNzMzODU2MTYwLDI5MDIwODc4NTEsMzIwMjQzNzA0NiwyOTY4MDExNDUzLDM5MzYyOTEyODQsMzgzNTAzNjg5NSw0MTM2NDQwNzcwLDQxNjk0MDgyMDEsMzUzNTQ4NjQ1NiwzNzAyNjY1NDU5LDM0NjcxOTIzMDIsMzIzMTcyMjIxMywyMDUxNTE4NzgwLDE5NTEzMTcwNDcsMTcxNjg5MDQxMCwxNzUwOTAyMzA1LDExMTM4MTgzODQsMTI4MjA1MDA3NSwxNTg0NTA0NTgyLDEzNTAwNzg5ODksMTY4ODEwODUyLDY3NTU2NDYzLDM3MTA0OTMzMCw0MDQwMTY3NjEsODQxNzM5NTkyLDEwMDg5MTg1OTUsNzc1NTUwODE0LDU0MDA4MDcyNSwzOTY5NTYyMzY5LDM4MDEzMzIyMzQsNDAzNTQ4OTA0Nyw0MjY5OTA3OTk2LDM1NjkyNTUyMTMsMzY2OTQ2MjU2NiwzMzY2NzU0NjE5LDMzMzI3NDAxNDQsMjYzMTA2NTQzMywyNDYzODc5NzYyLDIxNjAxMTcwNzEsMjM5NTU4ODY3NiwyNzY3NjQ1NTU3LDI4Njg4OTc0MDYsMzEwMjAxMTc0NywzMDY5MDQ5OTYwLDIwMjAwODQ5NywzMzc3ODM2MiwyNzAwNDA0ODcsNTA0NDU5NDM2LDg3NTQ1MTI5Myw5NzU2NTg2NDYsNjc1MDM5NjI3LDY0MTAyNTE1MiwyMDg0NzA0MjMzLDE5MTc1MTg1NjIsMTYxNTg2MTI0NywxODUxMzMyODUyLDExNDc1NTA2NjEsMTI0ODgwMjUxMCwxNDg0MDA1ODQzLDE0NTEwNDQwNTYsOTMzMzAxMzcwLDk2NzMxMTcyOSw3MzMxNTY5NzIsNjMyOTUzNzAzLDI2MDM4ODk1MCwyNTk2NTkxNywzMjg2NzE4MDgsNDk2OTA2MDU5LDEyMDY0Nzc4NTgsMTIzOTQ0Mzc1MywxNTQzMjA4NTAwLDE0NDE5NTI1NzUsMjE0NDE2MTgwNiwxOTA4Njk0Mjc3LDE2NzU1Nzc4ODAsMTg0Mjc1OTQ0MywzNjEwMzY5MjI2LDM2NDQzNzk1ODUsMzQwODExOTUxNiwzMzA3OTE2MjQ3LDQwMTExOTA1MDIsMzc3Njc2NzQ2OSw0MDc3Mzg0NDMyLDQyNDU2MTg2ODMsMjgwOTc3MTE1NCwyODQyNzM3MDQ5LDMxNDQzOTY0MjAsMzA0MzE0MDQ5NSwyNjczNzA1MTUwLDI0MzgyMzc2MjEsMjIwMzAzMjIzMiwyMzcwMjEzNzk1XTt2YXIgVTI9WzAsMTg1NDY5MTk3LDM3MDkzODM5NCw0ODc3MjU4NDcsNzQxODc2Nzg4LDY1Nzg2MTk0NSw5NzU0NTE2OTQsODI0ODUyMjU5LDE0ODM3NTM1NzYsMTQwMDc4MzIwNSwxMzE1NzIzODkwLDExNjQwNzE4MDcsMTk1MDkwMzM4OCwyMTM1MzE5ODg5LDE2NDk3MDQ1MTgsMTc2NzUzNjQ1OSwyOTY3NTA3MTUyLDMxNTI5NzYzNDksMjgwMTU2NjQxMCwyOTE4MzUzODYzLDI2MzE0NDc3ODAsMjU0NzQzMjkzNywyMzI4MTQzNjE0LDIxNzc1NDQxNzksMzkwMTgwNjc3NiwzODE4ODM2NDA1LDQyNzA2Mzk3NzgsNDExODk4NzY5NSwzMjk5NDA5MDM2LDM0ODM4MjU1MzcsMzUzNTA3MjkxOCwzNjUyOTA0ODU5LDIwNzc5NjUyNDMsMTg5MzAyMDM0MiwxODQxNzY4ODY1LDE3MjQ0NTcxMzIsMTQ3NDUwMjU0MywxNTU5MDQxNjY2LDExMDcyMzQxOTcsMTI1NzMwOTMzNiw1OTg0Mzg4NjcsNjgxOTMzNTM0LDkwMTIxMDU2OSwxMDUyMzM4MzcyLDI2MTMxNDUzNSw3NzQyMjMxNCw0Mjg4MTk5NjUsMzEwNDYzNzI4LDM0MDk2ODUzNTUsMzIyNDc0MDQ1NCwzNzEwMzY4MTEzLDM1OTMwNTYzODAsMzg3NTc3MDIwNywzOTYwMzA5MzMwLDQwNDUzODA5MzMsNDE5NTQ1NjA3MiwyNDcxMjI0MDY3LDI1NTQ3MTg3MzQsMjIzNzEzMzA4MSwyMzg4MjYwODg0LDMyMTIwMzU4OTUsMzAyODE0MzY3NCwyODQyNjc4NTczLDI3MjQzMjIzMzYsNDEzODU2MzE4MSw0MjU1MzUwNjI0LDM3Njk3MjE5NzUsMzk1NTE5MTE2MiwzNjY3MjE5MDMzLDM1MTY2MTk2MDQsMzQzMTU0Njk0NywzMzQ3NTMyMTEwLDI5MzM3MzQ5MTcsMjc4MjA4MjgyNCwzMDk5NjY3NDg3LDMwMTY2OTcxMDYsMjE5NjA1MjUyOSwyMzEzODg0NDc2LDI0OTkzNDg1MjMsMjY4Mzc2NTAzMCwxMTc5NTEwNDYxLDEyOTYyOTc5MDQsMTM0NzU0ODMyNywxNTMzMDE3NTE0LDE3ODYxMDI0MDksMTYzNTUwMjk4MCwyMDg3MzA5NDU5LDIwMDMyOTQ2MjIsNTA3MzU4OTMzLDM1NTcwNjg0MCwxMzY0Mjg3NTEsNTM0NTgzNzAsODM5MjI0MDMzLDk1NzA1NTk4MCw2MDU2NTczMzksNzkwMDczODQ2LDIzNzMzNDA2MzAsMjI1NjAyODg5MSwyNjA3NDM5ODIwLDI0MjI0OTQ5MTMsMjcwNjI3MDY5MCwyODU2MzQ1ODM5LDMwNzU2MzYyMTYsMzE2MDE3NTM0OSwzNTczOTQxNjk0LDM3MjUwNjk0OTEsMzI3MzI2NzEwOCwzMzU2NzYxNzY5LDQxODE1OTg2MDIsNDA2MzI0MjM3NSw0MDExOTk2MDQ4LDM4MjgxMDM4MzcsMTAzMzI5NzE1OCw5MTU5ODU0MTksNzMwNTE3Mjc2LDU0NTU3MjM2OSwyOTY2Nzk3MzAsNDQ2NzU0ODc5LDEyOTE2NjEyMCwyMTM3MDUyNTMsMTcwOTYxMDM1MCwxODYwNzM4MTQ3LDE5NDU3OTg1MTYsMjAyOTI5MzE3NywxMjM5MzMxMTYyLDExMjA5NzQ5MzUsMTYwNjU5MTI5NiwxNDIyNjk5MDg1LDQxNDgyOTI4MjYsNDIzMzA5NDYxNSwzNzgxMDMzNjY0LDM5MzEzNzE0NjksMzY4MjE5MTU5OCwzNDk3NTA5MzQ3LDM0NDYwMDQ0NjgsMzMyODk1NTM4NSwyOTM5MjY2MjI2LDI3NTU2MzY2NzEsMzEwNjc4MDg0MCwyOTg4Njg3MjY5LDIxOTg0MzgwMjIsMjI4MjE5NTMzOSwyNTAxMjE4OTcyLDI2NTI2MDk0MjUsMTIwMTc2NTM4NiwxMjg2NTY3MTc1LDEzNzEzNjg5NzYsMTUyMTcwNjc4MSwxODA1MjExNzEwLDE2MjA1Mjk0NTksMjEwNTg4NzI2OCwxOTg4ODM4MTg1LDUzMzgwNDEzMCwzNTAxNzQ1NzUsMTY0NDM5NjcyLDQ2MzQ2MTAxLDg3MDkxMjA4Niw5NTQ2Njk0MDMsNjM2ODEzOTAwLDc4ODIwNDM1MywyMzU4OTU3OTIxLDIyNzQ2ODA0MjgsMjU5MjUyMzY0MywyNDQxNjYxNTU4LDI2OTUwMzM2ODUsMjg4MDI0MDIxNiwzMDY1OTYyODMxLDMxODI0ODc2MTgsMzU3MjE0NTkyOSwzNzU2Mjk5NzgwLDMyNzA5Mzc4NzUsMzM4ODUwNzE2Niw0MTc0NTYwMDYxLDQwOTEzMjcwMjQsNDAwNjUyMTEyNywzODU0NjA2Mzc4LDEwMTQ2NDY3MDUsOTMwMzY5MjEyLDcxMTM0OTY3NSw1NjA0ODc1OTAsMjcyNzg2MzA5LDQ1Nzk5Mjg0MCwxMDY4NTI3NjcsMjIzMzc3NTU0LDE2NzgzODEwMTcsMTg2MjUzNDg2OCwxOTE0MDUyMDM1LDIwMzE2MjEzMjYsMTIxMTI0NzU5NywxMTI4MDE0NTYwLDE1ODAwODc3OTksMTQyODE3MzA1MCwzMjI4MzMxOSwxODI2MjExMTQsNDAxNjM5NTk3LDQ4NjQ0MTM3Niw3Njg5MTcxMjMsNjUxODY4MDQ2LDEwMDMwMDcxMjksODE4MzI0ODg0LDE1MDM0NDk4MjMsMTM4NTM1NjI0MiwxMzMzODM4MDIxLDExNTAyMDg0NTYsMTk3Mzc0NTM4NywyMTI1MTM1ODQ2LDE2NzMwNjE2MTcsMTc1NjgxODk0MCwyOTcwMzU2MzI3LDMxMjA2OTQxMjIsMjgwMjg0OTkxNywyODg3NjUxNjk2LDI2Mzc0NDI2NDMsMjUyMDM5MzU2NiwyMzM0NjY5ODk3LDIxNDk5ODc2NTIsMzkxNzIzNDcwMywzNzk5MTQxMTIyLDQyODQ1MDIwMzcsNDEwMDg3MjQ3MiwzMzA5NTk0MTcxLDM0NjA5ODQ2MzAsMzU0NTc4OTQ3MywzNjI5NTQ2Nzk2LDIwNTA0NjYwNjAsMTg5OTYwMzk2OSwxODE0ODAzMjIyLDE3MzA1MjU3MjMsMTQ0Mzg1NzcyMCwxNTYwMzgyNTE3LDEwNzUwMjU2OTgsMTI2MDIzMjIzOSw1NzUxMzgxNDgsNjkyNzA3NDMzLDg3ODQ0MzM5MCwxMDYyNTk3MjM1LDI0MzI1NjY1Niw5MTM0MTkxNyw0MDkxOTg0MTAsMzI1OTY1MzgzLDM0MDMxMDA2MzYsMzI1MjIzODU0NSwzNzA0MzAwNDg2LDM2MjAwMjI5ODcsMzg3NDQyODM5MiwzOTkwOTUzMTg5LDQwNDI0NTkxMjIsNDIyNzY2NTY2MywyNDYwNDQ5MjA0LDI1NzgwMTg0ODksMjIyNjg3NTMxMCwyNDExMDI5MTU1LDMxOTgxMTUyMDAsMzA0NjIwMDQ2MSwyODI3MTc3ODgyLDI3NDM5NDQ4NTVdO3ZhciBVMz1bMCwyMTg4MjgyOTcsNDM3NjU2NTk0LDM4Nzc4MTE0Nyw4NzUzMTMxODgsOTU4ODcxMDg1LDc3NTU2MjI5NCw1OTA0MjQ2MzksMTc1MDYyNjM3NiwxNjk5OTcwNjI1LDE5MTc3NDIxNzAsMjEzNTI1MzU4NywxNTUxMTI0NTg4LDEzNjcyOTU1ODksMTE4MDg0OTI3OCwxMjY1MTk1NjM5LDM1MDEyNTI3NTIsMzcyMDA4MTA0OSwzMzk5OTQxMjUwLDMzNTAwNjU4MDMsMzgzNTQ4NDM0MCwzOTE5MDQyMjM3LDQyNzA1MDcxNzQsNDA4NTM2OTUxOSwzMTAyMjQ5MTc2LDMwNTE1OTM0MjUsMjczNDU5MTE3OCwyOTUyMTAyNTk1LDIzNjE2OTg1NTYsMjE3Nzg2OTU1NywyNTMwMzkxMjc4LDI2MTQ3Mzc2MzksMzE0NTQ1NjQ0MywzMDYwODQ3OTIyLDI3MDgzMjYxODUsMjg5MjQxNzMxMiwyNDA0OTAxNjYzLDIxODcxMjgwODYsMjUwNDEzMDMxNywyNTU1MDQ4MTk2LDM1NDIzMzAyMjcsMzcyNzIwNTc1NCwzMzc1NzQwNzY5LDMyOTI0NDUwMzIsMzg3NjU1NzY1NSwzOTI2MTcwOTc0LDQyNDYzMTA3MjUsNDAyNzc0NDU4OCwxODA4NDgxMTk1LDE3MjM4NzI2NzQsMTkxMDMxOTAzMywyMDk0NDEwMTYwLDE2MDg5NzUyNDcsMTM5MTIwMTY3MCwxMTczNDMwMTczLDEyMjQzNDgwNTIsNTk5ODQ4NjcsMjQ0ODYwMzk0LDQyODE2OTIwMSwzNDQ4NzM0NjQsOTM1MjkzODk1LDk4NDkwNzIxNCw3NjYwNzg5MzMsNTQ3NTEyNzk2LDE4NDQ4ODI4MDYsMTYyNzIzNTE5OSwyMDExMjE0MTgwLDIwNjIyNzAzMTcsMTUwNzQ5NzI5OCwxNDIzMDIyOTM5LDExMzc0Nzc5NTIsMTMyMTY5OTE0NSw5NTM0NTk4MiwxNDUwODUyMzksNTMyMjAxNzcyLDMxMzc3Mzg2MSw4MzA2NjE5MTQsMTAxNTY3MTU3MSw3MzExODMzNjgsNjQ4MDE3NjY1LDMxNzU1MDEyODYsMjk1Nzg1MzY3OSwyODA3MDU4OTMyLDI4NTgxMTUwNjksMjMwNTQ1NTU1NCwyMjIwOTgxMTk1LDI0NzQ0MDQzMDQsMjY1ODYyNTQ5NywzNTc1NTI4ODc4LDM2MjUyNjgxMzUsMzQ3MzQxNjYzNiwzMjU0OTg4NzI1LDM3NzgxNTE4MTgsMzk2MzE2MTQ3NSw0MjEzNDQ3MDY0LDQxMzAyODEzNjEsMzU5OTU5NTA4NSwzNjgzMDIyOTE2LDM0MzI3MzczNzUsMzI0NzQ2NTU1OCwzODAyMjIyMTg1LDQwMjA5MTIyMjQsNDE3Mjc2Mzc3MSw0MTIyNzYyMzU0LDMyMDE2MzE3NDksMzAxNzY3MjcxNiwyNzY0MjQ5NjIzLDI4NDg0NjE4NTQsMjMzMTU5MDE3NywyMjgwNzk2MjAwLDI0MzE1OTA5NjMsMjY0ODk3NjQ0MiwxMDQ2OTk2MTMsMTg4MTI3NDQ0LDQ3MjYxNTYzMSwyODczNDM4MTQsODQwMDE5NzA1LDEwNTg3MDk3NDQsNjcxNTkzMTk1LDYyMTU5MTc3OCwxODUyMTcxOTI1LDE2NjgyMTI4OTIsMTk1Mzc1NzgzMSwyMDM3OTcwMDYyLDE1MTQ3OTA1NzcsMTQ2Mzk5NjYwMCwxMDgwMDE3NTcxLDEyOTc0MDMwNTAsMzY3MzYzNzM1NiwzNjIzNjM2OTY1LDMyMzU5OTUxMzQsMzQ1NDY4NjE5OSw0MDA3MzYwOTY4LDM4MjIwOTAxNzcsNDEwNzEwMTY1OCw0MTkwNTMwNTE1LDI5OTc4MjU5NTYsMzIxNTIxMjQ2MSwyODMwNzA4MTUwLDI3Nzk5MTUxOTksMjI1NjczNDU5MiwyMzQwOTQ3ODQ5LDI2MjcwMTYwODIsMjQ0MzA1ODA3NSwxNzI0NjY1NTYsMTIyNDY2MTY1LDI3Mzc5MjM2Niw0OTI0ODM0MzEsMTA0NzIzOWUzLDg2MTk2ODIwOSw2MTIyMDU4OTgsNjk1NjM0NzU1LDE2NDYyNTIzNDAsMTg2MzYzODg0NSwyMDEzOTA4MjYyLDE5NjMxMTUzMTEsMTQ0NjI0MjU3NiwxNTMwNDU1ODMzLDEyNzc1NTU5NzAsMTA5MzU5Nzk2MywxNjM2NjA0NjMxLDE4MjA4MjQ3OTgsMjA3MzcyNDYxMywxOTg5MjQ5MjI4LDE0MzY1OTA4MzUsMTQ4NzY0NTk0NiwxMzM3Mzc2NDgxLDExMTk3Mjc4NDgsMTY0OTQ4NjM5LDgxNzgxOTEwLDMzMTU0NDIwNSw1MTY1NTI4MzYsMTAzOTcxNzA1MSw4MjEyODgxMTQsNjY5OTYxODk3LDcxOTcwMDEyOCwyOTczNTMwNjk1LDMxNTc3NTA4NjIsMjg3MTY4MjY0NSwyNzg3MjA3MjYwLDIyMzI0MzUyOTksMjI4MzQ5MDQxMCwyNjY3OTk0NzM3LDI0NTAzNDYxMDQsMzY0NzIxMjA0NywzNTY0MDQ1MzE4LDMyNzkwMzM4ODUsMzQ2NDA0MjUxNiwzOTgwOTMxNjI3LDM3NjI1MDI2OTAsNDE1MDE0NDU2OSw0MTk5ODgyODAwLDMwNzAzNTY2MzQsMzEyMTI3NTUzOSwyOTA0MDI3MjcyLDI2ODYyNTQ3MjEsMjIwMDgxODg3OCwyMzg0OTExMDMxLDI1NzA4MzIwNDQsMjQ4NjIyNDU0OSwzNzQ3MTkyMDE4LDM1Mjg2MjY5MDcsMzMxMDMyMTg1NiwzMzU5OTM2MjAxLDM5NTAzNTU3MDIsMzg2NzA2MDk5MSw0MDQ5ODQ0NDUyLDQyMzQ3MjEwMDUsMTczOTY1NjIwMiwxNzkwNTc1MTA3LDIxMDgxMDA2MzIsMTg5MDMyODA4MSwxNDAyODExNDM4LDE1ODY5MDM1OTEsMTIzMzg1NjU3MiwxMTQ5MjQ5MDc3LDI2Njk1OTkzOCw0ODM5NDgyNywzNjkwNTc4NzIsNDE4NjcyMjE3LDEwMDI3ODM4NDYsOTE5NDg5MTM1LDU2NzQ5ODg2OCw3NTIzNzU0MjEsMjA5MzM2MjI1LDI0MTk3NTQ0LDM3NjE4NzgyNyw0NTk3NDQ2OTgsOTQ1MTY0MTY1LDg5NTI4NzY5Miw1NzQ2MjQ2NjMsNzkzNDUxOTM0LDE2Nzk5NjgyMzMsMTc2NDMxMzU2OCwyMTE3MzYwNjM1LDE5MzM1MzA2MTAsMTM0MzEyNzUwMSwxNTYwNjM3ODkyLDEyNDMxMTI0MTUsMTE5MjQ1NTYzOCwzNzA0MjgwODgxLDM1MTkxNDIyMDAsMzMzNjM1ODY5MSwzNDE5OTE1NTYyLDM5MDc0NDg1OTcsMzg1NzU3MjEyNCw0MDc1ODc3MTI3LDQyOTQ3MDQzOTgsMzAyOTUxMDAwOSwzMTEzODU1MzQ0LDI5Mjc5MzQzMTUsMjc0NDEwNDI5MCwyMTU5OTc2Mjg1LDIzNzc0ODY2NzYsMjU5NDczNDkyNywyNTQ0MDc4MTUwXTt2YXIgVTQ9WzAsMTUxODQ5NzQyLDMwMzY5OTQ4NCw0NTQ0OTk2MDIsNjA3Mzk4OTY4LDc1ODcyMDMxMCw5MDg5OTkyMDQsMTA1OTI3MDk1NCwxMjE0Nzk3OTM2LDEwOTcxNTk1NTAsMTUxNzQ0MDYyMCwxNDAwODQ5NzYyLDE4MTc5OTg0MDgsMTY5OTgzOTgxNCwyMTE4NTQxOTA4LDIwMDE0MzA4NzQsMjQyOTU5NTg3MiwyNTgxNDQ1NjE0LDIxOTQzMTkxMDAsMjM0NTExOTIxOCwzMDM0ODgxMjQwLDMxODYyMDI1ODIsMjgwMTY5OTUyNCwyOTUxOTcxMjc0LDM2MzU5OTY4MTYsMzUxODM1ODQzMCwzMzk5Njc5NjI4LDMyODMwODg3NzAsNDIzNzA4MzgxNiw0MTE4OTI1MjIyLDQwMDI4NjE3NDgsMzg4NTc1MDcxNCwxMDAyMTQyNjgzLDg1MDgxNzIzNyw2OTg0NDUyNTUsNTQ4MTY5NDE3LDUyOTQ4Nzg0MywzNzc2NDIyMjEsMjI3ODg1NTY3LDc3MDg5NTIxLDE5NDMyMTcwNjcsMjA2MTM3OTc0OSwxNjQwNTc2NDM5LDE3NTc2OTE1NzcsMTQ3NDc2MDU5NSwxNTkyMzk0OTA5LDExNzQyMTUwNTUsMTI5MDgwMTc5MywyODc1OTY4MzE1LDI3MjQ2NDI4NjksMzExMTI0NzE0MywyOTYwOTcxMzA1LDI0MDU0MjY5NDcsMjI1MzU4MTMyNSwyNjM4NjA2NjIzLDI0ODc4MTA1NzcsMzgwODY2MjM0NywzOTI2ODI1MDI5LDQwNDQ5ODE1OTEsNDE2MjA5NjcyOSwzMzQyMzE5NDc1LDM0NTk5NTM3ODksMzU3NjUzOTUwMywzNjkzMTI2MjQxLDE5ODY5MTgwNjEsMjEzNzA2MjgxOSwxNjg1NTc3OTA1LDE4MzY3NzIyODcsMTM4MTYyMDM3MywxNTMyMjg1MzM5LDEwNzgxODUwOTcsMTIyOTg5OTY1NSwxMDQwNTU5ODM3LDkyMzMxMzYxOSw3NDAyNzY0MTcsNjIxOTgyNjcxLDQzOTQ1MjM4OSwzMjI3MzQ1NzEsMTM3MDczOTEzLDE5MzA4NTM1LDM4NzExNjM5ODEsNDAyMTMwODczOSw0MTA0NjA1Nzc3LDQyNTU4MDAxNTksMzI2Mzc4NTU4OSwzNDE0NDUwNTU1LDM0OTkzMjY1NjksMzY1MTA0MTEyNywyOTMzMjAyNDkzLDI4MTU5NTYyNzUsMzE2NzY4NDY0MSwzMDQ5MzkwODk1LDIzMzAwMTQyMTMsMjIxMzI5NjM5NSwyNTY2NTk1NjA5LDI0NDg4MzAyMzEsMTMwNTkwNjU1MCwxMTU1MjM3NDk2LDE2MDcyNDQ2NTAsMTQ1NTUyNTk4OCwxNzc2NDYwMTEwLDE2MjYzMTk0MjQsMjA3OTg5NzQyNiwxOTI4NzA3MTY0LDk2MzkyNDU0LDIxMzExNDM3NiwzOTY2NzM4MTgsNTE0NDQzMjg0LDU2Mjc1NTkwMiw2Nzk5OThlMyw4NjUxMzY0MTgsOTgzNDI2MDkyLDM3MDgxNzM3MTgsMzU1NzUwNDY2NCwzNDc0NzI5ODY2LDMzMjMwMTEyMDQsNDE4MDgwODExMCw0MDMwNjY3NDI0LDM5NDUyNjkxNzAsMzc5NDA3ODkwOCwyNTA3MDQwMjMwLDI2MjM3NjIxNTIsMjI3MjU1NjAyNiwyMzkwMzI1NDkyLDI5NzU0ODQzODIsMzA5MjcyNjQ4MCwyNzM4OTA1MDI2LDI4NTcxOTQ3MDAsMzk3Mzc3MzEyMSwzODU2MTM3Mjk1LDQyNzQwNTM0NjksNDE1NzQ2NzIxOSwzMzcxMDk2OTUzLDMyNTI5MzI3MjcsMzY3MzQ3NjQ1MywzNTU2MzYxODM1LDI3NjMxNzM2ODEsMjkxNTAxNzc5MSwzMDY0NTEwNzY1LDMyMTUzMDcyOTksMjE1NjI5OTAxNywyMzA3NjIyOTE5LDI0NTk3MzUzMTcsMjYxMDAxMTY3NSwyMDgxMDQ4NDgxLDE5NjM0MTI2NTUsMTg0NjU2MzI2MSwxNzI5OTc3MDExLDE0ODA0ODU3ODUsMTM2MjMyMTU1OSwxMjQzOTA1NDEzLDExMjY3OTA3OTUsODc4ODQ1OTA1LDEwMzA2OTAwMTUsNjQ1NDAxMDM3LDc5NjE5NzU3MSwyNzQwODQ4NDEsNDI1NDA4NzQzLDM4NTQ0ODg1LDE4ODgyMTI0MywzNjEzNDk0NDI2LDM3MzE2NTQ1NDgsMzMxMzIxMjAzOCwzNDMwMzIyNTY4LDQwODI0NzUxNzAsNDIwMDExNTExNiwzNzgwMDk3NzI2LDM4OTY2ODgwNDgsMjY2ODIyMTY3NCwyNTE2OTAxODYwLDIzNjY4ODI1NTAsMjIxNjYxMDI5NiwzMTQxNDAwNzg2LDI5ODk1NTI2MDQsMjgzNzk2NjU0MiwyNjg3MTY1ODg4LDEyMDI3OTc2OTAsMTMyMDk1NzgxMiwxNDM3MjgwODcwLDE1NTQzOTE0MDAsMTY2OTY2NDgzNCwxNzg3MzA0NzgwLDE5MDYyNDcyNjIsMjAyMjgzNzU4NCwyNjU5MDUxNjIsMTE0NTg1MzQ4LDQ5OTM0Nzk5MCwzNDkwNzU3MzYsNzM2OTcwODAyLDU4NTEyMjYyMCw5NzI1MTI4MTQsODIxNzEyMTYwLDI1OTU2ODQ4NDQsMjQ3ODQ0MzIzNCwyMjkzMDQ1MjMyLDIxNzQ3NTQwNDYsMzE5NjI2Nzk4OCwzMDc5NTQ2NTg2LDI4OTU3MjM0NjQsMjc3Nzk1MjQ1NCwzNTM3ODUyODI4LDM2ODc5OTQwMDIsMzIzNDE1NjQxNiwzMzg1MzQ1MTY2LDQxNDI2MjYyMTIsNDI5MzI5NTc4NiwzODQxMDI0OTUyLDM5OTI3NDIwNzAsMTc0NTY3NjkyLDU3MzI2MDgyLDQxMDg4Nzk1MiwyOTI1OTY3NjYsNzc3MjMxNjY4LDY2MDUxMDI2NiwxMDExNDUyNzEyLDg5MzY4MTcwMiwxMTA4MzM5MDY4LDEyNTg0ODAyNDIsMTM0MzYxODkxMiwxNDk0ODA3NjYyLDE3MTUxOTMxNTYsMTg2NTg2MjczMCwxOTQ4MzczODQ4LDIxMDAwOTA5NjYsMjcwMTk0OTQ5NSwyODE4NjY2ODA5LDMwMDQ1OTExNDcsMzEyMjM1ODA1MywyMjM1MDYxNzc1LDIzNTIzMDc0NTcsMjUzNTYwNDI0MywyNjUzODk5NTQ5LDM5MTU2NTM3MDMsMzc2NDk4ODIzMyw0MjE5MzUyMTU1LDQwNjc2MzkxMjUsMzQ0NDU3NTg3MSwzMjk0NDMwNTc3LDM3NDYxNzUwNzUsMzU5NDk4MjI1Myw4MzY1NTM0MzEsOTUzMjcwNzQ1LDYwMDIzNTIxMSw3MTgwMDIxMTcsMzY3NTg1MDA3LDQ4NDgzMDY4OSwxMzMzNjE5MDcsMjUxNjU3MjEzLDIwNDE4NzcxNTksMTg5MTIxMTY4OSwxODA2NTk5MzU1LDE2NTQ4ODYzMjUsMTU2ODcxODQ5NSwxNDE4NTczMjAxLDEzMzU1MzU3NDcsMTE4NDM0MjkyNV07ZnVuY3Rpb24gY29udmVydFRvSW50MzIoYnl0ZXMpe3ZhciByZXN1bHQ9W107Zm9yKHZhciBpPTA7aTxieXRlcy5sZW5ndGg7aSs9NCl7cmVzdWx0LnB1c2goYnl0ZXNbaV08PDI0fGJ5dGVzW2krMV08PDE2fGJ5dGVzW2krMl08PDh8Ynl0ZXNbaSszXSl9cmV0dXJuIHJlc3VsdH12YXIgQUVTPWZ1bmN0aW9uKGtleSl7aWYoISh0aGlzIGluc3RhbmNlb2YgQUVTKSl7dGhyb3cgRXJyb3IoXCJBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImtleVwiLHt2YWx1ZTpjb2VyY2VBcnJheShrZXksdHJ1ZSl9KTt0aGlzLl9wcmVwYXJlKCl9O0FFUy5wcm90b3R5cGUuX3ByZXBhcmU9ZnVuY3Rpb24oKXt2YXIgcm91bmRzPW51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07aWYocm91bmRzPT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBzaXplIChtdXN0IGJlIDE2LCAyNCBvciAzMiBieXRlcylcIil9dGhpcy5fS2U9W107dGhpcy5fS2Q9W107Zm9yKHZhciBpPTA7aTw9cm91bmRzO2krKyl7dGhpcy5fS2UucHVzaChbMCwwLDAsMF0pO3RoaXMuX0tkLnB1c2goWzAsMCwwLDBdKX12YXIgcm91bmRLZXlDb3VudD0ocm91bmRzKzEpKjQ7dmFyIEtDPXRoaXMua2V5Lmxlbmd0aC80O3ZhciB0az1jb252ZXJ0VG9JbnQzMih0aGlzLmtleSk7dmFyIGluZGV4O2Zvcih2YXIgaT0wO2k8S0M7aSsrKXtpbmRleD1pPj4yO3RoaXMuX0tlW2luZGV4XVtpJTRdPXRrW2ldO3RoaXMuX0tkW3JvdW5kcy1pbmRleF1baSU0XT10a1tpXX12YXIgcmNvbnBvaW50ZXI9MDt2YXIgdD1LQyx0dDt3aGlsZSh0PHJvdW5kS2V5Q291bnQpe3R0PXRrW0tDLTFdO3RrWzBdXj1TW3R0Pj4xNiYyNTVdPDwyNF5TW3R0Pj44JjI1NV08PDE2XlNbdHQmMjU1XTw8OF5TW3R0Pj4yNCYyNTVdXnJjb25bcmNvbnBvaW50ZXJdPDwyNDtyY29ucG9pbnRlcis9MTtpZihLQyE9OCl7Zm9yKHZhciBpPTE7aTxLQztpKyspe3RrW2ldXj10a1tpLTFdfX1lbHNle2Zvcih2YXIgaT0xO2k8S0MvMjtpKyspe3RrW2ldXj10a1tpLTFdfXR0PXRrW0tDLzItMV07dGtbS0MvMl1ePVNbdHQmMjU1XV5TW3R0Pj44JjI1NV08PDheU1t0dD4+MTYmMjU1XTw8MTZeU1t0dD4+MjQmMjU1XTw8MjQ7Zm9yKHZhciBpPUtDLzIrMTtpPEtDO2krKyl7dGtbaV1ePXRrW2ktMV19fXZhciBpPTAscixjO3doaWxlKGk8S0MmJnQ8cm91bmRLZXlDb3VudCl7cj10Pj4yO2M9dCU0O3RoaXMuX0tlW3JdW2NdPXRrW2ldO3RoaXMuX0tkW3JvdW5kcy1yXVtjXT10a1tpKytdO3QrK319Zm9yKHZhciByPTE7cjxyb3VuZHM7cisrKXtmb3IodmFyIGM9MDtjPDQ7YysrKXt0dD10aGlzLl9LZFtyXVtjXTt0aGlzLl9LZFtyXVtjXT1VMVt0dD4+MjQmMjU1XV5VMlt0dD4+MTYmMjU1XV5VM1t0dD4+OCYyNTVdXlU0W3R0JjI1NV19fX07QUVTLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKHBsYWludGV4dCl7aWYocGxhaW50ZXh0Lmxlbmd0aCE9MTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpfXZhciByb3VuZHM9dGhpcy5fS2UubGVuZ3RoLTE7dmFyIGE9WzAsMCwwLDBdO3ZhciB0PWNvbnZlcnRUb0ludDMyKHBsYWludGV4dCk7Zm9yKHZhciBpPTA7aTw0O2krKyl7dFtpXV49dGhpcy5fS2VbMF1baV19Zm9yKHZhciByPTE7cjxyb3VuZHM7cisrKXtmb3IodmFyIGk9MDtpPDQ7aSsrKXthW2ldPVQxW3RbaV0+PjI0JjI1NV1eVDJbdFsoaSsxKSU0XT4+MTYmMjU1XV5UM1t0WyhpKzIpJTRdPj44JjI1NV1eVDRbdFsoaSszKSU0XSYyNTVdXnRoaXMuX0tlW3JdW2ldfXQ9YS5zbGljZSgpfXZhciByZXN1bHQ9Y3JlYXRlQXJyYXkoMTYpLHR0O2Zvcih2YXIgaT0wO2k8NDtpKyspe3R0PXRoaXMuX0tlW3JvdW5kc11baV07cmVzdWx0WzQqaV09KFNbdFtpXT4+MjQmMjU1XV50dD4+MjQpJjI1NTtyZXN1bHRbNCppKzFdPShTW3RbKGkrMSklNF0+PjE2JjI1NV1edHQ+PjE2KSYyNTU7cmVzdWx0WzQqaSsyXT0oU1t0WyhpKzIpJTRdPj44JjI1NV1edHQ+PjgpJjI1NTtyZXN1bHRbNCppKzNdPShTW3RbKGkrMyklNF0mMjU1XV50dCkmMjU1fXJldHVybiByZXN1bHR9O0FFUy5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihjaXBoZXJ0ZXh0KXtpZihjaXBoZXJ0ZXh0Lmxlbmd0aCE9MTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKX12YXIgcm91bmRzPXRoaXMuX0tkLmxlbmd0aC0xO3ZhciBhPVswLDAsMCwwXTt2YXIgdD1jb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtmb3IodmFyIGk9MDtpPDQ7aSsrKXt0W2ldXj10aGlzLl9LZFswXVtpXX1mb3IodmFyIHI9MTtyPHJvdW5kcztyKyspe2Zvcih2YXIgaT0wO2k8NDtpKyspe2FbaV09VDVbdFtpXT4+MjQmMjU1XV5UNlt0WyhpKzMpJTRdPj4xNiYyNTVdXlQ3W3RbKGkrMiklNF0+PjgmMjU1XV5UOFt0WyhpKzEpJTRdJjI1NV1edGhpcy5fS2Rbcl1baV19dD1hLnNsaWNlKCl9dmFyIHJlc3VsdD1jcmVhdGVBcnJheSgxNiksdHQ7Zm9yKHZhciBpPTA7aTw0O2krKyl7dHQ9dGhpcy5fS2Rbcm91bmRzXVtpXTtyZXN1bHRbNCppXT0oU2lbdFtpXT4+MjQmMjU1XV50dD4+MjQpJjI1NTtyZXN1bHRbNCppKzFdPShTaVt0WyhpKzMpJTRdPj4xNiYyNTVdXnR0Pj4xNikmMjU1O3Jlc3VsdFs0KmkrMl09KFNpW3RbKGkrMiklNF0+PjgmMjU1XV50dD4+OCkmMjU1O3Jlc3VsdFs0KmkrM109KFNpW3RbKGkrMSklNF0mMjU1XV50dCkmMjU1fXJldHVybiByZXN1bHR9O3ZhciBNb2RlT2ZPcGVyYXRpb25FQ0I9ZnVuY3Rpb24oa2V5KXtpZighKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25FQ0IpKXt0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpfXRoaXMuZGVzY3JpcHRpb249XCJFbGVjdHJvbmljIENvZGUgQmxvY2tcIjt0aGlzLm5hbWU9XCJlY2JcIjt0aGlzLl9hZXM9bmV3IEFFUyhrZXkpfTtNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24ocGxhaW50ZXh0KXtwbGFpbnRleHQ9Y29lcmNlQXJyYXkocGxhaW50ZXh0KTtpZihwbGFpbnRleHQubGVuZ3RoJTE2IT09MCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIil9dmFyIGNpcGhlcnRleHQ9Y3JlYXRlQXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7dmFyIGJsb2NrPWNyZWF0ZUFycmF5KDE2KTtmb3IodmFyIGk9MDtpPHBsYWludGV4dC5sZW5ndGg7aSs9MTYpe2NvcHlBcnJheShwbGFpbnRleHQsYmxvY2ssMCxpLGkrMTYpO2Jsb2NrPXRoaXMuX2Flcy5lbmNyeXB0KGJsb2NrKTtjb3B5QXJyYXkoYmxvY2ssY2lwaGVydGV4dCxpKX1yZXR1cm4gY2lwaGVydGV4dH07TW9kZU9mT3BlcmF0aW9uRUNCLnByb3RvdHlwZS5kZWNyeXB0PWZ1bmN0aW9uKGNpcGhlcnRleHQpe2NpcGhlcnRleHQ9Y29lcmNlQXJyYXkoY2lwaGVydGV4dCk7aWYoY2lwaGVydGV4dC5sZW5ndGglMTYhPT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIil9dmFyIHBsYWludGV4dD1jcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7dmFyIGJsb2NrPWNyZWF0ZUFycmF5KDE2KTtmb3IodmFyIGk9MDtpPGNpcGhlcnRleHQubGVuZ3RoO2krPTE2KXtjb3B5QXJyYXkoY2lwaGVydGV4dCxibG9jaywwLGksaSsxNik7YmxvY2s9dGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO2NvcHlBcnJheShibG9jayxwbGFpbnRleHQsaSl9cmV0dXJuIHBsYWludGV4dH07dmFyIE1vZGVPZk9wZXJhdGlvbkNCQz1mdW5jdGlvbihrZXksaXYpe2lmKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkNCQykpe3Rocm93IEVycm9yKFwiQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIil9dGhpcy5kZXNjcmlwdGlvbj1cIkNpcGhlciBCbG9jayBDaGFpbmluZ1wiO3RoaXMubmFtZT1cImNiY1wiO2lmKCFpdil7aXY9Y3JlYXRlQXJyYXkoMTYpfWVsc2UgaWYoaXYubGVuZ3RoIT0xNil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpfXRoaXMuX2xhc3RDaXBoZXJibG9jaz1jb2VyY2VBcnJheShpdix0cnVlKTt0aGlzLl9hZXM9bmV3IEFFUyhrZXkpfTtNb2RlT2ZPcGVyYXRpb25DQkMucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24ocGxhaW50ZXh0KXtwbGFpbnRleHQ9Y29lcmNlQXJyYXkocGxhaW50ZXh0KTtpZihwbGFpbnRleHQubGVuZ3RoJTE2IT09MCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIil9dmFyIGNpcGhlcnRleHQ9Y3JlYXRlQXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7dmFyIGJsb2NrPWNyZWF0ZUFycmF5KDE2KTtmb3IodmFyIGk9MDtpPHBsYWludGV4dC5sZW5ndGg7aSs9MTYpe2NvcHlBcnJheShwbGFpbnRleHQsYmxvY2ssMCxpLGkrMTYpO2Zvcih2YXIgaj0wO2o8MTY7aisrKXtibG9ja1tqXV49dGhpcy5fbGFzdENpcGhlcmJsb2NrW2pdfXRoaXMuX2xhc3RDaXBoZXJibG9jaz10aGlzLl9hZXMuZW5jcnlwdChibG9jayk7Y29weUFycmF5KHRoaXMuX2xhc3RDaXBoZXJibG9jayxjaXBoZXJ0ZXh0LGkpfXJldHVybiBjaXBoZXJ0ZXh0fTtNb2RlT2ZPcGVyYXRpb25DQkMucHJvdG90eXBlLmRlY3J5cHQ9ZnVuY3Rpb24oY2lwaGVydGV4dCl7Y2lwaGVydGV4dD1jb2VyY2VBcnJheShjaXBoZXJ0ZXh0KTtpZihjaXBoZXJ0ZXh0Lmxlbmd0aCUxNiE9PTApe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKX12YXIgcGxhaW50ZXh0PWNyZWF0ZUFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTt2YXIgYmxvY2s9Y3JlYXRlQXJyYXkoMTYpO2Zvcih2YXIgaT0wO2k8Y2lwaGVydGV4dC5sZW5ndGg7aSs9MTYpe2NvcHlBcnJheShjaXBoZXJ0ZXh0LGJsb2NrLDAsaSxpKzE2KTtibG9jaz10aGlzLl9hZXMuZGVjcnlwdChibG9jayk7Zm9yKHZhciBqPTA7ajwxNjtqKyspe3BsYWludGV4dFtpK2pdPWJsb2NrW2pdXnRoaXMuX2xhc3RDaXBoZXJibG9ja1tqXX1jb3B5QXJyYXkoY2lwaGVydGV4dCx0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssMCxpLGkrMTYpfXJldHVybiBwbGFpbnRleHR9O3ZhciBNb2RlT2ZPcGVyYXRpb25DRkI9ZnVuY3Rpb24oa2V5LGl2LHNlZ21lbnRTaXplKXtpZighKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25DRkIpKXt0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpfXRoaXMuZGVzY3JpcHRpb249XCJDaXBoZXIgRmVlZGJhY2tcIjt0aGlzLm5hbWU9XCJjZmJcIjtpZighaXYpe2l2PWNyZWF0ZUFycmF5KDE2KX1lbHNlIGlmKGl2Lmxlbmd0aCE9MTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IHNpemUpXCIpfWlmKCFzZWdtZW50U2l6ZSl7c2VnbWVudFNpemU9MX10aGlzLnNlZ21lbnRTaXplPXNlZ21lbnRTaXplO3RoaXMuX3NoaWZ0UmVnaXN0ZXI9Y29lcmNlQXJyYXkoaXYsdHJ1ZSk7dGhpcy5fYWVzPW5ldyBBRVMoa2V5KX07TW9kZU9mT3BlcmF0aW9uQ0ZCLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKHBsYWludGV4dCl7aWYocGxhaW50ZXh0Lmxlbmd0aCV0aGlzLnNlZ21lbnRTaXplIT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIHNlZ21lbnRTaXplIGJ5dGVzKVwiKX12YXIgZW5jcnlwdGVkPWNvZXJjZUFycmF5KHBsYWludGV4dCx0cnVlKTt2YXIgeG9yU2VnbWVudDtmb3IodmFyIGk9MDtpPGVuY3J5cHRlZC5sZW5ndGg7aSs9dGhpcy5zZWdtZW50U2l6ZSl7eG9yU2VnbWVudD10aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9zaGlmdFJlZ2lzdGVyKTtmb3IodmFyIGo9MDtqPHRoaXMuc2VnbWVudFNpemU7aisrKXtlbmNyeXB0ZWRbaStqXV49eG9yU2VnbWVudFtqXX1jb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3Rlcix0aGlzLl9zaGlmdFJlZ2lzdGVyLDAsdGhpcy5zZWdtZW50U2l6ZSk7Y29weUFycmF5KGVuY3J5cHRlZCx0aGlzLl9zaGlmdFJlZ2lzdGVyLDE2LXRoaXMuc2VnbWVudFNpemUsaSxpK3RoaXMuc2VnbWVudFNpemUpfXJldHVybiBlbmNyeXB0ZWR9O01vZGVPZk9wZXJhdGlvbkNGQi5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihjaXBoZXJ0ZXh0KXtpZihjaXBoZXJ0ZXh0Lmxlbmd0aCV0aGlzLnNlZ21lbnRTaXplIT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcylcIil9dmFyIHBsYWludGV4dD1jb2VyY2VBcnJheShjaXBoZXJ0ZXh0LHRydWUpO3ZhciB4b3JTZWdtZW50O2Zvcih2YXIgaT0wO2k8cGxhaW50ZXh0Lmxlbmd0aDtpKz10aGlzLnNlZ21lbnRTaXplKXt4b3JTZWdtZW50PXRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO2Zvcih2YXIgaj0wO2o8dGhpcy5zZWdtZW50U2l6ZTtqKyspe3BsYWludGV4dFtpK2pdXj14b3JTZWdtZW50W2pdfWNvcHlBcnJheSh0aGlzLl9zaGlmdFJlZ2lzdGVyLHRoaXMuX3NoaWZ0UmVnaXN0ZXIsMCx0aGlzLnNlZ21lbnRTaXplKTtjb3B5QXJyYXkoY2lwaGVydGV4dCx0aGlzLl9zaGlmdFJlZ2lzdGVyLDE2LXRoaXMuc2VnbWVudFNpemUsaSxpK3RoaXMuc2VnbWVudFNpemUpfXJldHVybiBwbGFpbnRleHR9O3ZhciBNb2RlT2ZPcGVyYXRpb25PRkI9ZnVuY3Rpb24oa2V5LGl2KXtpZighKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25PRkIpKXt0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpfXRoaXMuZGVzY3JpcHRpb249XCJPdXRwdXQgRmVlZGJhY2tcIjt0aGlzLm5hbWU9XCJvZmJcIjtpZighaXYpe2l2PWNyZWF0ZUFycmF5KDE2KX1lbHNlIGlmKGl2Lmxlbmd0aCE9MTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKX10aGlzLl9sYXN0UHJlY2lwaGVyPWNvZXJjZUFycmF5KGl2LHRydWUpO3RoaXMuX2xhc3RQcmVjaXBoZXJJbmRleD0xNjt0aGlzLl9hZXM9bmV3IEFFUyhrZXkpfTtNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24ocGxhaW50ZXh0KXt2YXIgZW5jcnlwdGVkPWNvZXJjZUFycmF5KHBsYWludGV4dCx0cnVlKTtmb3IodmFyIGk9MDtpPGVuY3J5cHRlZC5sZW5ndGg7aSsrKXtpZih0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXg9PT0xNil7dGhpcy5fbGFzdFByZWNpcGhlcj10aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKTt0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXg9MH1lbmNyeXB0ZWRbaV1ePXRoaXMuX2xhc3RQcmVjaXBoZXJbdGhpcy5fbGFzdFByZWNpcGhlckluZGV4KytdfXJldHVybiBlbmNyeXB0ZWR9O01vZGVPZk9wZXJhdGlvbk9GQi5wcm90b3R5cGUuZGVjcnlwdD1Nb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmVuY3J5cHQ7dmFyIENvdW50ZXI9ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBDb3VudGVyKSl7dGhyb3cgRXJyb3IoXCJDb3VudGVyIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIil9aWYoaW5pdGlhbFZhbHVlIT09MCYmIWluaXRpYWxWYWx1ZSl7aW5pdGlhbFZhbHVlPTF9aWYodHlwZW9mIGluaXRpYWxWYWx1ZT09PVwibnVtYmVyXCIpe3RoaXMuX2NvdW50ZXI9Y3JlYXRlQXJyYXkoMTYpO3RoaXMuc2V0VmFsdWUoaW5pdGlhbFZhbHVlKX1lbHNle3RoaXMuc2V0Qnl0ZXMoaW5pdGlhbFZhbHVlKX19O0NvdW50ZXIucHJvdG90eXBlLnNldFZhbHVlPWZ1bmN0aW9uKHZhbHVlKXtpZih0eXBlb2YgdmFsdWUhPT1cIm51bWJlclwifHxwYXJzZUludCh2YWx1ZSkhPXZhbHVlKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgdmFsdWUgKG11c3QgYmUgYW4gaW50ZWdlcilcIil9Zm9yKHZhciBpbmRleD0xNTtpbmRleD49MDstLWluZGV4KXt0aGlzLl9jb3VudGVyW2luZGV4XT12YWx1ZSUyNTY7dmFsdWU9dmFsdWU+Pjh9fTtDb3VudGVyLnByb3RvdHlwZS5zZXRCeXRlcz1mdW5jdGlvbihieXRlcyl7Ynl0ZXM9Y29lcmNlQXJyYXkoYnl0ZXMsdHJ1ZSk7aWYoYnl0ZXMubGVuZ3RoIT0xNil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb3VudGVyIGJ5dGVzIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpfXRoaXMuX2NvdW50ZXI9Ynl0ZXN9O0NvdW50ZXIucHJvdG90eXBlLmluY3JlbWVudD1mdW5jdGlvbigpe2Zvcih2YXIgaT0xNTtpPj0wO2ktLSl7aWYodGhpcy5fY291bnRlcltpXT09PTI1NSl7dGhpcy5fY291bnRlcltpXT0wfWVsc2V7dGhpcy5fY291bnRlcltpXSsrO2JyZWFrfX19O3ZhciBNb2RlT2ZPcGVyYXRpb25DVFI9ZnVuY3Rpb24oa2V5LGNvdW50ZXIpe2lmKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkNUUikpe3Rocm93IEVycm9yKFwiQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIil9dGhpcy5kZXNjcmlwdGlvbj1cIkNvdW50ZXJcIjt0aGlzLm5hbWU9XCJjdHJcIjtpZighKGNvdW50ZXIgaW5zdGFuY2VvZiBDb3VudGVyKSl7Y291bnRlcj1uZXcgQ291bnRlcihjb3VudGVyKX10aGlzLl9jb3VudGVyPWNvdW50ZXI7dGhpcy5fcmVtYWluaW5nQ291bnRlcj1udWxsO3RoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleD0xNjt0aGlzLl9hZXM9bmV3IEFFUyhrZXkpfTtNb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24ocGxhaW50ZXh0KXt2YXIgZW5jcnlwdGVkPWNvZXJjZUFycmF5KHBsYWludGV4dCx0cnVlKTtmb3IodmFyIGk9MDtpPGVuY3J5cHRlZC5sZW5ndGg7aSsrKXtpZih0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXg9PT0xNil7dGhpcy5fcmVtYWluaW5nQ291bnRlcj10aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9jb3VudGVyLl9jb3VudGVyKTt0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXg9MDt0aGlzLl9jb3VudGVyLmluY3JlbWVudCgpfWVuY3J5cHRlZFtpXV49dGhpcy5fcmVtYWluaW5nQ291bnRlclt0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXgrK119cmV0dXJuIGVuY3J5cHRlZH07TW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5kZWNyeXB0PU1vZGVPZk9wZXJhdGlvbkNUUi5wcm90b3R5cGUuZW5jcnlwdDtmdW5jdGlvbiBwa2NzN3BhZChkYXRhKXtkYXRhPWNvZXJjZUFycmF5KGRhdGEsdHJ1ZSk7dmFyIHBhZGRlcj0xNi1kYXRhLmxlbmd0aCUxNjt2YXIgcmVzdWx0PWNyZWF0ZUFycmF5KGRhdGEubGVuZ3RoK3BhZGRlcik7Y29weUFycmF5KGRhdGEscmVzdWx0KTtmb3IodmFyIGk9ZGF0YS5sZW5ndGg7aTxyZXN1bHQubGVuZ3RoO2krKyl7cmVzdWx0W2ldPXBhZGRlcn1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIHBrY3M3c3RyaXAoZGF0YSl7ZGF0YT1jb2VyY2VBcnJheShkYXRhLHRydWUpO2lmKGRhdGEubGVuZ3RoPDE2KXt0aHJvdyBuZXcgRXJyb3IoXCJQS0NTIzcgaW52YWxpZCBsZW5ndGhcIil9dmFyIHBhZGRlcj1kYXRhW2RhdGEubGVuZ3RoLTFdO2lmKHBhZGRlcj4xNil7dGhyb3cgbmV3IEVycm9yKFwiUEtDUyM3IHBhZGRpbmcgYnl0ZSBvdXQgb2YgcmFuZ2VcIil9dmFyIGxlbmd0aD1kYXRhLmxlbmd0aC1wYWRkZXI7Zm9yKHZhciBpPTA7aTxwYWRkZXI7aSsrKXtpZihkYXRhW2xlbmd0aCtpXSE9PXBhZGRlcil7dGhyb3cgbmV3IEVycm9yKFwiUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlXCIpfX12YXIgcmVzdWx0PWNyZWF0ZUFycmF5KGxlbmd0aCk7Y29weUFycmF5KGRhdGEscmVzdWx0LDAsMCxsZW5ndGgpO3JldHVybiByZXN1bHR9dmFyIGFlc2pzPXtBRVM6QUVTLENvdW50ZXI6Q291bnRlcixNb2RlT2ZPcGVyYXRpb246e2VjYjpNb2RlT2ZPcGVyYXRpb25FQ0IsY2JjOk1vZGVPZk9wZXJhdGlvbkNCQyxjZmI6TW9kZU9mT3BlcmF0aW9uQ0ZCLG9mYjpNb2RlT2ZPcGVyYXRpb25PRkIsY3RyOk1vZGVPZk9wZXJhdGlvbkNUUn0sdXRpbHM6e2hleDpjb252ZXJ0SGV4LHV0Zjg6Y29udmVydFV0Zjh9LHBhZGRpbmc6e3BrY3M3OntwYWQ6cGtjczdwYWQsc3RyaXA6cGtjczdzdHJpcH19LF9hcnJheVRlc3Q6e2NvZXJjZUFycmF5OmNvZXJjZUFycmF5LGNyZWF0ZUFycmF5OmNyZWF0ZUFycmF5LGNvcHlBcnJheTpjb3B5QXJyYXl9fTtpZihcIm9iamVjdFwiIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9YWVzanN9ZWxzZSBpZih0eXBlb2YgdW5kZWZpbmVkPT09XCJmdW5jdGlvblwiJiZ1bmRlZmluZWQuYW1kKXt1bmRlZmluZWQoYWVzanMpfWVsc2V7aWYocm9vdC5hZXNqcyl7YWVzanMuX2Flc2pzPXJvb3QuYWVzanN9cm9vdC5hZXNqcz1hZXNqc319KShjb21tb25qc0dsb2JhbCl9KTtjb25zdCB2ZXJzaW9uJGk9XCJqc29uLXdhbGxldHMvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBsb29zZUFycmF5aWZ5KGhleFN0cmluZyl7aWYodHlwZW9mIGhleFN0cmluZz09PVwic3RyaW5nXCImJmhleFN0cmluZy5zdWJzdHJpbmcoMCwyKSE9PVwiMHhcIil7aGV4U3RyaW5nPVwiMHhcIitoZXhTdHJpbmd9cmV0dXJuIGFycmF5aWZ5KGhleFN0cmluZyl9ZnVuY3Rpb24genBhZCh2YWx1ZSxsZW5ndGgpe3ZhbHVlPVN0cmluZyh2YWx1ZSk7d2hpbGUodmFsdWUubGVuZ3RoPGxlbmd0aCl7dmFsdWU9XCIwXCIrdmFsdWV9cmV0dXJuIHZhbHVlfWZ1bmN0aW9uIGdldFBhc3N3b3JkKHBhc3N3b3JkKXtpZih0eXBlb2YgcGFzc3dvcmQ9PT1cInN0cmluZ1wiKXtyZXR1cm4gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpfXJldHVybiBhcnJheWlmeShwYXNzd29yZCl9ZnVuY3Rpb24gc2VhcmNoUGF0aChvYmplY3QscGF0aCl7bGV0IGN1cnJlbnRDaGlsZD1vYmplY3Q7Y29uc3QgY29tcHM9cGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiL1wiKTtmb3IobGV0IGk9MDtpPGNvbXBzLmxlbmd0aDtpKyspe2xldCBtYXRjaGluZ0NoaWxkPW51bGw7Zm9yKGNvbnN0IGtleSBpbiBjdXJyZW50Q2hpbGQpe2lmKGtleS50b0xvd2VyQ2FzZSgpPT09Y29tcHNbaV0pe21hdGNoaW5nQ2hpbGQ9Y3VycmVudENoaWxkW2tleV07YnJlYWt9fWlmKG1hdGNoaW5nQ2hpbGQ9PT1udWxsKXtyZXR1cm4gbnVsbH1jdXJyZW50Q2hpbGQ9bWF0Y2hpbmdDaGlsZH1yZXR1cm4gY3VycmVudENoaWxkfWZ1bmN0aW9uIHV1aWRWNChyYW5kb21CeXRlcyl7Y29uc3QgYnl0ZXM9YXJyYXlpZnkocmFuZG9tQnl0ZXMpO2J5dGVzWzZdPWJ5dGVzWzZdJjE1fDY0O2J5dGVzWzhdPWJ5dGVzWzhdJjYzfDEyODtjb25zdCB2YWx1ZT1oZXhsaWZ5KGJ5dGVzKTtyZXR1cm5bdmFsdWUuc3Vic3RyaW5nKDIsMTApLHZhbHVlLnN1YnN0cmluZygxMCwxNCksdmFsdWUuc3Vic3RyaW5nKDE0LDE4KSx2YWx1ZS5zdWJzdHJpbmcoMTgsMjIpLHZhbHVlLnN1YnN0cmluZygyMiwzNCldLmpvaW4oXCItXCIpfVwidXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRuPW5ldyBMb2dnZXIodmVyc2lvbiRpKTtjbGFzcyBDcm93ZHNhbGVBY2NvdW50IGV4dGVuZHMgRGVzY3JpcHRpb257aXNDcm93ZHNhbGVBY2NvdW50KHZhbHVlKXtyZXR1cm4hISh2YWx1ZSYmdmFsdWUuX2lzQ3Jvd2RzYWxlQWNjb3VudCl9fWZ1bmN0aW9uIGRlY3J5cHQoanNvbixwYXNzd29yZCl7Y29uc3QgZGF0YT1KU09OLnBhcnNlKGpzb24pO3Bhc3N3b3JkPWdldFBhc3N3b3JkKHBhc3N3b3JkKTtjb25zdCBldGhhZGRyPWdldEFkZHJlc3Moc2VhcmNoUGF0aChkYXRhLFwiZXRoYWRkclwiKSk7Y29uc3QgZW5jc2VlZD1sb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSxcImVuY3NlZWRcIikpO2lmKCFlbmNzZWVkfHxlbmNzZWVkLmxlbmd0aCUxNiE9PTApe2xvZ2dlciRuLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZW5jc2VlZFwiLFwianNvblwiLGpzb24pfWNvbnN0IGtleT1hcnJheWlmeShwYmtkZjIocGFzc3dvcmQscGFzc3dvcmQsMmUzLDMyLFwic2hhMjU2XCIpKS5zbGljZSgwLDE2KTtjb25zdCBpdj1lbmNzZWVkLnNsaWNlKDAsMTYpO2NvbnN0IGVuY3J5cHRlZFNlZWQ9ZW5jc2VlZC5zbGljZSgxNik7Y29uc3QgYWVzQ2JjPW5ldyBhZXNKcy5Nb2RlT2ZPcGVyYXRpb24uY2JjKGtleSxpdik7Y29uc3Qgc2VlZD1hZXNKcy5wYWRkaW5nLnBrY3M3LnN0cmlwKGFycmF5aWZ5KGFlc0NiYy5kZWNyeXB0KGVuY3J5cHRlZFNlZWQpKSk7bGV0IHNlZWRIZXg9XCJcIjtmb3IobGV0IGk9MDtpPHNlZWQubGVuZ3RoO2krKyl7c2VlZEhleCs9U3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKX1jb25zdCBzZWVkSGV4Qnl0ZXM9dG9VdGY4Qnl0ZXMoc2VlZEhleCk7Y29uc3QgcHJpdmF0ZUtleT1rZWNjYWsyNTYoc2VlZEhleEJ5dGVzKTtyZXR1cm4gbmV3IENyb3dkc2FsZUFjY291bnQoe19pc0Nyb3dkc2FsZUFjY291bnQ6dHJ1ZSxhZGRyZXNzOmV0aGFkZHIscHJpdmF0ZUtleTpwcml2YXRlS2V5fSl9XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaXNDcm93ZHNhbGVXYWxsZXQoanNvbil7bGV0IGRhdGE9bnVsbDt0cnl7ZGF0YT1KU09OLnBhcnNlKGpzb24pfWNhdGNoKGVycm9yKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGRhdGEuZW5jc2VlZCYmZGF0YS5ldGhhZGRyfWZ1bmN0aW9uIGlzS2V5c3RvcmVXYWxsZXQoanNvbil7bGV0IGRhdGE9bnVsbDt0cnl7ZGF0YT1KU09OLnBhcnNlKGpzb24pfWNhdGNoKGVycm9yKXtyZXR1cm4gZmFsc2V9aWYoIWRhdGEudmVyc2lvbnx8cGFyc2VJbnQoZGF0YS52ZXJzaW9uKSE9PWRhdGEudmVyc2lvbnx8cGFyc2VJbnQoZGF0YS52ZXJzaW9uKSE9PTMpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiBnZXRKc29uV2FsbGV0QWRkcmVzcyhqc29uKXtpZihpc0Nyb3dkc2FsZVdhbGxldChqc29uKSl7dHJ5e3JldHVybiBnZXRBZGRyZXNzKEpTT04ucGFyc2UoanNvbikuZXRoYWRkcil9Y2F0Y2goZXJyb3Ipe3JldHVybiBudWxsfX1pZihpc0tleXN0b3JlV2FsbGV0KGpzb24pKXt0cnl7cmV0dXJuIGdldEFkZHJlc3MoSlNPTi5wYXJzZShqc29uKS5hZGRyZXNzKX1jYXRjaChlcnJvcil7cmV0dXJuIG51bGx9fXJldHVybiBudWxsfXZhciBzY3J5cHQ9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihyb290KXtjb25zdCBNQVhfVkFMVUU9MjE0NzQ4MzY0NztmdW5jdGlvbiBTSEEyNTYobSl7Y29uc3QgSz1uZXcgVWludDMyQXJyYXkoWzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF0pO2xldCBoMD0xNzc5MDMzNzAzLGgxPTMxNDQxMzQyNzcsaDI9MTAxMzkwNDI0MixoMz0yNzczNDgwNzYyO2xldCBoND0xMzU5ODkzMTE5LGg1PTI2MDA4MjI5MjQsaDY9NTI4NzM0NjM1LGg3PTE1NDE0NTkyMjU7Y29uc3Qgdz1uZXcgVWludDMyQXJyYXkoNjQpO2Z1bmN0aW9uIGJsb2NrcyhwKXtsZXQgb2ZmPTAsbGVuPXAubGVuZ3RoO3doaWxlKGxlbj49NjQpe2xldCBhPWgwLGI9aDEsYz1oMixkPWgzLGU9aDQsZj1oNSxnPWg2LGg9aDcsdSxpLGosdDEsdDI7Zm9yKGk9MDtpPDE2O2krKyl7aj1vZmYraSo0O3dbaV09KHBbal0mMjU1KTw8MjR8KHBbaisxXSYyNTUpPDwxNnwocFtqKzJdJjI1NSk8PDh8cFtqKzNdJjI1NX1mb3IoaT0xNjtpPDY0O2krKyl7dT13W2ktMl07dDE9KHU+Pj4xN3x1PDwzMi0xNyleKHU+Pj4xOXx1PDwzMi0xOSledT4+PjEwO3U9d1tpLTE1XTt0Mj0odT4+Pjd8dTw8MzItNyleKHU+Pj4xOHx1PDwzMi0xOCledT4+PjM7d1tpXT0odDErd1tpLTddfDApKyh0Mit3W2ktMTZdfDApfDB9Zm9yKGk9MDtpPDY0O2krKyl7dDE9KCgoZT4+PjZ8ZTw8MzItNileKGU+Pj4xMXxlPDwzMi0xMSleKGU+Pj4yNXxlPDwzMi0yNSkpKyhlJmZefmUmZyl8MCkrKGgrKEtbaV0rd1tpXXwwKXwwKXwwO3QyPSgoYT4+PjJ8YTw8MzItMileKGE+Pj4xM3xhPDwzMi0xMyleKGE+Pj4yMnxhPDwzMi0yMikpKyhhJmJeYSZjXmImYyl8MDtoPWc7Zz1mO2Y9ZTtlPWQrdDF8MDtkPWM7Yz1iO2I9YTthPXQxK3QyfDB9aDA9aDArYXwwO2gxPWgxK2J8MDtoMj1oMitjfDA7aDM9aDMrZHwwO2g0PWg0K2V8MDtoNT1oNStmfDA7aDY9aDYrZ3wwO2g3PWg3K2h8MDtvZmYrPTY0O2xlbi09NjR9fWJsb2NrcyhtKTtsZXQgaSxieXRlc0xlZnQ9bS5sZW5ndGglNjQsYml0TGVuSGk9bS5sZW5ndGgvNTM2ODcwOTEyfDAsYml0TGVuTG89bS5sZW5ndGg8PDMsbnVtWmVyb3M9Ynl0ZXNMZWZ0PDU2PzU2OjEyMCxwPW0uc2xpY2UobS5sZW5ndGgtYnl0ZXNMZWZ0LG0ubGVuZ3RoKTtwLnB1c2goMTI4KTtmb3IoaT1ieXRlc0xlZnQrMTtpPG51bVplcm9zO2krKyl7cC5wdXNoKDApfXAucHVzaChiaXRMZW5IaT4+PjI0JjI1NSk7cC5wdXNoKGJpdExlbkhpPj4+MTYmMjU1KTtwLnB1c2goYml0TGVuSGk+Pj44JjI1NSk7cC5wdXNoKGJpdExlbkhpPj4+MCYyNTUpO3AucHVzaChiaXRMZW5Mbz4+PjI0JjI1NSk7cC5wdXNoKGJpdExlbkxvPj4+MTYmMjU1KTtwLnB1c2goYml0TGVuTG8+Pj44JjI1NSk7cC5wdXNoKGJpdExlbkxvPj4+MCYyNTUpO2Jsb2NrcyhwKTtyZXR1cm5baDA+Pj4yNCYyNTUsaDA+Pj4xNiYyNTUsaDA+Pj44JjI1NSxoMD4+PjAmMjU1LGgxPj4+MjQmMjU1LGgxPj4+MTYmMjU1LGgxPj4+OCYyNTUsaDE+Pj4wJjI1NSxoMj4+PjI0JjI1NSxoMj4+PjE2JjI1NSxoMj4+PjgmMjU1LGgyPj4+MCYyNTUsaDM+Pj4yNCYyNTUsaDM+Pj4xNiYyNTUsaDM+Pj44JjI1NSxoMz4+PjAmMjU1LGg0Pj4+MjQmMjU1LGg0Pj4+MTYmMjU1LGg0Pj4+OCYyNTUsaDQ+Pj4wJjI1NSxoNT4+PjI0JjI1NSxoNT4+PjE2JjI1NSxoNT4+PjgmMjU1LGg1Pj4+MCYyNTUsaDY+Pj4yNCYyNTUsaDY+Pj4xNiYyNTUsaDY+Pj44JjI1NSxoNj4+PjAmMjU1LGg3Pj4+MjQmMjU1LGg3Pj4+MTYmMjU1LGg3Pj4+OCYyNTUsaDc+Pj4wJjI1NV19ZnVuY3Rpb24gUEJLREYyX0hNQUNfU0hBMjU2X09uZUl0ZXIocGFzc3dvcmQsc2FsdCxka0xlbil7cGFzc3dvcmQ9cGFzc3dvcmQubGVuZ3RoPD02ND9wYXNzd29yZDpTSEEyNTYocGFzc3dvcmQpO2NvbnN0IGlubmVyTGVuPTY0K3NhbHQubGVuZ3RoKzQ7Y29uc3QgaW5uZXI9bmV3IEFycmF5KGlubmVyTGVuKTtjb25zdCBvdXRlcktleT1uZXcgQXJyYXkoNjQpO2xldCBpO2xldCBkaz1bXTtmb3IoaT0wO2k8NjQ7aSsrKXtpbm5lcltpXT01NH1mb3IoaT0wO2k8cGFzc3dvcmQubGVuZ3RoO2krKyl7aW5uZXJbaV1ePXBhc3N3b3JkW2ldfWZvcihpPTA7aTxzYWx0Lmxlbmd0aDtpKyspe2lubmVyWzY0K2ldPXNhbHRbaV19Zm9yKGk9aW5uZXJMZW4tNDtpPGlubmVyTGVuO2krKyl7aW5uZXJbaV09MH1mb3IoaT0wO2k8NjQ7aSsrKW91dGVyS2V5W2ldPTkyO2ZvcihpPTA7aTxwYXNzd29yZC5sZW5ndGg7aSsrKW91dGVyS2V5W2ldXj1wYXNzd29yZFtpXTtmdW5jdGlvbiBpbmNyZW1lbnRDb3VudGVyKCl7Zm9yKGxldCBpPWlubmVyTGVuLTE7aT49aW5uZXJMZW4tNDtpLS0pe2lubmVyW2ldKys7aWYoaW5uZXJbaV08PTI1NSlyZXR1cm47aW5uZXJbaV09MH19d2hpbGUoZGtMZW4+PTMyKXtpbmNyZW1lbnRDb3VudGVyKCk7ZGs9ZGsuY29uY2F0KFNIQTI1NihvdXRlcktleS5jb25jYXQoU0hBMjU2KGlubmVyKSkpKTtka0xlbi09MzJ9aWYoZGtMZW4+MCl7aW5jcmVtZW50Q291bnRlcigpO2RrPWRrLmNvbmNhdChTSEEyNTYob3V0ZXJLZXkuY29uY2F0KFNIQTI1Nihpbm5lcikpKS5zbGljZSgwLGRrTGVuKSl9cmV0dXJuIGRrfWZ1bmN0aW9uIGJsb2NrbWl4X3NhbHNhOChCWSxZaSxyLHgsX1gpe2xldCBpO2FycmF5Y29weShCWSwoMipyLTEpKjE2LF9YLDAsMTYpO2ZvcihpPTA7aTwyKnI7aSsrKXtibG9ja3hvcihCWSxpKjE2LF9YLDE2KTtzYWxzYTIwXzgoX1gseCk7YXJyYXljb3B5KF9YLDAsQlksWWkraSoxNiwxNil9Zm9yKGk9MDtpPHI7aSsrKXthcnJheWNvcHkoQlksWWkraSoyKjE2LEJZLGkqMTYsMTYpfWZvcihpPTA7aTxyO2krKyl7YXJyYXljb3B5KEJZLFlpKyhpKjIrMSkqMTYsQlksKGkrcikqMTYsMTYpfX1mdW5jdGlvbiBSKGEsYil7cmV0dXJuIGE8PGJ8YT4+PjMyLWJ9ZnVuY3Rpb24gc2Fsc2EyMF84KEIseCl7YXJyYXljb3B5KEIsMCx4LDAsMTYpO2ZvcihsZXQgaT04O2k+MDtpLT0yKXt4WzRdXj1SKHhbMF0reFsxMl0sNyk7eFs4XV49Uih4WzRdK3hbMF0sOSk7eFsxMl1ePVIoeFs4XSt4WzRdLDEzKTt4WzBdXj1SKHhbMTJdK3hbOF0sMTgpO3hbOV1ePVIoeFs1XSt4WzFdLDcpO3hbMTNdXj1SKHhbOV0reFs1XSw5KTt4WzFdXj1SKHhbMTNdK3hbOV0sMTMpO3hbNV1ePVIoeFsxXSt4WzEzXSwxOCk7eFsxNF1ePVIoeFsxMF0reFs2XSw3KTt4WzJdXj1SKHhbMTRdK3hbMTBdLDkpO3hbNl1ePVIoeFsyXSt4WzE0XSwxMyk7eFsxMF1ePVIoeFs2XSt4WzJdLDE4KTt4WzNdXj1SKHhbMTVdK3hbMTFdLDcpO3hbN11ePVIoeFszXSt4WzE1XSw5KTt4WzExXV49Uih4WzddK3hbM10sMTMpO3hbMTVdXj1SKHhbMTFdK3hbN10sMTgpO3hbMV1ePVIoeFswXSt4WzNdLDcpO3hbMl1ePVIoeFsxXSt4WzBdLDkpO3hbM11ePVIoeFsyXSt4WzFdLDEzKTt4WzBdXj1SKHhbM10reFsyXSwxOCk7eFs2XV49Uih4WzVdK3hbNF0sNyk7eFs3XV49Uih4WzZdK3hbNV0sOSk7eFs0XV49Uih4WzddK3hbNl0sMTMpO3hbNV1ePVIoeFs0XSt4WzddLDE4KTt4WzExXV49Uih4WzEwXSt4WzldLDcpO3hbOF1ePVIoeFsxMV0reFsxMF0sOSk7eFs5XV49Uih4WzhdK3hbMTFdLDEzKTt4WzEwXV49Uih4WzldK3hbOF0sMTgpO3hbMTJdXj1SKHhbMTVdK3hbMTRdLDcpO3hbMTNdXj1SKHhbMTJdK3hbMTVdLDkpO3hbMTRdXj1SKHhbMTNdK3hbMTJdLDEzKTt4WzE1XV49Uih4WzE0XSt4WzEzXSwxOCl9Zm9yKGxldCBpPTA7aTwxNjsrK2kpe0JbaV0rPXhbaV19fWZ1bmN0aW9uIGJsb2NreG9yKFMsU2ksRCxsZW4pe2ZvcihsZXQgaT0wO2k8bGVuO2krKyl7RFtpXV49U1tTaStpXX19ZnVuY3Rpb24gYXJyYXljb3B5KHNyYyxzcmNQb3MsZGVzdCxkZXN0UG9zLGxlbmd0aCl7d2hpbGUobGVuZ3RoLS0pe2Rlc3RbZGVzdFBvcysrXT1zcmNbc3JjUG9zKytdfX1mdW5jdGlvbiBjaGVja0J1ZmZlcmlzaChvKXtpZighb3x8dHlwZW9mIG8ubGVuZ3RoIT09XCJudW1iZXJcIil7cmV0dXJuIGZhbHNlfWZvcihsZXQgaT0wO2k8by5sZW5ndGg7aSsrKXtjb25zdCB2PW9baV07aWYodHlwZW9mIHYhPT1cIm51bWJlclwifHx2JTF8fHY8MHx8dj49MjU2KXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfWZ1bmN0aW9uIGVuc3VyZUludGVnZXIodmFsdWUsbmFtZSl7aWYodHlwZW9mIHZhbHVlIT09XCJudW1iZXJcInx8dmFsdWUlMSl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBcIituYW1lKX1yZXR1cm4gdmFsdWV9ZnVuY3Rpb24gX3NjcnlwdChwYXNzd29yZCxzYWx0LE4scixwLGRrTGVuLGNhbGxiYWNrKXtOPWVuc3VyZUludGVnZXIoTixcIk5cIik7cj1lbnN1cmVJbnRlZ2VyKHIsXCJyXCIpO3A9ZW5zdXJlSW50ZWdlcihwLFwicFwiKTtka0xlbj1lbnN1cmVJbnRlZ2VyKGRrTGVuLFwiZGtMZW5cIik7aWYoTj09PTB8fChOJk4tMSkhPT0wKXt0aHJvdyBuZXcgRXJyb3IoXCJOIG11c3QgYmUgcG93ZXIgb2YgMlwiKX1pZihOPk1BWF9WQUxVRS8xMjgvcil7dGhyb3cgbmV3IEVycm9yKFwiTiB0b28gbGFyZ2VcIil9aWYocj5NQVhfVkFMVUUvMTI4L3Ape3Rocm93IG5ldyBFcnJvcihcInIgdG9vIGxhcmdlXCIpfWlmKCFjaGVja0J1ZmZlcmlzaChwYXNzd29yZCkpe3Rocm93IG5ldyBFcnJvcihcInBhc3N3b3JkIG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyXCIpfXBhc3N3b3JkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhc3N3b3JkKTtpZighY2hlY2tCdWZmZXJpc2goc2FsdCkpe3Rocm93IG5ldyBFcnJvcihcInNhbHQgbXVzdCBiZSBhbiBhcnJheSBvciBidWZmZXJcIil9c2FsdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzYWx0KTtsZXQgYj1QQktERjJfSE1BQ19TSEEyNTZfT25lSXRlcihwYXNzd29yZCxzYWx0LHAqMTI4KnIpO2NvbnN0IEI9bmV3IFVpbnQzMkFycmF5KHAqMzIqcik7Zm9yKGxldCBpPTA7aTxCLmxlbmd0aDtpKyspe2NvbnN0IGo9aSo0O0JbaV09KGJbaiszXSYyNTUpPDwyNHwoYltqKzJdJjI1NSk8PDE2fChiW2orMV0mMjU1KTw8OHwoYltqKzBdJjI1NSk8PDB9Y29uc3QgWFk9bmV3IFVpbnQzMkFycmF5KDY0KnIpO2NvbnN0IFY9bmV3IFVpbnQzMkFycmF5KDMyKnIqTik7Y29uc3QgWWk9MzIqcjtjb25zdCB4PW5ldyBVaW50MzJBcnJheSgxNik7Y29uc3QgX1g9bmV3IFVpbnQzMkFycmF5KDE2KTtjb25zdCB0b3RhbE9wcz1wKk4qMjtsZXQgY3VycmVudE9wPTA7bGV0IGxhc3RQZXJjZW50MTA9bnVsbDtsZXQgc3RvcD1mYWxzZTtsZXQgc3RhdGU9MDtsZXQgaTA9MCxpMTtsZXQgQmk7Y29uc3QgbGltaXQ9Y2FsbGJhY2s/cGFyc2VJbnQoMWUzL3IpOjQyOTQ5NjcyOTU7Y29uc3QgbmV4dFRpY2s9dHlwZW9mIHNldEltbWVkaWF0ZSE9PVwidW5kZWZpbmVkXCI/c2V0SW1tZWRpYXRlOnNldFRpbWVvdXQ7Y29uc3QgaW5jcmVtZW50YWxTTWl4PWZ1bmN0aW9uKCl7aWYoc3RvcCl7cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImNhbmNlbGxlZFwiKSxjdXJyZW50T3AvdG90YWxPcHMpfWxldCBzdGVwcztzd2l0Y2goc3RhdGUpe2Nhc2UgMDpCaT1pMCozMipyO2FycmF5Y29weShCLEJpLFhZLDAsWWkpO3N0YXRlPTE7aTE9MDtjYXNlIDE6c3RlcHM9Ti1pMTtpZihzdGVwcz5saW1pdCl7c3RlcHM9bGltaXR9Zm9yKGxldCBpPTA7aTxzdGVwcztpKyspe2FycmF5Y29weShYWSwwLFYsKGkxK2kpKllpLFlpKTtibG9ja21peF9zYWxzYTgoWFksWWkscix4LF9YKX1pMSs9c3RlcHM7Y3VycmVudE9wKz1zdGVwcztpZihjYWxsYmFjayl7Y29uc3QgcGVyY2VudDEwPXBhcnNlSW50KDFlMypjdXJyZW50T3AvdG90YWxPcHMpO2lmKHBlcmNlbnQxMCE9PWxhc3RQZXJjZW50MTApe3N0b3A9Y2FsbGJhY2sobnVsbCxjdXJyZW50T3AvdG90YWxPcHMpO2lmKHN0b3Ape2JyZWFrfWxhc3RQZXJjZW50MTA9cGVyY2VudDEwfX1pZihpMTxOKXticmVha31pMT0wO3N0YXRlPTI7Y2FzZSAyOnN0ZXBzPU4taTE7aWYoc3RlcHM+bGltaXQpe3N0ZXBzPWxpbWl0fWZvcihsZXQgaT0wO2k8c3RlcHM7aSsrKXtjb25zdCBvZmZzZXQ9KDIqci0xKSoxNjtjb25zdCBqPVhZW29mZnNldF0mTi0xO2Jsb2NreG9yKFYsaipZaSxYWSxZaSk7YmxvY2ttaXhfc2Fsc2E4KFhZLFlpLHIseCxfWCl9aTErPXN0ZXBzO2N1cnJlbnRPcCs9c3RlcHM7aWYoY2FsbGJhY2spe2NvbnN0IHBlcmNlbnQxMD1wYXJzZUludCgxZTMqY3VycmVudE9wL3RvdGFsT3BzKTtpZihwZXJjZW50MTAhPT1sYXN0UGVyY2VudDEwKXtzdG9wPWNhbGxiYWNrKG51bGwsY3VycmVudE9wL3RvdGFsT3BzKTtpZihzdG9wKXticmVha31sYXN0UGVyY2VudDEwPXBlcmNlbnQxMH19aWYoaTE8Til7YnJlYWt9YXJyYXljb3B5KFhZLDAsQixCaSxZaSk7aTArKztpZihpMDxwKXtzdGF0ZT0wO2JyZWFrfWI9W107Zm9yKGxldCBpPTA7aTxCLmxlbmd0aDtpKyspe2IucHVzaChCW2ldPj4wJjI1NSk7Yi5wdXNoKEJbaV0+PjgmMjU1KTtiLnB1c2goQltpXT4+MTYmMjU1KTtiLnB1c2goQltpXT4+MjQmMjU1KX1jb25zdCBkZXJpdmVkS2V5PVBCS0RGMl9ITUFDX1NIQTI1Nl9PbmVJdGVyKHBhc3N3b3JkLGIsZGtMZW4pO2lmKGNhbGxiYWNrKXtjYWxsYmFjayhudWxsLDEsZGVyaXZlZEtleSl9cmV0dXJuIGRlcml2ZWRLZXl9aWYoY2FsbGJhY2spe25leHRUaWNrKGluY3JlbWVudGFsU01peCl9fTtpZighY2FsbGJhY2spe3doaWxlKHRydWUpe2NvbnN0IGRlcml2ZWRLZXk9aW5jcmVtZW50YWxTTWl4KCk7aWYoZGVyaXZlZEtleSE9dW5kZWZpbmVkKXtyZXR1cm4gZGVyaXZlZEtleX19fWluY3JlbWVudGFsU01peCgpfWNvbnN0IGxpYj17c2NyeXB0OmZ1bmN0aW9uKHBhc3N3b3JkLHNhbHQsTixyLHAsZGtMZW4scHJvZ3Jlc3NDYWxsYmFjayl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtsZXQgbGFzdFByb2dyZXNzPTA7aWYocHJvZ3Jlc3NDYWxsYmFjayl7cHJvZ3Jlc3NDYWxsYmFjaygwKX1fc2NyeXB0KHBhc3N3b3JkLHNhbHQsTixyLHAsZGtMZW4sZnVuY3Rpb24oZXJyb3IscHJvZ3Jlc3Msa2V5KXtpZihlcnJvcil7cmVqZWN0KGVycm9yKX1lbHNlIGlmKGtleSl7aWYocHJvZ3Jlc3NDYWxsYmFjayYmbGFzdFByb2dyZXNzIT09MSl7cHJvZ3Jlc3NDYWxsYmFjaygxKX1yZXNvbHZlKG5ldyBVaW50OEFycmF5KGtleSkpfWVsc2UgaWYocHJvZ3Jlc3NDYWxsYmFjayYmcHJvZ3Jlc3MhPT1sYXN0UHJvZ3Jlc3Mpe2xhc3RQcm9ncmVzcz1wcm9ncmVzcztyZXR1cm4gcHJvZ3Jlc3NDYWxsYmFjayhwcm9ncmVzcyl9fSl9KX0sc3luY1NjcnlwdDpmdW5jdGlvbihwYXNzd29yZCxzYWx0LE4scixwLGRrTGVuKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX3NjcnlwdChwYXNzd29yZCxzYWx0LE4scixwLGRrTGVuKSl9fTtpZihcIm9iamVjdFwiIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9bGlifWVsc2UgaWYodHlwZW9mIHVuZGVmaW5lZD09PVwiZnVuY3Rpb25cIiYmdW5kZWZpbmVkLmFtZCl7dW5kZWZpbmVkKGxpYil9ZWxzZSBpZihyb290KXtpZihyb290LnNjcnlwdCl7cm9vdC5fc2NyeXB0PXJvb3Quc2NyeXB0fXJvb3Quc2NyeXB0PWxpYn19KShjb21tb25qc0dsb2JhbCl9KTtcInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyJDQ9d2luZG93JiZ3aW5kb3cuX19hd2FpdGVyfHxmdW5jdGlvbih0aGlzQXJnLF9hcmd1bWVudHMsUCxnZW5lcmF0b3Ipe2Z1bmN0aW9uIGFkb3B0KHZhbHVlKXtyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQP3ZhbHVlOm5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpe3Jlc29sdmUodmFsdWUpfSl9cmV0dXJuIG5ldyhQfHwoUD1Qcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2Z1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gc3RlcChyZXN1bHQpe3Jlc3VsdC5kb25lP3Jlc29sdmUocmVzdWx0LnZhbHVlKTphZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChnZW5lcmF0b3I9Z2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsX2FyZ3VtZW50c3x8W10pKS5uZXh0KCkpfSl9O2NvbnN0IGxvZ2dlciRvPW5ldyBMb2dnZXIodmVyc2lvbiRpKTtmdW5jdGlvbiBoYXNNbmVtb25pYyh2YWx1ZSl7cmV0dXJuIHZhbHVlIT1udWxsJiZ2YWx1ZS5tbmVtb25pYyYmdmFsdWUubW5lbW9uaWMucGhyYXNlfWNsYXNzIEtleXN0b3JlQWNjb3VudCBleHRlbmRzIERlc2NyaXB0aW9ue2lzS2V5c3RvcmVBY2NvdW50KHZhbHVlKXtyZXR1cm4hISh2YWx1ZSYmdmFsdWUuX2lzS2V5c3RvcmVBY2NvdW50KX19ZnVuY3Rpb24gX2RlY3J5cHQoZGF0YSxrZXksY2lwaGVydGV4dCl7Y29uc3QgY2lwaGVyPXNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9jaXBoZXJcIik7aWYoY2lwaGVyPT09XCJhZXMtMTI4LWN0clwiKXtjb25zdCBpdj1sb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9jaXBoZXJwYXJhbXMvaXZcIikpO2NvbnN0IGNvdW50ZXI9bmV3IGFlc0pzLkNvdW50ZXIoaXYpO2NvbnN0IGFlc0N0cj1uZXcgYWVzSnMuTW9kZU9mT3BlcmF0aW9uLmN0cihrZXksY291bnRlcik7cmV0dXJuIGFycmF5aWZ5KGFlc0N0ci5kZWNyeXB0KGNpcGhlcnRleHQpKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBfZ2V0QWNjb3VudChkYXRhLGtleSl7Y29uc3QgY2lwaGVydGV4dD1sb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9jaXBoZXJ0ZXh0XCIpKTtjb25zdCBjb21wdXRlZE1BQz1oZXhsaWZ5KGtlY2NhazI1Nihjb25jYXQoW2tleS5zbGljZSgxNiwzMiksY2lwaGVydGV4dF0pKSkuc3Vic3RyaW5nKDIpO2lmKGNvbXB1dGVkTUFDIT09c2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL21hY1wiKS50b0xvd2VyQ2FzZSgpKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhc3N3b3JkXCIpfWNvbnN0IHByaXZhdGVLZXk9X2RlY3J5cHQoZGF0YSxrZXkuc2xpY2UoMCwxNiksY2lwaGVydGV4dCk7aWYoIXByaXZhdGVLZXkpe2xvZ2dlciRvLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBjaXBoZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiZGVjcnlwdFwifSl9Y29uc3QgbW5lbW9uaWNLZXk9a2V5LnNsaWNlKDMyLDY0KTtjb25zdCBhZGRyZXNzPWNvbXB1dGVBZGRyZXNzKHByaXZhdGVLZXkpO2lmKGRhdGEuYWRkcmVzcyl7bGV0IGNoZWNrPWRhdGEuYWRkcmVzcy50b0xvd2VyQ2FzZSgpO2lmKGNoZWNrLnN1YnN0cmluZygwLDIpIT09XCIweFwiKXtjaGVjaz1cIjB4XCIrY2hlY2t9aWYoZ2V0QWRkcmVzcyhjaGVjaykhPT1hZGRyZXNzKXt0aHJvdyBuZXcgRXJyb3IoXCJhZGRyZXNzIG1pc21hdGNoXCIpfX1jb25zdCBhY2NvdW50PXtfaXNLZXlzdG9yZUFjY291bnQ6dHJ1ZSxhZGRyZXNzOmFkZHJlc3MscHJpdmF0ZUtleTpoZXhsaWZ5KHByaXZhdGVLZXkpfTtpZihzZWFyY2hQYXRoKGRhdGEsXCJ4LWV0aGVycy92ZXJzaW9uXCIpPT09XCIwLjFcIil7Y29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0PWxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLFwieC1ldGhlcnMvbW5lbW9uaWNDaXBoZXJ0ZXh0XCIpKTtjb25zdCBtbmVtb25pY0l2PWxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLFwieC1ldGhlcnMvbW5lbW9uaWNDb3VudGVyXCIpKTtjb25zdCBtbmVtb25pY0NvdW50ZXI9bmV3IGFlc0pzLkNvdW50ZXIobW5lbW9uaWNJdik7Y29uc3QgbW5lbW9uaWNBZXNDdHI9bmV3IGFlc0pzLk1vZGVPZk9wZXJhdGlvbi5jdHIobW5lbW9uaWNLZXksbW5lbW9uaWNDb3VudGVyKTtjb25zdCBwYXRoPXNlYXJjaFBhdGgoZGF0YSxcIngtZXRoZXJzL3BhdGhcIil8fGRlZmF1bHRQYXRoO2NvbnN0IGxvY2FsZT1zZWFyY2hQYXRoKGRhdGEsXCJ4LWV0aGVycy9sb2NhbGVcIil8fFwiZW5cIjtjb25zdCBlbnRyb3B5PWFycmF5aWZ5KG1uZW1vbmljQWVzQ3RyLmRlY3J5cHQobW5lbW9uaWNDaXBoZXJ0ZXh0KSk7dHJ5e2NvbnN0IG1uZW1vbmljPWVudHJvcHlUb01uZW1vbmljKGVudHJvcHksbG9jYWxlKTtjb25zdCBub2RlPUhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMsbnVsbCxsb2NhbGUpLmRlcml2ZVBhdGgocGF0aCk7aWYobm9kZS5wcml2YXRlS2V5IT1hY2NvdW50LnByaXZhdGVLZXkpe3Rocm93IG5ldyBFcnJvcihcIm1uZW1vbmljIG1pc21hdGNoXCIpfWFjY291bnQubW5lbW9uaWM9bm9kZS5tbmVtb25pY31jYXRjaChlcnJvcil7aWYoZXJyb3IuY29kZSE9PUxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVHx8ZXJyb3IuYXJndW1lbnQhPT1cIndvcmRsaXN0XCIpe3Rocm93IGVycm9yfX19cmV0dXJuIG5ldyBLZXlzdG9yZUFjY291bnQoYWNjb3VudCl9ZnVuY3Rpb24gcGJrZGYyU3luYyhwYXNzd29yZEJ5dGVzLHNhbHQsY291bnQsZGtMZW4scHJmRnVuYyl7cmV0dXJuIGFycmF5aWZ5KHBia2RmMihwYXNzd29yZEJ5dGVzLHNhbHQsY291bnQsZGtMZW4scHJmRnVuYykpfWZ1bmN0aW9uIHBia2RmMiQxKHBhc3N3b3JkQnl0ZXMsc2FsdCxjb3VudCxka0xlbixwcmZGdW5jKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcyxzYWx0LGNvdW50LGRrTGVuLHByZkZ1bmMpKX1mdW5jdGlvbiBfY29tcHV0ZUtkZktleShkYXRhLHBhc3N3b3JkLHBia2RmMkZ1bmMsc2NyeXB0RnVuYyxwcm9ncmVzc0NhbGxiYWNrKXtjb25zdCBwYXNzd29yZEJ5dGVzPWdldFBhc3N3b3JkKHBhc3N3b3JkKTtjb25zdCBrZGY9c2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZlwiKTtpZihrZGYmJnR5cGVvZiBrZGY9PT1cInN0cmluZ1wiKXtjb25zdCB0aHJvd0Vycm9yPWZ1bmN0aW9uKG5hbWUsdmFsdWUpe3JldHVybiBsb2dnZXIkby50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIixuYW1lLHZhbHVlKX07aWYoa2RmLnRvTG93ZXJDYXNlKCk9PT1cInNjcnlwdFwiKXtjb25zdCBzYWx0PWxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9zYWx0XCIpKTtjb25zdCBOPXBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSxcImNyeXB0by9rZGZwYXJhbXMvblwiKSk7Y29uc3Qgcj1wYXJzZUludChzZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8va2RmcGFyYW1zL3JcIikpO2NvbnN0IHA9cGFyc2VJbnQoc2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9wXCIpKTtpZighTnx8IXJ8fCFwKXt0aHJvd0Vycm9yKFwia2RmXCIsa2RmKX1pZigoTiZOLTEpIT09MCl7dGhyb3dFcnJvcihcIk5cIixOKX1jb25zdCBka0xlbj1wYXJzZUludChzZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8va2RmcGFyYW1zL2RrbGVuXCIpKTtpZihka0xlbiE9PTMyKXt0aHJvd0Vycm9yKFwiZGtsZW5cIixka0xlbil9cmV0dXJuIHNjcnlwdEZ1bmMocGFzc3dvcmRCeXRlcyxzYWx0LE4scixwLDY0LHByb2dyZXNzQ2FsbGJhY2spfWVsc2UgaWYoa2RmLnRvTG93ZXJDYXNlKCk9PT1cInBia2RmMlwiKXtjb25zdCBzYWx0PWxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9zYWx0XCIpKTtsZXQgcHJmRnVuYz1udWxsO2NvbnN0IHByZj1zZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8va2RmcGFyYW1zL3ByZlwiKTtpZihwcmY9PT1cImhtYWMtc2hhMjU2XCIpe3ByZkZ1bmM9XCJzaGEyNTZcIn1lbHNlIGlmKHByZj09PVwiaG1hYy1zaGE1MTJcIil7cHJmRnVuYz1cInNoYTUxMlwifWVsc2V7dGhyb3dFcnJvcihcInByZlwiLHByZil9Y29uc3QgY291bnQ9cGFyc2VJbnQoc2VhcmNoUGF0aChkYXRhLFwiY3J5cHRvL2tkZnBhcmFtcy9jXCIpKTtjb25zdCBka0xlbj1wYXJzZUludChzZWFyY2hQYXRoKGRhdGEsXCJjcnlwdG8va2RmcGFyYW1zL2RrbGVuXCIpKTtpZihka0xlbiE9PTMyKXt0aHJvd0Vycm9yKFwiZGtsZW5cIixka0xlbil9cmV0dXJuIHBia2RmMkZ1bmMocGFzc3dvcmRCeXRlcyxzYWx0LGNvdW50LGRrTGVuLHByZkZ1bmMpfX1yZXR1cm4gbG9nZ2VyJG8udGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZnVuY3Rpb25cIixcImtkZlwiLGtkZil9ZnVuY3Rpb24gZGVjcnlwdFN5bmMoanNvbixwYXNzd29yZCl7Y29uc3QgZGF0YT1KU09OLnBhcnNlKGpzb24pO2NvbnN0IGtleT1fY29tcHV0ZUtkZktleShkYXRhLHBhc3N3b3JkLHBia2RmMlN5bmMsc2NyeXB0LnN5bmNTY3J5cHQpO3JldHVybiBfZ2V0QWNjb3VudChkYXRhLGtleSl9ZnVuY3Rpb24gZGVjcnlwdCQxKGpzb24scGFzc3dvcmQscHJvZ3Jlc3NDYWxsYmFjayl7cmV0dXJuIF9fYXdhaXRlciQ0KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBkYXRhPUpTT04ucGFyc2UoanNvbik7Y29uc3Qga2V5PXlpZWxkIF9jb21wdXRlS2RmS2V5KGRhdGEscGFzc3dvcmQscGJrZGYyJDEsc2NyeXB0LnNjcnlwdCxwcm9ncmVzc0NhbGxiYWNrKTtyZXR1cm4gX2dldEFjY291bnQoZGF0YSxrZXkpfSl9ZnVuY3Rpb24gZW5jcnlwdChhY2NvdW50LHBhc3N3b3JkLG9wdGlvbnMscHJvZ3Jlc3NDYWxsYmFjayl7dHJ5e2lmKGdldEFkZHJlc3MoYWNjb3VudC5hZGRyZXNzKSE9PWNvbXB1dGVBZGRyZXNzKGFjY291bnQucHJpdmF0ZUtleSkpe3Rocm93IG5ldyBFcnJvcihcImFkZHJlc3MvcHJpdmF0ZUtleSBtaXNtYXRjaFwiKX1pZihoYXNNbmVtb25pYyhhY2NvdW50KSl7Y29uc3QgbW5lbW9uaWM9YWNjb3VudC5tbmVtb25pYztjb25zdCBub2RlPUhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLG51bGwsbW5lbW9uaWMubG9jYWxlKS5kZXJpdmVQYXRoKG1uZW1vbmljLnBhdGh8fGRlZmF1bHRQYXRoKTtpZihub2RlLnByaXZhdGVLZXkhPWFjY291bnQucHJpdmF0ZUtleSl7dGhyb3cgbmV3IEVycm9yKFwibW5lbW9uaWMgbWlzbWF0Y2hcIil9fX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9aWYodHlwZW9mIG9wdGlvbnM9PT1cImZ1bmN0aW9uXCImJiFwcm9ncmVzc0NhbGxiYWNrKXtwcm9ncmVzc0NhbGxiYWNrPW9wdGlvbnM7b3B0aW9ucz17fX1pZighb3B0aW9ucyl7b3B0aW9ucz17fX1jb25zdCBwcml2YXRlS2V5PWFycmF5aWZ5KGFjY291bnQucHJpdmF0ZUtleSk7Y29uc3QgcGFzc3dvcmRCeXRlcz1nZXRQYXNzd29yZChwYXNzd29yZCk7bGV0IGVudHJvcHk9bnVsbDtsZXQgcGF0aD1udWxsO2xldCBsb2NhbGU9bnVsbDtpZihoYXNNbmVtb25pYyhhY2NvdW50KSl7Y29uc3Qgc3JjTW5lbW9uaWM9YWNjb3VudC5tbmVtb25pYztlbnRyb3B5PWFycmF5aWZ5KG1uZW1vbmljVG9FbnRyb3B5KHNyY01uZW1vbmljLnBocmFzZSxzcmNNbmVtb25pYy5sb2NhbGV8fFwiZW5cIikpO3BhdGg9c3JjTW5lbW9uaWMucGF0aHx8ZGVmYXVsdFBhdGg7bG9jYWxlPXNyY01uZW1vbmljLmxvY2FsZXx8XCJlblwifWxldCBjbGllbnQ9b3B0aW9ucy5jbGllbnQ7aWYoIWNsaWVudCl7Y2xpZW50PVwiZXRoZXJzLmpzXCJ9bGV0IHNhbHQ9bnVsbDtpZihvcHRpb25zLnNhbHQpe3NhbHQ9YXJyYXlpZnkob3B0aW9ucy5zYWx0KX1lbHNle3NhbHQ9cmFuZG9tQnl0ZXMoMzIpfWxldCBpdj1udWxsO2lmKG9wdGlvbnMuaXYpe2l2PWFycmF5aWZ5KG9wdGlvbnMuaXYpO2lmKGl2Lmxlbmd0aCE9PTE2KXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl2XCIpfX1lbHNle2l2PXJhbmRvbUJ5dGVzKDE2KX1sZXQgdXVpZFJhbmRvbT1udWxsO2lmKG9wdGlvbnMudXVpZCl7dXVpZFJhbmRvbT1hcnJheWlmeShvcHRpb25zLnV1aWQpO2lmKHV1aWRSYW5kb20ubGVuZ3RoIT09MTYpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgdXVpZFwiKX19ZWxzZXt1dWlkUmFuZG9tPXJhbmRvbUJ5dGVzKDE2KX1sZXQgTj0xPDwxNyxyPTgscD0xO2lmKG9wdGlvbnMuc2NyeXB0KXtpZihvcHRpb25zLnNjcnlwdC5OKXtOPW9wdGlvbnMuc2NyeXB0Lk59aWYob3B0aW9ucy5zY3J5cHQucil7cj1vcHRpb25zLnNjcnlwdC5yfWlmKG9wdGlvbnMuc2NyeXB0LnApe3A9b3B0aW9ucy5zY3J5cHQucH19cmV0dXJuIHNjcnlwdC5zY3J5cHQocGFzc3dvcmRCeXRlcyxzYWx0LE4scixwLDY0LHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oa2V5PT57a2V5PWFycmF5aWZ5KGtleSk7Y29uc3QgZGVyaXZlZEtleT1rZXkuc2xpY2UoMCwxNik7Y29uc3QgbWFjUHJlZml4PWtleS5zbGljZSgxNiwzMik7Y29uc3QgbW5lbW9uaWNLZXk9a2V5LnNsaWNlKDMyLDY0KTtjb25zdCBjb3VudGVyPW5ldyBhZXNKcy5Db3VudGVyKGl2KTtjb25zdCBhZXNDdHI9bmV3IGFlc0pzLk1vZGVPZk9wZXJhdGlvbi5jdHIoZGVyaXZlZEtleSxjb3VudGVyKTtjb25zdCBjaXBoZXJ0ZXh0PWFycmF5aWZ5KGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtjb25zdCBtYWM9a2VjY2FrMjU2KGNvbmNhdChbbWFjUHJlZml4LGNpcGhlcnRleHRdKSk7Y29uc3QgZGF0YT17YWRkcmVzczphY2NvdW50LmFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCksaWQ6dXVpZFY0KHV1aWRSYW5kb20pLHZlcnNpb246MyxDcnlwdG86e2NpcGhlcjpcImFlcy0xMjgtY3RyXCIsY2lwaGVycGFyYW1zOntpdjpoZXhsaWZ5KGl2KS5zdWJzdHJpbmcoMil9LGNpcGhlcnRleHQ6aGV4bGlmeShjaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksa2RmOlwic2NyeXB0XCIsa2RmcGFyYW1zOntzYWx0OmhleGxpZnkoc2FsdCkuc3Vic3RyaW5nKDIpLG46Tixka2xlbjozMixwOnAscjpyfSxtYWM6bWFjLnN1YnN0cmluZygyKX19O2lmKGVudHJvcHkpe2NvbnN0IG1uZW1vbmljSXY9cmFuZG9tQnl0ZXMoMTYpO2NvbnN0IG1uZW1vbmljQ291bnRlcj1uZXcgYWVzSnMuQ291bnRlcihtbmVtb25pY0l2KTtjb25zdCBtbmVtb25pY0Flc0N0cj1uZXcgYWVzSnMuTW9kZU9mT3BlcmF0aW9uLmN0cihtbmVtb25pY0tleSxtbmVtb25pY0NvdW50ZXIpO2NvbnN0IG1uZW1vbmljQ2lwaGVydGV4dD1hcnJheWlmeShtbmVtb25pY0Flc0N0ci5lbmNyeXB0KGVudHJvcHkpKTtjb25zdCBub3c9bmV3IERhdGU7Y29uc3QgdGltZXN0YW1wPW5vdy5nZXRVVENGdWxsWWVhcigpK1wiLVwiK3pwYWQobm93LmdldFVUQ01vbnRoKCkrMSwyKStcIi1cIit6cGFkKG5vdy5nZXRVVENEYXRlKCksMikrXCJUXCIrenBhZChub3cuZ2V0VVRDSG91cnMoKSwyKStcIi1cIit6cGFkKG5vdy5nZXRVVENNaW51dGVzKCksMikrXCItXCIrenBhZChub3cuZ2V0VVRDU2Vjb25kcygpLDIpK1wiLjBaXCI7ZGF0YVtcIngtZXRoZXJzXCJdPXtjbGllbnQ6Y2xpZW50LGdldGhGaWxlbmFtZTpcIlVUQy0tXCIrdGltZXN0YW1wK1wiLS1cIitkYXRhLmFkZHJlc3MsbW5lbW9uaWNDb3VudGVyOmhleGxpZnkobW5lbW9uaWNJdikuc3Vic3RyaW5nKDIpLG1uZW1vbmljQ2lwaGVydGV4dDpoZXhsaWZ5KG1uZW1vbmljQ2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLHBhdGg6cGF0aCxsb2NhbGU6bG9jYWxlLHZlcnNpb246XCIwLjFcIn19cmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpfSl9XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZGVjcnlwdEpzb25XYWxsZXQoanNvbixwYXNzd29yZCxwcm9ncmVzc0NhbGxiYWNrKXtpZihpc0Nyb3dkc2FsZVdhbGxldChqc29uKSl7aWYocHJvZ3Jlc3NDYWxsYmFjayl7cHJvZ3Jlc3NDYWxsYmFjaygwKX1jb25zdCBhY2NvdW50PWRlY3J5cHQoanNvbixwYXNzd29yZCk7aWYocHJvZ3Jlc3NDYWxsYmFjayl7cHJvZ3Jlc3NDYWxsYmFjaygxKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFjY291bnQpfWlmKGlzS2V5c3RvcmVXYWxsZXQoanNvbikpe3JldHVybiBkZWNyeXB0JDEoanNvbixwYXNzd29yZCxwcm9ncmVzc0NhbGxiYWNrKX1yZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBKU09OIHdhbGxldFwiKSl9ZnVuY3Rpb24gZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24scGFzc3dvcmQpe2lmKGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pKXtyZXR1cm4gZGVjcnlwdChqc29uLHBhc3N3b3JkKX1pZihpc0tleXN0b3JlV2FsbGV0KGpzb24pKXtyZXR1cm4gZGVjcnlwdFN5bmMoanNvbixwYXNzd29yZCl9dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBKU09OIHdhbGxldFwiKX1jb25zdCB2ZXJzaW9uJGo9XCJ3YWxsZXQvNS4xLjBcIjtcInVzZSBzdHJpY3RcIjt2YXIgX19hd2FpdGVyJDU9d2luZG93JiZ3aW5kb3cuX19hd2FpdGVyfHxmdW5jdGlvbih0aGlzQXJnLF9hcmd1bWVudHMsUCxnZW5lcmF0b3Ipe2Z1bmN0aW9uIGFkb3B0KHZhbHVlKXtyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQP3ZhbHVlOm5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpe3Jlc29sdmUodmFsdWUpfSl9cmV0dXJuIG5ldyhQfHwoUD1Qcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2Z1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gc3RlcChyZXN1bHQpe3Jlc3VsdC5kb25lP3Jlc29sdmUocmVzdWx0LnZhbHVlKTphZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChnZW5lcmF0b3I9Z2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsX2FyZ3VtZW50c3x8W10pKS5uZXh0KCkpfSl9O2NvbnN0IGxvZ2dlciRwPW5ldyBMb2dnZXIodmVyc2lvbiRqKTtmdW5jdGlvbiBpc0FjY291bnQodmFsdWUpe3JldHVybiB2YWx1ZSE9bnVsbCYmaXNIZXhTdHJpbmcodmFsdWUucHJpdmF0ZUtleSwzMikmJnZhbHVlLmFkZHJlc3MhPW51bGx9ZnVuY3Rpb24gaGFzTW5lbW9uaWMkMSh2YWx1ZSl7Y29uc3QgbW5lbW9uaWM9dmFsdWUubW5lbW9uaWM7cmV0dXJuIG1uZW1vbmljJiZtbmVtb25pYy5waHJhc2V9Y2xhc3MgV2FsbGV0IGV4dGVuZHMgU2lnbmVye2NvbnN0cnVjdG9yKHByaXZhdGVLZXkscHJvdmlkZXIpe2xvZ2dlciRwLmNoZWNrTmV3KG5ldy50YXJnZXQsV2FsbGV0KTtzdXBlcigpO2lmKGlzQWNjb3VudChwcml2YXRlS2V5KSl7Y29uc3Qgc2lnbmluZ0tleT1uZXcgU2lnbmluZ0tleShwcml2YXRlS2V5LnByaXZhdGVLZXkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfc2lnbmluZ0tleVwiLCgpPT5zaWduaW5nS2V5KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYWRkcmVzc1wiLGNvbXB1dGVBZGRyZXNzKHRoaXMucHVibGljS2V5KSk7aWYodGhpcy5hZGRyZXNzIT09Z2V0QWRkcmVzcyhwcml2YXRlS2V5LmFkZHJlc3MpKXtsb2dnZXIkcC50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcml2YXRlS2V5L2FkZHJlc3MgbWlzbWF0Y2hcIixcInByaXZhdGVLZXlcIixcIltSRURBQ1RFRF1cIil9aWYoaGFzTW5lbW9uaWMkMShwcml2YXRlS2V5KSl7Y29uc3Qgc3JjTW5lbW9uaWM9cHJpdmF0ZUtleS5tbmVtb25pYztkZWZpbmVSZWFkT25seSh0aGlzLFwiX21uZW1vbmljXCIsKCk9Pih7cGhyYXNlOnNyY01uZW1vbmljLnBocmFzZSxwYXRoOnNyY01uZW1vbmljLnBhdGh8fGRlZmF1bHRQYXRoLGxvY2FsZTpzcmNNbmVtb25pYy5sb2NhbGV8fFwiZW5cIn0pKTtjb25zdCBtbmVtb25pYz10aGlzLm1uZW1vbmljO2NvbnN0IG5vZGU9SEROb2RlLmZyb21NbmVtb25pYyhtbmVtb25pYy5waHJhc2UsbnVsbCxtbmVtb25pYy5sb2NhbGUpLmRlcml2ZVBhdGgobW5lbW9uaWMucGF0aCk7aWYoY29tcHV0ZUFkZHJlc3Mobm9kZS5wcml2YXRlS2V5KSE9PXRoaXMuYWRkcmVzcyl7bG9nZ2VyJHAudGhyb3dBcmd1bWVudEVycm9yKFwibW5lbW9uaWMvYWRkcmVzcyBtaXNtYXRjaFwiLFwicHJpdmF0ZUtleVwiLFwiW1JFREFDVEVEXVwiKX19ZWxzZXtkZWZpbmVSZWFkT25seSh0aGlzLFwiX21uZW1vbmljXCIsKCk9Pm51bGwpfX1lbHNle2lmKFNpZ25pbmdLZXkuaXNTaWduaW5nS2V5KHByaXZhdGVLZXkpKXtpZihwcml2YXRlS2V5LmN1cnZlIT09XCJzZWNwMjU2azFcIil7bG9nZ2VyJHAudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgY3VydmU7IG11c3QgYmUgc2VjcDI1NmsxXCIsXCJwcml2YXRlS2V5XCIsXCJbUkVEQUNURURdXCIpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJfc2lnbmluZ0tleVwiLCgpPT5wcml2YXRlS2V5KX1lbHNle2lmKHR5cGVvZiBwcml2YXRlS2V5PT09XCJzdHJpbmdcIil7aWYocHJpdmF0ZUtleS5tYXRjaCgvXlswLTlhLWZdKiQvaSkmJnByaXZhdGVLZXkubGVuZ3RoPT09NjQpe3ByaXZhdGVLZXk9XCIweFwiK3ByaXZhdGVLZXl9fWNvbnN0IHNpZ25pbmdLZXk9bmV3IFNpZ25pbmdLZXkocHJpdmF0ZUtleSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9zaWduaW5nS2V5XCIsKCk9PnNpZ25pbmdLZXkpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJfbW5lbW9uaWNcIiwoKT0+bnVsbCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIixjb21wdXRlQWRkcmVzcyh0aGlzLnB1YmxpY0tleSkpfWlmKHByb3ZpZGVyJiYhUHJvdmlkZXIuaXNQcm92aWRlcihwcm92aWRlcikpe2xvZ2dlciRwLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJvdmlkZXJcIixcInByb3ZpZGVyXCIscHJvdmlkZXIpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHByb3ZpZGVyfHxudWxsKX1nZXQgbW5lbW9uaWMoKXtyZXR1cm4gdGhpcy5fbW5lbW9uaWMoKX1nZXQgcHJpdmF0ZUtleSgpe3JldHVybiB0aGlzLl9zaWduaW5nS2V5KCkucHJpdmF0ZUtleX1nZXQgcHVibGljS2V5KCl7cmV0dXJuIHRoaXMuX3NpZ25pbmdLZXkoKS5wdWJsaWNLZXl9Z2V0QWRkcmVzcygpe3JldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKX1jb25uZWN0KHByb3ZpZGVyKXtyZXR1cm4gbmV3IFdhbGxldCh0aGlzLHByb3ZpZGVyKX1zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pe3JldHVybiByZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbikudGhlbih0eD0+e2lmKHR4LmZyb20hPW51bGwpe2lmKGdldEFkZHJlc3ModHguZnJvbSkhPT10aGlzLmFkZHJlc3Mpe2xvZ2dlciRwLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uIGZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLFwidHJhbnNhY3Rpb24uZnJvbVwiLHRyYW5zYWN0aW9uLmZyb20pfWRlbGV0ZSB0eC5mcm9tfWNvbnN0IHNpZ25hdHVyZT10aGlzLl9zaWduaW5nS2V5KCkuc2lnbkRpZ2VzdChrZWNjYWsyNTYoc2VyaWFsaXplKHR4KSkpO3JldHVybiBzZXJpYWxpemUodHgsc2lnbmF0dXJlKX0pfXNpZ25NZXNzYWdlKG1lc3NhZ2Upe3JldHVybiBfX2F3YWl0ZXIkNSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7cmV0dXJuIGpvaW5TaWduYXR1cmUodGhpcy5fc2lnbmluZ0tleSgpLnNpZ25EaWdlc3QoaGFzaE1lc3NhZ2UobWVzc2FnZSkpKX0pfV9zaWduVHlwZWREYXRhKGRvbWFpbix0eXBlcyx2YWx1ZSl7cmV0dXJuIF9fYXdhaXRlciQ1KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBwb3B1bGF0ZWQ9eWllbGQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLHR5cGVzLHZhbHVlLG5hbWU9PntpZih0aGlzLnByb3ZpZGVyPT1udWxsKXtsb2dnZXIkcC50aHJvd0Vycm9yKFwiY2Fubm90IHJlc29sdmUgRU5TIG5hbWVzIHdpdGhvdXQgYSBwcm92aWRlclwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJyZXNvbHZlTmFtZVwiLHZhbHVlOm5hbWV9KX1yZXR1cm4gdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKX0pO3JldHVybiBqb2luU2lnbmF0dXJlKHRoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KFR5cGVkRGF0YUVuY29kZXIuaGFzaChwb3B1bGF0ZWQuZG9tYWluLHR5cGVzLHBvcHVsYXRlZC52YWx1ZSkpKX0pfWVuY3J5cHQocGFzc3dvcmQsb3B0aW9ucyxwcm9ncmVzc0NhbGxiYWNrKXtpZih0eXBlb2Ygb3B0aW9ucz09PVwiZnVuY3Rpb25cIiYmIXByb2dyZXNzQ2FsbGJhY2spe3Byb2dyZXNzQ2FsbGJhY2s9b3B0aW9ucztvcHRpb25zPXt9fWlmKHByb2dyZXNzQ2FsbGJhY2smJnR5cGVvZiBwcm9ncmVzc0NhbGxiYWNrIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpfWlmKCFvcHRpb25zKXtvcHRpb25zPXt9fXJldHVybiBlbmNyeXB0KHRoaXMscGFzc3dvcmQsb3B0aW9ucyxwcm9ncmVzc0NhbGxiYWNrKX1zdGF0aWMgY3JlYXRlUmFuZG9tKG9wdGlvbnMpe2xldCBlbnRyb3B5PXJhbmRvbUJ5dGVzKDE2KTtpZighb3B0aW9ucyl7b3B0aW9ucz17fX1pZihvcHRpb25zLmV4dHJhRW50cm9weSl7ZW50cm9weT1hcnJheWlmeShoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGNvbmNhdChbZW50cm9weSxvcHRpb25zLmV4dHJhRW50cm9weV0pKSwwLDE2KSl9Y29uc3QgbW5lbW9uaWM9ZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSxvcHRpb25zLmxvY2FsZSk7cmV0dXJuIFdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsb3B0aW9ucy5wYXRoLG9wdGlvbnMubG9jYWxlKX1zdGF0aWMgZnJvbUVuY3J5cHRlZEpzb24oanNvbixwYXNzd29yZCxwcm9ncmVzc0NhbGxiYWNrKXtyZXR1cm4gZGVjcnlwdEpzb25XYWxsZXQoanNvbixwYXNzd29yZCxwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGFjY291bnQ9PntyZXR1cm4gbmV3IFdhbGxldChhY2NvdW50KX0pfXN0YXRpYyBmcm9tRW5jcnlwdGVkSnNvblN5bmMoanNvbixwYXNzd29yZCl7cmV0dXJuIG5ldyBXYWxsZXQoZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24scGFzc3dvcmQpKX1zdGF0aWMgZnJvbU1uZW1vbmljKG1uZW1vbmljLHBhdGgsd29yZGxpc3Qpe2lmKCFwYXRoKXtwYXRoPWRlZmF1bHRQYXRofXJldHVybiBuZXcgV2FsbGV0KEhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMsbnVsbCx3b3JkbGlzdCkuZGVyaXZlUGF0aChwYXRoKSl9fWZ1bmN0aW9uIHZlcmlmeU1lc3NhZ2UobWVzc2FnZSxzaWduYXR1cmUpe3JldHVybiByZWNvdmVyQWRkcmVzcyhoYXNoTWVzc2FnZShtZXNzYWdlKSxzaWduYXR1cmUpfWZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShkb21haW4sdHlwZXMsdmFsdWUsc2lnbmF0dXJlKXtyZXR1cm4gcmVjb3ZlckFkZHJlc3MoVHlwZWREYXRhRW5jb2Rlci5oYXNoKGRvbWFpbix0eXBlcyx2YWx1ZSksc2lnbmF0dXJlKX1jb25zdCB2ZXJzaW9uJGs9XCJuZXR3b3Jrcy81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRxPW5ldyBMb2dnZXIodmVyc2lvbiRrKTtmdW5jdGlvbiBpc1JlbmV0d29ya2FibGUodmFsdWUpe3JldHVybiB2YWx1ZSYmdHlwZW9mIHZhbHVlLnJlbmV0d29yaz09PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yayl7Y29uc3QgZnVuYz1mdW5jdGlvbihwcm92aWRlcnMsb3B0aW9ucyl7aWYob3B0aW9ucz09bnVsbCl7b3B0aW9ucz17fX1jb25zdCBwcm92aWRlckxpc3Q9W107aWYocHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyKXt0cnl7cHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcihuZXR3b3JrLG9wdGlvbnMuaW5mdXJhKSl9Y2F0Y2goZXJyb3Ipe319aWYocHJvdmlkZXJzLkV0aGVyc2NhblByb3ZpZGVyKXt0cnl7cHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLG9wdGlvbnMuZXRoZXJzY2FuKSl9Y2F0Y2goZXJyb3Ipe319aWYocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcil7Y29uc3Qgc2tpcD1bXCJnb2VybGlcIixcInJvcHN0ZW5cIixcInJpbmtlYnlcIl07dHJ5e2NvbnN0IHByb3ZpZGVyPW5ldyBwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssb3B0aW9ucy5hbGNoZW15KTtpZihwcm92aWRlci5uZXR3b3JrJiZza2lwLmluZGV4T2YocHJvdmlkZXIubmV0d29yay5uYW1lKT09PS0xKXtwcm92aWRlckxpc3QucHVzaChwcm92aWRlcil9fWNhdGNoKGVycm9yKXt9fWlmKHByb3ZpZGVycy5Qb2NrZXRQcm92aWRlcil7Y29uc3Qgc2tpcD1bXCJnb2VybGlcIixcInJvcHN0ZW5cIixcInJpbmtlYnlcIl07dHJ5e2NvbnN0IHByb3ZpZGVyPW5ldyBwcm92aWRlcnMuUG9ja2V0UHJvdmlkZXIobmV0d29yayk7aWYocHJvdmlkZXIubmV0d29yayYmc2tpcC5pbmRleE9mKHByb3ZpZGVyLm5ldHdvcmsubmFtZSk9PT0tMSl7cHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpfX1jYXRjaChlcnJvcil7fX1pZihwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyKXt0cnl7cHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIobmV0d29yaykpfWNhdGNoKGVycm9yKXt9fWlmKHByb3ZpZGVyTGlzdC5sZW5ndGg9PT0wKXtyZXR1cm4gbnVsbH1pZihwcm92aWRlcnMuRmFsbGJhY2tQcm92aWRlcil7bGV0IHF1b3J1bT0xO2lmKG9wdGlvbnMucXVvcnVtIT1udWxsKXtxdW9ydW09b3B0aW9ucy5xdW9ydW19ZWxzZSBpZihuZXR3b3JrPT09XCJob21lc3RlYWRcIil7cXVvcnVtPTJ9cmV0dXJuIG5ldyBwcm92aWRlcnMuRmFsbGJhY2tQcm92aWRlcihwcm92aWRlckxpc3QscXVvcnVtKX1yZXR1cm4gcHJvdmlkZXJMaXN0WzBdfTtmdW5jLnJlbmV0d29yaz1mdW5jdGlvbihuZXR3b3JrKXtyZXR1cm4gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspfTtyZXR1cm4gZnVuY31mdW5jdGlvbiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLG5ldHdvcmspe2NvbnN0IGZ1bmM9ZnVuY3Rpb24ocHJvdmlkZXJzLG9wdGlvbnMpe2lmKHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIpe3JldHVybiBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcih1cmwsbmV0d29yayl9cmV0dXJuIG51bGx9O2Z1bmMucmVuZXR3b3JrPWZ1bmN0aW9uKG5ldHdvcmspe3JldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLG5ldHdvcmspfTtyZXR1cm4gZnVuY31jb25zdCBob21lc3RlYWQ9e2NoYWluSWQ6MSxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcImhvbWVzdGVhZFwiLF9kZWZhdWx0UHJvdmlkZXI6ZXRoRGVmYXVsdFByb3ZpZGVyKFwiaG9tZXN0ZWFkXCIpfTtjb25zdCByb3BzdGVuPXtjaGFpbklkOjMsZW5zQWRkcmVzczpcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLG5hbWU6XCJyb3BzdGVuXCIsX2RlZmF1bHRQcm92aWRlcjpldGhEZWZhdWx0UHJvdmlkZXIoXCJyb3BzdGVuXCIpfTtjb25zdCBjbGFzc2ljTW9yZG9yPXtjaGFpbklkOjYzLG5hbWU6XCJjbGFzc2ljTW9yZG9yXCIsX2RlZmF1bHRQcm92aWRlcjpldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovL3d3dy5ldGhlcmNsdXN0ZXIuY29tL21vcmRvclwiLFwiY2xhc3NpY01vcmRvclwiKX07Y29uc3QgbmV0d29ya3M9e3Vuc3BlY2lmaWVkOntjaGFpbklkOjAsbmFtZTpcInVuc3BlY2lmaWVkXCJ9LGhvbWVzdGVhZDpob21lc3RlYWQsbWFpbm5ldDpob21lc3RlYWQsbW9yZGVuOntjaGFpbklkOjIsbmFtZTpcIm1vcmRlblwifSxyb3BzdGVuOnJvcHN0ZW4sdGVzdG5ldDpyb3BzdGVuLHJpbmtlYnk6e2NoYWluSWQ6NCxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcInJpbmtlYnlcIixfZGVmYXVsdFByb3ZpZGVyOmV0aERlZmF1bHRQcm92aWRlcihcInJpbmtlYnlcIil9LGtvdmFuOntjaGFpbklkOjQyLG5hbWU6XCJrb3ZhblwiLF9kZWZhdWx0UHJvdmlkZXI6ZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIil9LGdvZXJsaTp7Y2hhaW5JZDo1LGVuc0FkZHJlc3M6XCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixuYW1lOlwiZ29lcmxpXCIsX2RlZmF1bHRQcm92aWRlcjpldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIil9LGNsYXNzaWM6e2NoYWluSWQ6NjEsbmFtZTpcImNsYXNzaWNcIixfZGVmYXVsdFByb3ZpZGVyOmV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vZXRjXCIsXCJjbGFzc2ljXCIpfSxjbGFzc2ljTW9yZGVuOntjaGFpbklkOjYyLG5hbWU6XCJjbGFzc2ljTW9yZGVuXCJ9LGNsYXNzaWNNb3Jkb3I6Y2xhc3NpY01vcmRvcixjbGFzc2ljVGVzdG5ldDpjbGFzc2ljTW9yZG9yLGNsYXNzaWNLb3R0aTp7Y2hhaW5JZDo2LG5hbWU6XCJjbGFzc2ljS290dGlcIixfZGVmYXVsdFByb3ZpZGVyOmV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20va290dGlcIixcImNsYXNzaWNLb3R0aVwiKX19O2Z1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yayl7aWYobmV0d29yaz09bnVsbCl7cmV0dXJuIG51bGx9aWYodHlwZW9mIG5ldHdvcms9PT1cIm51bWJlclwiKXtmb3IoY29uc3QgbmFtZSBpbiBuZXR3b3Jrcyl7Y29uc3Qgc3RhbmRhcmQ9bmV0d29ya3NbbmFtZV07aWYoc3RhbmRhcmQuY2hhaW5JZD09PW5ldHdvcmspe3JldHVybntuYW1lOnN0YW5kYXJkLm5hbWUsY2hhaW5JZDpzdGFuZGFyZC5jaGFpbklkLGVuc0FkZHJlc3M6c3RhbmRhcmQuZW5zQWRkcmVzc3x8bnVsbCxfZGVmYXVsdFByb3ZpZGVyOnN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXJ8fG51bGx9fX1yZXR1cm57Y2hhaW5JZDpuZXR3b3JrLG5hbWU6XCJ1bmtub3duXCJ9fWlmKHR5cGVvZiBuZXR3b3JrPT09XCJzdHJpbmdcIil7Y29uc3Qgc3RhbmRhcmQ9bmV0d29ya3NbbmV0d29ya107aWYoc3RhbmRhcmQ9PW51bGwpe3JldHVybiBudWxsfXJldHVybntuYW1lOnN0YW5kYXJkLm5hbWUsY2hhaW5JZDpzdGFuZGFyZC5jaGFpbklkLGVuc0FkZHJlc3M6c3RhbmRhcmQuZW5zQWRkcmVzcyxfZGVmYXVsdFByb3ZpZGVyOnN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXJ8fG51bGx9fWNvbnN0IHN0YW5kYXJkPW5ldHdvcmtzW25ldHdvcmsubmFtZV07aWYoIXN0YW5kYXJkKXtpZih0eXBlb2YgbmV0d29yay5jaGFpbklkIT09XCJudW1iZXJcIil7bG9nZ2VyJHEudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrIGNoYWluSWRcIixcIm5ldHdvcmtcIixuZXR3b3JrKX1yZXR1cm4gbmV0d29ya31pZihuZXR3b3JrLmNoYWluSWQhPT0wJiZuZXR3b3JrLmNoYWluSWQhPT1zdGFuZGFyZC5jaGFpbklkKXtsb2dnZXIkcS50aHJvd0FyZ3VtZW50RXJyb3IoXCJuZXR3b3JrIGNoYWluSWQgbWlzbWF0Y2hcIixcIm5ldHdvcmtcIixuZXR3b3JrKX1sZXQgZGVmYXVsdFByb3ZpZGVyPW5ldHdvcmsuX2RlZmF1bHRQcm92aWRlcnx8bnVsbDtpZihkZWZhdWx0UHJvdmlkZXI9PW51bGwmJnN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpe2lmKGlzUmVuZXR3b3JrYWJsZShzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSl7ZGVmYXVsdFByb3ZpZGVyPXN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIucmVuZXR3b3JrKG5ldHdvcmspfWVsc2V7ZGVmYXVsdFByb3ZpZGVyPXN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXJ9fXJldHVybntuYW1lOm5ldHdvcmsubmFtZSxjaGFpbklkOnN0YW5kYXJkLmNoYWluSWQsZW5zQWRkcmVzczpuZXR3b3JrLmVuc0FkZHJlc3N8fHN0YW5kYXJkLmVuc0FkZHJlc3N8fG51bGwsX2RlZmF1bHRQcm92aWRlcjpkZWZhdWx0UHJvdmlkZXJ9fVwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGRlY29kZSQxKHRleHREYXRhKXt0ZXh0RGF0YT1hdG9iKHRleHREYXRhKTtjb25zdCBkYXRhPVtdO2ZvcihsZXQgaT0wO2k8dGV4dERhdGEubGVuZ3RoO2krKyl7ZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpfXJldHVybiBhcnJheWlmeShkYXRhKX1mdW5jdGlvbiBlbmNvZGUkMShkYXRhKXtkYXRhPWFycmF5aWZ5KGRhdGEpO2xldCB0ZXh0RGF0YT1cIlwiO2ZvcihsZXQgaT0wO2k8ZGF0YS5sZW5ndGg7aSsrKXt0ZXh0RGF0YSs9U3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKX1yZXR1cm4gYnRvYSh0ZXh0RGF0YSl9XCJ1c2Ugc3RyaWN0XCI7dmFyIGluZGV4JDI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVjb2RlOmRlY29kZSQxLGVuY29kZTplbmNvZGUkMX0pO2NvbnN0IHZlcnNpb24kbD1cIndlYi81LjEuMFwiO1widXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkNj13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07ZnVuY3Rpb24gZ2V0VXJsKGhyZWYsb3B0aW9ucyl7cmV0dXJuIF9fYXdhaXRlciQ2KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZihvcHRpb25zPT1udWxsKXtvcHRpb25zPXt9fWNvbnN0IHJlcXVlc3Q9e21ldGhvZDpvcHRpb25zLm1ldGhvZHx8XCJHRVRcIixoZWFkZXJzOm9wdGlvbnMuaGVhZGVyc3x8e30sYm9keTpvcHRpb25zLmJvZHl8fHVuZGVmaW5lZCxtb2RlOlwiY29yc1wiLGNhY2hlOlwibm8tY2FjaGVcIixjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCIscmVkaXJlY3Q6XCJmb2xsb3dcIixyZWZlcnJlcjpcImNsaWVudFwifTtjb25zdCByZXNwb25zZT15aWVsZCBmZXRjaChocmVmLHJlcXVlc3QpO2NvbnN0IGJvZHk9eWllbGQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtjb25zdCBoZWFkZXJzPXt9O2lmKHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCl7cmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSxrZXkpPT57aGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV09dmFsdWV9KX1lbHNle3Jlc3BvbnNlLmhlYWRlcnMua2V5cygpLmZvckVhY2goa2V5PT57aGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV09cmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KX0pfXJldHVybntoZWFkZXJzOmhlYWRlcnMsc3RhdHVzQ29kZTpyZXNwb25zZS5zdGF0dXMsc3RhdHVzTWVzc2FnZTpyZXNwb25zZS5zdGF0dXNUZXh0LGJvZHk6YXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoYm9keSkpfX0pfVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkNz13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJHI9bmV3IExvZ2dlcih2ZXJzaW9uJGwpO2Z1bmN0aW9uIHN0YWxsZXIoZHVyYXRpb24pe3JldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlPT57c2V0VGltZW91dChyZXNvbHZlLGR1cmF0aW9uKX0pfWZ1bmN0aW9uIGJvZHlpZnkodmFsdWUsdHlwZSl7aWYodmFsdWU9PW51bGwpe3JldHVybiBudWxsfWlmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe3JldHVybiB2YWx1ZX1pZihpc0J5dGVzTGlrZSh2YWx1ZSkpe2lmKHR5cGUmJih0eXBlLnNwbGl0KFwiL1wiKVswXT09PVwidGV4dFwifHx0eXBlLnNwbGl0KFwiO1wiKVswXS50cmltKCk9PT1cImFwcGxpY2F0aW9uL2pzb25cIikpe3RyeXtyZXR1cm4gdG9VdGY4U3RyaW5nKHZhbHVlKX1jYXRjaChlcnJvcil7fX1yZXR1cm4gaGV4bGlmeSh2YWx1ZSl9cmV0dXJuIHZhbHVlfWZ1bmN0aW9uIF9mZXRjaERhdGEoY29ubmVjdGlvbixib2R5LHByb2Nlc3NGdW5jKXtjb25zdCBhdHRlbXB0TGltaXQ9dHlwZW9mIGNvbm5lY3Rpb249PT1cIm9iamVjdFwiJiZjb25uZWN0aW9uLnRocm90dGxlTGltaXQhPW51bGw/Y29ubmVjdGlvbi50aHJvdHRsZUxpbWl0OjEyO2xvZ2dlciRyLmFzc2VydEFyZ3VtZW50KGF0dGVtcHRMaW1pdD4wJiZhdHRlbXB0TGltaXQlMT09PTAsXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgbGltaXRcIixcImNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdFwiLGF0dGVtcHRMaW1pdCk7Y29uc3QgdGhyb3R0bGVDYWxsYmFjaz10eXBlb2YgY29ubmVjdGlvbj09PVwib2JqZWN0XCI/Y29ubmVjdGlvbi50aHJvdHRsZUNhbGxiYWNrOm51bGw7Y29uc3QgdGhyb3R0bGVTbG90SW50ZXJ2YWw9dHlwZW9mIGNvbm5lY3Rpb249PT1cIm9iamVjdFwiJiZ0eXBlb2YgY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbD09PVwibnVtYmVyXCI/Y29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbDoxMDA7bG9nZ2VyJHIuYXNzZXJ0QXJndW1lbnQodGhyb3R0bGVTbG90SW50ZXJ2YWw+MCYmdGhyb3R0bGVTbG90SW50ZXJ2YWwlMT09PTAsXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgc2xvdCBpbnRlcnZhbFwiLFwiY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbFwiLHRocm90dGxlU2xvdEludGVydmFsKTtjb25zdCBoZWFkZXJzPXt9O2xldCB1cmw9bnVsbDtjb25zdCBvcHRpb25zPXttZXRob2Q6XCJHRVRcIn07bGV0IGFsbG93MzA0PWZhbHNlO2xldCB0aW1lb3V0PTIqNjAqMWUzO2lmKHR5cGVvZiBjb25uZWN0aW9uPT09XCJzdHJpbmdcIil7dXJsPWNvbm5lY3Rpb259ZWxzZSBpZih0eXBlb2YgY29ubmVjdGlvbj09PVwib2JqZWN0XCIpe2lmKGNvbm5lY3Rpb249PW51bGx8fGNvbm5lY3Rpb24udXJsPT1udWxsKXtsb2dnZXIkci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIFVSTFwiLFwiY29ubmVjdGlvbi51cmxcIixjb25uZWN0aW9uKX11cmw9Y29ubmVjdGlvbi51cmw7aWYodHlwZW9mIGNvbm5lY3Rpb24udGltZW91dD09PVwibnVtYmVyXCImJmNvbm5lY3Rpb24udGltZW91dD4wKXt0aW1lb3V0PWNvbm5lY3Rpb24udGltZW91dH1pZihjb25uZWN0aW9uLmhlYWRlcnMpe2Zvcihjb25zdCBrZXkgaW4gY29ubmVjdGlvbi5oZWFkZXJzKXtoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXT17a2V5OmtleSx2YWx1ZTpTdHJpbmcoY29ubmVjdGlvbi5oZWFkZXJzW2tleV0pfTtpZihbXCJpZi1ub25lLW1hdGNoXCIsXCJpZi1tb2RpZmllZC1zaW5jZVwiXS5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKT49MCl7YWxsb3czMDQ9dHJ1ZX19fW9wdGlvbnMuYWxsb3dHemlwPSEhY29ubmVjdGlvbi5hbGxvd0d6aXA7aWYoY29ubmVjdGlvbi51c2VyIT1udWxsJiZjb25uZWN0aW9uLnBhc3N3b3JkIT1udWxsKXtpZih1cmwuc3Vic3RyaW5nKDAsNikhPT1cImh0dHBzOlwiJiZjb25uZWN0aW9uLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiE9PXRydWUpe2xvZ2dlciRyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIixMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwidXJsXCIsdXJsOnVybCx1c2VyOmNvbm5lY3Rpb24udXNlcixwYXNzd29yZDpcIltSRURBQ1RFRF1cIn0pfWNvbnN0IGF1dGhvcml6YXRpb249Y29ubmVjdGlvbi51c2VyK1wiOlwiK2Nvbm5lY3Rpb24ucGFzc3dvcmQ7aGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl09e2tleTpcIkF1dGhvcml6YXRpb25cIix2YWx1ZTpcIkJhc2ljIFwiK2VuY29kZSQxKHRvVXRmOEJ5dGVzKGF1dGhvcml6YXRpb24pKX19fWlmKGJvZHkpe29wdGlvbnMubWV0aG9kPVwiUE9TVFwiO29wdGlvbnMuYm9keT1ib2R5O2lmKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl09PW51bGwpe2hlYWRlcnNbXCJjb250ZW50LXR5cGVcIl09e2tleTpcIkNvbnRlbnQtVHlwZVwiLHZhbHVlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9fWlmKGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXT09bnVsbCl7aGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdPXtrZXk6XCJDb250ZW50LUxlbmd0aFwiLHZhbHVlOlN0cmluZyhib2R5Lmxlbmd0aCl9fX1jb25zdCBmbGF0SGVhZGVycz17fTtPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGtleT0+e2NvbnN0IGhlYWRlcj1oZWFkZXJzW2tleV07ZmxhdEhlYWRlcnNbaGVhZGVyLmtleV09aGVhZGVyLnZhbHVlfSk7b3B0aW9ucy5oZWFkZXJzPWZsYXRIZWFkZXJzO2NvbnN0IHJ1bm5pbmdUaW1lb3V0PWZ1bmN0aW9uKCl7bGV0IHRpbWVyPW51bGw7Y29uc3QgcHJvbWlzZT1uZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7aWYodGltZW91dCl7dGltZXI9c2V0VGltZW91dCgoKT0+e2lmKHRpbWVyPT1udWxsKXtyZXR1cm59dGltZXI9bnVsbDtyZWplY3QobG9nZ2VyJHIubWFrZUVycm9yKFwidGltZW91dFwiLExvZ2dlci5lcnJvcnMuVElNRU9VVCx7cmVxdWVzdEJvZHk6Ym9keWlmeShvcHRpb25zLmJvZHksZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLHJlcXVlc3RNZXRob2Q6b3B0aW9ucy5tZXRob2QsdGltZW91dDp0aW1lb3V0LHVybDp1cmx9KSl9LHRpbWVvdXQpfX0pO2NvbnN0IGNhbmNlbD1mdW5jdGlvbigpe2lmKHRpbWVyPT1udWxsKXtyZXR1cm59Y2xlYXJUaW1lb3V0KHRpbWVyKTt0aW1lcj1udWxsfTtyZXR1cm57cHJvbWlzZTpwcm9taXNlLGNhbmNlbDpjYW5jZWx9fSgpO2NvbnN0IHJ1bm5pbmdGZXRjaD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIkNyh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Zm9yKGxldCBhdHRlbXB0PTA7YXR0ZW1wdDxhdHRlbXB0TGltaXQ7YXR0ZW1wdCsrKXtsZXQgcmVzcG9uc2U9bnVsbDt0cnl7cmVzcG9uc2U9eWllbGQgZ2V0VXJsKHVybCxvcHRpb25zKTtpZihyZXNwb25zZS5zdGF0dXNDb2RlPT09NDI5JiZhdHRlbXB0PGF0dGVtcHRMaW1pdCl7bGV0IHRyeUFnYWluPXRydWU7aWYodGhyb3R0bGVDYWxsYmFjayl7dHJ5QWdhaW49eWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LHVybCl9aWYodHJ5QWdhaW4pe2xldCBzdGFsbD0wO2NvbnN0IHJldHJ5QWZ0ZXI9cmVzcG9uc2UuaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO2lmKHR5cGVvZiByZXRyeUFmdGVyPT09XCJzdHJpbmdcIiYmcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKXtzdGFsbD1wYXJzZUludChyZXRyeUFmdGVyKSoxZTN9ZWxzZXtzdGFsbD10aHJvdHRsZVNsb3RJbnRlcnZhbCpwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSpNYXRoLnBvdygyLGF0dGVtcHQpKSl9eWllbGQgc3RhbGxlcihzdGFsbCk7Y29udGludWV9fX1jYXRjaChlcnJvcil7cmVzcG9uc2U9ZXJyb3IucmVzcG9uc2U7aWYocmVzcG9uc2U9PW51bGwpe3J1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO2xvZ2dlciRyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise3JlcXVlc3RCb2R5OmJvZHlpZnkob3B0aW9ucy5ib2R5LGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxyZXF1ZXN0TWV0aG9kOm9wdGlvbnMubWV0aG9kLHNlcnZlckVycm9yOmVycm9yLHVybDp1cmx9KX19bGV0IGJvZHk9cmVzcG9uc2UuYm9keTtpZihhbGxvdzMwNCYmcmVzcG9uc2Uuc3RhdHVzQ29kZT09PTMwNCl7Ym9keT1udWxsfWVsc2UgaWYocmVzcG9uc2Uuc3RhdHVzQ29kZTwyMDB8fHJlc3BvbnNlLnN0YXR1c0NvZGU+PTMwMCl7cnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7bG9nZ2VyJHIudGhyb3dFcnJvcihcImJhZCByZXNwb25zZVwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHtzdGF0dXM6cmVzcG9uc2Uuc3RhdHVzQ29kZSxoZWFkZXJzOnJlc3BvbnNlLmhlYWRlcnMsYm9keTpib2R5aWZ5KGJvZHkscmVzcG9uc2UuaGVhZGVycz9yZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdOm51bGwpLHJlcXVlc3RCb2R5OmJvZHlpZnkob3B0aW9ucy5ib2R5LGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxyZXF1ZXN0TWV0aG9kOm9wdGlvbnMubWV0aG9kLHVybDp1cmx9KX1pZihwcm9jZXNzRnVuYyl7dHJ5e2NvbnN0IHJlc3VsdD15aWVsZCBwcm9jZXNzRnVuYyhib2R5LHJlc3BvbnNlKTtydW5uaW5nVGltZW91dC5jYW5jZWwoKTtyZXR1cm4gcmVzdWx0fWNhdGNoKGVycm9yKXtpZihlcnJvci50aHJvdHRsZVJldHJ5JiZhdHRlbXB0PGF0dGVtcHRMaW1pdCl7bGV0IHRyeUFnYWluPXRydWU7aWYodGhyb3R0bGVDYWxsYmFjayl7dHJ5QWdhaW49eWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LHVybCl9aWYodHJ5QWdhaW4pe2NvbnN0IHRpbWVvdXQ9dGhyb3R0bGVTbG90SW50ZXJ2YWwqcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMixhdHRlbXB0KSkpO3lpZWxkIHN0YWxsZXIodGltZW91dCk7Y29udGludWV9fXJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO2xvZ2dlciRyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise2JvZHk6Ym9keWlmeShib2R5LHJlc3BvbnNlLmhlYWRlcnM/cmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTpudWxsKSxlcnJvcjplcnJvcixyZXF1ZXN0Qm9keTpib2R5aWZ5KG9wdGlvbnMuYm9keSxmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSkscmVxdWVzdE1ldGhvZDpvcHRpb25zLm1ldGhvZCx1cmw6dXJsfSl9fXJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO3JldHVybiBib2R5fXJldHVybiBsb2dnZXIkci50aHJvd0Vycm9yKFwiZmFpbGVkIHJlc3BvbnNlXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise3JlcXVlc3RCb2R5OmJvZHlpZnkob3B0aW9ucy5ib2R5LGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxyZXF1ZXN0TWV0aG9kOm9wdGlvbnMubWV0aG9kLHVybDp1cmx9KX0pfSgpO3JldHVybiBQcm9taXNlLnJhY2UoW3J1bm5pbmdUaW1lb3V0LnByb21pc2UscnVubmluZ0ZldGNoXSl9ZnVuY3Rpb24gZmV0Y2hKc29uKGNvbm5lY3Rpb24sanNvbixwcm9jZXNzRnVuYyl7bGV0IHByb2Nlc3NKc29uRnVuYz0odmFsdWUscmVzcG9uc2UpPT57bGV0IHJlc3VsdD1udWxsO2lmKHZhbHVlIT1udWxsKXt0cnl7cmVzdWx0PUpTT04ucGFyc2UodG9VdGY4U3RyaW5nKHZhbHVlKSl9Y2F0Y2goZXJyb3Ipe2xvZ2dlciRyLnRocm93RXJyb3IoXCJpbnZhbGlkIEpTT05cIixMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUix7Ym9keTp2YWx1ZSxlcnJvcjplcnJvcn0pfX1pZihwcm9jZXNzRnVuYyl7cmVzdWx0PXByb2Nlc3NGdW5jKHJlc3VsdCxyZXNwb25zZSl9cmV0dXJuIHJlc3VsdH07bGV0IGJvZHk9bnVsbDtpZihqc29uIT1udWxsKXtib2R5PXRvVXRmOEJ5dGVzKGpzb24pO2NvbnN0IHVwZGF0ZWQ9dHlwZW9mIGNvbm5lY3Rpb249PT1cInN0cmluZ1wiP3t1cmw6Y29ubmVjdGlvbn06c2hhbGxvd0NvcHkoY29ubmVjdGlvbik7aWYodXBkYXRlZC5oZWFkZXJzKXtjb25zdCBoYXNDb250ZW50VHlwZT1PYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcihrPT5rLnRvTG93ZXJDYXNlKCk9PT1cImNvbnRlbnQtdHlwZVwiKS5sZW5ndGghPT0wO2lmKCFoYXNDb250ZW50VHlwZSl7dXBkYXRlZC5oZWFkZXJzPXNoYWxsb3dDb3B5KHVwZGF0ZWQuaGVhZGVycyk7dXBkYXRlZC5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdPVwiYXBwbGljYXRpb24vanNvblwifX1lbHNle3VwZGF0ZWQuaGVhZGVycz17XCJjb250ZW50LXR5cGVcIjpcImFwcGxpY2F0aW9uL2pzb25cIn19Y29ubmVjdGlvbj11cGRhdGVkfXJldHVybiBfZmV0Y2hEYXRhKGNvbm5lY3Rpb24sYm9keSxwcm9jZXNzSnNvbkZ1bmMpfWZ1bmN0aW9uIHBvbGwoZnVuYyxvcHRpb25zKXtpZighb3B0aW9ucyl7b3B0aW9ucz17fX1vcHRpb25zPXNoYWxsb3dDb3B5KG9wdGlvbnMpO2lmKG9wdGlvbnMuZmxvb3I9PW51bGwpe29wdGlvbnMuZmxvb3I9MH1pZihvcHRpb25zLmNlaWxpbmc9PW51bGwpe29wdGlvbnMuY2VpbGluZz0xZTR9aWYob3B0aW9ucy5pbnRlcnZhbD09bnVsbCl7b3B0aW9ucy5pbnRlcnZhbD0yNTB9cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtsZXQgdGltZXI9bnVsbDtsZXQgZG9uZT1mYWxzZTtjb25zdCBjYW5jZWw9KCk9PntpZihkb25lKXtyZXR1cm4gZmFsc2V9ZG9uZT10cnVlO2lmKHRpbWVyKXtjbGVhclRpbWVvdXQodGltZXIpfXJldHVybiB0cnVlfTtpZihvcHRpb25zLnRpbWVvdXQpe3RpbWVyPXNldFRpbWVvdXQoKCk9PntpZihjYW5jZWwoKSl7cmVqZWN0KG5ldyBFcnJvcihcInRpbWVvdXRcIikpfX0sb3B0aW9ucy50aW1lb3V0KX1jb25zdCByZXRyeUxpbWl0PW9wdGlvbnMucmV0cnlMaW1pdDtsZXQgYXR0ZW1wdD0wO2Z1bmN0aW9uIGNoZWNrKCl7cmV0dXJuIGZ1bmMoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7aWYocmVzdWx0IT09dW5kZWZpbmVkKXtpZihjYW5jZWwoKSl7cmVzb2x2ZShyZXN1bHQpfX1lbHNlIGlmKG9wdGlvbnMub25jZVBvbGwpe29wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIixjaGVjayl9ZWxzZSBpZihvcHRpb25zLm9uY2VCbG9jayl7b3B0aW9ucy5vbmNlQmxvY2sub25jZShcImJsb2NrXCIsY2hlY2spfWVsc2UgaWYoIWRvbmUpe2F0dGVtcHQrKztpZihhdHRlbXB0PnJldHJ5TGltaXQpe2lmKGNhbmNlbCgpKXtyZWplY3QobmV3IEVycm9yKFwicmV0cnkgbGltaXQgcmVhY2hlZFwiKSl9cmV0dXJufWxldCB0aW1lb3V0PW9wdGlvbnMuaW50ZXJ2YWwqcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMixhdHRlbXB0KSkpO2lmKHRpbWVvdXQ8b3B0aW9ucy5mbG9vcil7dGltZW91dD1vcHRpb25zLmZsb29yfWlmKHRpbWVvdXQ+b3B0aW9ucy5jZWlsaW5nKXt0aW1lb3V0PW9wdGlvbnMuY2VpbGluZ31zZXRUaW1lb3V0KGNoZWNrLHRpbWVvdXQpfXJldHVybiBudWxsfSxmdW5jdGlvbihlcnJvcil7aWYoY2FuY2VsKCkpe3JlamVjdChlcnJvcil9fSl9Y2hlY2soKX0pfVwidXNlIHN0cmljdFwiO3ZhciBBTFBIQUJFVD1cInFwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsXCI7dmFyIEFMUEhBQkVUX01BUD17fTtmb3IodmFyIHo9MDt6PEFMUEhBQkVULmxlbmd0aDt6Kyspe3ZhciB4PUFMUEhBQkVULmNoYXJBdCh6KTtpZihBTFBIQUJFVF9NQVBbeF0hPT11bmRlZmluZWQpdGhyb3cgbmV3IFR5cGVFcnJvcih4K1wiIGlzIGFtYmlndW91c1wiKTtBTFBIQUJFVF9NQVBbeF09en1mdW5jdGlvbiBwb2x5bW9kU3RlcChwcmUpe3ZhciBiPXByZT4+MjU7cmV0dXJuKHByZSYzMzU1NDQzMSk8PDVeLShiPj4wJjEpJjk5NjgyNTAxMF4tKGI+PjEmMSkmNjQyODEzNTQ5Xi0oYj4+MiYxKSY1MTM4NzQ0MjZeLShiPj4zJjEpJjEwMjc3NDg4MjleLShiPj40JjEpJjcwNTk3OTA1OX1mdW5jdGlvbiBwcmVmaXhDaGsocHJlZml4KXt2YXIgY2hrPTE7Zm9yKHZhciBpPTA7aTxwcmVmaXgubGVuZ3RoOysraSl7dmFyIGM9cHJlZml4LmNoYXJDb2RlQXQoaSk7aWYoYzwzM3x8Yz4xMjYpcmV0dXJuXCJJbnZhbGlkIHByZWZpeCAoXCIrcHJlZml4K1wiKVwiO2Noaz1wb2x5bW9kU3RlcChjaGspXmM+PjV9Y2hrPXBvbHltb2RTdGVwKGNoayk7Zm9yKGk9MDtpPHByZWZpeC5sZW5ndGg7KytpKXt2YXIgdj1wcmVmaXguY2hhckNvZGVBdChpKTtjaGs9cG9seW1vZFN0ZXAoY2hrKV52JjMxfXJldHVybiBjaGt9ZnVuY3Rpb24gZW5jb2RlJDIocHJlZml4LHdvcmRzLExJTUlUKXtMSU1JVD1MSU1JVHx8OTA7aWYocHJlZml4Lmxlbmd0aCs3K3dvcmRzLmxlbmd0aD5MSU1JVCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhjZWVkcyBsZW5ndGggbGltaXRcIik7cHJlZml4PXByZWZpeC50b0xvd2VyQ2FzZSgpO3ZhciBjaGs9cHJlZml4Q2hrKHByZWZpeCk7aWYodHlwZW9mIGNoaz09PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKGNoayk7dmFyIHJlc3VsdD1wcmVmaXgrXCIxXCI7Zm9yKHZhciBpPTA7aTx3b3Jkcy5sZW5ndGg7KytpKXt2YXIgeD13b3Jkc1tpXTtpZih4Pj41IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJOb24gNS1iaXQgd29yZFwiKTtjaGs9cG9seW1vZFN0ZXAoY2hrKV54O3Jlc3VsdCs9QUxQSEFCRVQuY2hhckF0KHgpfWZvcihpPTA7aTw2OysraSl7Y2hrPXBvbHltb2RTdGVwKGNoayl9Y2hrXj0xO2ZvcihpPTA7aTw2OysraSl7dmFyIHY9Y2hrPj4oNS1pKSo1JjMxO3Jlc3VsdCs9QUxQSEFCRVQuY2hhckF0KHYpfXJldHVybiByZXN1bHR9ZnVuY3Rpb24gX19kZWNvZGUoc3RyLExJTUlUKXtMSU1JVD1MSU1JVHx8OTA7aWYoc3RyLmxlbmd0aDw4KXJldHVybiBzdHIrXCIgdG9vIHNob3J0XCI7aWYoc3RyLmxlbmd0aD5MSU1JVClyZXR1cm5cIkV4Y2VlZHMgbGVuZ3RoIGxpbWl0XCI7dmFyIGxvd2VyZWQ9c3RyLnRvTG93ZXJDYXNlKCk7dmFyIHVwcGVyZWQ9c3RyLnRvVXBwZXJDYXNlKCk7aWYoc3RyIT09bG93ZXJlZCYmc3RyIT09dXBwZXJlZClyZXR1cm5cIk1peGVkLWNhc2Ugc3RyaW5nIFwiK3N0cjtzdHI9bG93ZXJlZDt2YXIgc3BsaXQ9c3RyLmxhc3RJbmRleE9mKFwiMVwiKTtpZihzcGxpdD09PS0xKXJldHVyblwiTm8gc2VwYXJhdG9yIGNoYXJhY3RlciBmb3IgXCIrc3RyO2lmKHNwbGl0PT09MClyZXR1cm5cIk1pc3NpbmcgcHJlZml4IGZvciBcIitzdHI7dmFyIHByZWZpeD1zdHIuc2xpY2UoMCxzcGxpdCk7dmFyIHdvcmRDaGFycz1zdHIuc2xpY2Uoc3BsaXQrMSk7aWYod29yZENoYXJzLmxlbmd0aDw2KXJldHVyblwiRGF0YSB0b28gc2hvcnRcIjt2YXIgY2hrPXByZWZpeENoayhwcmVmaXgpO2lmKHR5cGVvZiBjaGs9PT1cInN0cmluZ1wiKXJldHVybiBjaGs7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8d29yZENoYXJzLmxlbmd0aDsrK2kpe3ZhciBjPXdvcmRDaGFycy5jaGFyQXQoaSk7dmFyIHY9QUxQSEFCRVRfTUFQW2NdO2lmKHY9PT11bmRlZmluZWQpcmV0dXJuXCJVbmtub3duIGNoYXJhY3RlciBcIitjO2Noaz1wb2x5bW9kU3RlcChjaGspXnY7aWYoaSs2Pj13b3JkQ2hhcnMubGVuZ3RoKWNvbnRpbnVlO3dvcmRzLnB1c2godil9aWYoY2hrIT09MSlyZXR1cm5cIkludmFsaWQgY2hlY2tzdW0gZm9yIFwiK3N0cjtyZXR1cm57cHJlZml4OnByZWZpeCx3b3Jkczp3b3Jkc319ZnVuY3Rpb24gZGVjb2RlVW5zYWZlKCl7dmFyIHJlcz1fX2RlY29kZS5hcHBseShudWxsLGFyZ3VtZW50cyk7aWYodHlwZW9mIHJlcz09PVwib2JqZWN0XCIpcmV0dXJuIHJlc31mdW5jdGlvbiBkZWNvZGUkMihzdHIpe3ZhciByZXM9X19kZWNvZGUuYXBwbHkobnVsbCxhcmd1bWVudHMpO2lmKHR5cGVvZiByZXM9PT1cIm9iamVjdFwiKXJldHVybiByZXM7dGhyb3cgbmV3IEVycm9yKHJlcyl9ZnVuY3Rpb24gY29udmVydChkYXRhLGluQml0cyxvdXRCaXRzLHBhZCl7dmFyIHZhbHVlPTA7dmFyIGJpdHM9MDt2YXIgbWF4Vj0oMTw8b3V0Qml0cyktMTt2YXIgcmVzdWx0PVtdO2Zvcih2YXIgaT0wO2k8ZGF0YS5sZW5ndGg7KytpKXt2YWx1ZT12YWx1ZTw8aW5CaXRzfGRhdGFbaV07Yml0cys9aW5CaXRzO3doaWxlKGJpdHM+PW91dEJpdHMpe2JpdHMtPW91dEJpdHM7cmVzdWx0LnB1c2godmFsdWU+PmJpdHMmbWF4Vil9fWlmKHBhZCl7aWYoYml0cz4wKXtyZXN1bHQucHVzaCh2YWx1ZTw8b3V0Qml0cy1iaXRzJm1heFYpfX1lbHNle2lmKGJpdHM+PWluQml0cylyZXR1cm5cIkV4Y2VzcyBwYWRkaW5nXCI7aWYodmFsdWU8PG91dEJpdHMtYml0cyZtYXhWKXJldHVyblwiTm9uLXplcm8gcGFkZGluZ1wifXJldHVybiByZXN1bHR9ZnVuY3Rpb24gdG9Xb3Jkc1Vuc2FmZShieXRlcyl7dmFyIHJlcz1jb252ZXJ0KGJ5dGVzLDgsNSx0cnVlKTtpZihBcnJheS5pc0FycmF5KHJlcykpcmV0dXJuIHJlc31mdW5jdGlvbiB0b1dvcmRzKGJ5dGVzKXt2YXIgcmVzPWNvbnZlcnQoYnl0ZXMsOCw1LHRydWUpO2lmKEFycmF5LmlzQXJyYXkocmVzKSlyZXR1cm4gcmVzO3Rocm93IG5ldyBFcnJvcihyZXMpfWZ1bmN0aW9uIGZyb21Xb3Jkc1Vuc2FmZSh3b3Jkcyl7dmFyIHJlcz1jb252ZXJ0KHdvcmRzLDUsOCxmYWxzZSk7aWYoQXJyYXkuaXNBcnJheShyZXMpKXJldHVybiByZXN9ZnVuY3Rpb24gZnJvbVdvcmRzKHdvcmRzKXt2YXIgcmVzPWNvbnZlcnQod29yZHMsNSw4LGZhbHNlKTtpZihBcnJheS5pc0FycmF5KHJlcykpcmV0dXJuIHJlczt0aHJvdyBuZXcgRXJyb3IocmVzKX12YXIgYmVjaDMyPXtkZWNvZGVVbnNhZmU6ZGVjb2RlVW5zYWZlLGRlY29kZTpkZWNvZGUkMixlbmNvZGU6ZW5jb2RlJDIsdG9Xb3Jkc1Vuc2FmZTp0b1dvcmRzVW5zYWZlLHRvV29yZHM6dG9Xb3Jkcyxmcm9tV29yZHNVbnNhZmU6ZnJvbVdvcmRzVW5zYWZlLGZyb21Xb3Jkczpmcm9tV29yZHN9O2NvbnN0IHZlcnNpb24kbT1cInByb3ZpZGVycy81LjEuMlwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRzPW5ldyBMb2dnZXIodmVyc2lvbiRtKTtjbGFzcyBGb3JtYXR0ZXJ7Y29uc3RydWN0b3IoKXtsb2dnZXIkcy5jaGVja05ldyhuZXcudGFyZ2V0LEZvcm1hdHRlcik7dGhpcy5mb3JtYXRzPXRoaXMuZ2V0RGVmYXVsdEZvcm1hdHMoKX1nZXREZWZhdWx0Rm9ybWF0cygpe2NvbnN0IGZvcm1hdHM9e307Y29uc3QgYWRkcmVzcz10aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtjb25zdCBiaWdOdW1iZXI9dGhpcy5iaWdOdW1iZXIuYmluZCh0aGlzKTtjb25zdCBibG9ja1RhZz10aGlzLmJsb2NrVGFnLmJpbmQodGhpcyk7Y29uc3QgZGF0YT10aGlzLmRhdGEuYmluZCh0aGlzKTtjb25zdCBoYXNoPXRoaXMuaGFzaC5iaW5kKHRoaXMpO2NvbnN0IGhleD10aGlzLmhleC5iaW5kKHRoaXMpO2NvbnN0IG51bWJlcj10aGlzLm51bWJlci5iaW5kKHRoaXMpO2NvbnN0IHN0cmljdERhdGE9dj0+e3JldHVybiB0aGlzLmRhdGEodix0cnVlKX07Zm9ybWF0cy50cmFuc2FjdGlvbj17aGFzaDpoYXNoLHR5cGU6Rm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsbnVsbCksYWNjZXNzTGlzdDpGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLG51bGwpLGJsb2NrSGFzaDpGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsbnVsbCksYmxvY2tOdW1iZXI6Rm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsbnVsbCksdHJhbnNhY3Rpb25JbmRleDpGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlcixudWxsKSxjb25maXJtYXRpb25zOkZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLG51bGwpLGZyb206YWRkcmVzcyxnYXNQcmljZTpiaWdOdW1iZXIsZ2FzTGltaXQ6YmlnTnVtYmVyLHRvOkZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyxudWxsKSx2YWx1ZTpiaWdOdW1iZXIsbm9uY2U6bnVtYmVyLGRhdGE6ZGF0YSxyOkZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxzOkZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSx2OkZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxjcmVhdGVzOkZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyxudWxsKSxyYXc6Rm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKX07Zm9ybWF0cy50cmFuc2FjdGlvblJlcXVlc3Q9e2Zyb206Rm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxub25jZTpGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksZ2FzTGltaXQ6Rm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLGdhc1ByaWNlOkZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSx0bzpGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLHZhbHVlOkZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxkYXRhOkZvcm1hdHRlci5hbGxvd051bGwoc3RyaWN0RGF0YSksdHlwZTpGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksYWNjZXNzTGlzdDpGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLG51bGwpfTtmb3JtYXRzLnJlY2VpcHRMb2c9e3RyYW5zYWN0aW9uSW5kZXg6bnVtYmVyLGJsb2NrTnVtYmVyOm51bWJlcix0cmFuc2FjdGlvbkhhc2g6aGFzaCxhZGRyZXNzOmFkZHJlc3MsdG9waWNzOkZvcm1hdHRlci5hcnJheU9mKGhhc2gpLGRhdGE6ZGF0YSxsb2dJbmRleDpudW1iZXIsYmxvY2tIYXNoOmhhc2h9O2Zvcm1hdHMucmVjZWlwdD17dG86Rm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsbnVsbCksZnJvbTpGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcyxudWxsKSxjb250cmFjdEFkZHJlc3M6Rm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLG51bGwpLHRyYW5zYWN0aW9uSW5kZXg6bnVtYmVyLHJvb3Q6Rm9ybWF0dGVyLmFsbG93TnVsbChoZXgpLGdhc1VzZWQ6YmlnTnVtYmVyLGxvZ3NCbG9vbTpGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLGJsb2NrSGFzaDpoYXNoLHRyYW5zYWN0aW9uSGFzaDpoYXNoLGxvZ3M6Rm9ybWF0dGVyLmFycmF5T2YodGhpcy5yZWNlaXB0TG9nLmJpbmQodGhpcykpLGJsb2NrTnVtYmVyOm51bWJlcixjb25maXJtYXRpb25zOkZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLG51bGwpLGN1bXVsYXRpdmVHYXNVc2VkOmJpZ051bWJlcixzdGF0dXM6Rm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpfTtmb3JtYXRzLmJsb2NrPXtoYXNoOmhhc2gscGFyZW50SGFzaDpoYXNoLG51bWJlcjpudW1iZXIsdGltZXN0YW1wOm51bWJlcixub25jZTpGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksZGlmZmljdWx0eTp0aGlzLmRpZmZpY3VsdHkuYmluZCh0aGlzKSxnYXNMaW1pdDpiaWdOdW1iZXIsZ2FzVXNlZDpiaWdOdW1iZXIsbWluZXI6YWRkcmVzcyxleHRyYURhdGE6ZGF0YSx0cmFuc2FjdGlvbnM6Rm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSl9O2Zvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zPXNoYWxsb3dDb3B5KGZvcm1hdHMuYmxvY2spO2Zvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zLnRyYW5zYWN0aW9ucz1Gb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKHRoaXMudHJhbnNhY3Rpb25SZXNwb25zZS5iaW5kKHRoaXMpKSk7Zm9ybWF0cy5maWx0ZXI9e2Zyb21CbG9jazpGb3JtYXR0ZXIuYWxsb3dOdWxsKGJsb2NrVGFnLHVuZGVmaW5lZCksdG9CbG9jazpGb3JtYXR0ZXIuYWxsb3dOdWxsKGJsb2NrVGFnLHVuZGVmaW5lZCksYmxvY2tIYXNoOkZvcm1hdHRlci5hbGxvd051bGwoaGFzaCx1bmRlZmluZWQpLGFkZHJlc3M6Rm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLHVuZGVmaW5lZCksdG9waWNzOkZvcm1hdHRlci5hbGxvd051bGwodGhpcy50b3BpY3MuYmluZCh0aGlzKSx1bmRlZmluZWQpfTtmb3JtYXRzLmZpbHRlckxvZz17YmxvY2tOdW1iZXI6Rm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLGJsb2NrSGFzaDpGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gpLHRyYW5zYWN0aW9uSW5kZXg6bnVtYmVyLHJlbW92ZWQ6Rm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmJvb2xlYW4uYmluZCh0aGlzKSksYWRkcmVzczphZGRyZXNzLGRhdGE6Rm9ybWF0dGVyLmFsbG93RmFsc2lzaChkYXRhLFwiMHhcIiksdG9waWNzOkZvcm1hdHRlci5hcnJheU9mKGhhc2gpLHRyYW5zYWN0aW9uSGFzaDpoYXNoLGxvZ0luZGV4Om51bWJlcn07cmV0dXJuIGZvcm1hdHN9YWNjZXNzTGlzdChhY2Nlc3NMaXN0KXtyZXR1cm4gYWNjZXNzTGlzdGlmeShhY2Nlc3NMaXN0fHxbXSl9bnVtYmVyKG51bWJlcil7aWYobnVtYmVyPT09XCIweFwiKXtyZXR1cm4gMH1yZXR1cm4gQmlnTnVtYmVyLmZyb20obnVtYmVyKS50b051bWJlcigpfWJpZ051bWJlcih2YWx1ZSl7cmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKX1ib29sZWFuKHZhbHVlKXtpZih0eXBlb2YgdmFsdWU9PT1cImJvb2xlYW5cIil7cmV0dXJuIHZhbHVlfWlmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe3ZhbHVlPXZhbHVlLnRvTG93ZXJDYXNlKCk7aWYodmFsdWU9PT1cInRydWVcIil7cmV0dXJuIHRydWV9aWYodmFsdWU9PT1cImZhbHNlXCIpe3JldHVybiBmYWxzZX19dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib29sZWFuIC0gXCIrdmFsdWUpfWhleCh2YWx1ZSxzdHJpY3Qpe2lmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe2lmKCFzdHJpY3QmJnZhbHVlLnN1YnN0cmluZygwLDIpIT09XCIweFwiKXt2YWx1ZT1cIjB4XCIrdmFsdWV9aWYoaXNIZXhTdHJpbmcodmFsdWUpKXtyZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKX19cmV0dXJuIGxvZ2dlciRzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGFzaFwiLFwidmFsdWVcIix2YWx1ZSl9ZGF0YSh2YWx1ZSxzdHJpY3Qpe2NvbnN0IHJlc3VsdD10aGlzLmhleCh2YWx1ZSxzdHJpY3QpO2lmKHJlc3VsdC5sZW5ndGglMiE9PTApe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YTsgb2RkLWxlbmd0aCAtIFwiK3ZhbHVlKX1yZXR1cm4gcmVzdWx0fWFkZHJlc3ModmFsdWUpe3JldHVybiBnZXRBZGRyZXNzKHZhbHVlKX1jYWxsQWRkcmVzcyh2YWx1ZSl7aWYoIWlzSGV4U3RyaW5nKHZhbHVlLDMyKSl7cmV0dXJuIG51bGx9Y29uc3QgYWRkcmVzcz1nZXRBZGRyZXNzKGhleERhdGFTbGljZSh2YWx1ZSwxMikpO3JldHVybiBhZGRyZXNzPT09QWRkcmVzc1plcm8/bnVsbDphZGRyZXNzfWNvbnRyYWN0QWRkcmVzcyh2YWx1ZSl7cmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh2YWx1ZSl9YmxvY2tUYWcoYmxvY2tUYWcpe2lmKGJsb2NrVGFnPT1udWxsKXtyZXR1cm5cImxhdGVzdFwifWlmKGJsb2NrVGFnPT09XCJlYXJsaWVzdFwiKXtyZXR1cm5cIjB4MFwifWlmKGJsb2NrVGFnPT09XCJsYXRlc3RcInx8YmxvY2tUYWc9PT1cInBlbmRpbmdcIil7cmV0dXJuIGJsb2NrVGFnfWlmKHR5cGVvZiBibG9ja1RhZz09PVwibnVtYmVyXCJ8fGlzSGV4U3RyaW5nKGJsb2NrVGFnKSl7cmV0dXJuIGhleFZhbHVlKGJsb2NrVGFnKX10aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrVGFnXCIpfWhhc2godmFsdWUsc3RyaWN0KXtjb25zdCByZXN1bHQ9dGhpcy5oZXgodmFsdWUsc3RyaWN0KTtpZihoZXhEYXRhTGVuZ3RoKHJlc3VsdCkhPT0zMil7cmV0dXJuIGxvZ2dlciRzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGFzaFwiLFwidmFsdWVcIix2YWx1ZSl9cmV0dXJuIHJlc3VsdH1kaWZmaWN1bHR5KHZhbHVlKXtpZih2YWx1ZT09bnVsbCl7cmV0dXJuIG51bGx9Y29uc3Qgdj1CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7dHJ5e3JldHVybiB2LnRvTnVtYmVyKCl9Y2F0Y2goZXJyb3Ipe31yZXR1cm4gbnVsbH11aW50MjU2KHZhbHVlKXtpZighaXNIZXhTdHJpbmcodmFsdWUpKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIil9cmV0dXJuIGhleFplcm9QYWQodmFsdWUsMzIpfV9ibG9jayh2YWx1ZSxmb3JtYXQpe2lmKHZhbHVlLmF1dGhvciE9bnVsbCYmdmFsdWUubWluZXI9PW51bGwpe3ZhbHVlLm1pbmVyPXZhbHVlLmF1dGhvcn1yZXR1cm4gRm9ybWF0dGVyLmNoZWNrKGZvcm1hdCx2YWx1ZSl9YmxvY2sodmFsdWUpe3JldHVybiB0aGlzLl9ibG9jayh2YWx1ZSx0aGlzLmZvcm1hdHMuYmxvY2spfWJsb2NrV2l0aFRyYW5zYWN0aW9ucyh2YWx1ZSl7cmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLHRoaXMuZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMpfXRyYW5zYWN0aW9uUmVxdWVzdCh2YWx1ZSl7cmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0LHZhbHVlKX10cmFuc2FjdGlvblJlc3BvbnNlKHRyYW5zYWN0aW9uKXtpZih0cmFuc2FjdGlvbi5nYXMhPW51bGwmJnRyYW5zYWN0aW9uLmdhc0xpbWl0PT1udWxsKXt0cmFuc2FjdGlvbi5nYXNMaW1pdD10cmFuc2FjdGlvbi5nYXN9aWYodHJhbnNhY3Rpb24udG8mJkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLnRvKS5pc1plcm8oKSl7dHJhbnNhY3Rpb24udG89XCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIn1pZih0cmFuc2FjdGlvbi5pbnB1dCE9bnVsbCYmdHJhbnNhY3Rpb24uZGF0YT09bnVsbCl7dHJhbnNhY3Rpb24uZGF0YT10cmFuc2FjdGlvbi5pbnB1dH1pZih0cmFuc2FjdGlvbi50bz09bnVsbCYmdHJhbnNhY3Rpb24uY3JlYXRlcz09bnVsbCl7dHJhbnNhY3Rpb24uY3JlYXRlcz10aGlzLmNvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbil9aWYodHJhbnNhY3Rpb24udHlwZT09PTEmJnRyYW5zYWN0aW9uLmFjY2Vzc0xpc3Q9PW51bGwpe3RyYW5zYWN0aW9uLmFjY2Vzc0xpc3Q9W119Y29uc3QgcmVzdWx0PUZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb24sdHJhbnNhY3Rpb24pO2lmKHRyYW5zYWN0aW9uLmNoYWluSWQhPW51bGwpe2xldCBjaGFpbklkPXRyYW5zYWN0aW9uLmNoYWluSWQ7aWYoaXNIZXhTdHJpbmcoY2hhaW5JZCkpe2NoYWluSWQ9QmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKX1yZXN1bHQuY2hhaW5JZD1jaGFpbklkfWVsc2V7bGV0IGNoYWluSWQ9dHJhbnNhY3Rpb24ubmV0d29ya0lkO2lmKGNoYWluSWQ9PW51bGwmJnJlc3VsdC52PT1udWxsKXtjaGFpbklkPXRyYW5zYWN0aW9uLmNoYWluSWR9aWYoaXNIZXhTdHJpbmcoY2hhaW5JZCkpe2NoYWluSWQ9QmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKX1pZih0eXBlb2YgY2hhaW5JZCE9PVwibnVtYmVyXCImJnJlc3VsdC52IT1udWxsKXtjaGFpbklkPShyZXN1bHQudi0zNSkvMjtpZihjaGFpbklkPDApe2NoYWluSWQ9MH1jaGFpbklkPXBhcnNlSW50KGNoYWluSWQpfWlmKHR5cGVvZiBjaGFpbklkIT09XCJudW1iZXJcIil7Y2hhaW5JZD0wfXJlc3VsdC5jaGFpbklkPWNoYWluSWR9aWYocmVzdWx0LmJsb2NrSGFzaCYmcmVzdWx0LmJsb2NrSGFzaC5yZXBsYWNlKC8wL2csXCJcIik9PT1cInhcIil7cmVzdWx0LmJsb2NrSGFzaD1udWxsfXJldHVybiByZXN1bHR9dHJhbnNhY3Rpb24odmFsdWUpe3JldHVybiBwYXJzZSh2YWx1ZSl9cmVjZWlwdExvZyh2YWx1ZSl7cmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdExvZyx2YWx1ZSl9cmVjZWlwdCh2YWx1ZSl7Y29uc3QgcmVzdWx0PUZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCx2YWx1ZSk7aWYocmVzdWx0LnJvb3QhPW51bGwpe2lmKHJlc3VsdC5yb290Lmxlbmd0aDw9NCl7Y29uc3QgdmFsdWU9QmlnTnVtYmVyLmZyb20ocmVzdWx0LnJvb3QpLnRvTnVtYmVyKCk7aWYodmFsdWU9PT0wfHx2YWx1ZT09PTEpe2lmKHJlc3VsdC5zdGF0dXMhPW51bGwmJnJlc3VsdC5zdGF0dXMhPT12YWx1ZSl7bG9nZ2VyJHMudGhyb3dBcmd1bWVudEVycm9yKFwiYWx0LXJvb3Qtc3RhdHVzL3N0YXR1cyBtaXNtYXRjaFwiLFwidmFsdWVcIix7cm9vdDpyZXN1bHQucm9vdCxzdGF0dXM6cmVzdWx0LnN0YXR1c30pfXJlc3VsdC5zdGF0dXM9dmFsdWU7ZGVsZXRlIHJlc3VsdC5yb290fWVsc2V7bG9nZ2VyJHMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhbHQtcm9vdC1zdGF0dXNcIixcInZhbHVlLnJvb3RcIixyZXN1bHQucm9vdCl9fWVsc2UgaWYocmVzdWx0LnJvb3QubGVuZ3RoIT09NjYpe2xvZ2dlciRzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcm9vdCBoYXNoXCIsXCJ2YWx1ZS5yb290XCIscmVzdWx0LnJvb3QpfX1pZihyZXN1bHQuc3RhdHVzIT1udWxsKXtyZXN1bHQuYnl6YW50aXVtPXRydWV9cmV0dXJuIHJlc3VsdH10b3BpY3ModmFsdWUpe2lmKEFycmF5LmlzQXJyYXkodmFsdWUpKXtyZXR1cm4gdmFsdWUubWFwKHY9PnRoaXMudG9waWNzKHYpKX1lbHNlIGlmKHZhbHVlIT1udWxsKXtyZXR1cm4gdGhpcy5oYXNoKHZhbHVlLHRydWUpfXJldHVybiBudWxsfWZpbHRlcih2YWx1ZSl7cmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLHZhbHVlKX1maWx0ZXJMb2codmFsdWUpe3JldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlckxvZyx2YWx1ZSl9c3RhdGljIGNoZWNrKGZvcm1hdCxvYmplY3Qpe2NvbnN0IHJlc3VsdD17fTtmb3IoY29uc3Qga2V5IGluIGZvcm1hdCl7dHJ5e2NvbnN0IHZhbHVlPWZvcm1hdFtrZXldKG9iamVjdFtrZXldKTtpZih2YWx1ZSE9PXVuZGVmaW5lZCl7cmVzdWx0W2tleV09dmFsdWV9fWNhdGNoKGVycm9yKXtlcnJvci5jaGVja0tleT1rZXk7ZXJyb3IuY2hlY2tWYWx1ZT1vYmplY3Rba2V5XTt0aHJvdyBlcnJvcn19cmV0dXJuIHJlc3VsdH1zdGF0aWMgYWxsb3dOdWxsKGZvcm1hdCxudWxsVmFsdWUpe3JldHVybiBmdW5jdGlvbih2YWx1ZSl7aWYodmFsdWU9PW51bGwpe3JldHVybiBudWxsVmFsdWV9cmV0dXJuIGZvcm1hdCh2YWx1ZSl9fXN0YXRpYyBhbGxvd0ZhbHNpc2goZm9ybWF0LHJlcGxhY2VWYWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKXtpZighdmFsdWUpe3JldHVybiByZXBsYWNlVmFsdWV9cmV0dXJuIGZvcm1hdCh2YWx1ZSl9fXN0YXRpYyBhcnJheU9mKGZvcm1hdCl7cmV0dXJuIGZ1bmN0aW9uKGFycmF5KXtpZighQXJyYXkuaXNBcnJheShhcnJheSkpe3Rocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKX1jb25zdCByZXN1bHQ9W107YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7cmVzdWx0LnB1c2goZm9ybWF0KHZhbHVlKSl9KTtyZXR1cm4gcmVzdWx0fX19ZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSl7cmV0dXJuIHZhbHVlJiZ0eXBlb2YgdmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZT09PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBpc0NvbW11bml0eVJlc291cmNlKHZhbHVlKXtyZXR1cm4gaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkmJnZhbHVlLmlzQ29tbXVuaXR5UmVzb3VyY2UoKX1sZXQgdGhyb3R0bGVNZXNzYWdlPWZhbHNlO2Z1bmN0aW9uIHNob3dUaHJvdHRsZU1lc3NhZ2UoKXtpZih0aHJvdHRsZU1lc3NhZ2Upe3JldHVybn10aHJvdHRsZU1lc3NhZ2U9dHJ1ZTtjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO2NvbnNvbGUubG9nKFwiUmVxdWVzdC1SYXRlIEV4Y2VlZGVkICAodGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIHJlcGVhdGVkKVwiKTtjb25zb2xlLmxvZyhcIlwiKTtjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7Y29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7Y29uc29sZS5sb2coXCJcIik7Y29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7Y29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtjb25zb2xlLmxvZyhcIlwiKTtjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vZG9jcy5ldGhlcnMuaW8vYXBpLWtleXMvXCIpO2NvbnNvbGUubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT1cIil9XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciQ4PXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkdD1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7ZnVuY3Rpb24gY2hlY2tUb3BpYyh0b3BpYyl7aWYodG9waWM9PW51bGwpe3JldHVyblwibnVsbFwifWlmKGhleERhdGFMZW5ndGgodG9waWMpIT09MzIpe2xvZ2dlciR0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdG9waWNcIixcInRvcGljXCIsdG9waWMpfXJldHVybiB0b3BpYy50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHNlcmlhbGl6ZVRvcGljcyh0b3BpY3Mpe3RvcGljcz10b3BpY3Muc2xpY2UoKTt3aGlsZSh0b3BpY3MubGVuZ3RoPjAmJnRvcGljc1t0b3BpY3MubGVuZ3RoLTFdPT1udWxsKXt0b3BpY3MucG9wKCl9cmV0dXJuIHRvcGljcy5tYXAodG9waWM9PntpZihBcnJheS5pc0FycmF5KHRvcGljKSl7Y29uc3QgdW5pcXVlPXt9O3RvcGljLmZvckVhY2godG9waWM9Pnt1bmlxdWVbY2hlY2tUb3BpYyh0b3BpYyldPXRydWV9KTtjb25zdCBzb3J0ZWQ9T2JqZWN0LmtleXModW5pcXVlKTtzb3J0ZWQuc29ydCgpO3JldHVybiBzb3J0ZWQuam9pbihcInxcIil9ZWxzZXtyZXR1cm4gY2hlY2tUb3BpYyh0b3BpYyl9fSkuam9pbihcIiZcIil9ZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSl7aWYoZGF0YT09PVwiXCIpe3JldHVybltdfXJldHVybiBkYXRhLnNwbGl0KC8mL2cpLm1hcCh0b3BpYz0+e2lmKHRvcGljPT09XCJcIil7cmV0dXJuW119Y29uc3QgY29tcHM9dG9waWMuc3BsaXQoXCJ8XCIpLm1hcCh0b3BpYz0+e3JldHVybiB0b3BpYz09PVwibnVsbFwiP251bGw6dG9waWN9KTtyZXR1cm4gY29tcHMubGVuZ3RoPT09MT9jb21wc1swXTpjb21wc30pfWZ1bmN0aW9uIGdldEV2ZW50VGFnJDEoZXZlbnROYW1lKXtpZih0eXBlb2YgZXZlbnROYW1lPT09XCJzdHJpbmdcIil7ZXZlbnROYW1lPWV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO2lmKGhleERhdGFMZW5ndGgoZXZlbnROYW1lKT09PTMyKXtyZXR1cm5cInR4OlwiK2V2ZW50TmFtZX1pZihldmVudE5hbWUuaW5kZXhPZihcIjpcIik9PT0tMSl7cmV0dXJuIGV2ZW50TmFtZX19ZWxzZSBpZihBcnJheS5pc0FycmF5KGV2ZW50TmFtZSkpe3JldHVyblwiZmlsdGVyOio6XCIrc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZSl9ZWxzZSBpZihGb3JrRXZlbnQuaXNGb3JrRXZlbnQoZXZlbnROYW1lKSl7bG9nZ2VyJHQud2FybihcIm5vdCBpbXBsZW1lbnRlZFwiKTt0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIil9ZWxzZSBpZihldmVudE5hbWUmJnR5cGVvZiBldmVudE5hbWU9PT1cIm9iamVjdFwiKXtyZXR1cm5cImZpbHRlcjpcIisoZXZlbnROYW1lLmFkZHJlc3N8fFwiKlwiKStcIjpcIitzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lLnRvcGljc3x8W10pfXRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQgLSBcIitldmVudE5hbWUpfWZ1bmN0aW9uIGdldFRpbWUoKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX1mdW5jdGlvbiBzdGFsbChkdXJhdGlvbil7cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmU9PntzZXRUaW1lb3V0KHJlc29sdmUsZHVyYXRpb24pfSl9Y29uc3QgUG9sbGFibGVFdmVudHM9W1wiYmxvY2tcIixcIm5ldHdvcmtcIixcInBlbmRpbmdcIixcInBvbGxcIl07Y2xhc3MgRXZlbnR7Y29uc3RydWN0b3IodGFnLGxpc3RlbmVyLG9uY2Upe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJ0YWdcIix0YWcpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJsaXN0ZW5lclwiLGxpc3RlbmVyKTtkZWZpbmVSZWFkT25seSh0aGlzLFwib25jZVwiLG9uY2UpfWdldCBldmVudCgpe3N3aXRjaCh0aGlzLnR5cGUpe2Nhc2VcInR4XCI6cmV0dXJuIHRoaXMuaGFzaDtjYXNlXCJmaWx0ZXJcIjpyZXR1cm4gdGhpcy5maWx0ZXJ9cmV0dXJuIHRoaXMudGFnfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXX1nZXQgaGFzaCgpe2NvbnN0IGNvbXBzPXRoaXMudGFnLnNwbGl0KFwiOlwiKTtpZihjb21wc1swXSE9PVwidHhcIil7cmV0dXJuIG51bGx9cmV0dXJuIGNvbXBzWzFdfWdldCBmaWx0ZXIoKXtjb25zdCBjb21wcz10aGlzLnRhZy5zcGxpdChcIjpcIik7aWYoY29tcHNbMF0hPT1cImZpbHRlclwiKXtyZXR1cm4gbnVsbH1jb25zdCBhZGRyZXNzPWNvbXBzWzFdO2NvbnN0IHRvcGljcz1kZXNlcmlhbGl6ZVRvcGljcyhjb21wc1syXSk7Y29uc3QgZmlsdGVyPXt9O2lmKHRvcGljcy5sZW5ndGg+MCl7ZmlsdGVyLnRvcGljcz10b3BpY3N9aWYoYWRkcmVzcyYmYWRkcmVzcyE9PVwiKlwiKXtmaWx0ZXIuYWRkcmVzcz1hZGRyZXNzfXJldHVybiBmaWx0ZXJ9cG9sbGFibGUoKXtyZXR1cm4gdGhpcy50YWcuaW5kZXhPZihcIjpcIik+PTB8fFBvbGxhYmxlRXZlbnRzLmluZGV4T2YodGhpcy50YWcpPj0wfX1jb25zdCBjb2luSW5mb3M9ezA6e3N5bWJvbDpcImJ0Y1wiLHAycGtoOjAscDJzaDo1LHByZWZpeDpcImJjXCJ9LDI6e3N5bWJvbDpcImx0Y1wiLHAycGtoOjQ4LHAyc2g6NTAscHJlZml4OlwibHRjXCJ9LDM6e3N5bWJvbDpcImRvZ2VcIixwMnBraDozMCxwMnNoOjIyfSw2MDp7c3ltYm9sOlwiZXRoXCIsaWxrOlwiZXRoXCJ9LDYxOntzeW1ib2w6XCJldGNcIixpbGs6XCJldGhcIn0sNzAwOntzeW1ib2w6XCJ4ZGFpXCIsaWxrOlwiZXRoXCJ9fTtmdW5jdGlvbiBieXRlczMyaWZ5KHZhbHVlKXtyZXR1cm4gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSwzMil9ZnVuY3Rpb24gYmFzZTU4RW5jb2RlKGRhdGEpe3JldHVybiBCYXNlNTguZW5jb2RlKGNvbmNhdChbZGF0YSxoZXhEYXRhU2xpY2Uoc2hhMjU2JDEoc2hhMjU2JDEoZGF0YSkpLDAsNCldKSl9Y2xhc3MgUmVzb2x2ZXJ7Y29uc3RydWN0b3IocHJvdmlkZXIsYWRkcmVzcyxuYW1lKXtkZWZpbmVSZWFkT25seSh0aGlzLFwicHJvdmlkZXJcIixwcm92aWRlcik7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIm5hbWVcIixuYW1lKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYWRkcmVzc1wiLHByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpKX1fZmV0Y2hCeXRlcyhzZWxlY3RvcixwYXJhbWV0ZXJzKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHRyYW5zYWN0aW9uPXt0bzp0aGlzLmFkZHJlc3MsZGF0YTpoZXhDb25jYXQoW3NlbGVjdG9yLG5hbWVoYXNoKHRoaXMubmFtZSkscGFyYW1ldGVyc3x8XCIweFwiXSl9O2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHJhbnNhY3Rpb24pO2lmKHJlc3VsdD09PVwiMHhcIil7cmV0dXJuIG51bGx9Y29uc3Qgb2Zmc2V0PUJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShyZXN1bHQsMCwzMikpLnRvTnVtYmVyKCk7Y29uc3QgbGVuZ3RoPUJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShyZXN1bHQsb2Zmc2V0LG9mZnNldCszMikpLnRvTnVtYmVyKCk7cmV0dXJuIGhleERhdGFTbGljZShyZXN1bHQsb2Zmc2V0KzMyLG9mZnNldCszMitsZW5ndGgpfSl9X2dldEFkZHJlc3MoY29pblR5cGUsaGV4Qnl0ZXMpe2NvbnN0IGNvaW5JbmZvPWNvaW5JbmZvc1tTdHJpbmcoY29pblR5cGUpXTtpZihjb2luSW5mbz09bnVsbCl7bG9nZ2VyJHQudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgY29pbiB0eXBlOiAke2NvaW5UeXBlfWAsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgfSl9aWYoY29pbkluZm8uaWxrPT09XCJldGhcIil7cmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoaGV4Qnl0ZXMpfWNvbnN0IGJ5dGVzPWFycmF5aWZ5KGhleEJ5dGVzKTtpZihjb2luSW5mby5wMnBraCE9bnVsbCl7Y29uc3QgcDJwa2g9aGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7aWYocDJwa2gpe2NvbnN0IGxlbmd0aD1wYXJzZUludChwMnBraFsxXSwxNik7aWYocDJwa2hbMl0ubGVuZ3RoPT09bGVuZ3RoKjImJmxlbmd0aD49MSYmbGVuZ3RoPD03NSl7cmV0dXJuIGJhc2U1OEVuY29kZShjb25jYXQoW1tjb2luSW5mby5wMnBraF0sXCIweFwiK3AycGtoWzJdXSkpfX19aWYoY29pbkluZm8ucDJzaCE9bnVsbCl7Y29uc3QgcDJzaD1oZXhCeXRlcy5tYXRjaCgvXjB4YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg3JC8pO2lmKHAyc2gpe2NvbnN0IGxlbmd0aD1wYXJzZUludChwMnNoWzFdLDE2KTtpZihwMnNoWzJdLmxlbmd0aD09PWxlbmd0aCoyJiZsZW5ndGg+PTEmJmxlbmd0aDw9NzUpe3JldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJzaF0sXCIweFwiK3Ayc2hbMl1dKSl9fX1pZihjb2luSW5mby5wcmVmaXghPW51bGwpe2NvbnN0IGxlbmd0aD1ieXRlc1sxXTtsZXQgdmVyc2lvbj1ieXRlc1swXTtpZih2ZXJzaW9uPT09MCl7aWYobGVuZ3RoIT09MjAmJmxlbmd0aCE9PTMyKXt2ZXJzaW9uPS0xfX1lbHNle3ZlcnNpb249LTF9aWYodmVyc2lvbj49MCYmYnl0ZXMubGVuZ3RoPT09MitsZW5ndGgmJmxlbmd0aD49MSYmbGVuZ3RoPD03NSl7Y29uc3Qgd29yZHM9YmVjaDMyLnRvV29yZHMoYnl0ZXMuc2xpY2UoMikpO3dvcmRzLnVuc2hpZnQodmVyc2lvbik7cmV0dXJuIGJlY2gzMi5lbmNvZGUoY29pbkluZm8ucHJlZml4LHdvcmRzKX19cmV0dXJuIG51bGx9Z2V0QWRkcmVzcyhjb2luVHlwZSl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZihjb2luVHlwZT09bnVsbCl7Y29pblR5cGU9NjB9aWYoY29pblR5cGU9PT02MCl7Y29uc3QgdHJhbnNhY3Rpb249e3RvOnRoaXMuYWRkcmVzcyxkYXRhOlwiMHgzYjNiNTdkZVwiK25hbWVoYXNoKHRoaXMubmFtZSkuc3Vic3RyaW5nKDIpfTtjb25zdCBoZXhCeXRlcz15aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHJhbnNhY3Rpb24pO2lmKGhleEJ5dGVzPT09XCIweFwifHxoZXhCeXRlcz09PUhhc2haZXJvKXtyZXR1cm4gbnVsbH1yZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MoaGV4Qnl0ZXMpfWNvbnN0IGhleEJ5dGVzPXlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGYxY2I3ZTA2XCIsYnl0ZXMzMmlmeShjb2luVHlwZSkpO2lmKGhleEJ5dGVzPT1udWxsfHxoZXhCeXRlcz09PVwiMHhcIil7cmV0dXJuIG51bGx9Y29uc3QgYWRkcmVzcz10aGlzLl9nZXRBZGRyZXNzKGNvaW5UeXBlLGhleEJ5dGVzKTtpZihhZGRyZXNzPT1udWxsKXtsb2dnZXIkdC50aHJvd0Vycm9yKGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvaW4gZGF0YWAsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLGNvaW5UeXBlOmNvaW5UeXBlLGRhdGE6aGV4Qnl0ZXN9KX1yZXR1cm4gYWRkcmVzc30pfWdldENvbnRlbnRIYXNoKCl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBoZXhCeXRlcz15aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhiYzFjNThkMVwiKTtpZihoZXhCeXRlcz09bnVsbHx8aGV4Qnl0ZXM9PT1cIjB4XCIpe3JldHVybiBudWxsfWNvbnN0IGlwZnM9aGV4Qnl0ZXMubWF0Y2goL14weGUzMDEwMTcwKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtpZihpcGZzKXtjb25zdCBsZW5ndGg9cGFyc2VJbnQoaXBmc1szXSwxNik7aWYoaXBmc1s0XS5sZW5ndGg9PT1sZW5ndGgqMil7cmV0dXJuXCJpcGZzOi8vXCIrQmFzZTU4LmVuY29kZShcIjB4XCIraXBmc1sxXSl9fWNvbnN0IHN3YXJtPWhleEJ5dGVzLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO2lmKHN3YXJtKXtpZihzd2FybVsxXS5sZW5ndGg9PT0zMioyKXtyZXR1cm5cImJ6ejovL1wiK3N3YXJtWzFdfX1yZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImdldENvbnRlbnRIYXNoKClcIixkYXRhOmhleEJ5dGVzfSl9KX1nZXRUZXh0KGtleSl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtsZXQga2V5Qnl0ZXM9dG9VdGY4Qnl0ZXMoa2V5KTtrZXlCeXRlcz1jb25jYXQoW2J5dGVzMzJpZnkoNjQpLGJ5dGVzMzJpZnkoa2V5Qnl0ZXMubGVuZ3RoKSxrZXlCeXRlc10pO2lmKGtleUJ5dGVzLmxlbmd0aCUzMiE9PTApe2tleUJ5dGVzPWNvbmNhdChba2V5Qnl0ZXMsaGV4WmVyb1BhZChcIjB4XCIsMzIta2V5Lmxlbmd0aCUzMildKX1jb25zdCBoZXhCeXRlcz15aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHg1OWQxZDQzY1wiLGhleGxpZnkoa2V5Qnl0ZXMpKTtpZihoZXhCeXRlcz09bnVsbHx8aGV4Qnl0ZXM9PT1cIjB4XCIpe3JldHVybiBudWxsfXJldHVybiB0b1V0ZjhTdHJpbmcoaGV4Qnl0ZXMpfSl9fWxldCBkZWZhdWx0Rm9ybWF0dGVyPW51bGw7bGV0IG5leHRQb2xsSWQ9MTtjbGFzcyBCYXNlUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlcntjb25zdHJ1Y3RvcihuZXR3b3JrKXtsb2dnZXIkdC5jaGVja05ldyhuZXcudGFyZ2V0LFByb3ZpZGVyKTtzdXBlcigpO3RoaXMuX2V2ZW50cz1bXTt0aGlzLl9lbWl0dGVkPXtibG9jazotMn07dGhpcy5mb3JtYXR0ZXI9bmV3LnRhcmdldC5nZXRGb3JtYXR0ZXIoKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiYW55TmV0d29ya1wiLG5ldHdvcms9PT1cImFueVwiKTtpZih0aGlzLmFueU5ldHdvcmspe25ldHdvcms9dGhpcy5kZXRlY3ROZXR3b3JrKCl9aWYobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2Upe3RoaXMuX25ldHdvcmtQcm9taXNlPW5ldHdvcms7bmV0d29yay5jYXRjaChlcnJvcj0+e30pO3RoaXMuX3JlYWR5KCkuY2F0Y2goZXJyb3I9Pnt9KX1lbHNle2NvbnN0IGtub3duTmV0d29yaz1nZXRTdGF0aWMobmV3LnRhcmdldCxcImdldE5ldHdvcmtcIikobmV0d29yayk7aWYoa25vd25OZXR3b3JrKXtkZWZpbmVSZWFkT25seSh0aGlzLFwiX25ldHdvcmtcIixrbm93bk5ldHdvcmspO3RoaXMuZW1pdChcIm5ldHdvcmtcIixrbm93bk5ldHdvcmssbnVsbCl9ZWxzZXtsb2dnZXIkdC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG5ldHdvcmtcIixcIm5ldHdvcmtcIixuZXR3b3JrKX19dGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcj0tMTAyNDt0aGlzLl9sYXN0QmxvY2tOdW1iZXI9LTI7dGhpcy5fcG9sbGluZ0ludGVydmFsPTRlMzt0aGlzLl9mYXN0UXVlcnlEYXRlPTB9X3JlYWR5KCl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZih0aGlzLl9uZXR3b3JrPT1udWxsKXtsZXQgbmV0d29yaz1udWxsO2lmKHRoaXMuX25ldHdvcmtQcm9taXNlKXt0cnl7bmV0d29yaz15aWVsZCB0aGlzLl9uZXR3b3JrUHJvbWlzZX1jYXRjaChlcnJvcil7fX1pZihuZXR3b3JrPT1udWxsKXtuZXR3b3JrPXlpZWxkIHRoaXMuZGV0ZWN0TmV0d29yaygpfWlmKCFuZXR3b3JrKXtsb2dnZXIkdC50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUix7fSl9aWYodGhpcy5fbmV0d29yaz09bnVsbCl7aWYodGhpcy5hbnlOZXR3b3JrKXt0aGlzLl9uZXR3b3JrPW5ldHdvcmt9ZWxzZXtkZWZpbmVSZWFkT25seSh0aGlzLFwiX25ldHdvcmtcIixuZXR3b3JrKX10aGlzLmVtaXQoXCJuZXR3b3JrXCIsbmV0d29yayxudWxsKX19cmV0dXJuIHRoaXMuX25ldHdvcmt9KX1nZXQgcmVhZHkoKXtyZXR1cm4gcG9sbCgoKT0+e3JldHVybiB0aGlzLl9yZWFkeSgpLnRoZW4obmV0d29yaz0+e3JldHVybiBuZXR3b3JrfSxlcnJvcj0+e2lmKGVycm9yLmNvZGU9PT1Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1ImJmVycm9yLmV2ZW50PT09XCJub05ldHdvcmtcIil7cmV0dXJuIHVuZGVmaW5lZH10aHJvdyBlcnJvcn0pfSl9c3RhdGljIGdldEZvcm1hdHRlcigpe2lmKGRlZmF1bHRGb3JtYXR0ZXI9PW51bGwpe2RlZmF1bHRGb3JtYXR0ZXI9bmV3IEZvcm1hdHRlcn1yZXR1cm4gZGVmYXVsdEZvcm1hdHRlcn1zdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKXtyZXR1cm4gZ2V0TmV0d29yayhuZXR3b3JrPT1udWxsP1wiaG9tZXN0ZWFkXCI6bmV0d29yayl9X2dldEludGVybmFsQmxvY2tOdW1iZXIobWF4QWdlKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuX3JlYWR5KCk7aWYobWF4QWdlPjApe3doaWxlKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIpe2NvbnN0IGludGVybmFsQmxvY2tOdW1iZXI9dGhpcy5faW50ZXJuYWxCbG9ja051bWJlcjt0cnl7Y29uc3QgcmVzdWx0PXlpZWxkIGludGVybmFsQmxvY2tOdW1iZXI7aWYoZ2V0VGltZSgpLXJlc3VsdC5yZXNwVGltZTw9bWF4QWdlKXtyZXR1cm4gcmVzdWx0LmJsb2NrTnVtYmVyfWJyZWFrfWNhdGNoKGVycm9yKXtpZih0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyPT09aW50ZXJuYWxCbG9ja051bWJlcil7YnJlYWt9fX19Y29uc3QgcmVxVGltZT1nZXRUaW1lKCk7Y29uc3QgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyPXJlc29sdmVQcm9wZXJ0aWVzKHtibG9ja051bWJlcjp0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLHt9KSxuZXR3b3JrRXJyb3I6dGhpcy5nZXROZXR3b3JrKCkudGhlbihuZXR3b3JrPT5udWxsLGVycm9yPT5lcnJvcil9KS50aGVuKCh7YmxvY2tOdW1iZXI6YmxvY2tOdW1iZXIsbmV0d29ya0Vycm9yOm5ldHdvcmtFcnJvcn0pPT57aWYobmV0d29ya0Vycm9yKXtpZih0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyPT09Y2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKXt0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyPW51bGx9dGhyb3cgbmV0d29ya0Vycm9yfWNvbnN0IHJlc3BUaW1lPWdldFRpbWUoKTtibG9ja051bWJlcj1CaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtpZihibG9ja051bWJlcjx0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKXtibG9ja051bWJlcj10aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyfXRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXI9YmxvY2tOdW1iZXI7dGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtyZXR1cm57YmxvY2tOdW1iZXI6YmxvY2tOdW1iZXIscmVxVGltZTpyZXFUaW1lLHJlc3BUaW1lOnJlc3BUaW1lfX0pO3RoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI9Y2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyO2NoZWNrSW50ZXJuYWxCbG9ja051bWJlci5jYXRjaChlcnJvcj0+e2lmKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI9PT1jaGVja0ludGVybmFsQmxvY2tOdW1iZXIpe3RoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI9bnVsbH19KTtyZXR1cm4oeWllbGQgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKS5ibG9ja051bWJlcn0pfXBvbGwoKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHBvbGxJZD1uZXh0UG9sbElkKys7Y29uc3QgcnVubmVycz1bXTtsZXQgYmxvY2tOdW1iZXI9bnVsbDt0cnl7YmxvY2tOdW1iZXI9eWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDArdGhpcy5wb2xsaW5nSW50ZXJ2YWwvMil9Y2F0Y2goZXJyb3Ipe3RoaXMuZW1pdChcImVycm9yXCIsZXJyb3IpO3JldHVybn10aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO3RoaXMuZW1pdChcInBvbGxcIixwb2xsSWQsYmxvY2tOdW1iZXIpO2lmKGJsb2NrTnVtYmVyPT09dGhpcy5fbGFzdEJsb2NrTnVtYmVyKXt0aGlzLmVtaXQoXCJkaWRQb2xsXCIscG9sbElkKTtyZXR1cm59aWYodGhpcy5fZW1pdHRlZC5ibG9jaz09PS0yKXt0aGlzLl9lbWl0dGVkLmJsb2NrPWJsb2NrTnVtYmVyLTF9aWYoTWF0aC5hYnModGhpcy5fZW1pdHRlZC5ibG9jay1ibG9ja051bWJlcik+MWUzKXtsb2dnZXIkdC53YXJuKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHNcIik7dGhpcy5lbWl0KFwiZXJyb3JcIixsb2dnZXIkdC5tYWtlRXJyb3IoXCJuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWRcIixMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1Ise2Jsb2NrTnVtYmVyOmJsb2NrTnVtYmVyLGV2ZW50OlwiYmxvY2tTa2V3XCIscHJldmlvdXNCbG9ja051bWJlcjp0aGlzLl9lbWl0dGVkLmJsb2NrfSkpO3RoaXMuZW1pdChcImJsb2NrXCIsYmxvY2tOdW1iZXIpfWVsc2V7Zm9yKGxldCBpPXRoaXMuX2VtaXR0ZWQuYmxvY2srMTtpPD1ibG9ja051bWJlcjtpKyspe3RoaXMuZW1pdChcImJsb2NrXCIsaSl9fWlmKHRoaXMuX2VtaXR0ZWQuYmxvY2shPT1ibG9ja051bWJlcil7dGhpcy5fZW1pdHRlZC5ibG9jaz1ibG9ja051bWJlcjtPYmplY3Qua2V5cyh0aGlzLl9lbWl0dGVkKS5mb3JFYWNoKGtleT0+e2lmKGtleT09PVwiYmxvY2tcIil7cmV0dXJufWNvbnN0IGV2ZW50QmxvY2tOdW1iZXI9dGhpcy5fZW1pdHRlZFtrZXldO2lmKGV2ZW50QmxvY2tOdW1iZXI9PT1cInBlbmRpbmdcIil7cmV0dXJufWlmKGJsb2NrTnVtYmVyLWV2ZW50QmxvY2tOdW1iZXI+MTIpe2RlbGV0ZSB0aGlzLl9lbWl0dGVkW2tleV19fSl9aWYodGhpcy5fbGFzdEJsb2NrTnVtYmVyPT09LTIpe3RoaXMuX2xhc3RCbG9ja051bWJlcj1ibG9ja051bWJlci0xfXRoaXMuX2V2ZW50cy5mb3JFYWNoKGV2ZW50PT57c3dpdGNoKGV2ZW50LnR5cGUpe2Nhc2VcInR4XCI6e2NvbnN0IGhhc2g9ZXZlbnQuaGFzaDtsZXQgcnVubmVyPXRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpLnRoZW4ocmVjZWlwdD0+e2lmKCFyZWNlaXB0fHxyZWNlaXB0LmJsb2NrTnVtYmVyPT1udWxsKXtyZXR1cm4gbnVsbH10aGlzLl9lbWl0dGVkW1widDpcIitoYXNoXT1yZWNlaXB0LmJsb2NrTnVtYmVyO3RoaXMuZW1pdChoYXNoLHJlY2VpcHQpO3JldHVybiBudWxsfSkuY2F0Y2goZXJyb3I9Pnt0aGlzLmVtaXQoXCJlcnJvclwiLGVycm9yKX0pO3J1bm5lcnMucHVzaChydW5uZXIpO2JyZWFrfWNhc2VcImZpbHRlclwiOntjb25zdCBmaWx0ZXI9ZXZlbnQuZmlsdGVyO2ZpbHRlci5mcm9tQmxvY2s9dGhpcy5fbGFzdEJsb2NrTnVtYmVyKzE7ZmlsdGVyLnRvQmxvY2s9YmxvY2tOdW1iZXI7Y29uc3QgcnVubmVyPXRoaXMuZ2V0TG9ncyhmaWx0ZXIpLnRoZW4obG9ncz0+e2lmKGxvZ3MubGVuZ3RoPT09MCl7cmV0dXJufWxvZ3MuZm9yRWFjaChsb2c9Pnt0aGlzLl9lbWl0dGVkW1wiYjpcIitsb2cuYmxvY2tIYXNoXT1sb2cuYmxvY2tOdW1iZXI7dGhpcy5fZW1pdHRlZFtcInQ6XCIrbG9nLnRyYW5zYWN0aW9uSGFzaF09bG9nLmJsb2NrTnVtYmVyO3RoaXMuZW1pdChmaWx0ZXIsbG9nKX0pfSkuY2F0Y2goZXJyb3I9Pnt0aGlzLmVtaXQoXCJlcnJvclwiLGVycm9yKX0pO3J1bm5lcnMucHVzaChydW5uZXIpO2JyZWFrfX19KTt0aGlzLl9sYXN0QmxvY2tOdW1iZXI9YmxvY2tOdW1iZXI7UHJvbWlzZS5hbGwocnVubmVycykudGhlbigoKT0+e3RoaXMuZW1pdChcImRpZFBvbGxcIixwb2xsSWQpfSkuY2F0Y2goZXJyb3I9Pnt0aGlzLmVtaXQoXCJlcnJvclwiLGVycm9yKX0pO3JldHVybn0pfXJlc2V0RXZlbnRzQmxvY2soYmxvY2tOdW1iZXIpe3RoaXMuX2xhc3RCbG9ja051bWJlcj1ibG9ja051bWJlci0xO2lmKHRoaXMucG9sbGluZyl7dGhpcy5wb2xsKCl9fWdldCBuZXR3b3JrKCl7cmV0dXJuIHRoaXMuX25ldHdvcmt9ZGV0ZWN0TmV0d29yaygpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoXCJwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IG5ldHdvcmsgZGV0ZWN0aW9uXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInByb3ZpZGVyLmRldGVjdE5ldHdvcmtcIn0pfSl9Z2V0TmV0d29yaygpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgbmV0d29yaz15aWVsZCB0aGlzLl9yZWFkeSgpO2NvbnN0IGN1cnJlbnROZXR3b3JrPXlpZWxkIHRoaXMuZGV0ZWN0TmV0d29yaygpO2lmKG5ldHdvcmsuY2hhaW5JZCE9PWN1cnJlbnROZXR3b3JrLmNoYWluSWQpe2lmKHRoaXMuYW55TmV0d29yayl7dGhpcy5fbmV0d29yaz1jdXJyZW50TmV0d29yazt0aGlzLl9sYXN0QmxvY2tOdW1iZXI9LTI7dGhpcy5fZmFzdEJsb2NrTnVtYmVyPW51bGw7dGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZT1udWxsO3RoaXMuX2Zhc3RRdWVyeURhdGU9MDt0aGlzLl9lbWl0dGVkLmJsb2NrPS0yO3RoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXI9LTEwMjQ7dGhpcy5faW50ZXJuYWxCbG9ja051bWJlcj1udWxsO3RoaXMuZW1pdChcIm5ldHdvcmtcIixjdXJyZW50TmV0d29yayxuZXR3b3JrKTt5aWVsZCBzdGFsbCgwKTtyZXR1cm4gdGhpcy5fbmV0d29ya31jb25zdCBlcnJvcj1sb2dnZXIkdC5tYWtlRXJyb3IoXCJ1bmRlcmx5aW5nIG5ldHdvcmsgY2hhbmdlZFwiLExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUix7ZXZlbnQ6XCJjaGFuZ2VkXCIsbmV0d29yazpuZXR3b3JrLGRldGVjdGVkTmV0d29yazpjdXJyZW50TmV0d29ya30pO3RoaXMuZW1pdChcImVycm9yXCIsZXJyb3IpO3Rocm93IGVycm9yfXJldHVybiBuZXR3b3JrfSl9Z2V0IGJsb2NrTnVtYmVyKCl7dGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDArdGhpcy5wb2xsaW5nSW50ZXJ2YWwvMikudGhlbihibG9ja051bWJlcj0+e3RoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcil9LGVycm9yPT57fSk7cmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlciE9bnVsbD90aGlzLl9mYXN0QmxvY2tOdW1iZXI6LTF9Z2V0IHBvbGxpbmcoKXtyZXR1cm4gdGhpcy5fcG9sbGVyIT1udWxsfXNldCBwb2xsaW5nKHZhbHVlKXtpZih2YWx1ZSYmIXRoaXMuX3BvbGxlcil7dGhpcy5fcG9sbGVyPXNldEludGVydmFsKCgpPT57dGhpcy5wb2xsKCl9LHRoaXMucG9sbGluZ0ludGVydmFsKTtpZighdGhpcy5fYm9vdHN0cmFwUG9sbCl7dGhpcy5fYm9vdHN0cmFwUG9sbD1zZXRUaW1lb3V0KCgpPT57dGhpcy5wb2xsKCk7dGhpcy5fYm9vdHN0cmFwUG9sbD1zZXRUaW1lb3V0KCgpPT57aWYoIXRoaXMuX3BvbGxlcil7dGhpcy5wb2xsKCl9dGhpcy5fYm9vdHN0cmFwUG9sbD1udWxsfSx0aGlzLnBvbGxpbmdJbnRlcnZhbCl9LDApfX1lbHNlIGlmKCF2YWx1ZSYmdGhpcy5fcG9sbGVyKXtjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7dGhpcy5fcG9sbGVyPW51bGx9fWdldCBwb2xsaW5nSW50ZXJ2YWwoKXtyZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsfXNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PVwibnVtYmVyXCJ8fHZhbHVlPD0wfHxwYXJzZUludChTdHJpbmcodmFsdWUpKSE9dmFsdWUpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9sbGluZyBpbnRlcnZhbFwiKX10aGlzLl9wb2xsaW5nSW50ZXJ2YWw9dmFsdWU7aWYodGhpcy5fcG9sbGVyKXtjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7dGhpcy5fcG9sbGVyPXNldEludGVydmFsKCgpPT57dGhpcy5wb2xsKCl9LHRoaXMuX3BvbGxpbmdJbnRlcnZhbCl9fV9nZXRGYXN0QmxvY2tOdW1iZXIoKXtjb25zdCBub3c9Z2V0VGltZSgpO2lmKG5vdy10aGlzLl9mYXN0UXVlcnlEYXRlPjIqdGhpcy5fcG9sbGluZ0ludGVydmFsKXt0aGlzLl9mYXN0UXVlcnlEYXRlPW5vdzt0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlPXRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKGJsb2NrTnVtYmVyPT57aWYodGhpcy5fZmFzdEJsb2NrTnVtYmVyPT1udWxsfHxibG9ja051bWJlcj50aGlzLl9mYXN0QmxvY2tOdW1iZXIpe3RoaXMuX2Zhc3RCbG9ja051bWJlcj1ibG9ja051bWJlcn1yZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyfSl9cmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2V9X3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcil7aWYodGhpcy5fZmFzdEJsb2NrTnVtYmVyIT1udWxsJiZibG9ja051bWJlcjx0aGlzLl9mYXN0QmxvY2tOdW1iZXIpe3JldHVybn10aGlzLl9mYXN0UXVlcnlEYXRlPWdldFRpbWUoKTtpZih0aGlzLl9mYXN0QmxvY2tOdW1iZXI9PW51bGx8fGJsb2NrTnVtYmVyPnRoaXMuX2Zhc3RCbG9ja051bWJlcil7dGhpcy5fZmFzdEJsb2NrTnVtYmVyPWJsb2NrTnVtYmVyO3RoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2U9UHJvbWlzZS5yZXNvbHZlKGJsb2NrTnVtYmVyKX19d2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCxjb25maXJtYXRpb25zLHRpbWVvdXQpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYoY29uZmlybWF0aW9ucz09bnVsbCl7Y29uZmlybWF0aW9ucz0xfWNvbnN0IHJlY2VpcHQ9eWllbGQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtpZigocmVjZWlwdD9yZWNlaXB0LmNvbmZpcm1hdGlvbnM6MCk+PWNvbmZpcm1hdGlvbnMpe3JldHVybiByZWNlaXB0fXJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpPT57bGV0IHRpbWVyPW51bGw7bGV0IGRvbmU9ZmFsc2U7Y29uc3QgaGFuZGxlcj1yZWNlaXB0PT57aWYocmVjZWlwdC5jb25maXJtYXRpb25zPGNvbmZpcm1hdGlvbnMpe3JldHVybn1pZih0aW1lcil7Y2xlYXJUaW1lb3V0KHRpbWVyKX1pZihkb25lKXtyZXR1cm59ZG9uZT10cnVlO3RoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLGhhbmRsZXIpO3Jlc29sdmUocmVjZWlwdCl9O3RoaXMub24odHJhbnNhY3Rpb25IYXNoLGhhbmRsZXIpO2lmKHR5cGVvZiB0aW1lb3V0PT09XCJudW1iZXJcIiYmdGltZW91dD4wKXt0aW1lcj1zZXRUaW1lb3V0KCgpPT57aWYoZG9uZSl7cmV0dXJufXRpbWVyPW51bGw7ZG9uZT10cnVlO3RoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLGhhbmRsZXIpO3JlamVjdChsb2dnZXIkdC5tYWtlRXJyb3IoXCJ0aW1lb3V0IGV4Y2VlZGVkXCIsTG9nZ2VyLmVycm9ycy5USU1FT1VULHt0aW1lb3V0OnRpbWVvdXR9KSl9LHRpbWVvdXQpO2lmKHRpbWVyLnVucmVmKXt0aW1lci51bnJlZigpfX19KX0pfWdldEJsb2NrTnVtYmVyKCl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtyZXR1cm4gdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKX0pfWdldEdhc1ByaWNlKCl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtjb25zdCByZXN1bHQ9eWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0R2FzUHJpY2VcIix7fSk7dHJ5e3JldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpfWNhdGNoKGVycm9yKXtyZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise21ldGhvZDpcImdldEdhc1ByaWNlXCIscmVzdWx0OnJlc3VsdCxlcnJvcjplcnJvcn0pfX0pfWdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSxibG9ja1RhZyl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtjb25zdCBwYXJhbXM9eWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe2FkZHJlc3M6dGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxibG9ja1RhZzp0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyl9KTtjb25zdCByZXN1bHQ9eWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmFsYW5jZVwiLHBhcmFtcyk7dHJ5e3JldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpfWNhdGNoKGVycm9yKXtyZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise21ldGhvZDpcImdldEJhbGFuY2VcIixwYXJhbXM6cGFyYW1zLHJlc3VsdDpyZXN1bHQsZXJyb3I6ZXJyb3J9KX19KX1nZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsYmxvY2tUYWcpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgcGFyYW1zPXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzOnRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksYmxvY2tUYWc6dGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpfSk7Y29uc3QgcmVzdWx0PXlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uQ291bnRcIixwYXJhbXMpO3RyeXtyZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KS50b051bWJlcigpfWNhdGNoKGVycm9yKXtyZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise21ldGhvZDpcImdldFRyYW5zYWN0aW9uQ291bnRcIixwYXJhbXM6cGFyYW1zLHJlc3VsdDpyZXN1bHQsZXJyb3I6ZXJyb3J9KX19KX1nZXRDb2RlKGFkZHJlc3NPck5hbWUsYmxvY2tUYWcpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgcGFyYW1zPXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzOnRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksYmxvY2tUYWc6dGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpfSk7Y29uc3QgcmVzdWx0PXlpZWxkIHRoaXMucGVyZm9ybShcImdldENvZGVcIixwYXJhbXMpO3RyeXtyZXR1cm4gaGV4bGlmeShyZXN1bHQpfWNhdGNoKGVycm9yKXtyZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise21ldGhvZDpcImdldENvZGVcIixwYXJhbXM6cGFyYW1zLHJlc3VsdDpyZXN1bHQsZXJyb3I6ZXJyb3J9KX19KX1nZXRTdG9yYWdlQXQoYWRkcmVzc09yTmFtZSxwb3NpdGlvbixibG9ja1RhZyl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtjb25zdCBwYXJhbXM9eWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe2FkZHJlc3M6dGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxibG9ja1RhZzp0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZykscG9zaXRpb246UHJvbWlzZS5yZXNvbHZlKHBvc2l0aW9uKS50aGVuKHA9PmhleFZhbHVlKHApKX0pO2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIixwYXJhbXMpO3RyeXtyZXR1cm4gaGV4bGlmeShyZXN1bHQpfWNhdGNoKGVycm9yKXtyZXR1cm4gbG9nZ2VyJHQudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1Ise21ldGhvZDpcImdldFN0b3JhZ2VBdFwiLHBhcmFtczpwYXJhbXMscmVzdWx0OnJlc3VsdCxlcnJvcjplcnJvcn0pfX0pfV93cmFwVHJhbnNhY3Rpb24odHgsaGFzaCl7aWYoaGFzaCE9bnVsbCYmaGV4RGF0YUxlbmd0aChoYXNoKSE9PTMyKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpfWNvbnN0IHJlc3VsdD10eDtpZihoYXNoIT1udWxsJiZ0eC5oYXNoIT09aGFzaCl7bG9nZ2VyJHQudGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLHtleHBlY3RlZEhhc2g6dHguaGFzaCxyZXR1cm5lZEhhc2g6aGFzaH0pfXJlc3VsdC53YWl0PShjb25maXJtYXRpb25zPT5fX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYoY29uZmlybWF0aW9ucyE9PTApe3RoaXMuX2VtaXR0ZWRbXCJ0OlwiK3R4Lmhhc2hdPVwicGVuZGluZ1wifWNvbnN0IHJlY2VpcHQ9eWllbGQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24odHguaGFzaCxjb25maXJtYXRpb25zKTtpZihyZWNlaXB0PT1udWxsJiZjb25maXJtYXRpb25zPT09MCl7cmV0dXJuIG51bGx9dGhpcy5fZW1pdHRlZFtcInQ6XCIrdHguaGFzaF09cmVjZWlwdC5ibG9ja051bWJlcjtpZihyZWNlaXB0LnN0YXR1cz09PTApe2xvZ2dlciR0LnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIixMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLHt0cmFuc2FjdGlvbkhhc2g6dHguaGFzaCx0cmFuc2FjdGlvbjp0eCxyZWNlaXB0OnJlY2VpcHR9KX1yZXR1cm4gcmVjZWlwdH0pKTtyZXR1cm4gcmVzdWx0fXNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbil7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtjb25zdCBoZXhUeD15aWVsZCBQcm9taXNlLnJlc29sdmUoc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4odD0+aGV4bGlmeSh0KSk7Y29uc3QgdHg9dGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO3RyeXtjb25zdCBoYXNoPXlpZWxkIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLHtzaWduZWRUcmFuc2FjdGlvbjpoZXhUeH0pO3JldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgsaGFzaCl9Y2F0Y2goZXJyb3Ipe2Vycm9yLnRyYW5zYWN0aW9uPXR4O2Vycm9yLnRyYW5zYWN0aW9uSGFzaD10eC5oYXNoO3Rocm93IGVycm9yfX0pfV9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgdmFsdWVzPXlpZWxkIHRyYW5zYWN0aW9uO2NvbnN0IHR4PXt9O1tcImZyb21cIixcInRvXCJdLmZvckVhY2goa2V5PT57aWYodmFsdWVzW2tleV09PW51bGwpe3JldHVybn10eFtrZXldPVByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbih2PT52P3RoaXMuX2dldEFkZHJlc3Modik6bnVsbCl9KTtbXCJnYXNMaW1pdFwiLFwiZ2FzUHJpY2VcIixcInZhbHVlXCJdLmZvckVhY2goa2V5PT57aWYodmFsdWVzW2tleV09PW51bGwpe3JldHVybn10eFtrZXldPVByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbih2PT52P0JpZ051bWJlci5mcm9tKHYpOm51bGwpfSk7W1widHlwZVwiXS5mb3JFYWNoKGtleT0+e2lmKHZhbHVlc1trZXldPT1udWxsKXtyZXR1cm59dHhba2V5XT1Qcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4odj0+diE9bnVsbD92Om51bGwpfSk7aWYodmFsdWVzLmFjY2Vzc0xpc3Qpe3R4LmFjY2Vzc0xpc3Q9dGhpcy5mb3JtYXR0ZXIuYWNjZXNzTGlzdCh2YWx1ZXMuYWNjZXNzTGlzdCl9W1wiZGF0YVwiXS5mb3JFYWNoKGtleT0+e2lmKHZhbHVlc1trZXldPT1udWxsKXtyZXR1cm59dHhba2V5XT1Qcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4odj0+dj9oZXhsaWZ5KHYpOm51bGwpfSk7cmV0dXJuIHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVxdWVzdCh5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0eCkpfSl9X2dldEZpbHRlcihmaWx0ZXIpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7ZmlsdGVyPXlpZWxkIGZpbHRlcjtjb25zdCByZXN1bHQ9e307aWYoZmlsdGVyLmFkZHJlc3MhPW51bGwpe3Jlc3VsdC5hZGRyZXNzPXRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpfVtcImJsb2NrSGFzaFwiLFwidG9waWNzXCJdLmZvckVhY2goa2V5PT57aWYoZmlsdGVyW2tleV09PW51bGwpe3JldHVybn1yZXN1bHRba2V5XT1maWx0ZXJba2V5XX0pO1tcImZyb21CbG9ja1wiLFwidG9CbG9ja1wiXS5mb3JFYWNoKGtleT0+e2lmKGZpbHRlcltrZXldPT1udWxsKXtyZXR1cm59cmVzdWx0W2tleV09dGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyW2tleV0pfSk7cmV0dXJuIHRoaXMuZm9ybWF0dGVyLmZpbHRlcih5aWVsZCByZXNvbHZlUHJvcGVydGllcyhyZXN1bHQpKX0pfWNhbGwodHJhbnNhY3Rpb24sYmxvY2tUYWcpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgcGFyYW1zPXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHt0cmFuc2FjdGlvbjp0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pLGJsb2NrVGFnOnRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKX0pO2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIscGFyYW1zKTt0cnl7cmV0dXJuIGhleGxpZnkocmVzdWx0KX1jYXRjaChlcnJvcil7cmV0dXJuIGxvZ2dlciR0LnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLHttZXRob2Q6XCJjYWxsXCIscGFyYW1zOnBhcmFtcyxyZXN1bHQ6cmVzdWx0LGVycm9yOmVycm9yfSl9fSl9ZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7Y29uc3QgcGFyYW1zPXlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHt0cmFuc2FjdGlvbjp0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pfSk7Y29uc3QgcmVzdWx0PXlpZWxkIHRoaXMucGVyZm9ybShcImVzdGltYXRlR2FzXCIscGFyYW1zKTt0cnl7cmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCl9Y2F0Y2goZXJyb3Ipe3JldHVybiBsb2dnZXIkdC50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIixMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUix7bWV0aG9kOlwiZXN0aW1hdGVHYXNcIixwYXJhbXM6cGFyYW1zLHJlc3VsdDpyZXN1bHQsZXJyb3I6ZXJyb3J9KX19KX1fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IGFkZHJlc3M9eWllbGQgdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKTtpZihhZGRyZXNzPT1udWxsKXtsb2dnZXIkdC50aHJvd0Vycm9yKFwiRU5TIG5hbWUgbm90IGNvbmZpZ3VyZWRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOmByZXNvbHZlTmFtZSgke0pTT04uc3RyaW5naWZ5KGFkZHJlc3NPck5hbWUpfSlgfSl9cmV0dXJuIGFkZHJlc3N9KX1fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZyxpbmNsdWRlVHJhbnNhY3Rpb25zKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO2Jsb2NrSGFzaE9yQmxvY2tUYWc9eWllbGQgYmxvY2tIYXNoT3JCbG9ja1RhZztsZXQgYmxvY2tOdW1iZXI9LTEyODtjb25zdCBwYXJhbXM9e2luY2x1ZGVUcmFuc2FjdGlvbnM6ISFpbmNsdWRlVHJhbnNhY3Rpb25zfTtpZihpc0hleFN0cmluZyhibG9ja0hhc2hPckJsb2NrVGFnLDMyKSl7cGFyYW1zLmJsb2NrSGFzaD1ibG9ja0hhc2hPckJsb2NrVGFnfWVsc2V7dHJ5e3BhcmFtcy5ibG9ja1RhZz10aGlzLmZvcm1hdHRlci5ibG9ja1RhZyh5aWVsZCB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja0hhc2hPckJsb2NrVGFnKSk7aWYoaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSl7YmxvY2tOdW1iZXI9cGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwxNil9fWNhdGNoKGVycm9yKXtsb2dnZXIkdC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrIGhhc2ggb3IgYmxvY2sgdGFnXCIsXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsYmxvY2tIYXNoT3JCbG9ja1RhZyl9fXJldHVybiBwb2xsKCgpPT5fX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgYmxvY2s9eWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tcIixwYXJhbXMpO2lmKGJsb2NrPT1udWxsKXtpZihwYXJhbXMuYmxvY2tIYXNoIT1udWxsKXtpZih0aGlzLl9lbWl0dGVkW1wiYjpcIitwYXJhbXMuYmxvY2tIYXNoXT09bnVsbCl7cmV0dXJuIG51bGx9fWlmKHBhcmFtcy5ibG9ja1RhZyE9bnVsbCl7aWYoYmxvY2tOdW1iZXI+dGhpcy5fZW1pdHRlZC5ibG9jayl7cmV0dXJuIG51bGx9fXJldHVybiB1bmRlZmluZWR9aWYoaW5jbHVkZVRyYW5zYWN0aW9ucyl7bGV0IGJsb2NrTnVtYmVyPW51bGw7Zm9yKGxldCBpPTA7aTxibG9jay50cmFuc2FjdGlvbnMubGVuZ3RoO2krKyl7Y29uc3QgdHg9YmxvY2sudHJhbnNhY3Rpb25zW2ldO2lmKHR4LmJsb2NrTnVtYmVyPT1udWxsKXt0eC5jb25maXJtYXRpb25zPTB9ZWxzZSBpZih0eC5jb25maXJtYXRpb25zPT1udWxsKXtpZihibG9ja051bWJlcj09bnVsbCl7YmxvY2tOdW1iZXI9eWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDArMip0aGlzLnBvbGxpbmdJbnRlcnZhbCl9bGV0IGNvbmZpcm1hdGlvbnM9YmxvY2tOdW1iZXItdHguYmxvY2tOdW1iZXIrMTtpZihjb25maXJtYXRpb25zPD0wKXtjb25maXJtYXRpb25zPTF9dHguY29uZmlybWF0aW9ucz1jb25maXJtYXRpb25zfX1yZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrKX1yZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2soYmxvY2spfSkse29uY2VQb2xsOnRoaXN9KX0pfWdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpe3JldHVybiB0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLGZhbHNlKX1nZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2tIYXNoT3JCbG9ja1RhZyl7cmV0dXJuIHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsdHJ1ZSl9Z2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO3RyYW5zYWN0aW9uSGFzaD15aWVsZCB0cmFuc2FjdGlvbkhhc2g7Y29uc3QgcGFyYW1zPXt0cmFuc2FjdGlvbkhhc2g6dGhpcy5mb3JtYXR0ZXIuaGFzaCh0cmFuc2FjdGlvbkhhc2gsdHJ1ZSl9O3JldHVybiBwb2xsKCgpPT5fX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgcmVzdWx0PXlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uXCIscGFyYW1zKTtpZihyZXN1bHQ9PW51bGwpe2lmKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiK3RyYW5zYWN0aW9uSGFzaF09PW51bGwpe3JldHVybiBudWxsfXJldHVybiB1bmRlZmluZWR9Y29uc3QgdHg9dGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO2lmKHR4LmJsb2NrTnVtYmVyPT1udWxsKXt0eC5jb25maXJtYXRpb25zPTB9ZWxzZSBpZih0eC5jb25maXJtYXRpb25zPT1udWxsKXtjb25zdCBibG9ja051bWJlcj15aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCsyKnRoaXMucG9sbGluZ0ludGVydmFsKTtsZXQgY29uZmlybWF0aW9ucz1ibG9ja051bWJlci10eC5ibG9ja051bWJlcisxO2lmKGNvbmZpcm1hdGlvbnM8PTApe2NvbmZpcm1hdGlvbnM9MX10eC5jb25maXJtYXRpb25zPWNvbmZpcm1hdGlvbnN9cmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCl9KSx7b25jZVBvbGw6dGhpc30pfSl9Z2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTt0cmFuc2FjdGlvbkhhc2g9eWllbGQgdHJhbnNhY3Rpb25IYXNoO2NvbnN0IHBhcmFtcz17dHJhbnNhY3Rpb25IYXNoOnRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLHRydWUpfTtyZXR1cm4gcG9sbCgoKT0+X19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHJlc3VsdD15aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIixwYXJhbXMpO2lmKHJlc3VsdD09bnVsbCl7aWYodGhpcy5fZW1pdHRlZFtcInQ6XCIrdHJhbnNhY3Rpb25IYXNoXT09bnVsbCl7cmV0dXJuIG51bGx9cmV0dXJuIHVuZGVmaW5lZH1pZihyZXN1bHQuYmxvY2tIYXNoPT1udWxsKXtyZXR1cm4gdW5kZWZpbmVkfWNvbnN0IHJlY2VpcHQ9dGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO2lmKHJlY2VpcHQuYmxvY2tOdW1iZXI9PW51bGwpe3JlY2VpcHQuY29uZmlybWF0aW9ucz0wfWVsc2UgaWYocmVjZWlwdC5jb25maXJtYXRpb25zPT1udWxsKXtjb25zdCBibG9ja051bWJlcj15aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCsyKnRoaXMucG9sbGluZ0ludGVydmFsKTtsZXQgY29uZmlybWF0aW9ucz1ibG9ja051bWJlci1yZWNlaXB0LmJsb2NrTnVtYmVyKzE7aWYoY29uZmlybWF0aW9uczw9MCl7Y29uZmlybWF0aW9ucz0xfXJlY2VpcHQuY29uZmlybWF0aW9ucz1jb25maXJtYXRpb25zfXJldHVybiByZWNlaXB0fSkse29uY2VQb2xsOnRoaXN9KX0pfWdldExvZ3MoZmlsdGVyKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuZ2V0TmV0d29yaygpO2NvbnN0IHBhcmFtcz15aWVsZCByZXNvbHZlUHJvcGVydGllcyh7ZmlsdGVyOnRoaXMuX2dldEZpbHRlcihmaWx0ZXIpfSk7Y29uc3QgbG9ncz15aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRMb2dzXCIscGFyYW1zKTtsb2dzLmZvckVhY2gobG9nPT57aWYobG9nLnJlbW92ZWQ9PW51bGwpe2xvZy5yZW1vdmVkPWZhbHNlfX0pO3JldHVybiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpfSl9Z2V0RXRoZXJQcmljZSgpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7cmV0dXJuIHRoaXMucGVyZm9ybShcImdldEV0aGVyUHJpY2VcIix7fSl9KX1fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7YmxvY2tUYWc9eWllbGQgYmxvY2tUYWc7aWYodHlwZW9mIGJsb2NrVGFnPT09XCJudW1iZXJcIiYmYmxvY2tUYWc8MCl7aWYoYmxvY2tUYWclMSl7bG9nZ2VyJHQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCbG9ja1RhZ1wiLFwiYmxvY2tUYWdcIixibG9ja1RhZyl9bGV0IGJsb2NrTnVtYmVyPXlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwKzIqdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO2Jsb2NrTnVtYmVyKz1ibG9ja1RhZztpZihibG9ja051bWJlcjwwKXtibG9ja051bWJlcj0wfXJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja051bWJlcil9cmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrVGFnKX0pfWdldFJlc29sdmVyKG5hbWUpe3JldHVybiBfX2F3YWl0ZXIkOCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgYWRkcmVzcz15aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihuYW1lKTtpZihhZGRyZXNzPT1udWxsKXtyZXR1cm4gbnVsbH1yZXR1cm4gbmV3IFJlc29sdmVyKHRoaXMsYWRkcmVzcyxuYW1lKX0pfV9nZXRSZXNvbHZlcihuYW1lKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IG5ldHdvcms9eWllbGQgdGhpcy5nZXROZXR3b3JrKCk7aWYoIW5ldHdvcmsuZW5zQWRkcmVzcyl7bG9nZ2VyJHQudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiRU5TXCIsbmV0d29yazpuZXR3b3JrLm5hbWV9KX1jb25zdCB0cmFuc2FjdGlvbj17dG86bmV0d29yay5lbnNBZGRyZXNzLGRhdGE6XCIweDAxNzhiOGJmXCIrbmFtZWhhc2gobmFtZSkuc3Vic3RyaW5nKDIpfTtyZXR1cm4gdGhpcy5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MoeWllbGQgdGhpcy5jYWxsKHRyYW5zYWN0aW9uKSl9KX1yZXNvbHZlTmFtZShuYW1lKXtyZXR1cm4gX19hd2FpdGVyJDgodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe25hbWU9eWllbGQgbmFtZTt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWUpKX1jYXRjaChlcnJvcil7aWYoaXNIZXhTdHJpbmcobmFtZSkpe3Rocm93IGVycm9yfX1pZih0eXBlb2YgbmFtZSE9PVwic3RyaW5nXCIpe2xvZ2dlciR0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWVcIixcIm5hbWVcIixuYW1lKX1jb25zdCByZXNvbHZlcj15aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO2lmKCFyZXNvbHZlcil7cmV0dXJuIG51bGx9cmV0dXJuIHlpZWxkIHJlc29sdmVyLmdldEFkZHJlc3MoKX0pfWxvb2t1cEFkZHJlc3MoYWRkcmVzcyl7cmV0dXJuIF9fYXdhaXRlciQ4KHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXthZGRyZXNzPXlpZWxkIGFkZHJlc3M7YWRkcmVzcz10aGlzLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpO2NvbnN0IHJldmVyc2VOYW1lPWFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkrXCIuYWRkci5yZXZlcnNlXCI7Y29uc3QgcmVzb2x2ZXJBZGRyZXNzPXlpZWxkIHRoaXMuX2dldFJlc29sdmVyKHJldmVyc2VOYW1lKTtpZighcmVzb2x2ZXJBZGRyZXNzKXtyZXR1cm4gbnVsbH1sZXQgYnl0ZXM9YXJyYXlpZnkoeWllbGQgdGhpcy5jYWxsKHt0bzpyZXNvbHZlckFkZHJlc3MsZGF0YTpcIjB4NjkxZjM0MzFcIituYW1laGFzaChyZXZlcnNlTmFtZSkuc3Vic3RyaW5nKDIpfSkpO2lmKGJ5dGVzLmxlbmd0aDwzMnx8IUJpZ051bWJlci5mcm9tKGJ5dGVzLnNsaWNlKDAsMzIpKS5lcSgzMikpe3JldHVybiBudWxsfWJ5dGVzPWJ5dGVzLnNsaWNlKDMyKTtpZihieXRlcy5sZW5ndGg8MzIpe3JldHVybiBudWxsfWNvbnN0IGxlbmd0aD1CaWdOdW1iZXIuZnJvbShieXRlcy5zbGljZSgwLDMyKSkudG9OdW1iZXIoKTtieXRlcz1ieXRlcy5zbGljZSgzMik7aWYobGVuZ3RoPmJ5dGVzLmxlbmd0aCl7cmV0dXJuIG51bGx9Y29uc3QgbmFtZT10b1V0ZjhTdHJpbmcoYnl0ZXMuc2xpY2UoMCxsZW5ndGgpKTtjb25zdCBhZGRyPXlpZWxkIHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7aWYoYWRkciE9YWRkcmVzcyl7cmV0dXJuIG51bGx9cmV0dXJuIG5hbWV9KX1wZXJmb3JtKG1ldGhvZCxwYXJhbXMpe3JldHVybiBsb2dnZXIkdC50aHJvd0Vycm9yKG1ldGhvZCtcIiBub3QgaW1wbGVtZW50ZWRcIixMb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCx7b3BlcmF0aW9uOm1ldGhvZH0pfV9zdGFydEV2ZW50KGV2ZW50KXt0aGlzLnBvbGxpbmc9dGhpcy5fZXZlbnRzLmZpbHRlcihlPT5lLnBvbGxhYmxlKCkpLmxlbmd0aD4wfV9zdG9wRXZlbnQoZXZlbnQpe3RoaXMucG9sbGluZz10aGlzLl9ldmVudHMuZmlsdGVyKGU9PmUucG9sbGFibGUoKSkubGVuZ3RoPjB9X2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLGxpc3RlbmVyLG9uY2Upe2NvbnN0IGV2ZW50PW5ldyBFdmVudChnZXRFdmVudFRhZyQxKGV2ZW50TmFtZSksbGlzdGVuZXIsb25jZSk7dGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO3RoaXMuX3N0YXJ0RXZlbnQoZXZlbnQpO3JldHVybiB0aGlzfW9uKGV2ZW50TmFtZSxsaXN0ZW5lcil7cmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLGxpc3RlbmVyLGZhbHNlKX1vbmNlKGV2ZW50TmFtZSxsaXN0ZW5lcil7cmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLGxpc3RlbmVyLHRydWUpfWVtaXQoZXZlbnROYW1lLC4uLmFyZ3Mpe2xldCByZXN1bHQ9ZmFsc2U7bGV0IHN0b3BwZWQ9W107bGV0IGV2ZW50VGFnPWdldEV2ZW50VGFnJDEoZXZlbnROYW1lKTt0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzLmZpbHRlcihldmVudD0+e2lmKGV2ZW50LnRhZyE9PWV2ZW50VGFnKXtyZXR1cm4gdHJ1ZX1zZXRUaW1lb3V0KCgpPT57ZXZlbnQubGlzdGVuZXIuYXBwbHkodGhpcyxhcmdzKX0sMCk7cmVzdWx0PXRydWU7aWYoZXZlbnQub25jZSl7c3RvcHBlZC5wdXNoKGV2ZW50KTtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9KTtzdG9wcGVkLmZvckVhY2goZXZlbnQ9Pnt0aGlzLl9zdG9wRXZlbnQoZXZlbnQpfSk7cmV0dXJuIHJlc3VsdH1saXN0ZW5lckNvdW50KGV2ZW50TmFtZSl7aWYoIWV2ZW50TmFtZSl7cmV0dXJuIHRoaXMuX2V2ZW50cy5sZW5ndGh9bGV0IGV2ZW50VGFnPWdldEV2ZW50VGFnJDEoZXZlbnROYW1lKTtyZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudD0+e3JldHVybiBldmVudC50YWc9PT1ldmVudFRhZ30pLmxlbmd0aH1saXN0ZW5lcnMoZXZlbnROYW1lKXtpZihldmVudE5hbWU9PW51bGwpe3JldHVybiB0aGlzLl9ldmVudHMubWFwKGV2ZW50PT5ldmVudC5saXN0ZW5lcil9bGV0IGV2ZW50VGFnPWdldEV2ZW50VGFnJDEoZXZlbnROYW1lKTtyZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudD0+ZXZlbnQudGFnPT09ZXZlbnRUYWcpLm1hcChldmVudD0+ZXZlbnQubGlzdGVuZXIpfW9mZihldmVudE5hbWUsbGlzdGVuZXIpe2lmKGxpc3RlbmVyPT1udWxsKXtyZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKX1jb25zdCBzdG9wcGVkPVtdO2xldCBmb3VuZD1mYWxzZTtsZXQgZXZlbnRUYWc9Z2V0RXZlbnRUYWckMShldmVudE5hbWUpO3RoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50PT57aWYoZXZlbnQudGFnIT09ZXZlbnRUYWd8fGV2ZW50Lmxpc3RlbmVyIT1saXN0ZW5lcil7cmV0dXJuIHRydWV9aWYoZm91bmQpe3JldHVybiB0cnVlfWZvdW5kPXRydWU7c3RvcHBlZC5wdXNoKGV2ZW50KTtyZXR1cm4gZmFsc2V9KTtzdG9wcGVkLmZvckVhY2goZXZlbnQ9Pnt0aGlzLl9zdG9wRXZlbnQoZXZlbnQpfSk7cmV0dXJuIHRoaXN9cmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSl7bGV0IHN0b3BwZWQ9W107aWYoZXZlbnROYW1lPT1udWxsKXtzdG9wcGVkPXRoaXMuX2V2ZW50czt0aGlzLl9ldmVudHM9W119ZWxzZXtjb25zdCBldmVudFRhZz1nZXRFdmVudFRhZyQxKGV2ZW50TmFtZSk7dGhpcy5fZXZlbnRzPXRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQ9PntpZihldmVudC50YWchPT1ldmVudFRhZyl7cmV0dXJuIHRydWV9c3RvcHBlZC5wdXNoKGV2ZW50KTtyZXR1cm4gZmFsc2V9KX1zdG9wcGVkLmZvckVhY2goZXZlbnQ9Pnt0aGlzLl9zdG9wRXZlbnQoZXZlbnQpfSk7cmV0dXJuIHRoaXN9fVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkOT13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJHU9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2NvbnN0IGVycm9yR2FzPVtcImNhbGxcIixcImVzdGltYXRlR2FzXCJdO2Z1bmN0aW9uIGNoZWNrRXJyb3IobWV0aG9kLGVycm9yLHBhcmFtcyl7aWYobWV0aG9kPT09XCJjYWxsXCImJmVycm9yLmNvZGU9PT1Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUil7Y29uc3QgZT1lcnJvci5lcnJvcjtpZihlJiZlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSYmaXNIZXhTdHJpbmcoZS5kYXRhKSl7cmV0dXJuIGUuZGF0YX19bGV0IG1lc3NhZ2U9ZXJyb3IubWVzc2FnZTtpZihlcnJvci5jb2RlPT09TG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1ImJmVycm9yLmVycm9yJiZ0eXBlb2YgZXJyb3IuZXJyb3IubWVzc2FnZT09PVwic3RyaW5nXCIpe21lc3NhZ2U9ZXJyb3IuZXJyb3IubWVzc2FnZX1lbHNlIGlmKHR5cGVvZiBlcnJvci5ib2R5PT09XCJzdHJpbmdcIil7bWVzc2FnZT1lcnJvci5ib2R5fWVsc2UgaWYodHlwZW9mIGVycm9yLnJlc3BvbnNlVGV4dD09PVwic3RyaW5nXCIpe21lc3NhZ2U9ZXJyb3IucmVzcG9uc2VUZXh0fW1lc3NhZ2U9KG1lc3NhZ2V8fFwiXCIpLnRvTG93ZXJDYXNlKCk7Y29uc3QgdHJhbnNhY3Rpb249cGFyYW1zLnRyYW5zYWN0aW9ufHxwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb247aWYobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzLykpe2xvZ2dlciR1LnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMse2Vycm9yOmVycm9yLG1ldGhvZDptZXRob2QsdHJhbnNhY3Rpb246dHJhbnNhY3Rpb259KX1pZihtZXNzYWdlLm1hdGNoKC9ub25jZSB0b28gbG93Lykpe2xvZ2dlciR1LnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIixMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQse2Vycm9yOmVycm9yLG1ldGhvZDptZXRob2QsdHJhbnNhY3Rpb246dHJhbnNhY3Rpb259KX1pZihtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZC8pKXtsb2dnZXIkdS50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIixMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELHtlcnJvcjplcnJvcixtZXRob2Q6bWV0aG9kLHRyYW5zYWN0aW9uOnRyYW5zYWN0aW9ufSl9aWYobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkLykpe2xvZ2dlciR1LnRocm93RXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7ZXJyb3I6ZXJyb3IsbWV0aG9kOm1ldGhvZCx0cmFuc2FjdGlvbjp0cmFuc2FjdGlvbn0pfWlmKGVycm9yR2FzLmluZGV4T2YobWV0aG9kKT49MCYmbWVzc2FnZS5tYXRjaCgvZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlfGFsd2F5cyBmYWlsaW5nIHRyYW5zYWN0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKXtsb2dnZXIkdS50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQse2Vycm9yOmVycm9yLG1ldGhvZDptZXRob2QsdHJhbnNhY3Rpb246dHJhbnNhY3Rpb259KX10aHJvdyBlcnJvcn1mdW5jdGlvbiB0aW1lcih0aW1lb3V0KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSl7c2V0VGltZW91dChyZXNvbHZlLHRpbWVvdXQpfSl9ZnVuY3Rpb24gZ2V0UmVzdWx0KHBheWxvYWQpe2lmKHBheWxvYWQuZXJyb3Ipe2NvbnN0IGVycm9yPW5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO2Vycm9yLmNvZGU9cGF5bG9hZC5lcnJvci5jb2RlO2Vycm9yLmRhdGE9cGF5bG9hZC5lcnJvci5kYXRhO3Rocm93IGVycm9yfXJldHVybiBwYXlsb2FkLnJlc3VsdH1mdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpe2lmKHZhbHVlKXtyZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKX1yZXR1cm4gdmFsdWV9Y29uc3QgX2NvbnN0cnVjdG9yR3VhcmQkND17fTtjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgU2lnbmVye2NvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQscHJvdmlkZXIsYWRkcmVzc09ySW5kZXgpe2xvZ2dlciR1LmNoZWNrTmV3KG5ldy50YXJnZXQsSnNvblJwY1NpZ25lcik7c3VwZXIoKTtpZihjb25zdHJ1Y3Rvckd1YXJkIT09X2NvbnN0cnVjdG9yR3VhcmQkNCl7dGhyb3cgbmV3IEVycm9yKFwiZG8gbm90IGNhbGwgdGhlIEpzb25ScGNTaWduZXIgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBwcm92aWRlci5nZXRTaWduZXJcIil9ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb3ZpZGVyXCIscHJvdmlkZXIpO2lmKGFkZHJlc3NPckluZGV4PT1udWxsKXthZGRyZXNzT3JJbmRleD0wfWlmKHR5cGVvZiBhZGRyZXNzT3JJbmRleD09PVwic3RyaW5nXCIpe2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfYWRkcmVzc1wiLHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzc09ySW5kZXgpKTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2luZGV4XCIsbnVsbCl9ZWxzZSBpZih0eXBlb2YgYWRkcmVzc09ySW5kZXg9PT1cIm51bWJlclwiKXtkZWZpbmVSZWFkT25seSh0aGlzLFwiX2luZGV4XCIsYWRkcmVzc09ySW5kZXgpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJfYWRkcmVzc1wiLG51bGwpfWVsc2V7bG9nZ2VyJHUudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsXCJhZGRyZXNzT3JJbmRleFwiLGFkZHJlc3NPckluZGV4KX19Y29ubmVjdChwcm92aWRlcil7cmV0dXJuIGxvZ2dlciR1LnRocm93RXJyb3IoXCJjYW5ub3QgYWx0ZXIgSlNPTi1SUEMgU2lnbmVyIGNvbm5lY3Rpb25cIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiY29ubmVjdFwifSl9Y29ubmVjdFVuY2hlY2tlZCgpe3JldHVybiBuZXcgVW5jaGVja2VkSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCQ0LHRoaXMucHJvdmlkZXIsdGhpcy5fYWRkcmVzc3x8dGhpcy5faW5kZXgpfWdldEFkZHJlc3MoKXtpZih0aGlzLl9hZGRyZXNzKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2FkZHJlc3MpfXJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfYWNjb3VudHNcIixbXSkudGhlbihhY2NvdW50cz0+e2lmKGFjY291bnRzLmxlbmd0aDw9dGhpcy5faW5kZXgpe2xvZ2dlciR1LnRocm93RXJyb3IoXCJ1bmtub3duIGFjY291bnQgI1wiK3RoaXMuX2luZGV4LExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXRBZGRyZXNzXCJ9KX1yZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhY2NvdW50c1t0aGlzLl9pbmRleF0pfSl9c2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKXt0cmFuc2FjdGlvbj1zaGFsbG93Q29weSh0cmFuc2FjdGlvbik7Y29uc3QgZnJvbUFkZHJlc3M9dGhpcy5nZXRBZGRyZXNzKCkudGhlbihhZGRyZXNzPT57aWYoYWRkcmVzcyl7YWRkcmVzcz1hZGRyZXNzLnRvTG93ZXJDYXNlKCl9cmV0dXJuIGFkZHJlc3N9KTtpZih0cmFuc2FjdGlvbi5nYXNMaW1pdD09bnVsbCl7Y29uc3QgZXN0aW1hdGU9c2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO2VzdGltYXRlLmZyb209ZnJvbUFkZHJlc3M7dHJhbnNhY3Rpb24uZ2FzTGltaXQ9dGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyhlc3RpbWF0ZSl9cmV0dXJuIHJlc29sdmVQcm9wZXJ0aWVzKHt0eDpyZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbiksc2VuZGVyOmZyb21BZGRyZXNzfSkudGhlbigoe3R4OnR4LHNlbmRlcjpzZW5kZXJ9KT0+e2lmKHR4LmZyb20hPW51bGwpe2lmKHR4LmZyb20udG9Mb3dlckNhc2UoKSE9PXNlbmRlcil7bG9nZ2VyJHUudGhyb3dBcmd1bWVudEVycm9yKFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsXCJ0cmFuc2FjdGlvblwiLHRyYW5zYWN0aW9uKX19ZWxzZXt0eC5mcm9tPXNlbmRlcn1jb25zdCBoZXhUeD10aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCx7ZnJvbTp0cnVlfSk7cmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIixbaGV4VHhdKS50aGVuKGhhc2g9PntyZXR1cm4gaGFzaH0sZXJyb3I9PntyZXR1cm4gY2hlY2tFcnJvcihcInNlbmRUcmFuc2FjdGlvblwiLGVycm9yLGhleFR4KX0pfSl9c2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKXtyZXR1cm4gbG9nZ2VyJHUudGhyb3dFcnJvcihcInNpZ25pbmcgdHJhbnNhY3Rpb25zIGlzIHVuc3VwcG9ydGVkXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInNpZ25UcmFuc2FjdGlvblwifSl9c2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKXtyZXR1cm4gdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oaGFzaD0+e3JldHVybiBwb2xsKCgpPT57cmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbih0eD0+e2lmKHR4PT09bnVsbCl7cmV0dXJuIHVuZGVmaW5lZH1yZXR1cm4gdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LGhhc2gpfSl9LHtvbmNlQmxvY2s6dGhpcy5wcm92aWRlcn0pLmNhdGNoKGVycm9yPT57ZXJyb3IudHJhbnNhY3Rpb25IYXNoPWhhc2g7dGhyb3cgZXJyb3J9KX0pfXNpZ25NZXNzYWdlKG1lc3NhZ2Upe3JldHVybiBfX2F3YWl0ZXIkOSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgZGF0YT10eXBlb2YgbWVzc2FnZT09PVwic3RyaW5nXCI/dG9VdGY4Qnl0ZXMobWVzc2FnZSk6bWVzc2FnZTtjb25zdCBhZGRyZXNzPXlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO3JldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblwiLFthZGRyZXNzLnRvTG93ZXJDYXNlKCksaGV4bGlmeShkYXRhKV0pfSl9X3NpZ25UeXBlZERhdGEoZG9tYWluLHR5cGVzLHZhbHVlKXtyZXR1cm4gX19hd2FpdGVyJDkodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHBvcHVsYXRlZD15aWVsZCBUeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sdHlwZXMsdmFsdWUsbmFtZT0+e3JldHVybiB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpfSk7Y29uc3QgYWRkcmVzcz15aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtyZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIixbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLHR5cGVzLHBvcHVsYXRlZC52YWx1ZSkpXSl9KX11bmxvY2socGFzc3dvcmQpe3JldHVybiBfX2F3YWl0ZXIkOSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7Y29uc3QgcHJvdmlkZXI9dGhpcy5wcm92aWRlcjtjb25zdCBhZGRyZXNzPXlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO3JldHVybiBwcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLFthZGRyZXNzLnRvTG93ZXJDYXNlKCkscGFzc3dvcmQsbnVsbF0pfSl9fWNsYXNzIFVuY2hlY2tlZEpzb25ScGNTaWduZXIgZXh0ZW5kcyBKc29uUnBjU2lnbmVye3NlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbil7cmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKGhhc2g9PntyZXR1cm57aGFzaDpoYXNoLG5vbmNlOm51bGwsZ2FzTGltaXQ6bnVsbCxnYXNQcmljZTpudWxsLGRhdGE6bnVsbCx2YWx1ZTpudWxsLGNoYWluSWQ6bnVsbCxjb25maXJtYXRpb25zOjAsZnJvbTpudWxsLHdhaXQ6Y29uZmlybWF0aW9ucz0+e3JldHVybiB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbihoYXNoLGNvbmZpcm1hdGlvbnMpfX19KX19Y29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyQzPXtjaGFpbklkOnRydWUsZGF0YTp0cnVlLGdhc0xpbWl0OnRydWUsZ2FzUHJpY2U6dHJ1ZSxub25jZTp0cnVlLHRvOnRydWUsdmFsdWU6dHJ1ZSx0eXBlOnRydWUsYWNjZXNzTGlzdDp0cnVlfTtjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXJ7Y29uc3RydWN0b3IodXJsLG5ldHdvcmspe2xvZ2dlciR1LmNoZWNrTmV3KG5ldy50YXJnZXQsSnNvblJwY1Byb3ZpZGVyKTtsZXQgbmV0d29ya09yUmVhZHk9bmV0d29yaztpZihuZXR3b3JrT3JSZWFkeT09bnVsbCl7bmV0d29ya09yUmVhZHk9bmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e3NldFRpbWVvdXQoKCk9Pnt0aGlzLmRldGVjdE5ldHdvcmsoKS50aGVuKG5ldHdvcms9PntyZXNvbHZlKG5ldHdvcmspfSxlcnJvcj0+e3JlamVjdChlcnJvcil9KX0sMCl9KX1zdXBlcihuZXR3b3JrT3JSZWFkeSk7aWYoIXVybCl7dXJsPWdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLFwiZGVmYXVsdFVybFwiKSgpfWlmKHR5cGVvZiB1cmw9PT1cInN0cmluZ1wiKXtkZWZpbmVSZWFkT25seSh0aGlzLFwiY29ubmVjdGlvblwiLE9iamVjdC5mcmVlemUoe3VybDp1cmx9KSl9ZWxzZXtkZWZpbmVSZWFkT25seSh0aGlzLFwiY29ubmVjdGlvblwiLE9iamVjdC5mcmVlemUoc2hhbGxvd0NvcHkodXJsKSkpfXRoaXMuX25leHRJZD00Mn1nZXQgX2NhY2hlKCl7aWYodGhpcy5fZXZlbnRMb29wQ2FjaGU9PW51bGwpe3RoaXMuX2V2ZW50TG9vcENhY2hlPXt9fXJldHVybiB0aGlzLl9ldmVudExvb3BDYWNoZX1zdGF0aWMgZGVmYXVsdFVybCgpe3JldHVyblwiaHR0cDovL2xvY2FsaG9zdDo4NTQ1XCJ9ZGV0ZWN0TmV0d29yaygpe2lmKCF0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0pe3RoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXT10aGlzLl91bmNhY2hlZERldGVjdE5ldHdvcmsoKTtzZXRUaW1lb3V0KCgpPT57dGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdPW51bGx9LDApfXJldHVybiB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl19X3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpe3JldHVybiBfX2F3YWl0ZXIkOSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7eWllbGQgdGltZXIoMCk7bGV0IGNoYWluSWQ9bnVsbDt0cnl7Y2hhaW5JZD15aWVsZCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLFtdKX1jYXRjaChlcnJvcil7dHJ5e2NoYWluSWQ9eWllbGQgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIixbXSl9Y2F0Y2goZXJyb3Ipe319aWYoY2hhaW5JZCE9bnVsbCl7Y29uc3QgZ2V0TmV0d29yaz1nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvcixcImdldE5ldHdvcmtcIik7dHJ5e3JldHVybiBnZXROZXR3b3JrKEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpfWNhdGNoKGVycm9yKXtyZXR1cm4gbG9nZ2VyJHUudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUix7Y2hhaW5JZDpjaGFpbklkLGV2ZW50OlwiaW52YWxpZE5ldHdvcmtcIixzZXJ2ZXJFcnJvcjplcnJvcn0pfX1yZXR1cm4gbG9nZ2VyJHUudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUix7ZXZlbnQ6XCJub05ldHdvcmtcIn0pfSl9Z2V0U2lnbmVyKGFkZHJlc3NPckluZGV4KXtyZXR1cm4gbmV3IEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQkNCx0aGlzLGFkZHJlc3NPckluZGV4KX1nZXRVbmNoZWNrZWRTaWduZXIoYWRkcmVzc09ySW5kZXgpe3JldHVybiB0aGlzLmdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkuY29ubmVjdFVuY2hlY2tlZCgpfWxpc3RBY2NvdW50cygpe3JldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIixbXSkudGhlbihhY2NvdW50cz0+e3JldHVybiBhY2NvdW50cy5tYXAoYT0+dGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhKSl9KX1zZW5kKG1ldGhvZCxwYXJhbXMpe2NvbnN0IHJlcXVlc3Q9e21ldGhvZDptZXRob2QscGFyYW1zOnBhcmFtcyxpZDp0aGlzLl9uZXh0SWQrKyxqc29ucnBjOlwiMi4wXCJ9O3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlcXVlc3RcIixyZXF1ZXN0OmRlZXBDb3B5KHJlcXVlc3QpLHByb3ZpZGVyOnRoaXN9KTtjb25zdCBjYWNoZT1bXCJldGhfY2hhaW5JZFwiLFwiZXRoX2Jsb2NrTnVtYmVyXCJdLmluZGV4T2YobWV0aG9kKT49MDtpZihjYWNoZSYmdGhpcy5fY2FjaGVbbWV0aG9kXSl7cmV0dXJuIHRoaXMuX2NhY2hlW21ldGhvZF19Y29uc3QgcmVzdWx0PWZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksZ2V0UmVzdWx0KS50aGVuKHJlc3VsdD0+e3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlc3BvbnNlXCIscmVxdWVzdDpyZXF1ZXN0LHJlc3BvbnNlOnJlc3VsdCxwcm92aWRlcjp0aGlzfSk7cmV0dXJuIHJlc3VsdH0sZXJyb3I9Pnt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXNwb25zZVwiLGVycm9yOmVycm9yLHJlcXVlc3Q6cmVxdWVzdCxwcm92aWRlcjp0aGlzfSk7dGhyb3cgZXJyb3J9KTtpZihjYWNoZSl7dGhpcy5fY2FjaGVbbWV0aG9kXT1yZXN1bHQ7c2V0VGltZW91dCgoKT0+e3RoaXMuX2NhY2hlW21ldGhvZF09bnVsbH0sMCl9cmV0dXJuIHJlc3VsdH1wcmVwYXJlUmVxdWVzdChtZXRob2QscGFyYW1zKXtzd2l0Y2gobWV0aG9kKXtjYXNlXCJnZXRCbG9ja051bWJlclwiOnJldHVybltcImV0aF9ibG9ja051bWJlclwiLFtdXTtjYXNlXCJnZXRHYXNQcmljZVwiOnJldHVybltcImV0aF9nYXNQcmljZVwiLFtdXTtjYXNlXCJnZXRCYWxhbmNlXCI6cmV0dXJuW1wiZXRoX2dldEJhbGFuY2VcIixbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSxwYXJhbXMuYmxvY2tUYWddXTtjYXNlXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6cmV0dXJuW1wiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSxwYXJhbXMuYmxvY2tUYWddXTtjYXNlXCJnZXRDb2RlXCI6cmV0dXJuW1wiZXRoX2dldENvZGVcIixbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSxwYXJhbXMuYmxvY2tUYWddXTtjYXNlXCJnZXRTdG9yYWdlQXRcIjpyZXR1cm5bXCJldGhfZ2V0U3RvcmFnZUF0XCIsW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcykscGFyYW1zLnBvc2l0aW9uLHBhcmFtcy5ibG9ja1RhZ11dO2Nhc2VcInNlbmRUcmFuc2FjdGlvblwiOnJldHVybltcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixbcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uXV07Y2FzZVwiZ2V0QmxvY2tcIjppZihwYXJhbXMuYmxvY2tUYWcpe3JldHVybltcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsW3BhcmFtcy5ibG9ja1RhZywhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV19ZWxzZSBpZihwYXJhbXMuYmxvY2tIYXNoKXtyZXR1cm5bXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixbcGFyYW1zLmJsb2NrSGFzaCwhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV19cmV0dXJuIG51bGw7Y2FzZVwiZ2V0VHJhbnNhY3Rpb25cIjpyZXR1cm5bXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixbcGFyYW1zLnRyYW5zYWN0aW9uSGFzaF1dO2Nhc2VcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOnJldHVybltcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixbcGFyYW1zLnRyYW5zYWN0aW9uSGFzaF1dO2Nhc2VcImNhbGxcIjp7Y29uc3QgaGV4bGlmeVRyYW5zYWN0aW9uPWdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLFwiaGV4bGlmeVRyYW5zYWN0aW9uXCIpO3JldHVybltcImV0aF9jYWxsXCIsW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24se2Zyb206dHJ1ZX0pLHBhcmFtcy5ibG9ja1RhZ11dfWNhc2VcImVzdGltYXRlR2FzXCI6e2NvbnN0IGhleGxpZnlUcmFuc2FjdGlvbj1nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvcixcImhleGxpZnlUcmFuc2FjdGlvblwiKTtyZXR1cm5bXCJldGhfZXN0aW1hdGVHYXNcIixbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbix7ZnJvbTp0cnVlfSldXX1jYXNlXCJnZXRMb2dzXCI6aWYocGFyYW1zLmZpbHRlciYmcGFyYW1zLmZpbHRlci5hZGRyZXNzIT1udWxsKXtwYXJhbXMuZmlsdGVyLmFkZHJlc3M9Z2V0TG93ZXJDYXNlKHBhcmFtcy5maWx0ZXIuYWRkcmVzcyl9cmV0dXJuW1wiZXRoX2dldExvZ3NcIixbcGFyYW1zLmZpbHRlcl1dO2RlZmF1bHQ6YnJlYWt9cmV0dXJuIG51bGx9cGVyZm9ybShtZXRob2QscGFyYW1zKXtyZXR1cm4gX19hd2FpdGVyJDkodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IGFyZ3M9dGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QscGFyYW1zKTtpZihhcmdzPT1udWxsKXtsb2dnZXIkdS50aHJvd0Vycm9yKG1ldGhvZCtcIiBub3QgaW1wbGVtZW50ZWRcIixMb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCx7b3BlcmF0aW9uOm1ldGhvZH0pfXRyeXtyZXR1cm4geWllbGQgdGhpcy5zZW5kKGFyZ3NbMF0sYXJnc1sxXSl9Y2F0Y2goZXJyb3Ipe3JldHVybiBjaGVja0Vycm9yKG1ldGhvZCxlcnJvcixwYXJhbXMpfX0pfV9zdGFydEV2ZW50KGV2ZW50KXtpZihldmVudC50YWc9PT1cInBlbmRpbmdcIil7dGhpcy5fc3RhcnRQZW5kaW5nKCl9c3VwZXIuX3N0YXJ0RXZlbnQoZXZlbnQpfV9zdGFydFBlbmRpbmcoKXtpZih0aGlzLl9wZW5kaW5nRmlsdGVyIT1udWxsKXtyZXR1cm59Y29uc3Qgc2VsZj10aGlzO2NvbnN0IHBlbmRpbmdGaWx0ZXI9dGhpcy5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLFtdKTt0aGlzLl9wZW5kaW5nRmlsdGVyPXBlbmRpbmdGaWx0ZXI7cGVuZGluZ0ZpbHRlci50aGVuKGZ1bmN0aW9uKGZpbHRlcklkKXtmdW5jdGlvbiBwb2xsKCl7c2VsZi5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIixbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uKGhhc2hlcyl7aWYoc2VsZi5fcGVuZGluZ0ZpbHRlciE9cGVuZGluZ0ZpbHRlcil7cmV0dXJuIG51bGx9bGV0IHNlcT1Qcm9taXNlLnJlc29sdmUoKTtoYXNoZXMuZm9yRWFjaChmdW5jdGlvbihoYXNoKXtzZWxmLl9lbWl0dGVkW1widDpcIitoYXNoLnRvTG93ZXJDYXNlKCldPVwicGVuZGluZ1wiO3NlcT1zZXEudGhlbihmdW5jdGlvbigpe3JldHVybiBzZWxmLmdldFRyYW5zYWN0aW9uKGhhc2gpLnRoZW4oZnVuY3Rpb24odHgpe3NlbGYuZW1pdChcInBlbmRpbmdcIix0eCk7cmV0dXJuIG51bGx9KX0pfSk7cmV0dXJuIHNlcS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHRpbWVyKDFlMyl9KX0pLnRoZW4oZnVuY3Rpb24oKXtpZihzZWxmLl9wZW5kaW5nRmlsdGVyIT1wZW5kaW5nRmlsdGVyKXtzZWxmLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsW2ZpbHRlcklkXSk7cmV0dXJufXNldFRpbWVvdXQoZnVuY3Rpb24oKXtwb2xsKCl9LDApO3JldHVybiBudWxsfSkuY2F0Y2goZXJyb3I9Pnt9KX1wb2xsKCk7cmV0dXJuIGZpbHRlcklkfSkuY2F0Y2goZXJyb3I9Pnt9KX1fc3RvcEV2ZW50KGV2ZW50KXtpZihldmVudC50YWc9PT1cInBlbmRpbmdcIiYmdGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKT09PTApe3RoaXMuX3BlbmRpbmdGaWx0ZXI9bnVsbH1zdXBlci5fc3RvcEV2ZW50KGV2ZW50KX1zdGF0aWMgaGV4bGlmeVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLGFsbG93RXh0cmEpe2NvbnN0IGFsbG93ZWQ9c2hhbGxvd0NvcHkoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyQzKTtpZihhbGxvd0V4dHJhKXtmb3IoY29uc3Qga2V5IGluIGFsbG93RXh0cmEpe2lmKGFsbG93RXh0cmFba2V5XSl7YWxsb3dlZFtrZXldPXRydWV9fX1jaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sYWxsb3dlZCk7Y29uc3QgcmVzdWx0PXt9O1tcImdhc0xpbWl0XCIsXCJnYXNQcmljZVwiLFwidHlwZVwiLFwibm9uY2VcIixcInZhbHVlXCJdLmZvckVhY2goZnVuY3Rpb24oa2V5KXtpZih0cmFuc2FjdGlvbltrZXldPT1udWxsKXtyZXR1cm59Y29uc3QgdmFsdWU9aGV4VmFsdWUodHJhbnNhY3Rpb25ba2V5XSk7aWYoa2V5PT09XCJnYXNMaW1pdFwiKXtrZXk9XCJnYXNcIn1yZXN1bHRba2V5XT12YWx1ZX0pO1tcImZyb21cIixcInRvXCIsXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24oa2V5KXtpZih0cmFuc2FjdGlvbltrZXldPT1udWxsKXtyZXR1cm59cmVzdWx0W2tleV09aGV4bGlmeSh0cmFuc2FjdGlvbltrZXldKX0pO2lmKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3Qpe3Jlc3VsdFtcImFjY2Vzc0xpc3RcIl09YWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KX1yZXR1cm4gcmVzdWx0fX1cInVzZSBzdHJpY3RcIjtsZXQgV1M9bnVsbDt0cnl7V1M9V2ViU29ja2V0O2lmKFdTPT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoXCJpbmplY3QgcGxlYXNlXCIpfX1jYXRjaChlcnJvcil7Y29uc3QgbG9nZ2VyPW5ldyBMb2dnZXIodmVyc2lvbiRtKTtXUz1mdW5jdGlvbigpe2xvZ2dlci50aHJvd0Vycm9yKFwiV2ViU29ja2V0cyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwibmV3IFdlYlNvY2tldCgpXCJ9KX19XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciRhPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkdj1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7bGV0IE5leHRJZD0xO2NsYXNzIFdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVye2NvbnN0cnVjdG9yKHVybCxuZXR3b3JrKXtpZihuZXR3b3JrPT09XCJhbnlcIil7bG9nZ2VyJHYudGhyb3dFcnJvcihcIldlYlNvY2tldFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueScgbmV0d29yayB5ZXRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwibmV0d29yazphbnlcIn0pfXN1cGVyKHVybCxuZXR3b3JrKTt0aGlzLl9wb2xsaW5nSW50ZXJ2YWw9LTE7dGhpcy5fd3NSZWFkeT1mYWxzZTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX3dlYnNvY2tldFwiLG5ldyBXUyh0aGlzLmNvbm5lY3Rpb24udXJsKSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9yZXF1ZXN0c1wiLHt9KTtkZWZpbmVSZWFkT25seSh0aGlzLFwiX3N1YnNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9zdWJJZHNcIix7fSk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9kZXRlY3ROZXR3b3JrXCIsc3VwZXIuZGV0ZWN0TmV0d29yaygpKTt0aGlzLl93ZWJzb2NrZXQub25vcGVuPSgoKT0+e3RoaXMuX3dzUmVhZHk9dHJ1ZTtPYmplY3Qua2V5cyh0aGlzLl9yZXF1ZXN0cykuZm9yRWFjaChpZD0+e3RoaXMuX3dlYnNvY2tldC5zZW5kKHRoaXMuX3JlcXVlc3RzW2lkXS5wYXlsb2FkKX0pfSk7dGhpcy5fd2Vic29ja2V0Lm9ubWVzc2FnZT0obWVzc2FnZUV2ZW50PT57Y29uc3QgZGF0YT1tZXNzYWdlRXZlbnQuZGF0YTtjb25zdCByZXN1bHQ9SlNPTi5wYXJzZShkYXRhKTtpZihyZXN1bHQuaWQhPW51bGwpe2NvbnN0IGlkPVN0cmluZyhyZXN1bHQuaWQpO2NvbnN0IHJlcXVlc3Q9dGhpcy5fcmVxdWVzdHNbaWRdO2RlbGV0ZSB0aGlzLl9yZXF1ZXN0c1tpZF07aWYocmVzdWx0LnJlc3VsdCE9PXVuZGVmaW5lZCl7cmVxdWVzdC5jYWxsYmFjayhudWxsLHJlc3VsdC5yZXN1bHQpO3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlc3BvbnNlXCIscmVxdWVzdDpKU09OLnBhcnNlKHJlcXVlc3QucGF5bG9hZCkscmVzcG9uc2U6cmVzdWx0LnJlc3VsdCxwcm92aWRlcjp0aGlzfSl9ZWxzZXtsZXQgZXJyb3I9bnVsbDtpZihyZXN1bHQuZXJyb3Ipe2Vycm9yPW5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZXx8XCJ1bmtub3duIGVycm9yXCIpO2RlZmluZVJlYWRPbmx5KGVycm9yLFwiY29kZVwiLHJlc3VsdC5lcnJvci5jb2RlfHxudWxsKTtkZWZpbmVSZWFkT25seShlcnJvcixcInJlc3BvbnNlXCIsZGF0YSl9ZWxzZXtlcnJvcj1uZXcgRXJyb3IoXCJ1bmtub3duIGVycm9yXCIpfXJlcXVlc3QuY2FsbGJhY2soZXJyb3IsdW5kZWZpbmVkKTt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXNwb25zZVwiLGVycm9yOmVycm9yLHJlcXVlc3Q6SlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLHByb3ZpZGVyOnRoaXN9KX19ZWxzZSBpZihyZXN1bHQubWV0aG9kPT09XCJldGhfc3Vic2NyaXB0aW9uXCIpe2NvbnN0IHN1Yj10aGlzLl9zdWJzW3Jlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uXTtpZihzdWIpe3N1Yi5wcm9jZXNzRnVuYyhyZXN1bHQucGFyYW1zLnJlc3VsdCl9fWVsc2V7Y29uc29sZS53YXJuKFwidGhpcyBzaG91bGQgbm90IGhhcHBlblwiKX19KTtjb25zdCBmYXV4UG9sbD1zZXRJbnRlcnZhbCgoKT0+e3RoaXMuZW1pdChcInBvbGxcIil9LDFlMyk7aWYoZmF1eFBvbGwudW5yZWYpe2ZhdXhQb2xsLnVucmVmKCl9fWRldGVjdE5ldHdvcmsoKXtyZXR1cm4gdGhpcy5fZGV0ZWN0TmV0d29ya31nZXQgcG9sbGluZ0ludGVydmFsKCl7cmV0dXJuIDB9cmVzZXRFdmVudHNCbG9jayhibG9ja051bWJlcil7bG9nZ2VyJHYudGhyb3dFcnJvcihcImNhbm5vdCByZXNldCBldmVudHMgYmxvY2sgb24gV2ViU29ja2V0UHJvdmlkZXJcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwicmVzZXRFdmVudEJsb2NrXCJ9KX1zZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKXtsb2dnZXIkdi50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIGludGVydmFsIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcInNldFBvbGxpbmdJbnRlcnZhbFwifSl9cG9sbCgpe3JldHVybiBfX2F3YWl0ZXIkYSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7cmV0dXJuIG51bGx9KX1zZXQgcG9sbGluZyh2YWx1ZSl7aWYoIXZhbHVlKXtyZXR1cm59bG9nZ2VyJHYudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBvbiBXZWJTb2NrZXRQcm92aWRlclwiLExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzZXRQb2xsaW5nXCJ9KX1zZW5kKG1ldGhvZCxwYXJhbXMpe2NvbnN0IHJpZD1OZXh0SWQrKztyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e2Z1bmN0aW9uIGNhbGxiYWNrKGVycm9yLHJlc3VsdCl7aWYoZXJyb3Ipe3JldHVybiByZWplY3QoZXJyb3IpfXJldHVybiByZXNvbHZlKHJlc3VsdCl9Y29uc3QgcGF5bG9hZD1KU09OLnN0cmluZ2lmeSh7bWV0aG9kOm1ldGhvZCxwYXJhbXM6cGFyYW1zLGlkOnJpZCxqc29ucnBjOlwiMi4wXCJ9KTt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXF1ZXN0XCIscmVxdWVzdDpKU09OLnBhcnNlKHBheWxvYWQpLHByb3ZpZGVyOnRoaXN9KTt0aGlzLl9yZXF1ZXN0c1tTdHJpbmcocmlkKV09e2NhbGxiYWNrOmNhbGxiYWNrLHBheWxvYWQ6cGF5bG9hZH07aWYodGhpcy5fd3NSZWFkeSl7dGhpcy5fd2Vic29ja2V0LnNlbmQocGF5bG9hZCl9fSl9c3RhdGljIGRlZmF1bHRVcmwoKXtyZXR1cm5cIndzOi8vbG9jYWxob3N0Ojg1NDZcIn1fc3Vic2NyaWJlKHRhZyxwYXJhbSxwcm9jZXNzRnVuYyl7cmV0dXJuIF9fYXdhaXRlciRhKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtsZXQgc3ViSWRQcm9taXNlPXRoaXMuX3N1Yklkc1t0YWddO2lmKHN1YklkUHJvbWlzZT09bnVsbCl7c3ViSWRQcm9taXNlPVByb21pc2UuYWxsKHBhcmFtKS50aGVuKHBhcmFtPT57cmV0dXJuIHRoaXMuc2VuZChcImV0aF9zdWJzY3JpYmVcIixwYXJhbSl9KTt0aGlzLl9zdWJJZHNbdGFnXT1zdWJJZFByb21pc2V9Y29uc3Qgc3ViSWQ9eWllbGQgc3ViSWRQcm9taXNlO3RoaXMuX3N1YnNbc3ViSWRdPXt0YWc6dGFnLHByb2Nlc3NGdW5jOnByb2Nlc3NGdW5jfX0pfV9zdGFydEV2ZW50KGV2ZW50KXtzd2l0Y2goZXZlbnQudHlwZSl7Y2FzZVwiYmxvY2tcIjp0aGlzLl9zdWJzY3JpYmUoXCJibG9ja1wiLFtcIm5ld0hlYWRzXCJdLHJlc3VsdD0+e2NvbnN0IGJsb2NrTnVtYmVyPUJpZ051bWJlci5mcm9tKHJlc3VsdC5udW1iZXIpLnRvTnVtYmVyKCk7dGhpcy5fZW1pdHRlZC5ibG9jaz1ibG9ja051bWJlcjt0aGlzLmVtaXQoXCJibG9ja1wiLGJsb2NrTnVtYmVyKX0pO2JyZWFrO2Nhc2VcInBlbmRpbmdcIjp0aGlzLl9zdWJzY3JpYmUoXCJwZW5kaW5nXCIsW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSxyZXN1bHQ9Pnt0aGlzLmVtaXQoXCJwZW5kaW5nXCIscmVzdWx0KX0pO2JyZWFrO2Nhc2VcImZpbHRlclwiOnRoaXMuX3N1YnNjcmliZShldmVudC50YWcsW1wibG9nc1wiLHRoaXMuX2dldEZpbHRlcihldmVudC5maWx0ZXIpXSxyZXN1bHQ9PntpZihyZXN1bHQucmVtb3ZlZD09bnVsbCl7cmVzdWx0LnJlbW92ZWQ9ZmFsc2V9dGhpcy5lbWl0KGV2ZW50LmZpbHRlcix0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cocmVzdWx0KSl9KTticmVhaztjYXNlXCJ0eFwiOntjb25zdCBlbWl0UmVjZWlwdD1ldmVudD0+e2NvbnN0IGhhc2g9ZXZlbnQuaGFzaDt0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKS50aGVuKHJlY2VpcHQ9PntpZighcmVjZWlwdCl7cmV0dXJufXRoaXMuZW1pdChoYXNoLHJlY2VpcHQpfSl9O2VtaXRSZWNlaXB0KGV2ZW50KTt0aGlzLl9zdWJzY3JpYmUoXCJ0eFwiLFtcIm5ld0hlYWRzXCJdLHJlc3VsdD0+e3RoaXMuX2V2ZW50cy5maWx0ZXIoZT0+ZS50eXBlPT09XCJ0eFwiKS5mb3JFYWNoKGVtaXRSZWNlaXB0KX0pO2JyZWFrfWNhc2VcImRlYnVnXCI6Y2FzZVwicG9sbFwiOmNhc2VcIndpbGxQb2xsXCI6Y2FzZVwiZGlkUG9sbFwiOmNhc2VcImVycm9yXCI6YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmxvZyhcInVuaGFuZGxlZDpcIixldmVudCk7YnJlYWt9fV9zdG9wRXZlbnQoZXZlbnQpe2xldCB0YWc9ZXZlbnQudGFnO2lmKGV2ZW50LnR5cGU9PT1cInR4XCIpe2lmKHRoaXMuX2V2ZW50cy5maWx0ZXIoZT0+ZS50eXBlPT09XCJ0eFwiKS5sZW5ndGgpe3JldHVybn10YWc9XCJ0eFwifWVsc2UgaWYodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50LmV2ZW50KSl7cmV0dXJufWNvbnN0IHN1YklkPXRoaXMuX3N1Yklkc1t0YWddO2lmKCFzdWJJZCl7cmV0dXJufWRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtzdWJJZC50aGVuKHN1YklkPT57aWYoIXRoaXMuX3N1YnNbc3ViSWRdKXtyZXR1cm59ZGVsZXRlIHRoaXMuX3N1YnNbc3ViSWRdO3RoaXMuc2VuZChcImV0aF91bnN1YnNjcmliZVwiLFtzdWJJZF0pfSl9ZGVzdHJveSgpe3JldHVybiBfX2F3YWl0ZXIkYSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYodGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGU9PT1XUy5DT05ORUNUSU5HKXt5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlPT57dGhpcy5fd2Vic29ja2V0Lm9ub3Blbj1mdW5jdGlvbigpe3Jlc29sdmUodHJ1ZSl9O3RoaXMuX3dlYnNvY2tldC5vbmVycm9yPWZ1bmN0aW9uKCl7cmVzb2x2ZShmYWxzZSl9fSl9dGhpcy5fd2Vic29ja2V0LmNsb3NlKDFlMyl9KX19XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciRiPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkdz1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7Y2xhc3MgU3RhdGljSnNvblJwY1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVye2RldGVjdE5ldHdvcmsoKXtjb25zdCBfc3VwZXI9T2JqZWN0LmNyZWF0ZShudWxsLHtkZXRlY3ROZXR3b3JrOntnZXQ6KCk9PnN1cGVyLmRldGVjdE5ldHdvcmt9fSk7cmV0dXJuIF9fYXdhaXRlciRiKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtsZXQgbmV0d29yaz10aGlzLm5ldHdvcms7aWYobmV0d29yaz09bnVsbCl7bmV0d29yaz15aWVsZCBfc3VwZXIuZGV0ZWN0TmV0d29yay5jYWxsKHRoaXMpO2lmKCFuZXR3b3JrKXtsb2dnZXIkdy50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUix7fSl9aWYodGhpcy5fbmV0d29yaz09bnVsbCl7ZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9uZXR3b3JrXCIsbmV0d29yayk7dGhpcy5lbWl0KFwibmV0d29ya1wiLG5ldHdvcmssbnVsbCl9fXJldHVybiBuZXR3b3JrfSl9fWNsYXNzIFVybEpzb25ScGNQcm92aWRlciBleHRlbmRzIFN0YXRpY0pzb25ScGNQcm92aWRlcntjb25zdHJ1Y3RvcihuZXR3b3JrLGFwaUtleSl7bG9nZ2VyJHcuY2hlY2tBYnN0cmFjdChuZXcudGFyZ2V0LFVybEpzb25ScGNQcm92aWRlcik7bmV0d29yaz1nZXRTdGF0aWMobmV3LnRhcmdldCxcImdldE5ldHdvcmtcIikobmV0d29yayk7YXBpS2V5PWdldFN0YXRpYyhuZXcudGFyZ2V0LFwiZ2V0QXBpS2V5XCIpKGFwaUtleSk7Y29uc3QgY29ubmVjdGlvbj1nZXRTdGF0aWMobmV3LnRhcmdldCxcImdldFVybFwiKShuZXR3b3JrLGFwaUtleSk7c3VwZXIoY29ubmVjdGlvbixuZXR3b3JrKTtpZih0eXBlb2YgYXBpS2V5PT09XCJzdHJpbmdcIil7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFwaUtleVwiLGFwaUtleSl9ZWxzZSBpZihhcGlLZXkhPW51bGwpe09iamVjdC5rZXlzKGFwaUtleSkuZm9yRWFjaChrZXk9PntkZWZpbmVSZWFkT25seSh0aGlzLGtleSxhcGlLZXlba2V5XSl9KX19X3N0YXJ0UGVuZGluZygpe2xvZ2dlciR3Lndhcm4oXCJXQVJOSU5HOiBBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnNcIil9aXNDb21tdW5pdHlSZXNvdXJjZSgpe3JldHVybiBmYWxzZX1nZXRTaWduZXIoYWRkcmVzcyl7cmV0dXJuIGxvZ2dlciR3LnRocm93RXJyb3IoXCJBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nXCIsTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImdldFNpZ25lclwifSl9bGlzdEFjY291bnRzKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSl9c3RhdGljIGdldEFwaUtleShhcGlLZXkpe3JldHVybiBhcGlLZXl9c3RhdGljIGdldFVybChuZXR3b3JrLGFwaUtleSl7cmV0dXJuIGxvZ2dlciR3LnRocm93RXJyb3IoXCJub3QgaW1wbGVtZW50ZWQ7IHN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0VXJsXCIsTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQse29wZXJhdGlvbjpcImdldFVybFwifSl9fVwidXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciR4PW5ldyBMb2dnZXIodmVyc2lvbiRtKTtjb25zdCBkZWZhdWx0QXBpS2V5PVwiX2dnN3dTU2kwS01Cc2RLbkdWZkhEdWVxNnhNQjlFa0NcIjtjbGFzcyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBXZWJTb2NrZXRQcm92aWRlcntjb25zdHJ1Y3RvcihuZXR3b3JrLGFwaUtleSl7Y29uc3QgcHJvdmlkZXI9bmV3IEFsY2hlbXlQcm92aWRlcihuZXR3b3JrLGFwaUtleSk7Y29uc3QgdXJsPXByb3ZpZGVyLmNvbm5lY3Rpb24udXJsLnJlcGxhY2UoL15odHRwL2ksXCJ3c1wiKS5yZXBsYWNlKFwiLmFsY2hlbXlhcGkuXCIsXCIud3MuYWxjaGVteWFwaS5cIik7c3VwZXIodXJsLHByb3ZpZGVyLm5ldHdvcmspO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJhcGlLZXlcIixwcm92aWRlci5hcGlLZXkpfWlzQ29tbXVuaXR5UmVzb3VyY2UoKXtyZXR1cm4gdGhpcy5hcGlLZXk9PT1kZWZhdWx0QXBpS2V5fX1jbGFzcyBBbGNoZW15UHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXJ7c3RhdGljIGdldFdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssYXBpS2V5KXtyZXR1cm4gbmV3IEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLGFwaUtleSl9c3RhdGljIGdldEFwaUtleShhcGlLZXkpe2lmKGFwaUtleT09bnVsbCl7cmV0dXJuIGRlZmF1bHRBcGlLZXl9aWYoYXBpS2V5JiZ0eXBlb2YgYXBpS2V5IT09XCJzdHJpbmdcIil7bG9nZ2VyJHgudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcGlLZXlcIixcImFwaUtleVwiLGFwaUtleSl9cmV0dXJuIGFwaUtleX1zdGF0aWMgZ2V0VXJsKG5ldHdvcmssYXBpS2V5KXtsZXQgaG9zdD1udWxsO3N3aXRjaChuZXR3b3JrLm5hbWUpe2Nhc2VcImhvbWVzdGVhZFwiOmhvc3Q9XCJldGgtbWFpbm5ldC5hbGNoZW15YXBpLmlvL3YyL1wiO2JyZWFrO2Nhc2VcInJvcHN0ZW5cIjpob3N0PVwiZXRoLXJvcHN0ZW4uYWxjaGVteWFwaS5pby92Mi9cIjticmVhaztjYXNlXCJyaW5rZWJ5XCI6aG9zdD1cImV0aC1yaW5rZWJ5LmFsY2hlbXlhcGkuaW8vdjIvXCI7YnJlYWs7Y2FzZVwiZ29lcmxpXCI6aG9zdD1cImV0aC1nb2VybGkuYWxjaGVteWFwaS5pby92Mi9cIjticmVhaztjYXNlXCJrb3ZhblwiOmhvc3Q9XCJldGgta292YW4uYWxjaGVteWFwaS5pby92Mi9cIjticmVhaztkZWZhdWx0OmxvZ2dlciR4LnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIixcIm5ldHdvcmtcIixhcmd1bWVudHNbMF0pfXJldHVybnthbGxvd0d6aXA6dHJ1ZSx1cmw6XCJodHRwczovXCIrXCIvXCIraG9zdCthcGlLZXksdGhyb3R0bGVDYWxsYmFjazooYXR0ZW1wdCx1cmwpPT57aWYoYXBpS2V5PT09ZGVmYXVsdEFwaUtleSl7c2hvd1Rocm90dGxlTWVzc2FnZSgpfXJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSl9fX1pc0NvbW11bml0eVJlc291cmNlKCl7cmV0dXJuIHRoaXMuYXBpS2V5PT09ZGVmYXVsdEFwaUtleX19XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciRjPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkeT1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7Y2xhc3MgQ2xvdWRmbGFyZVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVye3N0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KXtpZihhcGlLZXkhPW51bGwpe2xvZ2dlciR5LnRocm93QXJndW1lbnRFcnJvcihcImFwaUtleSBub3Qgc3VwcG9ydGVkIGZvciBjbG91ZGZsYXJlXCIsXCJhcGlLZXlcIixhcGlLZXkpfXJldHVybiBudWxsfXN0YXRpYyBnZXRVcmwobmV0d29yayxhcGlLZXkpe2xldCBob3N0PW51bGw7c3dpdGNoKG5ldHdvcmsubmFtZSl7Y2FzZVwiaG9tZXN0ZWFkXCI6aG9zdD1cImh0dHBzOi8vY2xvdWRmbGFyZS1ldGguY29tL1wiO2JyZWFrO2RlZmF1bHQ6bG9nZ2VyJHkudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLFwibmV0d29ya1wiLGFyZ3VtZW50c1swXSl9cmV0dXJuIGhvc3R9cGVyZm9ybShtZXRob2QscGFyYW1zKXtjb25zdCBfc3VwZXI9T2JqZWN0LmNyZWF0ZShudWxsLHtwZXJmb3JtOntnZXQ6KCk9PnN1cGVyLnBlcmZvcm19fSk7cmV0dXJuIF9fYXdhaXRlciRjKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtpZihtZXRob2Q9PT1cImdldEJsb2NrTnVtYmVyXCIpe2NvbnN0IGJsb2NrPXlpZWxkIF9zdXBlci5wZXJmb3JtLmNhbGwodGhpcyxcImdldEJsb2NrXCIse2Jsb2NrVGFnOlwibGF0ZXN0XCJ9KTtyZXR1cm4gYmxvY2subnVtYmVyfXJldHVybiBfc3VwZXIucGVyZm9ybS5jYWxsKHRoaXMsbWV0aG9kLHBhcmFtcyl9KX19XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fYXdhaXRlciRkPXdpbmRvdyYmd2luZG93Ll9fYXdhaXRlcnx8ZnVuY3Rpb24odGhpc0FyZyxfYXJndW1lbnRzLFAsZ2VuZXJhdG9yKXtmdW5jdGlvbiBhZG9wdCh2YWx1ZSl7cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUD92YWx1ZTpuZXcgUChmdW5jdGlvbihyZXNvbHZlKXtyZXNvbHZlKHZhbHVlKX0pfXJldHVybiBuZXcoUHx8KFA9UHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiByZWplY3RlZCh2YWx1ZSl7dHJ5e3N0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKX1jYXRjaChlKXtyZWplY3QoZSl9fWZ1bmN0aW9uIHN0ZXAocmVzdWx0KXtyZXN1bHQuZG9uZT9yZXNvbHZlKHJlc3VsdC52YWx1ZSk6YWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCxyZWplY3RlZCl9c3RlcCgoZ2VuZXJhdG9yPWdlbmVyYXRvci5hcHBseSh0aGlzQXJnLF9hcmd1bWVudHN8fFtdKSkubmV4dCgpKX0pfTtjb25zdCBsb2dnZXIkej1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7ZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YSh0cmFuc2FjdGlvbil7Y29uc3QgcmVzdWx0PXt9O2ZvcihsZXQga2V5IGluIHRyYW5zYWN0aW9uKXtpZih0cmFuc2FjdGlvbltrZXldPT1udWxsKXtjb250aW51ZX1sZXQgdmFsdWU9dHJhbnNhY3Rpb25ba2V5XTtpZih7dHlwZTp0cnVlLGdhc0xpbWl0OnRydWUsZ2FzUHJpY2U6dHJ1ZSxub25jZTp0cnVlLHZhbHVlOnRydWV9W2tleV0pe3ZhbHVlPWhleFZhbHVlKGhleGxpZnkodmFsdWUpKX1lbHNlIGlmKGtleT09PVwiYWNjZXNzTGlzdFwiKXtjb25zdCBzZXRzPWFjY2Vzc0xpc3RpZnkodmFsdWUpO3ZhbHVlPVwiW1wiK3NldHMubWFwKHNldD0+e3JldHVybmB7YWRkcmVzczpcIiR7c2V0LmFkZHJlc3N9XCIsc3RvcmFnZUtleXM6W1wiJHtzZXQuc3RvcmFnZUtleXMuam9pbignXCIsXCInKX1cIl19YH0pLmpvaW4oXCIsXCIpK1wiXVwifWVsc2V7dmFsdWU9aGV4bGlmeSh2YWx1ZSl9cmVzdWx0W2tleV09dmFsdWV9cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBnZXRSZXN1bHQkMShyZXN1bHQpe2lmKHJlc3VsdC5zdGF0dXM9PTAmJihyZXN1bHQubWVzc2FnZT09PVwiTm8gcmVjb3JkcyBmb3VuZFwifHxyZXN1bHQubWVzc2FnZT09PVwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCIpKXtyZXR1cm4gcmVzdWx0LnJlc3VsdH1pZihyZXN1bHQuc3RhdHVzIT0xfHxyZXN1bHQubWVzc2FnZSE9XCJPS1wiKXtjb25zdCBlcnJvcj1uZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO2Vycm9yLnJlc3VsdD1KU09OLnN0cmluZ2lmeShyZXN1bHQpO2lmKChyZXN1bHQucmVzdWx0fHxcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpPj0wKXtlcnJvci50aHJvdHRsZVJldHJ5PXRydWV9dGhyb3cgZXJyb3J9cmV0dXJuIHJlc3VsdC5yZXN1bHR9ZnVuY3Rpb24gZ2V0SnNvblJlc3VsdChyZXN1bHQpe2lmKHJlc3VsdCYmcmVzdWx0LnN0YXR1cz09MCYmcmVzdWx0Lm1lc3NhZ2U9PVwiTk9UT0tcIiYmKHJlc3VsdC5yZXN1bHR8fFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJhdGUgbGltaXRcIik+PTApe2NvbnN0IGVycm9yPW5ldyBFcnJvcihcInRocm90dGxlZCByZXNwb25zZVwiKTtlcnJvci5yZXN1bHQ9SlNPTi5zdHJpbmdpZnkocmVzdWx0KTtlcnJvci50aHJvdHRsZVJldHJ5PXRydWU7dGhyb3cgZXJyb3J9aWYocmVzdWx0Lmpzb25ycGMhPVwiMi4wXCIpe2NvbnN0IGVycm9yPW5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIik7ZXJyb3IucmVzdWx0PUpTT04uc3RyaW5naWZ5KHJlc3VsdCk7dGhyb3cgZXJyb3J9aWYocmVzdWx0LmVycm9yKXtjb25zdCBlcnJvcj1uZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2V8fFwidW5rbm93biBlcnJvclwiKTtpZihyZXN1bHQuZXJyb3IuY29kZSl7ZXJyb3IuY29kZT1yZXN1bHQuZXJyb3IuY29kZX1pZihyZXN1bHQuZXJyb3IuZGF0YSl7ZXJyb3IuZGF0YT1yZXN1bHQuZXJyb3IuZGF0YX10aHJvdyBlcnJvcn1yZXR1cm4gcmVzdWx0LnJlc3VsdH1mdW5jdGlvbiBjaGVja0xvZ1RhZyhibG9ja1RhZyl7aWYoYmxvY2tUYWc9PT1cInBlbmRpbmdcIil7dGhyb3cgbmV3IEVycm9yKFwicGVuZGluZyBub3Qgc3VwcG9ydGVkXCIpfWlmKGJsb2NrVGFnPT09XCJsYXRlc3RcIil7cmV0dXJuIGJsb2NrVGFnfXJldHVybiBwYXJzZUludChibG9ja1RhZy5zdWJzdHJpbmcoMiksMTYpfWNvbnN0IGRlZmF1bHRBcGlLZXkkMT1cIjlEMTNaRTdYU0JUSjk0TjlCTkoyTUEzM1ZNQVkyWVBJUkJcIjtmdW5jdGlvbiBjaGVja0Vycm9yJDEobWV0aG9kLGVycm9yLHRyYW5zYWN0aW9uKXtpZihtZXRob2Q9PT1cImNhbGxcIiYmZXJyb3IuY29kZT09PUxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKXtjb25zdCBlPWVycm9yLmVycm9yO2lmKGUmJmUubWVzc2FnZS5tYXRjaChcInJldmVydGVkXCIpJiZpc0hleFN0cmluZyhlLmRhdGEpKXtyZXR1cm4gZS5kYXRhfX1sZXQgbWVzc2FnZT1lcnJvci5tZXNzYWdlO2lmKGVycm9yLmNvZGU9PT1Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUil7aWYoZXJyb3IuZXJyb3ImJnR5cGVvZiBlcnJvci5lcnJvci5tZXNzYWdlPT09XCJzdHJpbmdcIil7bWVzc2FnZT1lcnJvci5lcnJvci5tZXNzYWdlfWVsc2UgaWYodHlwZW9mIGVycm9yLmJvZHk9PT1cInN0cmluZ1wiKXttZXNzYWdlPWVycm9yLmJvZHl9ZWxzZSBpZih0eXBlb2YgZXJyb3IucmVzcG9uc2VUZXh0PT09XCJzdHJpbmdcIil7bWVzc2FnZT1lcnJvci5yZXNwb25zZVRleHR9fW1lc3NhZ2U9KG1lc3NhZ2V8fFwiXCIpLnRvTG93ZXJDYXNlKCk7aWYobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzLykpe2xvZ2dlciR6LnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMse2Vycm9yOmVycm9yLG1ldGhvZDptZXRob2QsdHJhbnNhY3Rpb246dHJhbnNhY3Rpb259KX1pZihtZXNzYWdlLm1hdGNoKC9zYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWR8dHJhbnNhY3Rpb24gbm9uY2UgaXMgdG9vIGxvdy8pKXtsb2dnZXIkei50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELHtlcnJvcjplcnJvcixtZXRob2Q6bWV0aG9kLHRyYW5zYWN0aW9uOnRyYW5zYWN0aW9ufSl9aWYobWVzc2FnZS5tYXRjaCgvYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UvKSl7bG9nZ2VyJHoudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCx7ZXJyb3I6ZXJyb3IsbWV0aG9kOm1ldGhvZCx0cmFuc2FjdGlvbjp0cmFuc2FjdGlvbn0pfWlmKG1lc3NhZ2UubWF0Y2goL2V4ZWN1dGlvbiBmYWlsZWQgZHVlIHRvIGFuIGV4Y2VwdGlvbi8pKXtsb2dnZXIkei50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQse2Vycm9yOmVycm9yLG1ldGhvZDptZXRob2QsdHJhbnNhY3Rpb246dHJhbnNhY3Rpb259KX10aHJvdyBlcnJvcn1jbGFzcyBFdGhlcnNjYW5Qcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlcntjb25zdHJ1Y3RvcihuZXR3b3JrLGFwaUtleSl7bG9nZ2VyJHouY2hlY2tOZXcobmV3LnRhcmdldCxFdGhlcnNjYW5Qcm92aWRlcik7c3VwZXIobmV0d29yayk7bGV0IG5hbWU9XCJpbnZhbGlkXCI7aWYodGhpcy5uZXR3b3JrKXtuYW1lPXRoaXMubmV0d29yay5uYW1lfWxldCBiYXNlVXJsPW51bGw7c3dpdGNoKG5hbWUpe2Nhc2VcImhvbWVzdGVhZFwiOmJhc2VVcmw9XCJodHRwczovL2FwaS5ldGhlcnNjYW4uaW9cIjticmVhaztjYXNlXCJyb3BzdGVuXCI6YmFzZVVybD1cImh0dHBzOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvXCI7YnJlYWs7Y2FzZVwicmlua2VieVwiOmJhc2VVcmw9XCJodHRwczovL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2Nhc2VcImtvdmFuXCI6YmFzZVVybD1cImh0dHBzOi8vYXBpLWtvdmFuLmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2Nhc2VcImdvZXJsaVwiOmJhc2VVcmw9XCJodHRwczovL2FwaS1nb2VybGkuZXRoZXJzY2FuLmlvXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIpfWRlZmluZVJlYWRPbmx5KHRoaXMsXCJiYXNlVXJsXCIsYmFzZVVybCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFwaUtleVwiLGFwaUtleXx8ZGVmYXVsdEFwaUtleSQxKX1kZXRlY3ROZXR3b3JrKCl7cmV0dXJuIF9fYXdhaXRlciRkKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtyZXR1cm4gdGhpcy5uZXR3b3JrfSl9cGVyZm9ybShtZXRob2QscGFyYW1zKXtjb25zdCBfc3VwZXI9T2JqZWN0LmNyZWF0ZShudWxsLHtwZXJmb3JtOntnZXQ6KCk9PnN1cGVyLnBlcmZvcm19fSk7cmV0dXJuIF9fYXdhaXRlciRkKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtsZXQgdXJsPXRoaXMuYmFzZVVybCtcIi9hcGlcIjtsZXQgYXBpS2V5PVwiXCI7aWYodGhpcy5hcGlLZXkpe2FwaUtleSs9XCImYXBpa2V5PVwiK3RoaXMuYXBpS2V5fWNvbnN0IGdldD0odXJsLHBheWxvYWQscHJvY0Z1bmMpPT5fX2F3YWl0ZXIkZCh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVxdWVzdFwiLHJlcXVlc3Q6dXJsLHByb3ZpZGVyOnRoaXN9KTtjb25zdCBjb25uZWN0aW9uPXt1cmw6dXJsLHRocm90dGxlU2xvdEludGVydmFsOjFlMyx0aHJvdHRsZUNhbGxiYWNrOihhdHRlbXB0LHVybCk9PntpZih0aGlzLmlzQ29tbXVuaXR5UmVzb3VyY2UoKSl7c2hvd1Rocm90dGxlTWVzc2FnZSgpfXJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSl9fTtsZXQgcGF5bG9hZFN0cj1udWxsO2lmKHBheWxvYWQpe2Nvbm5lY3Rpb24uaGVhZGVycz17XCJjb250ZW50LXR5cGVcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwifTtwYXlsb2FkU3RyPU9iamVjdC5rZXlzKHBheWxvYWQpLm1hcChrZXk9PntyZXR1cm5gJHtrZXl9PSR7cGF5bG9hZFtrZXldfWB9KS5qb2luKFwiJlwiKX1jb25zdCByZXN1bHQ9eWllbGQgZmV0Y2hKc29uKGNvbm5lY3Rpb24scGF5bG9hZFN0cixwcm9jRnVuY3x8Z2V0SnNvblJlc3VsdCk7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVzcG9uc2VcIixyZXF1ZXN0OnVybCxyZXNwb25zZTpkZWVwQ29weShyZXN1bHQpLHByb3ZpZGVyOnRoaXN9KTtyZXR1cm4gcmVzdWx0fSk7c3dpdGNoKG1ldGhvZCl7Y2FzZVwiZ2V0QmxvY2tOdW1iZXJcIjp1cmwrPVwiP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2Jsb2NrTnVtYmVyXCIrYXBpS2V5O3JldHVybiBnZXQodXJsLG51bGwpO2Nhc2VcImdldEdhc1ByaWNlXCI6dXJsKz1cIj9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nYXNQcmljZVwiK2FwaUtleTtyZXR1cm4gZ2V0KHVybCxudWxsKTtjYXNlXCJnZXRCYWxhbmNlXCI6dXJsKz1cIj9tb2R1bGU9YWNjb3VudCZhY3Rpb249YmFsYW5jZSZhZGRyZXNzPVwiK3BhcmFtcy5hZGRyZXNzO3VybCs9XCImdGFnPVwiK3BhcmFtcy5ibG9ja1RhZythcGlLZXk7cmV0dXJuIGdldCh1cmwsbnVsbCxnZXRSZXN1bHQkMSk7Y2FzZVwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOnVybCs9XCI/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCZhZGRyZXNzPVwiK3BhcmFtcy5hZGRyZXNzO3VybCs9XCImdGFnPVwiK3BhcmFtcy5ibG9ja1RhZythcGlLZXk7cmV0dXJuIGdldCh1cmwsbnVsbCk7Y2FzZVwiZ2V0Q29kZVwiOnVybCs9XCI/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0Q29kZSZhZGRyZXNzPVwiK3BhcmFtcy5hZGRyZXNzO3VybCs9XCImdGFnPVwiK3BhcmFtcy5ibG9ja1RhZythcGlLZXk7cmV0dXJuIGdldCh1cmwsbnVsbCk7Y2FzZVwiZ2V0U3RvcmFnZUF0XCI6dXJsKz1cIj9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRTdG9yYWdlQXQmYWRkcmVzcz1cIitwYXJhbXMuYWRkcmVzczt1cmwrPVwiJnBvc2l0aW9uPVwiK3BhcmFtcy5wb3NpdGlvbjt1cmwrPVwiJnRhZz1cIitwYXJhbXMuYmxvY2tUYWcrYXBpS2V5O3JldHVybiBnZXQodXJsLG51bGwpO2Nhc2VcInNlbmRUcmFuc2FjdGlvblwiOnJldHVybiBnZXQodXJsLHttb2R1bGU6XCJwcm94eVwiLGFjdGlvbjpcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixoZXg6cGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uLGFwaWtleTp0aGlzLmFwaUtleX0pLmNhdGNoKGVycm9yPT57cmV0dXJuIGNoZWNrRXJyb3IkMShcInNlbmRUcmFuc2FjdGlvblwiLGVycm9yLHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbil9KTtjYXNlXCJnZXRCbG9ja1wiOmlmKHBhcmFtcy5ibG9ja1RhZyl7dXJsKz1cIj9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRCbG9ja0J5TnVtYmVyJnRhZz1cIitwYXJhbXMuYmxvY2tUYWc7aWYocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMpe3VybCs9XCImYm9vbGVhbj10cnVlXCJ9ZWxzZXt1cmwrPVwiJmJvb2xlYW49ZmFsc2VcIn11cmwrPWFwaUtleTtyZXR1cm4gZ2V0KHVybCxudWxsKX10aHJvdyBuZXcgRXJyb3IoXCJnZXRCbG9jayBieSBibG9ja0hhc2ggbm90IGltcGxlbWVudGVkXCIpO2Nhc2VcImdldFRyYW5zYWN0aW9uXCI6dXJsKz1cIj9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCZ0eGhhc2g9XCIrcGFyYW1zLnRyYW5zYWN0aW9uSGFzaDt1cmwrPWFwaUtleTtyZXR1cm4gZ2V0KHVybCxudWxsKTtjYXNlXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjp1cmwrPVwiP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCZ0eGhhc2g9XCIrcGFyYW1zLnRyYW5zYWN0aW9uSGFzaDt1cmwrPWFwaUtleTtyZXR1cm4gZ2V0KHVybCxudWxsKTtjYXNlXCJjYWxsXCI6e2lmKHBhcmFtcy5ibG9ja1RhZyE9PVwibGF0ZXN0XCIpe3Rocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIil9Y29uc3QgcG9zdERhdGE9Z2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShwYXJhbXMudHJhbnNhY3Rpb24pO3Bvc3REYXRhLm1vZHVsZT1cInByb3h5XCI7cG9zdERhdGEuYWN0aW9uPVwiZXRoX2NhbGxcIjtwb3N0RGF0YS5hcGlrZXk9dGhpcy5hcGlLZXk7dHJ5e3JldHVybiB5aWVsZCBnZXQodXJsLHBvc3REYXRhKX1jYXRjaChlcnJvcil7cmV0dXJuIGNoZWNrRXJyb3IkMShcImNhbGxcIixlcnJvcixwYXJhbXMudHJhbnNhY3Rpb24pfX1jYXNlXCJlc3RpbWF0ZUdhc1wiOntjb25zdCBwb3N0RGF0YT1nZXRUcmFuc2FjdGlvblBvc3REYXRhKHBhcmFtcy50cmFuc2FjdGlvbik7cG9zdERhdGEubW9kdWxlPVwicHJveHlcIjtwb3N0RGF0YS5hY3Rpb249XCJldGhfZXN0aW1hdGVHYXNcIjtwb3N0RGF0YS5hcGlrZXk9dGhpcy5hcGlLZXk7dHJ5e3JldHVybiB5aWVsZCBnZXQodXJsLHBvc3REYXRhKX1jYXRjaChlcnJvcil7cmV0dXJuIGNoZWNrRXJyb3IkMShcImVzdGltYXRlR2FzXCIsZXJyb3IscGFyYW1zLnRyYW5zYWN0aW9uKX19Y2FzZVwiZ2V0TG9nc1wiOnt1cmwrPVwiP21vZHVsZT1sb2dzJmFjdGlvbj1nZXRMb2dzXCI7aWYocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spe3VybCs9XCImZnJvbUJsb2NrPVwiK2NoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKX1pZihwYXJhbXMuZmlsdGVyLnRvQmxvY2spe3VybCs9XCImdG9CbG9jaz1cIitjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spfWlmKHBhcmFtcy5maWx0ZXIuYWRkcmVzcyl7dXJsKz1cIiZhZGRyZXNzPVwiK3BhcmFtcy5maWx0ZXIuYWRkcmVzc31pZihwYXJhbXMuZmlsdGVyLnRvcGljcyYmcGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoPjApe2lmKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aD4xKXtsb2dnZXIkei50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgY291bnRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7dG9waWNzOnBhcmFtcy5maWx0ZXIudG9waWNzfSl9aWYocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoPT09MSl7Y29uc3QgdG9waWMwPXBhcmFtcy5maWx0ZXIudG9waWNzWzBdO2lmKHR5cGVvZiB0b3BpYzAhPT1cInN0cmluZ1wifHx0b3BpYzAubGVuZ3RoIT09NjYpe2xvZ2dlciR6LnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBmb3JtYXRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7dG9waWMwOnRvcGljMH0pfXVybCs9XCImdG9waWMwPVwiK3RvcGljMH19dXJsKz1hcGlLZXk7Y29uc3QgbG9ncz15aWVsZCBnZXQodXJsLG51bGwsZ2V0UmVzdWx0JDEpO2xldCBibG9ja3M9e307Zm9yKGxldCBpPTA7aTxsb2dzLmxlbmd0aDtpKyspe2NvbnN0IGxvZz1sb2dzW2ldO2lmKGxvZy5ibG9ja0hhc2ghPW51bGwpe2NvbnRpbnVlfWlmKGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdPT1udWxsKXtjb25zdCBibG9jaz15aWVsZCB0aGlzLmdldEJsb2NrKGxvZy5ibG9ja051bWJlcik7aWYoYmxvY2spe2Jsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdPWJsb2NrLmhhc2h9fWxvZy5ibG9ja0hhc2g9YmxvY2tzW2xvZy5ibG9ja051bWJlcl19cmV0dXJuIGxvZ3N9Y2FzZVwiZ2V0RXRoZXJQcmljZVwiOmlmKHRoaXMubmV0d29yay5uYW1lIT09XCJob21lc3RlYWRcIil7cmV0dXJuIDB9dXJsKz1cIj9tb2R1bGU9c3RhdHMmYWN0aW9uPWV0aHByaWNlXCI7dXJsKz1hcGlLZXk7cmV0dXJuIHBhcnNlRmxvYXQoKHlpZWxkIGdldCh1cmwsbnVsbCxnZXRSZXN1bHQkMSkpLmV0aHVzZCk7ZGVmYXVsdDpicmVha31yZXR1cm4gX3N1cGVyLnBlcmZvcm0uY2FsbCh0aGlzLG1ldGhvZCxwYXJhbXMpfSl9Z2V0SGlzdG9yeShhZGRyZXNzT3JOYW1lLHN0YXJ0QmxvY2ssZW5kQmxvY2spe2xldCB1cmw9dGhpcy5iYXNlVXJsO2xldCBhcGlLZXk9XCJcIjtpZih0aGlzLmFwaUtleSl7YXBpS2V5Kz1cIiZhcGlrZXk9XCIrdGhpcy5hcGlLZXl9aWYoc3RhcnRCbG9jaz09bnVsbCl7c3RhcnRCbG9jaz0wfWlmKGVuZEJsb2NrPT1udWxsKXtlbmRCbG9jaz05OTk5OTk5OX1yZXR1cm4gdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKS50aGVuKGFkZHJlc3M9Pnt1cmwrPVwiL2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9XCIrYWRkcmVzczt1cmwrPVwiJnN0YXJ0YmxvY2s9XCIrc3RhcnRCbG9jazt1cmwrPVwiJmVuZGJsb2NrPVwiK2VuZEJsb2NrO3VybCs9XCImc29ydD1hc2NcIithcGlLZXk7dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVxdWVzdFwiLHJlcXVlc3Q6dXJsLHByb3ZpZGVyOnRoaXN9KTtjb25zdCBjb25uZWN0aW9uPXt1cmw6dXJsLHRocm90dGxlU2xvdEludGVydmFsOjFlMyx0aHJvdHRsZUNhbGxiYWNrOihhdHRlbXB0LHVybCk9PntpZih0aGlzLmFwaUtleT09PWRlZmF1bHRBcGlLZXkkMSl7c2hvd1Rocm90dGxlTWVzc2FnZSgpfXJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSl9fTtyZXR1cm4gZmV0Y2hKc29uKGNvbm5lY3Rpb24sbnVsbCxnZXRSZXN1bHQkMSkudGhlbihyZXN1bHQ9Pnt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXNwb25zZVwiLHJlcXVlc3Q6dXJsLHJlc3BvbnNlOmRlZXBDb3B5KHJlc3VsdCkscHJvdmlkZXI6dGhpc30pO2xldCBvdXRwdXQ9W107cmVzdWx0LmZvckVhY2godHg9PntbXCJjb250cmFjdEFkZHJlc3NcIixcInRvXCJdLmZvckVhY2goZnVuY3Rpb24oa2V5KXtpZih0eFtrZXldPT1cIlwiKXtkZWxldGUgdHhba2V5XX19KTtpZih0eC5jcmVhdGVzPT1udWxsJiZ0eC5jb250cmFjdEFkZHJlc3MhPW51bGwpe3R4LmNyZWF0ZXM9dHguY29udHJhY3RBZGRyZXNzfWxldCBpdGVtPXRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO2lmKHR4LnRpbWVTdGFtcCl7aXRlbS50aW1lc3RhbXA9cGFyc2VJbnQodHgudGltZVN0YW1wKX1vdXRwdXQucHVzaChpdGVtKX0pO3JldHVybiBvdXRwdXR9KX0pfWlzQ29tbXVuaXR5UmVzb3VyY2UoKXtyZXR1cm4gdGhpcy5hcGlLZXk9PT1kZWZhdWx0QXBpS2V5JDF9fVwidXNlIHN0cmljdFwiO3ZhciBfX2F3YWl0ZXIkZT13aW5kb3cmJndpbmRvdy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKHRoaXNBcmcsX2FyZ3VtZW50cyxQLGdlbmVyYXRvcil7ZnVuY3Rpb24gYWRvcHQodmFsdWUpe3JldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFA/dmFsdWU6bmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSl7cmVzb2x2ZSh2YWx1ZSl9KX1yZXR1cm4gbmV3KFB8fChQPVByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKXt0cnl7c3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpfWNhdGNoKGUpe3JlamVjdChlKX19ZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpe3RyeXtzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSl9Y2F0Y2goZSl7cmVqZWN0KGUpfX1mdW5jdGlvbiBzdGVwKHJlc3VsdCl7cmVzdWx0LmRvbmU/cmVzb2x2ZShyZXN1bHQudmFsdWUpOmFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKGdlbmVyYXRvcj1nZW5lcmF0b3IuYXBwbHkodGhpc0FyZyxfYXJndW1lbnRzfHxbXSkpLm5leHQoKSl9KX07Y29uc3QgbG9nZ2VyJEE9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2Z1bmN0aW9uIG5vdygpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfWZ1bmN0aW9uIGNoZWNrTmV0d29ya3MobmV0d29ya3Mpe2xldCByZXN1bHQ9bnVsbDtmb3IobGV0IGk9MDtpPG5ldHdvcmtzLmxlbmd0aDtpKyspe2NvbnN0IG5ldHdvcms9bmV0d29ya3NbaV07aWYobmV0d29yaz09bnVsbCl7cmV0dXJuIG51bGx9aWYocmVzdWx0KXtpZighKHJlc3VsdC5uYW1lPT09bmV0d29yay5uYW1lJiZyZXN1bHQuY2hhaW5JZD09PW5ldHdvcmsuY2hhaW5JZCYmKHJlc3VsdC5lbnNBZGRyZXNzPT09bmV0d29yay5lbnNBZGRyZXNzfHxyZXN1bHQuZW5zQWRkcmVzcz09bnVsbCYmbmV0d29yay5lbnNBZGRyZXNzPT1udWxsKSkpe2xvZ2dlciRBLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVyIG1pc21hdGNoXCIsXCJuZXR3b3Jrc1wiLG5ldHdvcmtzKX19ZWxzZXtyZXN1bHQ9bmV0d29ya319cmV0dXJuIHJlc3VsdH1mdW5jdGlvbiBtZWRpYW4odmFsdWVzLG1heERlbHRhKXt2YWx1ZXM9dmFsdWVzLnNsaWNlKCkuc29ydCgpO2NvbnN0IG1pZGRsZT1NYXRoLmZsb29yKHZhbHVlcy5sZW5ndGgvMik7aWYodmFsdWVzLmxlbmd0aCUyKXtyZXR1cm4gdmFsdWVzW21pZGRsZV19Y29uc3QgYT12YWx1ZXNbbWlkZGxlLTFdLGI9dmFsdWVzW21pZGRsZV07aWYobWF4RGVsdGEhPW51bGwmJk1hdGguYWJzKGEtYik+bWF4RGVsdGEpe3JldHVybiBudWxsfXJldHVybihhK2IpLzJ9ZnVuY3Rpb24gc2VyaWFsaXplJDEodmFsdWUpe2lmKHZhbHVlPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9ZWxzZSBpZih0eXBlb2YgdmFsdWU9PT1cIm51bWJlclwifHx0eXBlb2YgdmFsdWU9PT1cImJvb2xlYW5cIil7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKX1lbHNlIGlmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe3JldHVybiB2YWx1ZX1lbHNlIGlmKEJpZ051bWJlci5pc0JpZ051bWJlcih2YWx1ZSkpe3JldHVybiB2YWx1ZS50b1N0cmluZygpfWVsc2UgaWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpe3JldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS5tYXAoaT0+c2VyaWFsaXplJDEoaSkpKX1lbHNlIGlmKHR5cGVvZiB2YWx1ZT09PVwib2JqZWN0XCIpe2NvbnN0IGtleXM9T2JqZWN0LmtleXModmFsdWUpO2tleXMuc29ydCgpO3JldHVyblwie1wiK2tleXMubWFwKGtleT0+e2xldCB2PXZhbHVlW2tleV07aWYodHlwZW9mIHY9PT1cImZ1bmN0aW9uXCIpe3Y9XCJbZnVuY3Rpb25dXCJ9ZWxzZXt2PXNlcmlhbGl6ZSQxKHYpfXJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpK1wiOlwiK3Z9KS5qb2luKFwiLFwiKStcIn1cIn10aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHZhbHVlIHR5cGU6IFwiK3R5cGVvZiB2YWx1ZSl9bGV0IG5leHRSaWQ9MTtmdW5jdGlvbiBzdGFsbCQxKGR1cmF0aW9uKXtsZXQgY2FuY2VsPW51bGw7bGV0IHRpbWVyPW51bGw7bGV0IHByb21pc2U9bmV3IFByb21pc2UocmVzb2x2ZT0+e2NhbmNlbD1mdW5jdGlvbigpe2lmKHRpbWVyKXtjbGVhclRpbWVvdXQodGltZXIpO3RpbWVyPW51bGx9cmVzb2x2ZSgpfTt0aW1lcj1zZXRUaW1lb3V0KGNhbmNlbCxkdXJhdGlvbil9KTtjb25zdCB3YWl0PWZ1bmM9Pntwcm9taXNlPXByb21pc2UudGhlbihmdW5jKTtyZXR1cm4gcHJvbWlzZX07ZnVuY3Rpb24gZ2V0UHJvbWlzZSgpe3JldHVybiBwcm9taXNlfXJldHVybntjYW5jZWw6Y2FuY2VsLGdldFByb21pc2U6Z2V0UHJvbWlzZSx3YWl0OndhaXR9fWNvbnN0IEZvcndhcmRFcnJvcnM9W0xvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVF07Y29uc3QgRm9yd2FyZFByb3BlcnRpZXM9W1wiYWRkcmVzc1wiLFwiYXJnc1wiLFwiZXJyb3JBcmdzXCIsXCJlcnJvclNpZ25hdHVyZVwiLFwibWV0aG9kXCIsXCJ0cmFuc2FjdGlvblwiXTtmdW5jdGlvbiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsbm93KXtjb25zdCByZXN1bHQ9e3dlaWdodDpjb25maWcud2VpZ2h0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LFwicHJvdmlkZXJcIix7Z2V0OigpPT5jb25maWcucHJvdmlkZXJ9KTtpZihjb25maWcuc3RhcnQpe3Jlc3VsdC5zdGFydD1jb25maWcuc3RhcnR9aWYobm93KXtyZXN1bHQuZHVyYXRpb249bm93LWNvbmZpZy5zdGFydH1pZihjb25maWcuZG9uZSl7aWYoY29uZmlnLmVycm9yKXtyZXN1bHQuZXJyb3I9Y29uZmlnLmVycm9yfWVsc2V7cmVzdWx0LnJlc3VsdD1jb25maWcucmVzdWx0fHxudWxsfX1yZXR1cm4gcmVzdWx0fWZ1bmN0aW9uIG5vcm1hbGl6ZWRUYWxseShub3JtYWxpemUscXVvcnVtKXtyZXR1cm4gZnVuY3Rpb24oY29uZmlncyl7Y29uc3QgdGFsbHk9e307Y29uZmlncy5mb3JFYWNoKGM9Pntjb25zdCB2YWx1ZT1ub3JtYWxpemUoYy5yZXN1bHQpO2lmKCF0YWxseVt2YWx1ZV0pe3RhbGx5W3ZhbHVlXT17Y291bnQ6MCxyZXN1bHQ6Yy5yZXN1bHR9fXRhbGx5W3ZhbHVlXS5jb3VudCsrfSk7Y29uc3Qga2V5cz1PYmplY3Qua2V5cyh0YWxseSk7Zm9yKGxldCBpPTA7aTxrZXlzLmxlbmd0aDtpKyspe2NvbnN0IGNoZWNrPXRhbGx5W2tleXNbaV1dO2lmKGNoZWNrLmNvdW50Pj1xdW9ydW0pe3JldHVybiBjaGVjay5yZXN1bHR9fXJldHVybiB1bmRlZmluZWR9fWZ1bmN0aW9uIGdldFByb2Nlc3NGdW5jKHByb3ZpZGVyLG1ldGhvZCxwYXJhbXMpe2xldCBub3JtYWxpemU9c2VyaWFsaXplJDE7c3dpdGNoKG1ldGhvZCl7Y2FzZVwiZ2V0QmxvY2tOdW1iZXJcIjpyZXR1cm4gZnVuY3Rpb24oY29uZmlncyl7Y29uc3QgdmFsdWVzPWNvbmZpZ3MubWFwKGM9PmMucmVzdWx0KTtsZXQgYmxvY2tOdW1iZXI9bWVkaWFuKGNvbmZpZ3MubWFwKGM9PmMucmVzdWx0KSwyKTtpZihibG9ja051bWJlcj09bnVsbCl7cmV0dXJuIHVuZGVmaW5lZH1ibG9ja051bWJlcj1NYXRoLmNlaWwoYmxvY2tOdW1iZXIpO2lmKHZhbHVlcy5pbmRleE9mKGJsb2NrTnVtYmVyKzEpPj0wKXtibG9ja051bWJlcisrfWlmKGJsb2NrTnVtYmVyPj1wcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyKXtwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyPWJsb2NrTnVtYmVyfXJldHVybiBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyfTtjYXNlXCJnZXRHYXNQcmljZVwiOnJldHVybiBmdW5jdGlvbihjb25maWdzKXtjb25zdCB2YWx1ZXM9Y29uZmlncy5tYXAoYz0+Yy5yZXN1bHQpO3ZhbHVlcy5zb3J0KCk7cmV0dXJuIHZhbHVlc1tNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGgvMildfTtjYXNlXCJnZXRFdGhlclByaWNlXCI6cmV0dXJuIGZ1bmN0aW9uKGNvbmZpZ3Mpe3JldHVybiBtZWRpYW4oY29uZmlncy5tYXAoYz0+Yy5yZXN1bHQpKX07Y2FzZVwiZ2V0QmFsYW5jZVwiOmNhc2VcImdldFRyYW5zYWN0aW9uQ291bnRcIjpjYXNlXCJnZXRDb2RlXCI6Y2FzZVwiZ2V0U3RvcmFnZUF0XCI6Y2FzZVwiY2FsbFwiOmNhc2VcImVzdGltYXRlR2FzXCI6Y2FzZVwiZ2V0TG9nc1wiOmJyZWFrO2Nhc2VcImdldFRyYW5zYWN0aW9uXCI6Y2FzZVwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6bm9ybWFsaXplPWZ1bmN0aW9uKHR4KXtpZih0eD09bnVsbCl7cmV0dXJuIG51bGx9dHg9c2hhbGxvd0NvcHkodHgpO3R4LmNvbmZpcm1hdGlvbnM9LTE7cmV0dXJuIHNlcmlhbGl6ZSQxKHR4KX07YnJlYWs7Y2FzZVwiZ2V0QmxvY2tcIjppZihwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucyl7bm9ybWFsaXplPWZ1bmN0aW9uKGJsb2NrKXtpZihibG9jaz09bnVsbCl7cmV0dXJuIG51bGx9YmxvY2s9c2hhbGxvd0NvcHkoYmxvY2spO2Jsb2NrLnRyYW5zYWN0aW9ucz1ibG9jay50cmFuc2FjdGlvbnMubWFwKHR4PT57dHg9c2hhbGxvd0NvcHkodHgpO3R4LmNvbmZpcm1hdGlvbnM9LTE7cmV0dXJuIHR4fSk7cmV0dXJuIHNlcmlhbGl6ZSQxKGJsb2NrKX19ZWxzZXtub3JtYWxpemU9ZnVuY3Rpb24oYmxvY2spe2lmKGJsb2NrPT1udWxsKXtyZXR1cm4gbnVsbH1yZXR1cm4gc2VyaWFsaXplJDEoYmxvY2spfX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVua25vd24gbWV0aG9kOiBcIittZXRob2QpfXJldHVybiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLHByb3ZpZGVyLnF1b3J1bSl9ZnVuY3Rpb24gd2FpdEZvclN5bmMoY29uZmlnLGJsb2NrTnVtYmVyKXtyZXR1cm4gX19hd2FpdGVyJGUodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKigpe2NvbnN0IHByb3ZpZGVyPWNvbmZpZy5wcm92aWRlcjtpZihwcm92aWRlci5ibG9ja051bWJlciE9bnVsbCYmcHJvdmlkZXIuYmxvY2tOdW1iZXI+PWJsb2NrTnVtYmVyfHxibG9ja051bWJlcj09PS0xKXtyZXR1cm4gcHJvdmlkZXJ9cmV0dXJuIHBvbGwoKCk9PntyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e3NldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihwcm92aWRlci5ibG9ja051bWJlcj49YmxvY2tOdW1iZXIpe3JldHVybiByZXNvbHZlKHByb3ZpZGVyKX1pZihjb25maWcuY2FuY2VsbGVkKXtyZXR1cm4gcmVzb2x2ZShudWxsKX1yZXR1cm4gcmVzb2x2ZSh1bmRlZmluZWQpfSwwKX0pfSx7b25jZVBvbGw6cHJvdmlkZXJ9KX0pfWZ1bmN0aW9uIGdldFJ1bm5lcihjb25maWcsY3VycmVudEJsb2NrTnVtYmVyLG1ldGhvZCxwYXJhbXMpe3JldHVybiBfX2F3YWl0ZXIkZSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7bGV0IHByb3ZpZGVyPWNvbmZpZy5wcm92aWRlcjtzd2l0Y2gobWV0aG9kKXtjYXNlXCJnZXRCbG9ja051bWJlclwiOmNhc2VcImdldEdhc1ByaWNlXCI6cmV0dXJuIHByb3ZpZGVyW21ldGhvZF0oKTtjYXNlXCJnZXRFdGhlclByaWNlXCI6aWYocHJvdmlkZXIuZ2V0RXRoZXJQcmljZSl7cmV0dXJuIHByb3ZpZGVyLmdldEV0aGVyUHJpY2UoKX1icmVhaztjYXNlXCJnZXRCYWxhbmNlXCI6Y2FzZVwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOmNhc2VcImdldENvZGVcIjppZihwYXJhbXMuYmxvY2tUYWcmJmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpe3Byb3ZpZGVyPXlpZWxkIHdhaXRGb3JTeW5jKGNvbmZpZyxjdXJyZW50QmxvY2tOdW1iZXIpfXJldHVybiBwcm92aWRlclttZXRob2RdKHBhcmFtcy5hZGRyZXNzLHBhcmFtcy5ibG9ja1RhZ3x8XCJsYXRlc3RcIik7Y2FzZVwiZ2V0U3RvcmFnZUF0XCI6aWYocGFyYW1zLmJsb2NrVGFnJiZpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKXtwcm92aWRlcj15aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsY3VycmVudEJsb2NrTnVtYmVyKX1yZXR1cm4gcHJvdmlkZXIuZ2V0U3RvcmFnZUF0KHBhcmFtcy5hZGRyZXNzLHBhcmFtcy5wb3NpdGlvbixwYXJhbXMuYmxvY2tUYWd8fFwibGF0ZXN0XCIpO2Nhc2VcImdldEJsb2NrXCI6aWYocGFyYW1zLmJsb2NrVGFnJiZpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKXtwcm92aWRlcj15aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsY3VycmVudEJsb2NrTnVtYmVyKX1yZXR1cm4gcHJvdmlkZXJbcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnM/XCJnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnNcIjpcImdldEJsb2NrXCJdKHBhcmFtcy5ibG9ja1RhZ3x8cGFyYW1zLmJsb2NrSGFzaCk7Y2FzZVwiY2FsbFwiOmNhc2VcImVzdGltYXRlR2FzXCI6aWYocGFyYW1zLmJsb2NrVGFnJiZpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKXtwcm92aWRlcj15aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsY3VycmVudEJsb2NrTnVtYmVyKX1yZXR1cm4gcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb24pO2Nhc2VcImdldFRyYW5zYWN0aW9uXCI6Y2FzZVwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6cmV0dXJuIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLnRyYW5zYWN0aW9uSGFzaCk7Y2FzZVwiZ2V0TG9nc1wiOntsZXQgZmlsdGVyPXBhcmFtcy5maWx0ZXI7aWYoZmlsdGVyLmZyb21CbG9jayYmaXNIZXhTdHJpbmcoZmlsdGVyLmZyb21CbG9jayl8fGZpbHRlci50b0Jsb2NrJiZpc0hleFN0cmluZyhmaWx0ZXIudG9CbG9jaykpe3Byb3ZpZGVyPXlpZWxkIHdhaXRGb3JTeW5jKGNvbmZpZyxjdXJyZW50QmxvY2tOdW1iZXIpfXJldHVybiBwcm92aWRlci5nZXRMb2dzKGZpbHRlcil9fXJldHVybiBsb2dnZXIkQS50aHJvd0Vycm9yKFwidW5rbm93biBtZXRob2QgZXJyb3JcIixMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1Ise21ldGhvZDptZXRob2QscGFyYW1zOnBhcmFtc30pfSl9Y2xhc3MgRmFsbGJhY2tQcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlcntjb25zdHJ1Y3Rvcihwcm92aWRlcnMscXVvcnVtKXtsb2dnZXIkQS5jaGVja05ldyhuZXcudGFyZ2V0LEZhbGxiYWNrUHJvdmlkZXIpO2lmKHByb3ZpZGVycy5sZW5ndGg9PT0wKXtsb2dnZXIkQS50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyc1wiLFwicHJvdmlkZXJzXCIscHJvdmlkZXJzKX1jb25zdCBwcm92aWRlckNvbmZpZ3M9cHJvdmlkZXJzLm1hcCgoY29uZmlnT3JQcm92aWRlcixpbmRleCk9PntpZihQcm92aWRlci5pc1Byb3ZpZGVyKGNvbmZpZ09yUHJvdmlkZXIpKXtjb25zdCBzdGFsbFRpbWVvdXQ9aXNDb21tdW5pdHlSZXNvdXJjZShjb25maWdPclByb3ZpZGVyKT8yZTM6NzUwO2NvbnN0IHByaW9yaXR5PTE7cmV0dXJuIE9iamVjdC5mcmVlemUoe3Byb3ZpZGVyOmNvbmZpZ09yUHJvdmlkZXIsd2VpZ2h0OjEsc3RhbGxUaW1lb3V0OnN0YWxsVGltZW91dCxwcmlvcml0eTpwcmlvcml0eX0pfWNvbnN0IGNvbmZpZz1zaGFsbG93Q29weShjb25maWdPclByb3ZpZGVyKTtpZihjb25maWcucHJpb3JpdHk9PW51bGwpe2NvbmZpZy5wcmlvcml0eT0xfWlmKGNvbmZpZy5zdGFsbFRpbWVvdXQ9PW51bGwpe2NvbmZpZy5zdGFsbFRpbWVvdXQ9aXNDb21tdW5pdHlSZXNvdXJjZShjb25maWdPclByb3ZpZGVyKT8yZTM6NzUwfWlmKGNvbmZpZy53ZWlnaHQ9PW51bGwpe2NvbmZpZy53ZWlnaHQ9MX1jb25zdCB3ZWlnaHQ9Y29uZmlnLndlaWdodDtpZih3ZWlnaHQlMXx8d2VpZ2h0PjUxMnx8d2VpZ2h0PDEpe2xvZ2dlciRBLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgd2VpZ2h0OyBtdXN0IGJlIGludGVnZXIgaW4gWzEsIDUxMl1cIixgcHJvdmlkZXJzWyR7aW5kZXh9XS53ZWlnaHRgLHdlaWdodCl9cmV0dXJuIE9iamVjdC5mcmVlemUoY29uZmlnKX0pO2NvbnN0IHRvdGFsPXByb3ZpZGVyQ29uZmlncy5yZWR1Y2UoKGFjY3VtLGMpPT5hY2N1bStjLndlaWdodCwwKTtpZihxdW9ydW09PW51bGwpe3F1b3J1bT10b3RhbC8yfWVsc2UgaWYocXVvcnVtPnRvdGFsKXtsb2dnZXIkQS50aHJvd0FyZ3VtZW50RXJyb3IoXCJxdW9ydW0gd2lsbCBhbHdheXMgZmFpbDsgbGFyZ2VyIHRoYW4gdG90YWwgd2VpZ2h0XCIsXCJxdW9ydW1cIixxdW9ydW0pfWxldCBuZXR3b3JrT3JSZWFkeT1jaGVja05ldHdvcmtzKHByb3ZpZGVyQ29uZmlncy5tYXAoYz0+Yy5wcm92aWRlci5uZXR3b3JrKSk7aWYobmV0d29ya09yUmVhZHk9PW51bGwpe25ldHdvcmtPclJlYWR5PW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntzZXRUaW1lb3V0KCgpPT57dGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihyZXNvbHZlLHJlamVjdCl9LDApfSl9c3VwZXIobmV0d29ya09yUmVhZHkpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlckNvbmZpZ3NcIixPYmplY3QuZnJlZXplKHByb3ZpZGVyQ29uZmlncykpO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJxdW9ydW1cIixxdW9ydW0pO3RoaXMuX2hpZ2hlc3RCbG9ja051bWJlcj0tMX1kZXRlY3ROZXR3b3JrKCl7cmV0dXJuIF9fYXdhaXRlciRlKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbiooKXtjb25zdCBuZXR3b3Jrcz15aWVsZCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoYz0+Yy5wcm92aWRlci5nZXROZXR3b3JrKCkpKTtyZXR1cm4gY2hlY2tOZXR3b3JrcyhuZXR3b3Jrcyl9KX1wZXJmb3JtKG1ldGhvZCxwYXJhbXMpe3JldHVybiBfX2F3YWl0ZXIkZSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24qKCl7aWYobWV0aG9kPT09XCJzZW5kVHJhbnNhY3Rpb25cIil7Y29uc3QgcmVzdWx0cz15aWVsZCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoYz0+e3JldHVybiBjLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4ocmVzdWx0PT57cmV0dXJuIHJlc3VsdC5oYXNofSxlcnJvcj0+e3JldHVybiBlcnJvcn0pfSkpO2ZvcihsZXQgaT0wO2k8cmVzdWx0cy5sZW5ndGg7aSsrKXtjb25zdCByZXN1bHQ9cmVzdWx0c1tpXTtpZih0eXBlb2YgcmVzdWx0PT09XCJzdHJpbmdcIil7cmV0dXJuIHJlc3VsdH19dGhyb3cgcmVzdWx0c1swXX1pZih0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXI9PT0tMSYmbWV0aG9kIT09XCJnZXRCbG9ja051bWJlclwiKXt5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCl9Y29uc3QgcHJvY2Vzc0Z1bmM9Z2V0UHJvY2Vzc0Z1bmModGhpcyxtZXRob2QscGFyYW1zKTtjb25zdCBjb25maWdzPXNodWZmbGVkKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChzaGFsbG93Q29weSkpO2NvbmZpZ3Muc29ydCgoYSxiKT0+YS5wcmlvcml0eS1iLnByaW9yaXR5KTtjb25zdCBjdXJyZW50QmxvY2tOdW1iZXI9dGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyO2xldCBpPTA7bGV0IGZpcnN0PXRydWU7d2hpbGUodHJ1ZSl7Y29uc3QgdDA9bm93KCk7bGV0IGluZmxpZ2h0V2VpZ2h0PWNvbmZpZ3MuZmlsdGVyKGM9PmMucnVubmVyJiZ0MC1jLnN0YXJ0PGMuc3RhbGxUaW1lb3V0KS5yZWR1Y2UoKGFjY3VtLGMpPT5hY2N1bStjLndlaWdodCwwKTt3aGlsZShpbmZsaWdodFdlaWdodDx0aGlzLnF1b3J1bSYmaTxjb25maWdzLmxlbmd0aCl7Y29uc3QgY29uZmlnPWNvbmZpZ3NbaSsrXTtjb25zdCByaWQ9bmV4dFJpZCsrO2NvbmZpZy5zdGFydD1ub3coKTtjb25maWcuc3RhbGxlcj1zdGFsbCQxKGNvbmZpZy5zdGFsbFRpbWVvdXQpO2NvbmZpZy5zdGFsbGVyLndhaXQoKCk9Pntjb25maWcuc3RhbGxlcj1udWxsfSk7Y29uZmlnLnJ1bm5lcj1nZXRSdW5uZXIoY29uZmlnLGN1cnJlbnRCbG9ja051bWJlcixtZXRob2QscGFyYW1zKS50aGVuKHJlc3VsdD0+e2NvbmZpZy5kb25lPXRydWU7Y29uZmlnLnJlc3VsdD1yZXN1bHQ7aWYodGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpe3RoaXMuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInJlcXVlc3RcIixyaWQ6cmlkLGJhY2tlbmQ6ZXhwb3NlRGVidWdDb25maWcoY29uZmlnLG5vdygpKSxyZXF1ZXN0OnttZXRob2Q6bWV0aG9kLHBhcmFtczpkZWVwQ29weShwYXJhbXMpfSxwcm92aWRlcjp0aGlzfSl9fSxlcnJvcj0+e2NvbmZpZy5kb25lPXRydWU7Y29uZmlnLmVycm9yPWVycm9yO2lmKHRoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKXt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXF1ZXN0XCIscmlkOnJpZCxiYWNrZW5kOmV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZyxub3coKSkscmVxdWVzdDp7bWV0aG9kOm1ldGhvZCxwYXJhbXM6ZGVlcENvcHkocGFyYW1zKX0scHJvdmlkZXI6dGhpc30pfX0pO2lmKHRoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKXt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXF1ZXN0XCIscmlkOnJpZCxiYWNrZW5kOmV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZyxudWxsKSxyZXF1ZXN0OnttZXRob2Q6bWV0aG9kLHBhcmFtczpkZWVwQ29weShwYXJhbXMpfSxwcm92aWRlcjp0aGlzfSl9aW5mbGlnaHRXZWlnaHQrPWNvbmZpZy53ZWlnaHR9Y29uc3Qgd2FpdGluZz1bXTtjb25maWdzLmZvckVhY2goYz0+e2lmKGMuZG9uZXx8IWMucnVubmVyKXtyZXR1cm59d2FpdGluZy5wdXNoKGMucnVubmVyKTtpZihjLnN0YWxsZXIpe3dhaXRpbmcucHVzaChjLnN0YWxsZXIuZ2V0UHJvbWlzZSgpKX19KTtpZih3YWl0aW5nLmxlbmd0aCl7eWllbGQgUHJvbWlzZS5yYWNlKHdhaXRpbmcpfWNvbnN0IHJlc3VsdHM9Y29uZmlncy5maWx0ZXIoYz0+Yy5kb25lJiZjLmVycm9yPT1udWxsKTtpZihyZXN1bHRzLmxlbmd0aD49dGhpcy5xdW9ydW0pe2NvbnN0IHJlc3VsdD1wcm9jZXNzRnVuYyhyZXN1bHRzKTtpZihyZXN1bHQhPT11bmRlZmluZWQpe2NvbmZpZ3MuZm9yRWFjaChjPT57aWYoYy5zdGFsbGVyKXtjLnN0YWxsZXIuY2FuY2VsKCl9Yy5jYW5jZWxsZWQ9dHJ1ZX0pO3JldHVybiByZXN1bHR9aWYoIWZpcnN0KXt5aWVsZCBzdGFsbCQxKDEwMCkuZ2V0UHJvbWlzZSgpfWZpcnN0PWZhbHNlfWNvbnN0IGVycm9ycz1jb25maWdzLnJlZHVjZSgoYWNjdW0sYyk9PntpZighYy5kb25lfHxjLmVycm9yPT1udWxsKXtyZXR1cm4gYWNjdW19Y29uc3QgY29kZT1jLmVycm9yLmNvZGU7aWYoRm9yd2FyZEVycm9ycy5pbmRleE9mKGNvZGUpPj0wKXtpZighYWNjdW1bY29kZV0pe2FjY3VtW2NvZGVdPXtlcnJvcjpjLmVycm9yLHdlaWdodDowfX1hY2N1bVtjb2RlXS53ZWlnaHQrPWMud2VpZ2h0fXJldHVybiBhY2N1bX0se30pO09iamVjdC5rZXlzKGVycm9ycykuZm9yRWFjaChlcnJvckNvZGU9Pntjb25zdCB0YWxseT1lcnJvcnNbZXJyb3JDb2RlXTtpZih0YWxseS53ZWlnaHQ8dGhpcy5xdW9ydW0pe3JldHVybn1jb25maWdzLmZvckVhY2goYz0+e2lmKGMuc3RhbGxlcil7Yy5zdGFsbGVyLmNhbmNlbCgpfWMuY2FuY2VsbGVkPXRydWV9KTtjb25zdCBlPXRhbGx5LmVycm9yO2NvbnN0IHByb3BzPXt9O0ZvcndhcmRQcm9wZXJ0aWVzLmZvckVhY2gobmFtZT0+e2lmKGVbbmFtZV09PW51bGwpe3JldHVybn1wcm9wc1tuYW1lXT1lW25hbWVdfSk7bG9nZ2VyJEEudGhyb3dFcnJvcihlLnJlYXNvbnx8ZS5tZXNzYWdlLGVycm9yQ29kZSxwcm9wcyl9KTtpZihjb25maWdzLmZpbHRlcihjPT4hYy5kb25lKS5sZW5ndGg9PT0wKXticmVha319Y29uZmlncy5mb3JFYWNoKGM9PntpZihjLnN0YWxsZXIpe2Muc3RhbGxlci5jYW5jZWwoKX1jLmNhbmNlbGxlZD10cnVlfSk7cmV0dXJuIGxvZ2dlciRBLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gbWVldCBxdW9ydW1cIixMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUix7bWV0aG9kOm1ldGhvZCxwYXJhbXM6cGFyYW1zLHJlc3VsdHM6Y29uZmlncy5tYXAoYz0+ZXhwb3NlRGVidWdDb25maWcoYykpLHByb3ZpZGVyOnRoaXN9KX0pfX1cInVzZSBzdHJpY3RcIjtjb25zdCBJcGNQcm92aWRlcj1udWxsO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRCPW5ldyBMb2dnZXIodmVyc2lvbiRtKTtjb25zdCBkZWZhdWx0UHJvamVjdElkPVwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtjbGFzcyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIFdlYlNvY2tldFByb3ZpZGVye2NvbnN0cnVjdG9yKG5ldHdvcmssYXBpS2V5KXtjb25zdCBwcm92aWRlcj1uZXcgSW5mdXJhUHJvdmlkZXIobmV0d29yayxhcGlLZXkpO2NvbnN0IGNvbm5lY3Rpb249cHJvdmlkZXIuY29ubmVjdGlvbjtpZihjb25uZWN0aW9uLnBhc3N3b3JkKXtsb2dnZXIkQi50aHJvd0Vycm9yKFwiSU5GVVJBIFdlYlNvY2tldCBwcm9qZWN0IHNlY3JldHMgdW5zdXBwb3J0ZWRcIixMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKVwifSl9Y29uc3QgdXJsPWNvbm5lY3Rpb24udXJsLnJlcGxhY2UoL15odHRwL2ksXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLFwiL3dzL3YzL1wiKTtzdXBlcih1cmwsbmV0d29yayk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcImFwaUtleVwiLHByb3ZpZGVyLnByb2plY3RJZCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb2plY3RJZFwiLHByb3ZpZGVyLnByb2plY3RJZCk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb2plY3RTZWNyZXRcIixwcm92aWRlci5wcm9qZWN0U2VjcmV0KX1pc0NvbW11bml0eVJlc291cmNlKCl7cmV0dXJuIHRoaXMucHJvamVjdElkPT09ZGVmYXVsdFByb2plY3RJZH19Y2xhc3MgSW5mdXJhUHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXJ7c3RhdGljIGdldFdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssYXBpS2V5KXtyZXR1cm4gbmV3IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssYXBpS2V5KX1zdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSl7Y29uc3QgYXBpS2V5T2JqPXthcGlLZXk6ZGVmYXVsdFByb2plY3RJZCxwcm9qZWN0SWQ6ZGVmYXVsdFByb2plY3RJZCxwcm9qZWN0U2VjcmV0Om51bGx9O2lmKGFwaUtleT09bnVsbCl7cmV0dXJuIGFwaUtleU9ian1pZih0eXBlb2YgYXBpS2V5PT09XCJzdHJpbmdcIil7YXBpS2V5T2JqLnByb2plY3RJZD1hcGlLZXl9ZWxzZSBpZihhcGlLZXkucHJvamVjdFNlY3JldCE9bnVsbCl7bG9nZ2VyJEIuYXNzZXJ0QXJndW1lbnQodHlwZW9mIGFwaUtleS5wcm9qZWN0SWQ9PT1cInN0cmluZ1wiLFwicHJvamVjdFNlY3JldCByZXF1aXJlcyBhIHByb2plY3RJZFwiLFwicHJvamVjdElkXCIsYXBpS2V5LnByb2plY3RJZCk7bG9nZ2VyJEIuYXNzZXJ0QXJndW1lbnQodHlwZW9mIGFwaUtleS5wcm9qZWN0U2VjcmV0PT09XCJzdHJpbmdcIixcImludmFsaWQgcHJvamVjdFNlY3JldFwiLFwicHJvamVjdFNlY3JldFwiLFwiW1JFREFDVEVEXVwiKTthcGlLZXlPYmoucHJvamVjdElkPWFwaUtleS5wcm9qZWN0SWQ7YXBpS2V5T2JqLnByb2plY3RTZWNyZXQ9YXBpS2V5LnByb2plY3RTZWNyZXR9ZWxzZSBpZihhcGlLZXkucHJvamVjdElkKXthcGlLZXlPYmoucHJvamVjdElkPWFwaUtleS5wcm9qZWN0SWR9YXBpS2V5T2JqLmFwaUtleT1hcGlLZXlPYmoucHJvamVjdElkO3JldHVybiBhcGlLZXlPYmp9c3RhdGljIGdldFVybChuZXR3b3JrLGFwaUtleSl7bGV0IGhvc3Q9bnVsbDtzd2l0Y2gobmV0d29yaz9uZXR3b3JrLm5hbWU6XCJ1bmtub3duXCIpe2Nhc2VcImhvbWVzdGVhZFwiOmhvc3Q9XCJtYWlubmV0LmluZnVyYS5pb1wiO2JyZWFrO2Nhc2VcInJvcHN0ZW5cIjpob3N0PVwicm9wc3Rlbi5pbmZ1cmEuaW9cIjticmVhaztjYXNlXCJyaW5rZWJ5XCI6aG9zdD1cInJpbmtlYnkuaW5mdXJhLmlvXCI7YnJlYWs7Y2FzZVwia292YW5cIjpob3N0PVwia292YW4uaW5mdXJhLmlvXCI7YnJlYWs7Y2FzZVwiZ29lcmxpXCI6aG9zdD1cImdvZXJsaS5pbmZ1cmEuaW9cIjticmVhaztkZWZhdWx0OmxvZ2dlciRCLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcIm5ldHdvcmtcIix2YWx1ZTpuZXR3b3JrfSl9Y29uc3QgY29ubmVjdGlvbj17YWxsb3dHemlwOnRydWUsdXJsOlwiaHR0cHM6L1wiK1wiL1wiK2hvc3QrXCIvdjMvXCIrYXBpS2V5LnByb2plY3RJZCx0aHJvdHRsZUNhbGxiYWNrOihhdHRlbXB0LHVybCk9PntpZihhcGlLZXkucHJvamVjdElkPT09ZGVmYXVsdFByb2plY3RJZCl7c2hvd1Rocm90dGxlTWVzc2FnZSgpfXJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSl9fTtpZihhcGlLZXkucHJvamVjdFNlY3JldCE9bnVsbCl7Y29ubmVjdGlvbi51c2VyPVwiXCI7Y29ubmVjdGlvbi5wYXNzd29yZD1hcGlLZXkucHJvamVjdFNlY3JldH1yZXR1cm4gY29ubmVjdGlvbn1pc0NvbW11bml0eVJlc291cmNlKCl7cmV0dXJuIHRoaXMucHJvamVjdElkPT09ZGVmYXVsdFByb2plY3RJZH19Y2xhc3MgSnNvblJwY0JhdGNoUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXJ7c2VuZChtZXRob2QscGFyYW1zKXtjb25zdCByZXF1ZXN0PXttZXRob2Q6bWV0aG9kLHBhcmFtczpwYXJhbXMsaWQ6dGhpcy5fbmV4dElkKyssanNvbnJwYzpcIjIuMFwifTtpZih0aGlzLl9wZW5kaW5nQmF0Y2g9PW51bGwpe3RoaXMuX3BlbmRpbmdCYXRjaD1bXX1jb25zdCBpbmZsaWdodFJlcXVlc3Q9e3JlcXVlc3Q6cmVxdWVzdCxyZXNvbHZlOm51bGwscmVqZWN0Om51bGx9O2NvbnN0IHByb21pc2U9bmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e2luZmxpZ2h0UmVxdWVzdC5yZXNvbHZlPXJlc29sdmU7aW5mbGlnaHRSZXF1ZXN0LnJlamVjdD1yZWplY3R9KTt0aGlzLl9wZW5kaW5nQmF0Y2gucHVzaChpbmZsaWdodFJlcXVlc3QpO2lmKCF0aGlzLl9wZW5kaW5nQmF0Y2hBZ2dyZWdhdG9yKXt0aGlzLl9wZW5kaW5nQmF0Y2hBZ2dyZWdhdG9yPXNldFRpbWVvdXQoKCk9Pntjb25zdCBiYXRjaD10aGlzLl9wZW5kaW5nQmF0Y2g7dGhpcy5fcGVuZGluZ0JhdGNoPW51bGw7dGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcj1udWxsO2NvbnN0IHJlcXVlc3Q9YmF0Y2gubWFwKGluZmxpZ2h0PT5pbmZsaWdodC5yZXF1ZXN0KTt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXF1ZXN0QmF0Y2hcIixyZXF1ZXN0OmRlZXBDb3B5KHJlcXVlc3QpLHByb3ZpZGVyOnRoaXN9KTtyZXR1cm4gZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbixKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSkudGhlbihyZXN1bHQ9Pnt0aGlzLmVtaXQoXCJkZWJ1Z1wiLHthY3Rpb246XCJyZXNwb25zZVwiLHJlcXVlc3Q6cmVxdWVzdCxyZXNwb25zZTpyZXN1bHQscHJvdmlkZXI6dGhpc30pO2JhdGNoLmZvckVhY2goKGluZmxpZ2h0UmVxdWVzdCxpbmRleCk9Pntjb25zdCBwYXlsb2FkPXJlc3VsdFtpbmRleF07aWYocGF5bG9hZC5lcnJvcil7Y29uc3QgZXJyb3I9bmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7ZXJyb3IuY29kZT1wYXlsb2FkLmVycm9yLmNvZGU7ZXJyb3IuZGF0YT1wYXlsb2FkLmVycm9yLmRhdGE7aW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcil9ZWxzZXtpbmZsaWdodFJlcXVlc3QucmVzb2x2ZShwYXlsb2FkLnJlc3VsdCl9fSl9LGVycm9yPT57dGhpcy5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwicmVzcG9uc2VcIixlcnJvcjplcnJvcixyZXF1ZXN0OnJlcXVlc3QscHJvdmlkZXI6dGhpc30pO2JhdGNoLmZvckVhY2goaW5mbGlnaHRSZXF1ZXN0PT57aW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcil9KX0pfSwxMCl9cmV0dXJuIHByb21pc2V9fVwidXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRDPW5ldyBMb2dnZXIodmVyc2lvbiRtKTtjb25zdCBkZWZhdWx0QXBpS2V5JDI9XCJFVEhFUlNfSlNfU0hBUkVEXCI7Y2xhc3MgTm9kZXNtaXRoUHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXJ7c3RhdGljIGdldEFwaUtleShhcGlLZXkpe2lmKGFwaUtleSYmdHlwZW9mIGFwaUtleSE9PVwic3RyaW5nXCIpe2xvZ2dlciRDLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsXCJhcGlLZXlcIixhcGlLZXkpfXJldHVybiBhcGlLZXl8fGRlZmF1bHRBcGlLZXkkMn1zdGF0aWMgZ2V0VXJsKG5ldHdvcmssYXBpS2V5KXtsb2dnZXIkQy53YXJuKFwiTm9kZVNtaXRoIHdpbGwgYmUgZGlzY29udGludWVkIG9uIDIwMTktMTItMjA7IHBsZWFzZSBtaWdyYXRlIHRvIGFub3RoZXIgcGxhdGZvcm0uXCIpO2xldCBob3N0PW51bGw7c3dpdGNoKG5ldHdvcmsubmFtZSl7Y2FzZVwiaG9tZXN0ZWFkXCI6aG9zdD1cImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9tYWlubmV0L2pzb25ycGNcIjticmVhaztjYXNlXCJyb3BzdGVuXCI6aG9zdD1cImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9yb3BzdGVuL2pzb25ycGNcIjticmVhaztjYXNlXCJyaW5rZWJ5XCI6aG9zdD1cImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9yaW5rZWJ5L2pzb25ycGNcIjticmVhaztjYXNlXCJnb2VybGlcIjpob3N0PVwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2dvZXJsaS9qc29ucnBjXCI7YnJlYWs7Y2FzZVwia292YW5cIjpob3N0PVwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2tvdmFuL2pzb25ycGNcIjticmVhaztkZWZhdWx0OmxvZ2dlciRDLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIixcIm5ldHdvcmtcIixhcmd1bWVudHNbMF0pfXJldHVybiBob3N0K1wiP2FwaUtleT1cIithcGlLZXl9fVwidXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciREPW5ldyBMb2dnZXIodmVyc2lvbiRtKTtjb25zdCBkZWZhdWx0QXBwbGljYXRpb25JZHM9e2hvbWVzdGVhZDpcIjYwMDRiY2QxMDA0MDI2MTYzM2FkZTk5MFwiLHJvcHN0ZW46XCI2MDA0YmQ0ZDAwNDAyNjE2MzNhZGU5OTFcIixyaW5rZWJ5OlwiNjAwNGJkYTIwMDQwMjYxNjMzYWRlOTk0XCIsZ29lcmxpOlwiNjAwNGJkODYwMDQwMjYxNjMzYWRlOTkyXCJ9O2NsYXNzIFBvY2tldFByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVye2NvbnN0cnVjdG9yKG5ldHdvcmssYXBpS2V5KXtpZihhcGlLZXk9PW51bGwpe2NvbnN0IG49Z2V0U3RhdGljKG5ldy50YXJnZXQsXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO2lmKG4pe2NvbnN0IGFwcGxpY2F0aW9uSWQ9ZGVmYXVsdEFwcGxpY2F0aW9uSWRzW24ubmFtZV07aWYoYXBwbGljYXRpb25JZCl7YXBpS2V5PXthcHBsaWNhdGlvbklkOmFwcGxpY2F0aW9uSWQsbG9hZEJhbGFuY2VyOnRydWV9fX1pZihhcGlLZXk9PW51bGwpe2xvZ2dlciRELnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcIm5ldHdvcmtcIix2YWx1ZTpuZXR3b3JrfSl9fXN1cGVyKG5ldHdvcmssYXBpS2V5KX1zdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSl7aWYoYXBpS2V5PT1udWxsKXtsb2dnZXIkRC50aHJvd0FyZ3VtZW50RXJyb3IoXCJQb2NrZXRQcm92aWRlci5nZXRBcGlLZXkgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFwaUtleVwiLFwiYXBpS2V5XCIsYXBpS2V5KX1jb25zdCBhcGlLZXlPYmo9e2FwcGxpY2F0aW9uSWQ6bnVsbCxsb2FkQmFsYW5jZXI6ZmFsc2UsYXBwbGljYXRpb25TZWNyZXRLZXk6bnVsbH07aWYodHlwZW9mIGFwaUtleT09PVwic3RyaW5nXCIpe2FwaUtleU9iai5hcHBsaWNhdGlvbklkPWFwaUtleX1lbHNlIGlmKGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleSE9bnVsbCl7bG9nZ2VyJEQuYXNzZXJ0QXJndW1lbnQodHlwZW9mIGFwaUtleS5hcHBsaWNhdGlvbklkPT09XCJzdHJpbmdcIixcImFwcGxpY2F0aW9uU2VjcmV0S2V5IHJlcXVpcmVzIGFuIGFwcGxpY2F0aW9uSWRcIixcImFwcGxpY2F0aW9uSWRcIixhcGlLZXkuYXBwbGljYXRpb25JZCk7bG9nZ2VyJEQuYXNzZXJ0QXJndW1lbnQodHlwZW9mIGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleT09PVwic3RyaW5nXCIsXCJpbnZhbGlkIGFwcGxpY2F0aW9uU2VjcmV0S2V5XCIsXCJhcHBsaWNhdGlvblNlY3JldEtleVwiLFwiW1JFREFDVEVEXVwiKTthcGlLZXlPYmouYXBwbGljYXRpb25JZD1hcGlLZXkuYXBwbGljYXRpb25JZDthcGlLZXlPYmouYXBwbGljYXRpb25TZWNyZXRLZXk9YXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5O2FwaUtleU9iai5sb2FkQmFsYW5jZXI9ISFhcGlLZXkubG9hZEJhbGFuY2VyfWVsc2UgaWYoYXBpS2V5LmFwcGxpY2F0aW9uSWQpe2xvZ2dlciRELmFzc2VydEFyZ3VtZW50KHR5cGVvZiBhcGlLZXkuYXBwbGljYXRpb25JZD09PVwic3RyaW5nXCIsXCJhcGlLZXkuYXBwbGljYXRpb25JZCBtdXN0IGJlIGEgc3RyaW5nXCIsXCJhcGlLZXkuYXBwbGljYXRpb25JZFwiLGFwaUtleS5hcHBsaWNhdGlvbklkKTthcGlLZXlPYmouYXBwbGljYXRpb25JZD1hcGlLZXkuYXBwbGljYXRpb25JZDthcGlLZXlPYmoubG9hZEJhbGFuY2VyPSEhYXBpS2V5LmxvYWRCYWxhbmNlcn1lbHNle2xvZ2dlciRELnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIFBvY2tldFByb3ZpZGVyIGFwaUtleVwiLFwiYXBpS2V5XCIsYXBpS2V5KX1yZXR1cm4gYXBpS2V5T2JqfXN0YXRpYyBnZXRVcmwobmV0d29yayxhcGlLZXkpe2xldCBob3N0PW51bGw7c3dpdGNoKG5ldHdvcms/bmV0d29yay5uYW1lOlwidW5rbm93blwiKXtjYXNlXCJob21lc3RlYWRcIjpob3N0PVwiZXRoLW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjticmVhaztjYXNlXCJyb3BzdGVuXCI6aG9zdD1cImV0aC1yb3BzdGVuLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7YnJlYWs7Y2FzZVwicmlua2VieVwiOmhvc3Q9XCJldGgtcmlua2VieS5nYXRld2F5LnBva3QubmV0d29ya1wiO2JyZWFrO2Nhc2VcImdvZXJsaVwiOmhvc3Q9XCJldGgtZ29lcmxpLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7YnJlYWs7ZGVmYXVsdDpsb2dnZXIkRC50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJuZXR3b3JrXCIsdmFsdWU6bmV0d29ya30pfWxldCB1cmw9bnVsbDtpZihhcGlLZXkubG9hZEJhbGFuY2VyKXt1cmw9YGh0dHBzOi8vJHtob3N0fS92MS9sYi8ke2FwaUtleS5hcHBsaWNhdGlvbklkfWB9ZWxzZXt1cmw9YGh0dHBzOi8vJHtob3N0fS92MS8ke2FwaUtleS5hcHBsaWNhdGlvbklkfWB9Y29uc3QgY29ubmVjdGlvbj17dXJsOnVybH07Y29ubmVjdGlvbi5oZWFkZXJzPXt9O2lmKGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleSE9bnVsbCl7Y29ubmVjdGlvbi51c2VyPVwiXCI7Y29ubmVjdGlvbi5wYXNzd29yZD1hcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXl9cmV0dXJuIGNvbm5lY3Rpb259aXNDb21tdW5pdHlSZXNvdXJjZSgpe3JldHVybiB0aGlzLmFwcGxpY2F0aW9uSWQ9PT1kZWZhdWx0QXBwbGljYXRpb25JZHNbdGhpcy5uZXR3b3JrLm5hbWVdfX1cInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkRT1uZXcgTG9nZ2VyKHZlcnNpb24kbSk7bGV0IF9uZXh0SWQ9MTtmdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLHNlbmRGdW5jKXtyZXR1cm4gZnVuY3Rpb24obWV0aG9kLHBhcmFtcyl7aWYobWV0aG9kPT1cImV0aF9zaWduXCImJihwcm92aWRlci5pc01ldGFNYXNrfHxwcm92aWRlci5pc1N0YXR1cykpe21ldGhvZD1cInBlcnNvbmFsX3NpZ25cIjtwYXJhbXM9W3BhcmFtc1sxXSxwYXJhbXNbMF1dfWNvbnN0IHJlcXVlc3Q9e21ldGhvZDptZXRob2QscGFyYW1zOnBhcmFtcyxpZDpfbmV4dElkKyssanNvbnJwYzpcIjIuMFwifTtyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e3NlbmRGdW5jKHJlcXVlc3QsZnVuY3Rpb24oZXJyb3IscmVzdWx0KXtpZihlcnJvcil7cmV0dXJuIHJlamVjdChlcnJvcil9aWYocmVzdWx0LmVycm9yKXtjb25zdCBlcnJvcj1uZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpO2Vycm9yLmNvZGU9cmVzdWx0LmVycm9yLmNvZGU7ZXJyb3IuZGF0YT1yZXN1bHQuZXJyb3IuZGF0YTtyZXR1cm4gcmVqZWN0KGVycm9yKX1yZXNvbHZlKHJlc3VsdC5yZXN1bHQpfSl9KX19ZnVuY3Rpb24gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcil7cmV0dXJuIGZ1bmN0aW9uKG1ldGhvZCxwYXJhbXMpe2lmKHBhcmFtcz09bnVsbCl7cGFyYW1zPVtdfWlmKG1ldGhvZD09XCJldGhfc2lnblwiJiYocHJvdmlkZXIuaXNNZXRhTWFza3x8cHJvdmlkZXIuaXNTdGF0dXMpKXttZXRob2Q9XCJwZXJzb25hbF9zaWduXCI7cGFyYW1zPVtwYXJhbXNbMV0scGFyYW1zWzBdXX1yZXR1cm4gcHJvdmlkZXIucmVxdWVzdCh7bWV0aG9kOm1ldGhvZCxwYXJhbXM6cGFyYW1zfSl9fWNsYXNzIFdlYjNQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlcntjb25zdHJ1Y3Rvcihwcm92aWRlcixuZXR3b3JrKXtsb2dnZXIkRS5jaGVja05ldyhuZXcudGFyZ2V0LFdlYjNQcm92aWRlcik7aWYocHJvdmlkZXI9PW51bGwpe2xvZ2dlciRFLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIixcInByb3ZpZGVyXCIscHJvdmlkZXIpfWxldCBwYXRoPW51bGw7bGV0IGpzb25ScGNGZXRjaEZ1bmM9bnVsbDtsZXQgc3VicHJvdmlkZXI9bnVsbDtpZih0eXBlb2YgcHJvdmlkZXI9PT1cImZ1bmN0aW9uXCIpe3BhdGg9XCJ1bmtub3duOlwiO2pzb25ScGNGZXRjaEZ1bmM9cHJvdmlkZXJ9ZWxzZXtwYXRoPXByb3ZpZGVyLmhvc3R8fHByb3ZpZGVyLnBhdGh8fFwiXCI7aWYoIXBhdGgmJnByb3ZpZGVyLmlzTWV0YU1hc2spe3BhdGg9XCJtZXRhbWFza1wifXN1YnByb3ZpZGVyPXByb3ZpZGVyO2lmKHByb3ZpZGVyLnJlcXVlc3Qpe2lmKHBhdGg9PT1cIlwiKXtwYXRoPVwiZWlwLTExOTM6XCJ9anNvblJwY0ZldGNoRnVuYz1idWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKX1lbHNlIGlmKHByb3ZpZGVyLnNlbmRBc3luYyl7anNvblJwY0ZldGNoRnVuYz1idWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLHByb3ZpZGVyLnNlbmRBc3luYy5iaW5kKHByb3ZpZGVyKSl9ZWxzZSBpZihwcm92aWRlci5zZW5kKXtqc29uUnBjRmV0Y2hGdW5jPWJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIscHJvdmlkZXIuc2VuZC5iaW5kKHByb3ZpZGVyKSl9ZWxzZXtsb2dnZXIkRS50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBwcm92aWRlclwiLFwicHJvdmlkZXJcIixwcm92aWRlcil9aWYoIXBhdGgpe3BhdGg9XCJ1bmtub3duOlwifX1zdXBlcihwYXRoLG5ldHdvcmspO2RlZmluZVJlYWRPbmx5KHRoaXMsXCJqc29uUnBjRmV0Y2hGdW5jXCIsanNvblJwY0ZldGNoRnVuYyk7ZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb3ZpZGVyXCIsc3VicHJvdmlkZXIpfXNlbmQobWV0aG9kLHBhcmFtcyl7cmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QscGFyYW1zKX19XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgbG9nZ2VyJEY9bmV3IExvZ2dlcih2ZXJzaW9uJG0pO2Z1bmN0aW9uIGdldERlZmF1bHRQcm92aWRlcihuZXR3b3JrLG9wdGlvbnMpe2lmKG5ldHdvcms9PW51bGwpe25ldHdvcms9XCJob21lc3RlYWRcIn1pZih0eXBlb2YgbmV0d29yaz09PVwic3RyaW5nXCIpe2NvbnN0IG1hdGNoPW5ldHdvcmsubWF0Y2goL14od3N8aHR0cClzPzovaSk7aWYobWF0Y2gpe3N3aXRjaChtYXRjaFsxXSl7Y2FzZVwiaHR0cFwiOnJldHVybiBuZXcgSnNvblJwY1Byb3ZpZGVyKG5ldHdvcmspO2Nhc2VcIndzXCI6cmV0dXJuIG5ldyBXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrKTtkZWZhdWx0OmxvZ2dlciRGLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIFVSTCBzY2hlbWVcIixcIm5ldHdvcmtcIixuZXR3b3JrKX19fWNvbnN0IG49Z2V0TmV0d29yayhuZXR3b3JrKTtpZighbnx8IW4uX2RlZmF1bHRQcm92aWRlcil7bG9nZ2VyJEYudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGdldERlZmF1bHRQcm92aWRlciBuZXR3b3JrXCIsTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLHtvcGVyYXRpb246XCJnZXREZWZhdWx0UHJvdmlkZXJcIixuZXR3b3JrOm5ldHdvcmt9KX1yZXR1cm4gbi5fZGVmYXVsdFByb3ZpZGVyKHtGYWxsYmFja1Byb3ZpZGVyOkZhbGxiYWNrUHJvdmlkZXIsQWxjaGVteVByb3ZpZGVyOkFsY2hlbXlQcm92aWRlcixDbG91ZGZsYXJlUHJvdmlkZXI6Q2xvdWRmbGFyZVByb3ZpZGVyLEV0aGVyc2NhblByb3ZpZGVyOkV0aGVyc2NhblByb3ZpZGVyLEluZnVyYVByb3ZpZGVyOkluZnVyYVByb3ZpZGVyLEpzb25ScGNQcm92aWRlcjpKc29uUnBjUHJvdmlkZXIsTm9kZXNtaXRoUHJvdmlkZXI6Tm9kZXNtaXRoUHJvdmlkZXIsUG9ja2V0UHJvdmlkZXI6UG9ja2V0UHJvdmlkZXIsV2ViM1Byb3ZpZGVyOldlYjNQcm92aWRlcixJcGNQcm92aWRlcjpJcGNQcm92aWRlcn0sb3B0aW9ucyl9dmFyIGluZGV4JDM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUHJvdmlkZXI6UHJvdmlkZXIsQmFzZVByb3ZpZGVyOkJhc2VQcm92aWRlcixSZXNvbHZlcjpSZXNvbHZlcixVcmxKc29uUnBjUHJvdmlkZXI6VXJsSnNvblJwY1Byb3ZpZGVyLEZhbGxiYWNrUHJvdmlkZXI6RmFsbGJhY2tQcm92aWRlcixBbGNoZW15UHJvdmlkZXI6QWxjaGVteVByb3ZpZGVyLEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcjpBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIsQ2xvdWRmbGFyZVByb3ZpZGVyOkNsb3VkZmxhcmVQcm92aWRlcixFdGhlcnNjYW5Qcm92aWRlcjpFdGhlcnNjYW5Qcm92aWRlcixJbmZ1cmFQcm92aWRlcjpJbmZ1cmFQcm92aWRlcixJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcjpJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcixKc29uUnBjUHJvdmlkZXI6SnNvblJwY1Byb3ZpZGVyLEpzb25ScGNCYXRjaFByb3ZpZGVyOkpzb25ScGNCYXRjaFByb3ZpZGVyLE5vZGVzbWl0aFByb3ZpZGVyOk5vZGVzbWl0aFByb3ZpZGVyLFBvY2tldFByb3ZpZGVyOlBvY2tldFByb3ZpZGVyLFN0YXRpY0pzb25ScGNQcm92aWRlcjpTdGF0aWNKc29uUnBjUHJvdmlkZXIsV2ViM1Byb3ZpZGVyOldlYjNQcm92aWRlcixXZWJTb2NrZXRQcm92aWRlcjpXZWJTb2NrZXRQcm92aWRlcixJcGNQcm92aWRlcjpJcGNQcm92aWRlcixKc29uUnBjU2lnbmVyOkpzb25ScGNTaWduZXIsZ2V0RGVmYXVsdFByb3ZpZGVyOmdldERlZmF1bHRQcm92aWRlcixnZXROZXR3b3JrOmdldE5ldHdvcmssaXNDb21tdW5pdHlSZXNvdXJjZTppc0NvbW11bml0eVJlc291cmNlLGlzQ29tbXVuaXR5UmVzb3VyY2FibGU6aXNDb21tdW5pdHlSZXNvdXJjYWJsZSxzaG93VGhyb3R0bGVNZXNzYWdlOnNob3dUaHJvdHRsZU1lc3NhZ2UsRm9ybWF0dGVyOkZvcm1hdHRlcn0pO1widXNlIHN0cmljdFwiO2NvbnN0IHJlZ2V4Qnl0ZXM9bmV3IFJlZ0V4cChcIl5ieXRlcyhbMC05XSspJFwiKTtjb25zdCByZWdleE51bWJlcj1uZXcgUmVnRXhwKFwiXih1P2ludCkoWzAtOV0qKSRcIik7Y29uc3QgcmVnZXhBcnJheT1uZXcgUmVnRXhwKFwiXiguKilcXFxcWyhbMC05XSopXFxcXF0kXCIpO2NvbnN0IFplcm9zJDE9XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7ZnVuY3Rpb24gX3BhY2sodHlwZSx2YWx1ZSxpc0FycmF5KXtzd2l0Y2godHlwZSl7Y2FzZVwiYWRkcmVzc1wiOmlmKGlzQXJyYXkpe3JldHVybiB6ZXJvUGFkKHZhbHVlLDMyKX1yZXR1cm4gYXJyYXlpZnkodmFsdWUpO2Nhc2VcInN0cmluZ1wiOnJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZSk7Y2FzZVwiYnl0ZXNcIjpyZXR1cm4gYXJyYXlpZnkodmFsdWUpO2Nhc2VcImJvb2xcIjp2YWx1ZT12YWx1ZT9cIjB4MDFcIjpcIjB4MDBcIjtpZihpc0FycmF5KXtyZXR1cm4gemVyb1BhZCh2YWx1ZSwzMil9cmV0dXJuIGFycmF5aWZ5KHZhbHVlKX1sZXQgbWF0Y2g9dHlwZS5tYXRjaChyZWdleE51bWJlcik7aWYobWF0Y2gpe2xldCBzaXplPXBhcnNlSW50KG1hdGNoWzJdfHxcIjI1NlwiKTtpZihtYXRjaFsyXSYmU3RyaW5nKHNpemUpIT09bWF0Y2hbMl18fHNpemUlOCE9PTB8fHNpemU9PT0wfHxzaXplPjI1Nil7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBudW1iZXIgdHlwZSAtIFwiK3R5cGUpfWlmKGlzQXJyYXkpe3NpemU9MjU2fXZhbHVlPUJpZ051bWJlci5mcm9tKHZhbHVlKS50b1R3b3Moc2l6ZSk7cmV0dXJuIHplcm9QYWQodmFsdWUsc2l6ZS84KX1tYXRjaD10eXBlLm1hdGNoKHJlZ2V4Qnl0ZXMpO2lmKG1hdGNoKXtjb25zdCBzaXplPXBhcnNlSW50KG1hdGNoWzFdKTtpZihTdHJpbmcoc2l6ZSkhPT1tYXRjaFsxXXx8c2l6ZT09PTB8fHNpemU+MzIpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMgdHlwZSAtIFwiK3R5cGUpfWlmKGFycmF5aWZ5KHZhbHVlKS5ieXRlTGVuZ3RoIT09c2l6ZSl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgXCIrdHlwZSl9aWYoaXNBcnJheSl7cmV0dXJuIGFycmF5aWZ5KCh2YWx1ZStaZXJvcyQxKS5zdWJzdHJpbmcoMCw2NikpfXJldHVybiB2YWx1ZX1tYXRjaD10eXBlLm1hdGNoKHJlZ2V4QXJyYXkpO2lmKG1hdGNoJiZBcnJheS5pc0FycmF5KHZhbHVlKSl7Y29uc3QgYmFzZVR5cGU9bWF0Y2hbMV07Y29uc3QgY291bnQ9cGFyc2VJbnQobWF0Y2hbMl18fFN0cmluZyh2YWx1ZS5sZW5ndGgpKTtpZihjb3VudCE9dmFsdWUubGVuZ3RoKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBcIit0eXBlKX1jb25zdCByZXN1bHQ9W107dmFsdWUuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7cmVzdWx0LnB1c2goX3BhY2soYmFzZVR5cGUsdmFsdWUsdHJ1ZSkpfSk7cmV0dXJuIGNvbmNhdChyZXN1bHQpfXRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZSAtIFwiK3R5cGUpfWZ1bmN0aW9uIHBhY2skMSh0eXBlcyx2YWx1ZXMpe2lmKHR5cGVzLmxlbmd0aCE9dmFsdWVzLmxlbmd0aCl7dGhyb3cgbmV3IEVycm9yKFwidHlwZS92YWx1ZSBjb3VudCBtaXNtYXRjaFwiKX1jb25zdCB0aWdodD1bXTt0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUsaW5kZXgpe3RpZ2h0LnB1c2goX3BhY2sodHlwZSx2YWx1ZXNbaW5kZXhdKSl9KTtyZXR1cm4gaGV4bGlmeShjb25jYXQodGlnaHQpKX1mdW5jdGlvbiBrZWNjYWsyNTYkMSh0eXBlcyx2YWx1ZXMpe3JldHVybiBrZWNjYWsyNTYocGFjayQxKHR5cGVzLHZhbHVlcykpfWZ1bmN0aW9uIHNoYTI1NiQyKHR5cGVzLHZhbHVlcyl7cmV0dXJuIHNoYTI1NiQxKHBhY2skMSh0eXBlcyx2YWx1ZXMpKX1jb25zdCB2ZXJzaW9uJG49XCJ1bml0cy81LjEuMFwiO1widXNlIHN0cmljdFwiO2NvbnN0IGxvZ2dlciRHPW5ldyBMb2dnZXIodmVyc2lvbiRuKTtjb25zdCBuYW1lcz1bXCJ3ZWlcIixcImt3ZWlcIixcIm13ZWlcIixcImd3ZWlcIixcInN6YWJvXCIsXCJmaW5uZXlcIixcImV0aGVyXCJdO2Z1bmN0aW9uIGNvbW1pZnkodmFsdWUpe2NvbnN0IGNvbXBzPVN0cmluZyh2YWx1ZSkuc3BsaXQoXCIuXCIpO2lmKGNvbXBzLmxlbmd0aD4yfHwhY29tcHNbMF0ubWF0Y2goL14tP1swLTldKiQvKXx8Y29tcHNbMV0mJiFjb21wc1sxXS5tYXRjaCgvXlswLTldKiQvKXx8dmFsdWU9PT1cIi5cInx8dmFsdWU9PT1cIi0uXCIpe2xvZ2dlciRHLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdmFsdWVcIixcInZhbHVlXCIsdmFsdWUpfWxldCB3aG9sZT1jb21wc1swXTtsZXQgbmVnYXRpdmU9XCJcIjtpZih3aG9sZS5zdWJzdHJpbmcoMCwxKT09PVwiLVwiKXtuZWdhdGl2ZT1cIi1cIjt3aG9sZT13aG9sZS5zdWJzdHJpbmcoMSl9d2hpbGUod2hvbGUuc3Vic3RyaW5nKDAsMSk9PT1cIjBcIil7d2hvbGU9d2hvbGUuc3Vic3RyaW5nKDEpfWlmKHdob2xlPT09XCJcIil7d2hvbGU9XCIwXCJ9bGV0IHN1ZmZpeD1cIlwiO2lmKGNvbXBzLmxlbmd0aD09PTIpe3N1ZmZpeD1cIi5cIisoY29tcHNbMV18fFwiMFwiKX13aGlsZShzdWZmaXgubGVuZ3RoPjImJnN1ZmZpeFtzdWZmaXgubGVuZ3RoLTFdPT09XCIwXCIpe3N1ZmZpeD1zdWZmaXguc3Vic3RyaW5nKDAsc3VmZml4Lmxlbmd0aC0xKX1jb25zdCBmb3JtYXR0ZWQ9W107d2hpbGUod2hvbGUubGVuZ3RoKXtpZih3aG9sZS5sZW5ndGg8PTMpe2Zvcm1hdHRlZC51bnNoaWZ0KHdob2xlKTticmVha31lbHNle2NvbnN0IGluZGV4PXdob2xlLmxlbmd0aC0zO2Zvcm1hdHRlZC51bnNoaWZ0KHdob2xlLnN1YnN0cmluZyhpbmRleCkpO3dob2xlPXdob2xlLnN1YnN0cmluZygwLGluZGV4KX19cmV0dXJuIG5lZ2F0aXZlK2Zvcm1hdHRlZC5qb2luKFwiLFwiKStzdWZmaXh9ZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsdW5pdE5hbWUpe2lmKHR5cGVvZiB1bml0TmFtZT09PVwic3RyaW5nXCIpe2NvbnN0IGluZGV4PW5hbWVzLmluZGV4T2YodW5pdE5hbWUpO2lmKGluZGV4IT09LTEpe3VuaXROYW1lPTMqaW5kZXh9fXJldHVybiBmb3JtYXRGaXhlZCh2YWx1ZSx1bml0TmFtZSE9bnVsbD91bml0TmFtZToxOCl9ZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSx1bml0TmFtZSl7aWYodHlwZW9mIHZhbHVlIT09XCJzdHJpbmdcIil7bG9nZ2VyJEcudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLFwidmFsdWVcIix2YWx1ZSl9aWYodHlwZW9mIHVuaXROYW1lPT09XCJzdHJpbmdcIil7Y29uc3QgaW5kZXg9bmFtZXMuaW5kZXhPZih1bml0TmFtZSk7aWYoaW5kZXghPT0tMSl7dW5pdE5hbWU9MyppbmRleH19cmV0dXJuIHBhcnNlRml4ZWQodmFsdWUsdW5pdE5hbWUhPW51bGw/dW5pdE5hbWU6MTgpfWZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSl7cmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwxOCl9ZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcil7cmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsMTgpfVwidXNlIHN0cmljdFwiO3ZhciB1dGlscyQxPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFiaUNvZGVyOkFiaUNvZGVyLGRlZmF1bHRBYmlDb2RlcjpkZWZhdWx0QWJpQ29kZXIsRnJhZ21lbnQ6RnJhZ21lbnQsRXZlbnRGcmFnbWVudDpFdmVudEZyYWdtZW50LEZ1bmN0aW9uRnJhZ21lbnQ6RnVuY3Rpb25GcmFnbWVudCxQYXJhbVR5cGU6UGFyYW1UeXBlLEZvcm1hdFR5cGVzOkZvcm1hdFR5cGVzLGNoZWNrUmVzdWx0RXJyb3JzOmNoZWNrUmVzdWx0RXJyb3JzLExvZ2dlcjpMb2dnZXIsUkxQOmluZGV4LF9mZXRjaERhdGE6X2ZldGNoRGF0YSxmZXRjaEpzb246ZmV0Y2hKc29uLHBvbGw6cG9sbCxjaGVja1Byb3BlcnRpZXM6Y2hlY2tQcm9wZXJ0aWVzLGRlZXBDb3B5OmRlZXBDb3B5LGRlZmluZVJlYWRPbmx5OmRlZmluZVJlYWRPbmx5LGdldFN0YXRpYzpnZXRTdGF0aWMscmVzb2x2ZVByb3BlcnRpZXM6cmVzb2x2ZVByb3BlcnRpZXMsc2hhbGxvd0NvcHk6c2hhbGxvd0NvcHksYXJyYXlpZnk6YXJyYXlpZnksY29uY2F0OmNvbmNhdCxzdHJpcFplcm9zOnN0cmlwWmVyb3MsemVyb1BhZDp6ZXJvUGFkLGlzQnl0ZXM6aXNCeXRlcyxpc0J5dGVzTGlrZTppc0J5dGVzTGlrZSxkZWZhdWx0UGF0aDpkZWZhdWx0UGF0aCxIRE5vZGU6SEROb2RlLFNpZ25pbmdLZXk6U2lnbmluZ0tleSxJbnRlcmZhY2U6SW50ZXJmYWNlLExvZ0Rlc2NyaXB0aW9uOkxvZ0Rlc2NyaXB0aW9uLFRyYW5zYWN0aW9uRGVzY3JpcHRpb246VHJhbnNhY3Rpb25EZXNjcmlwdGlvbixiYXNlNTg6QmFzZTU4LGJhc2U2NDppbmRleCQyLGhleGxpZnk6aGV4bGlmeSxpc0hleFN0cmluZzppc0hleFN0cmluZyxoZXhDb25jYXQ6aGV4Q29uY2F0LGhleFN0cmlwWmVyb3M6aGV4U3RyaXBaZXJvcyxoZXhWYWx1ZTpoZXhWYWx1ZSxoZXhaZXJvUGFkOmhleFplcm9QYWQsaGV4RGF0YUxlbmd0aDpoZXhEYXRhTGVuZ3RoLGhleERhdGFTbGljZTpoZXhEYXRhU2xpY2UsbmFtZXByZXA6bmFtZXByZXAsX3RvRXNjYXBlZFV0ZjhTdHJpbmc6X3RvRXNjYXBlZFV0ZjhTdHJpbmcsdG9VdGY4Qnl0ZXM6dG9VdGY4Qnl0ZXMsdG9VdGY4Q29kZVBvaW50czp0b1V0ZjhDb2RlUG9pbnRzLHRvVXRmOFN0cmluZzp0b1V0ZjhTdHJpbmcsVXRmOEVycm9yRnVuY3M6VXRmOEVycm9yRnVuY3MsZm9ybWF0Qnl0ZXMzMlN0cmluZzpmb3JtYXRCeXRlczMyU3RyaW5nLHBhcnNlQnl0ZXMzMlN0cmluZzpwYXJzZUJ5dGVzMzJTdHJpbmcsaGFzaE1lc3NhZ2U6aGFzaE1lc3NhZ2UsbmFtZWhhc2g6bmFtZWhhc2gsaXNWYWxpZE5hbWU6aXNWYWxpZE5hbWUsaWQ6aWQsX1R5cGVkRGF0YUVuY29kZXI6VHlwZWREYXRhRW5jb2RlcixnZXRBZGRyZXNzOmdldEFkZHJlc3MsZ2V0SWNhcEFkZHJlc3M6Z2V0SWNhcEFkZHJlc3MsZ2V0Q29udHJhY3RBZGRyZXNzOmdldENvbnRyYWN0QWRkcmVzcyxnZXRDcmVhdGUyQWRkcmVzczpnZXRDcmVhdGUyQWRkcmVzcyxpc0FkZHJlc3M6aXNBZGRyZXNzLGZvcm1hdEV0aGVyOmZvcm1hdEV0aGVyLHBhcnNlRXRoZXI6cGFyc2VFdGhlcixmb3JtYXRVbml0czpmb3JtYXRVbml0cyxwYXJzZVVuaXRzOnBhcnNlVW5pdHMsY29tbWlmeTpjb21taWZ5LGNvbXB1dGVIbWFjOmNvbXB1dGVIbWFjLGtlY2NhazI1NjprZWNjYWsyNTYscmlwZW1kMTYwOnJpcGVtZDE2MCQxLHNoYTI1NjpzaGEyNTYkMSxzaGE1MTI6c2hhNTEyJDEscmFuZG9tQnl0ZXM6cmFuZG9tQnl0ZXMsc2h1ZmZsZWQ6c2h1ZmZsZWQsc29saWRpdHlQYWNrOnBhY2skMSxzb2xpZGl0eUtlY2NhazI1NjprZWNjYWsyNTYkMSxzb2xpZGl0eVNoYTI1NjpzaGEyNTYkMixzcGxpdFNpZ25hdHVyZTpzcGxpdFNpZ25hdHVyZSxqb2luU2lnbmF0dXJlOmpvaW5TaWduYXR1cmUsYWNjZXNzTGlzdGlmeTphY2Nlc3NMaXN0aWZ5LHBhcnNlVHJhbnNhY3Rpb246cGFyc2Usc2VyaWFsaXplVHJhbnNhY3Rpb246c2VyaWFsaXplLGdldEpzb25XYWxsZXRBZGRyZXNzOmdldEpzb25XYWxsZXRBZGRyZXNzLGNvbXB1dGVBZGRyZXNzOmNvbXB1dGVBZGRyZXNzLHJlY292ZXJBZGRyZXNzOnJlY292ZXJBZGRyZXNzLGNvbXB1dGVQdWJsaWNLZXk6Y29tcHV0ZVB1YmxpY0tleSxyZWNvdmVyUHVibGljS2V5OnJlY292ZXJQdWJsaWNLZXksdmVyaWZ5TWVzc2FnZTp2ZXJpZnlNZXNzYWdlLHZlcmlmeVR5cGVkRGF0YTp2ZXJpZnlUeXBlZERhdGEsbW5lbW9uaWNUb0VudHJvcHk6bW5lbW9uaWNUb0VudHJvcHksZW50cm9weVRvTW5lbW9uaWM6ZW50cm9weVRvTW5lbW9uaWMsaXNWYWxpZE1uZW1vbmljOmlzVmFsaWRNbmVtb25pYyxtbmVtb25pY1RvU2VlZDptbmVtb25pY1RvU2VlZCxnZXQgU3VwcG9ydGVkQWxnb3JpdGhtKCl7cmV0dXJuIFN1cHBvcnRlZEFsZ29yaXRobX0sZ2V0IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSgpe3JldHVybiBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm19LGdldCBVdGY4RXJyb3JSZWFzb24oKXtyZXR1cm4gVXRmOEVycm9yUmVhc29ufSxJbmRleGVkOkluZGV4ZWR9KTtjb25zdCB2ZXJzaW9uJG89XCJldGhlcnMvNS4xLjRcIjtcInVzZSBzdHJpY3RcIjtjb25zdCBsb2dnZXIkSD1uZXcgTG9nZ2VyKHZlcnNpb24kbyk7dmFyIGV0aGVycz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxTaWduZXI6U2lnbmVyLFdhbGxldDpXYWxsZXQsVm9pZFNpZ25lcjpWb2lkU2lnbmVyLGdldERlZmF1bHRQcm92aWRlcjpnZXREZWZhdWx0UHJvdmlkZXIscHJvdmlkZXJzOmluZGV4JDMsQmFzZUNvbnRyYWN0OkJhc2VDb250cmFjdCxDb250cmFjdDpDb250cmFjdCxDb250cmFjdEZhY3Rvcnk6Q29udHJhY3RGYWN0b3J5LEJpZ051bWJlcjpCaWdOdW1iZXIsRml4ZWROdW1iZXI6Rml4ZWROdW1iZXIsY29uc3RhbnRzOmluZGV4JDEsZ2V0IGVycm9ycygpe3JldHVybiBFcnJvckNvZGV9LGxvZ2dlcjpsb2dnZXIkSCx1dGlsczp1dGlscyQxLHdvcmRsaXN0czp3b3JkbGlzdHMsdmVyc2lvbjp2ZXJzaW9uJG8sV29yZGxpc3Q6V29yZGxpc3R9KTtcInVzZSBzdHJpY3RcIjt0cnl7Y29uc3QgYW55R2xvYmFsPXdpbmRvdztpZihhbnlHbG9iYWwuX2V0aGVycz09bnVsbCl7YW55R2xvYmFsLl9ldGhlcnM9ZXRoZXJzfX1jYXRjaChlcnJvcil7fWV4cG9ydHtCYXNlQ29udHJhY3QsQmlnTnVtYmVyLENvbnRyYWN0LENvbnRyYWN0RmFjdG9yeSxGaXhlZE51bWJlcixTaWduZXIsVm9pZFNpZ25lcixXYWxsZXQsV29yZGxpc3QsaW5kZXgkMSBhcyBjb25zdGFudHMsRXJyb3JDb2RlIGFzIGVycm9ycyxldGhlcnMsZ2V0RGVmYXVsdFByb3ZpZGVyLGxvZ2dlciRIIGFzIGxvZ2dlcixpbmRleCQzIGFzIHByb3ZpZGVycyx1dGlscyQxIGFzIHV0aWxzLHZlcnNpb24kbyBhcyB2ZXJzaW9uLHdvcmRsaXN0c307IiwiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSBcIi4vZXRoZXJzLTUuMS5lc20ubWluLmpzXCI7XHJcbmltcG9ydCB7IGdlblJhbmRvbUxvZ2luTXNnIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2dpbih3YWxsZXRfYWRkcmVzcywgd2ViMylcclxue1xyXG4gICAgY29uc3QgbXNnID0gZ2VuUmFuZG9tTG9naW5Nc2coKTtcclxuXHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcih3ZWIzKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbmVyLnNpZ25NZXNzYWdlKG1zZyk7XHJcblxyXG4gICAgYXdhaXQgaGFuZGxlX2F1dGgod2FsbGV0X2FkZHJlc3MsIG1zZywgc2lnbmF0dXJlKTtcclxuXHJcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IFwiL2luZGV4XCI7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVfYXV0aCh3YWxsZXRfYWRkcmVzcywgbXNnLCBzaWduYXR1cmUpXHJcbntcclxuICAgIGNvbnNvbGUubG9nKHdhbGxldF9hZGRyZXNzKTtcclxuICAgIGNvbnNvbGUubG9nKHNpZ25hdHVyZSk7XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IHthZGRyZXNzOiB3YWxsZXRfYWRkcmVzcywgbWVzc2FnZTogbXNnLCBzaWduYXR1cmU6IHNpZ25hdHVyZX1cclxuXHJcbiAgICBhd2FpdCBmZXRjaCgnbG9naW4nLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXHJcbiAgICAgICAgfSk7XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkTGVhZGluZ1plcm9zKG51bWJlciwgdGFyZ2V0TGVuZ3RoKSB7XG4gIHZhciBzaWduID0gbnVtYmVyIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgb3V0cHV0ID0gTWF0aC5hYnMobnVtYmVyKS50b1N0cmluZygpO1xuXG4gIHdoaWxlIChvdXRwdXQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgb3V0cHV0ID0gJzAnICsgb3V0cHV0O1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKyBvdXRwdXQ7XG59IiwiaW1wb3J0IGdldFVUQ0RheU9mWWVhciBmcm9tIFwiLi4vLi4vLi4vX2xpYi9nZXRVVENEYXlPZlllYXIvaW5kZXguanNcIjtcbmltcG9ydCBnZXRVVENJU09XZWVrIGZyb20gXCIuLi8uLi8uLi9fbGliL2dldFVUQ0lTT1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCBnZXRVVENJU09XZWVrWWVhciBmcm9tIFwiLi4vLi4vLi4vX2xpYi9nZXRVVENJU09XZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IGdldFVUQ1dlZWsgZnJvbSBcIi4uLy4uLy4uL19saWIvZ2V0VVRDV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IGdldFVUQ1dlZWtZZWFyIGZyb20gXCIuLi8uLi8uLi9fbGliL2dldFVUQ1dlZWtZZWFyL2luZGV4LmpzXCI7XG5pbXBvcnQgYWRkTGVhZGluZ1plcm9zIGZyb20gXCIuLi8uLi9hZGRMZWFkaW5nWmVyb3MvaW5kZXguanNcIjtcbmltcG9ydCBsaWdodEZvcm1hdHRlcnMgZnJvbSBcIi4uL2xpZ2h0Rm9ybWF0dGVycy9pbmRleC5qc1wiO1xudmFyIGRheVBlcmlvZEVudW0gPSB7XG4gIGFtOiAnYW0nLFxuICBwbTogJ3BtJyxcbiAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gIG5vb246ICdub29uJyxcbiAgbW9ybmluZzogJ21vcm5pbmcnLFxuICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICBldmVuaW5nOiAnZXZlbmluZycsXG4gIG5pZ2h0OiAnbmlnaHQnXG59O1xuLypcbiAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgTWlsbGlzZWNvbmRzIGluIGRheSAgICAgICAgICAgIHxcbiAqIHwgIGIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgIHwgIEIgIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgIHxcbiAqIHwgIGMgIHwgU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsgIHwgIEMqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGUgIHwgTG9jYWwgZGF5IG9mIHdlZWsgICAgICAgICAgICAgIHwgIEUgIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGYgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEYqIHwgRGF5IG9mIHdlZWsgaW4gbW9udGggICAgICAgICAgIHxcbiAqIHwgIGcqIHwgTW9kaWZpZWQgSnVsaWFuIGRheSAgICAgICAgICAgIHwgIEcgIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGkhIHwgSVNPIGRheSBvZiB3ZWVrICAgICAgICAgICAgICAgIHwgIEkhIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgIHxcbiAqIHwgIGoqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHwgIEoqIHwgTG9jYWxpemVkIGhvdXIgdy9vIGRheSBwZXJpb2QgIHxcbiAqIHwgIGsgIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgIHwgIEsgIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGwqIHwgKGRlcHJlY2F0ZWQpICAgICAgICAgICAgICAgICAgIHwgIEwgIHwgU3RhbmQtYWxvbmUgbW9udGggICAgICAgICAgICAgIHxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG8hIHwgT3JkaW5hbCBudW1iZXIgbW9kaWZpZXIgICAgICAgIHwgIE8gIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHAhIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgIHwgIFAhIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgIHxcbiAqIHwgIHEgIHwgU3RhbmQtYWxvbmUgcXVhcnRlciAgICAgICAgICAgIHwgIFEgIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHIqIHwgUmVsYXRlZCBHcmVnb3JpYW4geWVhciAgICAgICAgIHwgIFIhIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgIHxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAqIHwgIHQhIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgIHwgIFQhIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgIHxcbiAqIHwgIHUgIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgIHwgIFUqIHwgQ3ljbGljIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHYqIHwgVGltZXpvbmUgKGdlbmVyaWMgbm9uLWxvY2F0LikgIHwgIFYqIHwgVGltZXpvbmUgKGxvY2F0aW9uKSAgICAgICAgICAgIHxcbiAqIHwgIHcgIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgIHwgIFcqIHwgV2VlayBvZiBtb250aCAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHggIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgIHwgIFggIHwgVGltZXpvbmUgKElTTy04NjAxKSAgICAgICAgICAgIHxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgIHxcbiAqIHwgIHogIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pIHwgIFoqIHwgVGltZXpvbmUgKGFsaWFzZXMpICAgICAgICAgICAgIHxcbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgISBhcmUgbm9uLXN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgZGF0ZS1mbnM6XG4gKiAtIGBvYCBtb2RpZmllcyB0aGUgcHJldmlvdXMgdG9rZW4gdG8gdHVybiBpdCBpbnRvIGFuIG9yZGluYWwgKHNlZSBgZm9ybWF0YCBkb2NzKVxuICogLSBgaWAgaXMgSVNPIGRheSBvZiB3ZWVrLiBGb3IgYGlgIGFuZCBgaWlgIGlzIHJldHVybnMgbnVtZXJpYyBJU08gd2VlayBkYXlzLFxuICogICBpLmUuIDcgZm9yIFN1bmRheSwgMSBmb3IgTW9uZGF5LCBldGMuXG4gKiAtIGBJYCBpcyBJU08gd2VlayBvZiB5ZWFyLCBhcyBvcHBvc2VkIHRvIGB3YCB3aGljaCBpcyBsb2NhbCB3ZWVrIG9mIHllYXIuXG4gKiAtIGBSYCBpcyBJU08gd2Vlay1udW1iZXJpbmcgeWVhciwgYXMgb3Bwb3NlZCB0byBgWWAgd2hpY2ggaXMgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhci5cbiAqICAgYFJgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgSWAgYW5kIGBpYFxuICogICBmb3IgdW5pdmVyc2FsIElTTyB3ZWVrLW51bWJlcmluZyBkYXRlLCB3aGVyZWFzXG4gKiAgIGBZYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHdgIGFuZCBgZWBcbiAqICAgZm9yIHdlZWstbnVtYmVyaW5nIGRhdGUgc3BlY2lmaWMgdG8gdGhlIGxvY2FsZS5cbiAqIC0gYFBgIGlzIGxvbmcgbG9jYWxpemVkIGRhdGUgZm9ybWF0XG4gKiAtIGBwYCBpcyBsb25nIGxvY2FsaXplZCB0aW1lIGZvcm1hdFxuICovXG5cbnZhciBmb3JtYXR0ZXJzID0ge1xuICAvLyBFcmFcbiAgRzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBlcmEgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPiAwID8gMSA6IDA7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBBRCwgQkNcbiAgICAgIGNhc2UgJ0cnOlxuICAgICAgY2FzZSAnR0cnOlxuICAgICAgY2FzZSAnR0dHJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEEsIEJcblxuICAgICAgY2FzZSAnR0dHR0cnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93J1xuICAgICAgICB9KTtcbiAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XG5cbiAgICAgIGNhc2UgJ0dHR0cnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gWWVhclxuICB5OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgLy8gT3JkaW5hbCBudW1iZXJcbiAgICBpZiAodG9rZW4gPT09ICd5bycpIHtcbiAgICAgIHZhciBzaWduZWRZZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpOyAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuXG4gICAgICB2YXIgeWVhciA9IHNpZ25lZFllYXIgPiAwID8gc2lnbmVkWWVhciA6IDEgLSBzaWduZWRZZWFyO1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoeWVhciwge1xuICAgICAgICB1bml0OiAneWVhcidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMueShkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJcbiAgWTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBzaWduZWRXZWVrWWVhciA9IGdldFVUQ1dlZWtZZWFyKGRhdGUsIG9wdGlvbnMpOyAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuXG4gICAgdmFyIHdlZWtZZWFyID0gc2lnbmVkV2Vla1llYXIgPiAwID8gc2lnbmVkV2Vla1llYXIgOiAxIC0gc2lnbmVkV2Vla1llYXI7IC8vIFR3byBkaWdpdCB5ZWFyXG5cbiAgICBpZiAodG9rZW4gPT09ICdZWScpIHtcbiAgICAgIHZhciB0d29EaWdpdFllYXIgPSB3ZWVrWWVhciAlIDEwMDtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModHdvRGlnaXRZZWFyLCAyKTtcbiAgICB9IC8vIE9yZGluYWwgbnVtYmVyXG5cblxuICAgIGlmICh0b2tlbiA9PT0gJ1lvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIod2Vla1llYXIsIHtcbiAgICAgICAgdW5pdDogJ3llYXInXG4gICAgICB9KTtcbiAgICB9IC8vIFBhZGRpbmdcblxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh3ZWVrWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAgUjogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgdmFyIGlzb1dlZWtZZWFyID0gZ2V0VVRDSVNPV2Vla1llYXIoZGF0ZSk7IC8vIFBhZGRpbmdcblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvV2Vla1llYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEV4dGVuZGVkIHllYXIuIFRoaXMgaXMgYSBzaW5nbGUgbnVtYmVyIGRlc2lnbmF0aW5nIHRoZSB5ZWFyIG9mIHRoaXMgY2FsZW5kYXIgc3lzdGVtLlxuICAvLyBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgbG9jYWxpemVycyBhcmUgQi5DLiB5ZWFyczpcbiAgLy8gfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAgLy8gfC0tLS0tLXwtLS0tLXwtLS0tLXxcbiAgLy8gfCBBQyAxIHwgICAxIHwgICAxIHxcbiAgLy8gfCBCQyAxIHwgICAxIHwgICAwIHxcbiAgLy8gfCBCQyAyIHwgICAyIHwgIC0xIHxcbiAgLy8gQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICAvLyB3aGlsZSBgdXVgIHBhZHMgc2luZ2xlIGRpZ2l0IHllYXJzIHRvIDIgY2hhcmFjdGVycyBhbmQgcmV0dXJucyBvdGhlciB5ZWFycyB1bmNoYW5nZWQuXG4gIHU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gUXVhcnRlclxuICBROiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMyk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhxdWFydGVyKTtcbiAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG5cbiAgICAgIGNhc2UgJ1FRJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhxdWFydGVyLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuXG4gICAgICBjYXNlICdRbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB1bml0OiAncXVhcnRlcidcbiAgICAgICAgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuXG4gICAgICBjYXNlICdRUVEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG5cbiAgICAgIGNhc2UgJ1FRUVFRJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuXG4gICAgICBjYXNlICdRUVFRJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIHF1YXJ0ZXJcbiAgcTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSAvIDMpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgY2FzZSAncSc6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuXG4gICAgICBjYXNlICdxcSc6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MocXVhcnRlciwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcblxuICAgICAgY2FzZSAncW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7XG4gICAgICAgICAgdW5pdDogJ3F1YXJ0ZXInXG4gICAgICAgIH0pO1xuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcblxuICAgICAgY2FzZSAncXFxJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuXG4gICAgICBjYXNlICdxcXFxcSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cblxuICAgICAgY2FzZSAncXFxcSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBNb250aFxuICBNOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICBjYXNlICdNTSc6XG4gICAgICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMuTShkYXRlLCB0b2tlbik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG5cbiAgICAgIGNhc2UgJ01vJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobW9udGggKyAxLCB7XG4gICAgICAgICAgdW5pdDogJ21vbnRoJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuXG4gICAgICBjYXNlICdNTU0nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBKLCBGLCAuLi4sIERcblxuICAgICAgY2FzZSAnTU1NTU0nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcblxuICAgICAgY2FzZSAnTU1NTSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFN0YW5kLWFsb25lIG1vbnRoXG4gIEw6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhtb250aCArIDEpO1xuICAgICAgLy8gMDEsIDAyLCAuLi4sIDEyXG5cbiAgICAgIGNhc2UgJ0xMJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhtb250aCArIDEsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxuXG4gICAgICBjYXNlICdMbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoICsgMSwge1xuICAgICAgICAgIHVuaXQ6ICdtb250aCdcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcblxuICAgICAgY2FzZSAnTExMJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG5cbiAgICAgIGNhc2UgJ0xMTExMJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG5cbiAgICAgIGNhc2UgJ0xMTEwnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBMb2NhbCB3ZWVrIG9mIHllYXJcbiAgdzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciB3ZWVrID0gZ2V0VVRDV2VlayhkYXRlLCBvcHRpb25zKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJ3dvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIod2Vlaywge1xuICAgICAgICB1bml0OiAnd2VlaydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3Mod2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSVNPIHdlZWsgb2YgeWVhclxuICBJOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGlzb1dlZWsgPSBnZXRVVENJU09XZWVrKGRhdGUpO1xuXG4gICAgaWYgKHRva2VuID09PSAnSW8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihpc29XZWVrLCB7XG4gICAgICAgIHVuaXQ6ICd3ZWVrJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdkbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDRGF0ZSgpLCB7XG4gICAgICAgIHVuaXQ6ICdkYXRlJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5kKGRhdGUsIHRva2VuKTtcbiAgfSxcbiAgLy8gRGF5IG9mIHllYXJcbiAgRDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBkYXlPZlllYXIgPSBnZXRVVENEYXlPZlllYXIoZGF0ZSk7XG5cbiAgICBpZiAodG9rZW4gPT09ICdEbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRheU9mWWVhciwge1xuICAgICAgICB1bml0OiAnZGF5T2ZZZWFyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXlPZlllYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSAnRSc6XG4gICAgICBjYXNlICdFRSc6XG4gICAgICBjYXNlICdFRUUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnRUVFRUUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdFRUVFRUUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnRUVFRSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gTG9jYWwgZGF5IG9mIHdlZWtcbiAgZTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuICAgIHZhciBsb2NhbERheU9mV2VlayA9IChkYXlPZldlZWsgLSBvcHRpb25zLndlZWtTdGFydHNPbiArIDgpICUgNyB8fCA3O1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChOdGggZGF5IG9mIHdlZWsgd2l0aCBjdXJyZW50IGxvY2FsZSBvciB3ZWVrU3RhcnRzT24pXG4gICAgICBjYXNlICdlJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsb2NhbERheU9mV2Vlayk7XG4gICAgICAvLyBQYWRkZWQgbnVtZXJpY2FsIHZhbHVlXG5cbiAgICAgIGNhc2UgJ2VlJzpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhsb2NhbERheU9mV2VlaywgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCA3dGhcblxuICAgICAgY2FzZSAnZW8nOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihsb2NhbERheU9mV2Vlaywge1xuICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdlZWUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFRcblxuICAgICAgY2FzZSAnZWVlZWUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuXG4gICAgICBjYXNlICdlZWVlZWUnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnc2hvcnQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcblxuICAgICAgY2FzZSAnZWVlZSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiAnd2lkZScsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcbiAgYzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xuICAgIHZhciBsb2NhbERheU9mV2VlayA9IChkYXlPZldlZWsgLSBvcHRpb25zLndlZWtTdGFydHNPbiArIDgpICUgNyB8fCA3O1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChzYW1lIGFzIGluIGBlYClcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcblxuICAgICAgY2FzZSAnY2MnOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGxvY2FsRGF5T2ZXZWVrLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgN3RoXG5cbiAgICAgIGNhc2UgJ2NvJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobG9jYWxEYXlPZldlZWssIHtcbiAgICAgICAgICB1bml0OiAnZGF5J1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnY2NjJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG5cbiAgICAgIGNhc2UgJ2NjY2NjJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ25hcnJvdycsXG4gICAgICAgICAgY29udGV4dDogJ3N0YW5kYWxvbmUnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcblxuICAgICAgY2FzZSAnY2NjY2NjJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3Nob3J0JyxcbiAgICAgICAgICBjb250ZXh0OiAnc3RhbmRhbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG5cbiAgICAgIGNhc2UgJ2NjY2MnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdzdGFuZGFsb25lJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIElTTyBkYXkgb2Ygd2Vla1xuICBpOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgdmFyIGlzb0RheU9mV2VlayA9IGRheU9mV2VlayA9PT0gMCA/IDcgOiBkYXlPZldlZWs7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAyXG4gICAgICBjYXNlICdpJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpc29EYXlPZldlZWspO1xuICAgICAgLy8gMDJcblxuICAgICAgY2FzZSAnaWknOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb0RheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDJuZFxuXG4gICAgICBjYXNlICdpbyc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb0RheU9mV2Vlaywge1xuICAgICAgICAgIHVuaXQ6ICdkYXknXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlXG5cbiAgICAgIGNhc2UgJ2lpaSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdhYmJyZXZpYXRlZCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuXG4gICAgICBjYXNlICdpaWlpaSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICduYXJyb3cnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG5cbiAgICAgIGNhc2UgJ2lpaWlpaSc6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICdzaG9ydCcsXG4gICAgICAgICAgY29udGV4dDogJ2Zvcm1hdHRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuXG4gICAgICBjYXNlICdpaWlpJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6ICd3aWRlJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBBTSBvciBQTVxuICBhOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWUgPSBob3VycyAvIDEyID49IDEgPyAncG0nIDogJ2FtJztcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnYWEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYWFhJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgY2FzZSAnYWFhYWEnOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2FhYWEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIEFNLCBQTSwgbWlkbmlnaHQsIG5vb25cbiAgYjogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlO1xuXG4gICAgaWYgKGhvdXJzID09PSAxMikge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5ub29uO1xuICAgIH0gZWxzZSBpZiAoaG91cnMgPT09IDApIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubWlkbmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGhvdXJzIC8gMTIgPj0gMSA/ICdwbScgOiAnYW0nO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJ2InOlxuICAgICAgY2FzZSAnYmInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYmJiJzpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ2FiYnJldmlhdGVkJyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgY2FzZSAnYmJiYmInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2JiYmInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIGluIHRoZSBtb3JuaW5nLCBpbiB0aGUgYWZ0ZXJub29uLCBpbiB0aGUgZXZlbmluZywgYXQgbmlnaHRcbiAgQjogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlO1xuXG4gICAgaWYgKGhvdXJzID49IDE3KSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLmV2ZW5pbmc7XG4gICAgfSBlbHNlIGlmIChob3VycyA+PSAxMikge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5hZnRlcm5vb247XG4gICAgfSBlbHNlIGlmIChob3VycyA+PSA0KSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm1vcm5pbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubmlnaHQ7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSAnQic6XG4gICAgICBjYXNlICdCQic6XG4gICAgICBjYXNlICdCQkInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnYWJicmV2aWF0ZWQnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnQkJCQkInOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge1xuICAgICAgICAgIHdpZHRoOiAnbmFycm93JyxcbiAgICAgICAgICBjb250ZXh0OiAnZm9ybWF0dGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ0JCQkInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogJ3dpZGUnLFxuICAgICAgICAgIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIEhvdXIgWzEtMTJdXG4gIGg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdobycpIHtcbiAgICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSAlIDEyO1xuICAgICAgaWYgKGhvdXJzID09PSAwKSBob3VycyA9IDEyO1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLmgoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBIb3VyIFswLTIzXVxuICBIOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSAnSG8nKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ0hvdXJzKCksIHtcbiAgICAgICAgdW5pdDogJ2hvdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLkgoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBIb3VyIFswLTExXVxuICBLOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpICUgMTI7XG5cbiAgICBpZiAodG9rZW4gPT09ICdLbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gSG91ciBbMS0yNF1cbiAgazogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBpZiAoaG91cnMgPT09IDApIGhvdXJzID0gMjQ7XG5cbiAgICBpZiAodG9rZW4gPT09ICdrbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7XG4gICAgICAgIHVuaXQ6ICdob3VyJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gTWludXRlXG4gIG06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09ICdtbycpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDTWludXRlcygpLCB7XG4gICAgICAgIHVuaXQ6ICdtaW51dGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLm0oZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBTZWNvbmRcbiAgczogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gJ3NvJykge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRVVENTZWNvbmRzKCksIHtcbiAgICAgICAgdW5pdDogJ3NlY29uZCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMucyhkYXRlLCB0b2tlbik7XG4gIH0sXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLlMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuICAvLyBUaW1lem9uZSAoSVNPLTg2MDEuIElmIG9mZnNldCBpcyAwLCBvdXRwdXQgaXMgYWx3YXlzIGAnWidgKVxuICBYOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIGlmICh0aW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdaJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSAnWCc6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXModGltZXpvbmVPZmZzZXQpO1xuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhgXG5cbiAgICAgIGNhc2UgJ1hYWFgnOlxuICAgICAgY2FzZSAnWFgnOlxuICAgICAgICAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYWGBcblxuICAgICAgY2FzZSAnWFhYWFgnOlxuICAgICAgY2FzZSAnWFhYJzogLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aCBgOmAgZGVsaW1pdGVyXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCwgJzonKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBgJyswMDowMCdgIG9yIGVxdWl2YWxlbnQpXG4gIHg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmVXaXRoT3B0aW9uYWxNaW51dGVzKHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4YFxuXG4gICAgICBjYXNlICd4eHh4JzpcbiAgICAgIGNhc2UgJ3h4JzpcbiAgICAgICAgLy8gSG91cnMgYW5kIG1pbnV0ZXMgd2l0aG91dCBgOmAgZGVsaW1pdGVyXG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZSh0aW1lem9uZU9mZnNldCk7XG4gICAgICAvLyBIb3VycywgbWludXRlcyBhbmQgb3B0aW9uYWwgc2Vjb25kcyB3aXRoIGA6YCBkZWxpbWl0ZXJcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGB4eHhgXG5cbiAgICAgIGNhc2UgJ3h4eHh4JzpcbiAgICAgIGNhc2UgJ3h4eCc6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBUaW1lem9uZSAoR01UKVxuICBPOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFNob3J0XG4gICAgICBjYXNlICdPJzpcbiAgICAgIGNhc2UgJ09PJzpcbiAgICAgIGNhc2UgJ09PTyc6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgICAvLyBMb25nXG5cbiAgICAgIGNhc2UgJ09PT08nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0aW9uKVxuICB6OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFNob3J0XG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ3p6JzpcbiAgICAgIGNhc2UgJ3p6eic6XG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgICAvLyBMb25nXG5cbiAgICAgIGNhc2UgJ3p6enonOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdHTVQnICsgZm9ybWF0VGltZXpvbmUodGltZXpvbmVPZmZzZXQsICc6Jyk7XG4gICAgfVxuICB9LFxuICAvLyBTZWNvbmRzIHRpbWVzdGFtcFxuICB0OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIF9sb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICB2YXIgdGltZXN0YW1wID0gTWF0aC5mbG9vcihvcmlnaW5hbERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0aW1lc3RhbXAsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAgVDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XG4gICAgdmFyIHRpbWVzdGFtcCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0aW1lc3RhbXAsIHRva2VuLmxlbmd0aCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lU2hvcnQob2Zmc2V0LCBkaXJ0eURlbGltaXRlcikge1xuICB2YXIgc2lnbiA9IG9mZnNldCA+IDAgPyAnLScgOiAnKyc7XG4gIHZhciBhYnNPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKGFic09mZnNldCAvIDYwKTtcbiAgdmFyIG1pbnV0ZXMgPSBhYnNPZmZzZXQgJSA2MDtcblxuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKTtcbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBkaXJ0eURlbGltaXRlciB8fCAnJztcbiAgcmV0dXJuIHNpZ24gKyBTdHJpbmcoaG91cnMpICsgZGVsaW1pdGVyICsgYWRkTGVhZGluZ1plcm9zKG1pbnV0ZXMsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXMob2Zmc2V0LCBkaXJ0eURlbGltaXRlcikge1xuICBpZiAob2Zmc2V0ICUgNjAgPT09IDApIHtcbiAgICB2YXIgc2lnbiA9IG9mZnNldCA+IDAgPyAnLScgOiAnKyc7XG4gICAgcmV0dXJuIHNpZ24gKyBhZGRMZWFkaW5nWmVyb3MoTWF0aC5hYnMob2Zmc2V0KSAvIDYwLCAyKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRUaW1lem9uZShvZmZzZXQsIGRpcnR5RGVsaW1pdGVyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmUob2Zmc2V0LCBkaXJ0eURlbGltaXRlcikge1xuICB2YXIgZGVsaW1pdGVyID0gZGlydHlEZWxpbWl0ZXIgfHwgJyc7XG4gIHZhciBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gIHZhciBob3VycyA9IGFkZExlYWRpbmdaZXJvcyhNYXRoLmZsb29yKGFic09mZnNldCAvIDYwKSwgMik7XG4gIHZhciBtaW51dGVzID0gYWRkTGVhZGluZ1plcm9zKGFic09mZnNldCAlIDYwLCAyKTtcbiAgcmV0dXJuIHNpZ24gKyBob3VycyArIGRlbGltaXRlciArIG1pbnV0ZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdHRlcnM7IiwiaW1wb3J0IGFkZExlYWRpbmdaZXJvcyBmcm9tIFwiLi4vLi4vYWRkTGVhZGluZ1plcm9zL2luZGV4LmpzXCI7XG4vKlxuICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAgYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgfCAgQSogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZCAgfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgfCAgRCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbSAgfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTSAgfCBNb250aCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgcyAgfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUyAgfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgfFxuICogfCAgeSAgfCBZZWFyIChhYnMpICAgICAgICAgICAgICAgICAgICAgfCAgWSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICogYXJlIG5vdCBpbXBsZW1lbnRlZCBidXQgcmVzZXJ2ZWQgYnkgVW5pY29kZSBzdGFuZGFyZC5cbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHtcbiAgLy8gWWVhclxuICB5OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICAvLyBGcm9tIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtMzEvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X3Rva2Vuc1xuICAgIC8vIHwgWWVhciAgICAgfCAgICAgeSB8IHl5IHwgICB5eXkgfCAgeXl5eSB8IHl5eXl5IHxcbiAgICAvLyB8LS0tLS0tLS0tLXwtLS0tLS0tfC0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICAgLy8gfCBBRCAxICAgICB8ICAgICAxIHwgMDEgfCAgIDAwMSB8ICAwMDAxIHwgMDAwMDEgfFxuICAgIC8vIHwgQUQgMTIgICAgfCAgICAxMiB8IDEyIHwgICAwMTIgfCAgMDAxMiB8IDAwMDEyIHxcbiAgICAvLyB8IEFEIDEyMyAgIHwgICAxMjMgfCAyMyB8ICAgMTIzIHwgIDAxMjMgfCAwMDEyMyB8XG4gICAgLy8gfCBBRCAxMjM0ICB8ICAxMjM0IHwgMzQgfCAgMTIzNCB8ICAxMjM0IHwgMDEyMzQgfFxuICAgIC8vIHwgQUQgMTIzNDUgfCAxMjM0NSB8IDQ1IHwgMTIzNDUgfCAxMjM0NSB8IDEyMzQ1IHxcbiAgICB2YXIgc2lnbmVkWWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTsgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcblxuICAgIHZhciB5ZWFyID0gc2lnbmVkWWVhciA+IDAgPyBzaWduZWRZZWFyIDogMSAtIHNpZ25lZFllYXI7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0b2tlbiA9PT0gJ3l5JyA/IHllYXIgJSAxMDAgOiB5ZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNb250aFxuICBNOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgcmV0dXJuIHRva2VuID09PSAnTScgPyBTdHJpbmcobW9udGggKyAxKSA6IGFkZExlYWRpbmdaZXJvcyhtb250aCArIDEsIDIpO1xuICB9LFxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENEYXRlKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEFNIG9yIFBNXG4gIGE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXRlLmdldFVUQ0hvdXJzKCkgLyAxMiA+PSAxID8gJ3BtJyA6ICdhbSc7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICdhJzpcbiAgICAgIGNhc2UgJ2FhJzpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICBjYXNlICdhYWEnOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlO1xuXG4gICAgICBjYXNlICdhYWFhYSc6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWVbMF07XG5cbiAgICAgIGNhc2UgJ2FhYWEnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZSA9PT0gJ2FtJyA/ICdhLm0uJyA6ICdwLm0uJztcbiAgICB9XG4gIH0sXG4gIC8vIEhvdXIgWzEtMTJdXG4gIGg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEhvdXIgWzAtMjNdXG4gIEg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENIb3VycygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuICAvLyBNaW51dGVcbiAgbTogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbiAgLy8gU2Vjb25kXG4gIHM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENTZWNvbmRzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICB2YXIgbnVtYmVyT2ZEaWdpdHMgPSB0b2tlbi5sZW5ndGg7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgdmFyIGZyYWN0aW9uYWxTZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgKiBNYXRoLnBvdygxMCwgbnVtYmVyT2ZEaWdpdHMgLSAzKSk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhmcmFjdGlvbmFsU2Vjb25kcywgdG9rZW4ubGVuZ3RoKTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdHRlcnM7IiwiZnVuY3Rpb24gZGF0ZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZykge1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlICdQJzpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe1xuICAgICAgICB3aWR0aDogJ3Nob3J0J1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdQUCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdtZWRpdW0nXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1BQUCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHtcbiAgICAgICAgd2lkdGg6ICdsb25nJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdQUFBQJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7XG4gICAgICAgIHdpZHRoOiAnZnVsbCdcbiAgICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpbWVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpIHtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSAncCc6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHtcbiAgICAgICAgd2lkdGg6ICdzaG9ydCdcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAncHAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnbWVkaXVtJ1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdwcHAnOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7XG4gICAgICAgIHdpZHRoOiAnbG9uZydcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAncHBwcCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe1xuICAgICAgICB3aWR0aDogJ2Z1bGwnXG4gICAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZykge1xuICB2YXIgbWF0Y2hSZXN1bHQgPSBwYXR0ZXJuLm1hdGNoKC8oUCspKHArKT8vKSB8fCBbXTtcbiAgdmFyIGRhdGVQYXR0ZXJuID0gbWF0Y2hSZXN1bHRbMV07XG4gIHZhciB0aW1lUGF0dGVybiA9IG1hdGNoUmVzdWx0WzJdO1xuXG4gIGlmICghdGltZVBhdHRlcm4pIHtcbiAgICByZXR1cm4gZGF0ZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZyk7XG4gIH1cblxuICB2YXIgZGF0ZVRpbWVGb3JtYXQ7XG5cbiAgc3dpdGNoIChkYXRlUGF0dGVybikge1xuICAgIGNhc2UgJ1AnOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdzaG9ydCdcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQUCc6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ21lZGl1bSdcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQUFAnOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHtcbiAgICAgICAgd2lkdGg6ICdsb25nJ1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BQUFAnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoe1xuICAgICAgICB3aWR0aDogJ2Z1bGwnXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGRhdGVUaW1lRm9ybWF0LnJlcGxhY2UoJ3t7ZGF0ZX19JywgZGF0ZUxvbmdGb3JtYXR0ZXIoZGF0ZVBhdHRlcm4sIGZvcm1hdExvbmcpKS5yZXBsYWNlKCd7e3RpbWV9fScsIHRpbWVMb25nRm9ybWF0dGVyKHRpbWVQYXR0ZXJuLCBmb3JtYXRMb25nKSk7XG59XG5cbnZhciBsb25nRm9ybWF0dGVycyA9IHtcbiAgcDogdGltZUxvbmdGb3JtYXR0ZXIsXG4gIFA6IGRhdGVUaW1lTG9uZ0Zvcm1hdHRlclxufTtcbmV4cG9ydCBkZWZhdWx0IGxvbmdGb3JtYXR0ZXJzOyIsIi8qKlxuICogR29vZ2xlIENocm9tZSBhcyBvZiA2Ny4wLjMzOTYuODcgaW50cm9kdWNlZCB0aW1lem9uZXMgd2l0aCBvZmZzZXQgdGhhdCBpbmNsdWRlcyBzZWNvbmRzLlxuICogVGhleSB1c3VhbGx5IGFwcGVhciBmb3IgZGF0ZXMgdGhhdCBkZW5vdGUgdGltZSBiZWZvcmUgdGhlIHRpbWV6b25lcyB3ZXJlIGludHJvZHVjZWRcbiAqIChlLmcuIGZvciAnRXVyb3BlL1ByYWd1ZScgdGltZXpvbmUgdGhlIG9mZnNldCBpcyBHTVQrMDA6NTc6NDQgYmVmb3JlIDEgT2N0b2JlciAxODkxXG4gKiBhbmQgR01UKzAxOjAwOjAwIGFmdGVyIHRoYXQgZGF0ZSlcbiAqXG4gKiBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgdGhlIG9mZnNldCBpbiBtaW51dGVzIGFuZCB3b3VsZCByZXR1cm4gNTcgZm9yIHRoZSBleGFtcGxlIGFib3ZlLFxuICogd2hpY2ggd291bGQgbGVhZCB0byBpbmNvcnJlY3QgY2FsY3VsYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcyB0aGF0IHRha2VzIHNlY29uZHMgaW4gYWNjb3VudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkYXRlKSB7XG4gIHZhciB1dGNEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCBkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSkpO1xuICB1dGNEYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSAtIHV0Y0RhdGUuZ2V0VGltZSgpO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG52YXIgTUlMTElTRUNPTkRTX0lOX0RBWSA9IDg2NDAwMDAwOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VVRDRGF5T2ZZZWFyKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB2YXIgc3RhcnRPZlllYXJUaW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgdmFyIGRpZmZlcmVuY2UgPSB0aW1lc3RhbXAgLSBzdGFydE9mWWVhclRpbWVzdGFtcDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIE1JTExJU0VDT05EU19JTl9EQVkpICsgMTtcbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENJU09XZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDSVNPV2Vlay9pbmRleC5qc1wiOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VVRDSVNPV2Vla1llYXIoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRVVENGdWxsWWVhcih5ZWFyICsgMSwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mVVRDSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyKTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIpO1xuXG4gIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXIgKyAxO1xuICB9IGVsc2UgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDE7XG4gIH1cbn0iLCJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi8uLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDSVNPV2VlayBmcm9tIFwiLi4vc3RhcnRPZlVUQ0lTT1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDSVNPV2Vla1llYXIgZnJvbSBcIi4uL3N0YXJ0T2ZVVENJU09XZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG52YXIgTUlMTElTRUNPTkRTX0lOX1dFRUsgPSA2MDQ4MDAwMDA7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVVENJU09XZWVrKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgdmFyIGRpZmYgPSBzdGFydE9mVVRDSVNPV2VlayhkYXRlKS5nZXRUaW1lKCkgLSBzdGFydE9mVVRDSVNPV2Vla1llYXIoZGF0ZSkuZ2V0VGltZSgpOyAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIGRheXMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuICAvLyBiZWNhdXNlIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnRcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBNSUxMSVNFQ09ORFNfSU5fV0VFSykgKyAxO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ1dlZWsgZnJvbSBcIi4uL3N0YXJ0T2ZVVENXZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9JbnRlZ2VyIGZyb20gXCIuLi90b0ludGVnZXIvaW5kZXguanNcIjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVUQ1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGU7XG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyAxIDogdG9JbnRlZ2VyKGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIHZhciBmaXJzdFdlZWtDb250YWluc0RhdGUgPSBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA6IHRvSW50ZWdlcihvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMSBhbmQgNyBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEoZmlyc3RXZWVrQ29udGFpbnNEYXRlID49IDEgJiYgZmlyc3RXZWVrQ29udGFpbnNEYXRlIDw9IDcpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZpcnN0V2Vla0NvbnRhaW5zRGF0ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNyBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgdmFyIGZpcnN0V2Vla09mTmV4dFllYXIgPSBuZXcgRGF0ZSgwKTtcbiAgZmlyc3RXZWVrT2ZOZXh0WWVhci5zZXRVVENGdWxsWWVhcih5ZWFyICsgMSwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrT2ZOZXh0WWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZVVENXZWVrKGZpcnN0V2Vla09mTmV4dFllYXIsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBmaXJzdFdlZWtPZlRoaXNZZWFyID0gbmV3IERhdGUoMCk7XG4gIGZpcnN0V2Vla09mVGhpc1llYXIuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrT2ZUaGlzWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENXZWVrKGZpcnN0V2Vla09mVGhpc1llYXIsIGRpcnR5T3B0aW9ucyk7XG5cbiAgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZOZXh0WWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhciArIDE7XG4gIH0gZWxzZSBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB5ZWFyIC0gMTtcbiAgfVxufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENXZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENXZWVrWWVhciBmcm9tIFwiLi4vc3RhcnRPZlVUQ1dlZWtZZWFyL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbnZhciBNSUxMSVNFQ09ORFNfSU5fV0VFSyA9IDYwNDgwMDAwMDsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVUQ1dlZWsoZGlydHlEYXRlLCBvcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGlmZiA9IHN0YXJ0T2ZVVENXZWVrKGRhdGUsIG9wdGlvbnMpLmdldFRpbWUoKSAtIHN0YXJ0T2ZVVENXZWVrWWVhcihkYXRlLCBvcHRpb25zKS5nZXRUaW1lKCk7IC8vIFJvdW5kIHRoZSBudW1iZXIgb2YgZGF5cyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG4gIC8vIGJlY2F1c2UgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gYSB3ZWVrIGlzIG5vdCBjb25zdGFudFxuICAvLyAoZS5nLiBpdCdzIGRpZmZlcmVudCBpbiB0aGUgd2VlayBvZiB0aGUgZGF5bGlnaHQgc2F2aW5nIHRpbWUgY2xvY2sgc2hpZnQpXG5cbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLKSArIDE7XG59IiwiaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG5pbXBvcnQgc3RhcnRPZlVUQ1dlZWsgZnJvbSBcIi4uL3N0YXJ0T2ZVVENXZWVrL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1NhbWVVVENXZWVrKGRpcnR5RGF0ZUxlZnQsIGRpcnR5RGF0ZVJpZ2h0LCBvcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZUxlZnRTdGFydE9mV2VlayA9IHN0YXJ0T2ZVVENXZWVrKGRpcnR5RGF0ZUxlZnQsIG9wdGlvbnMpO1xuICB2YXIgZGF0ZVJpZ2h0U3RhcnRPZldlZWsgPSBzdGFydE9mVVRDV2VlayhkaXJ0eURhdGVSaWdodCwgb3B0aW9ucyk7XG4gIHJldHVybiBkYXRlTGVmdFN0YXJ0T2ZXZWVrLmdldFRpbWUoKSA9PT0gZGF0ZVJpZ2h0U3RhcnRPZldlZWsuZ2V0VGltZSgpO1xufSIsInZhciBwcm90ZWN0ZWREYXlPZlllYXJUb2tlbnMgPSBbJ0QnLCAnREQnXTtcbnZhciBwcm90ZWN0ZWRXZWVrWWVhclRva2VucyA9IFsnWVknLCAnWVlZWSddO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4odG9rZW4pIHtcbiAgcmV0dXJuIHByb3RlY3RlZERheU9mWWVhclRva2Vucy5pbmRleE9mKHRva2VuKSAhPT0gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiBwcm90ZWN0ZWRXZWVrWWVhclRva2Vucy5pbmRleE9mKHRva2VuKSAhPT0gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gdGhyb3dQcm90ZWN0ZWRFcnJvcih0b2tlbiwgZm9ybWF0LCBpbnB1dCkge1xuICBpZiAodG9rZW4gPT09ICdZWVlZJykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVXNlIGB5eXl5YCBpbnN0ZWFkIG9mIGBZWVlZYCAoaW4gYFwiLmNvbmNhdChmb3JtYXQsIFwiYCkgZm9yIGZvcm1hdHRpbmcgeWVhcnMgdG8gdGhlIGlucHV0IGBcIikuY29uY2F0KGlucHV0LCBcImA7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcIikpO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnWVknKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVc2UgYHl5YCBpbnN0ZWFkIG9mIGBZWWAgKGluIGBcIi5jb25jYXQoZm9ybWF0LCBcImApIGZvciBmb3JtYXR0aW5nIHllYXJzIHRvIHRoZSBpbnB1dCBgXCIpLmNvbmNhdChpbnB1dCwgXCJgOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXCIpKTtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ0QnKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVc2UgYGRgIGluc3RlYWQgb2YgYERgIChpbiBgXCIuY29uY2F0KGZvcm1hdCwgXCJgKSBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aCB0byB0aGUgaW5wdXQgYFwiKS5jb25jYXQoaW5wdXQsIFwiYDsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clwiKSk7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09ICdERCcpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVzZSBgZGRgIGluc3RlYWQgb2YgYEREYCAoaW4gYFwiLmNvbmNhdChmb3JtYXQsIFwiYCkgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdG8gdGhlIGlucHV0IGBcIikuY29uY2F0KGlucHV0LCBcImA7IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcIikpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVxdWlyZWRBcmdzKHJlcXVpcmVkLCBhcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA8IHJlcXVpcmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihyZXF1aXJlZCArICcgYXJndW1lbnQnICsgKHJlcXVpcmVkID4gMSA/ICdzJyA6ICcnKSArICcgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmdzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG59IiwiaW1wb3J0IGdldFVUQ0lTT1dlZWtZZWFyIGZyb20gXCIuLi9nZXRVVENJU09XZWVrWWVhci9pbmRleC5qc1wiO1xuaW1wb3J0IHN0YXJ0T2ZVVENJU09XZWVrIGZyb20gXCIuLi9zdGFydE9mVVRDSVNPV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGFydE9mVVRDSVNPV2Vla1llYXIoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgeWVhciA9IGdldFVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSk7XG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHZhciBkYXRlID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5KTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXJ0T2ZVVENJU09XZWVrKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IDE7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBkYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xuICB2YXIgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRpZmYpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZGF0ZTtcbn0iLCJpbXBvcnQgZ2V0VVRDV2Vla1llYXIgZnJvbSBcIi4uL2dldFVUQ1dlZWtZZWFyL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbmltcG9ydCBzdGFydE9mVVRDV2VlayBmcm9tIFwiLi4vc3RhcnRPZlVUQ1dlZWsvaW5kZXguanNcIjtcbmltcG9ydCB0b0ludGVnZXIgZnJvbSBcIi4uL3RvSW50ZWdlci9pbmRleC5qc1wiOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RhcnRPZlVUQ1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IDEgOiB0b0ludGVnZXIobG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGwgPyBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlIDogdG9JbnRlZ2VyKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgdmFyIHllYXIgPSBnZXRVVENXZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gIHZhciBmaXJzdFdlZWsgPSBuZXcgRGF0ZSgwKTtcbiAgZmlyc3RXZWVrLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vlay5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgdmFyIGRhdGUgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWssIGRpcnR5T3B0aW9ucyk7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uLy4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG5pbXBvcnQgdG9JbnRlZ2VyIGZyb20gXCIuLi90b0ludGVnZXIvaW5kZXguanNcIjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXJ0T2ZVVENXZWVrKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICB2YXIgbG9jYWxlV2Vla1N0YXJ0c09uID0gbG9jYWxlICYmIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLndlZWtTdGFydHNPbjtcbiAgdmFyIGRlZmF1bHRXZWVrU3RhcnRzT24gPSBsb2NhbGVXZWVrU3RhcnRzT24gPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIobG9jYWxlV2Vla1N0YXJ0c09uKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGwgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogdG9JbnRlZ2VyKG9wdGlvbnMud2Vla1N0YXJ0c09uKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9JbnRlZ2VyKGRpcnR5TnVtYmVyKSB7XG4gIGlmIChkaXJ0eU51bWJlciA9PT0gbnVsbCB8fCBkaXJ0eU51bWJlciA9PT0gdHJ1ZSB8fCBkaXJ0eU51bWJlciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7XG5cbiAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgcmV0dXJuIG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKTtcbn0iLCJpbXBvcnQgdG9JbnRlZ2VyIGZyb20gXCIuLi9fbGliL3RvSW50ZWdlci9pbmRleC5qc1wiO1xuaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBhZGRNaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgYWRkZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCA3NTAgbWlsbGlzZWNvbmRzIHRvIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gKiBjb25zdCByZXN1bHQgPSBhZGRNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NTozMC43NTBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIHRpbWVzdGFtcCA9IHRvRGF0ZShkaXJ0eURhdGUpLmdldFRpbWUoKTtcbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlcihkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyBhbW91bnQpO1xufSIsImltcG9ydCBpc1ZhbGlkIGZyb20gXCIuLi9pc1ZhbGlkL2luZGV4LmpzXCI7XG5pbXBvcnQgZGVmYXVsdExvY2FsZSBmcm9tIFwiLi4vbG9jYWxlL2VuLVVTL2luZGV4LmpzXCI7XG5pbXBvcnQgc3ViTWlsbGlzZWNvbmRzIGZyb20gXCIuLi9zdWJNaWxsaXNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IGZvcm1hdHRlcnMgZnJvbSBcIi4uL19saWIvZm9ybWF0L2Zvcm1hdHRlcnMvaW5kZXguanNcIjtcbmltcG9ydCBsb25nRm9ybWF0dGVycyBmcm9tIFwiLi4vX2xpYi9mb3JtYXQvbG9uZ0Zvcm1hdHRlcnMvaW5kZXguanNcIjtcbmltcG9ydCBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzIGZyb20gXCIuLi9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4sIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbiwgdGhyb3dQcm90ZWN0ZWRFcnJvciB9IGZyb20gXCIuLi9fbGliL3Byb3RlY3RlZFRva2Vucy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7IC8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuXG52YXIgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZzsgLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuXG52YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcbnZhciBlc2NhcGVkU3RyaW5nUmVnRXhwID0gL14nKFteXSo/KSc/JC87XG52YXIgZG91YmxlUXVvdGVSZWdFeHAgPSAvJycvZztcbnZhciB1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCA9IC9bYS16QS1aXS87XG4vKipcbiAqIEBuYW1lIGZvcm1hdFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZyBpbiB0aGUgZ2l2ZW4gZm9ybWF0LiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBgZm9ybWF0YCB0b2tlbnMgZGlmZmVyIGZyb20gTW9tZW50LmpzIGFuZCBvdGhlciBsaWJyYXJpZXMuXG4gKiA+IFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXG4gKiBUd28gc2luZ2xlIHF1b3RlcyBpbiBhIHJvdywgd2hldGhlciBpbnNpZGUgb3Igb3V0c2lkZSBhIHF1b3RlZCBzZXF1ZW5jZSwgcmVwcmVzZW50IGEgJ3JlYWwnIHNpbmdsZSBxdW90ZS5cbiAqIChzZWUgdGhlIGxhc3QgZXhhbXBsZSlcbiAqXG4gKiBGb3JtYXQgb2YgdGhlIHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNyBiZWxvdyB0aGUgdGFibGUpLlxuICpcbiAqIEFjY2VwdGVkIHBhdHRlcm5zOlxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XG4gKiB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHLi5HR0cgIHwgQUQsIEJDICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENhbGVuZGFyIHllYXIgICAgICAgICAgICAgICAgICAgfCB5ICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMHRoLCAxN3RoICAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgfCBZICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCAyMDE3dGggICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICAgfCBSICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlIgICAgICB8IC00MywgMDAsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDAsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlJSICAgIHwgLTAwNDMsIDAwMDAsIDAwMDEsIDE5MDAsIDIwMTcgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSw3IHxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IHUgICAgICAgfCAtNDMsIDAsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dSAgICAgIHwgLTQzLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1dSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRUSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxcSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NTSAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMTCAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3dyAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJSSAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICAgIHwgMDEsIDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgIHwgOSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IERheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICAgICAgfCBFLi5FRUUgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRUUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaSAgICAgIHwgMDEsIDAyLCAuLi4sIDA3ICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpaSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8IDcgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChzdGFuZC1hbG9uZSkgfCBjICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2MgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjY2MgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgYS4uYWEgICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYSAgICAgfCBhbSwgcG0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICB8IGIuLmJiICAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmIgICAgIHwgYW0sIHBtLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiYiAgICB8IGEubS4sIHAubS4sIG5vb24sIG1pZG5pZ2h0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQkJCQiAgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDEydGggICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSG8gICAgICB8IDB0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgS28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDB0aCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtLICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwga28gICAgICB8IDI0dGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbW8gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc28gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1MgICAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy8gWikgICAgICAgIHwgWCAgICAgICB8IC0wOCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYWCAgICB8IC0wODAwLCArMDUzMCwgWiwgKzEyMzQ1NiAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHggICAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eHggICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAsICsxMjozNDo1NiB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgICB8IE8uLi5PT08gfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBPT09PICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiAgICAgfFxuICogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgIHwgei4uLnp6eiB8IEdNVC04LCBHTVQrNTozMCwgR01UKzAgICAgICAgICAgICB8IDYgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHp6enogICAgfCBHTVQtMDg6MDAsIEdNVCswNTozMCwgR01UKzAwOjAwICAgfCAyLDYgICB8XG4gKiB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICAgfCB0ICAgICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBUVCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw3ICAgfFxuICogfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgIHwgUCAgICAgICB8IDA0LzI5LzE0NTMgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQICAgICAgfCBBcHIgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFAgICAgIHwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUCAgICB8IEZyaWRheSwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICB8IDIsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcCAgICAgIHwgMTI6MDA6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHBwICAgICB8IDEyOjAwOjAwIEFNIEdNVCsyICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcHAgICAgfCAxMjowMDowMCBBTSBHTVQrMDI6MDAgICAgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IENvbWJpbmF0aW9uIG9mIGRhdGUgYW5kIHRpbWUgICAgfCBQcCAgICAgIHwgMDQvMjkvMTQ1MywgMTI6MDAgQU0gICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBwcCAgICB8IEFwciAyOSwgMTQ1MywgMTI6MDA6MDAgQU0gICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUHBwcCAgfCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBQcHBwcHwgRnJpZGF5LCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgIHwgMiw3ICAgfFxuICogTm90ZXM6XG4gKiAxLiBcIkZvcm1hdHRpbmdcIiB1bml0cyAoZS5nLiBmb3JtYXR0aW5nIHF1YXJ0ZXIpIGluIHRoZSBkZWZhdWx0IGVuLVVTIGxvY2FsZVxuICogICAgYXJlIHRoZSBzYW1lIGFzIFwic3RhbmQtYWxvbmVcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXG4gKiAgICBcIkZvcm1hdHRpbmdcIiB1bml0cyBhcmUgZGVjbGluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBvZiB0aGUgbGFuZ3VhZ2VcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXCJTdGFuZC1hbG9uZVwiIHVuaXRzIGFyZSBhbHdheXMgbm9taW5hdGl2ZSBzaW5ndWxhcjpcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIE1NTU0nLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkdSdgXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlIChlLmcuIGBFRUVFRUVFRUVFRWApXG4gKiAgICB0aGUgb3V0cHV0IHdpbGwgYmUgdGhlIHNhbWUgYXMgZGVmYXVsdCBwYXR0ZXJuIGZvciB0aGlzIHVuaXQsIHVzdWFsbHlcbiAqICAgIHRoZSBsb25nZXN0IG9uZSAoaW4gY2FzZSBvZiBJU08gd2Vla2RheXMsIGBFRUVFYCkuIERlZmF1bHQgcGF0dGVybnMgZm9yIHVuaXRzXG4gKiAgICBhcmUgbWFya2VkIHdpdGggXCIyXCIgaW4gdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTScpIC8vPT4gJ05vdidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU0nKSAvLz0+ICdOJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogMy4gU29tZSBwYXR0ZXJucyBjb3VsZCBiZSB1bmxpbWl0ZWQgbGVuZ3RoIChzdWNoIGFzIGB5eXl5eXl5eWApLlxuICogICAgVGhlIG91dHB1dCB3aWxsIGJlIHBhZGRlZCB3aXRoIHplcm9zIHRvIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICd5eXl5eXl5eScpIC8vPT4gJzAwMDAyMDE3J2BcbiAqXG4gKiA0LiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxuICogICAgVGhlc2UgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2hvcnRlc3QgZm9ybSBvZiB0aGUgcXVhcnRlci5cbiAqXG4gKiA1LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XG4gKlxuICogICAgfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XG4gKiAgICB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICogICAgfCBCQyAxIHwgICAxIHwgICAwIHxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gKlxuICogICAgQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICogICAgd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkOlxuICpcbiAqICAgIHwgWWVhciB8IGB5eWAgfCBgdXVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS0tfC0tLS0tLXxcbiAqICAgIHwgMSAgICB8ICAgMDEgfCAgIDAxIHxcbiAqICAgIHwgMTQgICB8ICAgMTQgfCAgIDE0IHxcbiAqICAgIHwgMzc2ICB8ICAgNzYgfCAgMzc2IHxcbiAqICAgIHwgMTQ1MyB8ICAgNTMgfCAxNDUzIHxcbiAqXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcbiAqICAgIGV4Y2VwdCBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgZGVwZW5kZW50IG9uIGBvcHRpb25zLndlZWtTdGFydHNPbmBcbiAqICAgIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIChjb21wYXJlIFtnZXRJU09XZWVrWWVhcl17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9nZXRJU09XZWVrWWVhcn1cbiAqICAgIGFuZCBbZ2V0V2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0V2Vla1llYXJ9KS5cbiAqXG4gKiA2LiBTcGVjaWZpYyBub24tbG9jYXRpb24gdGltZXpvbmVzIGFyZSBjdXJyZW50bHkgdW5hdmFpbGFibGUgaW4gYGRhdGUtZm5zYCxcbiAqICAgIHNvIHJpZ2h0IG5vdyB0aGVzZSB0b2tlbnMgZmFsbCBiYWNrIHRvIEdNVCB0aW1lem9uZXMuXG4gKlxuICogNy4gVGhlc2UgcGF0dGVybnMgYXJlIG5vdCBpbiB0aGUgVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcbiAqICAgIC0gYFJgOiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICogICAgLSBgdGA6IHNlY29uZHMgdGltZXN0YW1wXG4gKiAgICAtIGBUYDogbWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgb2A6IG9yZGluYWwgbnVtYmVyIG1vZGlmaWVyXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxuICogICAgLSBgcGA6IGxvbmcgbG9jYWxpemVkIHRpbWVcbiAqXG4gKiA4LiBgWVlgIGFuZCBgWVlZWWAgdG9rZW5zIHJlcHJlc2VudCB3ZWVrLW51bWJlcmluZyB5ZWFycyBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCB5ZWFycy5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiA5LiBgRGAgYW5kIGBERGAgdG9rZW5zIHJlcHJlc2VudCBkYXlzIG9mIHRoZSB5ZWFyIGJ1dCB0aGV5IGFyZSBvZnRlbiBjb25mdXNlZCB3aXRoIGRheXMgb2YgdGhlIG1vbnRoLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gVGhlIHNlY29uZCBhcmd1bWVudCBpcyBub3cgcmVxdWlyZWQgZm9yIHRoZSBzYWtlIG9mIGV4cGxpY2l0bmVzcy5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgLy8gQmVmb3JlIHYyLjAuMFxuICogICBmb3JtYXQobmV3IERhdGUoMjAxNiwgMCwgMSkpXG4gKlxuICogICAvLyB2Mi4wLjAgb253YXJkXG4gKiAgIGZvcm1hdChuZXcgRGF0ZSgyMDE2LCAwLCAxKSwgXCJ5eXl5LU1NLWRkJ1QnSEg6bW06c3MuU1NTeHh4XCIpXG4gKiAgIGBgYFxuICpcbiAqIC0gTmV3IGZvcm1hdCBzdHJpbmcgQVBJIGZvciBgZm9ybWF0YCBmdW5jdGlvblxuICogICB3aGljaCBpcyBiYXNlZCBvbiBbVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1XShodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlKS5cbiAqICAgU2VlIFt0aGlzIHBvc3RdKGh0dHBzOi8vYmxvZy5kYXRlLWZucy5vcmcvcG9zdC91bmljb2RlLXRva2Vucy1pbi1kYXRlLWZucy12Mi1zcmVhdHlraTkxamcpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogLSBDaGFyYWN0ZXJzIGFyZSBub3cgZXNjYXBlZCB1c2luZyBzaW5nbGUgcXVvdGUgc3ltYm9scyAoYCdgKSBpbnN0ZWFkIG9mIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgLSB0aGUgc3RyaW5nIG9mIHRva2Vuc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8Nn0gW29wdGlvbnMud2Vla1N0YXJ0c09uPTBdIC0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlPTFdIC0gdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM9ZmFsc2VdIC0gaWYgdHJ1ZSwgYWxsb3dzIHVzYWdlIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyIHRva2VucyBgWVlgIGFuZCBgWVlZWWA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vucz1mYWxzZV0gLSBpZiB0cnVlLCBhbGxvd3MgdXNhZ2Ugb2YgdGhlIGRheSBvZiB5ZWFyIHRva2VucyBgRGAgYW5kIGBERGA7XG4gKiAgIHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBsb2NhbGl6ZWAgcHJvcGVydHlcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXRMb25nYCBwcm9wZXJ0eVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMud2Vla1N0YXJ0c09uYCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgN1xuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eXl5YCBpbnN0ZWFkIG9mIGBZWVlZYCBmb3IgZm9ybWF0dGluZyB5ZWFycyB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdC5pby9meEN5clxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gdXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRgIGluc3RlYWQgb2YgYERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSB1c2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTEgRmVicnVhcnkgMjAxNCBpbiBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQobmV3IERhdGUoMjAxNCwgMSwgMTEpLCAnTU0vZGQveXl5eScpXG4gKiAvLz0+ICcwMi8xMS8yMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMiBKdWx5IDIwMTQgaW4gRXNwZXJhbnRvOlxuICogaW1wb3J0IHsgZW9Mb2NhbGUgfSBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gKiB2YXIgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIpLCBcImRvICdkZScgTU1NTSB5eXl5XCIsIHtcbiAqICAgbG9jYWxlOiBlb0xvY2FsZVxuICogfSlcbiAqIC8vPT4gJzItYSBkZSBqdWxpbyAyMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFc2NhcGUgc3RyaW5nIGJ5IHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzOlxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA2LCAyLCAxNSksIFwiaCAnbycnY2xvY2snXCIpXG4gKiAvLz0+IFwiMyBvJ2Nsb2NrXCJcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXQoZGlydHlEYXRlLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlPcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZm9ybWF0U3RyID0gU3RyaW5nKGRpcnR5Rm9ybWF0U3RyKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCBkZWZhdWx0TG9jYWxlO1xuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xuICB2YXIgZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9PSBudWxsID8gMSA6IHRvSW50ZWdlcihsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID0gb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbCA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgOiB0b0ludGVnZXIob3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpOyAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxuXG4gIGlmICghKGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA+PSAxICYmIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA8PSA3KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknKTtcbiAgfVxuXG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XG4gIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlcihvcHRpb25zLndlZWtTdGFydHNPbik7IC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG5cbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpO1xuICB9XG5cbiAgaWYgKCFsb2NhbGUubG9jYWxpemUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBsb2NhbGl6ZSBwcm9wZXJ0eScpO1xuICB9XG5cbiAgaWYgKCFsb2NhbGUuZm9ybWF0TG9uZykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIGZvcm1hdExvbmcgcHJvcGVydHknKTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbERhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcblxuICBpZiAoIWlzVmFsaWQob3JpZ2luYWxEYXRlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgfSAvLyBDb252ZXJ0IHRoZSBkYXRlIGluIHN5c3RlbSB0aW1lem9uZSB0byB0aGUgc2FtZSBkYXRlIGluIFVUQyswMDowMCB0aW1lem9uZS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIGxvY2FsZXMgd2lsbCBiZSBjb21wYXRpYmxlIHdpdGggdGhlbS5cbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG5cblxuICB2YXIgdGltZXpvbmVPZmZzZXQgPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKG9yaWdpbmFsRGF0ZSk7XG4gIHZhciB1dGNEYXRlID0gc3ViTWlsbGlzZWNvbmRzKG9yaWdpbmFsRGF0ZSwgdGltZXpvbmVPZmZzZXQpO1xuICB2YXIgZm9ybWF0dGVyT3B0aW9ucyA9IHtcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcbiAgICB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbixcbiAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICBfb3JpZ2luYWxEYXRlOiBvcmlnaW5hbERhdGVcbiAgfTtcbiAgdmFyIHJlc3VsdCA9IGZvcm1hdFN0ci5tYXRjaChsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCkubWFwKGZ1bmN0aW9uIChzdWJzdHJpbmcpIHtcbiAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG5cbiAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09ICdwJyB8fCBmaXJzdENoYXJhY3RlciA9PT0gJ1AnKSB7XG4gICAgICB2YXIgbG9uZ0Zvcm1hdHRlciA9IGxvbmdGb3JtYXR0ZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcbiAgICAgIHJldHVybiBsb25nRm9ybWF0dGVyKHN1YnN0cmluZywgbG9jYWxlLmZvcm1hdExvbmcsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzdHJpbmc7XG4gIH0pLmpvaW4oJycpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHApLm1hcChmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgLy8gUmVwbGFjZSB0d28gc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlclxuICAgIGlmIChzdWJzdHJpbmcgPT09IFwiJydcIikge1xuICAgICAgcmV0dXJuIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcblxuICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCInXCIpIHtcbiAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zICYmIGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbihzdWJzdHJpbmcpKSB7XG4gICAgICAgIHRocm93UHJvdGVjdGVkRXJyb3Ioc3Vic3RyaW5nLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlEYXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMgJiYgaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbihzdWJzdHJpbmcpKSB7XG4gICAgICAgIHRocm93UHJvdGVjdGVkRXJyb3Ioc3Vic3RyaW5nLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlEYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvcm1hdHRlcih1dGNEYXRlLCBzdWJzdHJpbmcsIGxvY2FsZS5sb2NhbGl6ZSwgZm9ybWF0dGVyT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Q2hhcmFjdGVyLm1hdGNoKHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Zvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlciBgJyArIGZpcnN0Q2hhcmFjdGVyICsgJ2AnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic3RyaW5nO1xuICB9KS5qb2luKCcnKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2xlYW5Fc2NhcGVkU3RyaW5nKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5tYXRjaChlc2NhcGVkU3RyaW5nUmVnRXhwKVsxXS5yZXBsYWNlKGRvdWJsZVF1b3RlUmVnRXhwLCBcIidcIik7XG59IiwiaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgaXNEYXRlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiB2YWx1ZSBhIGRhdGU/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIERhdGUuIFRoZSBmdW5jdGlvbiB3b3JrcyBmb3IgZGF0ZXMgdHJhbnNmZXJyZWQgYWNyb3NzIGlmcmFtZXMuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkYXRlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhIHZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUobmV3IERhdGUoKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgYW4gaW52YWxpZCBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNEYXRlKG5ldyBEYXRlKE5hTikpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHNvbWUgdmFsdWU6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUoJzIwMTQtMDItMzEnKVxuICogLy89PiBmYWxzZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgYW4gb2JqZWN0OlxuICogY29uc3QgcmVzdWx0ID0gaXNEYXRlKHt9KVxuICogLy89PiBmYWxzZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJztcbn0iLCJpbXBvcnQgaXNEYXRlIGZyb20gXCIuLi9pc0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgaXNWYWxpZFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB2YWxpZD9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgZmFsc2UgaWYgYXJndW1lbnQgaXMgSW52YWxpZCBEYXRlIGFuZCB0cnVlIG90aGVyd2lzZS5cbiAqIEFyZ3VtZW50IGlzIGNvbnZlcnRlZCB0byBEYXRlIHVzaW5nIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBJbnZhbGlkIERhdGUgaXMgYSBEYXRlLCB3aG9zZSB0aW1lIHZhbHVlIGlzIE5hTi5cbiAqXG4gKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gTm93IGBpc1ZhbGlkYCBkb2Vzbid0IHRocm93IGFuIGV4Y2VwdGlvblxuICogICBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKiAgIEluc3RlYWQsIGFyZ3VtZW50IGlzIGNvbnZlcnRlZCBiZWZvcmVoYW5kIHVzaW5nIGB0b0RhdGVgLlxuICpcbiAqICAgRXhhbXBsZXM6XG4gKlxuICogICB8IGBpc1ZhbGlkYCBhcmd1bWVudCAgICAgICAgfCBCZWZvcmUgdjIuMC4wIHwgdjIuMC4wIG9ud2FyZCB8XG4gKiAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLXxcbiAqICAgfCBgbmV3IERhdGUoKWAgICAgICAgICAgICAgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZSgnMjAxNi0wMS0wMScpYCAgfCBgdHJ1ZWAgICAgICAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYG5ldyBEYXRlKCcnKWAgICAgICAgICAgICB8IGBmYWxzZWAgICAgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgbmV3IERhdGUoMTQ4ODM3MDgzNTA4MSlgIHwgYHRydWVgICAgICAgICB8IGB0cnVlYCAgICAgICAgfFxuICogICB8IGBuZXcgRGF0ZShOYU4pYCAgICAgICAgICAgfCBgZmFsc2VgICAgICAgIHwgYGZhbHNlYCAgICAgICB8XG4gKiAgIHwgYCcyMDE2LTAxLTAxJ2AgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqICAgfCBgJydgICAgICAgICAgICAgICAgICAgICAgIHwgYFR5cGVFcnJvcmAgICB8IGBmYWxzZWAgICAgICAgfFxuICogICB8IGAxNDg4MzcwODM1MDgxYCAgICAgICAgICAgfCBgVHlwZUVycm9yYCAgIHwgYHRydWVgICAgICAgICB8XG4gKiAgIHwgYE5hTmAgICAgICAgICAgICAgICAgICAgICB8IGBUeXBlRXJyb3JgICAgfCBgZmFsc2VgICAgICAgIHxcbiAqXG4gKiAgIFdlIGludHJvZHVjZSB0aGlzIGNoYW5nZSB0byBtYWtlICpkYXRlLWZucyogY29uc2lzdGVudCB3aXRoIEVDTUFTY3JpcHQgYmVoYXZpb3JcbiAqICAgdGhhdCB0cnkgdG8gY29lcmNlIGFyZ3VtZW50cyB0byB0aGUgZXhwZWN0ZWQgdHlwZVxuICogICAod2hpY2ggaXMgYWxzbyB0aGUgY2FzZSB3aXRoIG90aGVyICpkYXRlLWZucyogZnVuY3Rpb25zKS5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGlzIHZhbGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWxpZCBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgyMDE0LCAxLCAzMSkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWx1ZSwgY29udmVydGFibGUgaW50byBhIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc1ZhbGlkKDEzOTM4MDQ4MDAwMDApXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSBpbnZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKCcnKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1ZhbGlkKGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcblxuICBpZiAoIWlzRGF0ZShkaXJ0eURhdGUpICYmIHR5cGVvZiBkaXJ0eURhdGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgcmV0dXJuICFpc05hTihOdW1iZXIoZGF0ZSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkRm9ybWF0TG9uZ0ZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgLy8gVE9ETzogUmVtb3ZlIFN0cmluZygpXG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGFyZ3MuZGVmYXVsdFdpZHRoO1xuICAgIHZhciBmb3JtYXQgPSBhcmdzLmZvcm1hdHNbd2lkdGhdIHx8IGFyZ3MuZm9ybWF0c1thcmdzLmRlZmF1bHRXaWR0aF07XG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZExvY2FsaXplRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5SW5kZXgsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0ID8gU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgOiAnc3RhbmRhbG9uZSc7XG4gICAgdmFyIHZhbHVlc0FycmF5O1xuXG4gICAgaWYgKGNvbnRleHQgPT09ICdmb3JtYXR0aW5nJyAmJiBhcmdzLmZvcm1hdHRpbmdWYWx1ZXMpIHtcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSBhcmdzLmRlZmF1bHRGb3JtYXR0aW5nV2lkdGggfHwgYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogZGVmYXVsdFdpZHRoO1xuICAgICAgdmFsdWVzQXJyYXkgPSBhcmdzLmZvcm1hdHRpbmdWYWx1ZXNbd2lkdGhdIHx8IGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1tkZWZhdWx0V2lkdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2RlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YXIgX3dpZHRoID0gb3B0aW9ucy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MudmFsdWVzW193aWR0aF0gfHwgYXJncy52YWx1ZXNbX2RlZmF1bHRXaWR0aF07XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gYXJncy5hcmd1bWVudENhbGxiYWNrID8gYXJncy5hcmd1bWVudENhbGxiYWNrKGRpcnR5SW5kZXgpIDogZGlydHlJbmRleDsgLy8gQHRzLWlnbm9yZTogRm9yIHNvbWUgcmVhc29uIFR5cGVTY3JpcHQganVzdCBkb24ndCB3YW50IHRvIG1hdGNoIGl0LCBubyBtYXR0ZXIgaG93IGhhcmQgd2UgdHJ5LiBJIGNoYWxsZW5nZSB5b3UgdG8gdHJ5IHRvIHJlbW92ZSBpdCFcblxuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF07XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRNYXRjaEZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICB2YXIgbWF0Y2hQYXR0ZXJuID0gd2lkdGggJiYgYXJncy5tYXRjaFBhdHRlcm5zW3dpZHRoXSB8fCBhcmdzLm1hdGNoUGF0dGVybnNbYXJncy5kZWZhdWx0TWF0Y2hXaWR0aF07XG4gICAgdmFyIG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKG1hdGNoUGF0dGVybik7XG5cbiAgICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZFN0cmluZyA9IG1hdGNoUmVzdWx0WzBdO1xuICAgIHZhciBwYXJzZVBhdHRlcm5zID0gd2lkdGggJiYgYXJncy5wYXJzZVBhdHRlcm5zW3dpZHRoXSB8fCBhcmdzLnBhcnNlUGF0dGVybnNbYXJncy5kZWZhdWx0UGFyc2VXaWR0aF07XG4gICAgdmFyIGtleSA9IEFycmF5LmlzQXJyYXkocGFyc2VQYXR0ZXJucykgPyBmaW5kSW5kZXgocGFyc2VQYXR0ZXJucywgZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobWF0Y2hlZFN0cmluZyk7XG4gICAgfSkgOiBmaW5kS2V5KHBhcnNlUGF0dGVybnMsIGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG1hdGNoZWRTdHJpbmcpO1xuICAgIH0pO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YWx1ZSA9IGFyZ3MudmFsdWVDYWxsYmFjayA/IGFyZ3MudmFsdWVDYWxsYmFjayhrZXkpIDoga2V5O1xuICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZUNhbGxiYWNrID8gb3B0aW9ucy52YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuICAgIHZhciByZXN0ID0gc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcmVzdDogcmVzdFxuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBwcmVkaWNhdGUob2JqZWN0W2tleV0pKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlKSB7XG4gIGZvciAodmFyIGtleSA9IDA7IGtleSA8IGFycmF5Lmxlbmd0aDsga2V5KyspIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2tleV0pKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRNYXRjaFBhdHRlcm5GbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLm1hdGNoUGF0dGVybik7XG4gICAgaWYgKCFtYXRjaFJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIG1hdGNoZWRTdHJpbmcgPSBtYXRjaFJlc3VsdFswXTtcbiAgICB2YXIgcGFyc2VSZXN1bHQgPSBzdHJpbmcubWF0Y2goYXJncy5wYXJzZVBhdHRlcm4pO1xuICAgIGlmICghcGFyc2VSZXN1bHQpIHJldHVybiBudWxsO1xuICAgIHZhciB2YWx1ZSA9IGFyZ3MudmFsdWVDYWxsYmFjayA/IGFyZ3MudmFsdWVDYWxsYmFjayhwYXJzZVJlc3VsdFswXSkgOiBwYXJzZVJlc3VsdFswXTtcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFjayA/IG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB2YXIgcmVzdCA9IHN0cmluZy5zbGljZShtYXRjaGVkU3RyaW5nLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHJlc3Q6IHJlc3RcbiAgICB9O1xuICB9O1xufSIsInZhciBmb3JtYXREaXN0YW5jZUxvY2FsZSA9IHtcbiAgbGVzc1RoYW5YU2Vjb25kczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJ3dlbmlnZXIgYWxzIDEgU2VrdW5kZScsXG4gICAgICBvdGhlcjogJ3dlbmlnZXIgYWxzIHt7Y291bnR9fSBTZWt1bmRlbidcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnd2VuaWdlciBhbHMgMSBTZWt1bmRlJyxcbiAgICAgIG90aGVyOiAnd2VuaWdlciBhbHMge3tjb3VudH19IFNla3VuZGVuJ1xuICAgIH1cbiAgfSxcbiAgeFNlY29uZHM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICcxIFNla3VuZGUnLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gU2VrdW5kZW4nXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJzEgU2VrdW5kZScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBTZWt1bmRlbidcbiAgICB9XG4gIH0sXG4gIGhhbGZBTWludXRlOiB7XG4gICAgc3RhbmRhbG9uZTogJ2hhbGJlIE1pbnV0ZScsXG4gICAgd2l0aFByZXBvc2l0aW9uOiAnaGFsYmVuIE1pbnV0ZSdcbiAgfSxcbiAgbGVzc1RoYW5YTWludXRlczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJ3dlbmlnZXIgYWxzIDEgTWludXRlJyxcbiAgICAgIG90aGVyOiAnd2VuaWdlciBhbHMge3tjb3VudH19IE1pbnV0ZW4nXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJ3dlbmlnZXIgYWxzIDEgTWludXRlJyxcbiAgICAgIG90aGVyOiAnd2VuaWdlciBhbHMge3tjb3VudH19IE1pbnV0ZW4nXG4gICAgfVxuICB9LFxuICB4TWludXRlczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJzEgTWludXRlJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IE1pbnV0ZW4nXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJzEgTWludXRlJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IE1pbnV0ZW4nXG4gICAgfVxuICB9LFxuICBhYm91dFhIb3Vyczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJ2V0d2EgMSBTdHVuZGUnLFxuICAgICAgb3RoZXI6ICdldHdhIHt7Y291bnR9fSBTdHVuZGVuJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICdldHdhIDEgU3R1bmRlJyxcbiAgICAgIG90aGVyOiAnZXR3YSB7e2NvdW50fX0gU3R1bmRlbidcbiAgICB9XG4gIH0sXG4gIHhIb3Vyczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJzEgU3R1bmRlJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IFN0dW5kZW4nXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJzEgU3R1bmRlJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IFN0dW5kZW4nXG4gICAgfVxuICB9LFxuICB4RGF5czoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJzEgVGFnJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IFRhZ2UnXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJzEgVGFnJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IFRhZ2VuJ1xuICAgIH1cbiAgfSxcbiAgYWJvdXRYV2Vla3M6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICdldHdhIDEgV29jaGUnLFxuICAgICAgb3RoZXI6ICdldHdhIHt7Y291bnR9fSBXb2NoZW4nXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJ2V0d2EgMSBXb2NoZScsXG4gICAgICBvdGhlcjogJ2V0d2Ege3tjb3VudH19IFdvY2hlbidcbiAgICB9XG4gIH0sXG4gIHhXZWVrczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJzEgV29jaGUnLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gV29jaGVuJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICcxIFdvY2hlJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IFdvY2hlbidcbiAgICB9XG4gIH0sXG4gIGFib3V0WE1vbnRoczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJ2V0d2EgMSBNb25hdCcsXG4gICAgICBvdGhlcjogJ2V0d2Ege3tjb3VudH19IE1vbmF0ZSdcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnZXR3YSAxIE1vbmF0JyxcbiAgICAgIG90aGVyOiAnZXR3YSB7e2NvdW50fX0gTW9uYXRlbidcbiAgICB9XG4gIH0sXG4gIHhNb250aHM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICcxIE1vbmF0JyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IE1vbmF0ZSdcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnMSBNb25hdCcsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBNb25hdGVuJ1xuICAgIH1cbiAgfSxcbiAgYWJvdXRYWWVhcnM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICdldHdhIDEgSmFocicsXG4gICAgICBvdGhlcjogJ2V0d2Ege3tjb3VudH19IEphaHJlJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICdldHdhIDEgSmFocicsXG4gICAgICBvdGhlcjogJ2V0d2Ege3tjb3VudH19IEphaHJlbidcbiAgICB9XG4gIH0sXG4gIHhZZWFyczoge1xuICAgIHN0YW5kYWxvbmU6IHtcbiAgICAgIG9uZTogJzEgSmFocicsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBKYWhyZSdcbiAgICB9LFxuICAgIHdpdGhQcmVwb3NpdGlvbjoge1xuICAgICAgb25lOiAnMSBKYWhyJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IEphaHJlbidcbiAgICB9XG4gIH0sXG4gIG92ZXJYWWVhcnM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICdtZWhyIGFscyAxIEphaHInLFxuICAgICAgb3RoZXI6ICdtZWhyIGFscyB7e2NvdW50fX0gSmFocmUnXG4gICAgfSxcbiAgICB3aXRoUHJlcG9zaXRpb246IHtcbiAgICAgIG9uZTogJ21laHIgYWxzIDEgSmFocicsXG4gICAgICBvdGhlcjogJ21laHIgYWxzIHt7Y291bnR9fSBKYWhyZW4nXG4gICAgfVxuICB9LFxuICBhbG1vc3RYWWVhcnM6IHtcbiAgICBzdGFuZGFsb25lOiB7XG4gICAgICBvbmU6ICdmYXN0IDEgSmFocicsXG4gICAgICBvdGhlcjogJ2Zhc3Qge3tjb3VudH19IEphaHJlJ1xuICAgIH0sXG4gICAgd2l0aFByZXBvc2l0aW9uOiB7XG4gICAgICBvbmU6ICdmYXN0IDEgSmFocicsXG4gICAgICBvdGhlcjogJ2Zhc3Qge3tjb3VudH19IEphaHJlbidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBmb3JtYXREaXN0YW5jZSA9IGZ1bmN0aW9uICh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIHRva2VuVmFsdWUgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmFkZFN1ZmZpeCA/IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXS53aXRoUHJlcG9zaXRpb24gOiBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0uc3RhbmRhbG9uZTtcblxuICBpZiAodHlwZW9mIHRva2VuVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gdG9rZW5WYWx1ZTtcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWUub25lO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWUub3RoZXIucmVwbGFjZSgne3tjb3VudH19JywgU3RyaW5nKGNvdW50KSk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5hZGRTdWZmaXgpIHtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJpc29uICYmIG9wdGlvbnMuY29tcGFyaXNvbiA+IDApIHtcbiAgICAgIHJldHVybiAnaW4gJyArIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd2b3IgJyArIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0RGlzdGFuY2U7IiwiaW1wb3J0IGJ1aWxkRm9ybWF0TG9uZ0ZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuL2luZGV4LmpzXCI7XG4vLyBESU4gNTAwODogaHR0cHM6Ly9kZS53aWtpcGVkaWEub3JnL3dpa2kvRGF0dW1zZm9ybWF0I0RJTl81MDA4XG52YXIgZGF0ZUZvcm1hdHMgPSB7XG4gIGZ1bGw6ICdFRUVFLCBkbyBNTU1NIHknLFxuICAvLyBNb250YWcsIDcuIEphbnVhciAyMDE4XG4gIGxvbmc6ICdkbyBNTU1NIHknLFxuICAvLyA3LiBKYW51YXIgMjAxOFxuICBtZWRpdW06ICdkbyBNTU0geScsXG4gIC8vIDcuIEphbi4gMjAxOFxuICBzaG9ydDogJ2RkLk1NLnknIC8vIDA3LjAxLjIwMThcblxufTtcbnZhciB0aW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogJ0hIOm1tOnNzIHp6enonLFxuICBsb25nOiAnSEg6bW06c3MgeicsXG4gIG1lZGl1bTogJ0hIOm1tOnNzJyxcbiAgc2hvcnQ6ICdISDptbSdcbn07XG52YXIgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiBcInt7ZGF0ZX19ICd1bScge3t0aW1lfX1cIixcbiAgbG9uZzogXCJ7e2RhdGV9fSAndW0nIHt7dGltZX19XCIsXG4gIG1lZGl1bTogJ3t7ZGF0ZX19IHt7dGltZX19JyxcbiAgc2hvcnQ6ICd7e2RhdGV9fSB7e3RpbWV9fSdcbn07XG52YXIgZm9ybWF0TG9uZyA9IHtcbiAgZGF0ZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pLFxuICB0aW1lOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogdGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSksXG4gIGRhdGVUaW1lOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZVRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgZm9ybWF0TG9uZzsiLCJ2YXIgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XG4gIGxhc3RXZWVrOiBcIidsZXR6dGVuJyBlZWVlICd1bScgcFwiLFxuICB5ZXN0ZXJkYXk6IFwiJ2dlc3Rlcm4gdW0nIHBcIixcbiAgdG9kYXk6IFwiJ2hldXRlIHVtJyBwXCIsXG4gIHRvbW9ycm93OiBcIidtb3JnZW4gdW0nIHBcIixcbiAgbmV4dFdlZWs6IFwiZWVlZSAndW0nIHBcIixcbiAgb3RoZXI6ICdQJ1xufTtcblxudmFyIGZvcm1hdFJlbGF0aXZlID0gZnVuY3Rpb24gKHRva2VuLCBfZGF0ZSwgX2Jhc2VEYXRlLCBfb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UmVsYXRpdmVMb2NhbGVbdG9rZW5dO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0UmVsYXRpdmU7IiwiaW1wb3J0IGJ1aWxkTG9jYWxpemVGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZExvY2FsaXplRm4vaW5kZXguanNcIjtcbnZhciBlcmFWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWyd2LkNoci4nLCAnbi5DaHIuJ10sXG4gIGFiYnJldmlhdGVkOiBbJ3YuQ2hyLicsICduLkNoci4nXSxcbiAgd2lkZTogWyd2b3IgQ2hyaXN0dXMnLCAnbmFjaCBDaHJpc3R1cyddXG59O1xudmFyIHF1YXJ0ZXJWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWycxJywgJzInLCAnMycsICc0J10sXG4gIGFiYnJldmlhdGVkOiBbJ1ExJywgJ1EyJywgJ1EzJywgJ1E0J10sXG4gIHdpZGU6IFsnMS4gUXVhcnRhbCcsICcyLiBRdWFydGFsJywgJzMuIFF1YXJ0YWwnLCAnNC4gUXVhcnRhbCddXG59OyAvLyBOb3RlOiBpbiBHZXJtYW4sIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXG4vLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbi8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cblxudmFyIG1vbnRoVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnSicsICdGJywgJ00nLCAnQScsICdNJywgJ0onLCAnSicsICdBJywgJ1MnLCAnTycsICdOJywgJ0QnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnSmFuJywgJ0ZlYicsICdNw6RyJywgJ0FwcicsICdNYWknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09rdCcsICdOb3YnLCAnRGV6J10sXG4gIHdpZGU6IFsnSmFudWFyJywgJ0ZlYnJ1YXInLCAnTcOkcnonLCAnQXByaWwnLCAnTWFpJywgJ0p1bmknLCAnSnVsaScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09rdG9iZXInLCAnTm92ZW1iZXInLCAnRGV6ZW1iZXInXVxufTsgLy8gaHR0cHM6Ly9zdC51bmljb2RlLm9yZy9jbGRyLWFwcHMvdiMvZGUvR3JlZ29yaWFuL1xuXG52YXIgZm9ybWF0dGluZ01vbnRoVmFsdWVzID0ge1xuICBuYXJyb3c6IG1vbnRoVmFsdWVzLm5hcnJvdyxcbiAgYWJicmV2aWF0ZWQ6IFsnSmFuLicsICdGZWIuJywgJ03DpHJ6JywgJ0Fwci4nLCAnTWFpJywgJ0p1bmknLCAnSnVsaScsICdBdWcuJywgJ1NlcC4nLCAnT2t0LicsICdOb3YuJywgJ0Rlei4nXSxcbiAgd2lkZTogbW9udGhWYWx1ZXMud2lkZVxufTtcbnZhciBkYXlWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydTJywgJ00nLCAnRCcsICdNJywgJ0QnLCAnRicsICdTJ10sXG4gIHNob3J0OiBbJ1NvJywgJ01vJywgJ0RpJywgJ01pJywgJ0RvJywgJ0ZyJywgJ1NhJ10sXG4gIGFiYnJldmlhdGVkOiBbJ1NvLicsICdNby4nLCAnRGkuJywgJ01pLicsICdEby4nLCAnRnIuJywgJ1NhLiddLFxuICB3aWRlOiBbJ1Nvbm50YWcnLCAnTW9udGFnJywgJ0RpZW5zdGFnJywgJ01pdHR3b2NoJywgJ0Rvbm5lcnN0YWcnLCAnRnJlaXRhZycsICdTYW1zdGFnJ11cbn07IC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL2NsZHIvY2hhcnRzLzMyL3N1bW1hcnkvZGUuaHRtbCMxODgxXG5cbnZhciBkYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAndm0uJyxcbiAgICBwbTogJ25tLicsXG4gICAgbWlkbmlnaHQ6ICdNaXR0ZXJuYWNodCcsXG4gICAgbm9vbjogJ01pdHRhZycsXG4gICAgbW9ybmluZzogJ01vcmdlbicsXG4gICAgYWZ0ZXJub29uOiAnTmFjaG0uJyxcbiAgICBldmVuaW5nOiAnQWJlbmQnLFxuICAgIG5pZ2h0OiAnTmFjaHQnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICd2b3JtLicsXG4gICAgcG06ICduYWNobS4nLFxuICAgIG1pZG5pZ2h0OiAnTWl0dGVybmFjaHQnLFxuICAgIG5vb246ICdNaXR0YWcnLFxuICAgIG1vcm5pbmc6ICdNb3JnZW4nLFxuICAgIGFmdGVybm9vbjogJ05hY2htaXR0YWcnLFxuICAgIGV2ZW5pbmc6ICdBYmVuZCcsXG4gICAgbmlnaHQ6ICdOYWNodCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAndm9ybWl0dGFncycsXG4gICAgcG06ICduYWNobWl0dGFncycsXG4gICAgbWlkbmlnaHQ6ICdNaXR0ZXJuYWNodCcsXG4gICAgbm9vbjogJ01pdHRhZycsXG4gICAgbW9ybmluZzogJ01vcmdlbicsXG4gICAgYWZ0ZXJub29uOiAnTmFjaG1pdHRhZycsXG4gICAgZXZlbmluZzogJ0FiZW5kJyxcbiAgICBuaWdodDogJ05hY2h0J1xuICB9XG59O1xudmFyIGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAndm0uJyxcbiAgICBwbTogJ25tLicsXG4gICAgbWlkbmlnaHQ6ICdNaXR0ZXJuYWNodCcsXG4gICAgbm9vbjogJ01pdHRhZycsXG4gICAgbW9ybmluZzogJ21vcmdlbnMnLFxuICAgIGFmdGVybm9vbjogJ25hY2htLicsXG4gICAgZXZlbmluZzogJ2FiZW5kcycsXG4gICAgbmlnaHQ6ICduYWNodHMnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICd2b3JtLicsXG4gICAgcG06ICduYWNobS4nLFxuICAgIG1pZG5pZ2h0OiAnTWl0dGVybmFjaHQnLFxuICAgIG5vb246ICdNaXR0YWcnLFxuICAgIG1vcm5pbmc6ICdtb3JnZW5zJyxcbiAgICBhZnRlcm5vb246ICduYWNobWl0dGFncycsXG4gICAgZXZlbmluZzogJ2FiZW5kcycsXG4gICAgbmlnaHQ6ICduYWNodHMnXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogJ3Zvcm1pdHRhZ3MnLFxuICAgIHBtOiAnbmFjaG1pdHRhZ3MnLFxuICAgIG1pZG5pZ2h0OiAnTWl0dGVybmFjaHQnLFxuICAgIG5vb246ICdNaXR0YWcnLFxuICAgIG1vcm5pbmc6ICdtb3JnZW5zJyxcbiAgICBhZnRlcm5vb246ICduYWNobWl0dGFncycsXG4gICAgZXZlbmluZzogJ2FiZW5kcycsXG4gICAgbmlnaHQ6ICduYWNodHMnXG4gIH1cbn07XG5cbnZhciBvcmRpbmFsTnVtYmVyID0gZnVuY3Rpb24gKGRpcnR5TnVtYmVyKSB7XG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuICByZXR1cm4gbnVtYmVyICsgJy4nO1xufTtcblxudmFyIGxvY2FsaXplID0ge1xuICBvcmRpbmFsTnVtYmVyOiBvcmRpbmFsTnVtYmVyLFxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBxdWFydGVyVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGFyZ3VtZW50Q2FsbGJhY2s6IGZ1bmN0aW9uIChxdWFydGVyKSB7XG4gICAgICByZXR1cm4gcXVhcnRlciAtIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBtb250aFZhbHVlcyxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nTW9udGhWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGZvcm1hdHRpbmdWYWx1ZXM6IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogJ3dpZGUnXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgbG9jYWxpemU7IiwiaW1wb3J0IGJ1aWxkTWF0Y2hGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoRm4vaW5kZXguanNcIjtcbmltcG9ydCBidWlsZE1hdGNoUGF0dGVybkZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4vaW5kZXguanNcIjtcbnZhciBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL14oXFxkKykoXFwuKT8vaTtcbnZhciBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL1xcZCsvaTtcbnZhciBtYXRjaEVyYVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKHZcXC4/ID9DaHJcXC4/fG5cXC4/ID9DaHJcXC4/KS9pLFxuICBhYmJyZXZpYXRlZDogL14odlxcLj8gP0NoclxcLj98blxcLj8gP0NoclxcLj8pL2ksXG4gIHdpZGU6IC9eKHZvciBDaHJpc3R1c3x2b3IgdW5zZXJlciBaZWl0cmVjaG51bmd8bmFjaCBDaHJpc3R1c3x1bnNlcmVyIFplaXRyZWNobnVuZykvaVxufTtcbnZhciBwYXJzZUVyYVBhdHRlcm5zID0ge1xuICBhbnk6IFsvXnYvaSwgL15uL2ldXG59O1xudmFyIG1hdGNoUXVhcnRlclBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eWzEyMzRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXnFbMTIzNF0vaSxcbiAgd2lkZTogL15bMTIzNF0oXFwuKT8gUXVhcnRhbC9pXG59O1xudmFyIHBhcnNlUXVhcnRlclBhdHRlcm5zID0ge1xuICBhbnk6IFsvMS9pLCAvMi9pLCAvMy9pLCAvNC9pXVxufTtcbnZhciBtYXRjaE1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bamZtYXNvbmRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXihqW2HDpF1ufGZlYnxtw6RyW3pdP3xhcHJ8bWFpfGp1bltpXT98anVsW2ldP3xhdWd8c2VwfG9rdHxub3Z8ZGV6KVxcLj8vaSxcbiAgd2lkZTogL14oamFudWFyfGZlYnJ1YXJ8bcOkcnp8YXByaWx8bWFpfGp1bml8anVsaXxhdWd1c3R8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGV6ZW1iZXIpL2lcbn07XG52YXIgcGFyc2VNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFsvXmovaSwgL15mL2ksIC9ebS9pLCAvXmEvaSwgL15tL2ksIC9eai9pLCAvXmovaSwgL15hL2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXSxcbiAgYW55OiBbL15qW2HDpF0vaSwgL15mL2ksIC9ebcOkci9pLCAvXmFwL2ksIC9ebWFpL2ksIC9eanVuL2ksIC9eanVsL2ksIC9eYXUvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldXG59O1xudmFyIG1hdGNoRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bc21kbWZdL2ksXG4gIHNob3J0OiAvXihzb3xtb3xkaXxtaXxkb3xmcnxzYSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKHNvbj98bW9uP3xkaWU/fG1pdD98ZG9uP3xmcmU/fHNhbT8pXFwuPy9pLFxuICB3aWRlOiAvXihzb25udGFnfG1vbnRhZ3xkaWVuc3RhZ3xtaXR0d29jaHxkb25uZXJzdGFnfGZyZWl0YWd8c2Ftc3RhZykvaVxufTtcbnZhciBwYXJzZURheVBhdHRlcm5zID0ge1xuICBhbnk6IFsvXnNvL2ksIC9ebW8vaSwgL15kaS9pLCAvXm1pL2ksIC9eZG8vaSwgL15mL2ksIC9ec2EvaV1cbn07XG52YXIgbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXih2bVxcLj98bm1cXC4/fE1pdHRlcm5hY2h0fE1pdHRhZ3xtb3JnZW5zfG5hY2htXFwuP3xhYmVuZHN8bmFjaHRzKS9pLFxuICBhYmJyZXZpYXRlZDogL14odm9ybVxcLj98bmFjaG1cXC4/fE1pdHRlcm5hY2h0fE1pdHRhZ3xtb3JnZW5zfG5hY2htXFwuP3xhYmVuZHN8bmFjaHRzKS9pLFxuICB3aWRlOiAvXih2b3JtaXR0YWdzfG5hY2htaXR0YWdzfE1pdHRlcm5hY2h0fE1pdHRhZ3xtb3JnZW5zfG5hY2htaXR0YWdzfGFiZW5kc3xuYWNodHMpL2lcbn07XG52YXIgcGFyc2VEYXlQZXJpb2RQYXR0ZXJucyA9IHtcbiAgYW55OiB7XG4gICAgYW06IC9edi9pLFxuICAgIHBtOiAvXm4vaSxcbiAgICBtaWRuaWdodDogL15NaXR0ZS9pLFxuICAgIG5vb246IC9eTWl0dGEvaSxcbiAgICBtb3JuaW5nOiAvbW9yZ2Vucy9pLFxuICAgIGFmdGVybm9vbjogL25hY2htaXR0YWdzL2ksXG4gICAgLy8gd2lsbCBuZXZlciBiZSBtYXRjaGVkLiBBZnRlcm5vb24gaXMgbWF0Y2hlZCBieSBgcG1gXG4gICAgZXZlbmluZzogL2FiZW5kcy9pLFxuICAgIG5pZ2h0OiAvbmFjaHRzL2kgLy8gd2lsbCBuZXZlciBiZSBtYXRjaGVkLiBOaWdodCBpcyBtYXRjaGVkIGJ5IGBwbWBcblxuICB9XG59O1xudmFyIG1hdGNoID0ge1xuICBvcmRpbmFsTnVtYmVyOiBidWlsZE1hdGNoUGF0dGVybkZuKHtcbiAgICBtYXRjaFBhdHRlcm46IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgcGFyc2VQYXR0ZXJuOiBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbiAgICB9XG4gIH0pLFxuICBlcmE6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBxdWFydGVyOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaE1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZU1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBkYXk6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBkYXlQZXJpb2Q6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgbWF0Y2g7IiwiaW1wb3J0IGZvcm1hdERpc3RhbmNlIGZyb20gXCIuL19saWIvZm9ybWF0RGlzdGFuY2UvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRMb25nIGZyb20gXCIuL19saWIvZm9ybWF0TG9uZy9pbmRleC5qc1wiO1xuaW1wb3J0IGZvcm1hdFJlbGF0aXZlIGZyb20gXCIuL19saWIvZm9ybWF0UmVsYXRpdmUvaW5kZXguanNcIjtcbmltcG9ydCBsb2NhbGl6ZSBmcm9tIFwiLi9fbGliL2xvY2FsaXplL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2ggZnJvbSBcIi4vX2xpYi9tYXRjaC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEB0eXBlIHtMb2NhbGV9XG4gKiBAY2F0ZWdvcnkgTG9jYWxlc1xuICogQHN1bW1hcnkgR2VybWFuIGxvY2FsZS5cbiAqIEBsYW5ndWFnZSBHZXJtYW5cbiAqIEBpc28tNjM5LTIgZGV1XG4gKiBAYXV0aG9yIFRob21hcyBFaWxtc3RlaW5lciBbQERlTXV1XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vRGVNdXV9XG4gKiBAYXV0aG9yIEFzaWEgW0Bhc2lhLXRde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2lhLXR9XG4gKiBAYXV0aG9yIFZhbiBWdW9uZyBOZ28gW0B2YW52dW9uZ25nb117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ZhbnZ1b25nbmdvfVxuICogQGF1dGhvciBSb21hbkVybnN0IFtAcGV4XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGV4fVxuICogQGF1dGhvciBQaGlsaXBwIEtlY2sgW0BQaGlsaXBwOTFde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9QaGlsaXBwOTF9XG4gKi9cbnZhciBsb2NhbGUgPSB7XG4gIGNvZGU6ICdkZScsXG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMVxuICAgIC8qIE1vbmRheSAqL1xuICAgICxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDRcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsZTsiLCJ2YXIgZm9ybWF0RGlzdGFuY2VMb2NhbGUgPSB7XG4gIGxlc3NUaGFuWFNlY29uZHM6IHtcbiAgICBvbmU6ICdsZXNzIHRoYW4gYSBzZWNvbmQnLFxuICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBzZWNvbmRzJ1xuICB9LFxuICB4U2Vjb25kczoge1xuICAgIG9uZTogJzEgc2Vjb25kJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBzZWNvbmRzJ1xuICB9LFxuICBoYWxmQU1pbnV0ZTogJ2hhbGYgYSBtaW51dGUnLFxuICBsZXNzVGhhblhNaW51dGVzOiB7XG4gICAgb25lOiAnbGVzcyB0aGFuIGEgbWludXRlJyxcbiAgICBvdGhlcjogJ2xlc3MgdGhhbiB7e2NvdW50fX0gbWludXRlcydcbiAgfSxcbiAgeE1pbnV0ZXM6IHtcbiAgICBvbmU6ICcxIG1pbnV0ZScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gbWludXRlcydcbiAgfSxcbiAgYWJvdXRYSG91cnM6IHtcbiAgICBvbmU6ICdhYm91dCAxIGhvdXInLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IGhvdXJzJ1xuICB9LFxuICB4SG91cnM6IHtcbiAgICBvbmU6ICcxIGhvdXInLFxuICAgIG90aGVyOiAne3tjb3VudH19IGhvdXJzJ1xuICB9LFxuICB4RGF5czoge1xuICAgIG9uZTogJzEgZGF5JyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBkYXlzJ1xuICB9LFxuICBhYm91dFhXZWVrczoge1xuICAgIG9uZTogJ2Fib3V0IDEgd2VlaycsXG4gICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0gd2Vla3MnXG4gIH0sXG4gIHhXZWVrczoge1xuICAgIG9uZTogJzEgd2VlaycsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gd2Vla3MnXG4gIH0sXG4gIGFib3V0WE1vbnRoczoge1xuICAgIG9uZTogJ2Fib3V0IDEgbW9udGgnLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IG1vbnRocydcbiAgfSxcbiAgeE1vbnRoczoge1xuICAgIG9uZTogJzEgbW9udGgnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1vbnRocydcbiAgfSxcbiAgYWJvdXRYWWVhcnM6IHtcbiAgICBvbmU6ICdhYm91dCAxIHllYXInLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IHllYXJzJ1xuICB9LFxuICB4WWVhcnM6IHtcbiAgICBvbmU6ICcxIHllYXInLFxuICAgIG90aGVyOiAne3tjb3VudH19IHllYXJzJ1xuICB9LFxuICBvdmVyWFllYXJzOiB7XG4gICAgb25lOiAnb3ZlciAxIHllYXInLFxuICAgIG90aGVyOiAnb3ZlciB7e2NvdW50fX0geWVhcnMnXG4gIH0sXG4gIGFsbW9zdFhZZWFyczoge1xuICAgIG9uZTogJ2FsbW9zdCAxIHllYXInLFxuICAgIG90aGVyOiAnYWxtb3N0IHt7Y291bnR9fSB5ZWFycydcbiAgfVxufTtcblxudmFyIGZvcm1hdERpc3RhbmNlID0gZnVuY3Rpb24gKHRva2VuLCBjb3VudCwgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0O1xuICB2YXIgdG9rZW5WYWx1ZSA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXTtcblxuICBpZiAodHlwZW9mIHRva2VuVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gdG9rZW5WYWx1ZTtcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWUub25lO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWUub3RoZXIucmVwbGFjZSgne3tjb3VudH19JywgY291bnQudG9TdHJpbmcoKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5hZGRTdWZmaXgpIHtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJpc29uICYmIG9wdGlvbnMuY29tcGFyaXNvbiA+IDApIHtcbiAgICAgIHJldHVybiAnaW4gJyArIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdCArICcgYWdvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0RGlzdGFuY2U7IiwiaW1wb3J0IGJ1aWxkRm9ybWF0TG9uZ0ZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuL2luZGV4LmpzXCI7XG52YXIgZGF0ZUZvcm1hdHMgPSB7XG4gIGZ1bGw6ICdFRUVFLCBNTU1NIGRvLCB5JyxcbiAgbG9uZzogJ01NTU0gZG8sIHknLFxuICBtZWRpdW06ICdNTU0gZCwgeScsXG4gIHNob3J0OiAnTU0vZGQveXl5eSdcbn07XG52YXIgdGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6ICdoOm1tOnNzIGEgenp6eicsXG4gIGxvbmc6ICdoOm1tOnNzIGEgeicsXG4gIG1lZGl1bTogJ2g6bW06c3MgYScsXG4gIHNob3J0OiAnaDptbSBhJ1xufTtcbnZhciBkYXRlVGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwie3tkYXRlfX0gJ2F0JyB7e3RpbWV9fVwiLFxuICBsb25nOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbWVkaXVtOiAne3tkYXRlfX0sIHt7dGltZX19JyxcbiAgc2hvcnQ6ICd7e2RhdGV9fSwge3t0aW1lfX0nXG59O1xudmFyIGZvcm1hdExvbmcgPSB7XG4gIGRhdGU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgdGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IHRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pLFxuICBkYXRlVGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVUaW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdExvbmc7IiwidmFyIGZvcm1hdFJlbGF0aXZlTG9jYWxlID0ge1xuICBsYXN0V2VlazogXCInbGFzdCcgZWVlZSAnYXQnIHBcIixcbiAgeWVzdGVyZGF5OiBcIid5ZXN0ZXJkYXkgYXQnIHBcIixcbiAgdG9kYXk6IFwiJ3RvZGF5IGF0JyBwXCIsXG4gIHRvbW9ycm93OiBcIid0b21vcnJvdyBhdCcgcFwiLFxuICBuZXh0V2VlazogXCJlZWVlICdhdCcgcFwiLFxuICBvdGhlcjogJ1AnXG59O1xuXG52YXIgZm9ybWF0UmVsYXRpdmUgPSBmdW5jdGlvbiAodG9rZW4sIF9kYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zKSB7XG4gIHJldHVybiBmb3JtYXRSZWxhdGl2ZUxvY2FsZVt0b2tlbl07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXRSZWxhdGl2ZTsiLCJpbXBvcnQgYnVpbGRMb2NhbGl6ZUZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkTG9jYWxpemVGbi9pbmRleC5qc1wiO1xudmFyIGVyYVZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ0InLCAnQSddLFxuICBhYmJyZXZpYXRlZDogWydCQycsICdBRCddLFxuICB3aWRlOiBbJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknXVxufTtcbnZhciBxdWFydGVyVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnMScsICcyJywgJzMnLCAnNCddLFxuICBhYmJyZXZpYXRlZDogWydRMScsICdRMicsICdRMycsICdRNCddLFxuICB3aWRlOiBbJzFzdCBxdWFydGVyJywgJzJuZCBxdWFydGVyJywgJzNyZCBxdWFydGVyJywgJzR0aCBxdWFydGVyJ11cbn07IC8vIE5vdGU6IGluIEVuZ2xpc2gsIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXG4vLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbi8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cblxudmFyIG1vbnRoVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnSicsICdGJywgJ00nLCAnQScsICdNJywgJ0onLCAnSicsICdBJywgJ1MnLCAnTycsICdOJywgJ0QnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgd2lkZTogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ11cbn07XG52YXIgZGF5VmFsdWVzID0ge1xuICBuYXJyb3c6IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddLFxuICBzaG9ydDogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddLFxuICBhYmJyZXZpYXRlZDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgd2lkZTogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddXG59O1xudmFyIGRheVBlcmlvZFZhbHVlcyA9IHtcbiAgbmFycm93OiB7XG4gICAgYW06ICdhJyxcbiAgICBwbTogJ3AnLFxuICAgIG1pZG5pZ2h0OiAnbWknLFxuICAgIG5vb246ICduJyxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXG4gICAgbmlnaHQ6ICduaWdodCdcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogJ0FNJyxcbiAgICBwbTogJ1BNJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnbmlnaHQnXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogJ2EubS4nLFxuICAgIHBtOiAncC5tLicsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgICBuaWdodDogJ25pZ2h0J1xuICB9XG59O1xudmFyIGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAnYScsXG4gICAgcG06ICdwJyxcbiAgICBtaWRuaWdodDogJ21pJyxcbiAgICBub29uOiAnbicsXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICdBTScsXG4gICAgcG06ICdQTScsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICdhLm0uJyxcbiAgICBwbTogJ3AubS4nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcbiAgfVxufTtcblxudmFyIG9yZGluYWxOdW1iZXIgPSBmdW5jdGlvbiAoZGlydHlOdW1iZXIsIF9vcHRpb25zKSB7XG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpOyAvLyBJZiBvcmRpbmFsIG51bWJlcnMgZGVwZW5kIG9uIGNvbnRleHQsIGZvciBleGFtcGxlLFxuICAvLyBpZiB0aGV5IGFyZSBkaWZmZXJlbnQgZm9yIGRpZmZlcmVudCBncmFtbWF0aWNhbCBnZW5kZXJzLFxuICAvLyB1c2UgYG9wdGlvbnMudW5pdGAuXG4gIC8vXG4gIC8vIGB1bml0YCBjYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RhdGUnLCAnZGF5T2ZZZWFyJyxcbiAgLy8gJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLlxuXG4gIHZhciByZW0xMDAgPSBudW1iZXIgJSAxMDA7XG5cbiAgaWYgKHJlbTEwMCA+IDIwIHx8IHJlbTEwMCA8IDEwKSB7XG4gICAgc3dpdGNoIChyZW0xMDAgJSAxMCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3N0JztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ25kJztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3JkJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVtYmVyICsgJ3RoJztcbn07XG5cbnZhciBsb2NhbGl6ZSA9IHtcbiAgb3JkaW5hbE51bWJlcjogb3JkaW5hbE51bWJlcixcbiAgZXJhOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZXJhVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBxdWFydGVyOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogcXVhcnRlclZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBhcmd1bWVudENhbGxiYWNrOiBmdW5jdGlvbiAocXVhcnRlcikge1xuICAgICAgcmV0dXJuIHF1YXJ0ZXIgLSAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGZvcm1hdHRpbmdWYWx1ZXM6IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogJ3dpZGUnXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgbG9jYWxpemU7IiwiaW1wb3J0IGJ1aWxkTWF0Y2hGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoRm4vaW5kZXguanNcIjtcbmltcG9ydCBidWlsZE1hdGNoUGF0dGVybkZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4vaW5kZXguanNcIjtcbnZhciBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL14oXFxkKykodGh8c3R8bmR8cmQpPy9pO1xudmFyIHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXFxkKy9pO1xudmFyIG1hdGNoRXJhUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYnxhKS9pLFxuICBhYmJyZXZpYXRlZDogL14oYlxcLj9cXHM/Y1xcLj98YlxcLj9cXHM/Y1xcLj9cXHM/ZVxcLj98YVxcLj9cXHM/ZFxcLj98Y1xcLj9cXHM/ZVxcLj8pL2ksXG4gIHdpZGU6IC9eKGJlZm9yZSBjaHJpc3R8YmVmb3JlIGNvbW1vbiBlcmF8YW5ubyBkb21pbml8Y29tbW9uIGVyYSkvaVxufTtcbnZhciBwYXJzZUVyYVBhdHRlcm5zID0ge1xuICBhbnk6IFsvXmIvaSwgL14oYXxjKS9pXVxufTtcbnZhciBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXlsxMjM0XS9pLFxuICBhYmJyZXZpYXRlZDogL15xWzEyMzRdL2ksXG4gIHdpZGU6IC9eWzEyMzRdKHRofHN0fG5kfHJkKT8gcXVhcnRlci9pXG59O1xudmFyIHBhcnNlUXVhcnRlclBhdHRlcm5zID0ge1xuICBhbnk6IFsvMS9pLCAvMi9pLCAvMy9pLCAvNC9pXVxufTtcbnZhciBtYXRjaE1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bamZtYXNvbmRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXihqYW58ZmVifG1hcnxhcHJ8bWF5fGp1bnxqdWx8YXVnfHNlcHxvY3R8bm92fGRlYykvaSxcbiAgd2lkZTogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaVxufTtcbnZhciBwYXJzZU1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9eai9pLCAvXmYvaSwgL15tL2ksIC9eYS9pLCAvXm0vaSwgL15qL2ksIC9eai9pLCAvXmEvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldLFxuICBhbnk6IFsvXmphL2ksIC9eZi9pLCAvXm1hci9pLCAvXmFwL2ksIC9ebWF5L2ksIC9eanVuL2ksIC9eanVsL2ksIC9eYXUvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldXG59O1xudmFyIG1hdGNoRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bc210d2ZdL2ksXG4gIHNob3J0OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAgd2lkZTogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcbn07XG52YXIgcGFyc2VEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL15zL2ksIC9ebS9pLCAvXnQvaSwgL153L2ksIC9edC9pLCAvXmYvaSwgL15zL2ldLFxuICBhbnk6IFsvXnN1L2ksIC9ebS9pLCAvXnR1L2ksIC9edy9pLCAvXnRoL2ksIC9eZi9pLCAvXnNhL2ldXG59O1xudmFyIG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYXxwfG1pfG58KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxuICBhbnk6IC9eKFthcF1cXC4/XFxzP21cXC4/fG1pZG5pZ2h0fG5vb258KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pXG59O1xudmFyIHBhcnNlRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIGFueToge1xuICAgIGFtOiAvXmEvaSxcbiAgICBwbTogL15wL2ksXG4gICAgbWlkbmlnaHQ6IC9ebWkvaSxcbiAgICBub29uOiAvXm5vL2ksXG4gICAgbW9ybmluZzogL21vcm5pbmcvaSxcbiAgICBhZnRlcm5vb246IC9hZnRlcm5vb24vaSxcbiAgICBldmVuaW5nOiAvZXZlbmluZy9pLFxuICAgIG5pZ2h0OiAvbmlnaHQvaVxuICB9XG59O1xudmFyIG1hdGNoID0ge1xuICBvcmRpbmFsTnVtYmVyOiBidWlsZE1hdGNoUGF0dGVybkZuKHtcbiAgICBtYXRjaFBhdHRlcm46IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgcGFyc2VQYXR0ZXJuOiBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9KSxcbiAgZXJhOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZUVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55JyxcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5OiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICdhbnknLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgbWF0Y2g7IiwiaW1wb3J0IGZvcm1hdERpc3RhbmNlIGZyb20gXCIuL19saWIvZm9ybWF0RGlzdGFuY2UvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRMb25nIGZyb20gXCIuL19saWIvZm9ybWF0TG9uZy9pbmRleC5qc1wiO1xuaW1wb3J0IGZvcm1hdFJlbGF0aXZlIGZyb20gXCIuL19saWIvZm9ybWF0UmVsYXRpdmUvaW5kZXguanNcIjtcbmltcG9ydCBsb2NhbGl6ZSBmcm9tIFwiLi9fbGliL2xvY2FsaXplL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2ggZnJvbSBcIi4vX2xpYi9tYXRjaC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEB0eXBlIHtMb2NhbGV9XG4gKiBAY2F0ZWdvcnkgTG9jYWxlc1xuICogQHN1bW1hcnkgRW5nbGlzaCBsb2NhbGUgKFVuaXRlZCBTdGF0ZXMpLlxuICogQGxhbmd1YWdlIEVuZ2xpc2hcbiAqIEBpc28tNjM5LTIgZW5nXG4gKiBAYXV0aG9yIFNhc2hhIEtvc3MgW0Brb3Nzbm9jb3JwXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20va29zc25vY29ycH1cbiAqIEBhdXRob3IgTGVzaGEgS29zcyBbQGxlc2hha29zc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xlc2hha29zc31cbiAqL1xudmFyIGxvY2FsZSA9IHtcbiAgY29kZTogJ2VuLVVTJyxcbiAgZm9ybWF0RGlzdGFuY2U6IGZvcm1hdERpc3RhbmNlLFxuICBmb3JtYXRMb25nOiBmb3JtYXRMb25nLFxuICBmb3JtYXRSZWxhdGl2ZTogZm9ybWF0UmVsYXRpdmUsXG4gIGxvY2FsaXplOiBsb2NhbGl6ZSxcbiAgbWF0Y2g6IG1hdGNoLFxuICBvcHRpb25zOiB7XG4gICAgd2Vla1N0YXJ0c09uOiAwXG4gICAgLyogU3VuZGF5ICovXG4gICAgLFxuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogMVxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgbG9jYWxlOyIsInZhciBmb3JtYXREaXN0YW5jZUxvY2FsZSA9IHtcbiAgbGVzc1RoYW5YU2Vjb25kczoge1xuICAgIG9uZTogJ+S4jeWIsCAxIOenkicsXG4gICAgb3RoZXI6ICfkuI3liLAge3tjb3VudH19IOenkidcbiAgfSxcbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6ICcxIOenkicsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0g56eSJ1xuICB9LFxuICBoYWxmQU1pbnV0ZTogJ+WNiuWIhumSnycsXG4gIGxlc3NUaGFuWE1pbnV0ZXM6IHtcbiAgICBvbmU6ICfkuI3liLAgMSDliIbpkp8nLFxuICAgIG90aGVyOiAn5LiN5YiwIHt7Y291bnR9fSDliIbpkp8nXG4gIH0sXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiAnMSDliIbpkp8nLFxuICAgIG90aGVyOiAne3tjb3VudH19IOWIhumSnydcbiAgfSxcbiAgeEhvdXJzOiB7XG4gICAgb25lOiAnMSDlsI/ml7YnLFxuICAgIG90aGVyOiAne3tjb3VudH19IOWwj+aXtidcbiAgfSxcbiAgYWJvdXRYSG91cnM6IHtcbiAgICBvbmU6ICflpKfnuqYgMSDlsI/ml7YnLFxuICAgIG90aGVyOiAn5aSn57qmIHt7Y291bnR9fSDlsI/ml7YnXG4gIH0sXG4gIHhEYXlzOiB7XG4gICAgb25lOiAnMSDlpKknLFxuICAgIG90aGVyOiAne3tjb3VudH19IOWkqSdcbiAgfSxcbiAgYWJvdXRYV2Vla3M6IHtcbiAgICBvbmU6ICflpKfnuqYgMSDkuKrmmJ/mnJ8nLFxuICAgIG90aGVyOiAn5aSn57qmIHt7Y291bnR9fSDkuKrmmJ/mnJ8nXG4gIH0sXG4gIHhXZWVrczoge1xuICAgIG9uZTogJzEg5Liq5pif5pyfJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSDkuKrmmJ/mnJ8nXG4gIH0sXG4gIGFib3V0WE1vbnRoczoge1xuICAgIG9uZTogJ+Wkp+e6piAxIOS4quaciCcsXG4gICAgb3RoZXI6ICflpKfnuqYge3tjb3VudH19IOS4quaciCdcbiAgfSxcbiAgeE1vbnRoczoge1xuICAgIG9uZTogJzEg5Liq5pyIJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSDkuKrmnIgnXG4gIH0sXG4gIGFib3V0WFllYXJzOiB7XG4gICAgb25lOiAn5aSn57qmIDEg5bm0JyxcbiAgICBvdGhlcjogJ+Wkp+e6piB7e2NvdW50fX0g5bm0J1xuICB9LFxuICB4WWVhcnM6IHtcbiAgICBvbmU6ICcxIOW5tCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0g5bm0J1xuICB9LFxuICBvdmVyWFllYXJzOiB7XG4gICAgb25lOiAn6LaF6L+HIDEg5bm0JyxcbiAgICBvdGhlcjogJ+i2hei/hyB7e2NvdW50fX0g5bm0J1xuICB9LFxuICBhbG1vc3RYWWVhcnM6IHtcbiAgICBvbmU6ICflsIbov5EgMSDlubQnLFxuICAgIG90aGVyOiAn5bCG6L+RIHt7Y291bnR9fSDlubQnXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXREaXN0YW5jZSh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKHR5cGVvZiBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dO1xuICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0ub3RoZXIucmVwbGFjZSgne3tjb3VudH19JywgY291bnQpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiA+IDApIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAn5YaFJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdCArICfliY0nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59IiwiaW1wb3J0IGJ1aWxkRm9ybWF0TG9uZ0ZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuL2luZGV4LmpzXCI7XG52YXIgZGF0ZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwieSflubQnTSfmnIgnZCfml6UnIEVFRUVcIixcbiAgbG9uZzogXCJ5J+W5tCdNJ+aciCdkJ+aXpSdcIixcbiAgbWVkaXVtOiAneXl5eS1NTS1kZCcsXG4gIHNob3J0OiAneXktTU0tZGQnXG59O1xudmFyIHRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiAnenp6eiBhIGg6bW06c3MnLFxuICBsb25nOiAneiBhIGg6bW06c3MnLFxuICBtZWRpdW06ICdhIGg6bW06c3MnLFxuICBzaG9ydDogJ2EgaDptbSdcbn07XG52YXIgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiAne3tkYXRlfX0ge3t0aW1lfX0nLFxuICBsb25nOiAne3tkYXRlfX0ge3t0aW1lfX0nLFxuICBtZWRpdW06ICd7e2RhdGV9fSB7e3RpbWV9fScsXG4gIHNob3J0OiAne3tkYXRlfX0ge3t0aW1lfX0nXG59O1xudmFyIGZvcm1hdExvbmcgPSB7XG4gIGRhdGU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgdGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IHRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pLFxuICBkYXRlVGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVUaW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdExvbmc7IiwiaW1wb3J0IGlzU2FtZVVUQ1dlZWsgZnJvbSBcIi4uLy4uLy4uLy4uL19saWIvaXNTYW1lVVRDV2Vlay9pbmRleC5qc1wiO1xuXG5mdW5jdGlvbiBjaGVja1dlZWsoX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMsIGJhc2VGb3JtYXQpIHtcbiAgaWYgKGlzU2FtZVVUQ1dlZWsoX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGJhc2VGb3JtYXQ7IC8vIGluIHNhbWUgd2Vla1xuICB9IGVsc2UgaWYgKF9kYXRlLmdldFRpbWUoKSA+IF9iYXNlRGF0ZS5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4gXCIn5LiL5LiqJ1wiICsgYmFzZUZvcm1hdDsgLy8gaW4gbmV4dCB3ZWVrXG4gIH1cblxuICByZXR1cm4gXCIn5LiK5LiqJ1wiICsgYmFzZUZvcm1hdDsgLy8gaW4gbGFzdCB3ZWVrXG59XG5cbnZhciBmb3JtYXRSZWxhdGl2ZUxvY2FsZSA9IHtcbiAgbGFzdFdlZWs6IGNoZWNrV2VlayxcbiAgLy8gZGF5cyBiZWZvcmUgeWVzdGVyZGF5LCBtYXliZSBpbiB0aGlzIHdlZWsgb3IgbGFzdCB3ZWVrXG4gIHllc3RlcmRheTogXCIn5pio5aSpJyBwXCIsXG4gIHRvZGF5OiBcIifku4rlpKknIHBcIixcbiAgdG9tb3Jyb3c6IFwiJ+aYjuWkqScgcFwiLFxuICBuZXh0V2VlazogY2hlY2tXZWVrLFxuICAvLyBkYXlzIGFmdGVyIHRvbW9ycm93LCBtYXliZSBpbiB0aGlzIHdlZWsgb3IgbmV4dCB3ZWVrXG4gIG90aGVyOiAnUFAgcCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZSh0b2tlbiwgX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMpIHtcbiAgdmFyIGZvcm1hdCA9IGZvcm1hdFJlbGF0aXZlTG9jYWxlW3Rva2VuXTtcblxuICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmb3JtYXQoX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMsICdlZWVlIHAnKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXQ7XG59IiwiaW1wb3J0IGJ1aWxkTG9jYWxpemVGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZExvY2FsaXplRm4vaW5kZXguanNcIjtcbnZhciBlcmFWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWyfliY0nLCAn5YWs5YWDJ10sXG4gIGFiYnJldmlhdGVkOiBbJ+WJjScsICflhazlhYMnXSxcbiAgd2lkZTogWyflhazlhYPliY0nLCAn5YWs5YWDJ11cbn07XG52YXIgcXVhcnRlclZhbHVlcyA9IHtcbiAgbmFycm93OiBbJzEnLCAnMicsICczJywgJzQnXSxcbiAgYWJicmV2aWF0ZWQ6IFsn56ys5LiA5a2jJywgJ+esrOS6jOWtoycsICfnrKzkuInlraMnLCAn56ys5Zub5a2jJ10sXG4gIHdpZGU6IFsn56ys5LiA5a2j5bqmJywgJ+esrOS6jOWto+W6picsICfnrKzkuInlraPluqYnLCAn56ys5Zub5a2j5bqmJ11cbn07XG52YXIgbW9udGhWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWyfkuIAnLCAn5LqMJywgJ+S4iScsICflm5snLCAn5LqUJywgJ+WFrScsICfkuIMnLCAn5YWrJywgJ+S5nScsICfljYEnLCAn5Y2B5LiAJywgJ+WNgeS6jCddLFxuICBhYmJyZXZpYXRlZDogWycx5pyIJywgJzLmnIgnLCAnM+aciCcsICc05pyIJywgJzXmnIgnLCAnNuaciCcsICc35pyIJywgJzjmnIgnLCAnOeaciCcsICcxMOaciCcsICcxMeaciCcsICcxMuaciCddLFxuICB3aWRlOiBbJ+S4gOaciCcsICfkuozmnIgnLCAn5LiJ5pyIJywgJ+Wbm+aciCcsICfkupTmnIgnLCAn5YWt5pyIJywgJ+S4g+aciCcsICflhavmnIgnLCAn5Lmd5pyIJywgJ+WNgeaciCcsICfljYHkuIDmnIgnLCAn5Y2B5LqM5pyIJ11cbn07XG52YXIgZGF5VmFsdWVzID0ge1xuICBuYXJyb3c6IFsn5pelJywgJ+S4gCcsICfkuownLCAn5LiJJywgJ+WbmycsICfkupQnLCAn5YWtJ10sXG4gIHNob3J0OiBbJ+aXpScsICfkuIAnLCAn5LqMJywgJ+S4iScsICflm5snLCAn5LqUJywgJ+WFrSddLFxuICBhYmJyZXZpYXRlZDogWyflkajml6UnLCAn5ZGo5LiAJywgJ+WRqOS6jCcsICflkajkuIknLCAn5ZGo5ZubJywgJ+WRqOS6lCcsICflkajlha0nXSxcbiAgd2lkZTogWyfmmJ/mnJ/ml6UnLCAn5pif5pyf5LiAJywgJ+aYn+acn+S6jCcsICfmmJ/mnJ/kuIknLCAn5pif5pyf5ZubJywgJ+aYn+acn+S6lCcsICfmmJ/mnJ/lha0nXVxufTtcbnZhciBkYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAn5LiKJyxcbiAgICBwbTogJ+S4iycsXG4gICAgbWlkbmlnaHQ6ICflh4zmmagnLFxuICAgIG5vb246ICfljYgnLFxuICAgIG1vcm5pbmc6ICfml6knLFxuICAgIGFmdGVybm9vbjogJ+S4i+WNiCcsXG4gICAgZXZlbmluZzogJ+aZmicsXG4gICAgbmlnaHQ6ICflpJwnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICfkuIrljYgnLFxuICAgIHBtOiAn5LiL5Y2IJyxcbiAgICBtaWRuaWdodDogJ+WHjOaZqCcsXG4gICAgbm9vbjogJ+S4reWNiCcsXG4gICAgbW9ybmluZzogJ+aXqeaZqCcsXG4gICAgYWZ0ZXJub29uOiAn5Lit5Y2IJyxcbiAgICBldmVuaW5nOiAn5pma5LiKJyxcbiAgICBuaWdodDogJ+WknOmXtCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAn5LiK5Y2IJyxcbiAgICBwbTogJ+S4i+WNiCcsXG4gICAgbWlkbmlnaHQ6ICflh4zmmagnLFxuICAgIG5vb246ICfkuK3ljYgnLFxuICAgIG1vcm5pbmc6ICfml6nmmagnLFxuICAgIGFmdGVybm9vbjogJ+S4reWNiCcsXG4gICAgZXZlbmluZzogJ+aZmuS4iicsXG4gICAgbmlnaHQ6ICflpJzpl7QnXG4gIH1cbn07XG52YXIgZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyA9IHtcbiAgbmFycm93OiB7XG4gICAgYW06ICfkuIonLFxuICAgIHBtOiAn5LiLJyxcbiAgICBtaWRuaWdodDogJ+WHjOaZqCcsXG4gICAgbm9vbjogJ+WNiCcsXG4gICAgbW9ybmluZzogJ+aXqScsXG4gICAgYWZ0ZXJub29uOiAn5LiL5Y2IJyxcbiAgICBldmVuaW5nOiAn5pmaJyxcbiAgICBuaWdodDogJ+WknCdcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogJ+S4iuWNiCcsXG4gICAgcG06ICfkuIvljYgnLFxuICAgIG1pZG5pZ2h0OiAn5YeM5pmoJyxcbiAgICBub29uOiAn5Lit5Y2IJyxcbiAgICBtb3JuaW5nOiAn5pep5pmoJyxcbiAgICBhZnRlcm5vb246ICfkuK3ljYgnLFxuICAgIGV2ZW5pbmc6ICfmmZrkuIonLFxuICAgIG5pZ2h0OiAn5aSc6Ze0J1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICfkuIrljYgnLFxuICAgIHBtOiAn5LiL5Y2IJyxcbiAgICBtaWRuaWdodDogJ+WHjOaZqCcsXG4gICAgbm9vbjogJ+S4reWNiCcsXG4gICAgbW9ybmluZzogJ+aXqeaZqCcsXG4gICAgYWZ0ZXJub29uOiAn5Lit5Y2IJyxcbiAgICBldmVuaW5nOiAn5pma5LiKJyxcbiAgICBuaWdodDogJ+WknOmXtCdcbiAgfVxufTtcblxuZnVuY3Rpb24gb3JkaW5hbE51bWJlcihkaXJ0eU51bWJlciwgZGlydHlPcHRpb25zKSB7XG4gIC8vIElmIG9yZGluYWwgbnVtYmVycyBkZXBlbmQgb24gY29udGV4dCwgZm9yIGV4YW1wbGUsXG4gIC8vIGlmIHRoZXkgYXJlIGRpZmZlcmVudCBmb3IgZGlmZmVyZW50IGdyYW1tYXRpY2FsIGdlbmRlcnMsXG4gIC8vIHVzZSBgb3B0aW9ucy51bml0YDpcbiAgLy9cbiAgLy8gICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fVxuICAvLyAgIHZhciB1bml0ID0gU3RyaW5nKG9wdGlvbnMudW5pdClcbiAgLy9cbiAgLy8gd2hlcmUgYHVuaXRgIGNhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF0ZScsICdkYXlPZlllYXInLFxuICAvLyAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCdcbiAgdmFyIG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7XG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICB2YXIgdW5pdCA9IFN0cmluZyhvcHRpb25zLnVuaXQpO1xuXG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIG51bWJlci50b1N0cmluZygpICsgJ+aXpSc7XG5cbiAgICBjYXNlICdob3VyJzpcbiAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKSArICfml7YnO1xuXG4gICAgY2FzZSAnbWludXRlJzpcbiAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKSArICfliIYnO1xuXG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKSArICfnp5InO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAn56ysICcgKyBudW1iZXIudG9TdHJpbmcoKTtcbiAgfVxufVxuXG52YXIgbG9jYWxpemUgPSB7XG4gIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXIsXG4gIGVyYTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGVyYVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZScsXG4gICAgYXJndW1lbnRDYWxsYmFjazogZnVuY3Rpb24gKHF1YXJ0ZXIpIHtcbiAgICAgIHJldHVybiBOdW1iZXIocXVhcnRlcikgLSAxO1xuICAgIH1cbiAgfSksXG4gIG1vbnRoOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheTogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGZvcm1hdHRpbmdWYWx1ZXM6IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogJ3dpZGUnXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgbG9jYWxpemU7IiwiaW1wb3J0IGJ1aWxkTWF0Y2hQYXR0ZXJuRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRNYXRjaFBhdHRlcm5Gbi9pbmRleC5qc1wiO1xuaW1wb3J0IGJ1aWxkTWF0Y2hGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoRm4vaW5kZXguanNcIjtcbnZhciBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL14o56ysXFxzKik/XFxkKyjml6V85pe2fOWIhnznp5IpPy9pO1xudmFyIHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXFxkKy9pO1xudmFyIG1hdGNoRXJhUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14o5YmNKS9pLFxuICBhYmJyZXZpYXRlZDogL14o5YmNKS9pLFxuICB3aWRlOiAvXijlhazlhYPliY185YWs5YWDKS9pXG59O1xudmFyIHBhcnNlRXJhUGF0dGVybnMgPSB7XG4gIGFueTogWy9eKOWJjSkvaSwgL14o5YWs5YWDKS9pXVxufTtcbnZhciBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXlsxMjM0XS9pLFxuICBhYmJyZXZpYXRlZDogL17nrKxb5LiA5LqM5LiJ5ZubXeWIuy9pLFxuICB3aWRlOiAvXuesrFvkuIDkuozkuInlm5td5Yi76ZKfL2lcbn07XG52YXIgcGFyc2VRdWFydGVyUGF0dGVybnMgPSB7XG4gIGFueTogWy8oMXzkuIApL2ksIC8oMnzkuowpL2ksIC8oM3zkuIkpL2ksIC8oNHzlm5spL2ldXG59O1xudmFyIG1hdGNoTW9udGhQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXijkuIB85LqMfOS4iXzlm5t85LqUfOWFrXzkuIN85YWrfOS5nXzljYFb5LqM5LiAXSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKOS4gHzkuox85LiJfOWbm3zkupR85YWtfOS4g3zlhat85LmdfOWNgVvkuozkuIBdfFxcZHwxWzEyXSnmnIgvaSxcbiAgd2lkZTogL14o5LiAfOS6jHzkuIl85ZubfOS6lHzlha185LiDfOWFq3zkuZ185Y2BW+S6jOS4gF0p5pyIL2lcbn07XG52YXIgcGFyc2VNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFsvXuS4gC9pLCAvXuS6jC9pLCAvXuS4iS9pLCAvXuWbmy9pLCAvXuS6lC9pLCAvXuWFrS9pLCAvXuS4gy9pLCAvXuWFqy9pLCAvXuS5nS9pLCAvXuWNgSg/ISjkuIB85LqMKSkvaSwgL17ljYHkuIAvaSwgL17ljYHkuowvaV0sXG4gIGFueTogWy9e5LiAfDEvaSwgL17kuox8Mi9pLCAvXuS4iXwzL2ksIC9e5ZubfDQvaSwgL17kupR8NS9pLCAvXuWFrXw2L2ksIC9e5LiDfDcvaSwgL17lhat8OC9pLCAvXuS5nXw5L2ksIC9e5Y2BKD8hKOS4gHzkuowpKXwxMC9pLCAvXuWNgeS4gHwxMS9pLCAvXuWNgeS6jHwxMi9pXVxufTtcbnZhciBtYXRjaERheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW+S4gOS6jOS4ieWbm+S6lOWFreaXpV0vaSxcbiAgc2hvcnQ6IC9eW+S4gOS6jOS4ieWbm+S6lOWFreaXpV0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9e5ZGoW+S4gOS6jOS4ieWbm+S6lOWFreaXpV0vaSxcbiAgd2lkZTogL17mmJ/mnJ9b5LiA5LqM5LiJ5Zub5LqU5YWt5pelXS9pXG59O1xudmFyIHBhcnNlRGF5UGF0dGVybnMgPSB7XG4gIGFueTogWy/ml6UvaSwgL+S4gC9pLCAv5LqML2ksIC/kuIkvaSwgL+Wbmy9pLCAv5LqUL2ksIC/lha0vaV1cbn07XG52YXIgbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyA9IHtcbiAgYW55OiAvXijkuIrljYg/fOS4i+WNiD985Y2I5aScfFvkuK3mraNd5Y2IfOaXqeS4ij985LiL5Y2IfOaZmuS4ij985YeM5pmofCkvaVxufTtcbnZhciBwYXJzZURheVBlcmlvZFBhdHRlcm5zID0ge1xuICBhbnk6IHtcbiAgICBhbTogL17kuIrljYg/L2ksXG4gICAgcG06IC9e5LiL5Y2IPy9pLFxuICAgIG1pZG5pZ2h0OiAvXuWNiOWknC9pLFxuICAgIG5vb246IC9eW+S4reato13ljYgvaSxcbiAgICBtb3JuaW5nOiAvXuaXqeS4ii9pLFxuICAgIGFmdGVybm9vbjogL17kuIvljYgvaSxcbiAgICBldmVuaW5nOiAvXuaZmuS4ij8vaSxcbiAgICBuaWdodDogL17lh4zmmagvaVxuICB9XG59O1xudmFyIG1hdGNoID0ge1xuICBvcmRpbmFsTnVtYmVyOiBidWlsZE1hdGNoUGF0dGVybkZuKHtcbiAgICBtYXRjaFBhdHRlcm46IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgcGFyc2VQYXR0ZXJuOiBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9KSxcbiAgZXJhOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZUVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55JyxcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5OiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICdhbnknLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgbWF0Y2g7IiwiaW1wb3J0IGZvcm1hdERpc3RhbmNlIGZyb20gXCIuL19saWIvZm9ybWF0RGlzdGFuY2UvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRMb25nIGZyb20gXCIuL19saWIvZm9ybWF0TG9uZy9pbmRleC5qc1wiO1xuaW1wb3J0IGZvcm1hdFJlbGF0aXZlIGZyb20gXCIuL19saWIvZm9ybWF0UmVsYXRpdmUvaW5kZXguanNcIjtcbmltcG9ydCBsb2NhbGl6ZSBmcm9tIFwiLi9fbGliL2xvY2FsaXplL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2ggZnJvbSBcIi4vX2xpYi9tYXRjaC9pbmRleC5qc1wiO1xuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IENoaW5lc2UgU2ltcGxpZmllZCBsb2NhbGUuXG4gKiBAbGFuZ3VhZ2UgQ2hpbmVzZSBTaW1wbGlmaWVkXG4gKiBAaXNvLTYzOS0yIHpob1xuICogQGF1dGhvciBDaGFuZ3l1IEdlbmcgW0BLaW5nTWFyaW9de0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nTWFyaW99XG4gKiBAYXV0aG9yIFNvbmcgU2h1b3l1biBbQGZubGN0cmxde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mbmxjdHJsfVxuICogQGF1dGhvciBzYWJyaW5hTSBbQHNhYnJpbmFtaWFvXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2FicmluYW1pYW99XG4gKiBAYXV0aG9yIENhcm5leSBXdSBbQGN1Ymljd29ya117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N1Ymljd29ya31cbiAqIEBhdXRob3IgVGVycmVuY2UgTGFtIFtAc2t5dXBsYW1de0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9za3l1cGxhbX1cbiAqL1xuXG52YXIgbG9jYWxlID0ge1xuICBjb2RlOiAnemgtQ04nLFxuICBmb3JtYXREaXN0YW5jZTogZm9ybWF0RGlzdGFuY2UsXG4gIGZvcm1hdExvbmc6IGZvcm1hdExvbmcsXG4gIGZvcm1hdFJlbGF0aXZlOiBmb3JtYXRSZWxhdGl2ZSxcbiAgbG9jYWxpemU6IGxvY2FsaXplLFxuICBtYXRjaDogbWF0Y2gsXG4gIG9wdGlvbnM6IHtcbiAgICB3ZWVrU3RhcnRzT246IDFcbiAgICAvKiBNb25kYXkgKi9cbiAgICAsXG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiA0XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBsb2NhbGU7IiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCBhZGRNaWxsaXNlY29uZHMgZnJvbSBcIi4uL2FkZE1pbGxpc2Vjb25kcy9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgc3ViTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgc3VidHJhY3RlZC4gUG9zaXRpdmUgZGVjaW1hbHMgd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmZsb29yYCwgZGVjaW1hbHMgbGVzcyB0aGFuIHplcm8gd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmNlaWxgLlxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgc3VidHJhY3RlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJ0cmFjdCA3NTAgbWlsbGlzZWNvbmRzIGZyb20gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN1Yk1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjI5LjI1MFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1Yk1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIGRpcnR5QW1vdW50KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgYW1vdW50ID0gdG9JbnRlZ2VyKGRpcnR5QW1vdW50KTtcbiAgcmV0dXJuIGFkZE1pbGxpc2Vjb25kcyhkaXJ0eURhdGUsIC1hbW91bnQpO1xufSIsImltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgbm9uZSBvZiB0aGUgYWJvdmUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIEludmFsaWQgRGF0ZS5cbiAqXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDbG9uZSB0aGUgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZSgxMzkyMDk4NDMwMDAwKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0RhdGUoYXJndW1lbnQpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpOyAvLyBDbG9uZSB0aGUgZGF0ZVxuXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGFyZ3VtZW50ID09PSAnb2JqZWN0JyAmJiBhcmdTdHIgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ251bWJlcicgfHwgYXJnU3RyID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgU3RyaW5nXScpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIHdpdGggdjIuMC4wLWJldGEuMSBkYXRlLWZucyBkb2Vzbid0IGFjY2VwdCBzdHJpbmdzIGFzIGRhdGUgYXJndW1lbnRzLiBQbGVhc2UgdXNlIGBwYXJzZUlTT2AgdG8gcGFyc2Ugc3RyaW5ncy4gU2VlOiBodHRwczovL2dpdC5pby9manVsZVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufSIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMjEnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJyxcbiAgICAgIElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQgPSAnSW52YWxpZCBgdmFyaWFibGVgIG9wdGlvbiBwYXNzZWQgaW50byBgXy50ZW1wbGF0ZWAnO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbiAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gdmFsaWRhdGUgdGhlIGB2YWxpZGF0ZWAgb3B0aW9uIGluIGBfLnRlbXBsYXRlYCB2YXJpYWJsZS5cbiAgICpcbiAgICogRm9yYmlkcyBjaGFyYWN0ZXJzIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNoYW5nZSB0aGUgbWVhbmluZyBvZiB0aGUgZnVuY3Rpb24gYXJndW1lbnQgZGVmaW5pdGlvbjpcbiAgICogLSBcIigpLFwiIChtb2RpZmljYXRpb24gb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAgICogLSBcIj1cIiAoZGVmYXVsdCB2YWx1ZSlcbiAgICogLSBcIltde31cIiAoZGVzdHJ1Y3R1cmluZyBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICAgKiAtIFwiL1wiIChiZWdpbm5pbmcgb2YgYSBjb21tZW50KVxuICAgKiAtIHdoaXRlc3BhY2VcbiAgICovXG4gIHZhciByZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycyA9IC9bKCk9LHt9XFxbXFxdXFwvXFxzXS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxLFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICByc0RpZ2l0cyxcbiAgICByc0Vtb2ppXG4gIF0uam9pbignfCcpLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgIH1cblxuICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNBcnJheUJ1ZmZlciA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzQXJyYXlCdWZmZXIsXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgICBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cCxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgICAgOiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZm9yYmlkZGVuIGNoYXJhY3RlciB3YXMgZm91bmQgaW4gYHZhcmlhYmxlYCwgdG8gcHJldmVudFxuICAgICAgLy8gcG90ZW50aWFsIGNvbW1hbmQgaW5qZWN0aW9uIGF0dGFja3MuXG4gICAgICBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xuXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCByZXR1cm5pbmcgYHRydWVgIGlmXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNUb2Agd2l0aFxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDIsICdiJzogMSB9LFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KFtfLmFkZCwgc3F1YXJlXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCBfLml0ZXJhdGVlKCd1c2VyJykpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGN1c3RvbSBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jLnRlc3Qoc3RyaW5nKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XG4gICAgICogLy8gPT4gWydkZWYnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgXy5tYXRjaGVzKHsgJ2EnOiA0IH0pXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDEpLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgbWF0Y2hlc0Z1bmMgPSBfLm92ZXJTb21lKFt7ICdhJzogMSB9LCB7ICdhJzogMiB9XSlcbiAgICAgKiB2YXIgbWF0Y2hlc1Byb3BlcnR5RnVuYyA9IF8ub3ZlclNvbWUoW1snYScsIDFdLCBbJ2EnLCAyXV0pXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSArICcnO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZWFsTmFtZXNba2V5XS5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsImZ1bmN0aW9uIGdldFJhbmRvbUludChtYXgpIHtcclxuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcclxufTtcclxuXHJcbmNvbnN0IGdlblJhbmRvbUhleCA9IHNpemUgPT4gWy4uLkFycmF5KHNpemUpXS5tYXAoKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpLnRvU3RyaW5nKDE2KSkuam9pbignJyk7XHJcblxyXG5mdW5jdGlvbiBnZW5SYW5kb21Mb2dpbk1zZygpIHtcclxuICAgIC8vIEUuZy4gXCJMb2dJbi1mYWIxNjRhMy0yZjYzLTAwMGQtMTU5Yi0zYjg2ODY4ZDhmZmVcIlxyXG4gICAgcmV0dXJuIFwiTG9nSW4tXCIgKyBnZW5SYW5kb21IZXgoOCkgKyBcIi1cIiArIGdlblJhbmRvbUhleCg0KSArIFwiLVwiICsgZ2VuUmFuZG9tSGV4KDQpICsgXCItXCIgKyBnZW5SYW5kb21IZXgoNCkgKyBcIi1cIiArIGdlblJhbmRvbUhleCgxMik7XHJcbn1cclxuXHJcbmV4cG9ydCB7IGdldFJhbmRvbUludCwgZ2VuUmFuZG9tTG9naW5Nc2cgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlcnJvcl9tc2cobXNnLCBjYXRlZ29yeSkge1xyXG4gIC8vIE1ha2UgbmljZSBlcnJvciBtZXNzYWdlcyB1c2luZyBCb290c3RyYXAgYWxlcnRzXHJcbiAgY29uc3QgaW5zZXJ0X3N0ciA9IFwiPGRpdiBjbGFzcz0nYWxlcnQgYWxlcnQtZGlzbWlzc2FibGUgZmFkZSBzaG93IGFsZXJ0LVwiICsgY2F0ZWdvcnkgKyBcIic+IFwiICsgbXNnICtcclxuICAgICAgICAgICAgICAgICAgICAgXCIgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuLWNsb3NlJyBkYXRhLWJzLWRpc21pc3M9J2FsZXJ0JyBhcmlhLWxhYmVsPSdDbG9zZScgc3R5bGU9J2Zsb2F0OiByaWdodCc+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCIgICA8L2J1dHRvbj4gPC9kaXY+XCI7XHJcbiAgY29uc29sZS5sb2coaW5zZXJ0X3N0cik7XHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhbGVydC1tZXNzYWdlc1wiKS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGluc2VydF9zdHIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2xlZXAobXMpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XHJcbn0iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJpbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkYXRlLWZucyc7XHJcbmltcG9ydCB7IGVuVVMsIGRlICwgemhDTn0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcclxuY29uc3QgbG9jYWxlX29iaiA9IHtcclxuICAgIFwiZW5cIjogZW5VUyxcclxuICAgIFwiZW4tVVNcIjogZW5VUyxcclxuICAgIFwiZGVcIjogZGUsXHJcbiAgICBcInpoXCI6IHpoQ04sXHJcbiAgICBcInpoLUNOXCI6IHpoQ05cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TGFuZygpIHtcclxuICAgIGlmIChuYXZpZ2F0b3IubGFuZ3VhZ2VzICE9IHVuZGVmaW5lZCkgXHJcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdOyBcclxuICAgIHJldHVybiBuYXZpZ2F0b3IubGFuZ3VhZ2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRMb2NhbGUoKSB7XHJcbiAgICBjb25zdCBsYW5nID0gZ2V0TGFuZygpO1xyXG4gICAgbGV0IGxvY2FsZSA9IGxvY2FsZV9vYmpbbGFuZ107XHJcblxyXG4gICAgaWYgKCFsb2NhbGUpXHJcbiAgICAgICAgbG9jYWxlID0gbG9jYWxlX29ialtcImVuXCJdO1xyXG4gICAgXHJcbiAgICByZXR1cm4gbG9jYWxlO1xyXG59O1xyXG5cclxuY29uc3QgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XHJcbi8vIGNvbnNvbGUubG9nKGxvY2FsZSk7XHJcblxyXG5mdW5jdGlvbiBkYXRlVGltZUZvcm1hdHRlcih0aW1lc3RhbXApIHtcclxuICAgIHJldHVybiBmb3JtYXQobmV3IERhdGUodGltZXN0YW1wKSwgXCJkZC9NTS95eXl5IEhIOm1tXCIpO1xyXG4gICAgLy9yZXR1cm4gZm9ybWF0KG5ldyBEYXRlKHRpbWVzdGFtcCksIFwiUHBcIiwge1wibG9jYWxlXCI6IGxvY2FsZV9vYmpbbG9jYWxlXX0pO1xyXG59XHJcblxyXG53aW5kb3cuZGF0ZVRpbWVGb3JtYXR0ZXIgPSBkYXRlVGltZUZvcm1hdHRlcjtcclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAkKFwiI3RhYmxlLXN0YXRzLW1ldGFtb25zXCIpLm9uKFwicG9zdC1oZWFkZXIuYnMudGFibGVcIiwgYWRqdXN0RXhwb3J0QnV0dG9uKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge31cclxufSk7XHJcblxyXG5mdW5jdGlvbiBhZGp1c3RFeHBvcnRCdXR0b24gKCkge1xyXG4gICAgY29uc3QgZXhwb3J0X2VsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImV4cG9ydFwiKTtcclxuICAgIGlmIChleHBvcnRfZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBleHBvcnRfZWxlbWVudHNbMF07XHJcbiAgICAgICAgY29uc3QgYnV0dG9uID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJ1dHRvblwiKVswXTtcclxuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSBcIkV4cG9ydFwiO1xyXG5cclxuICAgICAgICAvLyBJZiBkYXRhIGlzIG5vdCBhdmFpbGFibGUsIGRpc2FibGUgYnV0dG9uXHJcbiAgICAgICAgaWYgKCEgKCQoXCIjdGFibGUtc3RhdHMtbWV0YW1vbnNcIilbMF0uZGF0YXNldC51cmwpKVxyXG4gICAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgYWRqdXN0VGFibGUoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRqdXN0VGFibGUgKCkge1xyXG4gICAgLy8gTWFrZXMgYm9yZGVycyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0YWJsZSBoZWFkIHRvIHNlcGFyYXRlIFwiTWV0YW1vblwiIGFuZCBcIlJlc3VsdHNcIlxyXG4gICAgY29uc3QgZWwgPSAkKFwiLnRyLWNsYXNzLTFcIilbMF07XHJcbiAgICBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRoXCIpWzFdLnN0eWxlLmJvcmRlckxlZnQgPSBcIjJweCBzb2xpZCAjNDQ0NDQ0XCI7XHJcbiAgICBjb25zdCBlbDIgPSAkKFwiLnRyLWNsYXNzLTJcIilbMF07XHJcbiAgICBlbDIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aFwiKVs1XS5zdHlsZS5ib3JkZXJMZWZ0ID0gXCIycHggc29saWQgIzQ0NDQ0NFwiO1xyXG59IiwiaW1wb3J0IHsgZ2V0UmFuZG9tSW50LCBlcnJvcl9tc2csIHNsZWVwIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcclxuaW1wb3J0IF8sIHsgcmVzdWx0IH0gZnJvbSBcImxvZGFzaFwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0Q29va2llKG5hbWUpIHtcclxuICBjb25zdCB2YWx1ZSA9IGA7ICR7ZG9jdW1lbnQuY29va2llfWA7XHJcbiAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdChgOyAke25hbWV9PWApO1xyXG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHJldHVybiBwYXJ0cy5wb3AoKS5zcGxpdCgnOycpLnNoaWZ0KCk7XHJcbn07XHJcblxyXG5hc3luYyBmdW5jdGlvbiBtYWtlX3JlcXVlc3QoKSB7XHJcbiAgICB2YXIga3ZwYWlycyA9IHt9O1xyXG4gICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFuYWdlci1mb3JtXCIpO1xyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybS5lbGVtZW50cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICB2YXIgZSA9IGZvcm0uZWxlbWVudHNbaV07IFxyXG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjaGVja2JveFwiKVxyXG4gICAgICAgICAgICBrdnBhaXJzW2UubmFtZV0gPSBlLmNoZWNrZWQgPyBcIm9uXCIgOiBcIm9mZlwiO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAga3ZwYWlyc1tlLm5hbWVdID0gZS52YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICBtZXRob2Q6ICdwb3N0JyxcclxuICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnWC1DU1JGLVRPS0VOJzogZ2V0Q29va2llKCdjc3JmX2FjY2Vzc190b2tlbicpLFxyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoa3ZwYWlycylcclxuICAgIH07XHJcblxyXG4gICAgYXdhaXQgZmV0Y2goJy9tYW5hZ2VyJywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG5pZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiYXR0bGUtc3VibWl0LWJ1dHRvblwiKSkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiYXR0bGUtc3VibWl0LWJ1dHRvblwiKS5vbmNsaWNrID0gYXN5bmMgKCk9PntcclxuICAgICAgICAvL2F3YWl0IG1ha2VfcmVxdWVzdCgpO1xyXG4gICAgICAgIGF3YWl0IHN0YXJ0QmF0dGxlcygpO1xyXG4gICAgfTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hfbG9vcCh1cmwsIG1ldGhvZCwgZGF0YSwgaGVhZGVycykge1xyXG4gICAgLy9sZXQgaCA9ICB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ307XHJcbiAgICBsZXQgaCA9ICB7fTtcclxuXHRpZiAoaGVhZGVycykge1xyXG5cdFx0T2JqZWN0LmFzc2lnbihoLCBoZWFkZXJzKTtcclxuXHR9O1xyXG5cclxuXHRjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxyXG4gICAgICAgIGhlYWRlcnM6IGgsXHJcbiAgICAgICAgYm9keTogZGF0YVxyXG4gICAgfTtcclxuXHJcblxyXG5cdGZvciAobGV0IG4gPSAwOyBuIDwgNTsgbisrKSB7XHJcbiAgICAgICAgYXdhaXQgc2xlZXAoMC41KTtcclxuXHRcdHRyeSB7XHJcbiAgICAgICAgICAgIC8vIGF3YWl0IGxvZyhcIkZldGNoIFwiICsgdXJsICsgXCIgXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XHJcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VfanNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgLy9hd2FpdCBsb2coXCJSZXNwb25zZSBcIiArIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlX2pzb24pKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlX2pzb247XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0YXdhaXQgc2xlZXAoMik7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdXJsZW5jb2RlZChvYmopIHtcclxuICAgIHJlc3VsdCA9IF8uam9pbihfLm1hcChPYmplY3QuZW50cmllcyhvYmopLCBmdW5jdGlvbihvKSB7cmV0dXJuIG9bMF0gKyBcIj1cIiArIG9bMV19KSwgXCImXCIpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLy8gVVJMcyB0byBtYWtlIGFwaSBjYWxsc1xyXG5jb25zdCBCQVNFX1VSTCA9IFwiaHR0cHM6Ly9tZXRhbW9uLWFwaS5yYWRpb2NhY2EuY29tL3VzbS1hcGlcIjtcclxuY29uc3QgVE9LRU5fVVJMID0gQkFTRV9VUkwgKyBcIi9sb2dpblwiO1xyXG5jb25zdCBMSVNUX01PTlNURVJfVVJMID0gQkFTRV9VUkwgKyBcIi9nZXRXYWxsZXRQcm9wZXJ0eUJ5U3ltYm9sXCI7XHJcbmNvbnN0IENIQU5HRV9GSUdIVEVSX1VSTCA9IEJBU0VfVVJMICsgXCIvaXNGaWdodE1vbnN0ZXJcIjtcclxuY29uc3QgU1RBUlRfRklHSFRfVVJMID0gQkFTRV9VUkwgKyBcIi9zdGFydEJhdHRsZVwiO1xyXG5jb25zdCBMSVNUX0JBVFRMRVJfVVJMID0gQkFTRV9VUkwgKyBcIi9nZXRCYXR0ZWxPYmplY3RzXCI7XHJcbmNvbnN0IFdBTExFVF9QUk9QRVJUWV9MSVNUID0gQkFTRV9VUkwgKyBcIi9nZXRXYWxsZXRQcm9wZXJ0eUxpc3RcIjtcclxuY29uc3QgTFZMX1VQX1VSTCA9IEJBU0VfVVJMICsgXCIvdXBkYXRlTW9uc3RlclwiO1xyXG5jb25zdCBNSU5UX0VHR19VUkwgPSBCQVNFX1VSTCArIFwiL2NvbXBvc2VNb25zdGVyRWdnXCI7XHJcbmNvbnN0IENIRUNLX0JBR19VUkwgPSBCQVNFX1VSTCArIFwiL2NoZWNrQmFnXCI7XHJcblxyXG5jbGFzcyBNZXRhbW9uSXNsYW5kIHtcclxuXHRjb25zdHJ1Y3RvcihhZGRyZXNzLCBzaWduLCBtc2cpIHtcclxuXHRcdHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XHJcblx0XHR0aGlzLnNpZ24gPSBzaWduO1xyXG5cdFx0dGhpcy5tc2cgPSBtc2c7XHJcblx0XHRcclxuICAgICAgICB0aGlzLm5vdF9lbm91Z2hfbW9uZXkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvdGFsX2JwX251bSA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbF9zdWNjZXNzID0gMDtcclxuICAgICAgICB0aGlzLnRvdGFsX2ZhaWwgPSAwO1xyXG4gICAgICAgIHRoaXMubXRtX3N0YXRzID0gW107XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGw7XHJcblx0fVxyXG5cdFxyXG5cdGFzeW5jIGluaXRUb2tlbigpIHtcclxuXHRcdGNvbnN0IHBheWxvYWQgPSBcImFkZHJlc3M9XCIgKyB0aGlzLmFkZHJlc3MgKyBcIiZzaWduPVwiICsgdGhpcy5zaWduICsgXCImbXNnPVwiICsgdGhpcy5tc2cgKyBcIiZuZXR3b3JrPTFcIjtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoX2xvb3AoVE9LRU5fVVJMLCBcInBvc3RcIiwgcGF5bG9hZCwge1wiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9KTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlW1wiY29kZVwiXSA9PSBcIlNVQ0NFU1NcIikge1xyXG4gICAgICAgICAgICB0aGlzLnRva2VuID0gcmVzcG9uc2UuZGF0YS5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSAgICBcclxuXHR9XHJcblx0XHJcbiAgICBhc3luYyBjaGFuZ2VGaWdodGVyKG1vbnN0ZXJfaWQpIHtcclxuICAgICAgICAvLyBTd2l0Y2ggdG8gbmV4dCBtZXRhbW9uIGlmIHlvdSBoYXZlIGZld1xyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgIFwibWV0YW1vbklkXCI6IG1vbnN0ZXJfaWQsXHJcbiAgICAgICAgICAgIFwiYWRkcmVzc1wiOiB0aGlzLmFkZHJlc3MsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhd2FpdCBmZXRjaF9sb29wKENIQU5HRV9GSUdIVEVSX1VSTCwgXCJwb3N0XCIsIHVybGVuY29kZWQocGF5bG9hZCksIHRoaXMuaGVhZGVyc1Rva2VuQW5kQ1QoKSk7XHJcblx0fVxyXG5cdFxyXG5cdGFzeW5jIGxpc3RPcHBvbmVudHMobW9uc3Rlcl9pZCwgZnJvbnQ9MSkge1xyXG4gICAgICAgIC8vIE9idGFpbiBsaXN0IG9mIG9wcG9uZW50c1xyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgIFwiYWRkcmVzc1wiOiB0aGlzLmFkZHJlc3MsXHJcbiAgICAgICAgICAgIFwibWV0YW1vbklkXCI6IG1vbnN0ZXJfaWQsXHJcbiAgICAgICAgICAgIFwiZnJvbnRcIjogZnJvbnQsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaF9sb29wKExJU1RfQkFUVExFUl9VUkwsIFwicG9zdFwiLCB1cmxlbmNvZGVkKHBheWxvYWQpLCB0aGlzLmhlYWRlcnNUb2tlbkFuZENUKCkpO1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZVtcImRhdGFcIl1bXCJvYmplY3RzXCJdO1xyXG5cdH1cclxuXHJcblx0aGVhZGVyc1Rva2VuICgpIHtcclxuXHRcdHJldHVybiB7XCJhY2Nlc3NUb2tlblwiOiB0aGlzLnRva2VufTtcdFxyXG5cdH1cclxuXHJcbiAgICBoZWFkZXJzVG9rZW5BbmRDVCAoKSB7XHJcblx0XHRyZXR1cm4ge1wiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXHJcbiAgICAgICAgICAgICAgICBcImFjY2Vzc1Rva2VuXCI6IHRoaXMudG9rZW59O1x0XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHRPYnRhaW4gbGlzdCBvZiBNZXRhbW9ucyBpbiB0aGUgd2FsbGV0XHJcblx0ICovXHJcblx0YXN5bmMgdXBkYXRlV2FsbGV0KCkge1xyXG4gICAgICAgIGxldCBkYXRhID0gW107XHJcbiAgICAgICAgbGV0IHBhZ2UgPSAxO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XCJhZGRyZXNzXCI6IHRoaXMuYWRkcmVzcywgXCJwYWdlXCI6IHBhZ2UsIFwicGFnZVNpemVcIjogNjB9O1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoX2xvb3AoV0FMTEVUX1BST1BFUlRZX0xJU1QsIFwicG9zdFwiLCB1cmxlbmNvZGVkKHBheWxvYWQpLCB0aGlzLmhlYWRlcnNUb2tlbkFuZENUKCkpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbXCJjb2RlXCJdICE9IFwiU1VDQ0VTU1wiKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG5cdFx0XHRjb25zdCBtdG1zID0gcmVzcG9uc2VbXCJkYXRhXCJdW1wibWV0YW1vbkxpc3RcIl07XHJcbiAgICAgICAgICAgIGlmIChtdG1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uIDE4LzAxLzIwMjIgdGhlIEFQSSBzZWVtcyB0byBiZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG10bSBvZiBtdG1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0YW1vbl9pZHgobXRtLnRva2VuSWQsIGRhdGEpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChtdG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghYWRkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHBhZ2UgKz0gMTtcclxuXHRcdFx0fVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHRcdH07XHJcblxyXG4gICAgICAgIC8vIFNvcnQgbWV0YW1vbiBsaXN0XHJcbiAgICAgICAgZGF0YS5zb3J0KChtb25zdGVyMSwgbW9uc3RlcjIpID0+IG1vbnN0ZXIxLnRva2VuSWQgLSBtb25zdGVyMi50b2tlbklkKTtcclxuXHRcdFxyXG4gICAgICAgIHRoaXMubWV0YW1vbnMgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgYSBtZXRhbW9uIHdpdGggdG9rZW4gbW9uc3Rlcl90b2tlbl9pZCBpbiB0aGUgbGlzdCBvZiBtZXRhbW9ucy5cclxuICAgICAqL1xyXG4gICAgbWV0YW1vbl9pZHgobW9uc3Rlcl90b2tlbl9pZCwgbWV0YW1vbnMpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IG1vbnN0ZXIgb2YgbWV0YW1vbnMpIHtcclxuICAgICAgICAgICAgaWYgKG1vbnN0ZXIudG9rZW5JZCA9PSBtb25zdGVyX3Rva2VuX2lkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cdFxyXG5cdC8qKlxyXG5cdFBlcmZvcm0gYWxsIGJhdHRsZXMgb2YgYSBsaXN0IG9mIG1vbnN0ZXJzXHJcblx0ICovXHJcblx0YXN5bmMgYmF0dGxlIChtb25zdGVycywgc3RyYXRlZ3k9XCJ3ZWFrZXN0XCIsIGxldmVsdXA9dHJ1ZSkge1xyXG4gICAgICAgIC8vIGNvbnN0IHdhbGxldF9tb25zdGVycyA9IHRoaXMudXBkYXRlV2FsbGV0KCk7XHJcbiAgICAgICAgdGhpcy50b3RhbF9sZXZlbF91cHMgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBtb25zdGVyIG9mIG1vbnN0ZXJzKSB7XHJcblx0XHRcdGlmIChtb25zdGVyLnRlYXIgPT0gMClcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRlYXIgPSBtb25zdGVyLnRlYXI7XHJcbiAgICAgICAgICAgIC8vIGxldmVsID0gbW9uc3Rlci5nZXQoXCJsZXZlbFwiKVxyXG4gICAgICAgICAgICBjb25zdCBiYXR0bGVycyA9IGF3YWl0IHRoaXMubGlzdE9wcG9uZW50cyhtb25zdGVyLmlkKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0dGxlciA9IE1ldGFtb25Jc2xhbmQucGlja09wcG9uZW50KGJhdHRsZXJzLCBzdHJhdGVneSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldF9tb25zdGVyX2lkID0gYmF0dGxlci5pZDtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2hhbmdlRmlnaHRlcihtb25zdGVyLmlkKTtcclxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZDogUGFzcyB0aGUgaW5kZXggb2YgdGhlIG1vbnN0ZXIgaW4gdGhlIGN1cnJlbnQgdGFibGVcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIHVwZGF0ZU1ldGFtb25UYWJsZSB1c2VzIG1ldGFtb24gb2JqZWN0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBiYXR0bGVzXHJcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBsaXN0IG9mIG1ldGFtb25zIGluIG1pIGdldHMgdXBkYXRlZCBhZnRlciBsZXZlbCB1cHMsIHRodXMgaXQgd291bGQgbm90IGZpbmQgdGhlIG1ldGFtb25zIGFueW1vcmVcclxuICAgICAgICAgICAgY29uc3QgbW9uc3Rlcl90YWJsZV9pZHggPSB0aGlzLm1ldGFtb25faWR4KG1vbnN0ZXIudG9rZW5JZCwgdGhpcy5tZXRhbW9ucyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmF0dGxlTWV0YW1vbihtb25zdGVyLCBtb25zdGVyX3RhYmxlX2lkeCwgdGFyZ2V0X21vbnN0ZXJfaWQsIHRlYXIsIGxldmVsdXApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubm90X2Vub3VnaF9tb25leSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdFx0fVxyXG4gICAgICAgIFxyXG5cdFx0Y29uc3QgdG90YWxfY291bnQgPSB0aGlzLnRvdGFsX3N1Y2Nlc3MgKyB0aGlzLnRvdGFsX2ZhaWw7XHJcbiAgICAgICAgbGV0IHN1Y2Nlc3NfcGVyY2VudCA9IDAuMDtcclxuICAgICAgICBpZiAodG90YWxfY291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3NfcGVyY2VudCA9IHRoaXMudG90YWxfc3VjY2VzcyAvIHRvdGFsX2NvdW50O1xyXG5cdFx0fTtcclxuXHJcbiAgICAgICAgLy8gU3RhdHMgb2YgYWxsIGJhdHRsZXNcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgICAgICAgXCJ3b25cIjogdGhpcy50b3RhbF9zdWNjZXNzLFxyXG4gICAgICAgICAgICBcImRlZmVhdHNcIjogdGhpcy50b3RhbF9mYWlsLFxyXG4gICAgICAgICAgICBcIndpbl9yYXRlXCI6IHN1Y2Nlc3NfcGVyY2VudCxcclxuICAgICAgICAgICAgXCJmcmFnbWVudHNcIjogdGhpcy50b3RhbF9icF9udW0sXHJcbiAgICAgICAgICAgIFwibGV2ZWxfdXBzXCI6IHRoaXMudG90YWxfbGV2ZWxfdXBzLFxyXG4gICAgICAgICAgICBcInRpbWVzdGFtcFwiOiBEYXRlLm5vdygpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtzdGF0cywgdGhpcy5tdG1fc3RhdHNdO1xyXG5cdH1cclxuXHRcclxuICAgIC8qKlxyXG5cdE1haW4gbWV0aG9kIGZvciBiYXR0ZWxuZyB3aXRoIGEgc3BlY2lmaWMgbWV0YW1vblxyXG5cdCAqL1xyXG5cdGFzeW5jIGJhdHRsZU1ldGFtb24obW9uc3RlciwgbW9uc3Rlcl90YWJsZV9pZHgsIHRhcmdldF9tb25zdGVyX2lkLCBsb29wX2NvdW50PTEsIGxldmVsdXA9dHJ1ZSkge1xyXG4gICAgICAgIGxldCBzdWNjZXNzID0gMDtcclxuICAgICAgICBsZXQgZmFpbCA9IDA7XHJcbiAgICAgICAgbGV0IHRvdGFsX2JwX2ZyYWdtZW50X251bSA9IDA7XHJcbiAgICAgICAgY29uc3QgbXlfbW9uc3Rlcl9pZCA9IG1vbnN0ZXIuaWQ7XHJcbiAgICAgICAgY29uc3QgbXlfbW9uc3Rlcl90b2tlbl9pZCA9IHBhcnNlSW50KG1vbnN0ZXIudG9rZW5JZCk7XHJcbiAgICAgICAgbGV0IG15X2xldmVsID0gbW9uc3Rlci5sZXZlbDtcclxuICAgICAgICBjb25zdCBteV9wb3dlciA9IG1vbnN0ZXIuc2NhO1xyXG4gICAgICAgIGxldCBiYXR0bGVfbGV2ZWwgPSBNZXRhbW9uSXNsYW5kLnBpY2tCYXR0bGVMZXZlbChteV9sZXZlbCk7XHJcbiAgICAgICAgY29uc3QgaW5pdF90ZWFyID0gbW9uc3Rlci50ZWFyO1xyXG4gICAgICAgIGxldCBleHBlcmllbmNlID0gbW9uc3Rlci5leHA7XHJcbiAgICAgICAgbGV0IGV4cF90b19uZXh0ID0gbW9uc3Rlci5leHBNYXg7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGNvdW50ID0gMDsgY291bnQgPCBsb29wX2NvdW50OyBjb3VudCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgICBcIm1vbnN0ZXJBXCI6IG15X21vbnN0ZXJfaWQsXHJcbiAgICAgICAgICAgICAgICBcIm1vbnN0ZXJCXCI6IHRhcmdldF9tb25zdGVyX2lkLFxyXG4gICAgICAgICAgICAgICAgXCJhZGRyZXNzXCI6IHRoaXMuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIFwiYmF0dGxlTGV2ZWxcIjogYmF0dGxlX2xldmVsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoX2xvb3AoU1RBUlRfRklHSFRfVVJMLCBcInBvc3RcIiwgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSByZXNwb25zZS5jb2RlO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA9PSBcIkJBVFRMRV9OT1BBWVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vdF9lbm91Z2hfbW9uZXkgPSB0cnVlO1xyXG5cdFx0XHRcdGVycm9yX21zZyhcIk5vdCBlbm91Z2ggdVJBQ0EgdG8gcGxheSBvbiBNZXRhbW9uIElzbGFuZCFcIiwgXCJkYW5nZXJcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHRcdFx0fVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09IFwiU1VDQ0VTU1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZ2h0X3Jlc3VsdCA9IGRhdGEuY2hhbGxlbmdlUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnBfZnJhZ21lbnRfbnVtID0gZGF0YS5icEZyYWdtZW50TnVtO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZXJpZW5jZV9pbmNyID0gZGF0YS5jaGFsbGVuZ2VFeHA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbGV2ZWwgdXBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1wibmZ0SWRcIjogbXlfbW9uc3Rlcl9pZCwgXCJhZGRyZXNzXCI6IHRoaXMuYWRkcmVzc31cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaF9sb29wKExWTF9VUF9VUkwsIFwicG9zdFwiLCAgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gcmVzLmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT0gXCJTVUNDRVNTXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXlfbGV2ZWwgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxlYWd1ZSBsZXZlbCBpZiBuZXcgbGV2ZWwgaXMgMjEgb3IgNDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0dGxlX2xldmVsID0gTWV0YW1vbklzbGFuZC5waWNrQmF0dGxlTGV2ZWwobXlfbGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsX2xldmVsX3VwcyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlcmllbmNlID0gZXhwZXJpZW5jZSAtIGV4cF90b19uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byB1cGRhdGUgdGhlIG1ldGFtb24gdG8gdXBkYXRlIHRoZSBleHBNYXggZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsX21vbnN0ZXJzID0gYXdhaXQgdGhpcy51cGRhdGVXYWxsZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwX3RvX25leHQgPSBhbGxfbW9uc3RlcnMuZmluZChlbGVtZW50ID0+IGVsZW1lbnQudG9rZW5JZCA9PSBteV9tb25zdGVyX3Rva2VuX2lkKS5leHBNYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbF9icF9udW0gKz0gYnBfZnJhZ21lbnRfbnVtO1xyXG4gICAgICAgICAgICAgICAgdG90YWxfYnBfZnJhZ21lbnRfbnVtICs9IGJwX2ZyYWdtZW50X251bTtcclxuICAgICAgICAgICAgICAgIGV4cGVyaWVuY2UgKz0gZXhwZXJpZW5jZV9pbmNyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZ2h0X3Jlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsX3N1Y2Nlc3MgKz0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG90YWxfZmFpbCArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBzdGF0ZSBpbiBVSVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlTWV0YW1vblRhYmxlKG1vbnN0ZXIsIG1vbnN0ZXJfdGFibGVfaWR4LCBteV9sZXZlbCwgZXhwZXJpZW5jZSwgaW5pdF90ZWFyIC0gY291bnQgLSAxLCBwcm9ncmVzc19mcm9tX3RlYXIoaW5pdF90ZWFyIC0gY291bnQgLSAxKSwgc3VjY2VzcywgdG90YWxfYnBfZnJhZ21lbnRfbnVtKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyX210bV9zdGF0cyA9IHtcclxuICAgICAgICAgICAgXCJtZXRhbW9uX2lkXCI6IG15X21vbnN0ZXJfdG9rZW5faWQsXHJcbiAgICAgICAgICAgIFwibGVhZ3VlX2xldmVsXCI6IGJhdHRsZV9sZXZlbCxcclxuICAgICAgICAgICAgXCJiYXR0bGVzXCI6IGxvb3BfY291bnQsXHJcbiAgICAgICAgICAgIFwicG93ZXJcIjogbXlfcG93ZXIsXHJcbiAgICAgICAgICAgIFwiZXhwZXJpZW5jZVwiOiBleHBlcmllbmNlLFxyXG4gICAgICAgICAgICBcIm1ldGFtb25fbGV2ZWxcIjogbXlfbGV2ZWwsXHJcbiAgICAgICAgICAgIFwicmFyaXR5XCI6IG1vbnN0ZXIucmFyaXR5LFxyXG4gICAgICAgICAgICBcIndvblwiOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICBcImZyYWdtZW50c1wiOiB0b3RhbF9icF9mcmFnbWVudF9udW0sXHJcbiAgICAgICAgICAgIFwidGltZXN0YW1wXCI6IERhdGUubm93KClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdG1fc3RhdHMucHVzaChjdXJyX210bV9zdGF0cyk7XHJcbiAgICB9XHJcblx0XHJcblx0YXN5bmMgbWludEVnZ3MgKCkge1xyXG4gICAgICAgIC8vIGF3YWl0IHRoaXMuaW5pdF90b2tlbigpO1xyXG5cclxuXHRcdGNvbnN0IHBheWxvYWQgPSB7XCJhZGRyZXNzXCI6IHRoaXMuYWRkcmVzc307XHJcblx0XHRsZXQgdG90YWxFZ2dGcmFnbWVudHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBjdXJyZW50IGVnZyBmcmFnbWVudHNcclxuXHRcdGNvbnN0IGJhZ1JlcyA9IGF3YWl0IGZldGNoX2xvb3AoQ0hFQ0tfQkFHX1VSTCwgXCJwb3N0XCIsIHVybGVuY29kZWQocGF5bG9hZCksIHRoaXMuaGVhZGVyc1Rva2VuQW5kQ1QoKSk7XHJcblxyXG5cdFx0Y29uc3QgaXRlbXMgPSBiYWdSZXMuZGF0YS5pdGVtOyBcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcclxuXHRcdFx0aWYgKGl0ZW0uYnBUeXBlID09IDEpIHtcclxuXHRcdFx0XHR0b3RhbEVnZ0ZyYWdtZW50cyA9IGl0ZW0uYnBOdW07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuICAgICAgICBjb25zdCB0b3RhbEVnZ3MgPSBwYXJzZUludChwYXJzZUludCh0b3RhbEVnZ0ZyYWdtZW50cykgLyAxMDAwKTtcclxuXHJcblx0XHRpZiAodG90YWxFZ2dzIDwgMSkgXHJcblx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoX2xvb3AoTUlOVF9FR0dfVVJMLCBcInBvc3RcIiwgdXJsZW5jb2RlZChwYXlsb2FkKSwgdGhpcy5oZWFkZXJzVG9rZW5BbmRDVCgpKTtcclxuXHRcdGNvbnN0IGNvZGUgPSByZXNbXCJjb2RlXCJdO1xyXG5cdFx0aWYgKGNvZGUgIT0gXCJTVUNDRVNTXCIpXHJcblx0XHRcdHJldHVybiAwO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIk1pbnRlZCBFZ2dzIFRvdGFsOiBcIiArIHRvdGFsRWdncyk7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsRWdncztcclxuXHR9XHJcblx0XHJcblx0Ly8gU3RhdGljIG1ldGhvZHNcclxuXHRcclxuXHQvKipcclxuXHRQaWNrIGFuIG9wcG9uZW50IGFjY29yZGluZyB0byBhIGdpdmVuIHN0cmF0ZWd5IChcIndlYWtlc3RcIiBvciBcInJhbmRvbVwiKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBwaWNrT3Bwb25lbnQobW9uc3RlcnNfbGlzdCwgc3RyYXRlZ3k9XCJ3ZWFrZXN0XCIpIHtcclxuXHQgICAgbGV0IGJhdHRsZXJzID0gW107XHJcblx0XHRmb3IgKGxldCBtb25zdGVyIG9mIG1vbnN0ZXJzX2xpc3QpIHtcclxuXHRcdFx0aWYgKG1vbnN0ZXJbXCJyYXJpdHlcIl0gPT0gXCJOXCIpXHJcblx0XHRcdFx0YmF0dGxlcnMucHVzaChtb25zdGVyKTtcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdGlmIChiYXR0bGVycy5sZW5ndGggPT0gMCkge1xyXG5cdFx0XHRmb3IgKGxldCBtb25zdGVyIG9mIG1vbnN0ZXJzX2xpc3QpIHtcclxuXHRcdFx0XHRpZiAobW9uc3RlcltcInJhcml0eVwiXSA9PSBcIlJcIilcclxuXHRcdFx0XHRcdGJhdHRsZXJzLnB1c2gobW9uc3Rlcik7XHJcblx0XHRcdH07XHRcdFxyXG5cdFx0fTtcclxuXHQgICAgICAgIFxyXG5cdFxyXG5cdCAgICBpZiAoc3RyYXRlZ3kgPT0gXCJ3ZWFrZXN0XCIpXHJcblx0ICAgICAgICByZXR1cm4gTWV0YW1vbklzbGFuZC5waWNrT3Bwb25lbnRXZWFrZXN0KGJhdHRsZXJzKTtcclxuXHRcdGVsc2UgaWYgKHN0cmF0ZWd5ID09IFwicmFuZG9tXCIpXHJcblx0ICAgICAgICByZXR1cm4gTWV0YW1vbklzbGFuZC5waWNrT3Bwb25lbnRSYW5kb20oYmF0dGxlcnMpO1x0XHRcclxuXHR9O1xyXG5cdFxyXG5cdHN0YXRpYyBwaWNrT3Bwb25lbnRSYW5kb20oYmF0dGxlcnMpIHtcclxuXHQgICAgcmV0dXJuIGJhdHRsZXJzW2dldFJhbmRvbUludChsZW4oYmF0dGxlcnMpKV07XHJcblx0fTtcclxuXHRcclxuXHRzdGF0aWMgcGlja09wcG9uZW50V2Vha2VzdChiYXR0bGVycykge1xyXG5cdCAgICBsZXQgYmVzdF9iYXR0bGVyID0gYmF0dGxlcnNbMF07XHJcblx0ICAgIGxldCBzY29yZV9taW4gPSBiZXN0X2JhdHRsZXJbXCJzY2FcIl07XHJcblx0ICAgIFxyXG5cdFx0Zm9yIChsZXQgYmF0dGxlciBvZiBiYXR0bGVycykge1xyXG5cdCAgICAgICAgaWYgKGJhdHRsZXJbXCJzY2FcIl0gPCBzY29yZV9taW4pIHtcclxuXHQgICAgICAgICAgICBiZXN0X2JhdHRsZXIgPSBiYXR0bGVyO1xyXG5cdCAgICAgICAgICAgIHNjb3JlX21pbiA9IGJhdHRsZXJbXCJzY2FcIl07XHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cdCAgICByZXR1cm4gYmVzdF9iYXR0bGVyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0UGljayBhIGJhdHRsZSBsZWFndWUgKGN1cnJlbnRseSB0aGVyZSBhcmUgMyEpXHJcblx0ICovXHJcblx0c3RhdGljIHBpY2tCYXR0bGVMZXZlbCAobGV2ZWw9MSkge1xyXG5cdCAgICBpZiAoKDIxIDw9IGxldmVsKSAmJiAobGV2ZWwgPD0gNDApKSB7XHJcblx0ICAgICAgICByZXR1cm4gMjtcclxuXHRcdH0gZWxzZSBpZiAoKDQxIDw9IGxldmVsKSAmJiAobGV2ZWwgPD0gNjApKSB7XHJcblx0ICAgICAgICByZXR1cm4gMztcclxuXHRcdH1cclxuXHRcdFxyXG5cdCAgICByZXR1cm4gMTtcclxuXHR9O1xyXG59O1xyXG5cclxubGV0IG1pID0gbnVsbDtcclxuY29uc3QgTUFYX1RFQVIgPSAyMDtcclxuXHJcbmZ1bmN0aW9uIHByb2dyZXNzX2Zyb21fdGVhcih0ZWFyKSB7XHJcbiAgICByZXR1cm4gKE1BWF9URUFSIC0gdGVhcikqMTAwLjAvTUFYX1RFQVI7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhbW9ucyAoYWRkcmVzcywgc2lnbiwgbXNnKSB7XHJcbiAgICBlbmFibGVfc3VibWl0X2J1dHRvbihmYWxzZSk7XHJcbiAgICBzaG93X3NwaW5uZXIodHJ1ZSk7XHJcbiAgICBidXR0b25fdGV4dChcIkxvYWRpbmcuLi5cIik7XHJcblxyXG4gICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgaWYgKG1pID09IG51bGwpIHtcclxuICAgICAgICBtaSA9IG5ldyBNZXRhbW9uSXNsYW5kKGFkZHJlc3MsIHNpZ24sIG1zZyk7XHJcbiAgICAgICAgc3VjY2VzcyA9IGF3YWl0IG1pLmluaXRUb2tlbigpO1xyXG5cclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgZXJyb3JfbXNnKFwiQ291bGQgbm90IGxvZ2luIHRvIE1ldGFtb24gSXNsYW5kIVwiLCBcImRhbmdlclwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN1Y2Nlc3MpIHtcclxuICAgICAgICBjb25zdCBtZXRhbW9ucyA9IGF3YWl0IG1pLnVwZGF0ZVdhbGxldCgpO1xyXG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gXy5tYXAobWV0YW1vbnMsIGZ1bmN0aW9uIChtKSB7cmV0dXJuIHByb2dyZXNzX2Zyb21fdGVhcihtLnRlYXIpO30pO1xyXG4gICAgICAgIGNvbnN0IHdpbnMgPSBBcnJheS5mcm9tKCctJy5yZXBlYXQobWV0YW1vbnMubGVuZ3RoKSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRzID0gQXJyYXkuZnJvbSgnLScucmVwZWF0KG1ldGFtb25zLmxlbmd0aCkpO1xyXG5cclxuICAgICAgICBmaWxsTWV0YW1vblRhYmxlKG1ldGFtb25zLCBwcm9ncmVzcywgd2lucywgZnJhZ21lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBlbmFibGVfc3VibWl0X2J1dHRvbih0cnVlKTtcclxuICAgIHNob3dfc3Bpbm5lcihmYWxzZSk7XHJcbiAgICBidXR0b25fdGV4dChcIlN0YXJ0IGJhdHRsZXMhXCIpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzdGFydEJhdHRsZXMgKCkge1xyXG4gICAgaWYgKCFtaSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgZW5hYmxlX3N1Ym1pdF9idXR0b24oZmFsc2UpO1xyXG4gICAgc2hvd19zcGlubmVyKHRydWUpO1xyXG4gICAgYnV0dG9uX3RleHQoXCJCYXR0bGluZy4uLlwiKTtcclxuXHJcbiAgICBjb25zdCBzdHJhdGVneSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RyYXRlZ3lcIikudmFsdWU7XHJcbiAgICBjb25zdCBsZXZlbHVwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZXZlbHVwXCIpLmNoZWNrZWQ7XHJcbiAgICBjb25zdCBtaW50ZWdncyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWludGVnZ3NcIikuY2hlY2tlZDtcclxuICAgIGNvbnN0IHN0YXRpc3RpY3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRpc3RpY3NcIikuY2hlY2tlZDtcclxuXHJcbiAgICBsZXQgbWV0YW1vbnNfdG9fcGxheSA9IFtdO1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGZvciAobGV0IG1ldGFtb24gb2YgbWkubWV0YW1vbnMpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtdG1cIiArIGNvdW50KS5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIG1ldGFtb25zX3RvX3BsYXkucHVzaChtZXRhbW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtaS5iYXR0bGUobWV0YW1vbnNfdG9fcGxheSwgc3RyYXRlZ3ksIGxldmVsdXApO1xyXG5cclxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gcmVzdWx0WzBdO1xyXG4gICAgICAgIGNvbnN0IG10bV9zdGF0cyA9IHJlc3VsdFsxXTtcclxuICAgICAgICBcclxuICAgICAgICBzdGF0cy5taW50ZWRfZWdncyA9IDA7XHJcbiAgICAgICAgaWYgKG1pbnRlZ2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbnRlZF9lZ2dzID0gYXdhaXQgbWkubWludEVnZ3MoKTtcclxuICAgICAgICAgICAgc3RhdHMubWludGVkX2VnZ3MgPSBtaW50ZWRfZWdncztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGF0aXN0aWNzKVxyXG4gICAgICAgICAgICBzZW5kU3RhdHMoW3N0YXRzLCBtdG1fc3RhdHNdKTtcclxuXHJcbiAgICAgICAgZmlsbFN1bW1hcnlUYWJsZShzdGF0cyk7XHJcbiAgICAgICAgc2hvd19iYXR0bGVfcmVzdWx0cygpO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgbWkudXBkYXRlV2FsbGV0KCk7XHJcbiAgICBcclxuICAgIGVuYWJsZV9zdWJtaXRfYnV0dG9uKHRydWUpO1xyXG4gICAgc2hvd19zcGlubmVyKGZhbHNlKTtcclxuICAgIGJ1dHRvbl90ZXh0KFwiU3RhcnQgYmF0dGxlcyFcIik7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRTdGF0cyhkYXRhKSB7XHJcbiAgICBhd2FpdCBmZXRjaCgnc3RhdHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAncG9zdCcsXHJcbiAgICAgICAgaGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAgICdYLUNTUkYtVE9LRU4nOiBnZXRDb29raWUoJ2NzcmZfYWNjZXNzX3Rva2VuJyl9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gVXNlciBJbnRlcmZhY2VcclxuXHJcbmZ1bmN0aW9uIGZpbGxNZXRhbW9uVGFibGUgKG1ldGFtb25zLCBwcm9ncmVzcywgd2lucywgZnJhZ21lbnRzKSB7XHJcbiAgICBjb25zdCB0YWJsZV9ib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZXRhbW9uX3RhYmxlX2JvZHlcIik7XHJcblxyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuXHRmb3IgKGxldCBtZXRhbW9uIG9mIG1ldGFtb25zKSB7XHJcblx0XHQvLyA8dHI+XHRcclxuXHRcdGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrYm94XHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPiA8aW5wdXQgaWQ9XCJtdG0nICsgY291bnQgKyAnXCIgbmFtZT1cIm10bScgKyBjb3VudCArICdcIiB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cInNlbGVjdC1pdGVtIGNoZWNrYm94IGZvcm0tY2hlY2staW5wdXRcIiBjaGVja2VkPiA8L3RkPicpO1xyXG4gICAgICAgIC8vIERhdGE6IFRva2VuIElkXHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPicgKyBtZXRhbW9uLnRva2VuSWQgKyAnIDwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogUGljXHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPiA8aW1nIHNyYz1cIicgKyBtZXRhbW9uLmltYWdlVXJsICArICdcIiBhbHQ9XCInICsgbWV0YW1vbi50b2tlbklkICsgJ1wiPjwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogUmFyaXR5XHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPicgKyBtZXRhbW9uLnJhcml0eSArICc8L3RkPicpO1xyXG4gICAgICAgIC8vIERhdGE6IFBvd2VyXHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPicgKyBtZXRhbW9uLnNjYSArICc8L3RkPicpO1xyXG4gICAgICAgIC8vIERhdGE6IExldmVsXHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPicgKyBtZXRhbW9uLmxldmVsICsgJzxpPi8nICsgbWV0YW1vbi5sZXZlbE1heCArICc8L2k+PC90ZD4nKTtcclxuICAgICAgICAvLyBEYXRhOiBFeHBlcmllbmNlXHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPicgKyBtZXRhbW9uLmV4cCArICc8L3RkPicpO1xyXG4gICAgICAgIC8vIERhdGE6IEV4cGVyaWVuY2VcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIG1ldGFtb24udGVhciArICc8aT4vMjA8L2k+PC90ZD4nKTtcclxuICAgICAgICAvLyBEYXRhOiBQcm9ncmVzcyBiYXJcclxuICAgICAgICBsZXQgYWRkX2NsYXNzID0gXCJcIjtcclxuICAgICAgICBpZiAocHJvZ3Jlc3NbY291bnRdID09IDEwMCkge1xyXG4gICAgICAgICAgICBhZGRfY2xhc3MgPSBcInByb2dyZXNzX2ZpbmlzaGVkXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJvdy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgJzx0ZD4gPGRpdiBjbGFzcz1cInByb2dyZXNzXCI+IDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXIgJyArIGFkZF9jbGFzcyArICdcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiBzdHlsZT1cIndpZHRoOiAnICsgcHJvZ3Jlc3NbY291bnRdICsgJyVcIiBhcmlhLXZhbHVlbm93PVwiJyArIHByb2dyZXNzW2NvdW50XSArICdcIiBhcmlhLXZhbHVlbWluPVwiMFwiIGFyaWEtdmFsdWVtYXg9XCIxMDBcIj48L2Rpdj48L2Rpdj48L3RkPicpO1xyXG4gICAgICAgIC8vIERhdGE6IFdpbnNcclxuICAgICAgICByb3cuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsICc8dGQ+JyArIHdpbnNbY291bnRdICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgLy8gRGF0YTogRnJhZ21lbnRzXHJcbiAgICAgICAgcm93Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCAnPHRkPicgKyBmcmFnbWVudHNbY291bnRdICsgJzwvdGQ+Jyk7XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBhIG5ldyByb3cgdG8gdGFibGVcclxuICAgICAgICB0YWJsZV9ib2R5LmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgY291bnQrKztcclxuXHR9XHJcblxyXG4gICAgc2V0Q2hlY2tib3hPbkNsaWNrRXZlbnRzKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVNZXRhbW9uVGFibGUgKG1ldGFtb24sIG1vbnN0ZXJfdGFibGVfaWR4LCBsZXZlbCwgZXhwZXJpZW5jZSwgdGVhciwgcHJvZ3Jlc3MsIHdpbnMsIGZyYWdtZW50cykge1xyXG4gICAgY29uc3QgdGFibGVfYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWV0YW1vbl90YWJsZV9ib2R5XCIpO1xyXG5cclxuICAgIGNvbnN0IHRyX3RhZyA9IHRhYmxlX2JvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0clwiKVttb25zdGVyX3RhYmxlX2lkeF07XHJcblxyXG4gICAgaWYgKCF0cl90YWcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh0YWJsZV9ib2R5LCBtb25zdGVyX3RhYmxlX2lkeCwgdGFibGVfYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRyXCIpLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGRfdGFncyA9IHRyX3RhZy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRkXCIpO1xyXG5cclxuICAgIHRkX3RhZ3NbNV0uaW5uZXJIVE1MID0gbGV2ZWwgKyAnPGk+LycgKyBtZXRhbW9uLmxldmVsTWF4ICsgJzwvaT4nO1xyXG4gICAgdGRfdGFnc1s2XS5pbm5lckhUTUwgPSBTdHJpbmcoZXhwZXJpZW5jZSk7XHJcbiAgICB0ZF90YWdzWzddLmlubmVySFRNTCA9IHRlYXIgKyAnPGk+LycgKyBNQVhfVEVBUiArICc8L2k+JztcclxuICAgIGxldCBhZGRfY2xhc3MgPSBcIlwiO1xyXG4gICAgaWYgKHByb2dyZXNzID09IDEwMCkge1xyXG4gICAgICAgIGFkZF9jbGFzcyA9IFwicHJvZ3Jlc3NfZmluaXNoZWRcIlxyXG4gICAgfTtcclxuICAgIHRkX3RhZ3NbOF0uaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiPiA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyICcgKyBhZGRfY2xhc3MgKyAnXCIgcm9sZT1cInByb2dyZXNzYmFyXCIgc3R5bGU9XCJ3aWR0aDogJyArIHByb2dyZXNzICsgJyVcIiBhcmlhLXZhbHVlbm93PVwiJyArIHByb2dyZXNzICsgJ1wiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiPjwvZGl2PjwvZGl2Pic7XHJcbiAgICB0ZF90YWdzWzldLmlubmVySFRNTCA9IFN0cmluZyh3aW5zKTtcclxuICAgIHRkX3RhZ3NbMTBdLmlubmVySFRNTCA9IFN0cmluZyhmcmFnbWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWxsU3VtbWFyeVRhYmxlIChzdGF0cykge1xyXG4gICAgY29uc3QgdGFibGVfYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmF0dGxlLXJlc3VsdHNcIik7XHJcblxyXG4gICAgY29uc3Qgc3RhdHNfbGlzdCA9IFtzdGF0c1tcIndvblwiXSArIHN0YXRzW1wiZGVmZWF0c1wiXSwgc3RhdHNbXCJ3b25cIl0sIHN0YXRzW1wiZGVmZWF0c1wiXSwgKE1hdGgucm91bmQoc3RhdHNbXCJ3aW5fcmF0ZVwiXSAqIDEwMDApIC8gMTApLnRvRml4ZWQoMSkgKyBcIiVcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzW1wiZnJhZ21lbnRzXCJdLCBzdGF0c1tcIm1pbnRlZF9lZ2dzXCJdLCBzdGF0c1tcImxldmVsX3Vwc1wiXV07XHJcbiAgICBjb25zdCB0cl90YWdzID0gdGFibGVfYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRyXCIpO1xyXG4gICAgZm9yIChsZXQgbiA9IDAgOyBuIDwgc3RhdHNfbGlzdC5sZW5ndGggOyBuKyspIHtcclxuICAgICAgICBjb25zdCB0ZF90YWcgPSB0cl90YWdzW25dLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIilbMV07XHJcbiAgICAgICAgdGRfdGFnLmlubmVySFRNTCA9IFN0cmluZyhzdGF0c19saXN0W25dKTtcclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGJ1dHRvbl90ZXh0IChsYWJlbCkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiYXR0bGUtc3VibWl0LWJ1dHRvbi10ZXh0XCIpLnRleHRDb250ZW50ID0gbGFiZWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuYWJsZV9zdWJtaXRfYnV0dG9uICh2YWx1ZSkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiYXR0bGUtc3VibWl0LWJ1dHRvblwiKS5kaXNhYmxlZCA9ICF2YWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd19zcGlubmVyICh2YWx1ZSkge1xyXG4gICAgbGV0IHN0cl92YWwgPSB2YWx1ZSA/IFwiXCIgOiBcIm5vbmVcIjtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmF0dGxlLXN1Ym1pdC1idXR0b25cIikuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNwaW5uZXItYm9yZGVyXCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBzdHJfdmFsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93X2JhdHRsZV9yZXN1bHRzICgpIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmF0dGxlLXN1Ym1pdC1idXR0b25cIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0Q2hlY2tib3hPbkNsaWNrRXZlbnRzKCkge1xyXG4gICAgLy9jb2x1bW4gY2hlY2tib3ggc2VsZWN0IGFsbCBvciBjYW5jZWxcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJzZWxlY3QtYWxsXCIpWzBdLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2VsZWN0LWl0ZW0nKSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaXRlbS5jaGVja2VkID0gY2hlY2tlZDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy9jaGVjayBzZWxlY3RlZCBpdGVtc1xyXG4gICAgW10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJzZWxlY3QtaXRlbVwiKSwgKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgaXRlbS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGxldCBhbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic2VsZWN0LWFsbFwiKVswXTtcclxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGJveGVzXHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlbGVjdC1pdGVtXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGNoZWNrZWQgYm94ZXNcclxuICAgICAgICAgICAgbGV0IG51bV9jaGVja2VkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNlbGVjdC1pdGVtOmNoZWNrZWQnKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGFsbC5jaGVja2VkID0gbnVtX2NoZWNrZWQ9PT10b3RhbDtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG52YXIgdG9vbHRpcFRyaWdnZXJMaXN0ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCJdJykpXHJcbnZhciB0b29sdGlwTGlzdCA9IHRvb2x0aXBUcmlnZ2VyTGlzdC5tYXAoZnVuY3Rpb24gKHRvb2x0aXBUcmlnZ2VyRWwpIHtcclxuICByZXR1cm4gbmV3IGJvb3RzdHJhcC5Ub29sdGlwKHRvb2x0aXBUcmlnZ2VyRWwpXHJcbn0pXHJcblxyXG5cclxud2luZG93LmxvYWRNZXRhbW9ucyA9IGxvYWRNZXRhbW9ucztcclxuLy93aW5kb3cuc3RhcnRCYXR0bGVzID0gc3RhcnRCYXR0bGVzOyIsImltcG9ydCB7IGxvZ2luIH0gZnJvbSAnLi9sb2dpbi1hdXRoLmpzJztcclxuaW1wb3J0IHsgZXJyb3JfbXNnIH0gZnJvbSAnLi91dGlscy5qcyc7XHJcblxyXG5jb25zdCBCU0NfQ0hBSU5fSUQgPSA1NjtcclxuXHJcbltdLmZvckVhY2guY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibWV0YW1hc2stbG9naW5cIiksIChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgaXRlbS5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xyXG5cdFx0bG9naW5fbWV0YW1hc2soKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gbG9naW5fbWV0YW1hc2soKSB7XHJcblx0Y29uc3QgcHJvdmlkZXIgPSBhd2FpdCBkZXRlY3RFdGhlcmV1bVByb3ZpZGVyKClcclxuXHJcblx0aWYgKHByb3ZpZGVyKSB7XHJcblx0XHR0cnkgIHtcclxuXHRcdFx0aWYgKCFhd2FpdCBjaGVja19jaGFpbihwcm92aWRlcikpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHdhbGxldF9hZGRyZXNzID0gYXdhaXQgZ2V0X3dhbGxldF9hZGRyZXNzKHByb3ZpZGVyKTtcclxuXHRcdFx0YXdhaXQgbG9naW4od2FsbGV0X2FkZHJlc3MsIHByb3ZpZGVyKTtcclxuXHRcdH1cclxuXHRcdGNhdGNoKGVycm9yKSB7XHJcblx0XHRcdGlmIChlcnJvci5jb2RlID09IDQwMDEpIHtcclxuXHRcdFx0XHRlcnJvcl9tc2coXCJBbiBlcnJvciBvY2N1cnJlZC4gVHJ5IGFnYWluIGFuZCBpZiB0aGUgZXJyb3IgcGVyc2lzdHMsIHBsZWFzZSBjb250YWN0IG1lLlwiLCBcImRhbmdlclwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0ICBlcnJvcl9tc2coXCJDYW5ub3QgZmluZCBNZXRhbWFzayFcIiwgXCJkYW5nZXJcIik7XHJcblx0ICByZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59O1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gY2hlY2tfY2hhaW4ocHJvdmlkZXIpXHJcbntcclxuXHRpZiAocHJvdmlkZXIuY2hhaW5JZCAhPT0gQlNDX0NIQUlOX0lEKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0ICBcdGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xyXG5cdFx0XHRcdG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcclxuXHRcdFx0XHRwYXJhbXM6IFt7IGNoYWluSWQ6IFwiMHgzOFwiIH1dXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdC8vIFRoaXMgZXJyb3IgY29kZSBpbmRpY2F0ZXMgdGhhdCB0aGUgY2hhaW4gaGFzIG5vdCBiZWVuIGFkZGVkIHRvIE1ldGFNYXNrXHJcblx0XHRcdGlmIChlcnIuY29kZSA9PT0gNDkwMikge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcclxuXHRcdFx0XHRcdFx0bWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxyXG5cdFx0XHRcdFx0XHRwYXJhbXM6IFtcclxuXHRcdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0Y2hhaW5OYW1lOiAnQmluYW5jZSBDaGFpbicsXHJcblx0XHRcdFx0XHRcdFx0Y2hhaW5JZDogXCIweDM4XCIsXHJcblx0XHRcdFx0XHRcdFx0bmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogJ0JOQicsIGRlY2ltYWxzOiAxOCwgc3ltYm9sOiAnQk5CJyB9LFxyXG5cdFx0XHRcdFx0XHRcdHJwY1VybHM6IFsnaHR0cHM6Ly9ic2MtZGF0YXNlZWQuYmluYW5jZS5vcmcvJ11cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdF1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHRlcnJvcl9tc2coXCJZb3UgbmVlZCB0byBzd2l0Y2ggdG8gQmluYW5jZSBDaGFpbiB0byBsb2dpbiFcIiwgXCJkYW5nZXJcIik7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldF93YWxsZXRfYWRkcmVzcyhwcm92aWRlcilcclxue1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHttZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wifSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWzBdO1xyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgbG9naW4sIGhhbmRsZV9hdXRoIH0gZnJvbSBcIi4vbG9naW4tYXV0aC5qc1wiO1xyXG5pbXBvcnQgeyBnZW5SYW5kb21Mb2dpbk1zZywgZXJyb3JfbXNnIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSBcIi4vZXRoZXJzLTUuMS5lc20ubWluLmpzXCI7XHJcblxyXG4vL2ltcG9ydCBsb2Rhc2ggZnJvbSAnbG9kYXNoJztcclxuLy8gaW1wb3J0IFdlYjMgZnJvbSBcIndlYjMtcHJvdmlkZXItZW5naW5lXCI7XHJcbi8vaW1wb3J0IFdhbGxldENvbm5lY3RQcm92aWRlciBmcm9tIFwiLi93YWxsZXRjb25uZWN0LXdlYjMtcHJvdmlkZXJcIjtcclxuXHJcbi8qIGltcG9ydCBXYWxsZXRDb25uZWN0Q2xpZW50IGZyb20gXCJAd2FsbGV0Y29ubmVjdC9jbGllbnRcIjsgKi9cclxuLy9jb25zdCBXYWxsZXRDb25uZWN0UHJvdmlkZXIgPSB3aW5kb3cuV2FsbGV0Q29ubmVjdFByb3ZpZGVyLmRlZmF1bHQ7XHJcbi8vY29uc3QgV2ViMyA9IHdpbmRvdy5XZWIzLmRlZmF1bHQ7XHJcbmxldCBXYWxsZXRDb25uZWN0UHJvdmlkZXI7XHJcbmlmICh3aW5kb3cuV2FsbGV0Q29ubmVjdFByb3ZpZGVyKVxyXG4gICAgV2FsbGV0Q29ubmVjdFByb3ZpZGVyID0gd2luZG93LldhbGxldENvbm5lY3RQcm92aWRlci5kZWZhdWx0O1xyXG4gXHJcbmxldCB3Y19wcm92aWRlcjtcclxuIFxyXG5bXS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIndhbGxldGNvbm5lY3QtbG9naW5cIiksIChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgaXRlbS5vbmNsaWNrID0gYXN5bmMgKCk9PntcclxuICAgICAgICAvLyAgQ3JlYXRlIFdhbGxldENvbm5lY3QgUHJvdmlkZXJcclxuICAgICAgICB3Y19wcm92aWRlciA9IG5ldyBXYWxsZXRDb25uZWN0UHJvdmlkZXIoe1xyXG4gICAgICAgICAgICAvL2luZnVyYUlkOiBcIjI3ZTQ4NGRjZDllM2VmY2ZkMjVhODNhNzg3NzdjZGYxXCIsIC8vIFJlcXVpcmVkXHJcbiAgICAgICAgICAgIHJwYzoge1xyXG4gICAgICAgICAgICAgICAgNTY6IFwiaHR0cHM6Ly9ic2MtZGF0YXNlZWQuYmluYW5jZS5vcmcvXCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGNoYWluSWQ6IDU2XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBhY2NvdW50cyBjaGFuZ2VcclxuICAgICAgICB3Y19wcm92aWRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAoYWNjb3VudHMpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYWNjb3VudHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBzZXNzaW9uIGNvbm5lY3Rpb25cclxuICAgICAgICB3Y19wcm92aWRlci5vbihcImNvbm5lY3RcIiwgY29ubmVjdCk7XHJcblxyXG4gICAgICAgIC8vaWYgKGdldF93YWxsZXRfYWRkcmVzcyh3Y19wcm92aWRlcikubGVuZ3RoID49IDQyKSB7XHJcbiAgICAgICAgICAgIC8vYXdhaXQgY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB3Y19wcm92aWRlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgLy99XHJcblxyXG4gICAgICAgICAgICAvLyAgRW5hYmxlIHNlc3Npb24gKHRyaWdnZXJzIFFSIENvZGUgbW9kYWwpXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB3Y19wcm92aWRlci5lbmFibGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yID09IFwiRXJyb3I6IFVzZXIgY2xvc2VkIG1vZGFsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcl9tc2coXCJVc2VyIGNsb3NlZCB0aGUgd2luZG93IHRvIGNvbm5lY3QgdmlhIFdhbGxldENvbm5lY3QuIFBsZWFzZSBsb2dpbiB0byB1c2UgTWV0YW1vbiBNYW5hZ2VyLlwiLCBcImRhbmdlclwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfTtcclxufSk7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0ICgpIHtcclxuICAgIGNvbnN0IHdhbGxldF9hZGRyZXNzID0gZ2V0X3dhbGxldF9hZGRyZXNzKHdjX3Byb3ZpZGVyKTtcclxuICAgIGNvbnN0IG1zZyA9IGdlblJhbmRvbUxvZ2luTXNnKCk7XHJcblxyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2NfcHJvdmlkZXIuc2VuZChcclxuICAgICAgICAncGVyc29uYWxfc2lnbicsXHJcbiAgICAgICAgWyBldGhlcnMudXRpbHMuaGV4bGlmeShldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMobXNnKSksIHdhbGxldF9hZGRyZXNzLnRvTG93ZXJDYXNlKCkgXVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhzaWduYXR1cmUpO1xyXG5cclxuICAgIGF3YWl0IGhhbmRsZV9hdXRoKHdhbGxldF9hZGRyZXNzLCBtc2csIHNpZ25hdHVyZSk7XHJcblxyXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIi9pbmRleFwiO1xyXG5cclxuICAgIC8vYXdhaXQgbG9naW4od2FsbGV0X2FkZHJlc3MsIHdjX3Byb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgLypcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKHdjX3Byb3ZpZGVyKTtcclxuICAgIGNvbnN0IHNpZ25lciA9IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbmVyLnNpZ25NZXNzYWdlKFwiVGVzdFwiKTtcclxuICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xyXG5cclxuICAgIGNvbnN0IGFkZHJlc3MyID0gd2NfcHJvdmlkZXIud2MuYWNjb3VudHNbMF07XHJcblxyXG4gICAgbGV0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCB3Y19wcm92aWRlci5zZW5kKFxyXG4gICAgICAgICdwZXJzb25hbF9zaWduJyxcclxuICAgICAgICBbIGV0aGVycy51dGlscy5oZXhsaWZ5KGV0aGVycy51dGlscy50b1V0ZjhCeXRlcyhcIlRlc3RcIikpLCBhZGRyZXNzMi50b0xvd2VyQ2FzZSgpIF1cclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgd2ViMyA9IG5ldyBXZWIzKHByb3ZpZGVyKTtcclxuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgd2ViMy5ldGguZ2V0QWNjb3VudHMoKTtcclxuICAgICovXHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRfd2FsbGV0X2FkZHJlc3Mod2NfcHJvdmlkZXIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHdjX3Byb3ZpZGVyLndjLmFjY291bnRzWzBdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxufTsiLCJpbXBvcnQgeyBlcnJvcl9tc2cgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xyXG5cclxuZnVuY3Rpb24gc2hvd1ByaXZhY3lUb2FzdChzaG93KSB7XHJcbiAgICB2YXIgdG9hc3RFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dkcHJUb2FzdCcpO1xyXG4gICAgaWYgKHRvYXN0RWxlbWVudCkge1xyXG4gICAgICAgIHZhciB0b2FzdCA9IG5ldyBib290c3RyYXAuVG9hc3QodG9hc3RFbGVtZW50KTtcclxuICAgICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgICAgICB0b2FzdC5zaG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0b2FzdC5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbi8vIEV2ZW50IExpc3RlbmVyXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBpbml0Q29uc2VudCk7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBpbml0Q29uc2VudCAoKSB7XHJcbiAgICBpZiAoY29uc2VudFJlcXVpcmVkKCkpIHtcclxuICAgICAgICBzaG93UHJpdmFjeVRvYXN0KHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXdhaXQgc2VuZENvbnNlbnQoXCJOT1RfUkVRVUlSRURcIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgbm90QWdyZWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJpdmFjeS1ub3QtYWdyZWUnKTtcclxuaWYgKG5vdEFncmVlKVxyXG4gICAgbm90QWdyZWUub25jbGljayA9IG5vdEFjY2VwdEdEUFI7XHJcbnZhciBhZ3JlZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcml2YWN5LWFncmVlJyk7XHJcbmlmIChhZ3JlZSlcclxuICAgIGFncmVlLm9uY2xpY2sgPSBhY2NlcHRHRFBSO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gbm90QWNjZXB0R0RQUiAoKSB7XHJcbiAgICBzaG93UHJpdmFjeVRvYXN0KGZhbHNlKTtcclxuICAgIGVycm9yX21zZyhcIllvdSBuZWVkIHRvIGFjY2VwdCB0byBwbGFjaW5nIGNvb2tpZXMgdG8gdXNlIHRoaXMgd2Vic2l0ZS4gRnVuY3Rpb25hbGl0eSB3aWxsIGJlIHJlc3RyaWN0ZWQuXCIsIFwiZGFuZ2VyXCIpO1xyXG4gICAgYXdhaXQgc2VuZENvbnNlbnQoZmFsc2UpO1xyXG59O1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gYWNjZXB0R0RQUiAoKSB7XHJcbiAgICBhd2FpdCBzZW5kQ29uc2VudCh0cnVlKTtcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRDb25zZW50KGNvbnNlbnQpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgbWV0aG9kOiAncG9zdCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcImNvbnNlbnRcIjogY29uc2VudH0pXHJcbiAgICB9O1xyXG4gICAgYXdhaXQgZmV0Y2goJy9jb25zZW50Jywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb25zZW50IHRvIHNldHRpbmcgY29va2llcyBhY2NvcmRpbmcgdG8gdGVoIEdEUFIgaXMgcmVxdWlyZWQuXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgYSB1c2VyIGlzIGxpa2VseSBsaXZpbmcgaW4gRVVcclxuICovXHJcbmZ1bmN0aW9uIGNvbnNlbnRSZXF1aXJlZCgpIHtcclxuICAgIGxldCB0eiA9IFwiXCI7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHR6ID0gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoICh0eikge1xyXG4gICAgICBjYXNlICdFdXJvcGUvVmllbm5hJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0JydXNzZWxzJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1NvZmlhJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1phZ3JlYic6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0FzaWEvRmFtYWd1c3RhJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnQXNpYS9OaWNvc2lhJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1ByYWd1ZSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9Db3BlbmhhZ2VuJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1RhbGxpbm4nOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvSGVsc2lua2knOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvUGFyaXMnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvQmVybGluJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0J1c2luZ2VuJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0F0aGVucyc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9CdWRhcGVzdCc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9EdWJsaW4nOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvUm9tZSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9SaWdhJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL1ZpbG5pdXMnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvTHV4ZW1ib3VyZyc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9NYWx0YSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9BbXN0ZXJkYW0nOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvV2Fyc2F3JzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnQXRsYW50aWMvQXpvcmVzJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnQXRsYW50aWMvTWFkZWlyYSc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9MaXNib24nOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvQnVjaGFyZXN0JzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL0JyYXRpc2xhdmEnOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlICdFdXJvcGUvTGp1YmxqYW5hJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnQWZyaWNhL0NldXRhJzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnQXRsYW50aWMvQ2FuYXJ5JzpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgY2FzZSAnRXVyb3BlL01hZHJpZCc6XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIGNhc2UgJ0V1cm9wZS9TdG9ja2hvbG0nOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=